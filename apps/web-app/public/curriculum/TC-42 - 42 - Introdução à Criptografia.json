{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:39:31.581Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - TC-42",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 229
    },
    "areas": [
      {
        "id": "10",
        "name": "Ciência da Computação",
        "description": "Área dedicada ao estudo de fundamentos computacionais, algoritmos e segurança da informação.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Introdução à Criptografia",
            "description": "Algoritmos Probabilísticos. Criptosistemas: com chave simétrica e chave pública. Criptoanálise básica. Protocolos Criptográficos. Bibliografia: MENEZES, A. J. Handbook of applied cryptography. Boca Raton: CRC Press, 1996. (Discrete mathematics and its applications). PAAR, C.; PELZL, J. Understanding cryptography: a textbook for students and practitioners. Berlin: Springer, 2010. SCHNEIER, B. Applied cryptography: protocols, algorithms and source code in C. New York: Wiley, 2015.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Algoritmos Probabilísticos",
                "description": "Introdução aos algoritmos criptográficos que incorporam elementos probabilísticos para maior segurança e eficiência.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição de Algoritmos Probabilísticos",
                    "description": "Conceito de algoritmos criptográficos que incorporam aleatoriedade para gerar saídas variáveis e aumentar a segurança.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1.1",
                        "name": "Algoritmo Determinístico versus Probabilístico",
                        "description": "Compreensão da distinção fundamental entre algoritmos que produzem sempre a mesma saída para a mesma entrada (determinísticos) e aqueles que incorporam aleatoriedade, gerando saídas variáveis (probabilísticos), essencial para criptografia moderna.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1.1",
                            "name": "Definir algoritmo determinístico",
                            "description": "Explicar que um algoritmo determinístico produz a mesma saída para a mesma entrada fixa, sem uso de aleatoriedade, com exemplos simples como funções hash determinísticas (ex: SHA-256).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de um algoritmo",
                                  "subSteps": [
                                    "Leia a definição padrão de algoritmo: uma sequência finita de instruções bem definidas para resolver um problema.",
                                    "Identifique propriedades essenciais: finitude, definitude, efetividade e entrada/saída.",
                                    "Anote exemplos cotidianos, como receita de bolo ou instruções de navegação GPS.",
                                    "Pesquise fontes confiáveis como Wikipedia ou livros de introdução à programação.",
                                    "Resuma em suas próprias palavras."
                                  ],
                                  "verification": "Escreva uma definição de algoritmo em uma frase e liste 3 propriedades chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Acesso à internet para pesquisa",
                                    "Livro ou site sobre algoritmos básicos"
                                  ],
                                  "tips": "Use analogias do dia a dia para fixar o conceito; evite pular para exemplos avançados.",
                                  "learningObjective": "Definir corretamente o que é um algoritmo e suas propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com programa de computador",
                                    "Ignorar a finitude (algoritmo deve terminar)",
                                    "Pensar que algoritmos não precisam de entrada/saída claras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o conceito de determinismo em algoritmos",
                                  "subSteps": [
                                    "Defina determinismo: mesmo input sempre produz o mesmo output, sem variação.",
                                    "Estude a ausência de aleatoriedade ou estado não controlado.",
                                    "Compare com funções matemáticas puras (ex: f(x) = x² sempre dá o mesmo para x=2).",
                                    "Discuta por que determinismo é crucial em computação confiável.",
                                    "Crie um fluxograma simples de um algoritmo determinístico básico."
                                  ],
                                  "verification": "Desenhe um fluxograma de uma função simples como 'somar dois números' e confirme que é determinístico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para fluxograma",
                                    "Editor de texto ou ferramenta online como draw.io"
                                  ],
                                  "tips": "Teste mentalmente: 'Se eu rodar 10 vezes com mesmos inputs, sai igual?'",
                                  "learningObjective": "Explicar o que torna um algoritmo determinístico e por quê isso importa.",
                                  "commonMistakes": [
                                    "Confundir com eficiência",
                                    "Achar que loops infinitos são determinísticos",
                                    "Ignorar dependência de estado externo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar algoritmo determinístico de probabilístico",
                                  "subSteps": [
                                    "Defina algoritmo probabilístico: usa aleatoriedade, output pode variar para mesmo input.",
                                    "Compare: determinístico (SHA-256) vs probabilístico (gerador de números aleatórios).",
                                    "Liste vantagens do determinístico: previsibilidade, reprodutibilidade, verificação fácil.",
                                    "Estude contexto em criptografia: determinísticos para hashes, probabilísticos para chaves.",
                                    "Crie uma tabela comparativa com 3 colunas: Característica, Determinístico, Probabilístico."
                                  ],
                                  "verification": "Preencha e explique uma tabela comparativa para um colega ou em voz alta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Artigos sobre criptografia básica"
                                  ],
                                  "tips": "Use exemplos concretos: lançar moeda (probabilístico) vs calcular 2+2 (determinístico).",
                                  "learningObjective": "Distinguir claramente algoritmos determinísticos de probabilísticos com exemplos.",
                                  "commonMistakes": [
                                    "Achar que todo algoritmo criptográfico é probabilístico",
                                    "Confundir não-determinismo com paralelismo",
                                    "Subestimar impacto da aleatoriedade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar com exemplo prático: Função hash SHA-256",
                                  "subSteps": [
                                    "Instale biblioteca hashlib em Python (ou use online REPL).",
                                    "Escreva código: def hash_deterministic(input_str): return hashlib.sha256(input_str.encode()).hexdigest()",
                                    "Teste com mesmo input múltiplas vezes: confirme output idêntico.",
                                    "Teste inputs diferentes: observe outputs únicos mas determinísticos.",
                                    "Explique por que SHA-256 é determinístico e seu uso em criptografia."
                                  ],
                                  "verification": "Execute o código 3 vezes com mesmo input e capture screenshots dos outputs iguais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python instalado ou repl.it",
                                    "Documentação hashlib"
                                  ],
                                  "tips": "Sempre encode strings para bytes; teste edge cases como strings vazias.",
                                  "learningObjective": "Implementar e verificar um algoritmo determinístico real como SHA-256.",
                                  "commonMistakes": [
                                    "Esquecer .encode()",
                                    "Usar random em vez de hash",
                                    "Não testar múltiplas execuções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, crie uma função def verificar_senha(senha): return hashlib.sha256(senha.encode()).hexdigest() == 'hash_armazenado'. Teste com 'minha_senha123' três vezes: sempre produz 'e99a18c428cb38d5f260853678922e03d0cf459f40d20b20e0f3a4e1b0e0a4e6' (exemplo). Isso demonstra determinismo: mesma senha sempre gera mesmo hash, ideal para autenticação segura sem armazenar senhas em texto plano.",
                              "finalVerifications": [
                                "Explicar em 1 minuto o que é algoritmo determinístico sem consultar notas.",
                                "Dar 2 exemplos determinísticos e 1 probabilístico corretamente.",
                                "Executar código SHA-256 e confirmar outputs idênticos para inputs iguais.",
                                "Preencher tabela comparativa sem erros.",
                                "Resumir vantagens em criptografia.",
                                "Identificar se um dado algoritmo (ex: sort) é determinístico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (80% das propriedades corretas).",
                                "Capacidade de diferenciar de probabilístico (exemplos relevantes).",
                                "Implementação correta do exemplo prático (código roda sem erros).",
                                "Explicação clara e concisa (sem jargões desnecessários).",
                                "Uso de verificações e testes práticos.",
                                "Conexões com contexto de criptografia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções determinísticas e propriedades de mapeamento injetivo/sobretivo.",
                                "Física: Leis newtonianas determinísticas vs mecânica quântica probabilística.",
                                "Filosofia: Debate sobre determinismo vs livre arbítrio.",
                                "Engenharia de Software: Importância de testes reprodutíveis."
                              ],
                              "realWorldApplication": "Em sistemas de segurança digital, funções hash determinísticas como SHA-256 verificam integridade de arquivos (downloads), armazenam senhas de forma segura (bancos, apps) e assinaturas digitais, garantindo que pequenas mudanças no input alterem drasticamente o output, prevenindo fraudes sem revelar dados originais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.1.2",
                            "name": "Definir algoritmo probabilístico",
                            "description": "Descrever um algoritmo probabilístico como aquele que usa uma fonte de aleatoriedade para produzir saídas diferentes em execuções idênticas, referenciando definições de Menezes (1996) e Paar & Pelzl (2010).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceito de Algoritmo Determinístico",
                                  "subSteps": [
                                    "Leia a definição de algoritmo determinístico: produz sempre a mesma saída para a mesma entrada.",
                                    "Analise exemplos como soma de números ou ordenação bubble sort.",
                                    "Identifique características chave: previsibilidade e ausência de aleatoriedade.",
                                    "Anote diferenças iniciais com algoritmos não-determinísticos.",
                                    "Crie um fluxograma simples de um algoritmo determinístico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as características de um algoritmo determinístico com um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Handbook of Applied Cryptography' de Menezes (1996), capítulo relevante",
                                    "Papel e caneta para fluxograma",
                                    "Acesso online a definições básicas de algoritmos"
                                  ],
                                  "tips": "Use exemplos cotidianos como uma receita de bolo para ilustrar previsibilidade.",
                                  "learningObjective": "Compreender a base determinística para contrastar com probabilísticos.",
                                  "commonMistakes": [
                                    "Confundir determinismo com eficiência computacional",
                                    "Ignorar que entradas idênticas geram saídas idênticas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Fonte de Aleatoriedade",
                                  "subSteps": [
                                    "Estude o conceito de fonte de aleatoriedade (randomness source) em computação.",
                                    "Diferencie aleatoriedade verdadeira de pseudo-aleatoriedade.",
                                    "Explore fontes como /dev/random em Unix ou geradores hardware.",
                                    "Simule uma fonte simples lançando uma moeda virtual 10 vezes.",
                                    "Registre como a aleatoriedade afeta previsibilidade."
                                  ],
                                  "verification": "Gere uma sequência pseudo-aleatória e descreva por que ela difere em execuções repetidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Understanding Cryptography' de Paar & Pelzl (2010), seção sobre randomness",
                                    "Python ou ferramenta online para random (ex: random.org)",
                                    "Calculadora ou simulador de moedas"
                                  ],
                                  "tips": "Teste múltiplas execuções para observar variação nas saídas.",
                                  "learningObjective": "Identificar e simular fontes de aleatoriedade usadas em algoritmos probabilísticos.",
                                  "commonMistakes": [
                                    "Achar que todo random é verdadeiramente aleatório",
                                    "Não repetir execuções para verificar variação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Algoritmo Probabilístico com Referências",
                                  "subSteps": [
                                    "Leia definições exatas de Menezes (1996): algoritmo que usa aleatoriedade para saídas variadas em entradas idênticas.",
                                    "Consulte Paar & Pelzl (2010) para exemplos em criptografia.",
                                    "Escreva a definição formal: 'Um algoritmo probabilístico incorpora uma fonte de bits aleatórios em seu procedimento.'",
                                    "Compare com definição de algoritmo determinístico.",
                                    "Anote citações precisas das fontes."
                                  ],
                                  "verification": "Redija uma definição precisa citando as referências e explique em 1 parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cópias ou PDFs dos livros citados",
                                    "Bloco de notas digital",
                                    "Dicionário de termos criptográficos"
                                  ],
                                  "tips": "Use aspas para citações diretas e parafraseie para fixar o conceito.",
                                  "learningObjective": "Formular definição precisa ancorada em literatura padrão.",
                                  "commonMistakes": [
                                    "Omitir referência a aleatoriedade como fonte interna",
                                    "Confundir com algoritmos heurísticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Determinístico vs Probabilístico",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para determinístico e probabilístico (previsibilidade, saídas, usos).",
                                    "Desenvolva pseudocódigo simples para cada: ex. determinístico (soma), probabilístico (coin flip para decisão).",
                                    "Execute simulações e registre variações.",
                                    "Discuta vantagens em criptografia (ex. chaves aleatórias).",
                                    "Resuma diferenças em bullet points."
                                  ],
                                  "verification": "Apresente tabela e pseudocódigos executados mostrando saídas diferentes no probabilístico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para tabela/pseudocódigo",
                                    "Interpretador Python para testes",
                                    "Referências dos steps anteriores"
                                  ],
                                  "tips": "Use loops para múltiplas execuções e capture saídas.",
                                  "learningObjective": "Diferenciar claramente os dois tipos e suas implicações.",
                                  "commonMistakes": [
                                    "Achar probabilístico 'errado' por não ser previsível",
                                    "Ignorar contexto criptográfico"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python um algoritmo determinístico (função soma fixa) e um probabilístico (gerar chave RSA com random seed, executando 5 vezes para mostrar chaves diferentes), citando Menezes para justificativa.",
                              "finalVerifications": [
                                "Define corretamente algoritmo probabilístico com menção a aleatoriedade e saídas variáveis.",
                                "Cita precisamente Menezes (1996) e Paar & Pelzl (2010).",
                                "Diferencia de determinístico com exemplos concretos.",
                                "Explica papel em criptografia.",
                                "Simula execução mostrando variação.",
                                "Resume vantagens probabilísticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e citações (30%)",
                                "Profundidade na comparação determinístico vs probabilístico (25%)",
                                "Qualidade de exemplos e simulações (20%)",
                                "Clareza na explicação escrita/oral (15%)",
                                "Uso correto de terminologia técnica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e processos estocásticos.",
                                "Física: Mecânica Quântica como fonte de aleatoriedade verdadeira.",
                                "Estatística: Análise de distribuições em saídas aleatórias.",
                                "Filosofia: Debate sobre determinismo vs indeterminismo."
                              ],
                              "realWorldApplication": "Em criptografia, algoritmos probabilísticos geram chaves únicas (ex. Diffie-Hellman) ou assinaturas digitais (RSA com padding aleatório), garantindo segurança contra ataques de repetição."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.1.3",
                            "name": "Comparar determinístico e probabilístico",
                            "description": "Comparar as propriedades de previsibilidade e reprodutibilidade, destacando por que os probabilísticos são preferidos em criptografia para evitar padrões exploráveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e exemplificar algoritmos determinísticos",
                                  "subSteps": [
                                    "Ler a definição formal de algoritmo determinístico: mesma entrada sempre produz a mesma saída.",
                                    "Analisar exemplo simples: função f(x) = x * 2, onde f(3) sempre retorna 6.",
                                    "Discutir propriedades chave: previsibilidade total e reprodutibilidade perfeita.",
                                    "Criar um pseudocódigo determinístico para multiplicação de números.",
                                    "Testar o algoritmo com múltiplas entradas iguais para confirmar consistência."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a definição e fornecer um exemplo correto sem hesitação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou IDE simples",
                                    "Acesso a documentação online sobre algoritmos"
                                  ],
                                  "tips": "Use analogias cotidianas, como uma máquina de vending que sempre dá o mesmo refrigerante para a mesma moeda.",
                                  "learningObjective": "Compreender e exemplificar as características fundamentais de um algoritmo determinístico.",
                                  "commonMistakes": "Confundir determinístico com constante; ignorar que depende apenas da entrada, não de estado externo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e exemplificar algoritmos probabilísticos",
                                  "subSteps": [
                                    "Ler a definição: algoritmo que usa fontes de aleatoriedade (ex: gerador de números randômicos) para produzir saídas variáveis para a mesma entrada.",
                                    "Analisar exemplo: função que embaralha uma lista com seed randômico, gerando ordem diferente a cada execução.",
                                    "Discutir propriedades: saída probabilística, mas com garantias estatísticas (ex: probabilidade de colisão baixa).",
                                    "Implementar pseudocódigo probabilístico para sorteio de itens.",
                                    "Executar o algoritmo várias vezes com a mesma entrada e registrar variações."
                                  ],
                                  "verification": "Demonstrar com exemplo prático que a saída varia, mas atende a critérios probabilísticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Computador com Python ou JavaScript",
                                    "Biblioteca randômica (ex: random em Python)",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Sempre inicialize com sementes diferentes para simular aleatoriedade verdadeira.",
                                  "learningObjective": "Identificar e exemplificar o papel da aleatoriedade em algoritmos probabilísticos.",
                                  "commonMistakes": "Achar que probabilístico é 'aleatório puro' sem garantias; usar geradores pseudo-randômicos como verdadeiramente randômicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar propriedades de previsibilidade e reprodutibilidade",
                                  "subSteps": [
                                    "Listar tabela comparativa: determinístico (100% previsível, sempre reprodutível) vs probabilístico (previsível probabilisticamente, não reprodutível).",
                                    "Analisar impacto da previsibilidade: determinístico permite ataques baseados em padrões conhecidos.",
                                    "Discutir reprodutibilidade: útil em testes determinísticos, mas risco em cenários adversários.",
                                    "Criar diagrama Venn destacando diferenças e semelhanças (ex: ambos eficientes computacionalmente).",
                                    "Simular cenários: prever saída determinística vs estimar probabilidades em probabilístico."
                                  ],
                                  "verification": "Apresentar tabela ou diagrama comparativo preciso e justificar cada propriedade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (ex: Draw.io ou papel)",
                                    "Planilha para tabela comparativa",
                                    "Exemplos de código dos steps anteriores"
                                  ],
                                  "tips": "Foque em métricas quantitativas, como probabilidade de saída idêntica (1 em det., <1 em prob.).",
                                  "learningObjective": "Comparar quantitativa e qualitativamente as propriedades chave dos dois tipos de algoritmos.",
                                  "commonMistakes": "Ignorar nuances probabilísticas; equiparar 'não reprodutível' a 'imprevisível completamente'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar preferência por probabilísticos em criptografia",
                                  "subSteps": [
                                    "Explicar risco de padrões em determinísticos: mesma plaintext gera mesmo ciphertext, facilitando ataques de texto plano conhecido.",
                                    "Destacar vantagens probabilísticos: IV (Initialization Vector) randômico mascara padrões, tornando ataques exploráveis ineficazes.",
                                    "Estudar exemplos reais: modo ECB (determinístico, inseguro) vs CBC (probabilístico, seguro).",
                                    "Simular ataque simples em determinístico e mostrar falha em probabilístico.",
                                    "Concluir com cenários onde determinísticos ainda são usados (ex: assinaturas digitais)."
                                  ],
                                  "verification": "Explicar com exemplo por que probabilísticos evitam padrões exploráveis em criptografia.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca criptográfica (ex: cryptography em Python)",
                                    "Documentação de modos de operação AES",
                                    "Vídeos tutoriais sobre ataques ECB"
                                  ],
                                  "tips": "Teste com imagens ou textos repetidos para visualizar padrões em ECB vs CBC.",
                                  "learningObjective": "Justificar o uso preferencial de algoritmos probabilísticos em contextos de segurança como criptografia.",
                                  "commonMistakes": "Generalizar que todos determinísticos são inseguros; ignorar usos híbridos em cripto moderna."
                                }
                              ],
                              "practicalExample": "Encripte a mensagem 'senha123' usando AES-ECB (determinístico): sempre gera o mesmo ciphertext 'abc123def'. Ataque fácil com dicionário. Agora com AES-CBC + IV randômico (probabilístico): gera 'xyz789uvw' na primeira vez e 'pqr456stu' na segunda, frustrando ataques por padrão.",
                              "finalVerifications": [
                                "Explicar diferenças em previsibilidade e reprodutibilidade sem erros.",
                                "Identificar por que padrões em determinísticos são exploráveis em cripto.",
                                "Fornecer exemplo prático de ataque falhando em probabilístico.",
                                "Listar 3 vantagens de probabilísticos em segurança.",
                                "Criar tabela comparativa completa e precisa.",
                                "Simular código que demonstra variação em probabilístico."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de ambos os tipos.",
                                "Profundidade da comparação: cobertura de previsibilidade, reprodutibilidade e impactos.",
                                "Relevância criptográfica: justificativa clara para preferência probabilística.",
                                "Uso de exemplos: concretos, testáveis e ilustrativos.",
                                "Clareza na comunicação: tabelas/diagramas legíveis e explicações concisas.",
                                "Compreensão de riscos: identificação correta de ataques baseados em padrões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de probabilidade e distribuições estatísticas.",
                                "Estatística: Análise de variância em saídas probabilísticas.",
                                "Física: Analogia com fenômenos quânticos aleatórios vs determinísticos clássicos.",
                                "Segurança da Informação: Aplicações em protocolos de rede (TLS/SSL)."
                              ],
                              "realWorldApplication": "Em protocolos como HTTPS/TLS, cifras probabilísticas com IV randômico (ex: AES-GCM) previnem ataques de replay e padrões, protegendo comunicações bancárias e e-mails contra eavesdroppers que explorariam determinísticos para quebrar sessões."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.1.2",
                        "name": "Incorporação de Aleatoriedade",
                        "description": "Exploração de como a aleatoriedade é integrada aos algoritmos criptográficos probabilísticos para gerar chaves, nonces ou padding, aumentando a resistência a ataques.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.2.1",
                            "name": "Identificar fontes de aleatoriedade",
                            "description": "Reconhecer fontes como geradores de números pseudoaleatórios (PRNG) ou hardware RNG, e sua importância em contextos criptográficos conforme Schneier (2015).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Aleatoriedade em Computação",
                                  "subSteps": [
                                    "Defina aleatoriedade determinística vs. não-determinística em contextos computacionais.",
                                    "Explique a diferença entre números aleatórios verdadeiros e pseudoaleatórios.",
                                    "Discuta por que a aleatoriedade é essencial em algoritmos probabilísticos.",
                                    "Leia trechos introdutórios de Schneier (2015) sobre entropia e aleatoriedade.",
                                    "Anote exemplos cotidianos de eventos aleatórios (ex.: lançamento de moeda)."
                                  ],
                                  "verification": "Resuma em 3-5 frases os conceitos chave e compartilhe com um colega para feedback.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Applied Cryptography' de Schneier (2015) ou resumo online",
                                    "Notebook para anotações",
                                    "Vídeo introdutório sobre entropia (Khan Academy)"
                                  ],
                                  "tips": "Use analogias físicas como dados ou moedas para visualizar conceitos abstratos.",
                                  "learningObjective": "Distinguir tipos básicos de aleatoriedade e sua relevância em criptografia.",
                                  "commonMistakes": [
                                    "Confundir aleatoriedade com imprevisibilidade simples",
                                    "Ignorar o papel da entropia como medida quantitativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Geradores de Números Pseudoaleatórios (PRNG)",
                                  "subSteps": [
                                    "Estude algoritmos comuns de PRNG como Linear Congruential Generator (LCG) e Mersenne Twister.",
                                    "Implemente um PRNG simples em Python usando random.seed().",
                                    "Analise a semente (seed) e como ela torna o PRNG determinístico.",
                                    "Teste previsibilidade gerando sequências com a mesma seed.",
                                    "Compare qualidade de PRNGs usando testes estatísticos básicos (ex.: dieharder)."
                                  ],
                                  "verification": "Execute código PRNG e demonstre que sequências se repetem com a mesma seed.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Documentação Python random module",
                                    "Ferramenta online de testes de aleatoriedade como NIST STS"
                                  ],
                                  "tips": "Sempre inicialize com seeds diferentes para simular aleatoriedade em testes.",
                                  "learningObjective": "Identificar características e limitações de PRNGs como fontes de aleatoriedade.",
                                  "commonMistakes": [
                                    "Achar que PRNGs são 'verdadeiramente' aleatórios",
                                    "Usar seeds previsíveis como timestamp atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Geradores de Números Aleatórios Verdadeiros (Hardware RNG)",
                                  "subSteps": [
                                    "Descreva fontes de hardware RNG: ruído térmico, decaimento radioativo, eventos quânticos.",
                                    "Pesquise dispositivos como Intel RdRand ou LavaRand (Cloudflare).",
                                    "Acesse APIs ou bibliotecas para hardware RNG (ex.: /dev/urandom no Linux).",
                                    "Compare entropia coletada de hardware vs. software PRNG.",
                                    "Discuta vulnerabilidades conhecidas em hardware RNG (ex.: Intel RNG backdoor debates)."
                                  ],
                                  "verification": "Colete amostras de /dev/random e /dev/urandom e compare distribuições estatísticas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Linux terminal ou WSL",
                                    "Comando 'ent' para testes de entropia",
                                    "Artigos sobre hardware RNG de Schneier"
                                  ],
                                  "tips": "Use ferramentas como 'rngtest' para validar qualidade de hardware RNG.",
                                  "learningObjective": "Reconhecer fontes hardware-based e sua superioridade em entropia para criptografia.",
                                  "commonMistakes": [
                                    "Subestimar custos e disponibilidade de hardware RNG",
                                    "Confundir /dev/random com PRNG puro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Identificação de Fontes em Contextos Criptográficos",
                                  "subSteps": [
                                    "Analise código criptográfico (ex.: OpenSSL) para identificar uso de PRNG vs. RNG.",
                                    "Explique importância per Schneier: previsibilidade leva a ataques (ex.: Debian OpenSSL bug).",
                                    "Crie fluxograma para escolher fonte de aleatoriedade em apps cripto.",
                                    "Debata trade-offs: velocidade de PRNG vs. segurança de true RNG.",
                                    "Teste cenários: gere chaves com fontes diferentes e avalie segurança."
                                  ],
                                  "verification": "Crie relatório curto identificando fontes em 3 exemplos de código criptográfico.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Código fonte OpenSSL ou bibliotecas crypto Python",
                                    "Artigos Schneier sobre aleatoriedade em crypto"
                                  ],
                                  "tips": "Priorize true RNG para chaves; PRNG seeded com entropia para bulk randomness.",
                                  "learningObjective": "Identificar e justificar fontes de aleatoriedade em aplicações criptográficas.",
                                  "commonMistakes": [
                                    "Usar PRNG sem seed de alta entropia",
                                    "Ignorar mixing de fontes para melhor segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de chat seguro, identifique que o nonce para AES-GCM usa hardware RNG (/dev/urandom) para evitar reutilização previsível, enquanto bulk padding usa PRNG seeded, conforme recomendado por Schneier para equilibrar performance e segurança.",
                              "finalVerifications": [
                                "Liste e diferencie pelo menos 3 fontes de aleatoriedade (PRNG, hardware RNG, etc.).",
                                "Explique com exemplo como uma seed fraca compromete PRNG em criptografia.",
                                "Identifique fonte de aleatoriedade em código fornecido (ex.: Python random vs. secrets module).",
                                "Descreva teste estatístico para validar qualidade de uma fonte.",
                                "Relacione conceitos a Schneier (2015): entropia como métrica chave.",
                                "Crie fluxograma de seleção de fonte para geração de chaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre PRNG e true RNG (80% acurácia).",
                                "Profundidade na explicação de entropia e seeding (incluindo referências a Schneier).",
                                "Capacidade de identificar fontes em código real (mínimo 3 exemplos corretos).",
                                "Análise de trade-offs: segurança vs. performance.",
                                "Criatividade em exemplos práticos e verificações estatísticas.",
                                "Clareza e estrutura no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e testes estatísticos de uniformidade.",
                                "Física: Entropia termodinâmica e fontes quânticas de aleatoriedade.",
                                "Segurança da Informação: Auditoria de bibliotecas crypto como OpenSSL.",
                                "Engenharia de Software: Integração de APIs RNG em aplicações distribuídas.",
                                "Filosofia da Ciência: Determinismo vs. Indeterminismo quântico."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS, identificar e usar hardware RNG para chaves de sessão previne ataques como SWEET32; empresas como Cloudflare usam LavaRand para entropia em escala, garantindo privacidade em bilhões de conexões diárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2.2",
                            "name": "Explicar o papel do nonce",
                            "description": "Descrever o nonce (number used once) como entrada aleatória em algoritmos probabilísticos para garantir unicidade em cifras como modos CBC ou GCM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Básica de Nonce",
                                  "subSteps": [
                                    "Pesquise a definição de 'nonce' como 'number used once'.",
                                    "Compare com chaves criptográficas: nonce é público e descartável após uso único.",
                                    "Leia exemplos em documentações como RFC 5116 para GCM.",
                                    "Anote diferenças entre nonce, IV (Initialization Vector) e salt.",
                                    "Crie um glossário pessoal com 3 sinônimos e 3 contextos de uso."
                                  ],
                                  "verification": "Escreva uma definição de 50 palavras e valide com uma fonte confiável como Wikipedia ou NIST.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-38D",
                                    "Artigo Wikipedia sobre Initialization Vector"
                                  ],
                                  "tips": "Lembre-se: nonce não precisa ser secreto, mas deve ser único por chave.",
                                  "learningObjective": "Definir precisamente o que é um nonce e diferenciá-lo de conceitos semelhantes.",
                                  "commonMistakes": "Confundir nonce com chave secreta ou achar que pode ser reutilizado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Propósito em Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Estude algoritmos determinísticos vs. probabilísticos: o papel da aleatoriedade.",
                                    "Explique como nonce introduz aleatoriedade para evitar padrões em cifras.",
                                    "Simule criptografia sem nonce: observe vazamento de informações.",
                                    "Analise por que unicidade previne ataques como chosen-plaintext.",
                                    "Desenhe um diagrama mostrando fluxo de dados com nonce."
                                  ],
                                  "verification": "Crie um diagrama simples e explique oralmente para si mesmo o fluxo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo Khan Academy sobre Criptografia",
                                    "Ferramenta online como CyberChef para simulações"
                                  ],
                                  "tips": "Pense em nonce como 'semente única' para cada mensagem.",
                                  "learningObjective": "Explicar como nonce garante unicidade e segurança em contextos probabilísticos.",
                                  "commonMistakes": "Achar que aleatoriedade total substitui nonce; nonce é aleatório mas gerenciável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Uso em Cifras Específicas como CBC e GCM",
                                  "subSteps": [
                                    "Estude modo CBC: como IV/nonce inicializa o primeiro bloco.",
                                    "Analise GCM: nonce de 96 bits e seu impacto em autenticação.",
                                    "Compare comprimentos: CBC IV 128 bits vs. GCM nonce 96-104 bits.",
                                    "Implemente um exemplo simples em Python com cryptography library.",
                                    "Teste criptografando duas mensagens iguais com mesmo/nonce diferente."
                                  ],
                                  "verification": "Execute código e confirme que mensagens iguais produzem cifras diferentes com nonce único.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Biblioteca Python cryptography",
                                    "Exemplos em GitHub para AES-GCM"
                                  ],
                                  "tips": "Use nonce incremental para streams, mas gere aleatoriamente para mensagens únicas.",
                                  "learningObjective": "Descrever implementação prática de nonce em CBC e GCM.",
                                  "commonMistakes": "Reutilizar nonce na mesma chave, levando a quebra de confidencialidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Riscos e Melhores Práticas",
                                  "subSteps": [
                                    "Pesquise ataques reais: reutilização de nonce em GCM (ex: ataque de Sweet32).",
                                    "Liste regras: nunca reutilize por chave; tamanho fixo; fonte de alta entropia.",
                                    "Crie checklist para implementação segura.",
                                    "Discuta cenários: nonce em protocolos como TLS 1.3.",
                                    "Avalie trade-offs: overhead vs. segurança."
                                  ],
                                  "verification": "Redija um relatório de 1 página com 5 riscos e mitigações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Blog post sobre Nonce Reuse Attacks",
                                    "RFC 8446 para TLS"
                                  ],
                                  "tips": "Audite código sempre: verifique geração e unicidade de nonces.",
                                  "learningObjective": "Aplicar conhecimentos para evitar erros comuns com nonces.",
                                  "commonMistakes": "Usar contadores sem reset seguro ou fontes fracas de aleatoriedade."
                                }
                              ],
                              "practicalExample": "Ao criptografar duas mensagens idênticas 'Hello World' com AES-GCM usando a mesma chave mas nonces diferentes (ex: 0x01 vs. 0x02), as cifras resultantes serão únicas e indecifráveis sem chave. Reutilizando o mesmo nonce, as cifras se cancelam, revelando o plaintext via XOR.",
                              "finalVerifications": [
                                "Defina nonce corretamente em 1 frase.",
                                "Explique diferença entre nonce em CBC e GCM.",
                                "Identifique 3 consequências de reutilização.",
                                "Simule um exemplo com código ou ferramenta.",
                                "Crie diagrama de fluxo com nonce.",
                                "Liste 3 melhores práticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e contexto probabilístico (30%)",
                                "Compreensão de usos em CBC/GCM com exemplos (25%)",
                                "Identificação correta de riscos e mitigações (20%)",
                                "Qualidade de diagramas/simulações práticas (15%)",
                                "Clareza em explicações e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e entropia.",
                                "Segurança da Informação: Protocolos como TLS/IPsec.",
                                "Programação: Implementação em linguagens como Python/Rust.",
                                "Física: Analogia com chaves quânticas únicas."
                              ],
                              "realWorldApplication": "Em comunicações seguras como HTTPS (TLS 1.3 usa nonces em AEAD), VPNs (WireGuard) e apps de mensagens (Signal), nonces garantem que mensagens repetidas não vazeem padrões, prevenindo ataques em massa."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.1.2.3",
                            "name": "Analisar impacto da aleatoriedade na saída",
                            "description": "Analisar como a aleatoriedade faz com que a mesma plaintext + chave produza cifras diferentes, prevenindo ataques de texto plano conhecido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Criptografia Determinística e Probabilística",
                                  "subSteps": [
                                    "Defina criptografia determinística: mesma plaintext e chave sempre produzem a mesma cifra.",
                                    "Defina criptografia probabilística: incorpora aleatoriedade (ex: IV ou nonce) para produzir cifras diferentes na mesma entrada.",
                                    "Explique o ataque known-plaintext (KPA): atacante conhece plaintext e cifras correspondentes para derivar a chave.",
                                    "Compare exemplos: modo ECB (determinístico) vs CBC (probabilístico com IV).",
                                    "Crie um diagrama ilustrando o fluxo com e sem aleatoriedade."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras diferenciando os dois tipos e o risco do KPA.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre criptografia",
                                    "Diagramas de modos de operação (ECB/CBC)",
                                    "Editor de texto ou ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'impressão digital única' para aleatoriedade.",
                                  "learningObjective": "Diferenciar criptografia determinística de probabilística e identificar vulnerabilidades do KPA.",
                                  "commonMistakes": "Confundir aleatoriedade com mudança na chave; lembrar que chave é fixa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Encriptação Determinística e Observar Padrões",
                                  "subSteps": [
                                    "Implemente um algoritmo simples de XOR determinístico em Python usando uma chave fixa.",
                                    "Encripte a mesma plaintext (ex: 'HELLO') três vezes com a mesma chave.",
                                    "Registre as cifras geradas e observe que são idênticas.",
                                    "Simule um KPA: assuma que o atacante conhece 'HELLO' e as cifras para derivar a chave via XOR reverso.",
                                    "Documente o processo em um notebook Jupyter."
                                  ],
                                  "verification": "Execute o código e confirme que as três cifras são iguais; demonstre derivação da chave no KPA.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python ou Jupyter Notebook",
                                    "Biblioteca cryptography (opcional para XOR básico)",
                                    "Plaintext de teste: 'HELLO', Chave: 'KEY123'"
                                  ],
                                  "tips": "Teste com binário para visualizar padrões: ord(c) ^ ord(k).",
                                  "learningObjective": "Implementar e observar como determinismo facilita ataques KPA.",
                                  "commonMistakes": "Usar funções randômicas acidentalmente; garanta seed fixa ou ausência de rand."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Encriptação Probabilística com Aleatoriedade",
                                  "subSteps": [
                                    "Modifique o código para incluir um IV/nonce aleatório (use secrets.token_bytes(16) em Python).",
                                    "Encripte a mesma plaintext e chave três vezes, gerando IV diferente a cada vez.",
                                    "Registre as cifras e observe variações apesar da mesma entrada.",
                                    "Concatene IV à cifra para decifração e teste decifração correta.",
                                    "Compare com o Step 2 para destacar diferenças nas saídas."
                                  ],
                                  "verification": "Execute o código e confirme cifras diferentes nas três execuções; decifre todas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/Jupyter com import secrets e cryptography.fernet",
                                    "Mesma plaintext/chave do Step 2"
                                  ],
                                  "tips": "IV deve ser único e público; não reuse IV com mesma chave.",
                                  "learningObjective": "Demonstrar como aleatoriedade mascara padrões na cifra.",
                                  "commonMistakes": "Reutilizar o mesmo IV; sempre gere novo com cripto-aleatório."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto da Aleatoriedade na Prevenção de Ataques",
                                  "subSteps": [
                                    "Simule KPA na versão probabilística: explique por que o atacante não pode derivar a chave facilmente.",
                                    "Calcule entropia aparente das cifras (use len(cipher) * 8 bits).",
                                    "Discuta trade-offs: maior segurança vs overhead computacional.",
                                    "Crie um relatório comparando saídas e vulnerabilidades.",
                                    "Teste com plaintexts reais (ex: mensagens de chat) para ilustrar."
                                  ],
                                  "verification": "Escreva uma análise de 150 palavras explicando a prevenção do KPA pela aleatoriedade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Códigos dos steps anteriores",
                                    "Ferramenta de cálculo de entropia (opcional: scipy.stats.entropy)"
                                  ],
                                  "tips": "Pense em 'ruído' aleatório como camuflagem contra padrões.",
                                  "learningObjective": "Analisar quantitativamente como aleatoriedade previne KPA.",
                                  "commonMistakes": "Ignorar que IV é transmitido; ele não é segredo, mas essencial para decifração."
                                }
                              ],
                              "practicalExample": "Plaintext: 'HELLO', Chave: 'KEY123'. Determinístico (XOR): sempre 'Mÿÿÿÿÿ'. Probabilístico (AES-CBC com IV rand): 'a1b2c3d4e5f67890abcdef...[diferente a cada vez]'. No KPA, determinístico permite XOR(plaintext, cipher) = chave; probabilístico falha pois IV varia.",
                              "finalVerifications": [
                                "Explicar verbalmente por que mesmas entradas produzem cifras diferentes.",
                                "Demonstrar código rodando 5x com saídas variadas.",
                                "Identificar 2 cenários onde determinismo é inseguro.",
                                "Calcular e comparar 'previsibilidade' das cifras.",
                                "Decifrar cifras probabilísticas corretamente sem vazar chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção determinístico vs probabilístico (80%+ correto).",
                                "Código funcional sem erros, produzindo saídas esperadas.",
                                "Análise clara do impacto no KPA com exemplos concretos.",
                                "Uso correto de primitivas cripto-aleatórias (não math.random).",
                                "Relatório bem estruturado com diagramas e evidências.",
                                "Compreensão de trade-offs (segurança vs performance)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Conceitos de entropia e distribuições uniformes.",
                                "Matemática: Operações bitwise (XOR) e funções injetoras.",
                                "Segurança da Informação: Modelos de ataque (KPA, CPA).",
                                "Programação: Uso de bibliotecas criptográficas seguras."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS, IVs aleatórios em AES-GCM evitam detecção de padrões em tráfego de rede, prevenindo ataques de replay e análise de frequência em comunicações seguras como banking apps ou VPNs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.1.3",
                        "name": "Benefícios para Segurança Criptográfica",
                        "description": "Análise dos ganhos de segurança proporcionados por algoritmos probabilísticos em criptosistemas simétricos e assimétricos, como resistência a criptoanálise.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.3.1",
                            "name": "Relacionar com criptosistemas simétricos",
                            "description": "Exemplificar em cifras simétricas como AES em modo CTR, onde aleatoriedade garante IND-CCA segurança (Menezes, 1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Criptosistemas Simétricos e Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Defina criptosistema simétrico: usa a mesma chave para encriptação e decriptação.",
                                    "Explique algoritmos determinísticos vs. probabilísticos: probabilísticos usam aleatoriedade (nonce/IV).",
                                    "Liste exemplos de cifras simétricas: AES, DES.",
                                    "Descreva modos de operação: ECB (determinístico), CTR (probabilístico).",
                                    "Cite Menezes (1996) sobre benefícios da aleatoriedade em segurança."
                                  ],
                                  "verification": "Resuma em um parágrafo como algoritmos probabilísticos diferem de determinísticos em criptosistemas simétricos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Handbook of Applied Cryptography (Menezes, 1996) - Capítulo 7",
                                    "Notas de aula sobre criptografia",
                                    "Acesso a Wikipedia para modos de operação AES"
                                  ],
                                  "tips": "Use diagramas para visualizar diferenças entre modos determinísticos e probabilísticos.",
                                  "learningObjective": "Compreender a base teórica que permite a relação entre algoritmos probabilísticos e simétricos.",
                                  "commonMistakes": [
                                    "Confundir simétrico com assimétrico",
                                    "Ignorar o papel do IV/nonce como fonte de aleatoriedade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar AES em Modo CTR (Counter Mode)",
                                  "subSteps": [
                                    "Explique CTR: transforma AES em stream cipher usando contador incrementado com nonce aleatório.",
                                    "Descreva estrutura: nonce + contador -> AES -> keystream XOR plaintext.",
                                    "Implemente pseudocódigo simples de encriptação CTR.",
                                    "Gere IV/nonce aleatório e demonstre reutilização de keystream.",
                                    "Compare CTR com CBC para destacar probabilisticidade."
                                  ],
                                  "verification": "Escreva e execute pseudocódigo de AES-CTR com nonce aleatório diferente em duas mensagens idênticas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca Python: cryptography ou pycryptodome",
                                    "Documentação AES-CTR",
                                    "Editor de código como Jupyter Notebook"
                                  ],
                                  "tips": "Sempre gere nonce fresco por mensagem para evitar reutilização.",
                                  "learningObjective": "Dominar o funcionamento técnico do AES-CTR como exemplo probabilístico.",
                                  "commonMistakes": [
                                    "Reutilizar nonce levando a keystream reuse",
                                    "Confundir CTR com OFB/CTR variantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Papel da Aleatoriedade na Segurança IND-CCA",
                                  "subSteps": [
                                    "Defina IND-CCA: segurança contra ataques chosen-ciphertext onde ciphertext é indistinguível.",
                                    "Explique como CTR sem aleatoriedade (nonce fixo) falha em IND-CCA.",
                                    "Mostre prova conceitual: aleatoriedade garante que ciphertexts idênticos plaintexts produzam outputs diferentes.",
                                    "Relacione com teoremas de Menezes: probabilisticidade eleva segurança de IND-CPA para IND-CCA em certos modos.",
                                    "Discuta malleability em CTR e mitigações via autenticação (ex: GCM)."
                                  ],
                                  "verification": "Explique em 200 palavras por que AES-CTR com nonce aleatório atinge IND-CCA.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Menezes (1996) - Seções 7.5-7.6",
                                    "Artigos sobre IND-CCA security",
                                    "Ferramentas de simulação de ataques como CrypTool"
                                  ],
                                  "tips": "Use exemplos matemáticos simples: XOR com keystream randômico preserva IND.",
                                  "learningObjective": "Entender mecanicamente como aleatoriedade confere IND-CCA em simétricos.",
                                  "commonMistakes": [
                                    "Confundir IND-CPA com IND-CCA",
                                    "Subestimar riscos de nonce previsível"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e Relacionar Benefícios Práticos",
                                  "subSteps": [
                                    "Implemente AES-CTR em código real encriptando duas mensagens idênticas com nonces diferentes.",
                                    "Simule ataque sem aleatoriedade (nonce fixo) e observe falha.",
                                    "Discuta benefícios: paralelismo, eficiência em hardware, segurança sem padding.",
                                    "Relacione com contexto maior: algoritmos probabilísticos melhoram simétricos para apps modernas.",
                                    "Crie um relatório resumindo a relação."
                                  ],
                                  "verification": "Demonstre código rodando com/s em nonce aleatório e analise outputs.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pycryptodome",
                                    "Exemplos de código GitHub para AES-CTR",
                                    "Ambiente de teste seguro"
                                  ],
                                  "tips": "Teste em mensagens longas para ver eficiência de CTR.",
                                  "learningObjective": "Aplicar conceitualmente a relação em exemplo acionável.",
                                  "commonMistakes": [
                                    "Não autenticar CTR (use AEAD como GCM)",
                                    "Ignorar side-channel leaks em implementações"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente AES-128-CTR em Python para encriptar 'HELLO WORLD' duas vezes: primeira com nonce=0x01..., segunda com nonce aleatório via os.urandom(12). Observe ciphertexts diferentes apesar de plaintext idêntico, demonstrando IND-CCA via aleatoriedade. Simule ataque reutilizando nonce para recuperar plaintext via XOR.",
                              "finalVerifications": [
                                "Explica corretamente como CTR usa aleatoriedade para IND-CCA.",
                                "Implementa AES-CTR sem reutilizar nonce.",
                                "Identifica falhas em CTR determinístico.",
                                "Cita Menezes (1996) apropriadamente.",
                                "Distingue IND-CCA de outros modelos de segurança.",
                                "Aplica conceito a outros modos simétricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de AES-CTR (90%+ correta).",
                                "Demonstração prática com código funcional.",
                                "Análise clara do papel da aleatoriedade em IND-CCA.",
                                "Uso correto de terminologia criptográfica.",
                                "Relacionamento lógico com benefícios probabilísticos.",
                                "Ausência de erros comuns como nonce reuse."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Informação e Probabilidade (entropia de nonces).",
                                "Segurança da Informação: Modelos de segurança adversariais (IND-CCA).",
                                "Ciência da Computação: Algoritmos e Estruturas de Dados (implementação de streams).",
                                "Física: Hardware para geradores de números aleatórios (TRNGs)."
                              ],
                              "realWorldApplication": "Em protocolos como TLS 1.3 e WireGuard VPNs, AES-CTR com nonce aleatório garante confidencialidade contra ataques adaptativos em comunicações seguras, protegendo dados em trânsito em apps como HTTPS e streaming seguro."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.1.3.2",
                            "name": "Relacionar com criptosistemas de chave pública",
                            "description": "Discutir uso em assinaturas digitais probabilísticas como PSS (Probabilistic Signature Scheme) para evitar forjarias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Criptosistemas de Chave Pública",
                                  "subSteps": [
                                    "Defina criptosistemas de chave pública (PKC), incluindo chaves pública e privada.",
                                    "Explique o processo de assinatura digital: hash da mensagem, assinatura com chave privada, verificação com chave pública.",
                                    "Discuta exemplos clássicos como RSA e sua natureza determinística.",
                                    "Identifique limitações iniciais das assinaturas determinísticas em cenários de forjaria.",
                                    "Compare com criptografia simétrica para contextualizar."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo os componentes de um PKC e o fluxo de assinatura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Slides ou vídeo introdutório sobre PKC (ex: Khan Academy Criptografia)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias como 'cadeado público e chave privada pessoal' para fixar conceitos.",
                                  "learningObjective": "Compreender os pilares de PKC e seu papel em assinaturas digitais.",
                                  "commonMistakes": "Confundir chave pública com simétrica; assumir que todas as assinaturas são probabilísticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Problemas de Assinaturas Digitais Determinísticas",
                                  "subSteps": [
                                    "Estude ataques como forjaria de assinaturas em RSA padding determinístico (ex: Bleichenbacher).",
                                    "Descreva como mensagens semelhantes podem levar a assinaturas previsíveis.",
                                    "Simule um exemplo simples de colisão em hashing determinístico.",
                                    "Discuta vulnerabilidades em esquemas como RSA direto sem padding probabilístico.",
                                    "Liste cenários reais onde forjarias ocorreram devido a determinismo."
                                  ],
                                  "verification": "Identifique e explique pelo menos dois ataques específicos em um relatório curto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigo sobre Bleichenbacher attack (PDF ou wiki)",
                                    "Ferramenta online de simulação RSA (ex: Crypto101)"
                                  ],
                                  "tips": "Foque em 'previsibilidade' como raiz do problema; teste com números pequenos manualmente.",
                                  "learningObjective": "Identificar fraquezas de determinismo em assinaturas para motivar soluções probabilísticas.",
                                  "commonMistakes": "Ignorar o papel do padding; superestimar segurança de hashing sozinho."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Probabilistic Signature Scheme (PSS)",
                                  "subSteps": [
                                    "Descreva a estrutura do PSS: padding probabilístico com random bits e MGF (Mask Generation Function).",
                                    "Compare PSS com OAEP para criptografia, destacando adaptações para assinaturas.",
                                    "Implemente um pseudocódigo simples do processo de assinatura e verificação PSS.",
                                    "Explique como a aleatoriedade é incorporada via nonce.",
                                    "Teste conceitualmente com um exemplo numérico pequeno."
                                  ],
                                  "verification": "Escreva e valide um pseudocódigo PSS que produza assinaturas diferentes para mesma mensagem.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "RFC 8017 (PKCS#1 v2.2) seção PSS",
                                    "Editor de código como Jupyter para pseudocódigo"
                                  ],
                                  "tips": "Visualize o padding como 'ruído aleatório' que quebra previsibilidade.",
                                  "learningObjective": "Dominar o mecanismo técnico do PSS como algoritmo probabilístico.",
                                  "commonMistakes": "Confundir PSS com PS (Plain Signature); esquecer verificação de hash."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar PSS com PKC e Discutir Prevenção de Forjarias",
                                  "subSteps": [
                                    "Integre PSS ao fluxo PKC: assinatura RSA-PSS.",
                                    "Analise como probabilidade reduz espaço de ataque (ex: 2^80 tentativas).",
                                    "Compare métricas de segurança: EUF-CMA (existential unforgeability under chosen message attack).",
                                    "Discuta provas de segurança baseadas em aleatoriedade.",
                                    "Debata trade-offs: overhead computacional vs ganho de segurança."
                                  ],
                                  "verification": "Crie uma tabela comparativa PSS vs determinístico, destacando prevenção de forjarias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela comparativa em Excel/Google Sheets",
                                    "Paper 'PSS: Provably Secure Signature Scheme' resumo"
                                  ],
                                  "tips": "Use gráficos de probabilidade de forjaria para ilustrar benefícios.",
                                  "learningObjective": "Relacionar probabilisticidade do PSS aos benefícios em PKC contra forjarias.",
                                  "commonMistakes": "Subestimar necessidade de random source seguro; ignorar side-channel attacks."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar Conceitos",
                                  "subSteps": [
                                    "Resuma a relação: algoritmos probabilísticos elevam segurança de PKC via PSS.",
                                    "Crie um fluxograma completo de assinatura PSS em PKC.",
                                    "Discuta evoluções como EdDSA (ainda probabilístico em alguns aspectos).",
                                    "Planeje um experimento simples para demonstrar.",
                                    "Reflita sobre implicações para protocolos modernos."
                                  ],
                                  "verification": "Apresente um fluxograma e resumo de 200 palavras relacionando tudo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (ex: Draw.io)",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Conecte de volta ao contexto maior de algoritmos probabilísticos em cripto.",
                                  "learningObjective": "Sintetizar conhecimento para discutir uso de PSS em assinaturas probabilísticas.",
                                  "commonMistakes": "Perder o foco na prevenção de forjarias; generalizar demais."
                                }
                              ],
                              "practicalExample": "Simule assinatura de uma transação blockchain: use OpenSSL para gerar RSA-PSS signature em 'pay 1 BTC to Alice' com nonce aleatório, verificando que re-assinaturas iguais falham probabilisticamente, demonstrando resistência a forjaria.",
                              "finalVerifications": [
                                "Explicar diferença entre assinatura determinística e PSS em termos de padding.",
                                "Desenhar fluxograma correto de RSA-PSS.",
                                "Identificar pelo menos um ataque evitado pelo PSS.",
                                "Calcular overhead aproximado de PSS vs raw RSA.",
                                "Discutir papel da aleatoriedade em provas de segurança.",
                                "Comparar PSS com alternativas como BLS signatures."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (fundamentos PKC/PSS): 0-25%",
                                "Análise de vulnerabilidades e benefícios: 0-25%",
                                "Qualidade de exemplos e diagramas: 0-20%",
                                "Profundidade técnica (pseudocódigo/fluxos): 0-20%",
                                "Síntese e conexões interdisciplinares: 0-10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Funções Geradoras de Máscara (MGF).",
                                "Segurança da Informação: Modelos de Ameaça e Provas de Redução.",
                                "Ciência da Computação: Algoritmos Aleatórios e Complexidade Computacional.",
                                "Engenharia de Software: Implementação Segura de Cripto em Bibliotecas."
                              ],
                              "realWorldApplication": "Em protocolos como TLS 1.3 e Bitcoin/ECDSA-PSS variantes, PSS previne forjarias em certificados SSL e transações blockchain, garantindo integridade contra ataques quânticos parciais e chosen-message scenarios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.1.3.3",
                            "name": "Avaliar contra criptoanálise",
                            "description": "Explicar como saídas variáveis frustram ataques estatísticos e de padrão, com base em Paar & Pelzl (2010).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Ataques Estatísticos e de Padrão em Criptoanálise",
                                  "subSteps": [
                                    "Defina ataques estatísticos: análise de frequências de caracteres ou blocos em cifras determinísticas.",
                                    "Descreva ataques de padrão: identificação de padrões repetitivos em saídas criptográficas previsíveis.",
                                    "Estude exemplos clássicos como análise de frequência em cifra de César ou Monoalphabetic.",
                                    "Compare com cifras modernas determinísticas vulneráveis, como ECB mode sem padding.",
                                    "Registre diferenças entre determinístico e probabilístico em termos de previsibilidade."
                                  ],
                                  "verification": "Crie um diagrama comparando distribuições estatísticas de saídas determinísticas vs. aleatórias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro Paar & Pelzl (2010, Capítulo sobre Criptoanálise), papel e caneta ou ferramenta de diagramação como Draw.io.",
                                  "tips": "Use histogramas para visualizar distribuições; foque em entropia alta como métrica chave.",
                                  "learningObjective": "Identificar vulnerabilidades específicas de algoritmos determinísticos a ataques estatísticos e de padrão.",
                                  "commonMistakes": "Confundir ataques estatísticos com diferenciais; ignorar contexto de chaves conhecidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Algoritmos Probabilísticos e Saídas Variáveis",
                                  "subSteps": [
                                    "Defina algoritmo probabilístico: usa chaves aleatórias ou nonce para gerar saídas diferentes na mesma entrada.",
                                    "Explique geração de saídas variáveis: incorporação de randomness via IV, nonce ou padding randômico.",
                                    "Analise modos de operação como CBC com IV randômico vs. ECB.",
                                    "Calcule entropia: demonstre como randomness aumenta imprevisibilidade estatística.",
                                    "Cite Paar & Pelzl (2010): revise seção sobre benefícios probabilísticos em cifras simétricas."
                                  ],
                                  "verification": "Gere duas criptografias da mesma plaintext com nonce diferente e compare saídas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com pycryptodome, código exemplo de AES-CBC, PDF de Paar & Pelzl (2010).",
                                  "tips": "Sempre use bibliotecas seguras; teste com plaintext repetitivo para destacar variabilidade.",
                                  "learningObjective": "Descrever mecanismos que introduzem variabilidade em saídas criptográficas.",
                                  "commonMistakes": "Reutilizar IV/nonce; assumir que todas as cifras probabilísticas são seguras sem randomness adequada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Frustração de Ataques por Saídas Variáveis",
                                  "subSteps": [
                                    "Explique frustração estatística: cada saída é única, quebrando análise de frequência.",
                                    "Detalhe frustração de padrões: ausência de repetições mesmo com plaintext idêntico.",
                                    "Simule ataque: tente análise de frequência em múltiplas saídas variáveis (deve falhar).",
                                    "Quantifique: calcule chi-quadrado ou teste de adesão para distribuições uniformes.",
                                    "Referencie Paar & Pelzl (2010): extraia citações sobre 'perfect secrecy' via randomness."
                                  ],
                                  "verification": "Execute script simulando ataque estatístico em 100 criptotextos variáveis; confirme falha >95%.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Jupyter Notebook, bibliotecas NumPy/SciPy para testes estatísticos, Paar & Pelzl (2010).",
                                  "tips": "Use seeds diferentes para randomness; compare métricas antes/depois da variabilidade.",
                                  "learningObjective": "Demonstrar matematicamente como variabilidade neutraliza ataques estatísticos e de padrão.",
                                  "commonMistakes": "Ignorar dependência de chaves; superestimar segurança sem provar uniformidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Sintetizar Benefícios Baseados em Referência",
                                  "subSteps": [
                                    "Resuma achados de Paar & Pelzl (2010): ligue a seções sobre probabilidade em criptografia.",
                                    "Crie tabela comparativa: determinístico vs. probabilístico em cenários de ataque.",
                                    "Discuta limitações: variabilidade não previne todos os ataques (e.g., side-channel).",
                                    "Formule avaliação: critérios para julgar robustez contra criptoanálise.",
                                    "Prepare relatório: integre conceitos em parágrafo coeso."
                                  ],
                                  "verification": "Escreva ensaio de 300 palavras explicando frustração, com referências e evidências.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor de texto, Paar & Pelzl (2010), tabela em Excel ou Markdown.",
                                  "tips": "Estruture como: problema > solução > evidência > conclusão.",
                                  "learningObjective": "Sintetizar avaliação crítica de segurança probabilística contra criptoanálise.",
                                  "commonMistakes": "Citar referência sem ler contexto; generalizar para assimétricos."
                                }
                              ],
                              "practicalExample": "Criptografe 'HELLO WORLD' 5 vezes com AES-CBC usando IV randômico diferente cada vez. Tente análise de frequência nos criptotextos: distribuições uniformes frustram detecção de padrões, simulando defesa real em protocolos como HTTPS.",
                              "finalVerifications": [
                                "Explica corretamente como randomness quebra análise de frequência em >80% de casos simulados.",
                                "Identifica padrões em ECB vs. ausência em CBC com IV randômico.",
                                "Cita Paar & Pelzl (2010) com página/seção precisa sobre benefícios probabilísticos.",
                                "Realiza teste estatístico (e.g., chi-quadrado) mostrando uniformidade.",
                                "Discute limitações, como reutilização de nonce.",
                                "Produz diagrama ou tabela comparativa clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 30% (definições corretas de ataques e mecanismos).",
                                "Evidências práticas: 25% (simulações e testes estatísticos válidos).",
                                "Referenciação: 20% (integração fiel de Paar & Pelzl).",
                                "Análise crítica: 15% (frustração explicada matematicamente).",
                                "Clareza e estrutura: 10% (comunicação acionável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e Estatística (distribuições, testes de hipótese).",
                                "Segurança da Informação: Protocolos de rede (TLS/SSL).",
                                "Ciência de Dados: Análise de entropia e machine learning em ataques.",
                                "Física: Teoria da Informação (Shannon entropy)."
                              ],
                              "realWorldApplication": "Em comunicações seguras como WhatsApp ou banking apps, modos probabilísticos como AES-GCM com nonce único previnem ataques de padrão em tráfego repetitivo, garantindo confidencialidade contra eavesdroppers estatísticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Diferenças entre Algoritmos Determinísticos e Probabilísticos",
                    "description": "Comparação entre algoritmos que sempre produzem a mesma saída para a mesma entrada e aqueles que variam devido à aleatoriedade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1.1",
                        "name": "Algoritmos Determinísticos",
                        "description": "Algoritmos que, para uma mesma entrada fixa, sempre produzem exatamente a mesma saída, sem qualquer componente de aleatoriedade, garantindo previsibilidade total no comportamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1.1",
                            "name": "Definir algoritmo determinístico",
                            "description": "Explicar formalmente o conceito de algoritmo determinístico, destacando que a saída é unicamente determinada pela entrada, sem variações, e ilustrar com pseudocódigo simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de um Algoritmo",
                                  "subSteps": [
                                    "Defina algoritmo como uma sequência finita de instruções bem definidas para resolver um problema.",
                                    "Liste propriedades essenciais: finitude, definitude, efetividade e entrada/saída.",
                                    "Discuta o papel de entradas (dados de input) e saídas (resultados de output) em qualquer algoritmo.",
                                    "Examine exemplos simples como receita de bolo para ilustrar estrutura algorítmica."
                                  ],
                                  "verification": "Escreva uma definição de algoritmo com pelo menos 4 propriedades e 2 exemplos cotidianos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Acesso a definições online de algoritmo (Wikipedia ou livro-texto)"
                                  ],
                                  "tips": "Pense em algoritmos como 'receitas' precisas para evitar ambiguidades.",
                                  "learningObjective": "Compreender o conceito básico de algoritmo como base para determinismo.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com programa executável",
                                    "Omitir a propriedade de finitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Determinismo em Processos",
                                  "subSteps": [
                                    "Explique 'determinístico' como um processo onde a saída é unicamente determinada pela entrada, sem variações.",
                                    "Diferencie de processos probabilísticos ou randômicos, que envolvem aleatoriedade.",
                                    "Forneça 3 exemplos cotidianos determinísticos (ex: soma de números) vs não-determinísticos (ex: lançamento de moeda).",
                                    "Relacione com funções matemáticas onde f(x) sempre dá o mesmo resultado para o mesmo x."
                                  ],
                                  "verification": "Liste 3 exemplos determinísticos e 3 não-determinísticos, explicando por quê.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para diagramas de entrada/saída",
                                    "Vídeos curtos sobre determinismo (YouTube: 5 min)"
                                  ],
                                  "tips": "Visualize como uma máquina de vending: mesma moeda, mesmo refrigerante.",
                                  "learningObjective": "Diferenciar determinismo de não-determinismo em contextos gerais.",
                                  "commonMistakes": [
                                    "Confundir determinismo com previsibilidade em sistemas caóticos",
                                    "Ignorar que determinismo requer ausência total de aleatoriedade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição de Algoritmo Determinístico",
                                  "subSteps": [
                                    "Escreva a definição formal: Um algoritmo determinístico produz saída única e previsível para cada entrada específica, sem dependência de estado aleatório.",
                                    "Destaque que para toda entrada x, existe exatamente uma saída f(x).",
                                    "Compare com algoritmos probabilísticos, que podem variar saídas para mesma entrada.",
                                    "Inclua restrições: sem uso de geradores de números randômicos ou condições não-reprodutíveis."
                                  ],
                                  "verification": "Redija a definição formal em suas palavras e valide com um peer ou auto-revisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Modelo de definição formal (impresso ou digital)",
                                    "Ferramenta de texto para formatação"
                                  ],
                                  "tips": "Use notação matemática como f: Input → Output única para clareza.",
                                  "learningObjective": "Articular formalmente o conceito de algoritmo determinístico.",
                                  "commonMistakes": [
                                    "Incluir elementos randômicos na definição",
                                    "Definir vagamente sem menção à unicidade da saída"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Pseudocódigo Simples",
                                  "subSteps": [
                                    "Escolha um problema simples como 'verificar se número é primo'.",
                                    "Escreva pseudocódigo determinístico: INPUT n; FOR i=2 to sqrt(n); IF n%i==0 THEN OUTPUT 'Não primo'; OUTPUT 'Primo'.",
                                    "Simule execução com 2 entradas diferentes (ex: 7 e 8) mostrando saídas únicas.",
                                    "Analise por que o pseudocódigo é determinístico (mesma entrada, mesma execução)."
                                  ],
                                  "verification": "Execute o pseudocódigo manualmente para 3 entradas e confirme saídas consistentes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Calculadora para simulações"
                                  ],
                                  "tips": "Mantenha pseudocódigo simples e sem loops infinitos.",
                                  "learningObjective": "Demonstrar determinismo via pseudocódigo prático.",
                                  "commonMistakes": [
                                    "Introduzir rand() no pseudocódigo",
                                    "Erros lógicos que variam saídas inadvertidamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Consolidar e Comparar com Algoritmos Não-Determinísticos",
                                  "subSteps": [
                                    "Resuma a definição completa de algoritmo determinístico.",
                                    "Crie pseudocódigo probabilístico contrastante (ex: com rand() para amostragem).",
                                    "Discuta vantagens em criptografia: reprodutibilidade para descriptografia.",
                                    "Teste compreensão simulando cenários mistos."
                                  ],
                                  "verification": "Compare seu pseudocódigo determinístico com um probabilístico em tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela comparativa em papel ou Google Docs"
                                  ],
                                  "tips": "Foco em criptografia: determinístico garante mesma chave descriptografa corretamente.",
                                  "learningObjective": "Integrar definição com aplicações contextuais.",
                                  "commonMistakes": [
                                    "Subestimar impacto da aleatoriedade em segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Pseudocódigo para soma determinística: INPUT a, b; OUTPUT a + b. Para a=3, b=4, saída sempre 7, independentemente de execuções.",
                              "finalVerifications": [
                                "Define corretamente algoritmo determinístico com ênfase em saída única por entrada.",
                                "Explica formalmente a ausência de variações ou aleatoriedade.",
                                "Fornece pseudocódigo simples e simula execuções consistentes.",
                                "Distingue claramente de algoritmos probabilísticos com exemplos.",
                                "Relaciona conceito a aplicações em criptografia."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da definição formal (30%).",
                                "Clareza e correção do pseudocódigo exemplo (25%).",
                                "Qualidade da diferenciação com probabilísticos (20%).",
                                "Profundidade de exemplos e simulações (15%).",
                                "Conexão com contexto criptográfico (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções totais e injetoras determinísticas.",
                                "Física: Modelos newtonianos clássicos vs quânticos probabilísticos.",
                                "Lógica: Inferência dedutiva sem não-determinismo.",
                                "Filosofia: Debate determinismo vs livre-arbítrio."
                              ],
                              "realWorldApplication": "Em criptografia simétrica (ex: AES), algoritmos determinísticos garantem que a mesma chave e texto-plano sempre produz o mesmo texto-cifrado, permitindo descriptografia confiável."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.2",
                            "name": "Identificar exemplos em criptografia",
                            "description": "Reconhecer exemplos como o cifrador AES no modo ECB ou cifras de fluxo sem nonce, explicando por que eles são determinísticos e suas implicações em criptosistemas simétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Algoritmos Determinísticos",
                                  "subSteps": [
                                    "Defina algoritmo determinístico: sempre produz a mesma saída para a mesma entrada.",
                                    "Compare com probabilísticos: usam aleatoriedade, produzindo saídas diferentes para mesma entrada.",
                                    "Revise criptosistemas simétricos: usam a mesma chave para cifrar e decifrar.",
                                    "Identifique por que determinismo é problemático em criptografia: revela padrões em mensagens repetidas.",
                                    "Estude definições formais de funções determinísticas em criptografia."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre determinístico e probabilístico, com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre criptografia básica",
                                    "Artigo da Wikipedia sobre funções determinísticas"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar entrada/saída idênticas.",
                                  "learningObjective": "Compreender a definição e implicações fundamentais de algoritmos determinísticos.",
                                  "commonMistakes": "Confundir determinismo com invertibilidade; lembre-se que determinismo é sobre consistência de saída."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar AES no Modo ECB como Exemplo Determinístico",
                                  "subSteps": [
                                    "Descreva AES-ECB: cada bloco de texto plano é cifrado independentemente com a mesma chave.",
                                    "Cifre a mesma mensagem duas vezes com AES-ECB e observe saídas idênticas.",
                                    "Explique por quê: sem IV ou nonce, depende apenas de plaintext e chave.",
                                    "Visualize com imagens: imagem idêntica cifrada em ECB mostra padrões.",
                                    "Compare com modos como CBC que usam IV para não-determinismo."
                                  ],
                                  "verification": "Gere duas cifras idênticas de uma imagem simples usando ferramenta online de AES-ECB.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef para AES-ECB",
                                    "Documentação NIST sobre AES modes"
                                  ],
                                  "tips": "Teste com plaintext repetido para ver blocos idênticos no ciphertext.",
                                  "learningObjective": "Reconhecer AES-ECB como determinístico e demonstrar experimentalmente.",
                                  "commonMistakes": "Achar que AES é sempre determinístico; especifique o modo ECB."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Cifras de Fluxo sem Nonce como Exemplos Determinísticos",
                                  "subSteps": [
                                    "Defina cifras de fluxo: XOR de keystream com plaintext.",
                                    "Explique sem nonce: keystream gerado deterministicamente da chave e contador inicial.",
                                    "Cifre mensagens idênticas: keystream igual produz ciphertext igual.",
                                    "Exemplos: RC4 sem seed aleatória ou ChaCha20 sem nonce.",
                                    "Discuta vulnerabilidades: ataques de texto plano conhecido exploram repetições."
                                  ],
                                  "verification": "Implemente uma cifra de fluxo simples em Python sem nonce e verifique saídas idênticas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Biblioteca cryptography.io",
                                    "Exemplos de código de cifras de fluxo"
                                  ],
                                  "tips": "Use contador zero para simular ausência de nonce.",
                                  "learningObjective": "Identificar e demonstrar determinismo em cifras de fluxo sem nonce.",
                                  "commonMistakes": "Confundir nonce com IV; nonce é único por sessão em probabilísticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Implicações em Criptosistemas Simétricos",
                                  "subSteps": [
                                    "Descreva riscos: vazamento de informações sobre plaintext via padrões no ciphertext.",
                                    "Exemplos de ataques: reconhecimento de imagens em ECB, bias em keystream.",
                                    "Compare com boas práticas: sempre use IV/nonce aleatório para IND-CCA segurança.",
                                    "Discuta padrões como TLS 1.3: evitam determinísticos.",
                                    "Resuma quando usar determinísticos: apenas em cenários não-confidenciais."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que AES-ECB é inseguro para dados reais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel sobre ataques ECB",
                                    "Vídeo Khan Academy sobre modos de operação"
                                  ],
                                  "tips": "Pense em frequência analysis: letras comuns produzem padrões.",
                                  "learningObjective": "Articular implicações de segurança de algoritmos determinísticos.",
                                  "commonMistakes": "Subestimar riscos; lembre-se que mesmo sem chave, padrões vazam info."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação de Exemplos Determinísticos",
                                  "subSteps": [
                                    "Liste 3 exemplos determinísticos além dos dados (ex: DES-ECB).",
                                    "Classifique 5 algoritmos como determinístico ou não.",
                                    "Crie um fluxograma para identificar determinismo: 'mesma entrada = mesma saída?'.",
                                    "Debata cenários: quando determinismo é aceitável?",
                                    "Teste conhecimento com quiz autoavaliativo."
                                  ],
                                  "verification": "Resolva um quiz com 80% de acerto sobre identificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quiz online sobre criptografia",
                                    "Lista de algoritmos para classificar"
                                  ],
                                  "tips": "Pergunte: 'É sensível à entrada exata sem aleatoriedade?'",
                                  "learningObjective": "Aplicar conhecimento para identificar e explicar exemplos independentes.",
                                  "commonMistakes": "Classificar modos com IV fixo como determinísticos; IV deve ser aleatório."
                                }
                              ],
                              "practicalExample": "Cifrando a imagem do pinguim do Linux duas vezes com AES-ECB usando a mesma chave: o ciphertext resultante é idêntico, revelando o formato da imagem (olhos e bico visíveis como blocos iguais), demonstrando determinismo e vazamento de estrutura.",
                              "finalVerifications": [
                                "Lista corretamente AES-ECB e cifras de fluxo sem nonce como determinísticos.",
                                "Explica por que produzem saídas idênticas para entradas idênticas.",
                                "Descreve pelo menos duas implicações de segurança em criptosistemas simétricos.",
                                "Classifica 3 algoritmos adicionais como determinísticos ou probabilísticos.",
                                "Demonstra experimentalmente com ferramenta ou código.",
                                "Discute por que determinismo é evitado em criptografia moderna."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de determinismo (sem confusão com outros conceitos).",
                                "Exemplos corretos com explicação técnica detalhada.",
                                "Análise clara das implicações de segurança.",
                                "Uso de evidências experimentais ou visuais.",
                                "Conexão com conceitos mais amplos de criptosistemas simétricos.",
                                "Clareza e estrutura na explicação escrita/oral."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções determinísticas e propriedades de bijeção.",
                                "História: Evolução da criptografia de Enigma (determinística) para moderna.",
                                "Segurança da Informação: Análise de vulnerabilidades em protocolos.",
                                "Programação: Implementação de cifras em linguagens como Python.",
                                "Ética: Implicações de falhas criptográficas em privacidade digital."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps seguros, evitar AES-ECB previne vazamentos como no caso de fotos de perfil cifradas deterministicamente em serviços antigos, expondo identidades; use GCM ou ChaCha20-Poly1305 com nonce para conformidade com GDPR e proteção contra ataques de side-channel."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.3",
                            "name": "Analisar vantagens e desvantagens",
                            "description": "Discutir vantagens como reprodutibilidade e facilidade de teste, e desvantagens como vulnerabilidade a ataques de texto plano escolhido devido à detecção de padrões repetidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Algoritmos Determinísticos",
                                  "subSteps": [
                                    "Ler a definição de algoritmo determinístico: mesma entrada sempre produz mesma saída.",
                                    "Estudar exemplos como AES em modo ECB e DES.",
                                    "Comparar brevemente com algoritmos probabilísticos (mesma entrada pode gerar saídas diferentes).",
                                    "Anotar características principais: reprodutibilidade e previsibilidade.",
                                    "Assistir a um vídeo curto sobre criptografia simétrica determinística."
                                  ],
                                  "verification": "Escrever uma definição em suas próprias palavras e listar 3 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Texto introdutório de criptografia, vídeo no YouTube sobre AES, caderno para anotações.",
                                  "tips": "Use diagramas de fluxo para visualizar input-output fixo.",
                                  "learningObjective": "Dominar a definição e características fundamentais de algoritmos determinísticos.",
                                  "commonMistakes": "Confundir determinismo com probabilidade, ignorando o papel da chave fixa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Explicar as Vantagens",
                                  "subSteps": [
                                    "Listar vantagens principais: reprodutibilidade (mesmo resultado sempre).",
                                    "Explicar facilidade de teste e depuração devido à previsibilidade.",
                                    "Pesquisar eficiência computacional em cenários de alta repetição.",
                                    "Discutir cenários onde previsibilidade é essencial, como verificação de integridade.",
                                    "Criar uma tabela comparativa de vantagens."
                                  ],
                                  "verification": "Elaborar uma lista com 3 vantagens explicadas em 1-2 frases cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigos sobre criptografia (ex: Wikipedia AES), ferramenta de tabela como Google Sheets.",
                                  "tips": "Pense em contextos de software onde testes unitários dependem de outputs fixos.",
                                  "learningObjective": "Reconhecer e justificar as vantagens práticas dos algoritmos determinísticos.",
                                  "commonMistakes": "Superestimar vantagens sem considerar contexto de segurança."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Explicar as Desvantagens",
                                  "subSteps": [
                                    "Estudar vulnerabilidade a ataques chosen-plaintext (CPA) devido a padrões detectáveis.",
                                    "Analisar como padrões repetidos no plaintext revelam informações no ciphertext.",
                                    "Pesquisar exemplos históricos como quebra do DES por análise de padrões.",
                                    "Discutir limitação em dados com estrutura repetitiva (ex: imagens).",
                                    "Mapear desvantagens em uma tabela oposta às vantagens."
                                  ],
                                  "verification": "Descrever 3 desvantagens com exemplos de ataques associados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação sobre ataques CPA, exemplos de cifragem ECB em imagens (Ferramenta online como CyberChef).",
                                  "tips": "Teste cifrando uma imagem com ECB para visualizar padrões.",
                                  "learningObjective": "Identificar riscos de segurança inerentes aos algoritmos determinísticos.",
                                  "commonMistakes": "Ignorar o impacto de padrões no plaintext, focando só em performance."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a Análise Equilibrada",
                                  "subSteps": [
                                    "Comparar vantagens e desvantagens em um ensaio curto.",
                                    "Discutir quando usar determinísticos vs probabilísticos.",
                                    "Aplicar a análise a um caso real simples.",
                                    "Revisar e refinar argumentos para clareza.",
                                    "Preparar uma apresentação resumida."
                                  ],
                                  "verification": "Produzir um parágrafo de análise equilibrada com pelo menos 2 prós e 2 contras.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de texto, exemplos de cifragem prática.",
                                  "tips": "Use conectores como 'embora' para equilibrar prós e contras.",
                                  "learningObjective": "Integrar análise para formar uma discussão crítica completa.",
                                  "commonMistakes": "Ser unilateral, ignorando um lado da análise."
                                }
                              ],
                              "practicalExample": "Cifre uma imagem com modo ECB (determinístico) do AES usando CyberChef: observe padrões repetidos nos blocos uniformes da imagem no ciphertext, demonstrando vulnerabilidade a detecção de padrões, enquanto a reprodutibilidade permite testes idênticos repetidos.",
                              "finalVerifications": [
                                "Listar corretamente 3 vantagens e 3 desvantagens com explicações.",
                                "Explicar um ataque chosen-plaintext aplicado a determinísticos.",
                                "Comparar com probabilísticos em um cenário prático.",
                                "Produzir uma análise equilibrada sem viés.",
                                "Identificar quando evitar determinísticos (ex: dados padronizados)."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual nas vantagens/desvantagens (exatidão conceitual).",
                                "Profundidade da explicação com exemplos concretos.",
                                "Equilíbrio na análise (cobertura igual de prós e contras).",
                                "Clareza e estrutura lógica na discussão.",
                                "Aplicação prática demonstrada (ex: teste com ferramenta).",
                                "Uso correto de terminologia criptográfica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções determinísticas e análise de padrões.",
                                "Ética: Implicações de segurança em privacidade de dados.",
                                "Física: Modelos determinísticos vs quânticos/probabilísticos.",
                                "Lógica: Raciocínio crítico em avaliação de trade-offs."
                              ],
                              "realWorldApplication": "Em protocolos como TLS para chaves de sessão (reprodutibilidade para verificação), mas evitado em mensagens padronizadas como logs de transações bancárias para prevenir vazamento de padrões via chosen-plaintext attacks."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.2",
                        "name": "Algoritmos Probabilísticos",
                        "description": "Algoritmos que incorporam elementos de aleatoriedade (como chaves aleatórias ou nonces), podendo gerar saídas diferentes para a mesma entrada, o que é essencial para segurança em criptografia moderna.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.2.1",
                            "name": "Definir algoritmo probabilístico",
                            "description": "Descrever o conceito, enfatizando o uso de fontes de entropia aleatória e a probabilidade de saídas variadas, com referência a modelos como RP, BPP e ZPP em teoria da complexidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Algoritmos Determinísticos como Base",
                                  "subSteps": [
                                    "Leia a definição formal de um algoritmo determinístico: dada a mesma entrada, sempre produz a mesma saída.",
                                    "Identifique exemplos cotidianos, como soma de números ou busca binária.",
                                    "Compare com processos não-determinísticos em contextos simples, como decisões humanas.",
                                    "Anote as limitações em problemas com alta incerteza, como previsão climática.",
                                    "Crie um fluxograma simples de um algoritmo determinístico."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando por que determinísticos são previsíveis e forneça 2 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de teoria da computação",
                                    "Vídeo introdutório sobre algoritmos determinísticos (Khan Academy)",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": "Use analogias do dia a dia, como uma receita de bolo, para fixar o conceito.",
                                  "learningObjective": "Compreender as características fundamentais de algoritmos determinísticos para contrastar com probabilísticos.",
                                  "commonMistakes": [
                                    "Confundir determinismo com eficiência; lembre-se que determinismo é sobre previsibilidade, não velocidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceitos de Aleatoriedade e Entropia",
                                  "subSteps": [
                                    "Estude fontes de entropia aleatória: hardware (ruído térmico), software (geradores pseudo-aleatórios).",
                                    "Aprenda sobre entropia como medida de imprevisibilidade em teoria da informação.",
                                    "Simule uma fonte aleatória simples, como lançar uma moeda virtual 10 vezes.",
                                    "Discuta probabilidade de saídas variadas: mesmo input pode gerar outputs diferentes.",
                                    "Registre observações sobre como a aleatoriedade afeta previsibilidade."
                                  ],
                                  "verification": "Gere 5 sequências aleatórias com uma ferramenta online e descreva variações nas saídas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de gerador aleatório (random.org)",
                                    "Artigo sobre entropia (Wikipedia: Entropy (information theory))",
                                    "Calculadora ou Python para simulação"
                                  ],
                                  "tips": "Teste diferentes sementes em geradores pseudo-aleatórios para ver impactos na 'aleatoriedade'.",
                                  "learningObjective": "Dominar o papel das fontes de entropia e como elas introduzem variabilidade em computações.",
                                  "commonMistakes": [
                                    "Achar que pseudo-aleatório é verdadeiramente aleatório; diferencie de fontes verdadeiras."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Algoritmo Probabilístico Formalmente",
                                  "subSteps": [
                                    "Formule a definição: algoritmo que usa bits aleatórios como input adicional, produzindo saídas probabilísticas.",
                                    "Enfatize: probabilidade alta de acerto, mas possível erro (one-sided ou two-sided).",
                                    "Escreva a definição em suas palavras, incluindo entropia e variabilidade de saídas.",
                                    "Compare com determinísticos via tabela: inputs, outputs, garantias.",
                                    "Crie um pseudocódigo simples de um algoritmo probabilístico básico."
                                  ],
                                  "verification": "Escreva e recite a definição completa, citando entropia e probabilidade de saídas variadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Livro ou notas de Introdução à Criptografia",
                                    "Editor de texto para pseudocódigo",
                                    "Tabela comparativa em papel"
                                  ],
                                  "tips": "Inclua notação formal: A(x, r) onde r é string aleatória.",
                                  "learningObjective": "Construir uma definição precisa de algoritmo probabilístico, destacando aleatoriedade.",
                                  "commonMistakes": [
                                    "Ignorar que aleatoriedade é input explícito; não é 'indecisão' do algoritmo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Modelos de Complexidade: RP, BPP e ZPP",
                                  "subSteps": [
                                    "Defina RP (Randomized Polynomial): aceita sim com prob >1/2, rejeita sempre não.",
                                    "Estude BPP (Bounded-error Probabilistic Polynomial): prob de erro <1/3 para sim/não.",
                                    "Aprenda ZPP (Zero-error Probabilistic Polynomial): sempre correto, mas pode demorar.",
                                    "Crie um diagrama comparando as três classes com P e NP.",
                                    "Relacione com criptografia: testes probabilísticos rápidos."
                                  ],
                                  "verification": "Explique cada modelo em 1 frase e dê um exemplo de aplicação criptográfica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Referência: Teoria da Complexidade (Arora-Barak)",
                                    "Vídeo sobre classes probabilísticas (YouTube: Complexity Zoo)",
                                    "Ferramenta de diagrama (Draw.io)"
                                  ],
                                  "tips": "Lembre: RP ⊆ BPP ⊆ PSPACE; foque em garantias probabilísticas.",
                                  "learningObjective": "Associar definição de algoritmo probabilístico às classes RP, BPP e ZPP.",
                                  "commonMistakes": [
                                    "Confundir RP com BPP; RP é one-sided error, BPP two-sided."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o teste de primalidade de Miller-Rabin (RP): dado um número n, use bits aleatórios para gerar testemunhas. Execute 10 vezes no mesmo n primo/composto e observe saídas variadas, mas alta probabilidade de detecção correta, simulando entropia via random seed em Python.",
                              "finalVerifications": [
                                "Pode definir algoritmo probabilístico incluindo fontes de entropia e variabilidade de saídas.",
                                "Explica diferenças entre determinísticos e probabilísticos com exemplos.",
                                "Descreve corretamente RP, BPP e ZPP com suas garantias probabilísticas.",
                                "Simula uma fonte aleatória e discute impactos na saída.",
                                "Relaciona o conceito a aplicações em criptografia.",
                                "Cria pseudocódigo de um algoritmo probabilístico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição (entropia, probabilidade): 0-5 pontos.",
                                "Compreensão de classes RP/BPP/ZPP: distinção clara, 0-5 pontos.",
                                "Uso correto de exemplos práticos e simulações: 0-5 pontos.",
                                "Profundidade em fontes de aleatoriedade: 0-5 pontos.",
                                "Clareza na comparação com determinísticos: 0-5 pontos.",
                                "Criatividade em conexões com criptografia: 0-5 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Estatística (distribuições, limites probabilísticos).",
                                "Física: Entropia termodinâmica e quântica (fontes de aleatoriedade verdadeira).",
                                "Estatística: Análise de erro probabilístico e testes de hipótese.",
                                "Segurança da Informação: Aplicações em protocolos criptográficos.",
                                "Filosofia da Ciência: Limites do determinismo na computação."
                              ],
                              "realWorldApplication": "Em criptografia, algoritmos probabilísticos como Miller-Rabin testam primalidade de números gigantes rapidamente com alta probabilidade (>99.9% com poucas iterações), essenciais para gerar chaves RSA seguras, onde certeza absoluta é computacionalmente inviável."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.2",
                            "name": "Identificar exemplos criptográficos",
                            "description": "Exemplificar com padding OAEP em RSA ou modos de operação como CTR com nonce aleatório, explicando como a aleatoriedade previne ataques em criptosistemas de chave pública.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de algoritmos determinísticos versus probabilísticos",
                                  "subSteps": [
                                    "Defina algoritmo determinístico: saída sempre igual para mesma entrada e chave.",
                                    "Defina algoritmo probabilístico: incorpora aleatoriedade (ex: nonce, padding randômico) para saídas diferentes.",
                                    "Compare em criptografia: determinísticos vulneráveis a ataques de texto plano escolhido (CPA).",
                                    "Liste exemplos iniciais: RSA cru (determinístico) vs RSA-OAEP (probabilístico).",
                                    "Explique necessidade de aleatoriedade em chaves públicas para semantic security."
                                  ],
                                  "verification": "Resuma diferenças em um parágrafo e liste 2 exemplos de cada tipo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook, documento de referência sobre criptografia básica (ex: Wikipedia 'Probabilistic encryption').",
                                  "tips": "Use diagramas para visualizar entrada -> saída determinística vs variada.",
                                  "learningObjective": "Diferenciar algoritmos determinísticos e probabilísticos e seu impacto na segurança.",
                                  "commonMistakes": "Confundir aleatoriedade com chave secreta; aleatoriedade é pública mas imprevisível."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar padding OAEP em RSA como exemplo probabilístico",
                                  "subSteps": [
                                    "Descreva RSA básico: C = M^e mod N (determinístico, mesmo M -> mesmo C).",
                                    "Explique OAEP: Optimal Asymmetric Encryption Padding adiciona padding randômico (r) antes de hash.",
                                    "Detalhe processo: M + r -> hash -> XOR com seed randômica -> concatenação.",
                                    "Mostre como r garante C diferente para mesmo M.",
                                    "Discuta prevenção: impede ataques CPA onde atacante mapeia plaintexts."
                                  ],
                                  "verification": "Desenhe fluxo OAEP e criptografe manualmente 2 mesmos plaintexts com r diferente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora modular online, diagrama OAEP (RFC 8017).",
                                  "tips": "Implemente em Python com cryptography lib para ver ciphertexts variados.",
                                  "learningObjective": "Compreender como OAEP introduz aleatoriedade em RSA para segurança semântica.",
                                  "commonMistakes": "Ignorar que padding é essencial; RSA sem padding é inseguro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar modo de operação CTR com nonce aleatório",
                                  "subSteps": [
                                    "Defina CTR: Counter mode transforma bloco em stream cipher com contador.",
                                    "Explique nonce: Número único usado só uma vez (aleatório ou incremental).",
                                    "Descreva processo: Nonce + counter -> E_k -> XOR com plaintext.",
                                    "Mostre aleatoriedade: Novo nonce garante keystream único por mensagem.",
                                    "Compare com ECB: CTR previne padrões em plaintexts idênticos."
                                  ],
                                  "verification": "Gere 2 keystreams com nonces diferentes e XOR com mesmo texto para ver resultados únicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com pycryptodome, exemplos de código CTR mode.",
                                  "tips": "Nunca reuse nonce com mesma chave; causa colisões.",
                                  "learningObjective": "Identificar CTR como probabilístico e seu uso em chaves simétricas.",
                                  "commonMistakes": "Confundir nonce com IV; nonce não precisa ser secreto mas único."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar prevenção de ataques pela aleatoriedade",
                                  "subSteps": [
                                    "Liste ataques em determinísticos: CPA, chosen-ciphertext (CCA).",
                                    "Explique OAEP: Resistente a CCA via hash e masking.",
                                    "Explique CTR: Previne malleability e padrões sem padding.",
                                    "Compare exemplos: OAEP para assimétrico, CTR para simétrico.",
                                    "Crie tabela: Exemplo | Aleatoriedade usada | Ataque prevenido."
                                  ],
                                  "verification": "Escreva ensaio curto ligando aleatoriedade a exemplos e ataques evitados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel ou Google Docs para tabela.",
                                  "tips": "Foquem em 'por quê' aleatoriedade quebra previsibilidade do atacante.",
                                  "learningObjective": "Explicar mecanicamente como aleatoriedade eleva segurança em criptosistemas públicos.",
                                  "commonMistakes": "Achar que aleatoriedade substitui chaves fortes; é complementar."
                                }
                              ],
                              "practicalExample": "Ao enviar 'HELLO' via RSA sem OAEP, sempre gera mesmo ciphertext, permitindo atacante deduzir padrões. Com OAEP, nonce randômico produz C1 e C2 diferentes, mascarando estrutura e prevenindo CPA em apps como assinatura digital em blockchain.",
                              "finalVerifications": [
                                "Explica corretamente OAEP como padding probabilístico em RSA.",
                                "Descreve CTR com nonce e sua diferença de modos determinísticos.",
                                "Identifica pelo menos 2 ataques prevenidos pela aleatoriedade.",
                                "Dá exemplo concreto de criptotexto variado para mesmo plaintext.",
                                "Liga aleatoriedade a semantic security em chaves públicas.",
                                "Cria tabela comparativa de exemplos probabilísticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de OAEP e CTR (90%+ correção).",
                                "Profundidade na explicação de aleatoriedade vs ataques (exemplos específicos).",
                                "Clareza em diagramas ou códigos demonstrativos.",
                                "Número e relevância de sub-passos em análises.",
                                "Capacidade de sintetizar prevenção de ataques.",
                                "Uso correto de terminologia criptográfica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da probabilidade e geração de números pseudo-aleatórios.",
                                "Programação: Implementação em linguagens como Python (cryptography lib).",
                                "Segurança da Informação: Análise de vulnerabilidades em protocolos TLS.",
                                "Física: Entropia e fontes de aleatoriedade quântica."
                              ],
                              "realWorldApplication": "Em HTTPS/TLS, OAEP protege troca de chaves RSA contra ataques em e-commerce; CTR em VPNs (ex: WireGuard) usa nonce para streams seguros em comunicações móveis, prevenindo replay e padrões em dados sensíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.3",
                            "name": "Explicar papel da aleatoriedade",
                            "description": "Detalhar como a aleatoriedade é gerada (ex: geradores pseudoaleatórios) e seu impacto na segurança contra criptoanálise, citando referências como Menezes (1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Aleatoriedade em Criptografia",
                                  "subSteps": [
                                    "Defina aleatoriedade verdadeira versus pseudoaleatoriedade.",
                                    "Explique por que a aleatoriedade é essencial em algoritmos probabilísticos.",
                                    "Compare com algoritmos determinísticos, destacando previsibilidade.",
                                    "Identifique cenários onde a falta de aleatoriedade compromete a segurança.",
                                    "Revise definições de criptoanálise e como ela explora padrões."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo as diferenças entre aleatoriedade verdadeira e pseudoaleatoriedade, sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Handbook of Applied Cryptography (Menezes et al., 1996) - Capítulo 5",
                                    "Wikipedia: Pseudorandomness"
                                  ],
                                  "tips": "Use analogias como lançamento de moedas para aleatoriedade verdadeira versus calculadoras para pseudoaleatoriedade.",
                                  "learningObjective": "Diferenciar tipos de aleatoriedade e sua relevância em criptografia.",
                                  "commonMistakes": "Confundir pseudoaleatoriedade com aleatoriedade verdadeira; ignorar o contexto criptográfico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Geradores Pseudoaleatórios (PRNG)",
                                  "subSteps": [
                                    "Descreva como PRNGs funcionam, usando sementes e funções iterativas.",
                                    "Estude exemplos como Linear Congruential Generator (LCG) e Mersenne Twister.",
                                    "Implemente um PRNG simples em Python para gerar números.",
                                    "Analise propriedades criptográficas: período, uniformidade e imprevisibilidade.",
                                    "Discuta fontes de entropia para sementes (ex: ruído de hardware)."
                                  ],
                                  "verification": "Execute um código Python de PRNG e gere 100 números, verificando uniformidade via histograma.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Documentação Python random module",
                                    "Menezes (1996) - Seção 5.5"
                                  ],
                                  "tips": "Sempre inicialize com sementes de alta entropia; teste com sementes repetidas para ver padrões.",
                                  "learningObjective": "Entender mecanismos de geração de pseudoaleatoriedade e suas limitações.",
                                  "commonMistakes": "Usar sementes previsíveis como timestamp atual; assumir PRNG como criptograficamente seguro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Impacto da Aleatoriedade na Segurança Contra Criptoanálise",
                                  "subSteps": [
                                    "Explique como padrões em saídas determinísticas facilitam ataques (ex: chosen-plaintext).",
                                    "Discuta ataques a PRNG fracos, como o Debian OpenSSL bug de 2008.",
                                    "Descreva como aleatoriedade probabilística impede adivinhação de chaves/nonces.",
                                    "Compare segurança de modos ECB (determinístico) vs CBC com IV aleatório.",
                                    "Simule um ataque simples em código determinístico versus probabilístico."
                                  ],
                                  "verification": "Descreva um ataque criptanalítico em um PRNG fraco e como aleatoriedade o mitiga.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código em GitHub: PRNG attacks",
                                    "Menezes (1996) - Capítulo 7"
                                  ],
                                  "tips": "Pense em termos de informação teórica: aleatoriedade maximiza entropia.",
                                  "learningObjective": "Avaliar como aleatoriedade fortalece resistência a criptoanálise.",
                                  "commonMistakes": "Subestimar ataques de lado canal; confundir imprevisibilidade computacional com provada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Citar Referências e Sintetizar o Papel da Aleatoriedade",
                                  "subSteps": [
                                    "Leia trechos chave de Menezes (1996) sobre PRNGs e criptografia probabilística.",
                                    "Resuma o papel da aleatoriedade em protocolos como Diffie-Hellman ou assinatura digital.",
                                    "Crie um diagrama mostrando fluxo: entropia -> PRNG -> nonce/chave -> algoritmo.",
                                    "Debata trade-offs: custo computacional versus segurança.",
                                    "Prepare uma explicação oral ou escrita citando fontes."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras citando Menezes, com diagrama anexado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "PDF de Handbook of Applied Cryptography",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use citações diretas para precisão; foque em impactos práticos.",
                                  "learningObjective": "Integrar referências acadêmicas para validar explicações sobre aleatoriedade.",
                                  "commonMistakes": "Citar fontes sem contexto; ignorar atualizações pós-1996 como NIST SP 800-90."
                                }
                              ],
                              "practicalExample": "Implemente um chat seguro simples em Python usando criptografia probabilística: gere uma chave simétrica com secrets module (PRNG criptográfico), criptografe mensagens com AES-CBC e IV aleatório. Compare com versão determinística (IV fixo) mostrando como a mesma plaintext gera ciphertexts idênticos, vulnerável a análise de padrões.",
                              "finalVerifications": [
                                "Explicar em 2 minutos o funcionamento de um PRNG sem pausas ou erros.",
                                "Identificar falhas em um PRNG fraco fornecido em código.",
                                "Calcular entropia aproximada de uma sequência gerada.",
                                "Diferenciar impactos de aleatoriedade em padding oracles vs nonce reuse.",
                                "Citar corretamente Menezes (1996) em contexto de segurança probabilística.",
                                "Simular ataque em código determinístico com sucesso demonstrado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de PRNG e criptoanálise (30%)",
                                "Profundidade técnica: detalhes sobre geração e entropia (25%)",
                                "Uso de evidências: citações e exemplos práticos válidos (20%)",
                                "Clareza na explicação: linguagem acessível e lógica (15%)",
                                "Criatividade em exemplos: simulações reais e relevantes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Entropia de Shannon",
                                "Estatística: Testes de Uniformidade e Qui-quadrado para PRNG",
                                "Física: Fontes de Entropia Quântica (ex: decay radioativo)",
                                "Segurança da Informação: Aplicações em Blockchain e Criptomoedas"
                              ],
                              "realWorldApplication": "Em protocolos TLS/SSL, aleatoriedade via PRNGs (ex: /dev/urandom no Linux) gera nonces e chaves efêmeras, prevenindo ataques como BEAST ou POODLE que exploram reutilização previsível; falhas como o bug Heartbleed destacam riscos de entropia baixa em servidores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.4",
                            "name": "Discutir vantagens em protocolos",
                            "description": "Analisar benefícios em protocolos criptográficos, como anonimato em assinaturas probabilísticas ou resistência a ataques de repetição em cifras simétricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Algoritmos Determinísticos e Probabilísticos",
                                  "subSteps": [
                                    "Defina algoritmos determinísticos: sempre produzem a mesma saída para a mesma entrada.",
                                    "Defina algoritmos probabilísticos: incorporam aleatoriedade, produzindo saídas variáveis para garantir propriedades como anonimato.",
                                    "Compare exemplos: assinatura determinística (ex: RSA básica) vs probabilística (ex: BLS com blinding).",
                                    "Identifique cenários onde probabilidade é essencial em criptografia.",
                                    "Liste limitações dos determinísticos, como rastreabilidade."
                                  ],
                                  "verification": "Crie um quadro comparativo resumindo diferenças e envie para revisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre criptografia, quadro branco ou ferramenta digital como Draw.io.",
                                  "tips": "Use diagramas de fluxo para visualizar o impacto da aleatoriedade.",
                                  "learningObjective": "Compreender as diferenças fundamentais que justificam o uso de abordagens probabilísticas.",
                                  "commonMistakes": "Confundir probabilidade com imprevisibilidade; lembre que é controlada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Anonimato em Assinaturas Probabilísticas",
                                  "subSteps": [
                                    "Explique anonimato: impossibilidade de ligar assinatura ao signatário sem chave privada.",
                                    "Descreva mecanismo: adição de ruído aleatório (blinding) durante assinatura.",
                                    "Estude exemplo: assinaturas em ring signatures ou group signatures probabilísticas.",
                                    "Simule um ataque de rastreamento em versão determinística e mostre falha.",
                                    "Discuta trade-offs: overhead computacional vs ganho em privacidade."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como o anonimato probabilístico protege identidades.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Documentação de bibliotecas como Charm-Crypto, exemplos de código Python para assinaturas.",
                                  "tips": "Teste com código simples para observar saídas diferentes em execuções repetidas.",
                                  "learningObjective": "Identificar e explicar o benefício específico de anonimato fornecido por probabilismo.",
                                  "commonMistakes": "Ignorar que anonimato é condicional (heurístico ou criptográfico); especifique o tipo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Resistência a Ataques de Repetição em Cifras Simétricas",
                                  "subSteps": [
                                    "Defina replay attack: reutilização de mensagens válidas para enganar o receptor.",
                                    "Explique cifras determinísticas vulneráveis: AES sem nonce produz mesma ciphertext.",
                                    "Descreva solução probabilística: uso de IV/nonce aleatório em modos como GCM.",
                                    "Analise protocolo TLS: como nonces previnem replays em handshakes.",
                                    "Simule um replay attack em código e demonstre proteção com nonce."
                                  ],
                                  "verification": "Implemente um snippet de código mostrando replay falhando com nonce.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Biblioteca cryptography em Python, Wireshark para capturar tráfego TLS.",
                                  "tips": "Registre timestamps e nonces em logs para visualizar unicidade.",
                                  "learningObjective": "Demonstrar como probabilismo mitiga replay attacks em protocolos simétricos.",
                                  "commonMistakes": "Confundir nonce com chave; nonce é único por mensagem, não secreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Vantagens Gerais em Protocolos Criptográficos",
                                  "subSteps": [
                                    "Integre exemplos: anonimato em Zcash (zk-SNARKs probabilísticos) e replay em SSH.",
                                    "Compare protocolos: determinístico (falha em privacidade) vs probabilístico (robusto).",
                                    "Debata cenários: blockchain para anonimato, IoT para anti-replay.",
                                    "Avalie custos: latência vs segurança.",
                                    "Formule argumentos pró-probabilísticos em um ensaio curto."
                                  ],
                                  "verification": "Apresente uma discussão oral ou escrita de 5 minutos sobre vantagens.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos sobre protocolos como Tor ou Signal, gravador de áudio.",
                                  "tips": "Use bullet points para estruturar argumentos: benefício, exemplo, evidência.",
                                  "learningObjective": "Sintetizar vantagens para argumentar uso em protocolos reais.",
                                  "commonMistakes": "Generalizar demais; ancorar em exemplos específicos."
                                }
                              ],
                              "practicalExample": "Em um protocolo de votação eletrônica, use assinaturas probabilísticas para anonimato (votos não rastreáveis ao eleitor) e nonces em cifras simétricas para prevenir replays (evitar votos duplicados), simulando com código Python onde 10 eleitores votam sem revelar identidade.",
                              "finalVerifications": [
                                "Explica corretamente anonimato em assinaturas probabilísticas com exemplo.",
                                "Demonstra resistência a replay em cifras com nonce/IV.",
                                "Lista pelo menos 3 vantagens em protocolos reais.",
                                "Identifica trade-offs como overhead computacional.",
                                "Compara determinístico vs probabilístico em um quadro.",
                                "Aplica conceitos a um protocolo como TLS ou Zcash."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de termos criptográficos (90-100%).",
                                "Profundidade de análise: inclui mecanismos e exemplos (80-90%).",
                                "Clareza na comunicação: explicações lógicas e concisas (70-80%).",
                                "Uso de evidências: cita códigos, diagramas ou referências (60-70%).",
                                "Criatividade em aplicações: conecta a cenários reais (50-60%).",
                                "Completude: cobre todos os aspectos solicitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Distribuições Aleatórias.",
                                "Redes de Computadores: Protocolos de Segurança como TLS/SSL.",
                                "Ética e Sociedade: Privacidade de Dados e Implicações Legais (GDPR).",
                                "Física: Entropia como Fonte de Aleatoriedade Verdadeira."
                              ],
                              "realWorldApplication": "Em blockchains como Monero, assinaturas probabilísticas garantem anonimato de transações financeiras; em apps de mensagens como Signal, nonces previnem replay attacks, protegendo comunicações seguras contra eavesdroppers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.3",
                        "name": "Diferenças e Aplicações Comparativas",
                        "description": "Comparação direta entre algoritmos determinísticos e probabilísticos, focando em comportamentos, segurança e escolhas em criptosistemas simétricos e assimétricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.3.1",
                            "name": "Comparar saídas para entradas iguais",
                            "description": "Construir uma tabela comparativa mostrando que determinísticos geram saídas idênticas, enquanto probabilísticos variam, com exemplos numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Algoritmos Determinísticos e Probabilísticos",
                                  "subSteps": [
                                    "Defina algoritmo determinístico: sempre produz a mesma saída para a mesma entrada.",
                                    "Defina algoritmo probabilístico: pode produzir saídas diferentes para a mesma entrada devido a aleatoriedade.",
                                    "Identifique exemplos cotidianos: calculadora (determinístico) vs. lançamento de dado (probabilístico).",
                                    "Revise contexto de criptografia: hashes determinísticos vs. assinaturas com nonce aleatório.",
                                    "Anote diferenças chave em um quadro comparativo simples."
                                  ],
                                  "verification": "Explique oralmente ou por escrito as diferenças com exemplos próprios.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta ou editor de texto simples.",
                                  "tips": "Use analogias como 'receita de bolo fixa' vs. 'receita com pitada aleatória de sal'.",
                                  "learningObjective": "Diferenciar conceitualmente algoritmos determinísticos de probabilísticos.",
                                  "commonMistakes": "Confundir não-determinismo (devido a estado externo) com probabilidade interna."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Definir Exemplos Numéricos Simples",
                                  "subSteps": [
                                    "Escolha função determinística: f_det(x) = 2 * x.",
                                    "Escolha função probabilística: f_prob(x) = 2 * x + random.randint(0, 10).",
                                    "Defina entrada fixa: x = 5.",
                                    "Implemente funções em pseudocódigo ou Python básico.",
                                    "Teste manualmente uma vez cada função para validar."
                                  ],
                                  "verification": "Mostre código/pseudocódigo com saída esperada para x=5 na determinística.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (ex: Python IDLE, Google Colab) ou papel para pseudocódigo.",
                                  "tips": "Mantenha números pequenos para facilitar cálculos manuais.",
                                  "learningObjective": "Criar exemplos numéricos concretos e reproduzíveis.",
                                  "commonMistakes": "Escolher funções complexas que ofusquem a diferença principal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e Registrar Múltiplas Execuções com Entrada Fixa",
                                  "subSteps": [
                                    "Execute f_det(x=5) pelo menos 5 vezes e registre saídas.",
                                    "Execute f_prob(x=5) pelo menos 5 vezes e registre saídas.",
                                    "Observe e anote padrões: consistência vs. variação.",
                                    "Calcule estatísticas básicas: média e desvio para probabilística.",
                                    "Repita se necessário para confirmar aleatoriedade."
                                  ],
                                  "verification": "Lista de pelo menos 5 saídas para cada função, mostrando padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ambiente de programação Python com módulo random importado.",
                                  "tips": "Use loop for i in range(5): print(func(5)) para automação.",
                                  "learningObjective": "Demonstrar empiricamente o comportamento para entradas iguais.",
                                  "commonMistakes": "Usar sementes aleatórias fixas, tornando probabilístico determinístico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Analisar Tabela Comparativa",
                                  "subSteps": [
                                    "Crie tabela com colunas: Execução #, Entrada, Saída Determinística, Saída Probabilística.",
                                    "Preencha com dados das execuções.",
                                    "Adicione linha de resumo: 'Saídas idênticas' vs. 'Variam'.",
                                    "Inclua interpretação: implicações em criptografia (ex: detecção de colisões).",
                                    "Formate tabela em Markdown ou planilha para clareza."
                                  ],
                                  "verification": "Tabela completa compartilhada, com análise escrita de 2-3 frases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha (Google Sheets, Excel) ou Markdown editor.",
                                  "tips": "Use bordas e negrito para destacar diferenças.",
                                  "learningObjective": "Visualizar e concluir diferenças de forma comparativa.",
                                  "commonMistakes": "Ignorar variações mínimas ou não repetir execuções suficientes."
                                }
                              ],
                              "practicalExample": "Em Python: def det(x): return 2 * x; def prob(x): import random; return 2 * x + random.randint(0,10). Para x=5, det sempre retorna 10; prob retorna valores como 10, 13, 15, 12, 11 em 5 runs. Tabela: Exec#1: det=10, prob=12; etc.",
                              "finalVerifications": [
                                "Tabela mostra saídas idênticas para determinístico em todas execuções.",
                                "Saídas probabilísticas variam em pelo menos 80% das execuções.",
                                "Entrada é idêntica em todas linhas da tabela.",
                                "Análise escrita explica por que isso ocorre.",
                                "Exemplos numéricos são simples e corretos.",
                                "Conexão com criptografia mencionada (ex: hashes vs. proofs)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas (100%).",
                                "Qualidade dos exemplos: simplicidade e relevância (numéricos <100).",
                                "Número de execuções: mínimo 5 por função.",
                                "Clareza da tabela: legível, bem formatada.",
                                "Análise: insights sobre implicações práticas.",
                                "Completude: todos campos do atomicExpansion preenchidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções constantes vs. estocásticas.",
                                "Estatística: Medidas de variância e repetibilidade.",
                                "Física: Experimentos determinísticos vs. quânticos probabilísticos.",
                                "Probabilidade: Modelos aleatórios em simulações."
                              ],
                              "realWorldApplication": "Em criptografia, algoritmos determinísticos como SHA-256 garantem hashes idênticos para verificação de integridade de arquivos; probabilísticos como geração de chaves efêmeras em TLS variam saídas para maior segurança contra ataques de repetição."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.2",
                            "name": "Avaliar impactos na segurança",
                            "description": "Explicar como determinísticos facilitam criptoanálise básica por padrões, enquanto probabilísticos aumentam a entropia e resistem a ataques adaptativos, referenciando Paar & Pelzl (2010).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Básicas de Algoritmos Determinísticos e Probabilísticos",
                                  "subSteps": [
                                    "Ler a seção relevante de Paar & Pelzl (2010) sobre algoritmos criptográficos.",
                                    "Definir algoritmo determinístico: mesma entrada sempre produz mesma saída.",
                                    "Definir algoritmo probabilístico: incorpora aleatoriedade, saídas variam para mesma entrada.",
                                    "Identificar exemplos: determinístico (AES-ECB), probabilístico (AES-GCM)."
                                  ],
                                  "verification": "Escrever definições e exemplos em um documento, comparando com o livro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro Paar & Pelzl (2010), caderno ou editor de texto.",
                                  "tips": "Use diagramas de fluxo para visualizar diferenças na entrada/saída.",
                                  "learningObjective": "Diferenciar precisamente os dois tipos de algoritmos.",
                                  "commonMistakes": "Confundir com não-determinismo em computação quântica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vulnerabilidades dos Algoritmos Determinísticos",
                                  "subSteps": [
                                    "Explicar como padrões emergem em saídas determinísticas (ex: ECB mode revela padrões de imagem).",
                                    "Estudar criptoanálise básica: ataques de texto plano conhecido e análise de frequência.",
                                    "Simular um ataque simples em um ciphertext determinístico usando ferramentas online.",
                                    "Referenciar Paar & Pelzl (2010) sobre facilitação de padrões na criptoanálise.",
                                    "Documentar como padrões reduzem o espaço de chaves efetivo."
                                  ],
                                  "verification": "Gerar um ciphertext ECB de uma imagem e identificar padrões visuais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta online como CyberChef, imagem de teste, Paar & Pelzl (2010).",
                                  "tips": "Teste com imagens conhecidas como pingüim para visualização clara.",
                                  "learningObjective": "Compreender como determinismo facilita criptoanálise por padrões.",
                                  "commonMistakes": "Ignorar modos de operação como ECB vs CBC."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Vantagens dos Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Definir entropia em criptografia: medida de imprevisibilidade.",
                                    "Explicar como probabilísticos usam nonce/IV para aumentar entropia.",
                                    "Descrever resistência a ataques adaptativos (escolhido-cifra adaptativo).",
                                    "Referenciar Paar & Pelzl (2010) sobre aumento de entropia e resistência.",
                                    "Comparar entropia de saídas determinísticas vs probabilísticas com cálculos simples."
                                  ],
                                  "verification": "Calcular entropia aproximada de dois ciphertexts (um de cada tipo) usando fórmula Shannon.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python para entropia, Paar & Pelzl (2010).",
                                  "tips": "Use bibliotecas como SciPy para automação de cálculos de entropia.",
                                  "learningObjective": "Identificar como probabilismo melhora segurança via entropia.",
                                  "commonMistakes": "Confundir entropia com aleatoriedade verdadeira."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Comparar Impactos na Segurança",
                                  "subSteps": [
                                    "Criar tabela comparativa: determinísticos vs probabilísticos em criptoanálise, entropia, ataques.",
                                    "Avaliar cenários: quando usar cada um (ex: determinístico para MACs, probabilístico para confidencialidade).",
                                    "Discutir trade-offs: performance vs segurança.",
                                    "Referenciar explicitamente Paar & Pelzl (2010) em conclusões.",
                                    "Escrever parágrafo resumindo avaliação de impactos."
                                  ],
                                  "verification": "Compartilhar tabela e parágrafo com par ou auto-revisar contra critérios do livro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou Markdown para tabela, Paar & Pelzl (2010).",
                                  "tips": "Use cores na tabela para destacar forças/fraquezas.",
                                  "learningObjective": "Sintetizar diferenças e recomendar baseado em impactos de segurança.",
                                  "commonMistakes": "Superestimar determinísticos em todos os contextos."
                                }
                              ],
                              "practicalExample": "Compare cifragem de uma mensagem 'HELLO' com AES-ECB (determinístico: padrões repetidos) vs AES-GCM (probabilístico: saídas únicas por nonce). Ataque ECB revela 'H' sempre igual; GCM resiste por entropia.",
                              "finalVerifications": [
                                "Explicar corretamente padrões em determinísticos com exemplo.",
                                "Calcular e comparar entropia de dois ciphertexts.",
                                "Descrever um ataque adaptativo falhando em probabilísticos.",
                                "Citar Paar & Pelzl (2010) com página relevante.",
                                "Recomendar uso apropriado em cenário real.",
                                "Identificar pelo menos 3 diferenças chave em tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 20%)",
                                "Análise de vulnerabilidades (exemplos concretos: 25%)",
                                "Explicação de entropia e resistência (cálculos: 25%)",
                                "Referenciação e síntese (citação Paar & Pelzl: 15%)",
                                "Clareza e estrutura (tabelas/diagramas: 15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Entropia de Shannon.",
                                "Segurança da Informação: Análise de Ameaças e Modelos de Ataque.",
                                "Física: Geradores de Números Aleatórios Verdadeiros (QNGRs)."
                              ],
                              "realWorldApplication": "Em protocolos TLS/HTTPS, modos probabilísticos como GCM previnem ataques de padding oracle (Lucky Thirteen), enquanto ECB determinístico é evitado para evitar vazamento de padrões em dados sensíveis como cartões de crédito."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.3",
                            "name": "Decidir uso em contextos criptográficos",
                            "description": "Orientar quando optar por cada tipo, como determinísticos para verificação de integridade e probabilísticos para cifragem sem reutilização de chaves, com base em Schneier (2015).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar diferenças fundamentais entre algoritmos determinísticos e probabilísticos",
                                  "subSteps": [
                                    "Defina algoritmo determinístico: sempre produz a mesma saída para a mesma entrada.",
                                    "Defina algoritmo probabilístico: incorpora aleatoriedade, produzindo saídas variadas para a mesma entrada.",
                                    "Compare propriedades: determinísticos são previsíveis e reutilizáveis; probabilísticos evitam padrões e reutilização de chaves.",
                                    "Leia Schneier (2015), capítulo sobre modos de operação, para exemplos como ECB (determinístico) vs CTR (probabilístico).",
                                    "Anote 3 vantagens e 3 desvantagens de cada tipo."
                                  ],
                                  "verification": "Criar um quadro comparativo com pelo menos 6 pontos chave das diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Applied Cryptography' de Schneier (2015), notas em papel ou Google Docs.",
                                  "tips": "Use tabelas para visualização clara das diferenças.",
                                  "learningObjective": "Distinguir precisamente as características únicas de cada tipo de algoritmo.",
                                  "commonMistakes": "Confundir determinístico com sempre seguro; lembre que ECB é determinístico e inseguro para cifragem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar aplicações típicas recomendadas por Schneier",
                                  "subSteps": [
                                    "Identifique usos determinísticos: verificação de integridade (ex: HMAC), assinaturas digitais.",
                                    "Identifique usos probabilísticos: cifragem confidencial (ex: GCM para evitar reutilização de nonce).",
                                    "Analise citações de Schneier: determinísticos para MACs, probabilísticos para modos de cifragem sem padrões.",
                                    "Liste 4 cenários onde cada tipo é preferido, com justificativa.",
                                    "Compare com padrões modernos como NIST SP 800-38."
                                  ],
                                  "verification": "Elaborar uma lista de 8 aplicações (4 por tipo) com referências a Schneier.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Schneier (2015), PDF do NIST SP 800-38, navegador para busca rápida.",
                                  "tips": "Associe cada aplicação a um risco específico que o algoritmo mitiga.",
                                  "learningObjective": "Mapear aplicações padrão de cada algoritmo conforme literatura especializada.",
                                  "commonMistakes": "Ignorar contexto de Schneier; sempre verifique a edição 2015 para precisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver critérios de decisão para contextos criptográficos",
                                  "subSteps": [
                                    "Defina critérios chave: necessidade de confidencialidade vs integridade, risco de reutilização de chaves, desempenho.",
                                    "Crie fluxograma de decisão: 'Precisa de variabilidade? -> Probabilístico; Verificação estática? -> Determinístico'.",
                                    "Avalie trade-offs: probabilísticos mais seguros para cifragem, mas requerem gerenciamento de nonces.",
                                    "Teste critérios em 3 cenários hipotéticos (ex: email seguro, backup de arquivos).",
                                    "Refine com base em Schneier: priorize probabilísticos para privacidade sem padrões."
                                  ],
                                  "verification": "Produzir um fluxograma ou checklist de decisão com 5 critérios principais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de fluxograma como Draw.io ou Lucidchart, Schneier (2015).",
                                  "tips": "Comece com perguntas sim/não para simplificar o fluxograma.",
                                  "learningObjective": "Formular um framework sistemático para escolher algoritmos baseado em requisitos.",
                                  "commonMistakes": "Subestimar nonces em probabilísticos; sempre planeje geração única."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar decisões em cenários reais e validar escolhas",
                                  "subSteps": [
                                    "Selecione 5 cenários reais: HTTPS, blockchain, mensagens instantâneas, assinaturas de software, hashes de arquivos.",
                                    "Aplique critérios para decidir tipo de algoritmo em cada um.",
                                    "Justifique escolhas com referências a Schneier e valide contra práticas atuais (ex: TLS usa AEAD probabilístico).",
                                    "Simule erro: troque tipos e identifique vulnerabilidades.",
                                    "Documente lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Relatório com 5 decisões justificadas, incluindo uma análise de erro.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Casos de estudo online (OWASP, TLS specs), Schneier (2015).",
                                  "tips": "Use exemplos atuais como Signal app (probabilístico para mensagens).",
                                  "learningObjective": "Aplicar conhecimento para tomar decisões corretas em contextos variados.",
                                  "commonMistakes": "Escolher determinístico para cifragem sem justificativa; priorize segurança."
                                }
                              ],
                              "practicalExample": "Em um app de mensagens seguras como WhatsApp, opte por algoritmo probabilístico (ex: AES-GCM) para cifragem de mensagens, evitando reutilização de chaves e padrões detectáveis, conforme Schneier alerta sobre ataques de texto plano conhecido.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre os tipos.",
                                "Escolher corretamente algoritmo para 4 cenários dados (ex: integridade -> determinístico).",
                                "Desenhar fluxograma de decisão sem erros.",
                                "Citar Schneier (2015) em pelo menos 2 justificativas.",
                                "Identificar risco de usar determinístico em cifragem confidencial.",
                                "Validar escolha contra NIST guidelines."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas diferenças: 90% correto.",
                                "Justificativas baseadas em Schneier: pelo menos 3 citações.",
                                "Fluxograma completo e lógico: cobre 5+ critérios.",
                                "Aplicação prática: acerto em 80% dos cenários.",
                                "Análise de trade-offs: identifica prós/contras em todos passos.",
                                "Relatório claro e estruturado: sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e aleatoriedade em algoritmos.",
                                "Ética: Privacidade e implicações de escolhas criptográficas erradas.",
                                "Segurança da Informação: Integração com protocolos como TLS.",
                                "Engenharia de Software: Impacto no design de sistemas seguros."
                              ],
                              "realWorldApplication": "Em sistemas como HTTPS/TLS, probabilísticos (ex: ChaCha20-Poly1305) são usados para tráfego web seguro, prevenindo ataques de reutilização; determinísticos em assinaturas Git para verificação de commits, garantindo integridade sem variabilidade desnecessária."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Criptosistemas Probabilísticos Simétricos",
                    "description": "Uso de IV e nonce em modos de operação como CBC para cifração simétrica probabilística.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Criptosistemas Probabilísticos Simétricos",
                        "description": "Criptosistemas simétricos que incorporam aleatoriedade, como um vetor de inicialização (IV) ou nonce, para gerar cifras diferentes a partir da mesma mensagem de texto plano e chave, evitando padrões e melhorando a segurança contra ataques de texto plano conhecido.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Diferenciar criptosistemas determinísticos e probabilísticos",
                            "description": "Explicar as diferenças entre modos determinísticos (ex.: ECB) e probabilísticos (ex.: CBC com IV), destacando como a aleatoriedade impede a detecção de padrões em mensagens repetidas e mitiga ataques de criptoanálise básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Criptosistemas Determinísticos",
                                  "subSteps": [
                                    "Defina criptosistema determinístico: função de criptografia que produz sempre o mesmo ciphertext para a mesma plaintext e chave.",
                                    "Estude o modo ECB (Electronic Codebook) como exemplo clássico.",
                                    "Criptografe uma mensagem repetida (ex: 'HELLO' duas vezes) usando ECB e observe o padrão nos blocos de ciphertext.",
                                    "Identifique como padrões na plaintext são preservados no ciphertext.",
                                    "Registre as propriedades: previsibilidade e vulnerabilidade a análise de frequência."
                                  ],
                                  "verification": "Produza um ciphertext ECB para uma mensagem repetida e confirme que blocos idênticos aparecem para plaintexts idênticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca Python cryptography",
                                    "Documentação AES-ECB",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use mensagens com padrões óbvios para visualizar o problema facilmente.",
                                  "learningObjective": "Explicar como a determinística preserva padrões na plaintext.",
                                  "commonMistakes": [
                                    "Confundir com modos que usam IV",
                                    "Ignorar que chaves iguais sempre geram mesmo output"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Criptosistemas Probabilísticos",
                                  "subSteps": [
                                    "Defina criptosistema probabilístico: incorpora aleatoriedade (ex: IV - Initialization Vector) para variar o ciphertext mesmo com mesma plaintext e chave.",
                                    "Estude o modo CBC (Cipher Block Chaining) com IV aleatório.",
                                    "Criptografe a mesma mensagem repetida usando CBC com IVs diferentes e observe ciphertexts distintos.",
                                    "Explique o papel do IV: não secreto, mas garante unicidade por sessão.",
                                    "Compare com determinístico: aleatoriedade quebra padrões."
                                  ],
                                  "verification": "Gere dois ciphertexts CBC para a mesma mensagem com IVs diferentes e confirme que são únicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca Python cryptography",
                                    "Documentação AES-CBC",
                                    "Gerador de IV aleatório"
                                  ],
                                  "tips": "Sempre use IVs não reutilizáveis para simular cenários reais.",
                                  "learningObjective": "Descrever como a aleatoriedade mitiga detecção de padrões.",
                                  "commonMistakes": [
                                    "Reutilizar o mesmo IV, tornando-o determinístico",
                                    "Achar que IV é parte da chave secreta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Fundamentais",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: determinístico vs probabilístico (previsibilidade, uso de aleatoriedade, exemplos de modos).",
                                    "Analise impacto em mensagens repetidas: ECB mostra padrões, CBC os oculta.",
                                    "Discuta criptoanálise básica: frequência de letras em ECB é detectável, em CBC não.",
                                    "Simule um ataque simples: matching de blocos em ECB vs falha em CBC.",
                                    "Resuma vantagens: probabilísticos são preferidos para confidencialidade sem padrões."
                                  ],
                                  "verification": "Preencha e valide uma tabela comparativa com exemplos criptografados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Ferramentas de criptografia online como CyberChef"
                                  ],
                                  "tips": "Use imagens de ciphertexts ECB vs CBC para visualização.",
                                  "learningObjective": "Diferenciar propriedades e implicações de segurança.",
                                  "commonMistakes": [
                                    "Ignorar que ambos usam mesma primitiva como AES",
                                    "Subestimar riscos de ECB em dados estruturados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impactos em Ataques e Segurança",
                                  "subSteps": [
                                    "Estude ataques a determinísticos: padding oracle indireto via padrões.",
                                    "Simule detecção de padrões em ECB (ex: imagem criptografada revela contorno).",
                                    "Explique como CBC mitiga: cada bloco depende do anterior e IV.",
                                    "Discuta trade-offs: probabilísticos requerem IV transmissão, mas melhoram segurança.",
                                    "Conclua quando usar cada: ECB só para chaves curtas aleatórias, CBC para dados gerais."
                                  ],
                                  "verification": "Descreva um ataque bem-sucedido em ECB e por que falha em CBC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo clássico: Tux penguin em ECB",
                                    "Artigo 'ECB Penguin'"
                                  ],
                                  "tips": "Pesquise imagens reais de ECB falhas para reforçar aprendizado.",
                                  "learningObjective": "Avaliar riscos de criptoanálise e escolhas de modo.",
                                  "commonMistakes": [
                                    "Achar CBC invulnerável (não é a ataques como padding oracle)",
                                    "Confundir com autenticação"
                                  ]
                                }
                              ],
                              "practicalExample": "Criptografe a mensagem 'Attack at dawn!!Attack at dawn!!' usando AES-ECB (determinístico): blocos idênticos para 'Attack at dawn!!' aparecem repetidos, revelando padrão. No AES-CBC com IV aleatório diferente por execução: ciphertexts variam completamente, ocultando repetições e impedindo matching simples de blocos.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a diferença chave entre determinístico e probabilístico.",
                                "Gerar e comparar ciphertexts de ambos os tipos para mesma mensagem.",
                                "Identificar corretamente ECB como determinístico e CBC como probabilístico.",
                                "Descrever como aleatoriedade previne detecção de padrões em mensagens repetidas.",
                                "Listar um ataque facilitado por determinísticos e mitigado por probabilísticos.",
                                "Criar tabela comparativa precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de cada tipo (90% correto).",
                                "Demonstração prática com código ou ferramenta produzindo resultados esperados.",
                                "Compreensão de impactos em segurança (ex: padrões vs aleatoriedade).",
                                "Uso correto de terminologia (IV, modo, criptoanálise).",
                                "Análise de trade-offs e quando usar cada.",
                                "Clareza na tabela comparativa e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e aleatoriedade em funções injetoras.",
                                "Segurança da Informação: Modos de operação em protocolos como TLS.",
                                "Programação: Implementação de criptografia em Python ou C.",
                                "Estatística: Análise de frequência em criptoanálise.",
                                "Física: Analogia com ruído quântico em criptografia."
                              ],
                              "realWorldApplication": "Em comunicações seguras como HTTPS (TLS usa CBC ou GCM probabilístico para ocultar padrões em tráfego repetido), apps de mensagens (WhatsApp end-to-end usa modos probabilísticos para prevenir análise de texto frequente), e proteção de dados em nuvem onde blocos idênticos em ECB revelariam informações sensíveis duplicadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Identificar vantagens da cifração probabilística simétrica",
                            "description": "Descrever benefícios como resistência a ataques de texto plano escolhido, preservação da confidencialidade semântica e uso em protocolos criptográficos, referenciando exemplos de bibliografia como Menezes et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Cifração Simétrica Determinística vs. Probabilística",
                                  "subSteps": [
                                    "Defina cifração simétrica determinística: mesma chave e plaintext sempre produzem o mesmo ciphertext.",
                                    "Defina cifração simétrica probabilística: incorpora aleatoriedade (nonce/IV), produzindo ciphertexts diferentes para o mesmo plaintext.",
                                    "Explique o papel do nonce/IV na geração de ciphertexts únicos.",
                                    "Identifique cenários onde determinística falha (e.g., vazamento de padrões).",
                                    "Revise exemplos básicos de modos como ECB (determinístico) vs. CBC (probabilístico)."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças principais e forneça um exemplo simples de cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Handbook of Applied Cryptography' de Menezes et al. (Capítulo 7)",
                                    "Notas ou diagrama comparativo"
                                  ],
                                  "tips": "Use diagramas visuais para ilustrar múltiplos ciphertexts do mesmo plaintext.",
                                  "learningObjective": "Diferenciar cifração determinística e probabilística, entendendo o impacto da aleatoriedade.",
                                  "commonMistakes": [
                                    "Confundir nonce com chave secreta",
                                    "Ignorar que ECB é determinístico e inseguro para dados repetitivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Resistência a Ataques de Texto Plano Escolhido (CPA)",
                                  "subSteps": [
                                    "Descreva o ataque CPA: atacante envia plaintexts escolhidos e observa ciphertexts.",
                                    "Explique como cifração determinística vaza informações (e.g., igualdade de plaintexts).",
                                    "Mostre como probabilística resiste: ciphertexts indistinguíveis mesmo para plaintexts iguais.",
                                    "Simule um exemplo: criptografe 'hello' duas vezes em cada modo.",
                                    "Conclua que probabilística atinge IND-CPA security."
                                  ],
                                  "verification": "Crie um cenário CPA fictício e demonstre por que probabilística resiste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef para simular cifragem",
                                    "Referência Menezes et al., Seção 7.2"
                                  ],
                                  "tips": "Foquem em 'indistinguibilidade' como métrica chave de segurança.",
                                  "learningObjective": "Identificar como probabilística previne vazamentos em ataques CPA.",
                                  "commonMistakes": [
                                    "Achar que todos os modos simétricos são CPA-seguros",
                                    "Reutilizar nonce sem perceber riscos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Preservação da Confidencialidade Semântica",
                                  "subSteps": [
                                    "Defina confidencialidade semântica: ciphertext não revela nada sobre plaintext além do comprimento.",
                                    "Compare com determinística: padrões semânticos preservados.",
                                    "Discuta IND-CPA como base para semantic security.",
                                    "Exemplo: criptografar mensagens similares (e.g., 'attack at dawn' vs. 'attack at dusk').",
                                    "Referencie teoremas de segurança em Menezes et al."
                                  ],
                                  "verification": "Explique em termos leigos como semantic security protege contra inferências semânticas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo ou resumo de semantic security",
                                    "Menezes et al., Capítulo 7"
                                  ],
                                  "tips": "Pense em um atacante tentando adivinhar palavras baseadas em padrões.",
                                  "learningObjective": "Compreender como probabilística preserva a semântica do plaintext.",
                                  "commonMistakes": [
                                    "Confundir com autenticação",
                                    "Subestimar ataques de side-channel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Vantagens em Protocolos Criptográficos e Referenciar Literatura",
                                  "subSteps": [
                                    "Liste protocolos que usam probabilística: TLS (AES-GCM), disk encryption (XTS-AES).",
                                    "Descreva benefícios em cenários multi-uso da mesma chave.",
                                    "Cite Menezes et al.: modos como CTR, GCM para probabilistic security.",
                                    "Compare com assimétrica: eficiência simétrica em volume alto.",
                                    "Sintetize todas as vantagens em uma tabela comparativa."
                                  ],
                                  "verification": "Crie uma tabela resumindo 3 vantagens principais com exemplos de protocolos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Menezes et al. (disponível online)",
                                    "Documentação RFC de TLS"
                                  ],
                                  "tips": "Sempre associe teoria a protocolos reais para retenção.",
                                  "learningObjective": "Conectar vantagens teóricas a usos práticos e literatura padrão.",
                                  "commonMistakes": [
                                    "Ignorar overhead computacional da aleatoriedade",
                                    "Generalizar insegurança de todos os modos determinísticos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de mensagens seguras como WhatsApp, use AES-128 em modo GCM (probabilístico) para criptografar 'Olá, mundo!' duas vezes: obtém-se ciphertexts diferentes, resistindo a CPA onde um atacante não distingue mensagens idênticas enviadas múltiplas vezes, ao contrário de ECB determinístico que revelaria padrões.",
                              "finalVerifications": [
                                "Explique 3 vantagens principais sem consultar notas.",
                                "Simule um ataque CPA em determinístico vs. probabilístico.",
                                "Cite pelo menos 2 referências de Menezes et al.",
                                "Identifique um protocolo real usando cifração probabilística.",
                                "Diferencie semantic security de basic confidentiality."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção determinística vs. probabilística (80%+ correto).",
                                "Capacidade de explicar IND-CPA com exemplo prático.",
                                "Referências corretas à literatura (Menezes et al.).",
                                "Identificação de pelo menos 3 vantagens com aplicações.",
                                "Ausência de confusões comuns como nonce=chave.",
                                "Clareza em descrições semânticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e aleatoriedade em distribuições.",
                                "Segurança da Informação: Modelos de adversário e provas de segurança.",
                                "Ciência da Computação: Algoritmos de hashing e modos de operação.",
                                "Ética: Implicações de privacidade em comunicações digitais."
                              ],
                              "realWorldApplication": "Usado em protocolos como TLS 1.3 para HTTPS, protegendo tráfego web contra eavesdropping; em criptografia de disco (BitLocker) para arquivos sensíveis, garantindo que arquivos idênticos não gerem assinaturas detectáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Exemplificar uso em modos de operação simétricos",
                            "description": "Analisar como algoritmos como AES em modo CBC utilizam elementos probabilísticos para cifração segura, comparando com modos públicos e relacionando à criptoanálise básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Criptografia Simétrica e Modos de Operação",
                                  "subSteps": [
                                    "Estude o funcionamento básico de algoritmos simétricos como AES.",
                                    "Identifique modos determinísticos (ex: ECB) versus probabilísticos (ex: CBC).",
                                    "Explique o conceito de Initial Vector (IV) como elemento probabilístico.",
                                    "Liste vantagens da aleatoriedade em cifragem.",
                                    "Revise chaining de blocos em modos de operação."
                                  ],
                                  "verification": "Resuma em um diagrama os modos ECB e CBC, destacando diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação AES (NIST), diagramas de modos de operação online.",
                                  "tips": "Use imagens visuais para entender o fluxo de blocos.",
                                  "learningObjective": "Compreender a distinção entre modos determinísticos e probabilísticos.",
                                  "commonMistakes": "Confundir IV com chave; achar que ECB é seguro para padrões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Modo CBC em AES com Ênfase no IV Probabilístico",
                                  "subSteps": [
                                    "Descreva o processo de cifragem CBC: XOR com IV no primeiro bloco.",
                                    "Simule manualmente cifragem de um bloco simples com IV aleatório.",
                                    "Gere IVs diferentes e observe cifraturas variadas para mesma plaintext.",
                                    "Discuta como o IV previne padrões em cifraturas idênticas.",
                                    "Implemente uma simulação básica em pseudocódigo."
                                  ],
                                  "verification": "Cifre a mesma mensagem duas vezes com IVs diferentes e compare outputs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora hexadecimal, ferramenta online como CyberChef.",
                                  "tips": "Sempre use IV aleatório e único por mensagem.",
                                  "learningObjective": "Dominar o papel do IV na segurança probabilística do CBC.",
                                  "commonMistakes": "Reutilizar IV para mesma chave, levando a vazamento de padrões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar CBC com Modos Determinísticos e Discutir Criptoanálise Básica",
                                  "subSteps": [
                                    "Compare cifraturas ECB vs CBC para imagem com padrões repetidos.",
                                    "Identifique ataques em ECB (análise de frequência de blocos).",
                                    "Explique vulnerabilidades CBC como padding oracle attack.",
                                    "Relacione probabilismo à resistência básica de criptoanálise.",
                                    "Crie tabela comparativa de prós/contras."
                                  ],
                                  "verification": "Demonstre visualmente falha ECB cifrando uma imagem tiled.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos de imagens ECB (Wikipedia), vídeo sobre padding oracle.",
                                  "tips": "Visualize com ferramentas para ver padrões em ECB.",
                                  "learningObjective": "Comparar segurança e relacionar a criptoanálise.",
                                  "commonMistakes": "Subestimar riscos de IV previsível em CBC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Exemplificar AES-CBC em Código",
                                  "subSteps": [
                                    "Instale biblioteca cryptography em Python.",
                                    "Escreva código para cifrar/decifrar com AES-CBC e IV aleatório.",
                                    "Teste com múltiplas execuções mostrando outputs diferentes.",
                                    "Adicione comentários relacionando a probabilismo e criptoanálise.",
                                    "Execute e valide descriptografia correta."
                                  ],
                                  "verification": "Rode o código com 3 mensagens iguais e IVs diferentes; outputs únicos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python 3+, pip install cryptography, editor de código.",
                                  "tips": "Nunca hardcode chaves/IVs; use os.urandom().",
                                  "learningObjective": "Aplicar conceitos em implementação prática.",
                                  "commonMistakes": "Esquecer de transmitir IV junto com ciphertext."
                                }
                              ],
                              "practicalExample": "Usando Python: from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes; from cryptography.hazmat.backends import default_backend; chave = b'16 bytes chave!'; iv = os.urandom(16); cipher = Cipher(algorithms.AES(chave), modes.CBC(iv)); encryptor = cipher.encryptor(); ct = encryptor.update(b'Mensagem repetida') + encryptor.finalize(); Execute múltiplas vezes: ct varia devido ao IV aleatório, demonstrando probabilismo vs ECB fixo.",
                              "finalVerifications": [
                                "Explicar verbalmente como IV torna CBC probabilístico.",
                                "Gerar cifraturas CBC diferentes para mesma plaintext.",
                                "Identificar padrão em ECB e ausência em CBC.",
                                "Descrever um ataque básico em CBC mal usado.",
                                "Implementar código funcional AES-CBC.",
                                "Comparar tabelas de modos de operação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação do IV e chaining CBC (80%+ correto).",
                                "Demonstração prática com código rodando sem erros.",
                                "Comparação clara ECB vs CBC com exemplos visuais.",
                                "Identificação correta de 2+ vulnerabilidades criptanalíticas.",
                                "Uso adequado de IV aleatório em implementações.",
                                "Relacionamento lógico à segurança probabilística."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e aleatoriedade (distribuições uniformes para IV).",
                                "Programação: Implementação segura de criptografia em Python.",
                                "Segurança da Informação: Análise de vulnerabilidades como padding oracle.",
                                "Física: Analogia com ruído quântico em geradores de IV."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS (AES-CBC ou GCM), VPNs (IPsec), e armazenamento seguro de dados (ex: criptografia de disco com IV por setor), prevenindo ataques de chosen-plaintext via aleatoriedade do IV."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Vetor de Inicialização (IV)",
                        "description": "Valor aleatório ou pseudoaleatório usado em modos de operação como CBC para inicializar o processo de cifração, garantindo que cifras idênticas de plaintext resultem em outputs distintos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Definir e caracterizar o IV em cifração simétrica",
                            "description": "Explicar o papel do IV como entrada adicional ao algoritmo de bloco (ex.: AES-CBC), sua necessidade de ser imprevisível e não reutilizado com a mesma chave, conforme Schneier (2015).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Cifração de Bloco Simétrica",
                                  "subSteps": [
                                    "Revise o conceito de cifração simétrica e algoritmos de bloco como AES.",
                                    "Estude modos de operação determinísticos vs. probabilísticos, focando em ECB vs. CBC.",
                                    "Identifique limitações do ECB, como padrões revelados em blocos idênticos.",
                                    "Leia Schneier (2015) sobre a necessidade de aleatoriedade em modos como CBC.",
                                    "Anote definições chave: chave simétrica, bloco de texto plano e cifra."
                                  ],
                                  "verification": "Resuma em 3 frases o que é cifração de bloco e por que ECB é inseguro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Capítulo relevante de Schneier (2015): Cryptography Engineering",
                                    "Documentação AES oficial (NIST SP 800-38A)"
                                  ],
                                  "tips": "Use diagramas visuais para ilustrar como blocos são processados em ECB e CBC.",
                                  "learningObjective": "Entender o contexto onde o IV é necessário para randomização.",
                                  "commonMistakes": [
                                    "Confundir simétrica com assimétrica",
                                    "Ignorar que AES é de bloco fixo (128 bits)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Vetor de Inicialização (IV)",
                                  "subSteps": [
                                    "Defina IV como um valor aleatório de tamanho do bloco (ex.: 128 bits para AES).",
                                    "Explique seu papel: XOR inicial com o primeiro bloco de texto plano em CBC.",
                                    "Descreva como o IV é concatenado à cifra e enviado junto (não secreto).",
                                    "Compare IV com nonce: IV deve ser imprevisível, nonce pode ser contável.",
                                    "Estude diagrama de CBC: IV → XOR → AES → próximo bloco."
                                  ],
                                  "verification": "Desenhe um fluxograma simples de AES-CBC mostrando o IV.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NIST SP 800-38A: Recommendation for Block Cipher Modes",
                                    "Ferramenta online como CyberChef para visualizar CBC"
                                  ],
                                  "tips": "Lembre-se: IV é público, mas único por mensagem/chave.",
                                  "learningObjective": "Definir precisamente o IV e seu uso em algoritmos de bloco.",
                                  "commonMistakes": [
                                    "Pensar que IV é secreto como a chave",
                                    "Confundir tamanho do IV com tamanho da chave"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Caracterizar as Propriedades Essenciais do IV",
                                  "subSteps": [
                                    "Liste propriedades: imprevisível, único por chave/mensagem, gerado aleatoriamente.",
                                    "Explique por que imprevisível: previne ataques de texto plano conhecido.",
                                    "Discuta não-reutilização: mesma IV + chave revela XOR de plaintexts.",
                                    "Estude Schneier (2015) sobre ataques se IV reutilizado (ex.: many-time pad).",
                                    "Verifique geração: use CSPRNG (Cryptographically Secure Pseudo-Random Number Generator)."
                                  ],
                                  "verification": "Explique em uma frase por que IV não pode ser reutilizado com a mesma chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Schneier (2015), seção sobre IVs em modos de operação",
                                    "Artigo 'The Importance of Being Random' de Schneier"
                                  ],
                                  "tips": "Sempre teste IVs com ferramentas como OpenSSL para validar unicidade.",
                                  "learningObjective": "Caracterizar IV como imprevisível e não reutilizável.",
                                  "commonMistakes": [
                                    "Usar IV fixo ou previsível (ex.: zeros)",
                                    "Reutilizar IV em múltiplas mensagens"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Consequências e Melhores Práticas",
                                  "subSteps": [
                                    "Simule reutilização de IV: criptografe duas mensagens iguais e compare cifras.",
                                    "Analise ataques: chosen-plaintext se IV previsível.",
                                    "Defina melhores práticas: gere IV por mensagem, inclua na cifra.",
                                    "Compare com modos sem IV (GCM usa nonce).",
                                    "Documente regras: IV público, mas fresco e aleatório."
                                  ],
                                  "verification": "Identifique 2 riscos de IV mal usado e como mitigar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "OpenSSL ou Python cryptography library para testes",
                                    "Exemplos de código em GitHub sobre AES-CBC"
                                  ],
                                  "tips": "Em produção, use bibliotecas que gerenciam IV automaticamente.",
                                  "learningObjective": "Aplicar conhecimentos para evitar erros comuns com IV.",
                                  "commonMistakes": [
                                    "Não incluir IV na transmissão",
                                    "Usar MD5 para gerar IV (inseguro)"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python com cryptography: gere IV aleatório, criptografe 'Hello World' com AES-CBC e chave fixa. Repita com novo IV: cifras diferentes. Reutilize IV com 'Hello World' novamente: cifras idênticas, demonstrando risco.",
                              "finalVerifications": [
                                "Defina IV em 1 frase correta.",
                                "Explique papel em CBC com diagrama.",
                                "Liste 3 propriedades obrigatórias.",
                                "Descreva ataque de reutilização de IV.",
                                "Cite Schneier (2015) sobre IVs.",
                                "Gere e use IV corretamente em código simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e papel do IV (20%)",
                                "Correta caracterização de propriedades (imprevisível, único) (25%)",
                                "Compreensão de riscos de reutilização (25%)",
                                "Referência adequada a Schneier e padrões NIST (15%)",
                                "Exemplo prático demonstrado (10%)",
                                "Clareza em verificações e substeps (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações XOR e teoria da probabilidade para aleatoriedade.",
                                "Segurança da Informação: Aplicações em protocolos como TLS/SSL.",
                                "Programação: Implementação em linguagens como Python (cryptography lib).",
                                "Ética: Importância de práticas seguras para proteção de dados.",
                                "Física: Analogia com chaves quânticas seguras (futuro da cripto)."
                              ],
                              "realWorldApplication": "Em comunicações seguras como HTTPS (TLS usa IV em AEAD modes derivados de CBC), apps de mensagens (WhatsApp Signal Protocol), VPNs (IPsec), e armazenamento criptografado (FileVault, BitLocker), onde IV garante que mensagens idênticas produzam cifras únicas, prevenindo análise de padrões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Demonstrar geração e transmissão do IV",
                            "description": "Descrever métodos de geração segura de IV (ex.: usando gerador criptográfico) e como ele é transmitido junto à cifra sem comprometer a segurança, ilustrando com modo CBC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Propósito do Vetor de Inicialização (IV)",
                                  "subSteps": [
                                    "Defina IV como um valor aleatório usado em criptosistemas probabilísticos para garantir que a mesma plaintext produza cifras diferentes.",
                                    "Explique por que IV é essencial no modo CBC: evita padrões previsíveis e ataques de texto plano escolhido.",
                                    "Discuta propriedades do IV: deve ser imprevisível, único por mensagem e não secreto.",
                                    "Compare IV com nonce em outros modos como GCM.",
                                    "Revise exemplos de falhas sem IV adequado, como reutilização levando a ataques."
                                  ],
                                  "verification": "Resuma em 3-5 frases o papel do IV no CBC e liste 2 riscos de má geração/transmissão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de criptografia (ex.: NIST SP 800-38A), diagrama CBC online.",
                                  "tips": "Use diagramas visuais para ilustrar como IV afeta o primeiro bloco no CBC.",
                                  "learningObjective": "Explicar o propósito e propriedades do IV em criptografia simétrica probabilística.",
                                  "commonMistakes": "Confundir IV com chave secreta ou achar que IV precisa ser confidencial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Métodos Seguros de Geração de IV",
                                  "subSteps": [
                                    "Aprenda a usar geradores criptográficos seguros (CSPRNG) como os da biblioteca cryptography em Python ou Crypto++ em C++.",
                                    "Gere IV de tamanho apropriado: 128 bits para AES-CBC.",
                                    "Entenda fontes de entropia: /dev/urandom no Linux, CryptGenRandom no Windows.",
                                    "Evite geradores fracos como rand() da stdlib.",
                                    "Teste unicidade gerando múltiplos IVs e verificando colisões (deve ser improvável)."
                                  ],
                                  "verification": "Gere 10 IVs e confirme que todos são únicos e de tamanho correto via código simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Biblioteca cryptography (Python), ambiente de programação (Jupyter Notebook).",
                                  "tips": "Sempre inicialize CSPRNG corretamente para alta entropia.",
                                  "learningObjective": "Identificar e aplicar métodos seguros para gerar IVs criptograficamente aleatórios.",
                                  "commonMistakes": "Usar random.seed() baseado em tempo ou PID, levando a previsibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Geração de IV e Encriptação em Modo CBC",
                                  "subSteps": [
                                    "Escreva código para gerar IV com CSPRNG.",
                                    "Encripte uma plaintext usando AES-CBC com o IV gerado.",
                                    "Prefixe o IV à ciphertext (transmissão padrão: IV || ciphertext).",
                                    "Teste descriptação: extraia IV do prefixo e decripte corretamente.",
                                    "Repita com a mesma plaintext e IV diferente para mostrar saída única."
                                  ],
                                  "verification": "Execute código: encripte 'Hello World' duas vezes, confirme cifras diferentes e descriptação perfeita.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com pip install cryptography, editor de código (VS Code).",
                                  "tips": "Codifique IV em base64 para transmissão legível se necessário.",
                                  "learningObjective": "Implementar geração de IV e integrá-lo ao processo CBC.",
                                  "commonMistakes": "Padding incorreto ou não prefixar IV, causando falha na descriptação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Transmissão Segura do IV e Verificar Segurança",
                                  "subSteps": [
                                    "Simule transmissão: envie IV || ciphertext via socket ou arquivo.",
                                    "No receptor: extraia IV (primeiros N bytes), use para descriptar.",
                                    "Analise segurança: prove que IV público não revela chave ou plaintext.",
                                    "Teste ataques simulados: reutilize IV e mostre falha (XOR de plaintexts).",
                                    "Documente o processo em um relatório curto com código e saídas."
                                  ],
                                  "verification": "Compartilhe código e saída mostrando transmissão bem-sucedida e falha com IV reutilizado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python sockets ou arquivo de texto para simulação de transmissão.",
                                  "tips": "Use wireshark para visualizar transmissão real se possível.",
                                  "learningObjective": "Demonstrar transmissão de IV sem comprometer segurança em CBC.",
                                  "commonMistakes": "Reutilizar IV entre mensagens ou escondê-lo como secreto."
                                }
                              ],
                              "practicalExample": "Em Python com cryptography: gere IV = os.urandom(16), encripte mensagem com AES-CBC, transmita b64encode(IV + ciphertext). Receptor faz b64decode, extrai IV[:16], decripte. Exemplo: 'Mensagem secreta' vira IV diferente a cada vez, descripta perfeitamente.",
                              "finalVerifications": [
                                "IV gerado é de 128 bits e único por mensagem.",
                                "Transmissão prefixada permite descriptação correta sem chave.",
                                "Reutilização de IV revela plaintext via XOR de cifras.",
                                "Código usa CSPRNG, não gerador fraco.",
                                "Explicação cobre por que IV é público mas imprevisível.",
                                "Testes incluem múltiplas encriptações/decriptações."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explica IV, CBC e segurança (30%)",
                                "Implementação funcional: código gera/transmite IV corretamente (30%)",
                                "Demonstração de segurança: mostra riscos de má prática (20%)",
                                "Clareza da documentação: passos e saídas bem explicados (10%)",
                                "Testes abrangentes: unicidade, transmissão, falhas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e entropia em CSPRNG.",
                                "Programação: Uso de bibliotecas criptográficas seguras.",
                                "Segurança da Informação: Princípios de design criptográfico.",
                                "Redes: Transmissão de dados em protocolos como TLS."
                              ],
                              "realWorldApplication": "Em protocolos como TLS 1.3 (usa IVs em AEAD), apps de mensagens (Signal/WhatsApp) prefixam IV/nonce em cifras para proteger chats end-to-end contra replay e padrões."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Analisar riscos de reutilização de IV",
                            "description": "Explicar consequências de reutilizar IV com a mesma chave, como recuperação de XOR de plaintexts, e medidas preventivas baseadas em Paar & Pelzl (2010).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Papel do Vetor de Inicialização (IV) em Criptosistemas Probabilísticos",
                                  "subSteps": [
                                    "Estude a definição de IV em modos de operação como CBC (Cipher Block Chaining).",
                                    "Explique como o IV garante que criptogramas diferentes sejam produzidos para o mesmo plaintext.",
                                    "Compare criptografia determinística vs. probabilística, destacando o papel do IV na segunda.",
                                    "Leia a seção relevante de Paar & Pelzl (2010) sobre IVs em criptosistemas simétricos.",
                                    "Anote exemplos de modos de operação que usam IV (CBC, CTR)."
                                  ],
                                  "verification": "Resuma em 3 frases o propósito do IV e liste 2 modos que o utilizam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro Paar & Pelzl (2010)",
                                    "Notas de aula sobre modos de operação",
                                    "Documentação de AES-CBC"
                                  ],
                                  "tips": "Visualize o IV como uma 'semente aleatória' que randomiza cada criptografia.",
                                  "learningObjective": "Compreender o mecanismo fundamental do IV para evitar reutilização acidental.",
                                  "commonMistakes": "Confundir IV com chave; achar que IV é opcional em todos os modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Consequências Matemáticas da Reutilização de IV",
                                  "subSteps": [
                                    "Derive a equação de criptografia CBC: C_i = E_k(P_i XOR C_{i-1}), com C_0 = IV.",
                                    "Mostre que, com mesmo IV e chave, C1_0 = C2_0 = IV, levando a C1_1 XOR C2_1 = P1_1 XOR P2_1.",
                                    "Explique como o XOR de dois plaintexts pode ser recuperado sem conhecer a chave.",
                                    "Calcule um exemplo numérico simples com blocos de 1 byte para ilustrar.",
                                    "Discuta impacto em toda a cadeia de blocos subsequentes."
                                  ],
                                  "verification": "Escreva a derivação matemática e compute XOR para um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python para XOR",
                                    "Papel e caneta para derivações",
                                    "Referência Paar & Pelzl (2010)"
                                  ],
                                  "tips": "Use blocos pequenos inicialmente para facilitar cálculos manuais.",
                                  "learningObjective": "Dominar a matemática por trás da vulnerabilidade de reutilização de IV.",
                                  "commonMistakes": "Ignorar propagação para blocos subsequentes; confundir XOR com soma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Ataque Prático de Reutilização de IV",
                                  "subSteps": [
                                    "Implemente uma função simples em Python para criptografar duas mensagens com AES-CBC, usando mesmo IV e chave.",
                                    "Capture os ciphertexts e compute XOR entre blocos correspondentes.",
                                    "Recupere o XOR dos plaintexts originais e discuta o que um atacante pode inferir.",
                                    "Teste com mensagens conhecidas (ex: 'Hello' e 'World') para validar.",
                                    "Analise limitações do ataque (ex: precisa de dois ciphertexts alinhados)."
                                  ],
                                  "verification": "Execute o código e produza output mostrando recuperação de XOR de plaintexts.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com pycryptodome",
                                    "Código template para AES-CBC",
                                    "Dois plaintexts de teste"
                                  ],
                                  "tips": "Use chaves e IVs fixos para reprodutibilidade; debugue com print de blocos.",
                                  "learningObjective": "Aplicar o conhecimento teórico em uma simulação de ataque realista.",
                                  "commonMistakes": "Padding incorreto alterando blocos; não alinhar mensagens corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Medidas Preventivas e Boas Práticas",
                                  "subSteps": [
                                    "Liste recomendações de Paar & Pelzl (2010): IV único por mensagem.",
                                    "Discuta geração de IVs aleatórios (128 bits para AES) e verificação de unicidade.",
                                    "Explore nonce em CTR mode como alternativa sem reutilização.",
                                    "Revise padrões como NIST SP 800-38A para IV handling.",
                                    "Proponha políticas para aplicações: nunca reutilizar IV com mesma chave."
                                  ],
                                  "verification": "Crie uma checklist de 5 itens para prevenir reutilização de IV em um projeto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NIST SP 800-38A",
                                    "Paar & Pelzl (2010)",
                                    "Exemplos de código seguros"
                                  ],
                                  "tips": "Armazene IV junto ao ciphertext, mas gere novo a cada uso.",
                                  "learningObjective": "Aplicar medidas preventivas baseadas em literatura para mitigar riscos.",
                                  "commonMistakes": "Usar IVs previsíveis como contadores sem sal; ignorar colisões em IVs curtos."
                                }
                              ],
                              "practicalExample": "Criptografe 'Attack at dawn' e 'Attack at dusk' com AES-CBC, mesma chave K e IV=0. O atacante, com C1 e C2, computa C1[1] XOR C2[1] = ('dawn'[0] XOR 'dusk'[0]), revelando 'd' XOR 'd' = 0, e assim por diante, permitindo inferir diferenças nos plaintexts.",
                              "finalVerifications": [
                                "Explicar verbalmente o risco de reutilização de IV em <1 minuto.",
                                "Derivar corretamente a equação de recuperação de XOR.",
                                "Executar simulação em Python sem erros.",
                                "Listar 3 medidas preventivas de Paar & Pelzl.",
                                "Identificar vulnerabilidade em um ciphertext dado com IV reutilizado.",
                                "Propor IV seguro para uma aplicação hipotética."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação do ataque (90% correto).",
                                "Implementação funcional da simulação sem bugs de padding/IV.",
                                "Compreensão demonstrada via explicação clara de consequências.",
                                "Checklist de preventivas alinhada com padrões NIST/Paar & Pelzl.",
                                "Criatividade em exemplos práticos e conexões reais.",
                                "Tempo de execução dentro dos estimados com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise XOR e álgebra modular.",
                                "Probabilidade: Geração de IVs aleatórios e colisão birthday.",
                                "Segurança da Informação: Análise de side-channel e chosen-plaintext attacks.",
                                "Programação: Implementação segura de criptografia em Python.",
                                "Ética: Implicações de falhas criptográficas em privacidade de dados."
                              ],
                              "realWorldApplication": "Em protocolos como WPA2 (onde IV reuse em TKIP levou ao ataque Beck-Tews) ou TLS/SSL, reutilização de IV permite ataques que decifram tráfego Wi-Fi ou HTTPS, resultando em breaches de dados; desenvolvedores usam IVs únicos para proteger comunicações seguras em apps bancários e VPNs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Nonce em Criptosistemas Probabilísticos",
                        "description": "Número utilizado uma única vez (Number used ONCE), similar ao IV mas com garantia estrita de unicidade, usado em modos como CTR ou GCM para probabilisticidade sem necessidade de confidencialidade no próprio nonce.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Diferenciar IV e nonce",
                            "description": "Comparar IV (pode ser público e aleatório) com nonce (sequencial ou contraintuitivo, mas único por chave), destacando usos em CBC vs. modos stream como CTR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Initialization Vector (IV)",
                                  "subSteps": [
                                    "Defina IV como um vetor de inicialização aleatório e público usado em modos de operação de cifra simétrica como CBC.",
                                    "Explique que o IV garante que o mesmo plaintext produza ciphertext diferente em cada criptografia.",
                                    "Discuta propriedades: aleatoriedade, tamanho igual ao bloco (ex: 128 bits para AES), pode ser reutilizado se plaintext diferente.",
                                    "Estude exemplos em documentações como NIST SP 800-38A.",
                                    "Anote as funções principais: evitar padrões em plaintext repetido e fornecer probabilisticidade."
                                  ],
                                  "verification": "Escreva uma definição precisa do IV e liste 3 propriedades chave em um resumo de 100 palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-38A",
                                    "Artigo Wikipedia sobre Modos de Cifra",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre associe IV a modos de bloco como CBC/ECB para fixar o conceito.",
                                  "learningObjective": "Identificar o papel e propriedades do IV em criptosistemas simétricos probabilísticos.",
                                  "commonMistakes": [
                                    "Confundir IV com chave secreta",
                                    "Achar que IV deve ser secreto",
                                    "Reutilizar IV com mesmo plaintext"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de Nonce (Number used once)",
                                  "subSteps": [
                                    "Defina nonce como um valor único por chave, frequentemente sequencial ou counter-based, usado em modos stream como CTR.",
                                    "Explique que nonce não precisa ser secreto, mas deve ser único para evitar reutilização que compromete segurança.",
                                    "Discuta propriedades: previsível ou contraintuitivo, tamanho fixo (ex: 96 bits em GCM), incrementado por uso.",
                                    "Compare com IV: nonce é estritamente único por chave, enquanto IV pode ser público mas aleatório.",
                                    "Revise exemplos em AES-GCM ou ChaCha20-Poly1305."
                                  ],
                                  "verification": "Crie um diagrama comparando estrutura de nonce vs IV e explique unicidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RFC 5116 para AES-CTR",
                                    "Documentação libsodium sobre nonces",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Lembre: 'Number used ONCE' – unicidade é crítica, não aleatoriedade absoluta.",
                                  "learningObjective": "Distinguir propriedades e usos do nonce em modos de operação stream.",
                                  "commonMistakes": [
                                    "Tratar nonce como totalmente aleatório",
                                    "Reutilizar nonce com mesma chave",
                                    "Confundir com IV em todos os contextos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar IV e Nonce diretamente",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: aleatoriedade (IV sim, nonce não necessariamente), unicidade (ambos, mas nonce por chave), reutilização (IV ok se plaintext diferente, nonce nunca com mesma chave).",
                                    "Analise impactos de misuse: reutilizar IV em CBC vaza plaintext; reutilizar nonce em CTR revela keystream XOR.",
                                    "Discuta contextos: IV em CBC para blocos, nonce em CTR para streams.",
                                    "Simule cenários: criptografar 'hello' duas vezes com mesmo IV/nonce e observe diferenças.",
                                    "Resuma diferenças chave em bullet points."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças e envie para auto-revisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Exemplos de código Python com cryptography library"
                                  ],
                                  "tips": "Use mnemônicos: IV = 'Inicia Variado', Nonce = 'Nunca Once'.",
                                  "learningObjective": "Articular diferenças fundamentais entre IV e nonce com exemplos precisos.",
                                  "commonMistakes": [
                                    "Ignorar dependência de chave para nonce",
                                    "Achar ambos sempre aleatórios",
                                    "Não considerar modos de operação específicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos em contextos de uso (CBC vs CTR)",
                                  "subSteps": [
                                    "Implemente criptografia AES-CBC com IV aleatório e observe ciphertext único.",
                                    "Implemente AES-CTR com nonce sequencial e verifique unicidade por chave.",
                                    "Simule ataque: reutilize IV em CBC (pattern oracle) vs nonce em CTR (two-time pad).",
                                    "Analise protocolos reais: TLS usa IV em CBC, nonce em GCM.",
                                    "Documente lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Execute código de exemplo e capture saídas mostrando diferenças em ciphertexts.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com biblioteca cryptography ou pycryptodome",
                                    "Ambiente Jupyter Notebook",
                                    "Documentação OpenSSL"
                                  ],
                                  "tips": "Teste com plaintexts idênticos para ver impactos claros.",
                                  "learningObjective": "Demonstrar usos práticos de IV e nonce em modos específicos.",
                                  "commonMistakes": [
                                    "Usar modo errado no código",
                                    "Gerar IV/nonce não aleatório/único",
                                    "Ignorar padding em CBC"
                                  ]
                                }
                              ],
                              "practicalExample": "Criptografe a mensagem 'Attack at dawn' duas vezes com AES-128: (1) Em CBC com IV aleatório diferente – ciphertexts distintos; (2) Em CTR com mesmo nonce e chave – keystream idêntico, XOR revela plaintext. Isso destaca IV probabilistic vs nonce uniqueness.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças chave entre IV e nonce.",
                                "Identifique modo de operação adequado baseado em IV/nonce.",
                                "Detecte misuse em um cenário hipotético de criptografia.",
                                "Crie tabela comparativa precisa.",
                                "Implemente código simples sem reutilização.",
                                "Discuta impactos de segurança de confusões."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de IV e nonce (90% match com standards).",
                                "Correta identificação de propriedades únicas (aleatoriedade vs unicidade).",
                                "Uso correto em exemplos CBC/CTR.",
                                "Compreensão de riscos de misuse.",
                                "Clareza na tabela comparativa e explicações.",
                                "Aplicação prática via código sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e aleatoriedade em geração de IV.",
                                "Programação: Implementação segura de criptografia em Python/Rust.",
                                "Segurança da Informação: Análise de ataques como two-time pad.",
                                "Redes: Uso em protocolos TLS/IPsec.",
                                "Engenharia de Software: Melhores práticas em bibliotecas crypto."
                              ],
                              "realWorldApplication": "Em VPNs como WireGuard (usa nonce em ChaCha20), TLS 1.3 (nonce em AEAD), ou apps de mensagens como Signal (nonce para forward secrecy), diferenciando IV/nonce previne vazamentos de dados sensíveis em comunicações seguras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Explicar papel do nonce em modos de operação",
                            "description": "Descrever como nonce garante unicidade em algoritmos simétricos probabilísticos, prevenindo colisões e ataques, com exemplos de protocolos criptográficos (Menezes, 1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de Nonce",
                                  "subSteps": [
                                    "Defina nonce como 'Number used ONCE' (número usado uma única vez).",
                                    "Diferencie nonce de IV (Initialization Vector): nonce é estritamente único por chave, IV pode ser previsível em alguns modos.",
                                    "Explique por que unicidade é crucial em criptografia probabilística.",
                                    "Leia seção relevante de Menezes (1996) sobre primitivas criptográficas.",
                                    "Anote exemplos de nonces em contextos cotidianos, como tickets únicos."
                                  ],
                                  "verification": "Escreva uma definição precisa de nonce em 2-3 frases e cite uma diferença chave com IV.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Handbook of Applied Cryptography' (Menezes, 1996)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogia: nonce é como um bilhete de loteria único para evitar duplicatas.",
                                  "learningObjective": "Definir nonce e sua importância para unicidade em criptosistemas.",
                                  "commonMistakes": [
                                    "Confundir nonce com chave secreta.",
                                    "Achar que nonce é sempre aleatório (pode ser contador)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar algoritmos simétricos probabilísticos",
                                  "subSteps": [
                                    "Revise modos de operação determinísticos vs. probabilísticos (ex: ECB vs. CTR).",
                                    "Identifique problemas de reutilização de inputs em modos como CTR: keystream reutilizado leva a XOR recovery.",
                                    "Calcule manualmente um exemplo simples de colisão sem nonce único.",
                                    "Estude como nonce é concatenado ao contador em modos como GCM ou ChaCha20.",
                                    "Discuta entropia necessária para nonces (128 bits recomendados)."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando input duplicado em CTR levando a plaintext recovery.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef para simular CTR",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Lembre: Em CTR, nonce + counter = unique block index.",
                                  "learningObjective": "Explicar como falta de unicidade causa vazamento de plaintext em algoritmos probabilísticos.",
                                  "commonMistakes": [
                                    "Ignorar que nonce protege contra ataques de chosen-plaintext.",
                                    "Confundir probabilístico com não-determinístico."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o papel do nonce em modos de operação específicos",
                                  "subSteps": [
                                    "Estude modo CTR: nonce inicializa contador para keystream único.",
                                    "Examine GCM: nonce em GHASH para autenticação e encriptação.",
                                    "Compare com CCM ou OCB, destacando restrições de reutilização.",
                                    "Simule encriptação com nonce reutilizado vs. único usando pseudocódigo.",
                                    "Verifique especificações RFC (ex: RFC 5116 para nonces em AES-GCM)."
                                  ],
                                  "verification": "Implemente pseudocódigo para CTR com nonce e demonstre falha em reutilização.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo editor (ex: Python IDLE)",
                                    "RFCs online (ietf.org)"
                                  ],
                                  "tips": "Sempre incremente contador após nonce para evitar wrap-around.",
                                  "learningObjective": "Descrever mecanismo exato de nonce em pelo menos 2 modos de operação.",
                                  "commonMistakes": [
                                    "Reutilizar nonce em sessões diferentes.",
                                    "Usar nonces curtos suscetíveis a birthday attacks."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em protocolos criptográficos e prevenção de ataques",
                                  "subSteps": [
                                    "Analise uso em TLS 1.3: nonce por record para AEAD.",
                                    "Estude IPsec/ESP: nonce em modos como GCM para unicidade.",
                                    "Discuta ataques reais: BEAST (nonce predictability em TLS 1.0).",
                                    "Liste protocolos que falharam por má gestão de nonce (ex: WEP).",
                                    "Crie um checklist para implementação segura de nonces."
                                  ],
                                  "verification": "Explique como nonce previne 2 ataques específicos com exemplos de protocolos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação TLS/IPsec",
                                    "Artigos sobre ataques BEAST/POODLE"
                                  ],
                                  "tips": "Gere nonces com CSPRNG ou contadores monotonicamente crescentes.",
                                  "learningObjective": "Conectar nonce a protocolos reais e mitigar riscos de colisão.",
                                  "commonMistakes": [
                                    "Subestimar tamanho do nonce.",
                                    "Reutilizar em múltiplas chaves."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule encriptação AES-CTR: Use nonce 'abc123' para criptografar 'Hello' resultando em keystream único. Reutilize nonce com 'World' e XOR para recuperar plaintext original, demonstrando ataque. Gere novo nonce e veja unicidade restaurada.",
                              "finalVerifications": [
                                "Explique nonce em palavras próprias sem consultar notas.",
                                "Identifique 3 modos de operação que usam nonce.",
                                "Descreva um ataque causado por nonce reutilizado.",
                                "Diferencie nonce de IV em 2 exemplos.",
                                "Crie diagrama de fluxo para CTR com nonce.",
                                "Liste 2 protocolos que dependem de nonces únicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de nonce e unicidade (20%)",
                                "Compreensão de colisões em modos probabilísticos (25%)",
                                "Exemplos corretos de modos/protocols (20%)",
                                "Identificação de ataques e prevenções (20%)",
                                "Clareza em diagramas/explicações (10%)",
                                "Checklist de melhores práticas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e birthday paradox para tamanho de nonce.",
                                "Redes: Protocolos TLS/IPsec em comunicações seguras.",
                                "Segurança da Informação: Análise de vulnerabilidades como BEAST.",
                                "Programação: Implementação em Python com cryptography library.",
                                "Ética: Implicações de falhas criptográficas em privacidade."
                              ],
                              "realWorldApplication": "Em navegadores web, nonces em TLS 1.3 garantem que sessões HTTPS únicas previnam ataques de replay ou decryption oracles, protegendo dados bancários e comunicações privadas diariamente."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Criptosistemas Probabilísticos de Chave Pública",
                    "description": "Esquemas como ElGamal e padding OAEP no RSA para cifração probabilística.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Criptosistema ElGamal Probabilístico",
                        "description": "Esquema de criptografia de chave pública probabilística baseado no problema do logaritmo discreto, onde cada cifração utiliza um valor aleatório para garantir IND-CPA.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Gerar chaves no ElGamal",
                            "description": "Explicar e implementar a geração de chaves públicas e privadas no criptosistema ElGamal, incluindo a escolha de um primo grande p, um gerador g e o cálculo da chave pública h = g^x mod p.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar o primo grande p",
                                  "subSteps": [
                                    "Estude a importância de p ser um número primo grande para segurança (ex: 1024 bits ou mais em produção).",
                                    "Para fins educacionais, escolha um primo pequeno como p=23 para demonstração.",
                                    "Use ferramentas ou testes para verificar se o número escolhido é primo (ex: teste de Miller-Rabin).",
                                    "Registre o valor de p e justifique sua escolha (tamanho e primalidade).",
                                    "Discuta trade-offs: p pequeno para aprendizado vs. p grande para segurança real."
                                  ],
                                  "verification": "Execute um teste de primalidade e confirme que p é primo (ex: usando sympy.isprime(p) em Python).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca Python sympy ou sage para testes de primalidade",
                                    "Lista de primos pequenos",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com primos pequenos para prática; em produção, gere p usando bibliotecas criptográficas como OpenSSL.",
                                  "learningObjective": "Compreender o papel do módulo primo p na segurança do ElGamal.",
                                  "commonMistakes": [
                                    "Escolher números pares ou compostos",
                                    "Ignorar o tamanho de p, comprometendo segurança",
                                    "Não verificar primalidade adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher o gerador primitivo g",
                                  "subSteps": [
                                    "Aprenda que g deve ser um gerador primitivo do grupo multiplicativo Z_p* (ordem p-1).",
                                    "Teste candidatos g (tipicamente pequenos, 2 a p-1) verificando se g^{(p-1)/q} ≠ 1 mod p para todos fatores q de p-1.",
                                    "Para p=23, teste g=5: fatores de 22=2*11, verifique 5^{11} mod 23 ≠1 e 5^{22/2}=5^{11} mod23 ≠1.",
                                    "Registre g e prove que é gerador usando fatoração de p-1.",
                                    "Implemente uma função para encontrar g automaticamente."
                                  ],
                                  "verification": "Confirme que a ordem de g é exatamente p-1 testando contra fatores primos de p-1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fatorizador de números (sympy.factorint)",
                                    "Código Python para exponenciação modular (pow(g, exp, p))",
                                    "Tabela de fatores de p-1"
                                  ],
                                  "tips": "Use g=2 ou 5 como candidatos iniciais; bibliotecas como cryptography podem gerar automaticamente.",
                                  "learningObjective": "Dominar a seleção de geradores primitivos para garantir o espaço completo de chaves.",
                                  "commonMistakes": [
                                    "Escolher g que não gera todo o grupo (ordem < p-1)",
                                    "Não fatorar p-1 corretamente",
                                    "Usar g=1 ou g=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar a chave privada x",
                                  "subSteps": [
                                    "Escolha x aleatoriamente no intervalo 2 ≤ x ≤ p-2 para segurança.",
                                    "Use um gerador de números aleatórios criptograficamente seguros (ex: secrets module em Python).",
                                    "Para demonstração com p=23, escolha x=6.",
                                    "Registre x como secreto (chave privada).",
                                    "Discuta por que x não deve ser 1 ou p-1 (chaves fracas)."
                                  ],
                                  "verification": "Verifique que 1 < x < p-1 e que x é inteiro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python secrets.token_bytes() para aleatoriedade",
                                    "Calculadora para intervalo"
                                  ],
                                  "tips": "Nunca use random() para chaves reais; sempre criptograficamente seguro.",
                                  "learningObjective": "Entender a geração segura de expoentes privados no ElGamal.",
                                  "commonMistakes": [
                                    "Escolher x=1 (h=g^1=g, previsível)",
                                    "Usar gerador não-seguro",
                                    "x fora do intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a chave pública h = g^x mod p",
                                  "subSteps": [
                                    "Implemente exponenciação modular eficiente (ex: pow(g, x, p) em Python).",
                                    "Para exemplo: g=5, x=6, p=23 → 5^6 mod 23 = 15625 mod 23 = 8.",
                                    "Calcule manualmente passos intermediários: 5^1=5, 5^2=2, 5^3=10, 5^4=4, 5^5=20, 5^6=8 mod 23.",
                                    "Registre h como chave pública (p, g, h).",
                                    "Teste com código para confirmar cálculo."
                                  ],
                                  "verification": "Compute h independentemente e compare; confirme h ≠ 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python ou JavaScript para pow",
                                    "Papel e caneta para cálculo manual"
                                  ],
                                  "tips": "Use built-in pow para eficiência; evite loops ingênuos para grandes expoentes.",
                                  "learningObjective": "Implementar corretamente o cálculo da chave pública usando aritmética modular.",
                                  "commonMistakes": [
                                    "Erro em cálculo modular",
                                    "Exponenciação ingênua (lenta para p grande)",
                                    "Revelar x ao calcular h"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a validade das chaves geradas",
                                  "subSteps": [
                                    "Confirme: p primo, g gerador, 1 < x < p-1, 1 < h < p, h = g^x mod p.",
                                    "Teste se alguém pode recuperar x de (p,g,h) (não deve ser trivial).",
                                    "Gere par de chaves em código e exporte como JSON ou PEM-like.",
                                    "Simule uso: gere chaves para um par ElGamal completo.",
                                    "Documente o par: privada (p,g,x), pública (p,g,h)."
                                  ],
                                  "verification": "Execute script de validação que checa todas as propriedades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Script Python de validação",
                                    "Exemplo de código ElGamal"
                                  ],
                                  "tips": "Armazene chaves separadamente; pública pode ser compartilhada.",
                                  "learningObjective": "Validar um par de chaves ElGamal completo para uso seguro.",
                                  "commonMistakes": [
                                    "h=1 (x=0)",
                                    "Não verificar g como gerador",
                                    "Misturar chaves pública/privada"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo completo: p=23 (primo), g=5 (gerador), x=6 (privada), h=pow(5,6,23)=8 (pública). Par: Privada=(23,5,6), Pública=(23,5,8). Implemente em Python: import secrets; p=23; g=5; x=secrets.randbelow(p-2)+2; h=pow(g,x,p); print(f'Chaves: pub={h}, priv={x}')",
                              "finalVerifications": [
                                "p é primo e suficientemente grande para contexto.",
                                "g tem ordem p-1 no grupo Z_p*.",
                                "1 < x < p-1 e gerado aleatoriamente.",
                                "h = g^x mod p e 1 < h < p.",
                                "Ninguém pode recuperar x facilmente de (p,g,h).",
                                "Chaves podem ser usadas em criptografia ElGamal sem erros."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática em todos os cálculos (ex: h exato).",
                                "Escolha adequada de p, g e x com justificativa.",
                                "Implementação eficiente e segura (ex: pow modular, rand seguro).",
                                "Validação completa das propriedades das chaves.",
                                "Documentação clara do processo e exemplo.",
                                "Ausência de erros comuns como chaves fracas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números, grupos cíclicos, aritmética modular.",
                                "Programação: Implementação de algoritmos criptográficos em Python/Java.",
                                "Segurança da Informação: Princípios de geração de chaves seguras.",
                                "Física/Engenharia: Aplicações em comunicações quânticas resistentes."
                              ],
                              "realWorldApplication": "Geração de chaves para protocolos como PGP, SSL/TLS e VPNs, permitindo criptografia assimétrica segura em comunicações online, assinaturas digitais e troca de chaves em sistemas distribuídos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Cifrar mensagens no ElGamal",
                            "description": "Descrever o processo de cifração probabilística: escolher k aleatório, calcular c1 = g^k mod p e c2 = m * h^k mod p, formando o par (c1, c2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Preparar os Parâmetros Públicos e a Mensagem",
                                  "subSteps": [
                                    "Identifique os parâmetros públicos: primo p, gerador g e chave pública h = g^x mod p (onde x é privado).",
                                    "Converta a mensagem m em um número inteiro entre 0 e p-1 (ex: ASCII ou numérico).",
                                    "Verifique que m < p para evitar erros modulares.",
                                    "Anote todos os valores em um local acessível para cálculos subsequentes.",
                                    "Confirme que p é primo e g é um gerador primitivo do grupo multiplicativo mod p."
                                  ],
                                  "verification": "Liste corretamente p, g, h e m com suas propriedades verificadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Tabela de logaritmos discretos opcionais",
                                    "Calculadora para verificação de primalidade"
                                  ],
                                  "tips": "Use ferramentas online como Wolfram Alpha para verificar se g é gerador mod p inicialmente.",
                                  "learningObjective": "Preparar todos os componentes necessários para a cifração ElGamal de forma precisa.",
                                  "commonMistakes": [
                                    "Escolher m >= p sem reduzir mod p",
                                    "Confundir h com a chave privada x",
                                    "Usar p não primo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o Expoente Aleatório k",
                                  "subSteps": [
                                    "Escolha k aleatoriamente tal que 1 < k < p-1.",
                                    "Garanta que k seja coprimo com p-1 para segurança (opcional para aprendizado básico).",
                                    "Use um gerador de números aleatórios confiável (ex: Python random.randint(2, p-2)).",
                                    "Registre o valor de k separadamente, pois é efêmero e não compartilhado.",
                                    "Repita a escolha se k for muito pequeno ou previsível em testes."
                                  ],
                                  "verification": "k está no intervalo correto e é único para esta cifração (probabilístico).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Gerador de números aleatórios (software como Python ou calculadora)",
                                    "Documentação de RNG criptográficos"
                                  ],
                                  "tips": "Em produção, use criptografia RNG; para aprendizado, simule com dados aleatórios.",
                                  "learningObjective": "Entender o papel da aleatoriedade na cifração probabilística do ElGamal.",
                                  "commonMistakes": [
                                    "Escolher k=1 ou k=p-1 (inseguro)",
                                    "Reutilizar k em múltiplas mensagens",
                                    "k não aleatório"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Primeiro Componente do Cifrato: c1 = g^k mod p",
                                  "subSteps": [
                                    "Calcule g^k mod p usando exponenciação modular eficiente (ex: binary exponentiation).",
                                    "Verifique o cálculo passo a passo: g^1, g^2, etc., dobrando quando bit=1.",
                                    "Confirme que c1 está entre 1 e p-1.",
                                    "Anote c1 para uso posterior.",
                                    "Teste com expoente pequeno para validar método."
                                  ],
                                  "verification": "c1 = pow(g, k, p) resulta em valor consistente com cálculo manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora modular ou Python (pow(g, k, p))",
                                    "Tabela de potências de g mod p"
                                  ],
                                  "tips": "Implemente exponenciação quadrática para eficiência: O(log k) operações.",
                                  "learningObjective": "Dominar exponenciação modular, base da aritmética criptográfica.",
                                  "commonMistakes": [
                                    "Calcular g^k sem mod p (overflow)",
                                    "Erro em binary exponentiation",
                                    "Confundir base e expoente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Segundo Componente: sk = h^k mod p e c2 = m * sk mod p",
                                  "subSteps": [
                                    "Calcule sk = h^k mod p usando o mesmo método de exponenciação modular.",
                                    "Multiplique c2 = (m * sk) mod p.",
                                    "Reduza m * sk mod p para garantir c2 < p.",
                                    "Verifique multiplicação modular: (a*b) mod p = [(a mod p)*(b mod p)] mod p.",
                                    "Anote sk temporariamente para depuração."
                                  ],
                                  "verification": "c2 = (m * pow(h, k, p)) % p é correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma calculadora modular",
                                    "Exemplo de código Python para validação"
                                  ],
                                  "tips": "Note que sk = (g^x)^k = g^(x*k) mod p, mas não compute x.",
                                  "learningObjective": "Aplicar mascaramento multiplicativo na cifração.",
                                  "commonMistakes": [
                                    "Esquecer mod p na multiplicação",
                                    "Usar g^k em vez de h^k",
                                    "Overflow em m*sk"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formar e Verificar o Par Cifrato (c1, c2)",
                                  "subSteps": [
                                    "Combine c1 e c2 em um par: ciphertext = (c1, c2).",
                                    "Verifique que ambos componentes estão em 1..p-1.",
                                    "Simule descriptografia parcial: compute h^k = c1^x mod p e verifique m = c2 * inv(h^k) mod p (se tiver x).",
                                    "Codifique o par para transmissão (ex: JSON ou bytes).",
                                    "Documente o processo completo para reutilização."
                                  ],
                                  "verification": "O par (c1, c2) é único e descriptografável com chave privada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto para registrar",
                                    "Chave privada x para teste opcional"
                                  ],
                                  "tips": "Sempre teste com mensagem conhecida e chave privada para validar.",
                                  "learningObjective": "Finalizar cifração e entender estrutura do cifrato ElGamal.",
                                  "commonMistakes": [
                                    "Trocar c1 e c2",
                                    "Não verificar intervalos",
                                    "Expor k"
                                  ]
                                }
                              ],
                              "practicalExample": "Parâmetros: p=23, g=5, h=10 (x=6 privado), m=7. Escolha k=3. c1 = 5^3 mod 23 = 125 mod 23 = 10. sk = 10^3 mod 23 = 1000 mod 23 = 15. c2 = 7*15 mod 23 = 105 mod 23 = 13. Cifrato: (10, 13).",
                              "finalVerifications": [
                                "Calcula c1 corretamente para k dado.",
                                "Computa c2 com mascaramento sk preciso.",
                                "Forma par (c1,c2) único por k.",
                                "Explica por que diferentes k geram cifrados distintos.",
                                "Valida com descriptografia usando x privado.",
                                "Identifica erros em exemplos fornecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos modulares (100% correto).",
                                "Escolha adequada de k aleatório e seguro.",
                                "Eficiência no uso de exponenciação modular.",
                                "Compreensão do papel probabilístico (múltiplos cifrados válidos).",
                                "Capacidade de depurar erros comuns em cifração.",
                                "Documentação clara do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e exponenciação.",
                                "Probabilidade: Geração de aleatoriedade segura.",
                                "Ciência da Computação: Algoritmos eficientes e big integers.",
                                "Segurança da Informação: Conceitos de chaves públicas.",
                                "Física: Analogia com mecânica quântica em criptografia pós-quântica."
                              ],
                              "realWorldApplication": "Usado em protocolos como PGP para email seguro, VPNs e blockchain para transações privadas, garantindo confidencialidade em comunicações públicas via aleatoriedade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Decifrar mensagens no ElGamal",
                            "description": "Explicar a decifração: calcular s = c1^x mod p e então m = c2 * s^{-1} mod p, destacando a dependência do valor aleatório k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os parâmetros da decifração ElGamal",
                                  "subSteps": [
                                    "Receba o ciphertext composto por (c1, c2) e os parâmetros públicos (p, g, y = g^x mod p)",
                                    "Identifique e confirme a chave privada x (secreta do receptor)",
                                    "Verifique que 1 < c1, c2 < p e que p é primo, g é gerador",
                                    "Anote todos os valores em uma tabela para referência rápida",
                                    "Confirme que a mensagem m esperada satisfaz 0 < m < p"
                                  ],
                                  "verification": "Todos os parâmetros estão anotados corretamente e validados sem erros de range ou tipo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de ciphertext conhecido"
                                  ],
                                  "tips": "Crie uma tabela com colunas para cada parâmetro para evitar confusões durante cálculos.",
                                  "learningObjective": "Preparar com precisão e validar todos os inputs necessários para o processo de decifração ElGamal.",
                                  "commonMistakes": [
                                    "Confundir a chave privada x com a pública y",
                                    "Usar valores fora do range [1, p-1] para c1 ou c2",
                                    "Esquecer de anotar p ou x"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o compartilhamento secreto s = c1^x mod p",
                                  "subSteps": [
                                    "Lembre-se conceitualmente que s = (g^k)^x = (g^x)^k = y^k mod p, simulando compartilhamento Diffie-Hellman",
                                    "Implemente exponenciação modular usando método square-and-multiply para eficiência",
                                    "Calcule passo a passo: represente x em binário e compute potências sucessivas",
                                    "Verifique que s ≠ 0 e 1 ≤ s < p",
                                    "Teste com pow(c1, x, p) em Python para validação se disponível"
                                  ],
                                  "verification": "Comparar s com valor esperado de um exemplo conhecido ou verificar propriedades (ex: ordem no grupo).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora modular",
                                    "Software Python com função pow(base, exp, mod)"
                                  ],
                                  "tips": "Sempre reduza módulo p após cada multiplicação para evitar números grandes.",
                                  "learningObjective": "Dominar a exponenciação modular eficiente e compreender o papel de s como y^k.",
                                  "commonMistakes": [
                                    "Esquecer o módulo p no cálculo, levando a overflow",
                                    "Usar multiplicação direta em vez de square-and-multiply para expoentes grandes",
                                    "Confundir c1 com c2 no cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o inverso modular s^{-1} mod p",
                                  "subSteps": [
                                    "Confirme que gcd(s, p) = 1 (p primo garante invertibilidade se s ≠ 0)",
                                    "Aplique o Algoritmo Estendido de Euclides para encontrar bezout coefficients",
                                    "Alternativamente, use Little Fermat: s^{p-2} mod p se p primo",
                                    "Verifique o inverso multiplicando s * s^{-1} mod p == 1",
                                    "Registre os passos do Euclides para auditoria"
                                  ],
                                  "verification": "s * s_inv ≡ 1 mod p deve ser exatamente 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela para Euclides estendido",
                                    "Python: pow(s, -1, p)"
                                  ],
                                  "tips": "Memorize os passos do Euclides estendido: aplique recursão e back-substituição.",
                                  "learningObjective": "Calcular inversos modulares manualmente e entender sua existência em campos finitos.",
                                  "commonMistakes": [
                                    "Não verificar gcd(s,p)=1 antes",
                                    "Erros de sinal na back-substituição do Euclides",
                                    "Usar divisão comum em vez de modular"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recuperar a mensagem m = c2 * s^{-1} mod p",
                                  "subSteps": [
                                    "Multiplique c2 pelo inverso s^{-1} obtido",
                                    "Aplique o módulo p ao produto resultante",
                                    "Converta m numérico para texto ou formato original se aplicável",
                                    "Valide que 0 < m < p e que descriptografa corretamente uma mensagem teste",
                                    "Explique como o k aleatório garante fresh ciphertexts para mesma m"
                                  ],
                                  "verification": "Descriptografar um ciphertext conhecido resulta na mensagem original exata.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para multiplicação modular"
                                  ],
                                  "tips": "A dependência de k probabilístico previne replay attacks e chosen-plaintext.",
                                  "learningObjective": "Completar a decifração obtendo m corretamente e relacionar com aleatoriedade k.",
                                  "commonMistakes": [
                                    "Usar s em vez de s^{-1}, obtendo lixo",
                                    "Esquecer módulo p após multiplicação",
                                    "Não validar range de m"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo concreto: p=17, c1=5, c2=12, x=10 (chave privada). Passo 2: s = 5^10 mod 17 = 9. Passo 3: 9^{-1} mod 17 = 2 (pois 9*2=18≡1 mod 17). Passo 4: m = 12*2 mod 17 = 24 mod 17 = 7. Mensagem original recuperada: 7.",
                              "finalVerifications": [
                                "s calculado corretamente como c1^x mod p",
                                "Inverso s^{-1} validado por s * s^{-1} ≡ 1 mod p",
                                "Mensagem m recuperada e igual ao plaintext conhecido",
                                "Explicação clara da dependência do k aleatório na segurança",
                                "Todos cálculos modulares sem erros de overflow",
                                "Processo completo repetido com novo k para mesmo m, produzindo c diferente"
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos modulares (100% correto)",
                                "Eficiência: uso de algoritmos otimizados como square-and-multiply",
                                "Compreensão conceitual: explicar papel de k e por que s^{-1}",
                                "Verificações independentes em cada passo",
                                "Capacidade de generalizar para números maiores/p",
                                "Clareza na documentação dos passos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, grupos cíclicos e teorema de Fermat",
                                "Matemática: Algoritmo Estendido de Euclides e inversos",
                                "Ciência da Computação: Criptografia assimétrica e Diffie-Hellman",
                                "Segurança Cibernética: Protocolos de chave pública como PGP/GPG",
                                "Física Quântica: Vulnerabilidades a Shor's algorithm em computadores quânticos"
                              ],
                              "realWorldApplication": "Decifração ElGamal é usada em protocolos como OpenPGP para emails criptografados, assinatura digital em blockchain (ex: Ethereum), e troca de chaves em VPNs/SSL, onde o k aleatório garante que mensagens idênticas produzam ciphertexts únicos, resistindo a ataques de análise de frequência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.4",
                            "name": "Analisar propriedades probabilísticas do ElGamal",
                            "description": "Demonstrar por que o ElGamal é semanticamente seguro (IND-CPA) devido à aleatoriedade de k, comparando com esquemas determinísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento do Criptosistema ElGamal e esquemas determinísticos",
                                  "subSteps": [
                                    "Estude a geração de chaves no ElGamal: escolha p primo grande, g gerador, x privado, y = g^x mod p público.",
                                    "Revise o processo de criptografia: para mensagem m, escolha k aleatório, c1 = g^k mod p, c2 = m * y^k mod p.",
                                    "Compare com esquemas determinísticos como RSA sem padding: criptografia usa apenas chaves pública e mensagem fixa.",
                                    "Identifique diferenças: ElGamal usa k randômico por mensagem, determinísticos produzem mesmo ciphertext para mesma mensagem.",
                                    "Anote exemplos numéricos simples com p=23, g=5."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras comparando os dois esquemas e liste 3 diferenças chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação ElGamal (Wikipedia ou textbook), calculadora modular online (SageMath ou Python)"
                                  ],
                                  "tips": "Use exemplos pequenos para cálculos manuais; foque na dependência de k.",
                                  "learningObjective": "Compreender a estrutura básica do ElGamal e contrastá-la com métodos determinísticos.",
                                  "commonMistakes": [
                                    "Confundir k com chave privada x",
                                    "Ignorar que k é efêmero e randômico por mensagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o conceito de Segurança Semântica (IND-CPA)",
                                  "subSteps": [
                                    "Defina IND-CPA: Indistinguibilidade sob Criptografia de Chave Pública Adaptativa Escolhida.",
                                    "Aprenda o experimento de segurança: atacante escolhe duas mensagens m0, m1; recebe criptotexto de uma aleatória; deve adivinhar qual.",
                                    "Estude por que determinísticos falham: mesmo m sempre mesmo c, permitindo detecção por padrões.",
                                    "Veja formalmente: em IND-CPA, |Pr[advanta=1] - 1/2| negligible.",
                                    "Resolva exercício: por que Textbook RSA é determinístico e não IND-CPA?"
                                  ],
                                  "verification": "Explique o jogo IND-CPA em um diagrama e identifique falha em determinísticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Slides ou vídeo sobre IND-CPA (Coursera Crypto I), papel e caneta para diagrama"
                                  ],
                                  "tips": "Pense no atacante como um 'jogo' probabilístico; memorize a vantagem negligible.",
                                  "learningObjective": "Dominar a definição formal de IND-CPA e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir CPA com CCA",
                                    "Achar que IND-CPA requer descriptografia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o papel da aleatoriedade k na segurança do ElGamal",
                                  "subSteps": [
                                    "Examine criptotexto (c1, c2): c1 mascara k, c2 integra m com y^k.",
                                    "Prove que para mesma m, diferentes k produzem (c1, c2) indistinguíveis de randômicos.",
                                    "Use DDH assumption: dada (g, y=g^x, c1=g^k, c2=y^k * m), difícil distinguir m=1 vs m randômico.",
                                    "Simule numericamente: criptografe m duas vezes com k diferentes e compare distribuições.",
                                    "Conclua: aleatoriedade k torna distribuição de ciphertext independente de m."
                                  ],
                                  "verification": "Gere 3 pares de ciphertext para mesma m com k variados e mostre que parecem randômicos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com sympy ou pycryptodome para simulações modulares",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Implemente função encrypt_ElGamal(k, m) e rode loops para múltiplos k.",
                                  "learningObjective": "Demonstrar matematicamente como k proporciona IND-CPA.",
                                  "commonMistakes": [
                                    "Reutilizar k (torna determinístico)",
                                    "Ignorar DDH como base da prova"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ElGamal com esquemas determinísticos e concluir segurança",
                                  "subSteps": [
                                    "Compare ataque em determinístico: frequência de c revela frequência de m.",
                                    "Em ElGamal: múltiplos c por m, estatisticamente indistinguíveis.",
                                    "Discuta limitações: ElGamal IND-CPA mas não IND-CCA sem hybrid.",
                                    "Resuma prova: sob DDH, ElGamal é IND-CPA; determinísticos violam por injeção.",
                                    "Aplique a contexto: por que probabilísticos são padrão em PKI."
                                  ],
                                  "verification": "Escreva parágrafo provando 'ElGamal é IND-CPA devido a k' com referências a steps anteriores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo original ElGamal (1985), quadro branco para mindmap"
                                  ],
                                  "tips": "Use tabela: colunas Determinístico vs Probabilístico, linhas Segurança, Cifrottexto, etc.",
                                  "learningObjective": "Sintetizar análise para demonstrar superioridade probabilística.",
                                  "commonMistakes": [
                                    "Achar ElGamal CCA-seguro",
                                    "Omitir aleatoriedade fresca por mensagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um ataque: em RSA determinístico, criptografe 'SIM' e 'NAO' múltiplas vezes; padrões emergem. No ElGamal (p=10007, g=3), use k=123,456 para 'SIM' e k=789 para mesmo 'SIM'; ciphertext (c1,c2) difere completamente, confundindo atacante em IND-CPA game.",
                              "finalVerifications": [
                                "Explicar em 2 minutos por que reutilizar k quebra IND-CPA.",
                                "Resolver problema: dado ElGamal ct, distinguir m0=1 vs m1=2 sem descriptografar? (Não pode).",
                                "Comparar distribuições de 10 ct de mesma m vs 10 m diferentes.",
                                "Provar informalmente DDH => IND-CPA para ElGamal.",
                                "Identificar 3 apps reais usando ElGamal-like (ECDH em TLS)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção determinístico vs probabilístico (90%+ correto).",
                                "Uso correto de termos IND-CPA, DDH, k efêmero.",
                                "Exemplos numéricos válidos e verificáveis.",
                                "Conexão clara entre aleatoriedade k e indistinguibilidade.",
                                "Ausência de erros comuns como confundir x e k.",
                                "Profundidade na prova/redução de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grupos Cíclicos e DDH (Number Theory).",
                                "Probabilidade: Distribuições Indistinguíveis e Negligible Advantage.",
                                "Ciência da Computação: Algoritmos Randomizados e Complexidade Computacional.",
                                "Estatística: Testes de Hipótese para Indistinguibilidade.",
                                "Física: Analogia com superposição quântica em QKD."
                              ],
                              "realWorldApplication": "ElGamal é base para esquemas como ECIES em protocolos TLS/HTTPS, VPNs (IPsec) e blockchain (Ethereum signatures), garantindo confidencialidade em comunicações seguras onde mensagens idênticas não revelam padrões, prevenindo ataques de análise de tráfego."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Padding OAEP no RSA",
                        "description": "Técnica de padding probabilístico Optimal Asymmetric Encryption Padding (OAEP) aplicada ao RSA para transformar a cifração determinística em probabilística e segura contra ataques escolhidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Entender RSA determinístico vs probabilístico",
                            "description": "Comparar o RSA básico (determinístico e inseguro contra ataques malleability) com o uso de padding para introduzir aleatoriedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o RSA Determinístico Básico",
                                  "subSteps": [
                                    "Revise o funcionamento padrão do RSA: geração de chaves (p, q primos, n = p*q, e e d)",
                                    "Entenda a criptografia direta: c = m^e mod n, onde m é o plaintext numérico",
                                    "Descriptografia: m = c^d mod n",
                                    "Note que para o mesmo m, sempre obtém o mesmo c (determinístico)",
                                    "Implemente um exemplo simples em Python usando pow(m, e, n)"
                                  ],
                                  "verification": "Implemente e execute código que criptografa a mesma mensagem duas vezes e obtém o mesmo ciphertext",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Biblioteca Python (built-in pow)",
                                    "Documentação RSA básica (Wikipedia ou Crypto101)"
                                  ],
                                  "tips": "Use números pequenos para testes manuais antes de codificar",
                                  "learningObjective": "Dominar o algoritmo RSA sem padding e sua natureza determinística",
                                  "commonMistakes": [
                                    "Confundir chaves pública/privada",
                                    "Usar n pequeno causando fatoração fácil"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Vulnerabilidades do RSA Determinístico",
                                  "subSteps": [
                                    "Estude ataques de malleability: modificação de ciphertext sem chave privada (ex: multiplicar c por g^e mod n resulta em m*g)",
                                    "Simule um ataque: altere um ciphertext válido para descriptografar uma mensagem modificada",
                                    "Discuta chosen-ciphertext attacks (CCA) explorando determinismo",
                                    "Compare com propriedades IND-CCA que o determinístico falha",
                                    "Registre exemplos onde o mesmo plaintext gera sempre o mesmo ciphertext, facilitando padrões"
                                  ],
                                  "verification": "Desenvolva e demonstre um ataque de malleability bem-sucedido em código",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Leitura: 'RSA Attacks' em Crypto StackExchange"
                                  ],
                                  "tips": "Teste com mensagens como 'yes' (1) e 'no' (0) para clareza em ataques binários",
                                  "learningObjective": "Reconhecer por que o RSA determinístico é inseguro em cenários reais",
                                  "commonMistakes": [
                                    "Ignorar que malleability afeta apenas certos modos, não todos os usos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir RSA Probabilístico com Padding OAEP",
                                  "subSteps": [
                                    "Aprenda OAEP (Optimal Asymmetric Encryption Padding): padding com XOR randômico e hash",
                                    "Entenda como OAEP introduz aleatoriedade: mesmo plaintext + nonce diferente = ciphertexts variados",
                                    "Implemente OAEP simplificado ou use biblioteca (ex: cryptography em Python)",
                                    "Criptografe a mesma mensagem múltiplas vezes e observe ciphertexts únicos",
                                    "Verifique segurança: tente malleability e veja falhar devido à aleatoriedade"
                                  ],
                                  "verification": "Gere 3 ciphertexts diferentes para o mesmo plaintext usando OAEP",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Biblioteca Python cryptography.io",
                                    "RFC 8017 (PKCS#1 OAEP)"
                                  ],
                                  "tips": "Comece com OAEP básico antes de full implementação para entender fluxo",
                                  "learningObjective": "Implementar e compreender como padding torna RSA probabilístico",
                                  "commonMistakes": [
                                    "Confundir PKCS#1 v1.5 (ainda vulnerável) com OAEP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Sintetizar Diferenças",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: determinístico vs probabilístico (segurança, output, uso)",
                                    "Discuta benefícios: resistência a malleability, IND-CCA security",
                                    "Analise cenários: quando usar cada (raramente determinístico hoje)",
                                    "Teste híbrido: envie mensagens via socket com ambos e compare detecção",
                                    "Resuma em diagrama: fluxo com/sem padding"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças com exemplos concretos",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io)",
                                    "Códigos dos steps anteriores"
                                  ],
                                  "tips": "Use side-by-side code execution para visualização imediata",
                                  "learningObjective": "Capacitar comparação crítica entre variantes RSA",
                                  "commonMistakes": [
                                    "Subestimar impacto da aleatoriedade em privacidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Criptografe 'Hello' (convertido para int) com RSA determinístico: sempre obtém mesmo ciphertext. Com OAEP, gera ciphertexts únicos a cada vez. Simule envio em TLS: sem padding permite atacante alterar 'buy 1 share' para 'buy 100 shares'; com padding, falha.",
                              "finalVerifications": [
                                "Explicar malleability attack em RSA determinístico com equação matemática",
                                "Gerar 3 ciphertexts diferentes para mesmo plaintext via OAEP",
                                "Identificar por que OAEP previne chosen-ciphertext attacks",
                                "Comparar propriedades de segurança (IND-CPA vs IND-CCA)",
                                "Implementar código que falha em atacar RSA-OAEP",
                                "Descrever papel do nonce/randomness no padding"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do algoritmo RSA básico e suas fraquezas",
                                "Correta implementação e demonstração de padding OAEP",
                                "Capacidade de simular e explicar ataques de malleability",
                                "Tabela ou diagrama claro comparando variantes",
                                "Uso correto de terminologia criptográfica (probabilístico, determinístico, IND-CCA)",
                                "Exemplos práticos relevantes e livres de erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, Teorema de Euler",
                                "Probabilidade: Uso de nonces aleatórios e entropia",
                                "Segurança da Informação: Protocolos como TLS/SSL",
                                "Programação: Implementação segura de criptografia em Python",
                                "Ética: Implicações de falhas criptográficas em sistemas reais"
                              ],
                              "realWorldApplication": "Em protocolos como HTTPS (TLS 1.3 usa RSA-OAEP para key exchange seguro), prevenindo ataques man-in-the-middle onde malleability permitiria alterar transações financeiras ou dados sensíveis sem detecção."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Descrever o funcionamento do OAEP",
                            "description": "Explicar os componentes do OAEP: máscaras G e H baseadas em hash, seed aleatório, e como o padding é aplicado à mensagem antes da exponenciação RSA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes básicos do OAEP",
                                  "subSteps": [
                                    "Identifique a mensagem original M e o tamanho do padding k (geralmente relacionado ao módulo RSA n).",
                                    "Explique o seed r: um valor aleatório de tamanho m (tipicamente 2h+2 bits, onde h é o output do hash).",
                                    "Descreva as funções de máscara G e H: G expande o seed para maskedSeed usando hash iterativo, H comprime para maskedDB.",
                                    "Revise o formato: padded message = maskedDB || maskedSeed, com lHash (hash do label, geralmente vazio)."
                                  ],
                                  "verification": "Liste e defina corretamente todos os 4 componentes principais (M, r, G/H, formato) em um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 8017 (PKCS#1 v2.2)",
                                    "Papel e caneta para diagrama",
                                    "Calculadora para tamanhos de bits"
                                  ],
                                  "tips": "Comece desenhando um fluxograma para visualizar os componentes antes de memorizar fórmulas.",
                                  "learningObjective": "Compreender os elementos fundamentais que compõem o esquema OAEP.",
                                  "commonMistakes": "Confundir G (expansão) com H (compressão); ignorar lHash como prefixo fixo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o processo de padding na encriptação",
                                  "subSteps": [
                                    "Gere seed r aleatório de m bits.",
                                    "Compute maskedSeed = G(r, 0^{k-m}) (aplicação de MGF1 com hash SHA para expandir r).",
                                    "Compute maskedDB = H(mmaskedSeed) XOR DB, onde DB = lHash || PS || 0x01 || M (PS é padding de zeros).",
                                    "Forme EM = maskedDB || maskedSeed e aplique RSA: c = EM^e mod n."
                                  ],
                                  "verification": "Simule o padding com valores pequenos (ex: k=20 bits) e verifique se maskedDB e maskedSeed têm tamanhos corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Implementação Python simples de MGF1 (código exemplo online)",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use pseudocódigo para anotar cada XOR e concatenação; teste com seed fixo primeiro.",
                                  "learningObjective": "Dominar a sequência exata de máscaras e XORs no padding de encriptação.",
                                  "commonMistakes": "Esquecer o 0x01 separador em DB; inverter a ordem de concatenação (maskedDB primeiro)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o processo de descriptografia e máscaras inversas",
                                  "subSteps": [
                                    "Após RSA descript: EM' = c^d mod n.",
                                    "Extraia seed' = H(EM'[0..k-m]) (maskedDB') e maskedSeed' = EM'[k-m..k-1].",
                                    "Compute r' = G^{-1}(maskedSeed') via iteração inversa do MGF1.",
                                    "Compute DB' = H(r') XOR maskedDB'; parse para verificar lHash, PS, 0x01 e recuperar M.",
                                    "Falha se verificações (PS termina em 0x01, lHash correto) não passarem."
                                  ],
                                  "verification": "Descreva o inverso passo-a-passo e identifique onde a aleatoriedade impede ataques determinísticos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Diagrama bidirecional de OAEP (busque imagens RFC)",
                                    "Simulador online de OAEP (ex: CrypTool)"
                                  ],
                                  "tips": "Pense em descriptografia como 'desfazer XORs na ordem reversa' para simplicidade.",
                                  "learningObjective": "Entender como as máscaras inversas garantem segurança sem vazar informação da mensagem.",
                                  "commonMistakes": "Confundir ordem das máscaras inversas; subestimar o papel da verificação de padding."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar vantagens e funcionamento holístico",
                                  "subSteps": [
                                    "Compare com padding determinístico (ex: PKCS#1 v1.5): destaque provable security contra chosen ciphertext.",
                                    "Explique como seed aleatório e máscaras baseadas em hash previnem vazamento via side-channels.",
                                    "Descreva o papel do MGF1 (Mask Generation Function) usando hash iterado.",
                                    "Resuma o fluxo completo: input M -> padding probabilístico -> RSA.",
                                    "Discuta limitações: requer hash seguro e tamanho k adequado."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o funcionamento completo em 150 palavras, cobrindo encript/descript.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo 'OAEP Reconsidered' de Bellare e Rogaway",
                                    "Vídeo explicativo sobre RSA-OAEP"
                                  ],
                                  "tips": "Use analogia: 'máscaras escondem mensagem como camadas de cebola criptográfica'.",
                                  "learningObjective": "Integrar todos os componentes em uma descrição coesa do OAEP.",
                                  "commonMistakes": "Ignorar que OAEP é probabilístico (mesma M produz ciphertexts diferentes); confundir com PSS (signature)."
                                }
                              ],
                              "practicalExample": "Para RSA-1024 (k=1024 bits, h=256 SHA-256, m=2h+2=514 bits), M='hello' (padded em DB), seed r= random 514 bits. maskedSeed = G(r, zeros), maskedDB = H(maskedSeed) XOR (lHash || zeros || 0x01 || 'hello'). EM = maskedDB (510 bits) || maskedSeed (514 bits). c = EM^e mod n. Descriptografia recupera 'hello' após máscaras inversas e parse.",
                              "finalVerifications": [
                                "Pode listar e definir G, H, seed, DB corretamente?",
                                "Descreve a ordem exata de XOR e concatenação no padding?",
                                "Explica o processo inverso na descriptografia sem erros?",
                                "Identifica o papel da aleatoriedade na segurança?",
                                "Compara OAEP com paddings mais simples?",
                                "Desenha um fluxograma completo do OAEP?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das funções G e H (expansão/compressão via MGF1): 25%",
                                "Correção na estrutura de DB (lHash, PS, 0x01, M): 20%",
                                "Explicação clara do fluxo bidirecional (encript/descript): 25%",
                                "Uso correto de terminologia (maskedDB, maskedSeed, verificação de padding): 15%",
                                "Integração de conceitos de segurança (provável CCA-security): 15%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e geração de máscaras (teoria dos números, iterações).",
                                "Probabilidade: Uso de seed aleatório para não-determinismo.",
                                "Segurança da Informação: Análise de ataques chosen-ciphertext.",
                                "Programação: Implementação de MGF1 em linguagens como Python.",
                                "Engenharia de Software: Padrões criptográficos em protocolos (TLS)."
                              ],
                              "realWorldApplication": "OAEP é padrão em TLS 1.3 para RSA encryption, PGP/GPG para email seguro, e bibliotecas como OpenSSL, protegendo comunicações web contra ataques de padding oracle."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Implementar cifração RSA-OAEP",
                            "description": "Passo a passo: adicionar seed aleatório, aplicar máscaras G(seed) XOR mensagem e H(máscara) XOR seed, concatenar e cifrar com chave pública RSA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e parâmetros OAEP",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias como cryptography ou implemente funções hash/máscara manualmente em Python.",
                                    "Defina parâmetros: tamanho da chave RSA (ex: 2048 bits), comprimento do seed k0 (ex: 256 bits), comprimento da mensagem k1.",
                                    "Implemente ou importe funções G (PRF expansora, ex: MGF1 com SHA-256) e H (hash, ex: SHA-256).",
                                    "Prepare a mensagem a ser cifrada, padronizando-a para k1 bits com padding fixo (ex: 0x00 || mensagem).",
                                    "Gere chave pública RSA (n, e)."
                                  ],
                                  "verification": "Verifique se funções G e H produzem saídas de tamanho correto e se parâmetros k0/k1 somam ao tamanho do bloco RSA menos overhead.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Biblioteca cryptography ou hashlib",
                                    "Chave RSA pública gerada"
                                  ],
                                  "tips": "Use MGF1 padrão para G para compatibilidade; teste funções isoladamente com inputs conhecidos.",
                                  "learningObjective": "Entender e configurar os blocos fundamentais do esquema OAEP.",
                                  "commonMistakes": [
                                    "Usar tamanhos incorretos para k0/k1 levando a overflow",
                                    "Esquecer padding inicial na mensagem",
                                    "Confundir H com G"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar seed aleatório e preparar mensagem encoberta",
                                  "subSteps": [
                                    "Gere um seed aleatório de exatamente k0 bits usando criptografia segura (ex: os.urandom(k0//8)).",
                                    "Converta a mensagem para bytes e aplique padding L (ex: zeros à esquerda até k1 - len(msg)).",
                                    "Crie a mensagem padded: b'\\x00' + padded_msg (para indicar mensagem válida).",
                                    "Armazene seed e mensagem_padded em variáveis separadas.",
                                    "Valide que len(seed) == k0 e len(mensagem_padded) == k1."
                                  ],
                                  "verification": "Execute print(len(seed)) e print(len(mensagem_padded)) para confirmar tamanhos exatos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Módulo os ou secrets para random",
                                    "Bytes da mensagem de teste"
                                  ],
                                  "tips": "Sempre use fontes de entropia criptográfica para seed; evite random padrão.",
                                  "learningObjective": "Dominar geração segura de aleatoriedade essencial para probabilisticidade.",
                                  "commonMistakes": [
                                    "Gerar seed não-uniforme ou reutilizável",
                                    "Padding incorreto expondo mensagem",
                                    "Tamanho de seed errado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar máscara G ao seed para XOR com mensagem",
                                  "subSteps": [
                                    "Compute máscara_mensagem = G(seed, k1) usando MGF1 para expandir seed para k1 bits.",
                                    "Execute XOR bitwise: masked_msg = mensagem_padded XOR máscara_mensagem.",
                                    "Converta para bytes se necessário e valide que resultado tem k1 bits.",
                                    "Teste com seed conhecido: G deve ser determinístico e expansor.",
                                    "Armazene masked_msg."
                                  ],
                                  "verification": "Para seed fixo, masked_msg deve ser reproduzível e XOR reversível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Implementação de MGF1/SHA256",
                                    "Função XOR para bytes"
                                  ],
                                  "tips": "Implemente MGF1 iterativamente: hash(seed || counter) concatenado até k1 bits.",
                                  "learningObjective": "Implementar função de derivação de chave pseudo-aleatória G.",
                                  "commonMistakes": [
                                    "MGF1 não iterativo o suficiente",
                                    "XOR em strings ao invés de bytes",
                                    "Comprimento de saída errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar hash H à máscara para XOR com seed",
                                  "subSteps": [
                                    "Compute hash_máscara = H(masked_msg) usando SHA-256 para obter k0 bits.",
                                    "Execute XOR bitwise: masked_seed = seed XOR hash_máscara.",
                                    "Valide len(masked_seed) == k0.",
                                    "Teste reversibilidade: seed XOR H(G(seed) XOR msg) deve recuperar seed.",
                                    "Armazene masked_seed."
                                  ],
                                  "verification": "Com inputs conhecidos, recupere seed via XOR reverso para confirmar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "hashlib.sha256",
                                    "Função XOR bytes"
                                  ],
                                  "tips": "H é colisão-resistente; use digest() para tamanho fixo.",
                                  "learningObjective": "Compreender o papel de H na difusão de informações.",
                                  "commonMistakes": [
                                    "Usar hash de tamanho errado",
                                    "XOR assíncrono entre seed e hash",
                                    "Ignorar endianness em inteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concatenar máscaras e cifrar com RSA pública",
                                  "subSteps": [
                                    "Concatene: encoded = masked_seed + masked_msg (k0 + k1 bits).",
                                    "Converta encoded para inteiro m < n (chave RSA).",
                                    "Cifre: c = pow(m, e, n) (RSA encryption).",
                                    "Converta c para bytes se necessário.",
                                    "Teste completo com mensagem conhecida e descriptografia simulada."
                                  ],
                                  "verification": "Implemente descriptografia reversa básica para confirmar recuperação da mensagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Chave RSA (n, e)",
                                    "Funções pow para bigints"
                                  ],
                                  "tips": "Garanta que m < n; pad com zeros se necessário.",
                                  "learningObjective": "Integrar padding OAEP ao RSA para segurança sem padding determinístico.",
                                  "commonMistakes": [
                                    "Concatenação errada (seed após msg)",
                                    "m >= n causando falha",
                                    "Não converter bytes para int corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Cifrar mensagem b'Hello World!' (padded a k1=188 bytes com k0=256, RSA 2048). Gere seed=32 bytes aleatório. G(seed)=máscara 188 bytes XOR padded_msg. H(máscara)=32 bytes XOR seed. Concat=64+188=252 bytes -> int m < 2^2048. c = m^e mod n. Resultado: ciphertext hex de 256 bytes.",
                              "finalVerifications": [
                                "Ciphertext tem tamanho exato do bloco RSA (ex: 256 bytes para 2048-bit).",
                                "Descriptografia reversa (implemente RSA-OAEP dec) recupera mensagem original.",
                                "Teste com 10 seeds diferentes: ciphertexts únicos para mesma msg (probabilisticidade).",
                                "Funções G/H isoladas produzem saídas corretas para inputs conhecidos (NIST vectors).",
                                "Nenhum leak de info: últimas bytes de ciphertext não revelam msg.",
                                "Execução sem erros de tamanho ou overflow."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: XORs e concatenação exatos conforme RFC 8017.",
                                "Segurança: Uso de primitives cripto padrão (SHA256, MGF1, CSPRNG).",
                                "Eficiência: Tempo de execução <1s para 2048-bit em hardware comum.",
                                "Robustez: Trata edge cases (msg vazia, max size).",
                                "Documentação: Código comentado explicando cada passo OAEP.",
                                "Testes: Unit tests para G, H, full encrypt com asserts."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (modular exponentiation RSA), funções hash como PRFs.",
                                "Probabilidade: Aleatoriedade em cripto, uniformidade de seeds.",
                                "Segurança da Informação: Padding oracles, IND-CCA2 security.",
                                "Programação: Manipulação de big integers, bytes em Python.",
                                "Engenharia de Software: Modularidade em funções criptográficas."
                              ],
                              "realWorldApplication": "Usado em protocolos como TLS 1.3 para cifrar chaves de sessão, PGP para email seguro, e APIs HTTPS para proteger dados sensíveis contra ataques de chosen-ciphertext."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.4",
                            "name": "Implementar decifração RSA-OAEP",
                            "description": "Reverter o processo: decifrar com chave privada, extrair máscara e seed, verificar consistência e recuperar mensagem, garantindo detecção de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente, chaves e parâmetros OAEP",
                                  "subSteps": [
                                    "Importar bibliotecas necessárias: hashlib para funções hash (SHA-256), pow para exponenciação modular.",
                                    "Definir parâmetros OAEP: hLen = 32 (SHA-256), mLen esperado, k = tamanho do bloco RSA em bytes (ex: 256 para 2048-bit).",
                                    "Carregar ou gerar par de chaves RSA: n (modulo), d (privada), e (pública para contexto).",
                                    "Preparar ciphertext c (inteiro) e label L (geralmente vazio)."
                                  ],
                                  "verification": "Verificar se chaves são válidas testando uma assinatura simples ou verificando n.bit_length() == 2048.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Biblioteca hashlib",
                                    "Código fonte de chaves RSA geradas previamente"
                                  ],
                                  "tips": "Use chaves de teste pequenas para depuração inicial antes de usar 2048-bit.",
                                  "learningObjective": "Entender e configurar os componentes fundamentais para decifração OAEP.",
                                  "commonMistakes": [
                                    "Usar hash errado (ex: MD5 em vez de SHA-256)",
                                    "Ignorar endianness ao converter inteiros para bytes",
                                    "Definir k incorreto baseado no tamanho de n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar decifração RSA básica com chave privada",
                                  "subSteps": [
                                    "Converter ciphertext c para bytes se necessário: c_bytes = c.to_bytes(k, 'big').",
                                    "Computar padded_message = pow(c, d, n) usando pow() para eficiência.",
                                    "Converter padded_message para bytes: padded_bytes = padded_message.to_bytes(k, 'big').",
                                    "Verificar se padded_bytes tem exatamente k bytes; senão, erro de padding inválido."
                                  ],
                                  "verification": "padded_bytes deve ter len == k e representar um número < n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Chaves RSA preparadas",
                                    "Python pow()"
                                  ],
                                  "tips": "Use pow(c, d, n) em vez de loops manuais para evitar timeouts com grandes expoentes.",
                                  "learningObjective": "Dominar a decifração RSA primitiva como base para esquemas paddados.",
                                  "commonMistakes": [
                                    "Erro de endianness: sempre 'big'",
                                    "Não verificar se resultado < n",
                                    "Usar chave pública por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair componentes maskedSeed e maskedDB do padded message",
                                  "subSteps": [
                                    "Computar lHash = SHA256(L) (label hash, geralmente b'\\x00'*32 se L vazio).",
                                    "Verificar se len(padded_bytes) >= 2*hLen + 2; maskedSeed = padded_bytes[:hLen].",
                                    "maskedDB = padded_bytes[hLen : -hLen]; hash_value = padded_bytes[-hLen:].",
                                    "Armazenar componentes para próxima etapa."
                                  ],
                                  "verification": "Confirmar tamanhos: maskedSeed (32 bytes), maskedDB (k - 2*hLen -1 bytes), hash (32 bytes).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "hashlib.sha256()",
                                    "padded_bytes do step anterior"
                                  ],
                                  "tips": "Imprima hex(padded_bytes) para visualizar estrutura durante debug.",
                                  "learningObjective": "Identificar corretamente a estrutura interna do padding OAEP.",
                                  "commonMistakes": [
                                    "Off-by-one em slicing de bytes",
                                    "Confundir ordem: seed primeiro, DB depois",
                                    "Esquecer lHash no início"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar máscaras e realizar unmasking de seed e DB",
                                  "subSteps": [
                                    "Gerar mask_db_seed = SHA256(maskedDB)[:hLen] (primeiros hLen bytes).",
                                    "Unmask seed: seed = bytes(a ^ b for a, b in zip(maskedSeed, mask_db_seed)).",
                                    "Gerar dbMask = MGF(seed, len(maskedDB)) usando Mask Generation Function (implementar com SHA256 iterado).",
                                    "Unmask DB: DB = bytes(a ^ b for a, b in zip(maskedDB, dbMask)).",
                                    "Verificar se DB começa com lHash."
                                  ],
                                  "verification": "DB[:hLen] == lHash e seed é aleatório/não-zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função MGF custom (iterar SHA256)",
                                    "Biblioteca hashlib"
                                  ],
                                  "tips": "Implemente MGF como loop: counter em 4 bytes, hash concatenado até tamanho desejado.",
                                  "learningObjective": "Implementar o mecanismo de masking/unmasking central do OAEP para difusão de entropia.",
                                  "commonMistakes": [
                                    "MGF errado: usar truncado em vez de concatenado",
                                    "XOR byte-a-byte incorreto",
                                    "Não truncar masks adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar consistência de hash e recuperar mensagem",
                                  "subSteps": [
                                    "Localizar PS (padding string de 0x00) em DB após lHash, seguido de 0x01 e mensagem.",
                                    "Computar expected_hash = SHA256(DB).",
                                    "Verificar se expected_hash == hash_value; senão, detectar erro/integridade falha.",
                                    "Extrair mensagem M de DB após 0x01.",
                                    "Retornar M ou raise exceção se falha em verificações."
                                  ],
                                  "verification": "Mensagem recuperada decodifica para texto original; hash match 100%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "DB unmasked",
                                    "hashlib.sha256()"
                                  ],
                                  "tips": "Busque por b'\\x00+\\x01' em DB para parse robusto.",
                                  "learningObjective": "Garantir detecção de erros e recuperação segura da mensagem plaintext.",
                                  "commonMistakes": [
                                    "Não detectar PS inválido (sem 0x01)",
                                    "Hash mismatch ignorado",
                                    "Mensagem truncada por slicing errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado n=... (2048-bit), d=..., c=0x... (ciphertext de 'Hello World'), L=b''. Após steps: seed unmasked=0x..., DB começa com SHA256(L), termina com hash match, M=b'Hello World'. Teste alterando c: hash falha, erro detectado.",
                              "finalVerifications": [
                                "Mensagem decifrada é idêntica à original em múltiplos testes.",
                                "Tampering no ciphertext causa falha na verificação de hash.",
                                "Funciona com labels não-vazios.",
                                "Tempo de execução < 1s para 2048-bit.",
                                "Nenhuma exceção em inputs válidos; exceções apropriadas em inválidos.",
                                "MGF produz masks corretos (teste unitário)."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% match em mensagens e detecção de erros.",
                                "Eficiência: Uso de pow() e MGF otimizado.",
                                "Robustez: Tratamento de edge cases (padding inválido, tamanhos errados).",
                                "Clareza: Código comentado com estrutura modular.",
                                "Segurança: Sem side-channels óbvios (constante-time onde possível).",
                                "Testes: Pelo menos 5 casos unitários incluídos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Exponenciação modular e teoria dos números.",
                                "Segurança da Informação: Autenticidade e detecção de malleability.",
                                "Probabilidade: Uso de seeds aleatórios para IND-CCA segurança.",
                                "Algoritmos: Funções de derivação de chave (MGF como KDF).",
                                "Engenharia de Software: Implementação de primitives crypto seguras."
                              ],
                              "realWorldApplication": "Implementado em protocolos como TLS 1.3 para criptografia híbrida segura em HTTPS, protegendo comunicações web contra eavesdropping e ataques de chosen-ciphertext."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.5",
                            "name": "Analisar segurança do OAEP-RSA",
                            "description": "Discutir provas de segurança prováveis sob o modelo ROM, resistência a ataques CCA e comparação com outros paddings como PKCS#1 v1.5.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de OAEP e RSA",
                                  "subSteps": [
                                    "Estude a estrutura do esquema OAEP (Optimal Asymmetric Encryption Padding), incluindo máscaras G e H.",
                                    "Revise o funcionamento básico do RSA como criptosistema determinístico.",
                                    "Identifique como OAEP transforma RSA em probabilístico adicionando randomização.",
                                    "Analise o processo de encapsulamento e desencapsulamento com diagramas.",
                                    "Compare OAEP com paddings simples para destacar diferenças."
                                  ],
                                  "verification": "Crie um diagrama anotado do fluxo OAEP-RSA e explique verbalmente para um par.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação RFC 3447 (PKCS#1 v2.1)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Notas de aula sobre RSA"
                                  ],
                                  "tips": "Use animações online para visualizar o padding dinamicamente.",
                                  "learningObjective": "Compreender a construção básica de OAEP-RSA e sua randomização.",
                                  "commonMistakes": [
                                    "Confundir funções G e H",
                                    "Ignorar o papel do seed aleatório",
                                    "Assumir OAEP como padding fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Modelo Random Oracle (ROM)",
                                  "subSteps": [
                                    "Defina o modelo ROM e suas suposições (hash como oráculo aleatório).",
                                    "Discuta vantagens e críticas ao ROM (ex: Bellare-Rogaway).",
                                    "Estude implicações para provas de segurança em criptografia híbrida.",
                                    "Implemente um simulador simples de oráculo aleatório em Python.",
                                    "Analise por que ROM é usado em provas de OAEP."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando ROM e execute o simulador com testes.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Papel 'OAEP Revisited' de Bellare e Rogaway",
                                    "Python com hashlib",
                                    "Vídeos Khan Academy sobre modelos de segurança"
                                  ],
                                  "tips": "Pense no ROM como uma 'caixa preta mágica' que responde queries aleatoriamente.",
                                  "learningObjective": "Dominar conceitos do ROM e sua relevância para provas de segurança.",
                                  "commonMistakes": [
                                    "Confundir ROM com modelo padrão",
                                    "Subestimar limitações contra ataques quânticos",
                                    "Não diferenciar queries adaptativas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Provas de Segurança Prováveis sob ROM",
                                  "subSteps": [
                                    "Leia a prova de Fujisaki-Okamoto para OAEP-RSA IND-CCA sob ROM.",
                                    "Identifique reduções para problemas difíceis como RSA-OAEP assumption.",
                                    "Analise tight security e lossy reductions.",
                                    "Verifique formalmente os hibridizadores usados na prova.",
                                    "Discuta condições necessárias (ex: mensagens curtas)."
                                  ],
                                  "verification": "Resuma a prova em um fluxograma e identifique premissas chave.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Papel 'Secure and Simply Encoding' de Fujisaki et al.",
                                    "LaTeX para anotações matemáticas",
                                    "Ferramenta ProofWiki"
                                  ],
                                  "tips": "Foquem em hybrid arguments; ignore detalhes algébricos iniciais.",
                                  "learningObjective": "Explicar a prova de segurança de OAEP-RSA no ROM.",
                                  "commonMistakes": [
                                    "Ignorar o papel do hash como oráculo",
                                    "Confundir IND-CPA com IND-CCA",
                                    "Não notar dependência em mensagens válidas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resistência a Ataques CCA",
                                  "subSteps": [
                                    "Defina ataques CCA e modele o experimento de jogo.",
                                    "Simule um ataque CCA em OAEP-RSA usando código.",
                                    "Explique como máscaras previnem plaintext recovery.",
                                    "Compare com falhas em paddings determinísticos.",
                                    "Discuta extensões para KEM/DEM paradigm."
                                  ],
                                  "verification": "Implemente e execute um simulador de ataque CCA falhando em OAEP.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Biblioteca cryptography em Python",
                                    "Código de exemplo de ataques Bleichenbacher",
                                    "RFC 8017"
                                  ],
                                  "tips": "Use malleability como métrica chave para CCA.",
                                  "learningObjective": "Demonstrar por que OAEP resiste a CCA via randomização.",
                                  "commonMistakes": [
                                    "Confundir CCA2 com CCA1",
                                    "Não modelar decryption oracles corretamente",
                                    "Subestimar padding oracles"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar com Outros Paddings como PKCS#1 v1.5",
                                  "subSteps": [
                                    "Descreva vulnerabilidades de PKCS#1 v1.5 (ex: Bleichenbacher).",
                                    "Compare formalmente IND-CCA security entre OAEP e PKCS#1.",
                                    "Analise migração em protocolos como TLS 1.3.",
                                    "Discuta trade-offs: performance vs segurança.",
                                    "Crie uma tabela comparativa de propriedades."
                                  ],
                                  "verification": "Produza uma tabela comparativa e discuta em um relatório curto.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Papel Bleichenbacher 'Chosen Ciphertext Attacks'",
                                    "Documentação TLS 1.3",
                                    "Planilha Google Sheets"
                                  ],
                                  "tips": "Priorize ataques históricos para contextualizar.",
                                  "learningObjective": "Comparar superioridade de OAEP sobre paddings legados.",
                                  "commonMistakes": [
                                    "Superestimar segurança de PKCS#1",
                                    "Ignorar contextos de uso híbrido",
                                    "Não mencionar mitigações modernas"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a segurança de uma implementação OAEP-RSA em um servidor web TLS: identifique se usa ROM assumptions corretas, teste contra CCA simulados e compare com uma versão PKCS#1 vulnerável, recomendando upgrades.",
                              "finalVerifications": [
                                "Explicar ROM e sua aplicação em OAEP sem erros.",
                                "Desenhar e simular um ataque CCA falhando em OAEP.",
                                "Comparar corretamente OAEP vs PKCS#1 em uma tabela.",
                                "Resumir prova de Fujisaki-Okamoto em termos acessíveis.",
                                "Identificar 3 limitações reais de OAEP-RSA.",
                                "Implementar verificação básica de padding em código."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual em ROM e provas (30%)",
                                "Análise correta de CCA resistance (25%)",
                                "Comparação detalhada com paddings alternativos (20%)",
                                "Uso de exemplos práticos e simulações (15%)",
                                "Clareza em verificações e fluxogramas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Reduções Computacionais",
                                "Segurança de Software: Análise de Vulnerabilidades em Protocolos",
                                "Ciência da Computação: Algoritmos Probabilísticos e Complexidade",
                                "Engenharia: Design de Sistemas Seguros e Trade-offs Performance"
                              ],
                              "realWorldApplication": "Em protocolos como TLS 1.3 e PGP, OAEP-RSA protege comunicações seguras contra eavesdropping e ataques adaptativos, essencial para banking online, VPNs e autenticação em nuvem."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Vantagens de Segurança e Eficiência",
                    "description": "Benefícios como resistência a ataques de texto plano conhecido e escolhido, e maior eficiência em protocolos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Resistência a Ataques de Texto Plano Conhecido e Escolhido",
                        "description": "Explicação das vantagens dos algoritmos probabilísticos em resistir a ataques de criptoanálise onde o atacante conhece pares de texto plano e cifra (known-plaintext attack) ou pode escolher textos planos (chosen-plaintext attack), garantindo segurança semântica provável (IND-CPA).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar ataques de texto plano conhecido",
                            "description": "Diferenciar e exemplificar ataques known-plaintext em criptosistemas determinísticos versus probabilísticos, destacando como o uso de chaves aleatórias por mensagem impede a recuperação de informações úteis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Ataque Known-Plaintext (KPA)",
                                  "subSteps": [
                                    "Defina o que é um ataque known-plaintext: cenário onde o atacante conhece pares de texto plano e texto cifrado.",
                                    "Identifique os pressupostos: atacante tem acesso a plaintexts conhecidos e seus correspondentes ciphertexts.",
                                    "Discuta o objetivo do KPA: recuperar a chave secreta ou descriptografar outros textos.",
                                    "Compare com outros ataques (ciphertext-only, chosen-plaintext) para contextualizar.",
                                    "Revise exemplos históricos, como quebra do cifrador Enigma na WWII."
                                  ],
                                  "verification": "Resuma em 3 frases o que é KPA e seus pressupostos; valide com um diagrama simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook ou papel para anotações",
                                    "Vídeo introdutório sobre criptoanálise (YouTube: 'Known Plaintext Attack')"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas, como adivinhar uma senha sabendo parte dela.",
                                    "Desenhe fluxogramas para visualizar o fluxo de ataque."
                                  ],
                                  "learningObjective": "Compreender os conceitos básicos e pressupostos do KPA.",
                                  "commonMistakes": [
                                    "Confundir KPA com chosen-plaintext attack.",
                                    "Ignorar que plaintexts devem ser conhecidos a priori."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar KPA em Criptosistemas Determinísticos",
                                  "subSteps": [
                                    "Explique sistemas determinísticos: mesma plaintext + mesma chave = mesmo ciphertext (ex: ECB mode).",
                                    "Demonstre como KPA explora isso: colete múltiplos pares (P,C), resolva equações para chave.",
                                    "Implemente um exemplo simples com cifra de César ou ECB em Python.",
                                    "Calcule como poucos pares podem quebrar a chave em algoritmos fracos.",
                                    "Teste com ferramenta online como CyberChef para simular ECB."
                                  ],
                                  "verification": "Criptografe uma mensagem conhecida em ECB e mostre como recuperar a chave com 2-3 pares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Biblioteca cryptography ou pycryptodome",
                                    "Ferramenta CyberChef online"
                                  ],
                                  "tips": [
                                    "Comece com chaves curtas para demonstração rápida.",
                                    "Registre todos os pares (P,C) em uma tabela."
                                  ],
                                  "learningObjective": "Identificar vulnerabilidades de KPA em sistemas determinísticos.",
                                  "commonMistakes": [
                                    "Assumir que todos os modos de bloco são determinísticos.",
                                    "Não considerar o tamanho da chave na complexidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar KPA em Criptosistemas Probabilísticos",
                                  "subSteps": [
                                    "Defina sistemas probabilísticos: incorporam aleatoriedade (nonce/IV), mesmo P + chave = C diferente.",
                                    "Explique por que KPA falha: ciphertexts variam, não há padrões exploitáveis.",
                                    "Compare modos: ECB (determinístico) vs CBC/CTR (probabilísticos).",
                                    "Simule em código: criptografe mesmo plaintext múltiplas vezes e observe diferenças.",
                                    "Discuta limites: se nonce reutilizado, pode haver vazamento (não aleatório por mensagem)."
                                  ],
                                  "verification": "Gere 5 ciphertexts do mesmo plaintext em modo CBC e prove que não revela chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com pycryptodome",
                                    "Documentação AES modos de operação"
                                  ],
                                  "tips": [
                                    "Sempre use IV/nonce aleatório novo por mensagem.",
                                    "Visualize com histogramas de bytes de ciphertext."
                                  ],
                                  "learningObjective": "Diferenciar o comportamento de KPA em sistemas probabilísticos.",
                                  "commonMistakes": [
                                    "Confundir IV fixo com aleatório.",
                                    "Achar que probabilístico é invulnerável a todos os ataques."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar o Papel de Chaves Aleatórias por Mensagem e Síntese",
                                  "subSteps": [
                                    "Explique 'chaves aleatórias por mensagem': na prática, nonce/IV + chave mestra simula chave única.",
                                    "Mostre como impede recuperação: cada mensagem tem 'chave efetiva' única, sem padrões.",
                                    "Sintetize diferenças: determinístico permite equações lineares; probabilístico adiciona ruído.",
                                    "Crie tabela comparativa: vulnerabilidade, exemplos, mitigações.",
                                    "Debata cenários reais: por que TLS usa IV aleatório."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como nonce impede KPA, com exemplo numérico simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para tabela comparativa (Google Sheets)",
                                    "Artigo sobre nonce reuse attacks"
                                  ],
                                  "tips": [
                                    "Pense em nonce como 'semente única' por mensagem.",
                                    "Evite reutilização de nonce na simulação."
                                  ],
                                  "learningObjective": "Compreender como aleatoriedade impede recuperação de informações em KPA.",
                                  "commonMistakes": [
                                    "Chamar nonce de 'chave' literalmente.",
                                    "Ignorar que chave mestra ainda é secreta."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de mensagens de chat usando AES-ECB (determinístico), um atacante intercepta 'Olá, [nome]' onde 'Olá,' é known-plaintext. Ele alinha blocos e recupera o bloco de [nome]. No AES-CBC com IV aleatório, cada 'Olá, [nome]' produz ciphertext único, impedindo alinhamento e recuperação.",
                              "finalVerifications": [
                                "Diferencie KPA em determinístico vs probabilístico com exemplos precisos.",
                                "Simule um KPA bem-sucedido em ECB e falho em CBC.",
                                "Explique o papel do nonce/IV em impedir vazamentos.",
                                "Identifique quando um sistema probabilístico ainda é vulnerável (ex: nonce reuse).",
                                "Crie um diagrama comparativo de fluxos de ataque.",
                                "Responda a 5 perguntas de quiz sobre conceitos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Exemplos práticos: simulações funcionais e relevantes (25%)",
                                "Análise comparativa: tabela/diagrama clara destacando diferenças (20%)",
                                "Compreensão de mitigações: explicação do nonce/IV (15%)",
                                "Clareza de comunicação: explicações concisas e acionáveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações lineares e teoria da probabilidade em criptoanálise.",
                                "Segurança Cibernética: Análise de vulnerabilidades em protocolos reais (TLS, VPN).",
                                "Algoritmos: Implementação de modos de operação de cifras de bloco.",
                                "Ética em TI: Implicações de ataques em privacidade de dados.",
                                "Física: Analogias com ruído quântico em criptografia."
                              ],
                              "realWorldApplication": "Em comunicações seguras como HTTPS/TLS, IVs/nonces aleatórios por sessão previnem KPA em tráfego de rede, protegendo dados sensíveis como credenciais de login contra interceptações em Wi-Fi público."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Analisar resistência a chosen-plaintext attacks",
                            "description": "Demonstrar como algoritmos probabilísticos, como modos CBC ou OAEP, tornam indistinguíveis cifras de textos planos escolhidos pelo atacante, comparando com modos determinísticos como ECB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Chosen-Plaintext Attack (CPA)",
                                  "subSteps": [
                                    "Defina um CPA: um atacante pode escolher textos planos e obter suas cifras correspondentes do oráculo de encriptação.",
                                    "Explique o objetivo do atacante: distinguir entre duas mensagens possíveis com alta probabilidade.",
                                    "Diferencie CPA de known-plaintext attack (KPA), onde o atacante só conhece alguns pares plaintext-ciphertext.",
                                    "Estude a definição formal de IND-CPA (Indistinguishability under Chosen-Plaintext Attack).",
                                    "Revise exemplos históricos de ataques CPA em cifras fracas."
                                  ],
                                  "verification": "Escreva uma definição clara de CPA e explique em suas palavras como um oráculo funciona; valide com um diagrama simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre criptografia básica",
                                    "Artigo Wikipedia sobre CPA",
                                    "Diagrama em branco para desenhar o oráculo"
                                  ],
                                  "tips": "Use analogias como um 'caixa preta' que encripta qualquer mensagem que você envia para visualizar o oráculo.",
                                  "learningObjective": "Entender os fundamentos e o modelo de ameaça de ataques CPA.",
                                  "commonMistakes": [
                                    "Confundir CPA com CCA (chosen-ciphertext)",
                                    "Ignorar o papel da probabilidade na distinção de mensagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vulnerabilidades em Modos Determinísticos como ECB",
                                  "subSteps": [
                                    "Implemente ou simule encriptação ECB com um bloco simples (ex: AES-ECB).",
                                    "Escolha dois textos planos similares (ex: imagem com padrões repetidos) e encripte-os.",
                                    "Observe padrões na cifra ECB: blocos idênticos produzem cifras idênticas.",
                                    "Simule um CPA: atacante envia plaintexts escolhidos e mapeia padrões para recuperar informações.",
                                    "Calcule a probabilidade de distinção: próxima de 1 para ECB."
                                  ],
                                  "verification": "Gere cifras ECB para dois plaintexts conhecidos e demonstre padrões idênticos; explique como um atacante explora isso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com pycryptodome ou cryptography library",
                                    "Imagem PNG simples para teste",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use imagens como plaintext para visualizar padrões em ECB; compare antes/depois da encriptação.",
                                  "learningObjective": "Identificar por que modos determinísticos falham em IND-CPA.",
                                  "commonMistakes": [
                                    "Usar chaves diferentes inadvertidamente",
                                    "Ignorar padding que pode mascarar padrões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Modos Probabilísticos como CBC e OAEP",
                                  "subSteps": [
                                    "Estude CBC: inicialize com IV aleatório, cada bloco XOR com ciphertext anterior.",
                                    "Implemente CBC e encripte os mesmos plaintexts múltiplas vezes: observe cifras únicas.",
                                    "Analise OAEP: padding probabilístico com hash e XOR aleatório para RSA.",
                                    "Explique como aleatoriedade (IV/nonce) torna cifras indistinguíveis para plaintexts escolhidos.",
                                    "Compare formalmente: em CBC/OAEP, probabilidade de distinção é ~1/2 (ideal)."
                                  ],
                                  "verification": "Encripte o mesmo plaintext 5 vezes em CBC/OAEP e confirme que todas as cifras são únicas e indistinguíveis.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python para CBC/OAEP",
                                    "Documentação RFC 3962 (CBC)",
                                    "RFC 8017 (OAEP)"
                                  ],
                                  "tips": "Sempre use IV/nonce frescos; teste com seed fixa para depuração.",
                                  "learningObjective": "Compreender mecanismos probabilísticos que conferem resistência CPA.",
                                  "commonMistakes": [
                                    "Reutilizar IV, simulando modo determinístico",
                                    "Confundir CBC com CFB/CTR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Analisar Resistência Geral",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: ECB vs CBC/OAEP em termos de IND-CPA.",
                                    "Simule um jogo IND-CPA: atacante escolhe duas mensagens, sistema encripta uma aleatoriamente.",
                                    "Meça vantagem do atacante: compute |Pr[acerto] - 1/2| para cada modo.",
                                    "Discuta trade-offs: overhead computacional vs segurança.",
                                    "Conclua por que probabilísticos são preferidos em prática."
                                  ],
                                  "verification": "Produza tabela e simulação mostrando vantagem ~0 para CBC/OAEP e alta para ECB.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Script Python para simulação IND-CPA"
                                  ],
                                  "tips": "Execute 1000 rodadas na simulação para estatísticas confiáveis.",
                                  "learningObjective": "Analisar quantitativamente a resistência a CPA entre modos.",
                                  "commonMistakes": [
                                    "Não randomizar adequadamente na simulação",
                                    "Esquecer de modelar o oráculo corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Análise em Cenários Práticos",
                                  "subSteps": [
                                    "Analise protocolos reais: TLS 1.3 usa CBC? Não, mas GCM (similarmente probabilístico).",
                                    "Teste com ferramenta como Wireshark: capture tráfego HTTPS e observe cifras.",
                                    "Discuta migração de ECB para probabilísticos em sistemas legados.",
                                    "Crie relatório resumindo achados.",
                                    "Debata limitações: CPA não cobre malleability ou side-channels."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que HTTPS resiste CPA, citando modos usados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Documentação TLS",
                                    "Amostra de tráfego HTTPS capturado"
                                  ],
                                  "tips": "Filtre por TLS em Wireshark para focar em cifras Application Data.",
                                  "learningObjective": "Conectar teoria a aplicações reais de criptografia.",
                                  "commonMistakes": [
                                    "Assumir ECB ainda usado em TLS moderno",
                                    "Ignorar evolução para AEAD"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um CPA em Python: para ECB, encripte duas imagens similares (gato/preto e gato/branco); padrões emergem. Para CBC, adicione IV aleatório e repita: cifras parecem ruído aleatório indistinguível. Atacante falha em distinguir qual imagem foi encriptada.",
                              "finalVerifications": [
                                "Explicar IND-CPA em termos probabilísticos sem jargão excessivo.",
                                "Implementar ECB e CBC, demonstrando diferenças em múltiplas encriptações.",
                                "Criar tabela comparativa precisa de vantagens/desvantagens.",
                                "Simular jogo IND-CPA com resultados estatísticos.",
                                "Identificar modos probabilísticos em protocolos como TLS.",
                                "Discutir por que ECB é inseguro para dados com padrões."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de CPA e IND-CPA (30%)",
                                "Implementação prática: códigos funcionais sem reutilização de IV (25%)",
                                "Análise quantitativa: cálculos de probabilidade e simulações (20%)",
                                "Comparação clara: tabelas/diagramas ilustrativos (15%)",
                                "Aplicação real: conexões com protocolos modernos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Análise Estatística para IND-CPA.",
                                "Segurança da Informação: Modelos de Ameaça e Protocolos de Rede (TLS).",
                                "Programação: Implementação de Criptografia em Python.",
                                "Física/Engenharia: Analogias com Ruído Aleatório e Sistemas Quânticos."
                              ],
                              "realWorldApplication": "Em comunicações seguras como HTTPS/TLS, modos probabilísticos como GCM (sucessor de CBC) previnem que atacantes em MITM distingam conteúdos de sites escolhidos, protegendo bancos online e e-mails contra espionagem em massa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Comparar segurança em criptosistemas simétricos e públicos",
                            "description": "Comparar a resistência de algoritmos probabilísticos em chaves simétricas (ex: GCM) e públicas (ex: RSA-OAEP) contra ataques básicos de criptoanálise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Criptosistemas Simétricos e Públicos Probabilísticos",
                                  "subSteps": [
                                    "Defina criptografia simétrica (chave única compartilhada) e assimétrica (chaves pública/privada).",
                                    "Explique algoritmos probabilísticos: uso de nonce/randomness para evitar padrões em cifras.",
                                    "Estude GCM (Galois/Counter Mode para AES simétrico) e RSA-OAEP (padding optimal assimétrico).",
                                    "Identifique diferenças chave: velocidade simétrica vs. segurança de longo prazo assimétrica.",
                                    "Anote exemplos de uso: GCM em TLS, RSA-OAEP em assinatura de certificados."
                                  ],
                                  "verification": "Crie um diagrama comparativo de 1 página resumindo definições e diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial AES-GCM e RSA-OAEP (NIST SP 800-38D, PKCS#1 v2.2), papel/caneta ou ferramenta de diagrama como Draw.io.",
                                  "tips": "Use tabelas para organizar diferenças para visualização rápida.",
                                  "learningObjective": "Compreender fundamentos e distinções entre GCM e RSA-OAEP.",
                                  "commonMistakes": "Confundir simétrico com assimétrico ou ignorar papel do nonce em probabilísticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Ataques Básicos de Criptoanálise: Texto Plano Conhecido e Escolhido",
                                  "subSteps": [
                                    "Descreva ataque known-plaintext (KPA): atacante conhece pares plaintext-ciphertext.",
                                    "Descreva chosen-plaintext (CPA): atacante escolhe plaintexts e obtém ciphertexts.",
                                    "Explique impacto em determinísticos vs. probabilísticos: padrões revelam chaves.",
                                    "Simule KPA/CPA conceitualmente com cifras determinísticas simples (ex: ECB).",
                                    "Liste defesas probabilísticas: IV/nonce único por mensagem."
                                  ],
                                  "verification": "Escreva um parágrafo explicando KPA vs. CPA com exemplo hipotético.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Recursos online como Crypto101 ou Khan Academy Criptografia, simulador de cifras (CrypTool).",
                                  "tips": "Pense em ataques como 'adivinhação informada' para fixar conceitos.",
                                  "learningObjective": "Dominar mecanismos de ataques básicos relevantes para comparação.",
                                  "commonMistakes": "Confundir KPA com CPA ou subestimar necessidade de aleatoriedade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Resistência do GCM (Simétrico) a Ataques KPA e CPA",
                                  "subSteps": [
                                    "Examine estrutura GCM: counter mode + autenticação Galois.",
                                    "Teste KPA: nonce único previne reutilização, mas chave compromete tudo.",
                                    "Teste CPA: probabilístico resiste se nonce fresco; falha em reutilização nonce.",
                                    "Calcule vantagens: eficiência computacional alta, mas depende de segredo da chave.",
                                    "Registre vulnerabilidades conhecidas: nonce reuse leva a forjarias."
                                  ],
                                  "verification": "Crie tabela de resistências GCM vs. ataques com justificativas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Pseudocódigo GCM (Wikipedia ou RFC 5116), calculadora para operações Galois.",
                                  "tips": "Foquem em nonce: 'um erro, tudo perdido'.",
                                  "learningObjective": "Avaliar forças e fraquezas específicas do GCM.",
                                  "commonMistakes": "Ignorar autenticação MAC no GCM, focando só em confidencialidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resistência do RSA-OAEP (Público) a Ataques KPA e CPA",
                                  "subSteps": [
                                    "Desconstrua OAEP: padding com hash, XOR randomness e seed.",
                                    "Teste KPA: padding probabilístico mascara plaintexts conhecidos.",
                                    "Teste CPA: resiste semanticamente seguro sob CPA (IND-CPA).",
                                    "Compare overhead: mais lento devido a expoentes modulares grandes.",
                                    "Note dependência em hard problems: fatoração vs. segredo simétrico."
                                  ],
                                  "verification": "Desenhe fluxo OAEP e anote pontos de resistência a KPA/CPA.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "RFC 8017 (PKCS#1), visualizador de padding OAEP (online tools como CyberChef).",
                                  "tips": "Visualize OAEP como 'camadas de cebola' para randomness.",
                                  "learningObjective": "Compreender proteções únicas do RSA-OAEP.",
                                  "commonMistakes": "Confundir RSA cru (determinístico) com OAEP probabilístico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Resistências e Sintetizar Vantagens/Desvantagens",
                                  "subSteps": [
                                    "Compare KPA/CPA: ambos resistem bem, mas GCM falha em nonce reuse, RSA em fatoração.",
                                    "Avalie trade-offs: GCM rápido/eficiente para bulk data, RSA lento/seguro para key exchange.",
                                    "Discuta cenários: simétrico para volume, assimétrico para distribuição de chaves.",
                                    "Crie matriz comparativa: resistência, performance, ameaças.",
                                    "Conclua com melhores práticas híbridas (ex: TLS handshake)."
                                  ],
                                  "verification": "Produza relatório de 1 página com tabela comparativa final.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabelas dos steps anteriores, ferramenta de escrita (Google Docs).",
                                  "tips": "Use métricas quantitativas como ciclos CPU onde possível.",
                                  "learningObjective": "Sintetizar comparação holística de segurança.",
                                  "commonMistakes": "Generalizar demais sem exemplos específicos de algoritmos."
                                }
                              ],
                              "practicalExample": "Em um chat seguro como Signal, GCM cifra mensagens (rápido para texto), enquanto RSA-OAEP negocia chaves iniciais. Simule: use OpenSSL para encriptar 'hello' com AES-GCM e RSA-OAEP, tente KPA com múltiplas mensagens – GCM resiste se nonce varia, RSA sempre via padding.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave em resistência KPA/CPA entre GCM e RSA-OAEP.",
                                "Identificar cenário onde GCM falha mas RSA não (ex: nonce reuse vs. key exposure).",
                                "Montar tabela comparativa precisa sem consultar notas.",
                                "Simular ataque simples em ferramenta e discutir por que probabilístico mitiga.",
                                "Descrever uso híbrido em protocolo real como TLS 1.3.",
                                "Listar 2 vantagens de cada em termos de performance/segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de algoritmos e ataques (30%).",
                                "Profundidade análise: cobertura de sub-passos e verificações (25%).",
                                "Comparação equilibrada: trade-offs claros sem viés (20%).",
                                "Exemplos práticos: relevância e concretude (15%).",
                                "Clareza síntese: tabela/relatório bem estruturado (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (fatoração RSA) e álgebra linear (Galois fields em GCM).",
                                "Segurança Cibernética: Modelos de ameaça (IND-CPA) e protocolos híbridos.",
                                "Ciência da Computação: Complexidade algorítmica (O(n) GCM vs. O(k^2) RSA).",
                                "Física/Engenharia: Entropia quântica para randomness em chaves."
                              ],
                              "realWorldApplication": "Em HTTPS/TLS, RSA-OAEP autentica servidor e negocia chave simétrica, depois GCM cifra dados – resiste a ataques em trânsito como em bancos online ou VPNs, prevenindo espionagem em texto plano conhecido (ex: headers HTTP)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Eficiência em Protocolos Criptográficos",
                        "description": "Benefícios em termos de desempenho computacional, armazenamento e integração em protocolos, onde o overhead probabilístico é compensado por maior segurança sem necessidade de múltiplas chaves ou padding determinístico.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Avaliar overhead computacional",
                            "description": "Calcular e comparar o custo adicional de geração de aleatoriedade em algoritmos probabilísticos versus determinísticos, mostrando eficiência em cenários de alto volume como protocolos TLS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Overhead Computacional",
                                  "subSteps": [
                                    "Defina overhead computacional como o custo adicional em tempo, memória ou ciclos de CPU.",
                                    "Compare algoritmos determinísticos (previsíveis, sem aleatoriedade) com probabilísticos (usam RNG para aleatoriedade).",
                                    "Identifique fontes de overhead em probabilísticos: geração de números pseudo-aleatórios (PRNG) e entropia verdadeira.",
                                    "Estude métricas chave: tempo de execução, uso de CPU e consumo de energia.",
                                    "Revise exemplos básicos de criptografia, como assinaturas determinísticas vs probabilísticas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre determinísticos e probabilísticos, citando pelo menos 3 métricas de overhead.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notebook ou computador",
                                    "Artigos introdutórios sobre algoritmos probabilísticos (ex: Wikipedia RNG)",
                                    "Vídeo tutorial sobre criptografia básica"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar onde a aleatoriedade é inserida nos algoritmos.",
                                  "learningObjective": "Compreender as bases teóricas de overhead em contextos criptográficos.",
                                  "commonMistakes": [
                                    "Confundir PRNG com aleatoriedade verdadeira",
                                    "Ignorar overhead de seed inicialização",
                                    "Subestimar impacto em dispositivos low-power"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Medir Overhead Computacional",
                                  "subSteps": [
                                    "Instale ferramentas de profiling: timeit em Python, perf no Linux ou Visual Studio Profiler.",
                                    "Implemente benchmarks simples: função determinística (ex: hash fixo) vs probabilística (ex: nonce aleatório).",
                                    "Meça tempo de execução para 1.000 iterações, registrando média, desvio padrão e uso de CPU.",
                                    "Colete dados de memória e ciclos de CPU usando ferramentas como gprof ou Valgrind.",
                                    "Crie um template de script para comparações padronizadas."
                                  ],
                                  "verification": "Execute um benchmark simples e gere um relatório com tabelas de tempos médios para ambos os tipos de algoritmo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3+ com bibliotecas timeit, random, hashlib",
                                    "Ambiente Linux para perf",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Execute testes em loop grande (10k+) para suavizar variações de cache e OS.",
                                  "learningObjective": "Dominar técnicas práticas de medição de performance computacional.",
                                  "commonMistakes": [
                                    "Não isolar variáveis (ex: rodar em background processes)",
                                    "Usar RNG fraco sem seed segura",
                                    "Esquecer de warm-up runs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Comparar Overhead em Algoritmos Específicos",
                                  "subSteps": [
                                    "Escolha pares de algoritmos: determinístico (ex: ECDSA determinístico) vs probabilístico (ex: ECDSA com k aleatório).",
                                    "Calcule overhead percentual: (tempo_prob - tempo_det) / tempo_det * 100%.",
                                    "Simule cenários de alto volume: 1 milhão de execuções, plotando gráficos de custo acumulado.",
                                    "Analise impacto da qualidade do RNG (ex: /dev/urandom vs hardware RNG).",
                                    "Documente fórmulas: Overhead = C_aleat + C_base, onde C_aleat é custo de geração de aleatoriedade."
                                  ],
                                  "verification": "Produza um gráfico comparativo e calcule overhead médio >5% para probabilísticos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com matplotlib, numpy",
                                    "Bibliotecas cripto: cryptography ou pycryptodome",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Use context managers para precisão em medições de tempo.",
                                  "learningObjective": "Aplicar cálculos quantitativos para quantificar ineficiências.",
                                  "commonMistakes": [
                                    "Não normalizar por iteração",
                                    "Ignorar overhead de inicialização do RNG",
                                    "Comparar implementações não-equivalentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Eficiência em Protocolos Reais como TLS",
                                  "subSteps": [
                                    "Estude handshake TLS 1.3: identifique pontos de aleatoriedade (ClientHello nonce, chaves efêmeras).",
                                    "Simule overhead em Wireshark ou custom server: compare TLS com/ sem geração extra de aleatoriedade.",
                                    "Modele cenários de alto volume: 10k handshakes/segundo em servidor web.",
                                    "Compare com alternativas determinísticas hipotéticas e discuta trade-offs segurança vs eficiência.",
                                    "Conclua com recomendações para otimização (ex: usar hardware RNG)."
                                  ],
                                  "verification": "Gere relatório com análise TLS mostrando overhead <10% justificado pela segurança.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Wireshark",
                                    "OpenSSL para simulações TLS",
                                    "Servidor local com nginx/apache",
                                    "Documentação RFC 8446 (TLS 1.3)"
                                  ],
                                  "tips": "Use ferramentas como sslyze para profiling de handshakes reais.",
                                  "learningObjective": "Avaliar overhead em contextos práticos de protocolos criptográficos.",
                                  "commonMistakes": [
                                    "Subestimar overhead de rede vs computacional",
                                    "Ignorar entropia pool exhaustion",
                                    "Não considerar ataques side-channel"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor web TLS 1.3 lidando com 1 milhão de conexões/dia, meça o overhead de gerar nonces aleatórios no ClientHello: implemente benchmark OpenSSL mostrando +15% tempo de CPU vs versão determinística hipotética, provando que o custo é aceitável para segurança contra replay attacks.",
                              "finalVerifications": [
                                "Calcule corretamente overhead percentual em pelo menos 3 benchmarks.",
                                "Identifique fontes de aleatoriedade em TLS handshake.",
                                "Gere gráficos comparativos tempo vs volume.",
                                "Explique trade-off segurança-eficiência em relatório.",
                                "Simule cenário alto volume sem erros de medição.",
                                "Recomende otimizações baseadas em dados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de overhead (erro <5%).",
                                "Uso correto de ferramentas de profiling.",
                                "Análise qualitativa e quantitativa balanceada.",
                                "Clareza em relatórios e visualizações.",
                                "Compreensão de implicações em protocolos reais.",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e estatística para análise de desvios em benchmarks.",
                                "Física: Entropia termodinâmica e limites de geração de aleatoriedade física.",
                                "Economia: Custo-benefício de computação em nuvem (ex: AWS pricing por CPU).",
                                "Engenharia de Software: Otimização de performance em sistemas distribuídos.",
                                "Segurança da Informação: Impacto de overhead em resiliência a ataques."
                              ],
                              "realWorldApplication": "Em data centers de empresas como Google ou Cloudflare, avaliar overhead de TLS probabilístico otimiza custos operacionais, permitindo escalar para bilhões de sessões HTTPS diárias sem comprometer segurança contra ataques como Sweet32 ou replay."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Exemplificar uso em protocolos",
                            "description": "Descrever aplicações em protocolos criptográficos como IPSec ou SSH, onde algoritmos probabilísticos melhoram eficiência ao evitar reutilização de chaves e reduzir vulnerabilidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Defina algoritmos probabilísticos: criptografia que incorpora elementos aleatórios como nonces ou IVs para cada mensagem.",
                                    "Explique a prevenção de reutilização de chaves: mensagens idênticas produzem cifras diferentes, frustrando ataques de texto plano conhecido.",
                                    "Discuta ganhos de eficiência: reduz overhead de gerenciamento de chaves e estado em protocolos.",
                                    "Compare com algoritmos determinísticos: destaque vulnerabilidades como reutilização em ECB mode.",
                                    "Liste exemplos iniciais: IV em CBC mode."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo definições e 3 vantagens de eficiência em protocolos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre criptografia",
                                    "Documentação RFC 4301 (IPSec)",
                                    "Vídeo introdutório sobre modos de operação"
                                  ],
                                  "tips": "Use diagramas para visualizar diferença entre determinístico e probabilístico.",
                                  "learningObjective": "Compreender como elementos probabilísticos evitam reutilização e melhoram eficiência.",
                                  "commonMistakes": "Confundir nonce com chave secreta ou ignorar impacto em ataques de replay."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aplicação em IPSec",
                                  "subSteps": [
                                    "Descreva IPSec: protocolo para segurança IP em VPNs, com AH e ESP.",
                                    "Foco em ESP: modo CBC com IV probabilístico gerado aleatoriamente por pacote.",
                                    "Explique eficiência: IV único evita necessidade de sincronização de sequência estrita, reduzindo latência.",
                                    "Identifique vulnerabilidades mitigadas: previne replay attacks e reutilização sem estado extra.",
                                    "Desenhe fluxo: pacote plaintext + IV -> cifra única."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando IV em ESP e explique seu papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 4303 (IPSec ESP)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Exemplos de tráfego Wireshark IPSec"
                                  ],
                                  "tips": "Simule com Wireshark para ver IVs variando em pacotes reais.",
                                  "learningObjective": "Exemplificar uso específico de probabilismo em IPSec para eficiência.",
                                  "commonMistakes": "Achar que IPSec usa apenas chaves simétricas sem IVs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Aplicação em SSH",
                                  "subSteps": [
                                    "Descreva SSH: protocolo para acesso remoto seguro, versão 2 usa chaves efêmeras.",
                                    "Foco em negociação de chaves: Diffie-Hellman efêmero (DHE) gera chaves probabilísticas por sessão.",
                                    "Explique eficiência: evita reutilização de chaves de longo prazo, reduzindo exposição em sessões múltiplas.",
                                    "Discuta redução de vulnerabilidades: chaves únicas por conexão mitigam compromissos futuros.",
                                    "Trace handshake: client nonce + server nonce -> chave derivada única."
                                  ],
                                  "verification": "Esboce o handshake SSH e anote onde elementos probabilísticos entram.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 4253 (SSH Transport)",
                                    "Ferramenta SSH como OpenSSH",
                                    "Diagrama de handshake SSH"
                                  ],
                                  "tips": "Execute 'ssh -v' para ver nonces em logs reais.",
                                  "learningObjective": "Demonstrar probabilismo em SSH para segurança e eficiência em acessos remotos.",
                                  "commonMistakes": "Confundir chaves de host com chaves de sessão efêmeras."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Comparar Exemplos",
                                  "subSteps": [
                                    "Compare IPSec e SSH: ambos usam probabilismo para IV/nonces/chaves efêmeras.",
                                    "Liste benefícios comuns: eficiência em throughput e redução de ataques.",
                                    "Crie tabela comparativa: protocolo, elemento probabilístico, ganho de eficiência.",
                                    "Desenvolva exemplo híbrido: como SSH sobre IPSec usaria ambos.",
                                    "Reflita sobre escalabilidade: em redes de alta velocidade."
                                  ],
                                  "verification": "Produza uma tabela comparativa e um exemplo verbal explicando vantagens.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown",
                                    "Resumos dos steps anteriores"
                                  ],
                                  "tips": "Use bullet points para clareza na comparação.",
                                  "learningObjective": "Integrar exemplos para exemplificar uso amplo em protocolos.",
                                  "commonMistakes": "Ignorar diferenças contextuais entre protocolos de rede e aplicação."
                                }
                              ],
                              "practicalExample": "Em uma VPN IPSec, cada pacote ESP inclui um IV de 96 bits aleatório no modo GCM probabilístico, garantindo que mesmo pacotes idênticos (ex: pings repetidos) gerem cifras únicas, evitando detecção de padrões e reutilização sem overhead de contadores sincronizados. Similarmente, no SSH, o nonce do cliente e servidor durante DHE gera uma chave de sessão única, permitindo múltiplas sessões sem risco de reutilização de chaves antigas.",
                              "finalVerifications": [
                                "Explicar com precisão o papel do IV probabilístico em IPSec ESP.",
                                "Descrever handshake SSH com ênfase em elementos probabilísticos.",
                                "Listar 3 benefícios de eficiência em protocolos reais.",
                                "Identificar como probabilismo reduz vulnerabilidades de reutilização.",
                                "Comparar IPSec e SSH em um diagrama ou tabela.",
                                "Simular um cenário onde determinístico falharia vs probabilístico."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de IVs, nonces e chaves efêmeras (80%+ correto).",
                                "Uso de exemplos concretos de IPSec/SSH com referências a RFCs.",
                                "Demonstração clara de ganhos de eficiência e segurança.",
                                "Estrutura lógica em explicações, com diagramas ou fluxos.",
                                "Identificação correta de erros comuns como reutilização.",
                                "Criatividade em aplicações híbridas ou cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Probabilidade e Aleatoriedade em Criptosistemas.",
                                "Redes de Computadores: Protocolos de Camada de Rede e Transporte.",
                                "Segurança da Informação: Análise de Ameaças como Replay e Known-Plaintext.",
                                "Engenharia de Software: Design de Protocolos Seguros e Escaláveis."
                              ],
                              "realWorldApplication": "Em empresas, IPSec protege túneis VPN para trabalho remoto, usando IVs probabilísticos para alta velocidade sem sincronização; SSH assegura logins seguros em servidores cloud, com chaves efêmeras evitando breaches em sessões reutilizadas, essencial em DevOps e infraestrutura crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Discutir trade-offs de eficiência",
                            "description": "Analisar trade-offs entre segurança probabilística e eficiência, referenciando bibliografia como Menezes e Paar para justificar o uso em cenários práticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Segurança Probabilística e Eficiência",
                                  "subSteps": [
                                    "Defina segurança probabilística como a propriedade onde um algoritmo resiste a ataques com alta probabilidade, mas não certeza absoluta.",
                                    "Explique eficiência em termos de complexidade computacional (tempo de execução, uso de memória e largura de banda).",
                                    "Compare métricas: probabilidade de falha vs. overhead computacional em algoritmos probabilísticos.",
                                    "Identifique vantagens probabilísticas: flexibilidade em cenários de alta entropia.",
                                    "Liste métricas chave: tempo de chave gerada, verificação e probabilidade de colisão."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras definindo e comparando os conceitos, sem erros conceituais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Capítulo 1 de 'Understanding Cryptography' por Christof Paar; notas pessoais.",
                                  "tips": "Use diagramas Venn para visualizar sobreposições entre segurança e eficiência.",
                                  "learningObjective": "Dominar definições precisas para basear análises de trade-offs.",
                                  "commonMistakes": "Confundir segurança probabilística com determinística; ignorar métricas de espaço além de tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos de Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Estude assinatura digital probabilística (ex: BLS signatures) vs. determinística (RSA).",
                                    "Calcule overhead: compare tempo de assinatura/verificação em cenários simulados.",
                                    "Avalie segurança: probabilidade de falsificação negligenciável (2^{-128}).",
                                    "Registre trade-offs: BLS é mais eficiente em agregação, mas requer setup probabilístico.",
                                    "Compare com Paillier para criptografia homomórfica probabilística."
                                  ],
                                  "verification": "Crie uma tabela comparativa de 3 algoritmos com colunas para tempo, segurança e trade-offs.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Seção 11.4 do 'Handbook of Applied Cryptography' por Menezes; simulador online como Crypto101.",
                                  "tips": "Use Python com biblioteca cryptography para protótipos rápidos de timing.",
                                  "learningObjective": "Identificar trade-offs concretos em algoritmos reais.",
                                  "commonMistakes": "Focar apenas em teoria sem métricas numéricas; superestimar eficiência sem benchmarks."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Referenciar Bibliografia e Justificar Trade-offs",
                                  "subSteps": [
                                    "Leia trechos de Menezes (Cap. 11) sobre probabilística em assinaturas.",
                                    "Extraia citações de Paar sobre eficiência em protocolos (ex: Diffie-Hellman probabilístico).",
                                    "Sintetize justificativas: use probabilístico quando eficiência > certeza absoluta.",
                                    "Crie argumentos balanceados: cite cenários onde trade-off favorece eficiência (IoT).",
                                    "Anote contra-argumentos para robustez na discussão."
                                  ],
                                  "verification": "Compile 5 citações com resumos de como justificam trade-offs específicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "PDFs de 'Handbook of Applied Cryptography' (Menezes) e 'Understanding Cryptography' (Paar); Zotero para anotações.",
                                  "tips": "Busque seções sobre 'probabilistic signatures' e 'efficiency tradeoffs'.",
                                  "learningObjective": "Integrar referências acadêmicas para embasar discussões.",
                                  "commonMistakes": "Citar sem contexto; ignorar edições ou capítulos errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Discussão de Trade-offs em Cenários Práticos",
                                  "subSteps": [
                                    "Escolha cenário: protocolo TLS 1.3 com chaves efêmeras probabilísticas.",
                                    "Discuta: eficiência ganha (handshake rápido) vs. risco mínimo de colisão.",
                                    "Simule debate: prós/cons com justificativas bibliográficas.",
                                    "Escreva ensaio curto justificando escolha em app móvel.",
                                    "Revise com peer review simulado (auto-crítica)."
                                  ],
                                  "verification": "Grave um vídeo de 5 minutos discutindo trade-off em um cenário, referenciando fontes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "RFC 8446 (TLS 1.3); gravador de tela.",
                                  "tips": "Estruture como 'problema-trade-off-justificativa-conclusão'.",
                                  "learningObjective": "Articular trade-offs de forma persuasiva e prática.",
                                  "commonMistakes": "Ser unilateral; omitir referências em discussões verbais."
                                }
                              ],
                              "practicalExample": "Em um protocolo de blockchain como Ethereum, discutir trade-off de usar provas de conhecimento zero probabilísticas (zk-SNARKs): eficiência em verificação (milissegundos vs. minutos em determinísticos), com segurança de 2^{-100}, referenciando Paar para overhead de setup, justificando uso em transações diárias.",
                              "finalVerifications": [
                                "Pode listar 3 trade-offs específicos com métricas numéricas.",
                                "Cita corretamente Menezes/Paar em argumentos.",
                                "Explica quando priorizar eficiência sobre certeza absoluta.",
                                "Identifica cenários práticos (ex: IoT, web).",
                                "Balanceia prós/cons sem viés.",
                                "Usa terminologia precisa (ex: negligível advantage)."
                              ],
                              "assessmentCriteria": [
                                "Profundidade conceitual: definições precisas (30%).",
                                "Uso de referências: citações relevantes e integradas (25%).",
                                "Análise quantitativa: métricas de eficiência/segurança (20%).",
                                "Clareza na discussão: estrutura lógica (15%).",
                                "Aplicação prática: cenários realistas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e teoria da complexidade.",
                                "Economia: Análise custo-benefício em decisões de design.",
                                "Engenharia de Software: Otimização de performance vs. robustez.",
                                "Filosofia: Racionalidade em incertezas (utilitarismo)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps de fintech, como wallets cripto, onde trade-offs de eficiência em assinaturas probabilísticas permitem transações rápidas em dispositivos low-power, justificando com Menezes para resistir a ataques quânticos iniciais, equilibrando UX com segurança em escala global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Criptosistemas com Chave Simétrica",
                "description": "Estudo de sistemas criptográficos que utilizam a mesma chave para cifragem e decifragem, como AES e DES.",
                "totalSkills": 53,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Definição de Criptosistemas com Chave Simétrica",
                    "description": "Conceitos fundamentais de sistemas que utilizam a mesma chave para cifragem e decifragem, incluindo propriedades de confidencialidade e autenticação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Criptosistema com Chave Simétrica",
                        "description": "Definição formal de um criptosistema que emprega uma única chave secreta compartilhada entre emissor e receptor para realizar tanto a cifragem quanto a decifragem de mensagens, garantindo segurança através da confidencialidade da chave.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Identificar a definição básica de criptosistema simétrico",
                            "description": "Reconhecer que um criptosistema simétrico usa a mesma chave para cifrar uma mensagem plaintext em ciphertext e decifrar de volta para plaintext, diferenciando-o de sistemas assimétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Termos Fundamentais da Criptografia",
                                  "subSteps": [
                                    "Leia e memorize a definição de 'plaintext' como a mensagem original legível por humanos.",
                                    "Identifique 'ciphertext' como a versão codificada e ilegível da mensagem.",
                                    "Explique o conceito de 'chave' como um segredo compartilhado usado no processo de codificação."
                                  ],
                                  "verification": "Escreva definições curtas para plaintext, ciphertext e chave em um papel, garantindo precisão.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um glossário online de criptografia básico"
                                  ],
                                  "tips": "Use analogias cotidianas: plaintext é como uma carta aberta, ciphertext é selada com código secreto.",
                                  "learningObjective": "Dominar a terminologia essencial para criptografia.",
                                  "commonMistakes": "Confundir chave com a mensagem em si ou achar que plaintext é sempre numérico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Processo de Criptografia Simétrica",
                                  "subSteps": [
                                    "Descreva como a mesma chave transforma plaintext em ciphertext através de um algoritmo.",
                                    "Simule manualmente: pegue 'HELLO', use chave '3' (shift César) para cifrar em 'KHOOR'.",
                                    "Registre que o algoritmo aplica a chave de forma reversível."
                                  ],
                                  "verification": "Produza um ciphertext correto a partir de um plaintext dado usando shift 3.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela alfabética para shift"
                                  ],
                                  "tips": "Pratique com mensagens curtas para visualizar a transformação.",
                                  "learningObjective": "Entender como a chave única é aplicada na cifragem.",
                                  "commonMistakes": "Usar shifts diferentes para cifrar e testar decifrar, quebrando a simetria."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Processo de Descriptografia Simétrica",
                                  "subSteps": [
                                    "Demonstre como a MESMA chave reverte ciphertext para plaintext.",
                                    "Usando o exemplo anterior 'KHOOR', aplique shift -3 para voltar a 'HELLO'.",
                                    "Confirme que sem a chave exata, a reversão falha."
                                  ],
                                  "verification": "Decifre corretamente um ciphertext fornecido usando a chave original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Mesmo exemplo do step 2"
                                  ],
                                  "tips": "Sempre teste ida e volta para validar a simetria.",
                                  "learningObjective": "Reconhecer a reversibilidade usando uma única chave.",
                                  "commonMistakes": "Assumir que descriptografia usa uma chave diferente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Criptosistemas Simétricos de Assimétricos",
                                  "subSteps": [
                                    "Defina criptosistema assimétrico: usa chave pública para cifrar e privada para decifrar.",
                                    "Compare: simétrico (1 chave compartilhada) vs. assimétrico (par de chaves).",
                                    "Liste uma vantagem de cada: simétrico é rápido, assimétrico resolve distribuição de chaves."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 3 diferenças chave.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo curto sobre RSA vs AES (opcional)"
                                  ],
                                  "tips": "Pense em simétrico como 'segredo compartilhado entre amigos', assimétrico como 'cadeado público'.",
                                  "learningObjective": "Distinguir claramente os dois tipos de criptosistemas.",
                                  "commonMistakes": "Confundir: achar que simétrico usa chaves públicas."
                                }
                              ],
                              "practicalExample": "Alice quer enviar 'MEETINGATNOON' para Bob. Eles compartilham a chave '5'. Usando cifra César (shift 5), cifram para 'RJHHJXYFSSTTS'. Bob usa a mesma chave '5' (shift -5) para decifrar de volta. Isso demonstra simetria: mesma chave para ambos os sentidos.",
                              "finalVerifications": [
                                "Explique em uma frase o que define um criptosistema simétrico.",
                                "Converta corretamente um plaintext simples em ciphertext e vice-versa com uma chave dada.",
                                "Identifique incorretamente um exemplo como assimétrico se usar chaves diferentes.",
                                "Diferencie simétrico de assimétrico em uma comparação escrita.",
                                "Responda verdadeiro/falso: 'Simétrico requer troca segura de uma única chave' (verdadeiro)."
                              ],
                              "assessmentCriteria": [
                                "Definição inclui explicitamente 'mesma chave para cifrar e decifrar'.",
                                "Exemplo prático demonstra transformação reversível corretamente.",
                                "Diferenciação clara de assimétricos sem confusões terminológicas.",
                                "Uso preciso de termos: plaintext, ciphertext, chave.",
                                "Compreensão de implicações básicas, como necessidade de troca segura da chave.",
                                "Capacidade de simular processo manualmente sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e funções bijetivas reversíveis.",
                                "História: Cifras antigas como a de César, usadas em guerras romanas.",
                                "Segurança da Informação: Fundamento para protocolos modernos como TLS.",
                                "Lógica e Filosofia: Conceitos de segredo compartilhado e confiança."
                              ],
                              "realWorldApplication": "Criptosistemas simétricos como AES protegem dados em apps de mensagens (WhatsApp), discos rígidos criptografados (BitLocker) e comunicações VPN, garantindo velocidade para grandes volumes de dados após troca inicial de chaves via assimétricos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Explicar o papel da chave única no processo",
                            "description": "Descrever como a chave simétrica é gerada, distribuída de forma segura e utilizada em ambos os processos de cifragem (E_k(m)) e decifragem (D_k(c)), destacando a necessidade de confidencialidade absoluta da chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico da chave única em criptografia simétrica",
                                  "subSteps": [
                                    "Defina criptografia simétrica como um método onde a mesma chave é usada para cifrar e decifrar mensagens.",
                                    "Explique que a chave única é o 'segredo compartilhado' entre remetente e destinatário.",
                                    "Diferencie de criptografia assimétrica, onde há chaves pública e privada.",
                                    "Ilustre com um diagrama simples: remetente -> E_k(m) -> ciphertext -> D_k(c) -> destinatário.",
                                    "Discuta por que uma única chave simplifica o processo, mas exige proteção máxima."
                                  ],
                                  "verification": "Desenhe um diagrama do processo e explique verbalmente o fluxo da chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, quadro branco ou ferramenta digital como Draw.io",
                                  "tips": "Use analogias como uma 'chave de cofre' compartilhada apenas entre donos.",
                                  "learningObjective": "Identificar o papel fundamental da chave única como elemento central na simetria do algoritmo.",
                                  "commonMistakes": "Confundir com chaves assimétricas ou achar que a chave é pública."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a geração da chave simétrica",
                                  "subSteps": [
                                    "Descreva métodos comuns de geração: geradores pseudo-aleatórios (PRNG) baseados em entropia.",
                                    "Especifique tamanhos típicos: 128, 192 ou 256 bits para algoritmos como AES.",
                                    "Discuta a importância de alta entropia para resistir a ataques de força bruta.",
                                    "Simule geração manual: combine sementes de mouse, teclado e tempo do sistema.",
                                    "Verifique unicidade e aleatoriedade usando testes estatísticos básicos."
                                  ],
                                  "verification": "Gere uma chave de exemplo (ex: 16 bytes hex) e justifique sua segurança.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Computador com Python ou ferramenta online como random.org, calculadora hexadecimal",
                                  "tips": "Sempre use fontes de entropia fortes; evite geradores fracos como rand() sem seed.",
                                  "learningObjective": "Dominar como chaves simétricas são criadas para garantir imprevisibilidade.",
                                  "commonMistakes": "Gerar chaves curtas ou previsíveis, subestimando a necessidade de bits suficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a distribuição segura da chave",
                                  "subSteps": [
                                    "Explique desafios: chave deve chegar ao destinatário sem interceptação.",
                                    "Liste métodos seguros: entrega física, canais pré-estabelecidos ou Diffie-Hellman para troca.",
                                    "Simule um cenário: use um canal off-line para 'entregar' a chave.",
                                    "Discuta ataques como man-in-the-middle e como evitá-los com autenticação.",
                                    "Enfatize que vazamento da chave compromete todo o sistema."
                                  ],
                                  "verification": "Descreva um protocolo de distribuição e identifique pontos vulneráveis em um diagrama.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Dois dispositivos simulados (ex: dois terminais Python), diagrama de fluxo",
                                  "tips": "Pense em 'quem confiável entrega a chave?' – priorize bootstrapping seguro.",
                                  "learningObjective": "Entender os riscos e soluções para compartilhar a chave confidencialmente.",
                                  "commonMistakes": "Ignorar distribuição e assumir que 'a chave magicamente chega'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar uso da chave em cifragem e decifragem com ênfase na confidencialidade",
                                  "subSteps": [
                                    "Aplique E_k(m): transforme plaintext em ciphertext usando a chave (ex: AES-ECB simples).",
                                    "Execute D_k(c): reverta ciphertext para plaintext com a mesma chave.",
                                    "Compare: sem chave correta, decifragem falha completamente.",
                                    "Simule código prático: criptografe 'Olá Mundo' e decifre.",
                                    "Reforce confidencialidade: 'quem tem a chave, controla os dados eternamente'."
                                  ],
                                  "verification": "Criptografe e decifre uma mensagem de teste com sucesso usando a chave gerada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python com pycryptodome ou ferramenta online como CyberChef",
                                  "tips": "Teste com chaves erradas para ver falhas e reforçar importância.",
                                  "learningObjective": "Aplicar a chave em ambos os processos e compreender sua indispensabilidade.",
                                  "commonMistakes": "Usar modos inseguros como ECB sem padding ou confundir ordem de bytes."
                                }
                              ],
                              "practicalExample": "Usando AES-128, gere uma chave 'secretkey1234567' (16 bytes), cifre 'Mensagem confidencial' para obter ciphertext como 'a1b2c3d4e5f67890...', envie ao parceiro via canal inseguro, e decifre com a mesma chave para recuperar a mensagem original.",
                              "finalVerifications": [
                                "Explica corretamente o fluxo E_k(m) e D_k(c) com diagrama.",
                                "Gera e distribui uma chave simétrica de forma simulada segura.",
                                "Demonstra cifragem/decifragem prática sem erros.",
                                "Identifica pelo menos 3 riscos de confidencialidade da chave.",
                                "Diferencia simétrica de assimétrica com exemplos.",
                                "Responde a perguntas sobre ataques relacionados à chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% correta explicação do papel da chave (30%)",
                                "Detalhe prático: Demonstração funcional de geração/uso (25%)",
                                "Compreensão de riscos: Lista distribuição e confidencialidade (20%)",
                                "Clareza de comunicação: Diagramas e analogias eficazes (15%)",
                                "Aplicação: Executa exemplo real sem falhas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em campos finitos e aritmética modular nos algoritmos.",
                                "História: Uso de chaves simétricas na máquina Enigma da WWII.",
                                "Física: Analogia com polarização de luz para conceitos de simetria.",
                                "Ética: Discussão sobre privacidade e responsabilidade na distribuição de chaves."
                              ],
                              "realWorldApplication": "Em apps como WhatsApp (Signal Protocol com chaves simétricas derivadas), bancos protegem transações com AES, e VPNs usam chaves simétricas para túneis seguros, garantindo que apenas partes autorizadas acessem dados sensíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Diferenciar de criptosistemas com chave pública",
                            "description": "Comparar criptosistemas simétricos (chave única compartilhada) com assimétricos (par de chaves pública/privada), identificando vantagens como eficiência computacional em cenários de alto volume de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Criptosistemas Simétricos",
                                  "subSteps": [
                                    "Defina criptosistema simétrico: usa uma única chave compartilhada para criptografia e descriptografia.",
                                    "Liste exemplos comuns como AES e DES.",
                                    "Explique o processo: remetente criptografa com chave compartilhada, destinatário descriptografa com a mesma chave.",
                                    "Discuta requisitos: chave deve ser trocada de forma segura previamente.",
                                    "Anote vantagens iniciais: velocidade e eficiência em grandes volumes de dados."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando o fluxo de criptografia/descriptografia com uma chave única.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Notas de aula sobre AES/DES"
                                  ],
                                  "tips": "Use setas no diagrama para ilustrar o compartilhamento da chave.",
                                  "learningObjective": "Compreender os princípios básicos e o mecanismo de operação dos criptosistemas simétricos.",
                                  "commonMistakes": [
                                    "Confundir com assimétrico achando que há múltiplas chaves",
                                    "Ignorar a necessidade de troca segura da chave"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Criptosistemas Assimétricos",
                                  "subSteps": [
                                    "Defina criptosistema assimétrico: usa par de chaves - pública (para criptografar) e privada (para descriptografar).",
                                    "Liste exemplos como RSA e ECC.",
                                    "Explique o processo: qualquer um usa chave pública para criptografar; apenas dono da privada descriptografa.",
                                    "Discuta como chaves são geradas: matemática baseada em números primos grandes.",
                                    "Anote desvantagens iniciais: computacionalmente mais intensivo."
                                  ],
                                  "verification": "Gere um par de chaves simples usando uma ferramenta online como RSA key generator e descreva o uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online gratuita para geração de chaves RSA (ex: cryptojs ou browser console)",
                                    "Calculadora para conceitos matemáticos básicos"
                                  ],
                                  "tips": "Não use chaves reais para dados sensíveis; foque no conceito.",
                                  "learningObjective": "Entender a estrutura de par de chaves e seu mecanismo único de operação.",
                                  "commonMistakes": [
                                    "Achar que chave pública descriptografa",
                                    "Confundir ordem: pública criptografa, privada descriptografa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Mecanismos e Características",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: chaves (1 vs par), distribuição (compartilhada vs pública aberta), segurança (troca segura vs sem troca prévia).",
                                    "Compare força computacional: simétrico mais rápido para bulk data.",
                                    "Analise cenários: simétrico para arquivos grandes, assimétrico para chaves iniciais.",
                                    "Discuta autenticação: assimétrico permite assinaturas digitais.",
                                    "Identifique trade-offs: simétrico eficiente mas problema de distribuição de chave."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 linhas de diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Referências: Wikipedia Criptografia Simétrica/Assimétrica"
                                  ],
                                  "tips": "Use cores para destacar diferenças: verde para vantagens simétrico, laranja para assimétrico.",
                                  "learningObjective": "Realizar uma comparação lado a lado dos dois tipos de criptosistemas.",
                                  "commonMistakes": [
                                    "Generalizar que simétrico é sempre melhor",
                                    "Esquecer autenticação em assimétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Vantagens em Cenários Específicos",
                                  "subSteps": [
                                    "Foque em eficiência: simétrico superior em alto volume de dados (ex: streaming).",
                                    "Compare benchmarks: AES ~1000x mais rápido que RSA para dados grandes.",
                                    "Discuta híbridos: assimétrico para handshake, simétrico para sessão.",
                                    "Avalie desvantagens: simétrico vulnerável se chave comprometida.",
                                    "Conclua com quando usar cada: simétrico para performance, assimétrico para conveniência."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que AES é preferido para criptografar 1GB de dados vs RSA.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de performance online (ex: busca 'AES vs RSA speed')",
                                    "Editor de texto"
                                  ],
                                  "tips": "Pesquise benchmarks reais para números concretos.",
                                  "learningObjective": "Aplicar a comparação para identificar vantagens contextuais, especialmente eficiência.",
                                  "commonMistakes": [
                                    "Ignorar cenários híbridos comuns",
                                    "Superestimar velocidade assimétrica"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de backup de dados empresariais com 10TB de arquivos, use AES (simétrico) para criptografar os dados devido à eficiência (rápido em CPUs padrão), mas RSA (assimétrico) apenas para trocar a chave AES inicialmente, evitando envio inseguro da chave única.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre uma chave única e um par de chaves.",
                                "Desenhe diagramas corretos para ambos os fluxos.",
                                "Identifique corretamente 3 vantagens do simétrico sobre assimétrico.",
                                "Descreva um cenário onde assimétrico é essencial.",
                                "Compare tempos de execução hipotéticos para 1MB de dados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de chaves e processos (90% correto).",
                                "Profundidade da comparação (cobertura de pelo menos 5 diferenças).",
                                "Correta identificação de vantagens de eficiência em alto volume.",
                                "Uso de exemplos reais ou benchmarks.",
                                "Clareza na tabela/diagrama comparativo.",
                                "Ausência de confusões comuns como inversão de funções de chaves."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e fatoração para RSA.",
                                "Redes de Computadores: Handshakes em protocolos como TLS/SSL.",
                                "Segurança da Informação: Gerenciamento de chaves e PKI.",
                                "Física/Engenharia: Otimização computacional e hardware aceleradores (ex: AES-NI)."
                              ],
                              "realWorldApplication": "Em comunicações seguras como VPNs (IPsec usa AES simétrico para dados de alto throughput) versus email com PGP (RSA assimétrico para distribuição segura sem chave pré-compartilhada), destacando eficiência simétrica em streaming de vídeo confidencial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Processo de Cifragem e Decifragem",
                        "description": "Descrição dos mecanismos operacionais onde a mesma chave é aplicada para transformar mensagens em formas seguras e revertê-las, incluindo noções de algoritmos determinísticos e probabilísticos básicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Descrever o processo de cifragem",
                            "description": "Explicar como uma mensagem plaintext é transformada em ciphertext usando uma função de cifragem E_k(m), onde k é a chave simétrica, e mencionar exemplos como cifras de bloco (ex: AES em modo básico).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Cifragem",
                                  "subSteps": [
                                    "Defina plaintext como a mensagem original legível.",
                                    "Defina ciphertext como a mensagem cifrada ilegível.",
                                    "Explique a chave simétrica (k) como o segredo compartilhado entre emissor e receptor.",
                                    "Descreva a função de cifragem E_k(m) como o algoritmo que aplica a chave à mensagem.",
                                    "Diferencie cifras de bloco (processam blocos fixos) de cifras de fluxo (bit a bit)."
                                  ],
                                  "verification": "Escreva definições curtas para cada termo e explique verbalmente como eles se relacionam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Glossário de criptografia online"
                                  ],
                                  "tips": "Use analogias como 'plaintext é uma carta aberta, ciphertext é codificada'.",
                                  "learningObjective": "Identificar e definir os componentes básicos do processo de cifragem simétrica.",
                                  "commonMistakes": "Confundir chave simétrica com assimétrica; ignorar que a mesma chave é usada para cifrar e decifrar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Processo Geral de Cifragem",
                                  "subSteps": [
                                    "Selecione ou gere uma chave simétrica k compartilhada de forma segura.",
                                    "Prepare a mensagem m (plaintext) dividindo-a em blocos se necessário (para cifras de bloco).",
                                    "Aplique a função E_k: cada bit ou bloco de m é transformado matematicamente usando k.",
                                    "Concatene os resultados para formar o ciphertext c = E_k(m).",
                                    "Transmita c pelo canal inseguro."
                                  ],
                                  "verification": "Desenhe um fluxograma simples mostrando m → E_k → c.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online como Draw.io",
                                    "Vídeo tutorial sobre cifragem simétrica"
                                  ],
                                  "tips": "Pense no processo como uma 'caixa preta' onde k é a 'chave da fechadura'.",
                                  "learningObjective": "Mapear sequencialmente os passos matemáticos e lógicos da transformação plaintext para ciphertext.",
                                  "commonMistakes": "Omitir a preparação de blocos em cifras de bloco; assumir que E_k é reversível sem chave."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Práticos com Cifras de Bloco",
                                  "subSteps": [
                                    "Estude AES como exemplo: divide m em blocos de 128 bits.",
                                    "Descreva rodadas de substituição, permutação e mistura usando k expandida.",
                                    "Simule uma cifragem simples de um bloco com chave fixa (use ferramenta online).",
                                    "Compare com cifra de fluxo como RC4: XOR bit a bit com keystream gerado por k.",
                                    "Note que AES usa múltiplas rodadas para segurança."
                                  ],
                                  "verification": "Execute uma simulação online e descreva o antes/depois de um bloco pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador AES online (ex: AES Animation tool)",
                                    "Chave de exemplo: 16 bytes"
                                  ],
                                  "tips": "Comece com AES-128 para simplicidade; foque em 'substituição-permutação'.",
                                  "learningObjective": "Aplicar o processo geral a exemplos concretos como AES em modo básico.",
                                  "commonMistakes": "Ignorar padding em mensagens não múltiplas do tamanho do bloco; confundir modo ECB com outros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Verificar a Compreensão do Processo",
                                  "subSteps": [
                                    "Resuma o processo completo: seleção de k, preparação de m, aplicação de E_k, output c.",
                                    "Discuta requisitos: k secreta, E_k determinística e reversível com k.",
                                    "Crie uma explicação em 1 minuto para um colega.",
                                    "Identifique vulnerabilidades se k vazar.",
                                    "Relacione com decifragem D_k(c) = m."
                                  ],
                                  "verification": "Grave uma explicação oral de 1-2 minutos e autoavalie clareza.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gravador de voz no celular",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use bullet points para estruturar sua explicação final.",
                                  "learningObjective": "Articular o processo de cifragem de forma coesa e precisa.",
                                  "commonMistakes": "Esquecer que E_k deve ser eficiente para uso prático; exagerar complexidade desnecessária."
                                }
                              ],
                              "practicalExample": "Para cifrar 'HELLO' com cifra XOR simples (chave k='KEY'): Converta para bytes, XOR cada byte com byte correspondente de k repetida ('KEYKEY...'), resultando em ciphertext como '0x1B 0x0E 0x17 0x17 0x1C'. Use Python: c = ''.join(chr(ord(m[i]) ^ ord(k[i % len(k)])) for i in range(len(m))).",
                              "finalVerifications": [
                                "Explicar verbalmente E_k(m) = c sem hesitação.",
                                "Desenhar fluxograma correto do processo.",
                                "Simular cifragem de mensagem curta com ferramenta.",
                                "Identificar componentes em diagrama dado.",
                                "Diferenciar corretamente cifras de bloco vs. fluxo.",
                                "Prever resultado de XOR simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos termos técnicos (plaintext, ciphertext, E_k).",
                                "Sequência lógica dos passos sem omissões.",
                                "Uso de exemplos relevantes como AES.",
                                "Clareza na explicação para leigo.",
                                "Inclusão de verificações de segurança básica.",
                                "Profundidade em sub-passos (pelo menos 4 por step)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações modulares e funções bijetoras.",
                                "História: Cifras como Enigma na WWII.",
                                "Física: Analogia com codificação de sinais.",
                                "Informática: Implementação em programação (Python crypto libs)."
                              ],
                              "realWorldApplication": "Em apps como WhatsApp (Signal protocol com AES para mensagens) ou HTTPS (TLS usa cifras simétricas para dados após handshake), garantindo privacidade em comunicações diárias contra interceptação."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Descrever o processo de decifragem",
                            "description": "Detalhar a inversão do processo via função de decifragem D_k(c) = m, enfatizando que D_k deve ser a inversa exata de E_k para o mesmo k, garantindo recuperação perfeita da mensagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Decifragem",
                                  "subSteps": [
                                    "Revise o processo de cifragem: mensagem original m transformada em texto cifrado c via E_k(m) = c.",
                                    "Identifique que a decifragem é o processo reverso para recuperar m a partir de c.",
                                    "Discuta a importância da chave k ser a mesma para cifragem e decifragem em sistemas simétricos.",
                                    "Explique que sem decifragem correta, a confidencialidade é perdida.",
                                    "Diferencie decifragem de descriptografia (que quebra chaves desconhecidas)."
                                  ],
                                  "verification": "Escreva uma definição de decifragem em suas próprias palavras e compare com a descrição oficial.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta; diagrama de cifragem/decifragem impresso ou digital.",
                                  "tips": "Use setas em um diagrama para visualizar m → c → m.",
                                  "learningObjective": "Entender o papel fundamental da decifragem como inverso da cifragem.",
                                  "commonMistakes": "Confundir decifragem com descriptografia ou assumir chaves diferentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Função de Decifragem D_k",
                                  "subSteps": [
                                    "Apresente a notação matemática: D_k(c) = m, onde c é o texto cifrado e m é a mensagem original.",
                                    "Descreva D_k como uma função parametrizada pela chave secreta k.",
                                    "Explique que D_k é computacionalmente eficiente para o detentor da chave k.",
                                    "Forneça pseudocódigo simples: input c, chave k; output m = decrypt(c, k).",
                                    "Enfatize que D_k opera apenas no domínio do texto cifrado válido."
                                  ],
                                  "verification": "Escreva a fórmula D_k(c) = m e um pseudocódigo básico para decifragem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Quadro branco ou editor de texto; exemplos de funções criptográficas simples.",
                                  "tips": "Sempre inclua a chave k na notação para reforçar o sistema simétrico.",
                                  "learningObjective": "Dominar a notação e definição formal da função de decifragem.",
                                  "commonMistakes": "Omitir a dependência da chave k ou inverter os papéis de entrada/saída."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Inversa Exata de E_k",
                                  "subSteps": [
                                    "Defina função inversa: D_k é inversa de E_k se D_k(E_k(m)) = m para todo m.",
                                    "Demonstre matematicamente: composição E_k ∘ D_k = identidade e D_k ∘ E_k = identidade.",
                                    "Discuta propriedades algébricas necessárias (bijetividade de E_k e D_k).",
                                    "Use exemplo numérico simples para ilustrar a inversa.",
                                    "Aborde que falhas na inversa levam a perda de informação ou erros de recuperação."
                                  ],
                                  "verification": "Prove com um exemplo que D_k(E_k(m)) = m e vice-versa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou software como Python para testes; tabela de funções inversas.",
                                  "tips": "Teste com valores pequenos para visualizar a reversibilidade.",
                                  "learningObjective": "Compreender e demonstrar a propriedade matemática de inversa exata.",
                                  "commonMistakes": "Confundir inversa com simetria ou ignorar o requisito de bijetividade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir Recuperação Perfeita da Mensagem",
                                  "subSteps": [
                                    "Enfatize que a inversa exata assegura m' = D_k(E_k(m)) = m sem perda.",
                                    "Discuta tolerância a ruído ou erros de transmissão em sistemas reais.",
                                    "Explique implicações para confidencialidade e integridade.",
                                    "Compare com sistemas assimétricos onde chaves diferem.",
                                    "Conclua com a importância da eficiência computacional para ambos os processos."
                                  ],
                                  "verification": "Aplique cifragem e decifragem em uma mensagem teste e confirme recuperação exata.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta online de cifra simétrica (ex: AES demo) ou implementações manuais.",
                                  "tips": "Sempre teste com mensagens longas para detectar padrões de falha.",
                                  "learningObjective": "Aplicar o conceito para validar recuperação perfeita em cenários práticos.",
                                  "commonMistakes": "Assumir recuperação perfeita sem verificar a inversa ou ignorar padding/erros."
                                }
                              ],
                              "practicalExample": "Considere a Cifra de César com k=3: Mensagem 'HELLO' → E_3('HELLO') = 'KHOOR'. Decifragem: D_3('KHOOR') = ('K'-3='H'), ('H'-3='E'), etc., resultando em 'HELLO' exato, demonstrando D_3 como inversa perfeita de E_3.",
                              "finalVerifications": [
                                "Descreve corretamente D_k(c) = m com notação precisa.",
                                "Explica a inversa exata D_k(E_k(m)) = m.",
                                "Identifica que a mesma chave k é usada em ambos os processos.",
                                "Demonstra recuperação perfeita com um exemplo numérico.",
                                "Diferencia decifragem de outros processos criptográficos.",
                                "Discute implicações de falha na inversa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de D_k (90%+ acurácia).",
                                "Clareza na explicação da propriedade de inversa.",
                                "Uso de exemplos concretos para ilustrar conceitos.",
                                "Compreensão de requisitos simétricos (mesma chave).",
                                "Identificação de erros comuns e prevenções.",
                                "Capacidade de aplicar em cenários práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções bijetivas e inversas em álgebra.",
                                "História: Evolução da criptografia simétrica desde Enigma.",
                                "Física: Sistemas reversíveis e conservação de informação.",
                                "Informática: Implementação de algoritmos em programação."
                              ],
                              "realWorldApplication": "Em comunicações seguras como HTTPS/TLS ou apps de mensagens (WhatsApp), a decifragem simétrica garante que apenas o destinatário com a chave k recupere mensagens originais perfeitamente, protegendo dados bancários e comunicações privadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Reconhecer algoritmos probabilísticos em simétricos",
                            "description": "Identificar como algoritmos probabilísticos introduzem aleatoriedade (ex: IV em modos de operação) para evitar padrões em ciframentos repetidos da mesma mensagem com a mesma chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Criptografia Simétrica Determinística e seus Problemas",
                                  "subSteps": [
                                    "Revise o funcionamento básico de um cifrador simétrico como AES em modo ECB.",
                                    "Cifre a mesma mensagem plaintext duas vezes com a mesma chave e observe o ciphertext idêntico.",
                                    "Analise visualmente o ciphertext em uma ferramenta de análise de padrões.",
                                    "Identifique como padrões repetidos no plaintext criam vazamentos no ciphertext.",
                                    "Documente os riscos de segurança, como análise de frequência."
                                  ],
                                  "verification": "Gere dois ciphertexts idênticos e explique por que eles revelam padrões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Implementação AES-ECB online (ex: CyberChef), mesma chave e plaintext repetido.",
                                  "tips": "Use mensagens com padrões óbvios como 'AAAAA' para visualizar facilmente.",
                                  "learningObjective": "Compreender por que algoritmos determinísticos falham em mensagens repetidas.",
                                  "commonMistakes": "Confundir modo de operação com o algoritmo base; assumir que AES sempre é probabilístico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceito de Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Defina algoritmo probabilístico: usa aleatoriedade para produzir saídas diferentes para mesma entrada.",
                                    "Compare com determinísticos: mesma entrada/chave sempre produz mesmo output.",
                                    "Estude fontes de aleatoriedade em cripto: geradores de números pseudo-aleatórios (PRNG).",
                                    "Discuta papel da aleatoriedade em evitar padrões previsíveis.",
                                    "Exemplo simples: adição de nonce ou IV ao plaintext antes de cifrar."
                                  ],
                                  "verification": "Explique em suas palavras a diferença e dê um exemplo não-cripto de probabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigos sobre PRNG (ex: Wikipedia), diagrama de fluxo determinístico vs probabilístico.",
                                  "tips": "Pense em dados como um dado: mesmo input, output varia.",
                                  "learningObjective": "Diferenciar algoritmos determinísticos de probabilísticos no contexto criptográfico.",
                                  "commonMistakes": "Achar que toda aleatoriedade é 'verdadeira' random; ignorar PRNG vs TRNG."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar IV e Modos de Operação Probabilísticos",
                                  "subSteps": [
                                    "Aprenda o que é IV: vetor de inicialização aleatório único por cifragem.",
                                    "Estude modos CBC e CTR: como IV é incorporado para introduzir aleatoriedade.",
                                    "Cifre a mesma mensagem em CBC com IVs diferentes e compare ciphertexts.",
                                    "Analise por que IV evita padrões em mensagens repetidas.",
                                    "Verifique decifragem correta apesar de IVs variados."
                                  ],
                                  "verification": "Produza ciphertexts diferentes para mesma mensagem/chave mudando só IV.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta CyberChef ou Python com cryptography library, exemplos de modos AES.",
                                  "tips": "Sempre gere IV aleatório novo; nunca reuse em produção.",
                                  "learningObjective": "Reconhecer IV como mecanismo chave para probabilisticidade em simétricos.",
                                  "commonMistakes": "Reutilizar IV; confundir IV com chave; achar que IV é secreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento de Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Analise ciphertexts de ECB vs CBC: identifique padrões visuais.",
                                    "Classifique modos: ECB (determinístico), CBC/CTR (probabilístico).",
                                    "Resolva exercícios: dado código ou diagrama, diga se é probabilístico e por quê.",
                                    "Discuta ataques como chosen-plaintext em determinísticos.",
                                    "Crie um fluxograma para verificação rápida."
                                  ],
                                  "verification": "Corretamente classifique 5 exemplos de modos como probabilísticos ou não.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exercícios online (CryptoPals), imagens de ciframentos ECB vs CBC (pinguins).",
                                  "tips": "Procure padrões em blocos: uniformidade indica probabilístico.",
                                  "learningObjective": "Identificar algoritmos probabilísticos em cenários reais de cifragem simétrica.",
                                  "commonMistakes": "Ignorar modo de operação; focar só no algoritmo base como AES."
                                }
                              ],
                              "practicalExample": "Cifrando 'Hello World' duas vezes com AES-128-CBC: Primeira com IV=000...01 resulta em ciphertext 'a1b2c3...', segunda com IV=000...02 em 'x9y8z7...'. Mesma mensagem/chave, ciphertexts diferentes devido ao IV probabilístico. Em ECB, seriam idênticos, revelando padrões.",
                              "finalVerifications": [
                                "Explicar corretamente por que ECB falha em mensagens repetidas.",
                                "Identificar IV em um diagrama de modo CBC.",
                                "Gerar e comparar ciphertexts probabilísticos vs determinísticos.",
                                "Listar 3 modos probabilísticos comuns em simétricos.",
                                "Discutir risco de reutilização de IV.",
                                "Classificar um código-fonte como probabilístico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção determinístico vs probabilístico (80% acerto).",
                                "Explicação clara do papel do IV (detalhes sobre aleatoriedade).",
                                "Análise correta de exemplos práticos (sem padrões detectados).",
                                "Uso correto de terminologia (IV, modos de operação, PRNG).",
                                "Identificação de erros comuns em cenários dados.",
                                "Criatividade em conexões reais (ex: segurança web)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da probabilidade e entropia.",
                                "Estatística: Análise de padrões e testes de aleatoriedade (Chi-quadrado).",
                                "Segurança da Informação: Modelos de ataque (CPA).",
                                "Programação: Implementação de PRNG em linguagens como Python.",
                                "Física: Analogia com ruído quântico em TRNG."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS, AES-GCM usa nonce (similar a IV) para cifrar dados de sessão, garantindo que tráfego repetido (ex: logins) não revele padrões, protegendo privacidade em bancos e e-mails."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Propriedades de Confidencialidade e Autenticação",
                        "description": "Atributos de segurança fundamentais proporcionados por criptosistemas simétricos, como proteção contra divulgação não autorizada e verificação de integridade/origem da mensagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Explicar confidencialidade em criptosistemas simétricos",
                            "description": "Definir confidencialidade como a garantia de que apenas detentores da chave correta podem recuperar o plaintext, resistindo a ataques de criptoanálise básica sem a chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o conceito de confidencialidade em criptografia",
                                  "subSteps": [
                                    "Leia a definição formal: confidencialidade garante que apenas detentores da chave correta acessem o plaintext.",
                                    "Compare com analogia: como uma caixa-forte onde só a chave abre.",
                                    "Identifique os elementos chave: plaintext, ciphertext, chave secreta.",
                                    "Anote exemplos cotidianos de confidencialidade sem criptografia (ex: diário trancado).",
                                    "Resuma em suas palavras o que significa 'garantia de sigilo'."
                                  ],
                                  "verification": "Escreva uma definição de confidencialidade em 2-3 frases e compare com a definição padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição padrão de confidencialidade",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": [
                                    "Use analogias simples para fixar o conceito.",
                                    "Evite confundir com autenticação."
                                  ],
                                  "learningObjective": "Compreender o significado fundamental de confidencialidade como propriedade criptográfica.",
                                  "commonMistakes": [
                                    "Confundir confidencialidade com integridade.",
                                    "Pensar que confidencialidade é absoluta sem chave."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender criptosistemas simétricos e seu papel na confidencialidade",
                                  "subSteps": [
                                    "Descreva criptosistema simétrico: mesma chave para encriptar e decriptar.",
                                    "Estude exemplos: DES, AES.",
                                    "Desenhe diagrama: plaintext -> encripta(chave) -> ciphertext -> decripta(chave) -> plaintext.",
                                    "Explique por que simetria é crucial para confidencialidade.",
                                    "Liste vantagens: velocidade em comparação a assimétricos."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama de encriptação/decryptação simétrica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de exemplo de AES",
                                    "Ferramenta de desenho como Draw.io ou papel"
                                  ],
                                  "tips": [
                                    "Lembre: chave secreta compartilhada só entre partes confiáveis.",
                                    "Pratique desenhando o fluxo várias vezes."
                                  ],
                                  "learningObjective": "Diferenciar criptosistemas simétricos e associá-los à confidencialidade.",
                                  "commonMistakes": [
                                    "Confundir simétrico com assimétrico (chaves públicas/privadas).",
                                    "Ignorar risco de divulgação da chave."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar como a confidencialidade é garantida no processo",
                                  "subSteps": [
                                    "Detalhe o algoritmo: função de encriptação E_k(m) = c, decrypta D_k(c) = m.",
                                    "Simule com exemplo simples: chiffre 'HELLO' com chave 'KEY' usando cifra de César adaptada.",
                                    "Discuta dependência da chave: sem ela, ciphertext é indecifrável.",
                                    "Aborde força computacional: resistência a força bruta.",
                                    "Teste mental: tente decriptar sem chave."
                                  ],
                                  "verification": "Realize uma simulação manual de encriptação e explique por que não pode decriptar sem chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de cifra simples (César ou substitution)",
                                    "Calculadora ou simulador online básico"
                                  ],
                                  "tips": [
                                    "Use chaves longas para ilustrar força.",
                                    "Foquem na unicidade da chave."
                                  ],
                                  "learningObjective": "Articular o mecanismo matemático que assegura confidencialidade.",
                                  "commonMistakes": [
                                    "Achar que qualquer algoritmo garante confidencialidade.",
                                    "Subestimar ataques conhecidos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resistência a ataques de criptoanálise básica",
                                  "subSteps": [
                                    "Liste ataques básicos: análise de frequência, força bruta sem chave.",
                                    "Explique por que falham: ciphertext parece ruído aleatório.",
                                    "Estude métricas: entropia alta do ciphertext.",
                                    "Compare com texto plano: padrões legíveis vs. aleatoriedade.",
                                    "Conclua: confidencialidade sem chave é mantida."
                                  ],
                                  "verification": "Descreva um ataque básico e justifique por que falha em simétricos bem projetados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de ataques de frequência",
                                    "Textos cifrados de amostra"
                                  ],
                                  "tips": [
                                    "Visualize frequência de letras em ciphertext.",
                                    "Use ferramentas como CyberChef para demo."
                                  ],
                                  "learningObjective": "Compreender limitações de ataques sem chave na confidencialidade.",
                                  "commonMistakes": [
                                    "Confundir criptoanálise com quebra por força bruta viável.",
                                    "Ignorar que chaves fracas comprometem tudo."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de mensagens como WhatsApp, uma conversa 'Oi, vamos ao cinema?' é encriptada com AES (simétrico) usando uma chave compartilhada. Sem a chave, o atacante vê apenas bytes aleatórios como 'x7f2a9b...', incapaz de ler o plaintext.",
                              "finalVerifications": [
                                "Defina confidencialidade corretamente em contexto simétrico.",
                                "Descreva o fluxo E_k e D_k sem erros.",
                                "Explique por que ataques básicos falham sem chave.",
                                "Dê um exemplo prático de aplicação.",
                                "Diferencie confidencialidade de outras propriedades.",
                                "Simule uma encriptação simples manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de confidencialidade (90% match com padrão).",
                                "Correta representação do processo simétrico em diagrama.",
                                "Explicação clara de resistência a criptoanálise básica.",
                                "Uso de exemplos relevantes e analogias eficazes.",
                                "Identificação de pelo menos 3 erros comuns evitados.",
                                "Compreensão integrada de chave como elemento central."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções injetivas e bijetivas em algoritmos de cifra.",
                                "Ética: Privacidade de dados e leis como LGPD/GDPR.",
                                "Física: Analogias com ondas e ruído aleatório.",
                                "História: Evolução de cifras simétricas (Enigma na WWII)."
                              ],
                              "realWorldApplication": "Garante sigilo em comunicações seguras como banking apps (ex: encriptação de senhas), VPNs para tráfego internet privado e armazenamento de dados em nuvem, protegendo contra eavesdroppers sem a chave compartilhada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Descrever autenticação proporcionada",
                            "description": "Discutir como modos de operação ou MACs (Message Authentication Codes) baseados em chaves simétricas fornecem autenticação, detectando modificações ou falsificações na mensagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de autenticação em criptografia",
                                  "subSteps": [
                                    "Definir autenticação como a garantia de que a mensagem veio da fonte correta e não foi alterada.",
                                    "Diferenciar autenticação de confidencialidade, explicando que autenticação foca em integridade e origem.",
                                    "Identificar ameaças como modificação e falsificação de mensagens.",
                                    "Explicar o papel das chaves simétricas na autenticação."
                                  ],
                                  "verification": "Resumir em 3 frases os conceitos chave e compartilhar com um colega para feedback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Acesso à internet para leitura de artigos introdutórios sobre criptografia (ex: Wikipedia - Autenticação de mensagens).",
                                  "tips": "Use diagramas simples para visualizar fluxo de mensagem autêntica vs. falsificada.",
                                  "learningObjective": "Diferenciar autenticação de confidencialidade e identificar ameaças principais.",
                                  "commonMistakes": "Confundir autenticação com encriptação, achando que cifrar basta para autenticar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Message Authentication Codes (MACs)",
                                  "subSteps": [
                                    "Explicar como MACs usam chaves simétricas e funções hash para gerar uma tag de autenticação.",
                                    "Descrever o processo: remetente calcula MAC(mensagem, chave) e anexa à mensagem.",
                                    "Mostrar verificação: destinatário recalcula MAC e compara com o recebido.",
                                    "Discutir detecção de modificações: qualquer alteração invalida o MAC.",
                                    "Mencionar exemplos como HMAC-SHA256."
                                  ],
                                  "verification": "Calcular manualmente um MAC simples com hash fictício e verificar se altera com mudança na mensagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação RFC 2104 (HMAC), calculadora online de hash (ex: CyberChef).",
                                  "tips": "Pense no MAC como uma 'assinatura digital simétrica' colada na mensagem.",
                                  "learningObjective": "Descrever o funcionamento e verificação de MACs baseados em chaves simétricas.",
                                  "commonMistakes": "Ignorar que MAC requer chave compartilhada, confundindo com chaves assimétricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar modos de operação que fornecem autenticação",
                                  "subSteps": [
                                    "Introduzir modos como CBC-MAC e GCM (Galois/Counter Mode).",
                                    "Explicar CBC-MAC: último bloco de cifragem em CBC como tag de autenticação.",
                                    "Descrever GCM: combina cifragem CTR com autenticação GMAC para integridade e confidencialidade.",
                                    "Comparar: MAC puro para autenticação só, modos para autenticação + cifragem.",
                                    "Mostrar como detectam falsificações via falha na verificação da tag."
                                  ],
                                  "verification": "Desenhar fluxogramas de CBC-MAC e GCM, destacando ponto de falha em ataques.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Vídeos tutoriais (ex: Khan Academy ou YouTube sobre modos AEAD), papel e caneta para diagramas.",
                                  "tips": "Lembre: modos autênticos previnem ataques como padding oracle via tags integradas.",
                                  "learningObjective": "Comparar MACs e modos de operação autênticos em detecção de modificações.",
                                  "commonMistakes": "Achar que todos os modos simétricos autenticam (ex: CBC puro não autentica sozinho)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e praticar detecção de autenticação",
                                  "subSteps": [
                                    "Revisar como MACs/modos detectam qualquer alteração (devido a funções hash colisão-resistentes).",
                                    "Simular ataque: alterar mensagem e mostrar MAC inválido.",
                                    "Discutir limitações: replay attacks (mitigados com nonces/timestamps).",
                                    "Aplicar a cenários: autenticação em protocolos como TLS.",
                                    "Formular explicação completa da autenticação proporcionada."
                                  ],
                                  "verification": "Escrever parágrafo descrevendo autenticação e testar com quiz autoavaliativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto, exemplos de código Python com hmac e cryptography library.",
                                  "tips": "Teste com código real: implemente e quebre um MAC para ver na prática.",
                                  "learningObjective": "Explicar integralmente como chaves simétricas detectam falsificações.",
                                  "commonMistakes": "Subestimar necessidade de chaves secretas compartilhadas e frescas."
                                }
                              ],
                              "practicalExample": "Usando Python com biblioteca hmac: gere MAC para 'Mensagem secreta' com chave 'minha_chave_secreta'. Altere para 'Mensagem alterada' e veja a verificação falhar, demonstrando detecção de modificação em um chat seguro simulado.",
                              "finalVerifications": [
                                "Explicar em suas palavras como um MAC detecta falsificação.",
                                "Identificar diferença entre MAC e modo GCM em um diagrama.",
                                "Simular verificação de MAC em exemplo prático sem erros.",
                                "Listar 3 ataques prevenidos por autenticação simétrica.",
                                "Descrever limitação de replay e solução com nonce."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção de autenticação vs. confidencialidade (30%).",
                                "Detalhe técnico: Explicação clara de MAC e modos com exemplos (25%).",
                                "Compreensão prática: Demonstração de detecção via simulação (20%).",
                                "Análise de ameaças: Identificação de modificações/falsificações (15%).",
                                "Clareza de expressão: Linguagem técnica acessível e sem erros (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e propriedades colisão-resistentes.",
                                "Segurança da Informação: Protocolos como TLS/IPsec usando MACs.",
                                "Redes de Computadores: Autenticação em camadas de transporte.",
                                "Programação: Implementação com bibliotecas crypto em Python/Java."
                              ],
                              "realWorldApplication": "Em protocolos como TLS 1.3 (usa AEAD como GCM para autenticação de mensagens HTTP), garantindo que dados em transações bancárias online não sejam alterados por atacantes MITM, ou em apps de mensagens seguras como Signal para verificar integridade de chats."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Relacionar com criptoanálise básica",
                            "description": "Entender vulnerabilidades básicas como ataques de texto plano conhecido ou cifra única, e como propriedades simétricas mitigam-nas quando a chave é segura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Ataques Básicos de Criptoanálise: Texto Plano Conhecido e Cifra Única",
                                  "subSteps": [
                                    "Defina ataque de texto plano conhecido (known-plaintext attack): atacante conhece pares plaintext-ciphertext.",
                                    "Explique ataque de cifra única (monoalfabética): frequência de letras revela padrões sem chave.",
                                    "Compare com ciphertext-only attack para contextualizar limitações.",
                                    "Estude exemplos históricos como cifra de César ou Vigenère fraca.",
                                    "Identifique por que esses ataques funcionam em cifras fracas."
                                  ],
                                  "verification": "Resuma em 3 frases os dois ataques e forneça um exemplo simples de cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeos introdutórios sobre criptoanálise (Khan Academy ou YouTube)",
                                    "Papel e lápis para simulações manuais"
                                  ],
                                  "tips": "Use mensagens comuns como 'HELLO' para demonstrar known-plaintext.",
                                  "learningObjective": "Identificar e descrever mecanismos de ataques básicos de criptoanálise.",
                                  "commonMistakes": "Confundir known-plaintext com chosen-plaintext; assumir que cifras antigas são irrelevantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vulnerabilidades em Cifras Simples",
                                  "subSteps": [
                                    "Simule known-plaintext em cifra de substituição: mapeie letras conhecidas.",
                                    "Demonstre análise de frequência em cifra única para quebrar padrões.",
                                    "Calcule entropia básica: compare distribuição de letras em plaintext vs. ciphertext.",
                                    "Discuta impacto: recuperação de chave ou mensagem completa.",
                                    "Registre limitações: requer amostras suficientes."
                                  ],
                                  "verification": "Quebre uma cifra simples de 20 caracteres usando known-plaintext e explique o processo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef ou dCode.fr",
                                    "Textos de exemplo criptografados"
                                  ],
                                  "tips": "Comece com plaintext previsível como cabeçalhos de email.",
                                  "learningObjective": "Aplicar ataques práticos para expor fraquezas de cifras primitivas.",
                                  "commonMistakes": "Ignorar contexto linguístico; superestimar segurança de cifras curtas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedades de Criptosistemas Simétricos Seguros",
                                  "subSteps": [
                                    "Descreva confidencialidade em cifras como AES: avalanche effect e difusão.",
                                    "Explique por que known-plaintext não revela chave: cada bloco é independente com IV.",
                                    "Discuta autenticação: MACs previnem modificações (ex: AES-GCM).",
                                    "Compare com cifras fracas: blocos múltiplos e chaves longas resistem análise.",
                                    "Enfatize requisito: chave secreta e aleatória."
                                  ],
                                  "verification": "Diagramar fluxo AES e marcar onde known-plaintext falha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Diagramas AES (Wikipedia)",
                                    "Simulador criptográfico como CrypTool"
                                  ],
                                  "tips": "Visualize 'efeito avalanche': 1 bit muda afeta 50% do output.",
                                  "learningObjective": "Compreender como propriedades simétricas superam ataques básicos.",
                                  "commonMistakes": "Confundir simétrico com assimétrico; ignorar IV/nonce."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Mitigações e Verificar Compreensão",
                                  "subSteps": [
                                    "Mapeie ataques a propriedades: confidencialidade bloqueia known-plaintext via confusão/difusão.",
                                    "Explique autenticação mitiga cifra única/modificações.",
                                    "Discuta cenários de falha: chave fraca ou reutilizada.",
                                    "Crie tabela comparativa: cifras fracas vs. simétricas.",
                                    "Teste com exemplo: criptografe mensagem em AES e tente 'atacar'."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como AES mitiga os dois ataques.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca Python cryptography para demo",
                                    "Planilha comparativa"
                                  ],
                                  "tips": "Use chaves de 128+ bits; evite ECB mode.",
                                  "learningObjective": "Integrar conceitos para justificar segurança simétrica.",
                                  "commonMistakes": "Atribuir segurança à cifra em vez da chave; negligenciar autenticação."
                                }
                              ],
                              "practicalExample": "Simule um known-plaintext attack em cifra de César ('ATTACKATDAWN' -> shifted) para quebrar em 5 tentativas. Em AES-128 com chave segura, mesmo conhecendo 1M pares plaintext-ciphertext, a chave permanece secreta devido à difusão.",
                              "finalVerifications": [
                                "Descreva known-plaintext attack e por que falha em AES.",
                                "Explique análise de frequência em cifra única e sua ineficácia em blocos.",
                                "Liste 3 propriedades simétricas que mitigam esses ataques.",
                                "Forneça exemplo de falha por chave insegura.",
                                "Crie diagrama de fluxo de ataque vs. defesa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ataques (90%+ correto).",
                                "Clareza na explicação de mitigações simétricas.",
                                "Uso correto de terminologia (confidencialidade, autenticação, avalanche).",
                                "Exemplos práticos viáveis e relevantes.",
                                "Compreensão de dependência na chave segura.",
                                "Integração interdisciplinar básica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise estatística de frequências e teoria da informação (entropia).",
                                "História: Criptoanálise na WWII (Enigma e known-plaintext).",
                                "Física: Analogia com caos determinístico no efeito avalanche.",
                                "Ética: Implicações de segurança em privacidade digital."
                              ],
                              "realWorldApplication": "Em apps de mensagens como WhatsApp (Signal Protocol com AES), mitiga eavesdropping mesmo se atacante conhece plaintext padrão (ex: 'Hi'), protegendo comunicações bancárias e dados pessoais contra hackers básicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.3",
                              "10.1.2.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Data Encryption Standard (DES)",
                    "description": "Descrição do algoritmo DES, suas 16 rodadas de substituição-permutação e limitações de segurança devido ao tamanho da chave.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Estrutura Geral do DES",
                        "description": "Visão geral do algoritmo Data Encryption Standard (DES), incluindo o bloco de entrada de 64 bits, a chave de 64 bits (com 56 bits efetivos), a permutação inicial (IP), as 16 rodadas e a permutação final (IP^{-1}).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar os componentes principais do DES",
                            "description": "Reconhecer e descrever os elementos fundamentais do DES: bloco de texto plano de 64 bits, chave de 64 bits com paridade, permutação inicial IP, 16 rodadas de Feistel e permutação final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Entradas do DES: Bloco de Texto Plano e Chave",
                                  "subSteps": [
                                    "Examine o tamanho padrão do bloco de texto plano: exatamente 64 bits.",
                                    "Identifique a chave de 64 bits, incluindo 8 bits de paridade (bits 8,16,...,64), resultando em 56 bits efetivos de chave.",
                                    "Entenda que o texto plano é dividido em blocos de 64 bits se maior.",
                                    "Revise exemplos binários simples de plaintext e chaves para familiarização."
                                  ],
                                  "verification": "Liste corretamente os tamanhos e propósitos do plaintext e da chave, mencionando paridade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de estrutura geral do DES",
                                    "Exemplos binários de plaintext e chave (pode usar ferramentas online como DES visualizadores)"
                                  ],
                                  "tips": "Sempre verifique se a chave tem exatamente 64 bits, com paridade nos positions pares.",
                                  "learningObjective": "Reconhecer as especificações exatas das entradas do algoritmo DES.",
                                  "commonMistakes": "Confundir o tamanho efetivo da chave (56 bits) com o total (64 bits) ou ignorar bits de paridade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Permutação Inicial (IP)",
                                  "subSteps": [
                                    "Estude a tabela de permutação inicial IP, que reordena os 64 bits do plaintext.",
                                    "Memorize ou anote os primeiros e últimos bits da IP: bit 58 primeiro, bit 58 último.",
                                    "Entenda que IP é uma expansão fixa sem perda de informação (bijetiva).",
                                    "Aplique IP manualmente a um exemplo de 64 bits plaintext truncado para prática."
                                  ],
                                  "verification": "Aplique IP a um plaintext de exemplo e confirme a saída corresponde à tabela padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de permutação IP do DES (disponível em RFC 46 ou diagramas)"
                                  ],
                                  "tips": "Use uma tabela para mapear positions; ferramentas como Python DES simulators ajudam na verificação.",
                                  "learningObjective": "Descrever o papel e funcionamento da permutação inicial IP no DES.",
                                  "commonMistakes": "Confundir IP com permutação da chave ou aplicar tabela errada (há IP e FP distintas)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar as 16 Rodadas de Rede Feistel",
                                  "subSteps": [
                                    "Descreva a estrutura Feistel: L0/R0 -> L1 = R0, R1 = L0 XOR f(R0, K1).",
                                    "Entenda que cada rodada usa uma subchave Ki derivada da chave principal.",
                                    "Note que há 16 rodadas idênticas em estrutura, mas com subchaves diferentes.",
                                    "Revise a função f: expansão para 48 bits, S-boxes e permutação final de 32 bits."
                                  ],
                                  "verification": "Desenhe ou liste o fluxo de uma rodada Feistel, identificando L, R e f.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama detalhado de uma rodada Feistel do DES",
                                    "Tabelas de expansão E e S-boxes (8 caixas)"
                                  ],
                                  "tips": "Foquem na simetria: metade esquerda/direita trocam papéis invertidas nas rodadas pares/ímpares.",
                                  "learningObjective": "Identificar e descrever a rede Feistel como coração do DES com 16 iterações.",
                                  "commonMistakes": "Pensar que todas rodadas usam a mesma subchave ou ignorar a inversibilidade da Feistel."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar a Permutação Final e Saída",
                                  "subSteps": [
                                    "Aprenda que a permutação final é IP^{-1}, a inversa da IP inicial.",
                                    "Entenda que após 16 rodadas, aplica-se FP aos 64 bits (L16/R16 concatenados).",
                                    "Confirme que isso produz o ciphertext de 64 bits.",
                                    "Verifique com exemplo: entrada e saída devem ser consistentes com IP * FP = identidade."
                                  ],
                                  "verification": "Aplique FP a uma saída de rodadas simulada e liste os componentes finais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de permutação final FP (inversa da IP)",
                                    "Simulador DES online para validação completa"
                                  ],
                                  "tips": "Lembre-se: FP desfaz a IP, restaurando ordem original exceto pelo processamento.",
                                  "learningObjective": "Reconhecer o papel da permutação final em completar o ciclo DES.",
                                  "commonMistakes": "Confundir ordem de FP com IP ou achar que há mais rodadas após FP."
                                }
                              ],
                              "practicalExample": "Para plaintext P = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 (64 zeros) e chave K padrão (ex: 00010011 00110100 ...), aplique IP -> 16 Feistels -> FP para obter ciphertext, visualizando como cada componente transforma os bits.",
                              "finalVerifications": [
                                "Liste os 5 componentes principais: plaintext 64b, chave 64b/paridade, IP, 16 Feistels, FP.",
                                "Desenhe diagrama de alto nível do fluxo DES.",
                                "Explique verbalmente o caminho de bits de input a output.",
                                "Identifique tamanhos exatos em cada etapa.",
                                "Simule uma rodada Feistel com valores binários simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos componentes (100% cobertura).",
                                "Descrições claras e corretas sem omissões (ex: mencionar paridade).",
                                "Capacidade de aplicar IP/FP em exemplo pequeno.",
                                "Compreensão da estrutura Feistel (L/R swap).",
                                "Uso correto de terminologia técnica (Feistel, permutação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Permutações e funções bijetivas (IP/FP).",
                                "História da Computação: Evolução de padrões NIST (DES para AES).",
                                "Segurança Cibernética: Conceitos de chave simétrica e ataques brute-force.",
                                "Algoritmos: Estruturas iterativas e subchaves derivadas."
                              ],
                              "realWorldApplication": "O DES foi padrão federal dos EUA (1977-2005) para proteger transações ATM, comunicações militares e dados bancários, ilustrando como componentes como Feistel garantem eficiência em hardware limitado da época."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Explicar o modo de operação Feistel no DES",
                            "description": "Descrever a estrutura de rede de Feistel utilizada no DES, onde o bloco é dividido em duas metades de 32 bits (L e R), e cada rodada atualiza R_{i} = L_{i-1} XOR f(R_{i-1}, K_i).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico da Rede de Feistel",
                                  "subSteps": [
                                    "Estude a definição de uma rede de Feistel como uma estrutura simétrica para cifras de bloco que permite descriptografia sem função inversa.",
                                    "Identifique os componentes principais: entrada dividida em duas metades (L0 e R0), função de rodada f, chaves de rodada Ki e operação XOR.",
                                    "Compare com cifras não-Feistel para destacar a vantagem da invertibilidade inerente.",
                                    "Desenhe um diagrama esquemático de uma rede Feistel genérica com 1 rodada.",
                                    "Revise exemplos históricos como Lucifer, precursor do DES."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de rede Feistel básica e explique verbalmente sua invertibilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Artigo ou vídeo introdutório sobre redes Feistel (ex: Wikipedia DES)"
                                  ],
                                  "tips": "Comece com uma visão geral ampla antes de detalhes; use analogias como 'troca de lados com mistura'.",
                                  "learningObjective": "Entender os princípios fundamentais e vantagens da estrutura Feistel.",
                                  "commonMistakes": [
                                    "Confundir com cifras de fluxo",
                                    "Ignorar a simetria L/R",
                                    "Achar que f precisa ser invertível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Divisão do Bloco de 64 Bits em DES",
                                  "subSteps": [
                                    "Confirme que o DES processa blocos de 64 bits (incluindo 8 bits de paridade).",
                                    "Divida explicitamente em L0 (primeiros 32 bits) e R0 (últimos 32 bits).",
                                    "Explique a notação: para rodada i, Li = Ri-1 e Ri = Li-1 XOR f(Ri-1, Ki).",
                                    "Implemente uma divisão manual em um exemplo de bloco hexadecimal simples (ex: 0x0123456789ABCDEF).",
                                    "Verifique que a concatenação L0 || R0 forma o plaintext original."
                                  ],
                                  "verification": "Divida um bloco de 64 bits exemplo em L0 e R0 e recite a notação de atualização.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal",
                                    "Ferramenta online de conversão bin/hex (ex: CyberChef)"
                                  ],
                                  "tips": "Sempre escreva L à esquerda e R à direita no diagrama para evitar confusão visual.",
                                  "learningObjective": "Dominar a divisão inicial e notação das metades no DES.",
                                  "commonMistakes": [
                                    "Trocar ordem de L e R",
                                    "Esquecer bits de paridade",
                                    "Usar 64 bits por metade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o Processo de uma Rodada Individual",
                                  "subSteps": [
                                    "Descreva a função f: expansão de 32 para 48 bits, XOR com Ki (48 bits), S-boxes (compressão para 32 bits), P-box (permutação).",
                                    "Simule matematicamente: Ri = Li-1 XOR f(Ri-1, Ki).",
                                    "Implemente um exemplo numérico simplificado com valores pequenos (ex: L=1010, R=1100, f=0110 → novo R=1010 XOR 0110=1100).",
                                    "Desenhe o fluxo de uma única rodada com setas e rótulos.",
                                    "Explique por que XOR garante invertibilidade: XOR é sua própria inversa."
                                  ],
                                  "verification": "Simule uma rodada com números binários de 4 bits e obtenha saída correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para binários",
                                    "Tabela de S-boxes DES (impressa ou online)"
                                  ],
                                  "tips": "Pratique com blocos pequenos primeiro; memorize que f é não-linear via S-boxes.",
                                  "learningObjective": "Executar e explicar o cálculo de uma rodada Feistel no DES.",
                                  "commonMistakes": [
                                    "Esquecer expansão/permutação em f",
                                    "Confundir entrada/saída de f",
                                    "Aplicar XOR incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Múltiplas Rodadas e Descriptografia",
                                  "subSteps": [
                                    "Descreva as 16 rodadas do DES com chaves Ki derivadas de uma chave mestra de 56 bits.",
                                    "Após 16 rodadas, inverta: ciphertext = RL || RR (troca final de metades).",
                                    "Explique descriptografia: use rodadas reversas com chaves em ordem inversa, sem troca inicial.",
                                    "Simule 2 rodadas completas com exemplo numérico.",
                                    "Discuta por que 16 rodadas proporcionam difusão/confusão suficientes."
                                  ],
                                  "verification": "Descreva o processo completo de 16 rodadas e demonstre descriptografia em diagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama completo DES (template online)",
                                    "Simulador DES (ex: DES calculator tools)"
                                  ],
                                  "tips": "Lembre: descriptografia é idêntica à encriptação, só chaves reversas – chave genial do Feistel!",
                                  "learningObjective": "Compreender o ciclo completo e propriedade de auto-inversão.",
                                  "commonMistakes": [
                                    "Esquecer troca final de metades",
                                    "Confundir ordem de chaves na descriptografia",
                                    "Achar que precisa de 32 rodadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o DES simplificado com 2 rodadas em um bloco de 8 bits (4 L + 4 R): Plaintext=1011 1100, K1=0011, f(R,K)=R XOR K. Rodada 1: L1=1100, R1=1011 XOR f(1100,0011)=1011 XOR 1111=0100. Continue para rodada 2 e verifique descriptografia.",
                              "finalVerifications": [
                                "Desenhar diagrama completo de rede Feistel do DES com 16 rodadas.",
                                "Recitar notação exata: Ri = Li-1 XOR f(Ri-1, Ki).",
                                "Simular corretamente 1-2 rodadas com exemplo numérico.",
                                "Explicar descriptografia sem função inversa de f.",
                                "Identificar componentes de f (expansão, S-boxes, P-box).",
                                "Comparar com cifra moderna como AES (não-Feistel)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação e fórmulas matemáticas (ex: XOR correto).",
                                "Clareza no diagrama visual com rótulos apropriados.",
                                "Profundidade na explicação de f e sua não-linearidade.",
                                "Correta descrição da descriptografia e invertibilidade.",
                                "Uso de exemplos concretos para ilustrar conceitos.",
                                "Identificação de vantagens sobre estruturas não-Feistel."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise (XOR, permutações) e teoria de grupos.",
                                "História: Evolução da criptografia (Lucifer → DES → AES).",
                                "Engenharia de Software: Implementação em linguagens como Python (biblioteca pycryptodome).",
                                "Segurança da Informação: Análise de ataques como differential cryptanalysis no DES.",
                                "Física: Analogia com difusão em sistemas caóticos."
                              ],
                              "realWorldApplication": "O modo Feistel no DES foi base para padrões como Triple DES e influencia cifras modernas (ex: Blowfish, Twofish); usado em protocolos legados como SSL/TLS antigos, pagamentos eletrônicos iniciais e sistemas embarcados, destacando princípios de segurança simétrica escaláveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Diferenciar criptografia direta e inversa no DES",
                            "description": "Entender que a descriptografia no DES usa as mesmas rodadas em ordem reversa com chaves subchaves em ordem reversa, sem necessidade de algoritmo separado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura geral do DES e suas rodadas",
                                  "subSteps": [
                                    "Estude o fluxo inicial do DES: IP (permutação inicial), 16 rodadas de Feistel e IP^{-1} (permutação final inversa).",
                                    "Identifique os componentes de uma rodada Feistel: expansão, XOR com subchave, S-boxes e permutação P.",
                                    "Anote que as 16 subchaves (K1 a K16) são geradas a partir da chave principal de 64 bits.",
                                    "Desenhe um diagrama simples do DES destacando as 16 rodadas.",
                                    "Memorize que cada rodada usa uma subchave única em ordem sequencial para encriptação."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama do DES com 16 rodadas e subchaves K1-K16.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do DES (impresso ou online)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use cores diferentes para distinguir esquerda e direita no cipher block chaining.",
                                  "learningObjective": "Compreender a arquitetura Feistel do DES e o papel das 16 rodadas.",
                                  "commonMistakes": [
                                    "Confundir IP com IP^{-1}",
                                    "Ignorar que subchaves são pré-computadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o processo de criptografia direta (encriptação)",
                                  "subSteps": [
                                    "Simule a encriptação: após IP, aplique rodada 1 com K1, rodada 2 com K2, ..., rodada 16 com K16.",
                                    "Observe que o lado direito (R) é expandido, XOR com Ki, processado por S-boxes e P, então XOR com esquerdo (L).",
                                    "Troque L e R após cada rodada, terminando com IP^{-1}.",
                                    "Registre a sequência: subchaves K1 → K16 em ordem progressiva.",
                                    "Teste com um bloco de 64 bits fictício para rastrear o fluxo."
                                  ],
                                  "verification": "Liste a ordem das subchaves usadas (K1 a K16) e descreva o swap L/R.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de simulação DES (ex: DES calculator)",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Rastreie apenas L e R em poucas rodadas para visualizar o padrão.",
                                  "learningObjective": "Dominar a sequência exata de subchaves na encriptação direta.",
                                  "commonMistakes": [
                                    "Esquecer o swap L/R após cada rodada",
                                    "Usar chaves erradas nas rodadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o processo de criptografia inversa (descriptografia)",
                                  "subSteps": [
                                    "Inicie a descriptografia com IP no ciphertext, mas use rodadas em ordem reversa.",
                                    "Aplique rodada 1 com K16, rodada 2 com K15, ..., rodada 16 com K1.",
                                    "Mantenha a mesma estrutura Feistel: expansão, XOR com subchave reversa, S-boxes, P e swap L/R.",
                                    "Finalize com IP^{-1} para recuperar o plaintext.",
                                    "Compare fluxogramas: mesma lógica Feistel, mas subchaves invertidas."
                                  ],
                                  "verification": "Liste a ordem das subchaves na descriptografia (K16 a K1) e confirme reversibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo diagrama do Step 1",
                                    "Simulador DES"
                                  ],
                                  "tips": "Pense na descriptografia como 'rebobinar' as rodadas invertendo as chaves.",
                                  "learningObjective": "Entender por que a inversão das subchaves permite descriptografia sem algoritmo separado.",
                                  "commonMistakes": [
                                    "Usar ordem progressiva K1-K16 na descriptografia",
                                    "Alterar a estrutura Feistel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e diferenciar criptografia direta e inversa",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para encriptação e descriptografia, linhas para IP, rodadas, subchaves, IP^{-1}.",
                                    "Explique por que a estrutura Feistel é auto-inversível com chaves reversas.",
                                    "Simule um ciclo completo: encripte um bloco e descriptografe para verificar identidade.",
                                    "Discuta vantagens: mesmo código para ambos, otimizado em hardware.",
                                    "Resuma: única diferença é a ordem das 16 subchaves."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença chave e demonstre com exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em branco",
                                    "Simulador DES para teste"
                                  ],
                                  "tips": "Use setas para mostrar fluxo reverso nas subchaves.",
                                  "learningObjective": "Diferenciar precisamente os processos e justificar a reversibilidade do DES.",
                                  "commonMistakes": [
                                    "Achar que descriptografia usa algoritmo diferente",
                                    "Ignorar que IP e IP^{-1} são iguais em ambos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um bloco plaintext simplificado de 64 bits representado como 'ABC123'. Na encriptação direta: use K1-K16 sequencialmente nas 16 rodadas para obter ciphertext 'XYZ789'. Na inversa: aplique K16-K1 nas mesmas rodadas para recuperar 'ABC123', provando reversibilidade sem algoritmo separado.",
                              "finalVerifications": [
                                "Descrever corretamente a ordem das subchaves na encriptação (K1-K16) e descriptografia (K16-K1).",
                                "Explicar o papel da estrutura Feistel na reversibilidade.",
                                "Desenhar fluxogramas precisos para ambos os processos.",
                                "Simular um ciclo encripta-desencripta com sucesso em um simulador.",
                                "Identificar que IP e IP^{-1} são idênticos em ambos.",
                                "Resumir a diferença única: ordem das subchaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de subchaves (100% correto).",
                                "Clareza na explicação da estrutura Feistel e swaps L/R.",
                                "Capacidade de simular e verificar reversibilidade.",
                                "Identificação correta de componentes comuns e diferenças.",
                                "Uso de diagramas ou tabelas para comparação.",
                                "Ausência de confusões comuns como algoritmos separados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções bijetivas e inversas em permutações (IP/IP^{-1}).",
                                "Segurança da Informação: Princípios de criptografia simétrica reversível.",
                                "Algoritmos: Estruturas de rede Feistel em design de block ciphers.",
                                "História da Computação: Evolução do DES para AES moderno."
                              ],
                              "realWorldApplication": "Essa distinção é essencial em implementações de software legado como banking systems ou VPNs que ainda suportam DES, garantindo descriptografia correta para evitar perda de dados; base para entender ciphers modernos como AES que usam modos semelhantes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "As 16 Rodadas de Substituição-Permutação",
                        "description": "Detalhamento das 16 rodadas idênticas no DES, cada uma composta pela função f que inclui expansão de 32 para 48 bits, XOR com subchave de 48 bits, passagem por 8 S-boxes de substituição e permutação P.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Descrever a geração das subchaves",
                            "description": "Explicar o processo de geração das 16 subchaves de 48 bits a partir da chave inicial de 64 bits: permutação PC-1, shifts circulares e compressão PC-2 para cada rodada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a chave inicial e aplicar a permutação PC-1",
                                  "subSteps": [
                                    "Identifique a chave inicial de 64 bits, ignorando os 8 bits de paridade para trabalhar com 56 bits efetivos.",
                                    "Consulte a tabela de permutação PC-1 (56 posições) e remova os bits de paridade conforme especificado.",
                                    "Divida o resultado em duas metades: C0 (28 bits à esquerda) e D0 (28 bits à direita).",
                                    "Anote os valores binários de C0 e D0 para referência.",
                                    "Verifique se a permutação foi aplicada corretamente comparando com um exemplo conhecido."
                                  ],
                                  "verification": "Confirme que C0 e D0 têm exatamente 28 bits cada e correspondem à aplicação correta da tabela PC-1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela PC-1 impressa ou digital, chave de exemplo em binário/hexadecimal, papel e caneta para cálculos.",
                                  "tips": "Comece convertendo a chave hex para binário para facilitar a visualização dos bits.",
                                  "learningObjective": "Entender como a chave de 64 bits é transformada em duas metades de 28 bits via PC-1.",
                                  "commonMistakes": "Esquecer de descartar os bits de paridade ou aplicar shifts prematuramente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar shifts circulares nas metades C e D",
                                  "subSteps": [
                                    "Consulte a tabela de número de shifts por rodada (1 ou 2 shifts para rodadas 1,2,9,16; 2 shifts para as demais).",
                                    "Para cada rodada i (1 a 16), aplique shifts circulares esquerdos independentes em C e D.",
                                    "Exemplo: Para rodada 1, 1 shift em C0 → C1 e 1 shift em D0 → D1.",
                                    "Registre C_i e D_i após cada shift.",
                                    "Repita para múltiplas rodadas para visualizar o padrão."
                                  ],
                                  "verification": "Verifique se os bits foram rotacionados corretamente comparando o primeiro e último bit antes/depois do shift.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela de shifts por rodada, sequências binárias de C e D de rodadas anteriores.",
                                  "tips": "Use uma fita métrica imaginária para visualizar a rotação circular dos bits.",
                                  "learningObjective": "Dominar os shifts circulares como mecanismo para variar as subchaves por rodada.",
                                  "commonMistakes": "Confundir shifts esquerdos com direitos ou aplicar o número errado de shifts por rodada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a compressão PC-2 para gerar a subchave de 48 bits",
                                  "subSteps": [
                                    "Combine C_i (28 bits) e D_i (28 bits) em uma sequência de 56 bits.",
                                    "Aplique a tabela PC-2 (48 posições) para selecionar e comprimir bits específicos, descartando 8 bits.",
                                    "O resultado é a subchave K_i de 48 bits para a rodada i.",
                                    "Converta para hexadecimal para facilitar armazenamento.",
                                    "Teste com rodada 1 para validar."
                                  ],
                                  "verification": "Confirme que exatamente 48 bits foram selecionados e que nenhum bit de paridade foi incluído.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela PC-2, valores de C_i e D_i combinados.",
                                  "tips": "Numere as posições da tabela PC-2 para rastrear quais bits de C/D são escolhidos.",
                                  "learningObjective": "Compreender como a compressão garante subchaves de 48 bits adequadas ao algoritmo.",
                                  "commonMistakes": "Selecionar bits na ordem errada ou incluir bits descartados pela PC-2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar o processo para gerar todas as 16 subchaves",
                                  "subSteps": [
                                    "Inicie com C0 e D0 e repita shifts + PC-2 para i=1 até 16.",
                                    "Mantenha uma tabela com todas K1 a K16.",
                                    "Note que após rodada 16, não há inversão das metades (diferente da descriptografia).",
                                    "Valide com uma chave de teste conhecida cujas subchaves estão disponíveis online.",
                                    "Discuta a importância da variação em cada rodada para segurança."
                                  ],
                                  "verification": "Gere todas 16 subchaves e compare pelo menos as primeiras com valores padrão de uma chave teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou software para automação opcional, chaves de teste padrão (ex: 133457799BBCDFF1).",
                                  "tips": "Automatize com Python se possível, mas faça manualmente primeiro para compreensão.",
                                  "learningObjective": "Executar o ciclo completo de geração de subchaves para as 16 rodadas do DES.",
                                  "commonMistakes": "Perder o rastreamento das rodadas ou inverter o número de shifts."
                                }
                              ],
                              "practicalExample": "Chave inicial hex: 133457799BBCDFF1. Após PC-1: C0=000110 110000 001011 101111 111111 000111 000001 110010, D0=110110 001011 101111 111111 000111 000001 110010 000000. Rodada 1: 1 shift → C1=001101 100000 010111 011111 111110 000111 000011 10010, D1=101100 010111 011111 111110 000111 000001 110000 00000. PC-2 → K1=000110 010000 001011 101111 111111 000111 000001 110010 100011 010101 011111 010000 010010 000111.",
                              "finalVerifications": [
                                "Pode reproduzir C0 e D0 corretamente a partir de uma chave dada?",
                                "Lista o número de shifts para rodadas 1, 9 e 16?",
                                "Gera K1 corretamente para uma chave teste?",
                                "Explica por que PC-2 reduz de 56 para 48 bits?",
                                "Descreve o ciclo completo para todas 16 subchaves?",
                                "Identifica diferenças na geração para criptografia vs. descriptografia?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação das tabelas PC-1 e PC-2 (sem erros de bits).",
                                "Correta execução de shifts circulares com contagem exata por rodada.",
                                "Geração completa e válida de pelo menos 3 subchaves iniciais.",
                                "Explicação clara do propósito de cada etapa no contexto do DES.",
                                "Uso de exemplos numéricos para ilustrar o processo.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Permutações, operações bit a bit e aritmética modular.",
                                "Algoritmos e Programação: Loops iterativos e manipulação de arrays binários.",
                                "Segurança da Informação: Fundamentos de chaves derivadas em criptografia.",
                                "Lógica Computacional: Tabelas de lookup e compressão de dados."
                              ],
                              "realWorldApplication": "Implementação em software criptográfico legado (ex: bibliotecas OpenSSL para DES), análise de vulnerabilidades em sistemas antigos e compreensão de algoritmos simétricos em protocolos como SSL/TLS iniciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Explicar a função de expansão E",
                            "description": "Detalhar a expansão de 32 bits da metade direita para 48 bits usando a tabela E, que duplica bits adjacentes para preparar o XOR com a subchave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Contexto e Propósito da Função de Expansão E",
                                  "subSteps": [
                                    "Revise a estrutura de uma rodada do DES, identificando a função f(R_i, K_i) onde R_i é 32 bits e K_i é 48 bits.",
                                    "Explique a necessidade de expansão: alinhar tamanhos para o XOR efetivo.",
                                    "Descreva como E introduz difusão duplicando bits adjacentes nos limites dos grupos.",
                                    "Discuta o impacto na avalanche effect do DES.",
                                    "Compare com permutações puras, destacando a duplicação intencional."
                                  ],
                                  "verification": "Descreva verbalmente o papel de E na função f e justifique sua necessidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama da rodada DES",
                                    "Descrição textual do algoritmo DES",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Visualize E como uma 'ponte' entre 32 bits de R e 48 bits de K, ampliando influência de bits chave.",
                                  "learningObjective": "Entender o propósito arquitetural da expansão E no DES.",
                                  "commonMistakes": "Confundir E com a permutação inicial IP ou final FP; ignorar o aspecto de difusão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar e Memorizar a Tabela de Expansão E",
                                  "subSteps": [
                                    "Liste a tabela E completa: 32,1,2,3,4,5 | 4,5,6,7,8,9 | 8,9,10,11,12,13 | 12,13,14,15,16,17 | 16,17,18,19,20,21 | 20,21,22,23,24,25 | 24,25,26,27,28,29 | 28,29,30,31,32,1.",
                                    "Identifique os 8 grupos de 6 bits cada e note as duplicações nos bits compartilhados (ex: bits 4,5 repetidos).",
                                    "Desenhe um diagrama circular dos bits 1-32 mostrando sobreposições.",
                                    "Pratique recitando a tabela em voz alta, focando nos inícios e fins de grupos.",
                                    "Anote o padrão: cada grupo sobrepõe 2 bits com o anterior."
                                  ],
                                  "verification": "Recite corretamente a tabela E para pelo menos 3 grupos consecutivos sem consultar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela E oficial do DES (impressa ou digital)",
                                    "Papel quadriculado para diagrama"
                                  ],
                                  "tips": "Agrupe mentalmente em 8 blocos de 6 para facilitar memorização; destaque duplicações em negrito.",
                                  "learningObjective": "Dominar a estrutura exata da tabela de expansão E.",
                                  "commonMistakes": "Errar a ordem dos grupos (começa com 32,1,... termina com 28-32,1); esquecer circularidade entre 32 e 1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Expansão E a um Exemplo Concreto",
                                  "subSteps": [
                                    "Selecione um R de 32 bits exemplo: 01111111 01000101 00101010 11001100 (bits 1-8:01111111, 9-16:01000101, etc.).",
                                    "Mapeie cada posição da tabela E para o bit correspondente em R, escrevendo grupo por grupo.",
                                    "Calcule os 48 bits resultantes, verificando duplicações (ex: bit4 e bit5 aparecem em dois grupos).",
                                    "Escreva o resultado em binário e hex para confirmação.",
                                    "Repita com um segundo R aleatório para prática."
                                  ],
                                  "verification": "Expanda corretamente um R dado de 32 para 48 bits, mostrando todos os mapeamentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora binária ou Python para verificação",
                                    "Papel e caneta",
                                    "Exemplos de R pré-definidos"
                                  ],
                                  "tips": "Numere os bits de R de 1 a 32 claramente; processe um grupo de 6 por vez.",
                                  "learningObjective": "Executar a expansão E manualmente com precisão.",
                                  "commonMistakes": "Indexação errada (bits de 0 ou 1-32 inconsistente); pular duplicações nos cálculos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Efeitos, Integração e Verificação Final",
                                  "subSteps": [
                                    "Compare R original vs E(R), contando duplicações (16 bits duplicados no total).",
                                    "Simule XOR de E(R) com uma subchave K de 48 bits exemplo.",
                                    "Explique como E contribui para difusão antes das S-boxes.",
                                    "Teste mudança em 1 bit de R e observe propagação em E(R).",
                                    "Conecte E com os passos subsequentes: XOR → S-boxes → P."
                                  ],
                                  "verification": "Demonstre o efeito avalanche alterando 1 bit em R e mostrando mudança em E(R).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de subchave 48 bits",
                                    "Ferramenta de simulação DES opcional"
                                  ],
                                  "tips": "Use mudança de bit única para visualizar difusão; pense em E como 'expansor de influência'.",
                                  "learningObjective": "Analisar o impacto de E na segurança e fluxo do DES.",
                                  "commonMistakes": "Subestimar duplicações (são essenciais para difusão); isolar E do contexto f(R,K)."
                                }
                              ],
                              "practicalExample": "Exemplo concreto: R = 01111111010001010010101011001100 (bits 1-32). Aplicando E: Grupo1 (32=0,1=0,2=1,3=1,4=1,5=1,6=1) → 0111111; Grupo2 (4=1,5=1,6=1,7=0,8=1,9=0) → 111010; e assim por diante até Grupo8 (28=1,29=1,30=0,31=0,32=0,1=0) → 110000. Resultado completo 48 bits: 0111111111010110010110110111001100110110 (verifique duplicações como bits 4-5=11 em múltiplos grupos).",
                              "finalVerifications": [
                                "Expansão correta de um R arbitrário de 32 para 48 bits usando tabela E.",
                                "Identificação precisa de todas as duplicações nos 8 grupos.",
                                "Explicação clara do propósito de difusão e alinhamento de tamanhos.",
                                "Recitação fluida da tabela E sem erros.",
                                "Demonstração do fluxo E → XOR em um exemplo.",
                                "Análise do efeito de uma mudança de bit em R sobre E(R)."
                              ],
                              "assessmentCriteria": [
                                "Precisão absoluta na aplicação da tabela E (zero erros de mapeamento).",
                                "Compreensão demonstrada do mecanismo de duplicação e difusão.",
                                "Capacidade de executar expansão manual em <5 minutos.",
                                "Explicação integrada com contexto DES (f(R,K), S-boxes).",
                                "Identificação correta de padrões na tabela (sobreposições circulares).",
                                "Evidência de efeito avalanche via exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de permutação e expansão vetorial em espaços binários.",
                                "Engenharia Elétrica: Manipulação de sinais digitais e padding de bits.",
                                "Matemática Discreta: Grafos circulares e sobreposições em sequências.",
                                "Segurança Cibernética: Princípios de confusão e difusão em criptoanálise.",
                                "Programação: Implementação de tabelas de lookup em código (ex: Python DES)."
                              ],
                              "realWorldApplication": "A expansão E no DES garante difusão de bits, essencial para resistir a ataques lineares; usada em protocolos legados como EMV para cartões de crédito e sistemas bancários até os anos 2000, influenciando designs modernos de block ciphers como AES em VPNs e HTTPS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Entender o papel das S-boxes e P-box",
                            "description": "Descrever as 8 caixas-S (S-boxes) que mapeiam 6 bits para 4 bits com não-linearidade, e a permutação P que rearranja os 32 bits de saída das S-boxes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura e propósito das S-boxes",
                                  "subSteps": [
                                    "Ler a definição oficial das S-boxes no algoritmo DES: 8 caixas de substituição que recebem 6 bits de entrada e produzem 4 bits de saída.",
                                    "Estudar o papel da não-linearidade: explicar como as S-boxes introduzem confusão no algoritmo, tornando-o resistente a ataques lineares.",
                                    "Visualizar um diagrama da função de rodada DES destacando as S-boxes.",
                                    "Identificar as entradas: 48 bits expandidos divididos em 8 grupos de 6 bits.",
                                    "Memorizar que cada S-box tem uma tabela de lookup fixa de 64 entradas (2^6) para 16 saídas possíveis (4 bits)."
                                  ],
                                  "verification": "Desenhar um diagrama simples mostrando uma S-box recebendo 6 bits e saindo 4 bits, e explicar verbalmente seu propósito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama da rodada DES (impresso ou online)",
                                    "Tabelas das 8 S-boxes do DES (disponíveis em Wikipedia ou NIST)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Comece memorizando apenas uma S-box (ex: S1) para praticar antes de todas.",
                                  "learningObjective": "Entender que as S-boxes fornecem não-linearidade essencial para a segurança do DES.",
                                  "commonMistakes": [
                                    "Confundir S-boxes com P-boxes (substituição vs. permutação)",
                                    "Achar que S-boxes são lineares ou reversíveis de forma simples"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o funcionamento detalhado de uma S-box",
                                  "subSteps": [
                                    "Escolher uma S-box específica (ex: S1) e copiar sua tabela de 4x16 entradas.",
                                    "Praticar lookup: pegue um exemplo de 6 bits (ex: 000000 = linha 0, coluna 0), encontre o valor de saída (ex: 14 = 1110).",
                                    "Explicar o processo de indexação: bits 1 e 6 definem linha (0-3), bits 2-5 definem coluna (0-15).",
                                    "Calcular 3 exemplos manuais de entrada-saída para a mesma S-box.",
                                    "Comparar saídas de diferentes S-boxes para um mesmo input de 6 bits."
                                  ],
                                  "verification": "Resolver corretamente 5 lookups em uma S-box sem consultar a tabela após o primeiro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela detalhada da S1 a S8 (planilha Excel ou PDF)",
                                    "Calculadora binária online",
                                    "Simulador DES interativo (ex: Cryptool ou dcode.fr)"
                                  ],
                                  "tips": "Use representação binária para inputs e converta para decimal apenas para lookup.",
                                  "learningObjective": "Dominar o mecanismo de substituição não-linear via tabelas lookup.",
                                  "commonMistakes": [
                                    "Erro na indexação de linha/coluna (bits externos vs. internos)",
                                    "Ignorar que saídas são ativas em 4 bits, não 6"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar a P-box e sua função de permutação",
                                  "subSteps": [
                                    "Ler a definição da P-box: tabela de permutação fixa que rearranja 32 bits de saída das 8 S-boxes.",
                                    "Visualizar o input: 32 bits concatenados das S-boxes (4 bits cada).",
                                    "Copiar a tabela P: 32 posições de entrada mapeadas para 32 de saída (ex: bit 16 vai para posição 1).",
                                    "Aplicar um exemplo: pegue 32 bits de amostra e aplique a permutação manualmente.",
                                    "Explicar o propósito: difusão, espalhando influência de bits para toda a saída."
                                  ],
                                  "verification": "Aplicar a P-box a um vetor de 32 bits exemplo e verificar contra uma ferramenta online.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela da P-box DES (32x32 permutação)",
                                    "Ferramenta online de permutação DES",
                                    "Papel quadriculado para rastrear bits"
                                  ],
                                  "tips": "Numere os bits de 1 a 32 e use setas para mostrar o remapeamento.",
                                  "learningObjective": "Compreender como a P-box promove difusão após a confusão das S-boxes.",
                                  "commonMistakes": [
                                    "Confundir ordem de aplicação (S-boxes primeiro, P depois)",
                                    "Achar que P-box é reversível sem tabela (é, mas requer cuidado)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar S-boxes e P-box no fluxo da rodada DES",
                                  "subSteps": [
                                    "Revisar o fluxo: expansão E (32->48), XOR com subchave, S-boxes (48->32), P-box (32->32).",
                                    "Simular uma rodada completa com dados de exemplo (plaintext conhecido).",
                                    "Explicar confusão-difusão: S-boxes confundem, P-box difunde.",
                                    "Discutir segurança: por que essa combinação resiste a criptoanálise diferencial.",
                                    "Comparar com rodadas seguintes: como a saída vai para próxima expansão."
                                  ],
                                  "verification": "Descrever o fluxo completo de bits desde expansão até saída da P-box em uma rodada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador completo DES (Cryptool, DES calculator online)",
                                    "Vídeo explicativo sobre rodada DES (YouTube: Computerphile ou similar)"
                                  ],
                                  "tips": "Use cores diferentes para rastrear bits através das caixas.",
                                  "learningObjective": "Integrar o papel das S-boxes e P-box na rede de substituição-permutação.",
                                  "commonMistakes": [
                                    "Esquecer XOR com subchave antes das S-boxes",
                                    "Subestimar impacto da não-linearidade na segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e verificar compreensão integrada",
                                  "subSteps": [
                                    "Resolver exercício: dado 48 bits pós-XOR, compute saídas S-boxes e aplique P.",
                                    "Implementar em pseudocódigo ou Python snippet para S1 + P parcial.",
                                    "Analisar ataque histórico: como S-boxes modificadas no DES quebrado (não faça isso).",
                                    "Discutir fraquezas modernas do DES apesar das S/P-boxes.",
                                    "Autoavaliar com quiz: 10 perguntas sobre funções e exemplos."
                                  ],
                                  "verification": "Implementar e testar código que processa uma rodada parcial corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de código (Python com bitwise ops)",
                                    "Quizzes online DES (ex: Crypto101)",
                                    "Documentação DES completa"
                                  ],
                                  "tips": "Comece com código simples, teste com valores conhecidos do DES.",
                                  "learningObjective": "Aplicar conhecimento em simulação prática.",
                                  "commonMistakes": [
                                    "Erros em bitwise shifts no código",
                                    "Ignorar endianness em representações binárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rodada DES, após XOR dos 48 bits R_i com subchave K_i, aplique S-boxes: ex, input 48 bits '011111...'. S1 recebe primeiros 6 bits '011111' (linha 1, col 15) -> saída '10' (2 em decimal). Após todas S-boxes, 32 bits são permutados pela P-box (ex, bit 1 da P vai para posição 16). Resultado: 32 bits prontos para próxima rodada.",
                              "finalVerifications": [
                                "Descrever precisamente como 6 bits viram 4 em uma S-box.",
                                "Aplicar lookup correto em pelo menos 3 S-boxes diferentes.",
                                "Executar permutação P em 32 bits sem erros.",
                                "Explicar confusão (S-boxes) vs. difusão (P-box).",
                                "Simular fluxo de uma rodada parcial com acerto total.",
                                "Identificar não-linearidade como chave de segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das tabelas S-boxes (90% correto).",
                                "Correção em cálculos manuais de lookup e permutação (sem erros).",
                                "Explicação clara de não-linearidade e difusão (conceitos integrados).",
                                "Uso correto de terminologia DES (S-box, P-box, rodada).",
                                "Criatividade em exemplos práticos ou diagramas.",
                                "Compreensão de contexto histórico/segurança do DES."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tabelas de funções, indexação matricial (4x16).",
                                "Matemática: Teoria de grafos para permutações (P-box como grafo de bits).",
                                "História: Contexto do DES (1977, concurso NBS, controvérsias S-boxes).",
                                "Programação: Implementação bitwise em linguagens low-level.",
                                "Física: Analogia com redes de substituição em óptica quântica criptográfica."
                              ],
                              "realWorldApplication": "Nas redes de substituição-permutação modernas como AES (SubBytes + ShiftRows semelhantes a S/P), usadas em HTTPS, banking apps e VPNs para proteger dados; entender DES ajuda a debugar implementações cripto e resistir a side-channel attacks."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.4",
                            "name": "Simular uma rodada completa do DES",
                            "description": "Passo a passo: divisão L/R, expansão E, XOR com subchave, S-boxes, P-box e XOR final com L anterior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Dividir o bloco de 64 bits em metades esquerda (L) e direita (R)",
                                  "subSteps": [
                                    "Obtenha o bloco de 64 bits após a Permutação Inicial (IP).",
                                    "Extraia os primeiros 32 bits como L (L_i).",
                                    "Extraia os últimos 32 bits como R (R_i).",
                                    "Verifique a contagem de bits em cada metade.",
                                    "Registre os valores em formato hexadecimal ou binário para rastreamento."
                                  ],
                                  "verification": "L + R reconstrói exatamente o input de 64 bits sem sobreposição ou perda.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Bloco de exemplo de 64 bits em hex/bin",
                                    "Tabela de Permutação Inicial (IP)"
                                  ],
                                  "tips": "Use ferramentas como calculadoras binárias online para manipulação rápida de bits.",
                                  "learningObjective": "Compreender a bipartição inicial do estado para processamento em rodadas DES.",
                                  "commonMistakes": [
                                    "Inverter L e R",
                                    "Esquecer a IP prévia",
                                    "Contar bits incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a expansão E no R para gerar 48 bits",
                                  "subSteps": [
                                    "Consulte a tabela de expansão E (32 para 48 bits).",
                                    "Duplique e reordene bits de R conforme a tabela E.",
                                    "Mapeie cada posição: ex. bit 1 de R vai para posições 1,4 na saída.",
                                    "Gere a string de 48 bits expandida.",
                                    "Confirme comprimento exato de 48 bits."
                                  ],
                                  "verification": "Saída tem 48 bits e inclui todas duplicações especificadas na tabela E.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de expansão E do DES",
                                    "R de 32 bits do passo anterior"
                                  ],
                                  "tips": "Anote a tabela E em papel para visualização; agrupe bits por posição.",
                                  "learningObjective": "Dominar a expansão não-linear para alinhar com tamanho da subchave.",
                                  "commonMistakes": [
                                    "Usar tabela errada (confundir com P)",
                                    "Perder duplicações de bits",
                                    "Erro de indexação 0 vs 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar XOR entre o resultado da expansão E e a subchave de 48 bits",
                                  "subSteps": [
                                    "Obtenha a subchave K_i de 48 bits para a rodada atual.",
                                    "Alinhe bit a bit: expandido (48 bits) XOR K_i (48 bits).",
                                    "Calcule XOR para cada posição (1 se diferente, 0 se igual).",
                                    "Gere o resultado de 48 bits.",
                                    "Valide com um XOR conhecido simples."
                                  ],
                                  "verification": "Resultado muda apenas onde bits diferem; teste com todos zeros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Subchave K_i da rodada",
                                    "Saída da expansão E",
                                    "Calculadora XOR bitwise"
                                  ],
                                  "tips": "Divida em grupos de 8 bits para facilitar cálculos manuais.",
                                  "learningObjective": "Aplicar operação XOR fundamental na função f do DES.",
                                  "commonMistakes": [
                                    "Usar OR/AND em vez de XOR",
                                    "Desalinhar subchave",
                                    "Erro em bits altos/baixos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar as 8 S-boxes no resultado de 48 bits",
                                  "subSteps": [
                                    "Divida os 48 bits em 8 grupos de 6 bits cada.",
                                    "Para cada grupo: extraia 2 bits linha (externos), 4 bits coluna (internos).",
                                    "Consulte a tabela S_j (j=1 a 8) para obter valor de 4 bits.",
                                    "Concatene os 8 valores de 4 bits em 32 bits.",
                                    "Verifique índices linha (1-4) e coluna (0-15)."
                                  ],
                                  "verification": "Saída tem exatamente 32 bits; cada S-box produz 4 bits válidos (0-15).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas das 8 S-boxes do DES",
                                    "48 bits pós-XOR"
                                  ],
                                  "tips": "Comece com S1; use matriz 4x16 impressa para rapidez.",
                                  "learningObjective": "Entender substituição não-linear para confusão no DES.",
                                  "commonMistakes": [
                                    "Índices linha/coluna trocados",
                                    "Usar S-box errada",
                                    "Concatenação fora de ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a permutação P nos 32 bits das S-boxes",
                                  "subSteps": [
                                    "Consulte a tabela de permutação P (32 para 32 bits).",
                                    "Reordene os 32 bits conforme posições na tabela P.",
                                    "Exemplo: bit 16 vai para posição 1, etc.",
                                    "Gere a string de 32 bits permutada.",
                                    "Confirme que é uma permutação (sem perda/ganho de bits)."
                                  ],
                                  "verification": "Todos 32 bits originais aparecem exatamente uma vez na nova ordem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de permutação P do DES",
                                    "Saída das S-boxes de 32 bits"
                                  ],
                                  "tips": "Marque posições com setas na tabela para rastrear.",
                                  "learningObjective": "Compreender difusão via permutação na função f.",
                                  "commonMistakes": [
                                    "Confundir com tabela E",
                                    "Pular posições",
                                    "Erro de transposição"
                                  ]
                                },
                                {
                                  "stepNumber": 6,
                                  "title": "XOR final com L original e preparar para próxima rodada",
                                  "subSteps": [
                                    "XOR os 32 bits de P com os 32 bits de L original.",
                                    "Resultado é novo R_{i+1}.",
                                    "Novo L_{i+1} = R_i original.",
                                    "Concatene novo L_{i+1} + novo R_{i+1} para input da próxima rodada.",
                                    "Valide comprimento total de 64 bits."
                                  ],
                                  "verification": "Novo bloco de 64 bits pronto; XOR reversível testado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "L original",
                                    "Saída P de 32 bits"
                                  ],
                                  "tips": "Lembre: rodada usa swap implícito via atribuições.",
                                  "learningObjective": "Finalizar a rodada de substituição-permutação completa.",
                                  "commonMistakes": [
                                    "XOR com R em vez de L",
                                    "Esquecer swap L/R",
                                    "Não concatenar corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Input após IP (hex): 0123456789ABCDEF FEDCBA9876543210. L=0123456789ABCDEF FEDCBA98, R=76543210. Expansão E em R gera 48 bits (ex: usando tabela E). XOR com K1=00011011000000101110111111111100010011010101100111001001110000. Pós-Sboxes/P: ex resultado f=001000110100001110101011001000101011111100110111000011111110011. XOR com L gera novo R; novo L=velho R. Simule manualmente para confirmar.",
                              "finalVerifications": [
                                "Simulação produz 64 bits corretos para próxima rodada.",
                                "Cada tabela (E, S, P) aplicada sem erros de indexação.",
                                "XORs validados com ferramenta bitwise.",
                                "Comprimentos de bits corretos em todos intermediários.",
                                "Combina com exemplo padrão DES conhecido.",
                                "Sem alterações em bits não processados."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de XOR e tabelas.",
                                "Substeps seguidos sequencialmente sem atalhos.",
                                "Correta interpretação de tabelas E/S/P.",
                                "Validações intermediárias documentadas.",
                                "Tempo dentro do estimado com qualidade.",
                                "Explicação clara do fluxo f(R,K)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra booleana, teoria de grupos (permutações).",
                                "Programação: Implementar DES em Python/C para automação.",
                                "Segurança da Informação: Análise de ataques como diferencial.",
                                "História da Computação: Evolução de Feistel networks.",
                                "Física: Analogia com circuitos lógicos digitais."
                              ],
                              "realWorldApplication": "Simular rodadas DES ajuda a auditar sistemas legados como ATMs bancários e protocolos IPsec antigos, identificando vulnerabilidades e migrando para AES, essencial para analistas de cibersegurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Limitações de Segurança do DES",
                        "description": "Análise das fraquezas do DES, principalmente devido ao tamanho efetivo da chave de 56 bits, vulnerável a ataques de força bruta, e menção a melhorias como 3DES.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Calcular a complexidade de força bruta no DES",
                            "description": "Demonstrar que com 56 bits de chave, há 2^56 possibilidades, factível com hardware moderno (ex: EFF quebrou em 1998 em 56 horas).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do DES e Ataque de Força Bruta",
                                  "subSteps": [
                                    "Revise a estrutura do DES: algoritmo de chave simétrica com chaves de 64 bits, mas efetivamente 56 bits de chave (8 bits de paridade).",
                                    "Defina ataque de força bruta: tentativa exaustiva de todas as chaves possíveis até encontrar a correta.",
                                    "Explique por que força bruta é viável para chaves curtas: depende do tamanho do espaço de chaves (2^n para n bits).",
                                    "Discuta pré-requisitos: conhecimento de criptografia simétrica e funções hash básica.",
                                    "Anote diferenças entre DES e sucessores como AES."
                                  ],
                                  "verification": "Resuma em 3 frases: o que é DES, tamanho da chave efetiva e conceito de força bruta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do DES (NIST FIPS 46-3)",
                                    "Vídeo introdutório sobre criptografia simétrica (Khan Academy ou YouTube)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use analogias como tentar todas as combinações de um cofre para visualizar força bruta.",
                                  "learningObjective": "Entender os conceitos básicos que levam à vulnerabilidade do DES por força bruta.",
                                  "commonMistakes": [
                                    "Confundir 64 bits totais com 56 bits efetivos",
                                    "Ignorar paridade na chave",
                                    "Achar que força bruta é só para senhas fracas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Tamanho Efetivo da Chave no DES",
                                  "subSteps": [
                                    "Confirme o comprimento da chave DES: 64 bits brutos, mas 56 bits de chave + 8 bits de paridade.",
                                    "Calcule o espaço de chaves: cada bit de chave dobra as possibilidades (2^56 chaves únicas).",
                                    "Compare com outros algoritmos: DES (56 bits) vs Triple DES (168 bits efetivos) vs AES (128+ bits).",
                                    "Pesquise fontes confiáveis para validar: RFCs ou papers acadêmicos.",
                                    "Crie uma tabela comparativa de tamanhos de chaves."
                                  ],
                                  "verification": "Liste corretamente: bits totais, bits efetivos e fórmula do espaço de chaves.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Especificação DES (Wikipedia ou Crypto101)",
                                    "Calculadora ou Python para potências de 2",
                                    "Planilha Excel/Google Sheets"
                                  ],
                                  "tips": "Lembre-se: paridade não adiciona entropia; é só verificação de erros.",
                                  "learningObjective": "Dominar o parâmetro crítico que define a força do DES: 56 bits.",
                                  "commonMistakes": [
                                    "Usar 64 bits no cálculo",
                                    "Confundir com modo de operação",
                                    "Subestimar impacto da paridade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Complexidade Numérica: 2^56",
                                  "subSteps": [
                                    "Calcule 2^56 passo a passo: 2^10=1024, 2^20≈1M, 2^30≈1B, 2^40≈1T, 2^50≈1P, 2^56≈72P.",
                                    "Expresse em notação científica: 2^56 = 7.205759403792794 × 10^16.",
                                    "Pratique cálculo manual e com ferramentas: Python (2**56) ou calculadora científica.",
                                    "Converta para unidades: quatrilhões de tentativas.",
                                    "Documente o resultado com fontes matemáticas."
                                  ],
                                  "verification": "Forneça o valor exato de 2^56 e sua aproximação decimal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica ou app (Wolfram Alpha)",
                                    "Interpretador Python/Jupyter Notebook",
                                    "Papel e lápis para cálculo manual"
                                  ],
                                  "tips": "Quebre em potências menores: 2^56 = 2^(50+6) = (2^10)^5 * 2^6 * 2^0.",
                                  "learningObjective": "Executar e interpretar o cálculo preciso do espaço de chaves DES.",
                                  "commonMistakes": [
                                    "Erro aritmético em potências (ex: confundir 2^10=1000)",
                                    "Notação errada (10^16 vs 10^17)",
                                    "Ignorar exatidão vs aproximação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Factibilidade com Hardware Moderno e Exemplo Histórico",
                                  "subSteps": [
                                    "Estime taxa de tentativas: DES quebra a ~10^9 chaves/segundo em hardware 1990s; moderno >10^12/seg.",
                                    "Calcule tempo: 2^56 / 10^12 ≈ 22 horas em GPU moderna.",
                                    "Estude caso EFF DES Cracker (1998): 56 horas em hardware dedicado (~$250k).",
                                    "Compare eras: o que levava dias agora leva minutos com ASICs/FPGAs.",
                                    "Discuta implicações: DES obsoleto para aplicações reais."
                                  ],
                                  "verification": "Explique por que 2^56 é 'factível' hoje e cite o tempo da EFF.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo EFF DES Cracker (eff.org)",
                                    "Benchmark de hardware cripto (OpenSSL speed tests)",
                                    "Vídeo sobre história DES"
                                  ],
                                  "tips": "Use simuladores online de brute force para visualizar escala.",
                                  "learningObjective": "Conectar cálculo teórico à realidade prática de ataques.",
                                  "commonMistakes": [
                                    "Superestimar dificuldade atual",
                                    "Ignorar avanços em hardware paralelo",
                                    "Confundir DES com 3DES"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado um ciphertext DES criptografado com chave desconhecida, calcule as 72 quatrilhões de tentativas necessárias (2^56) e estime tempo em uma GPU NVIDIA RTX 4090 (~10^13 chaves/segundo): menos de 2 horas, demonstrando quebra prática como a EFF em 1998 (56 horas).",
                              "finalVerifications": [
                                "Calcula corretamente 2^56 = 72.057.594.037.927.936",
                                "Identifica 56 bits como chave efetiva do DES",
                                "Explica ataque de força bruta como exaustivo",
                                "Cita EFF DES Cracker: 56 horas em 1998",
                                "Compara factibilidade: inviável em 1977, trivial hoje",
                                "Lista sucessores seguros (AES-128+)"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo de 2^56 (exato ou notação científica correta)",
                                "Compreensão conceitual: diferencia chave bruta vs efetiva",
                                "Aplicação histórica: referencia EFF corretamente",
                                "Análise crítica: explica por que DES é inseguro",
                                "Clareza na comunicação: usa unidades e comparações adequadas",
                                "Criatividade: inclui estimativas personalizadas de hardware"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Exponenciação binária e notação científica",
                                "História da Computação: Evolução de hardware (1977 vs 1998 vs hoje)",
                                "Física/Engenharia: Capacidade computacional e lei de Moore",
                                "Ética e Sociedade: Implicações de criptografia fraca em privacidade",
                                "Economia: Custo de ataques (EFF: $250k vs cloud moderno)"
                              ],
                              "realWorldApplication": "Essa compreensão explica a depreciação do DES em 2005 (NIST) e adoção de AES, impactando segurança em protocolos como TLS/SSL, banking (ex: cartões de crédito), VPNs e sistemas governamentais, evitando breaches por chaves fracas em aplicações legadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Identificar ataques diferenciais e lineares",
                            "description": "Explicar brevemente a criptoanálise diferencial explorando S-boxes e ataques lineares que reduzem a efetividade da chave para ~43 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Criptoanálise Diferencial",
                                  "subSteps": [
                                    "Leia a definição de criptoanálise diferencial: análise de pares de textos claros e cifrados com diferenças específicas.",
                                    "Estude o conceito de diferença XOR entre entradas e saídas em rodadas do DES.",
                                    "Aprenda sobre probabilidades de diferenças propagadas através das S-boxes.",
                                    "Revise o papel das S-boxes no DES como ponto fraco explorável.",
                                    "Analise diagramas de trilhas diferenciais (differential trails)."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave de pares diferenciais e probabilidades, e identifique uma trilha diferencial básica.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Especificação DES (FIPS 46-3)",
                                    "Artigo 'Differential Cryptanalysis of DES' de Biham e Shamir (PDF)",
                                    "Ferramenta online de visualização de S-boxes DES"
                                  ],
                                  "tips": "Comece com diferenças de entrada de alta probabilidade (ex: 0x4008 nas S-boxes). Use tabelas pré-computadas para probabilidades.",
                                  "learningObjective": "Compreender como diferenças são propagadas em cifras de bloco como o DES.",
                                  "commonMistakes": [
                                    "Confundir diferença XOR com soma modular.",
                                    "Ignorar a não-linearidade das S-boxes como foco principal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Ataques Diferenciais nas S-Boxes do DES",
                                  "subSteps": [
                                    "Liste as 8 S-boxes do DES e suas tabelas de lookup.",
                                    "Construa uma trilha diferencial de 15 rodadas para DES reduzido.",
                                    "Calcule probabilidades compostas de propagação através de múltiplas rodadas.",
                                    "Simule manualmente um par diferencial em uma única S-box.",
                                    "Discuta por que o DES requer ~2^47 pares para quebrar (complexidade)."
                                  ],
                                  "verification": "Crie uma tabela simples mostrando entrada/saída diferencial para S1 com probabilidade > 1/16.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Tabelas de S-boxes DES (impressas ou digital)",
                                    "Script Python básico para simular S-box (fornecido ou criar)",
                                    "Vídeo tutorial sobre trilhas diferenciais no DES"
                                  ],
                                  "tips": "Foquem em diferenças ativas (non-zero) nas S-boxes para maximizar bias probabilístico.",
                                  "learningObjective": "Identificar vulnerabilidades específicas das S-boxes do DES a ataques diferenciais.",
                                  "commonMistakes": [
                                    "Subestimar a expansão/permutação entre rodadas.",
                                    "Não considerar chaves parciais desconhecidas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender os Fundamentos da Criptoanálise Linear",
                                  "subSteps": [
                                    "Defina aproximações lineares: equações booleanas aproximando S-boxes com bias.",
                                    "Estude máscaras de entrada/saída para linearizar XORs em S-boxes.",
                                    "Aprenda sobre a soma de biases em rodadas iteradas (Piling-up lemma).",
                                    "Analise aproximações lineares de alta probabilidade nas S-boxes DES.",
                                    "Compare com diferencial: linear usa estatística em vez de pares específicos."
                                  ],
                                  "verification": "Escreva uma aproximação linear para S1 (ex: 14 paridade bits entrada = 4 saída com bias 20).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Artigo 'Linear Cryptanalysis' de Matsui (PDF)",
                                    "Ferramenta Crypto101 ou SageMath para biases",
                                    "Tabelas de biases lineares para DES S-boxes"
                                  ],
                                  "tips": "Use o piling-up lemma: bias total ≈ produto de biases individuais.",
                                  "learningObjective": "Dominar como equações lineares exploram biases não-lineares em S-boxes.",
                                  "commonMistakes": [
                                    "Confundir bias com probabilidade absoluta.",
                                    "Esquecer de combinar com análise de chaves parciais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Comparar Impactos dos Ataques no DES",
                                  "subSteps": [
                                    "Calcule a redução de segurança: diferencial ~2^47, linear ~2^43 chaves efetivas.",
                                    "Compare complexidades: linear Matsui ~2^43 conhecido plaintexts.",
                                    "Discuta contramedidas: redesign de S-boxes resistentes (AES).",
                                    "Simule identificação de vulnerabilidade em DES vs. cifra segura.",
                                    "Crie um fluxograma para detectar se uma cifra é suscetível a diferencial/linear."
                                  ],
                                  "verification": "Explique por que DES tem 56 bits mas efetividade ~43 bits sob linear, com números.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Implementação DES em Python/C (para testes)",
                                    "Paper Matsui DES linear attack",
                                    "Comparativo DES vs AES segurança"
                                  ],
                                  "tips": "Lembre: DES projetado pré-conhecimento desses ataques; S-boxes intencionalmente não-lineares mas fracas.",
                                  "learningObjective": "Identificar ataques diferenciais e lineares como limitações chave do DES.",
                                  "commonMistakes": [
                                    "Acreditar que DES é 'quebrado' para todos usos (ainda ok com chaves derivadas).",
                                    "Ignorar que ataques requerem poder computacional massivo hoje."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python, simule um ataque linear em DES reduzido (3 rodadas): gere 2^20 plaintexts conhecidos, colete biases em aproximações lineares de S-boxes, e recupere bits de subchave com testes estatísticos (chi-quadrado). Verifique recuperação correta de 6 bits de chave.",
                              "finalVerifications": [
                                "Explicar diferença entre propagação diferencial e aproximação linear.",
                                "Identificar S-box DES com maior bias linear (S5 ou S6).",
                                "Calcular complexidade aproximada de ataque linear Matsui no DES full.",
                                "Desenhar trilha diferencial básica de 1 rodada.",
                                "Discutir por que ~43 bits efetivos em vez de 56.",
                                "Comparar com AES: por que resistente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 30%)",
                                "Uso correto de termos técnicos (XOR diff, bias, piling-up: 20%)",
                                "Cálculos numéricos exatos (probs, complexidade: 20%)",
                                "Exemplos práticos viáveis (simulações: 15%)",
                                "Compreensão de impactos (redução segurança: 15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra booleana, probabilidades e estatística (chi-quadrado).",
                                "Programação: Implementação de cifras e testes criptográficos em Python/C.",
                                "História da Computação: Evolução DES para AES.",
                                "Estatística: Análise de biases e hipóteses nulas."
                              ],
                              "realWorldApplication": "Esses ataques levaram à depreciação do DES em 1999 (NIST), transição para 3DES/AES; usados hoje para auditar cifras em protocolos legados como SSL antigo ou sistemas bancários obsoletos, e no design de cripto resistente (competição NIST pós-quântica)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1",
                              "10.1.2.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Comparar DES com sucessores como AES",
                            "description": "Discutir por que o DES foi substituído pelo AES (chave de 128/192/256 bits) e o uso de 3DES como transição (Triple DES com três chaves).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Características e Limitações do DES",
                                  "subSteps": [
                                    "Identificar o tamanho da chave do DES (56 bits efetivos) e do bloco de dados (64 bits).",
                                    "Explicar o processo de criptografia Feistel do DES com 16 rodadas.",
                                    "Discutir vulnerabilidades conhecidas, como ataques de força bruta e diferencial.",
                                    "Analisar o impacto da chave curta em termos de segurança moderna (2^56 operações viáveis hoje).",
                                    "Listar eventos históricos, como o DES Challenge de 1997-1999 que quebrou DES."
                                  ],
                                  "verification": "Criar um diagrama comparativo das rodadas do DES e listar 3 limitações principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do DES (FIPS 46-3)",
                                    "Vídeos tutoriais sobre estrutura Feistel (Khan Academy ou YouTube)",
                                    "Ferramenta online para simular DES (ex: CrypTool)"
                                  ],
                                  "tips": "Use analogias como 'chave de 56 bits é como um cadeado de bicicleta em 2023' para entender fraqueza.",
                                  "learningObjective": "Compreender por que o DES, apesar de inovador nos anos 70, não atende padrões atuais de segurança.",
                                  "commonMistakes": [
                                    "Confundir bits da chave (64 divulgados, 56 efetivos)",
                                    "Ignorar que DES é simétrico e usa S-boxes para não-linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o 3DES como Solução de Transição",
                                  "subSteps": [
                                    "Descrever o 3DES: aplicação do DES três vezes (Encrypt-Decrypt-Encrypt) com chaves diferentes.",
                                    "Calcular a força efetiva da chave (168 bits nominais, ~112 bits efetivos contra ataques meet-in-the-middle).",
                                    "Comparar performance: 3DES é ~3x mais lento que DES single.",
                                    "Explicar uso como ponte: aprovado pelo NIST até 2023 para retrocompatibilidade.",
                                    "Discutir limitações: ainda vulnerável a ataques quânticos e lento para hardware moderno."
                                  ],
                                  "verification": "Implementar uma cifra simples 3DES em pseudocódigo e medir 'tempo' relativo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificação NIST SP 800-67 (3DES)",
                                    "Comparador de algoritmos online (ex: CyberChef)",
                                    "Pseudocódigo templates"
                                  ],
                                  "tips": "Lembre: 3DES não é 'novo', é DES reutilizado para ganhar tempo na transição.",
                                  "learningObjective": "Reconhecer o 3DES como medida temporária, não solução permanente.",
                                  "commonMistakes": [
                                    "Achar que 3DES tem 168 bits de segurança real (ignore meet-in-the-middle)",
                                    "Confundir modos EDE vs DDD"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o AES e suas Vantagens Técnicas",
                                  "subSteps": [
                                    "Apresentar AES (Rijndael): blocos de 128 bits, chaves 128/192/256 bits, 10/12/14 rodadas.",
                                    "Explicar estrutura SPN (Substitution-Permutation Network) vs Feistel do DES.",
                                    "Destacar eficiência: projetado para hardware/software rápido (AES-NI em CPUs).",
                                    "Discutir processo de seleção: concurso NIST 1997-2001 com 15 candidatos.",
                                    "Listar resistências: contra ataques lineares/diferenciais, side-channel mitigações."
                                  ],
                                  "verification": "Montar tabela de parâmetros AES (chave vs rodadas) e compará-la com DES.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "FIPS 197 (AES spec)",
                                    "AES animation tools (ex: AESAnimation on GitHub)",
                                    "Documentos do AES competition"
                                  ],
                                  "tips": "Foquem em 'AES é futuro-proof para clássicos', mas mencione ameaças quânticas (Grover).",
                                  "learningObjective": "Entender por que AES é o padrão ouro para criptografia simétrica moderna.",
                                  "commonMistakes": [
                                    "Confundir AES com RSA (simétrico vs assimétrico)",
                                    "Subestimar importância de modos de operação (CBC, GCM)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Comparação Direta e Analisar Substituição",
                                  "subSteps": [
                                    "Comparar métricas: chave (DES 56 vs AES 128+), bloco (64 vs 128), velocidade (AES >> DES).",
                                    "Analisar segurança: DES quebrado (EFF DES cracker), AES sem breaks práticos.",
                                    "Discutir adoção: NIST descontinuou DES/3DES, AES em TLS, IPsec, disk encryption.",
                                    "Avaliar custo-benefício: AES mais eficiente em energia/bateria.",
                                    "Concluir razões: brute force viável em DES, AES resiste até ~2030+."
                                  ],
                                  "verification": "Escrever parágrafo resumindo 'Por que AES substituiu DES?' com 3 razões chave.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela comparativa printable (NIST docs)",
                                    "Ferramentas de benchmark crypto (OpenSSL speed)"
                                  ],
                                  "tips": "Use gráficos de 'segurança por ano' para visualizar obsolescência do DES.",
                                  "learningObjective": "Sintetizar diferenças e justificar transição histórica.",
                                  "commonMistakes": [
                                    "Ignorar contexto legal (export controls nos 90s enfraqueceram DES)",
                                    "Achar 3DES superior a AES (não é)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cenário de proteção de dados em nuvem: use DES para encriptar um arquivo de 1GB (lento e inseguro), depois migre para AES-256-GCM (rápido e seguro), medindo tempo e testando 'crackability' simulada.",
                              "finalVerifications": [
                                "Explicar corretamente tamanhos de chave DES vs AES.",
                                "Listar 3 limitações do DES resolvidas pelo AES.",
                                "Descrever papel do 3DES na transição.",
                                "Comparar velocidades relativas em hardware moderno.",
                                "Identificar aplicações reais onde AES é mandatório (ex: HTTPS).",
                                "Citar data aproximada da quebra prática do DES (1998)."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual em comparações (90%+ correto).",
                                "Profundidade na explicação de vulnerabilidades (cita ataques específicos).",
                                "Clareza na justificativa de substituição (lógica e evidências).",
                                "Uso de exemplos quantitativos (bits, rodadas, benchmarks).",
                                "Capacidade de conectar a história (NIST, desafios)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grupos e Criptoanálise Linear/Diferencial.",
                                "História da Computação: Evolução de padrões NIST (DES 1977, AES 2001).",
                                "Segurança Cibernética: Impacto em protocolos como TLS/SSL.",
                                "Engenharia de Software: Implementação eficiente (AES-NI).",
                                "Ética: Responsabilidade em usar crypto obsoleta."
                              ],
                              "realWorldApplication": "Na proteção de comunicações seguras (HTTPS/TLS usa AES), VPNs (IPsec com AES), criptografia de disco (BitLocker/FileVault com AES), e conformidade regulatória (GDPR, PCI-DSS exigem AES-level security, banindo DES)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Advanced Encryption Standard (AES)",
                    "description": "Funcionamento do AES, com chaves de 128, 192 ou 256 bits, baseado em transformações em blocos de 128 bits usando S-boxes e MixColumns.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Arquitetura Geral do AES",
                        "description": "O Advanced Encryption Standard (AES) é um criptossistema de chave simétrica que opera em blocos de dados de 128 bits (4x4 bytes, representados como uma matriz estado) utilizando chaves de 128, 192 ou 256 bits, realizando 10, 12 ou 14 rodadas de transformações sucessivas, respectivamente, compostas por SubBytes, ShiftRows, MixColumns e AddRoundKey.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar os parâmetros fundamentais do AES",
                            "description": "Reconhecer que o AES processa blocos fixos de 128 bits independentemente do tamanho da chave (128, 192 ou 256 bits) e que o número de rodadas varia conforme o tamanho da chave: 10 para 128 bits, 12 para 192 bits e 14 para 256 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o tamanho fixo do bloco no AES",
                                  "subSteps": [
                                    "Leia a definição oficial do AES do FIPS 197, focando na seção sobre estrutura de blocos.",
                                    "Anote que o AES sempre processa dados em blocos de 128 bits, independentemente da chave.",
                                    "Compare com cifras de bloco anteriores como DES (64 bits) para destacar a padronização.",
                                    "Visualize um bloco de 128 bits como uma matriz 4x4 de bytes (16 bytes).",
                                    "Desenhe um diagrama simples representando um bloco de entrada de 128 bits."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o tamanho do bloco é sempre 128 bits e dê um exemplo de como dados maiores são divididos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento FIPS 197 (disponível online)",
                                    "Papel e caneta para diagramas",
                                    "Calculadora para conversões de bits para bytes"
                                  ],
                                  "tips": "Lembre-se: o bloco é fixo para simplicidade e eficiência em hardware/software.",
                                  "learningObjective": "Reconhecer que o AES usa blocos de 128 bits fixos para todas as chaves.",
                                  "commonMistakes": [
                                    "Confundir tamanho do bloco com tamanho da chave",
                                    "Achar que o bloco varia com a chave"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os tamanhos de chave suportados pelo AES",
                                  "subSteps": [
                                    "Liste os três tamanhos de chave: 128 bits (AES-128), 192 bits (AES-192) e 256 bits (AES-256).",
                                    "Calcule o número de bytes para cada: 16, 24 e 32 bytes respectivamente.",
                                    "Pesquise origens: AES-128 para equilíbrio, AES-192 para intermediário, AES-256 para máxima segurança.",
                                    "Crie uma tabela comparativa com colunas para bits e bytes.",
                                    "Teste conversão: converta 256 bits para bytes (256/8=32)."
                                  ],
                                  "verification": "Recite os três tamanhos de chave e seus equivalentes em bytes sem consultar notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela em branco",
                                    "Referência FIPS 197",
                                    "Calculadora"
                                  ],
                                  "tips": "Use mnemônicos: '128 básico, 192 médio, 256 máximo' para lembrar a ordem crescente.",
                                  "learningObjective": "Memorizar e explicar os tamanhos de chave AES: 128, 192, 256 bits.",
                                  "commonMistakes": [
                                    "Inverter 192 e 256 bits",
                                    "Esquecer que são opções independentes do bloco"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Associar o número de rodadas aos tamanhos de chave",
                                  "subSteps": [
                                    "Memorize a correspondência: 10 rodadas para 128 bits, 12 para 192 bits, 14 para 256 bits.",
                                    "Crie um fluxograma: tamanho da chave → número de rodadas.",
                                    "Estude por quê: mais bits de chave requerem mais rodadas para segurança equivalente.",
                                    "Repita em voz alta três vezes: '128-10, 192-12, 256-14'.",
                                    "Teste com quiz autoaplicado: cubra a tabela e responda."
                                  ],
                                  "verification": "Preencha uma tabela vazia com chaves e rodadas corretamente em menos de 1 minuto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Flashcards auto-criados",
                                    "Timer"
                                  ],
                                  "tips": "Associe números: 128≈10 (próximo), 192≈12 (divida por 16), 256≈14 (256/18≈14).",
                                  "learningObjective": "Associar precisamente: 10 rodadas (128 bits), 12 (192), 14 (256).",
                                  "commonMistakes": [
                                    "Confundir rodadas com tamanho da chave",
                                    "Achar que todas usam 10 rodadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e revisar todos os parâmetros fundamentais",
                                  "subSteps": [
                                    "Compile tudo em uma tabela única: coluna para parâmetro (bloco, chave, rodadas).",
                                    "Explique a independência: bloco fixo vs. chave variável.",
                                    "Simule uma consulta: 'Qual rodada para AES-256?' Responda rapidamente.",
                                    "Discuta impacto: mais rodadas = mais segurança, mas mais lento.",
                                    "Crie um resumo de 1 parágrafo com todos os parâmetros."
                                  ],
                                  "verification": "Ensine a um colega ou grave um vídeo de 2 minutos explicando os parâmetros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela compilada",
                                    "Gravador de voz ou parceiro de estudo"
                                  ],
                                  "tips": "Revise diariamente por 3 dias para fixação na memória de longo prazo.",
                                  "learningObjective": "Sintetizar bloco 128 bits, chaves 128/192/256, rodadas 10/12/14.",
                                  "commonMistakes": [
                                    "Ignorar variação de rodadas",
                                    "Não enfatizar independência do bloco"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao encriptar um arquivo de 1KB com AES-256, o arquivo é dividido em múltiplos blocos de 128 bits cada. A chave de 256 bits é expandida e usada por 14 rodadas de transformações em cada bloco, garantindo segurança mesmo para chaves maiores.",
                              "finalVerifications": [
                                "Recitar corretamente: bloco sempre 128 bits.",
                                "Listar tamanhos de chave: 128, 192, 256 bits.",
                                "Associar rodadas: 10/128, 12/192, 14/256.",
                                "Explicar independência do bloco em relação à chave.",
                                "Preencher tabela de parâmetros sem erros.",
                                "Responder quiz de 10 perguntas com 100% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% correto nos parâmetros.",
                                "Clareza na explicação da independência do bloco.",
                                "Velocidade de recall: menos de 30 segundos por parâmetro.",
                                "Uso de exemplos visuais ou tabelas na resposta.",
                                "Compreensão do 'por quê': segurança vs. performance.",
                                "Aplicação em cenários reais sem hesitação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversões bit/byte e aritmética modular.",
                                "História: Evolução de DES (56 bits) para AES (128+ bits).",
                                "Física/Engenharia: Implementação em hardware (chips com rodadas paralelas).",
                                "Segurança da Informação: Impacto em protocolos como TLS.",
                                "Programação: Uso em bibliotecas como OpenSSL."
                              ],
                              "realWorldApplication": "No HTTPS de sites bancários, AES-256 com 14 rodadas protege transações financeiras processando dados em blocos de 128 bits, garantindo confidencialidade contra interceptações em redes públicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Descrever a estrutura de rodadas do AES",
                            "description": "Explicar a sequência de operações em cada rodada: AddRoundKey inicial, seguida de rodadas completas (SubBytes, ShiftRows, MixColumns, AddRoundKey) e uma rodada final sem MixColumns, destacando a diferença entre rodadas iniciais, médias e finais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral das Rodadas do AES",
                                  "subSteps": [
                                    "Estude o número total de rodadas no AES-128: 10 rodadas numeradas de 0 a 10.",
                                    "Identifique a rodada inicial (rodada 0): apenas AddRoundKey.",
                                    "Descreva as rodadas principais (1 a 9): SubBytes, ShiftRows, MixColumns e AddRoundKey.",
                                    "Explique a rodada final (rodada 10): SubBytes, ShiftRows e AddRoundKey (sem MixColumns).",
                                    "Visualize o estado do AES como uma matriz 4x4 de bytes."
                                  ],
                                  "verification": "Desenhe um fluxograma simples mostrando a sequência de rodadas e operações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama oficial do AES (impresso ou digital)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": [
                                    "Lembre-se: AES-128 tem Nr=10; generalize para AES-192/256 com mais rodadas.",
                                    "Use cores diferentes para destacar operações em cada tipo de rodada."
                                  ],
                                  "learningObjective": "Identificar corretamente o número de rodadas e a sequência geral de operações no AES.",
                                  "commonMistakes": [
                                    "Confundir o número de rodadas (ex: achar 16 em vez de 10 para AES-128)",
                                    "Ignorar que a rodada inicial é só AddRoundKey"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Rodada Inicial (Pré-Rodada ou Rodada 0)",
                                  "subSteps": [
                                    "Entenda que o plaintext é representado como uma matriz de estado 4x4 (128 bits).",
                                    "Aprenda AddRoundKey: XOR bit a bit entre o estado e a chave de rodada 0 (round key 0).",
                                    "Gere ou visualize a round key 0 derivada da chave cipher original via expansão de chaves.",
                                    "Confirme que não há outras transformações nesta rodada.",
                                    "Verifique como isso prepara o estado para as rodadas principais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece com um byte exemplo no estado após AddRoundKey.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de plaintext e chave AES-128",
                                    "Calculadora ou ferramenta para XOR manual"
                                  ],
                                  "tips": [
                                    "XOR é reversível e não altera o tamanho dos dados.",
                                    "Anote a expansão de chaves brevemente para contextualizar a round key 0."
                                  ],
                                  "learningObjective": "Descrever precisamente a operação única da rodada inicial e seu propósito.",
                                  "commonMistakes": [
                                    "Esquecer que AddRoundKey usa round key 0 da expansão de chaves",
                                    "Confundir XOR com outras operações como OR ou AND"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever uma Rodada Completa (Rodadas 1 a 9)",
                                  "subSteps": [
                                    "SubBytes: Substitua cada byte do estado por S-box (não-linear).",
                                    "ShiftRows: Desloque linhas da matriz (0,1,2,3 posições à esquerda).",
                                    "MixColumns: Multiplique colunas por matriz fixa no campo GF(2^8).",
                                    "AddRoundKey: XOR com round key i (i=1 a 9).",
                                    "Repita esta sequência para cada rodada principal, atualizando a round key."
                                  ],
                                  "verification": "Liste as 4 operações em ordem e dê um exemplo simplificado para uma linha/coluna.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela S-box impressa",
                                    "Matriz MixColumns e polinômio GF(2^8)",
                                    "Ferramenta online simuladora AES (opcional)"
                                  ],
                                  "tips": [
                                    "SubBytes introduz confusão, MixColumns difusão.",
                                    "Pratique ShiftRows contando posições: linha 0 fixa, linha 1 shift 1, etc."
                                  ],
                                  "learningObjective": "Explicar o papel de cada transformação em uma rodada completa e sua sequência exata.",
                                  "commonMistakes": [
                                    "Ordem errada (ex: ShiftRows antes de SubBytes)",
                                    "Esquecer MixColumns nas rodadas principais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a Rodada Final e Diferenças entre Tipos de Rodadas",
                                  "subSteps": [
                                    "Identifique rodada 10: SubBytes, ShiftRows, AddRoundKey (sem MixColumns).",
                                    "Compare rodada inicial: só AddRoundKey (sem confusão/difusão).",
                                    "Diferencie rodadas principais: todas 4 ops para máxima difusão.",
                                    "Compare rodada final: evita MixColumns para facilitar inversão no decript.",
                                    "Resuma diferenças: inicial (prep), principais (transform), final (finalize)."
                                  ],
                                  "verification": "Crie uma tabela comparativa das operações em cada tipo de rodada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para tabela comparativa",
                                    "Resumo visual das rodadas AES"
                                  ],
                                  "tips": [
                                    "Motivo sem MixColumns na final: otimização, pois difusão já ocorreu.",
                                    "Use mnemônicos: 'SSMA' para principais, 'SSA' para final."
                                  ],
                                  "learningObjective": "Destacar precisamente as diferenças entre rodada inicial, principais e final.",
                                  "commonMistakes": [
                                    "Incluir MixColumns na rodada final",
                                    "Confundir rodada inicial com rodada 1"
                                  ]
                                }
                              ],
                              "practicalExample": "Para plaintext '000102030405060708090A0B0C0D0E0F' e chave '000102030405060708090A0B0C0D0E0F000101020304050607', a sequência é: Rodada 0 (AddRoundKey0) → Rodadas 1-9 (SubBytes→ShiftRows→MixColumns→AddRoundKey i) → Rodada 10 (SubBytes→ShiftRows→AddRoundKey10). Trace um byte através das ops iniciais.",
                              "finalVerifications": [
                                "Liste corretamente as operações da rodada 0.",
                                "Descreva a sequência exata de uma rodada principal (1-9).",
                                "Explique por que a rodada 10 omite MixColumns.",
                                "Desenhe a estrutura geral de 10 rodadas.",
                                "Compare diferenças entre os três tipos de rodadas.",
                                "Identifique o papel de AddRoundKey em todas as rodadas.",
                                "Confirme Nr=10 para AES-128."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de operações (100% correto).",
                                "Correta identificação de diferenças entre rodadas (inicial, principal, final).",
                                "Uso correto de terminologia (SubBytes, etc.).",
                                "Capacidade de visualizar/diagrama estrutura geral.",
                                "Explicação clara do propósito de cada tipo de rodada.",
                                "Integração com expansão de chaves mencionada.",
                                "Exemplo prático descrito sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em campos finitos GF(2^8) para MixColumns e S-box.",
                                "Programação: Implementação de loops para rodadas em linguagens como Python/C.",
                                "Álgebra Linear: Matriz MixColumns como transformação linear.",
                                "Segurança da Informação: Conceitos de confusão e difusão.",
                                "Engenharia de Software: Design modular de algoritmos criptográficos."
                              ],
                              "realWorldApplication": "A estrutura de rodadas do AES garante segurança em protocolos como HTTPS/TLS (navegação segura), VPNs (comunicação privada), criptografia de discos (BitLocker/FileVault) e assinaturas digitais, protegendo dados contra ataques em bilhões de dispositivos diários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Representar o estado do bloco no AES",
                            "description": "Ilustrar a representação do bloco de 128 bits como uma matriz 4x4 de bytes (estado) e explicar como as transformações atuam sobre essa matriz em coordenadas de bytes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o tamanho do bloco e a representação em bytes",
                                  "subSteps": [
                                    "Estude o conceito de bloco de 128 bits no AES, equivalente a 16 bytes.",
                                    "Aprenda que os dados são processados em blocos fixos de 128 bits para padronização.",
                                    "Identifique que cada byte é representado por 8 bits (um octeto).",
                                    "Revise exemplos de entrada de texto plano convertida em bytes hexadecimais.",
                                    "Anote a importância da representação binária para criptografia."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que 128 bits formam 16 bytes e dê um exemplo de conversão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora hexadecimal online",
                                    "Documentação AES oficial (FIPS 197)"
                                  ],
                                  "tips": "Use uma calculadora para converter strings em hex para visualizar bytes facilmente.",
                                  "learningObjective": "Entender a estrutura básica do bloco AES como 16 bytes.",
                                  "commonMistakes": "Confundir bits com bytes (lembre: 1 byte = 8 bits)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar o bloco como matriz 4x4 de bytes",
                                  "subSteps": [
                                    "Desenhe uma matriz vazia de 4 linhas por 4 colunas (estado ou 'state').",
                                    "Preencha a matriz coluna por coluna: bytes 0-3 na primeira coluna, 4-7 na segunda, etc.",
                                    "Use notação de bytes como a[i][j], onde i é linha (0-3) e j é coluna (0-3).",
                                    "Converta um bloco de exemplo (ex: 00 11 22 33 ... FF) na matriz.",
                                    "Verifique a ordem de preenchimento: little-endian em colunas."
                                  ],
                                  "verification": "Desenhe a matriz para um bloco dado e confirme que todos os 16 bytes estão posicionados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Editor de texto para hex",
                                    "Ferramenta de visualização AES online"
                                  ],
                                  "tips": "Sempre preencha coluna por coluna, de cima para baixo, para evitar transposições.",
                                  "learningObjective": "Visualizar o bloco linear como matriz bidimensional 4x4.",
                                  "commonMistakes": "Preencher linha por linha em vez de coluna por coluna."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender coordenadas de bytes e indexação",
                                  "subSteps": [
                                    "Defina coordenadas: byte em posição (i,j) acessado como estado[i][j].",
                                    "Estude convenções de indexação no AES (linhas de 0 a 3, colunas de 0 a 3).",
                                    "Pratique acessando bytes específicos: ex: primeiro byte é estado[0][0].",
                                    "Compare com representação linear: byte k = estado[k mod 4][k div 4].",
                                    "Anote diferenças entre coordenadas de bytes e palavras (colunas)."
                                  ],
                                  "verification": "Para um byte k=5, identifique corretamente sua posição (i=1, j=1) na matriz.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para matriz",
                                    "Pseudocódigo de indexação"
                                  ],
                                  "tips": "Use a fórmula floor(k/4) para coluna e k%4 para linha para conversões rápidas.",
                                  "learningObjective": "Dominar o sistema de coordenadas da matriz de estado.",
                                  "commonMistakes": "Inverter linhas e colunas na indexação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar ações das transformações na matriz",
                                  "subSteps": [
                                    "Revise SubBytes: substituição independente em cada byte estado[i][j].",
                                    "Estude ShiftRows: deslocamento circular por linha (0:0, 1:1, 2:2, 3:3 posições).",
                                    "Analise MixColumns: mistura por coluna, afetando 4 bytes verticais.",
                                    "Descreva AddRoundKey: XOR byte a byte com round key expandida.",
                                    "Simule uma rodada completa mostrando mudanças na matriz."
                                  ],
                                  "verification": "Descreva como ShiftRows altera posições específicas em uma matriz exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de transformações AES",
                                    "Simulador AES online",
                                    "Papel para desenhos passo a passo"
                                  ],
                                  "tips": "Visualize transformações como operações matriciais para melhor compreensão.",
                                  "learningObjective": "Compreender como cada transformação opera nas coordenadas da matriz.",
                                  "commonMistakes": "Confundir ShiftRows (horizontal) com MixColumns (vertical)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e sintetizar o conceito",
                                  "subSteps": [
                                    "Pegue um bloco de entrada e aplique manualmente as transformações iniciais.",
                                    "Desenhe a matriz antes/depois de cada passo.",
                                    "Compare com saída esperada de um simulador.",
                                    "Explique para um parceiro ou grave um vídeo curto.",
                                    "Resuma em um mapa mental: bloco → matriz → transformações."
                                  ],
                                  "verification": "Produza um diagrama completo de uma matriz evoluindo em uma rodada AES.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Simulador AES (ex: AES Animation tool)",
                                    "Mapa mental digital (MindMeister)"
                                  ],
                                  "tips": "Use cores diferentes para rastrear bytes em transformações.",
                                  "learningObjective": "Aplicar o conhecimento em um fluxo completo de representação.",
                                  "commonMistakes": "Ignorar a expansão da chave no AddRoundKey."
                                }
                              ],
                              "practicalExample": "Considere o bloco de entrada em hex: 00112233445566778899AABBCCDDEEFF. Represente como matriz: coluna 0: 00,44,88,CC; coluna 1: 11,55,99,DD; etc. Aplique ShiftRows: linha 1 desloca esquerda 1 (55→posição [1][0], etc.), ilustrando mudança nas coordenadas.",
                              "finalVerifications": [
                                "Desenhar corretamente a matriz 4x4 para qualquer bloco de 128 bits dado.",
                                "Identificar posição (i,j) de qualquer byte k na matriz.",
                                "Explicar impacto de SubBytes, ShiftRows e MixColumns nas coordenadas.",
                                "Simular AddRoundKey com uma subchave exemplo.",
                                "Converter matriz de volta para bloco linear sem erros.",
                                "Discutir diferenças entre estado em bytes vs. palavras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação matricial (30%)",
                                "Correta indexação de coordenadas (20%)",
                                "Descrição precisa das transformações (25%)",
                                "Uso correto de exemplos práticos (15%)",
                                "Clareza na explicação verbal/escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações matriciais e vetores (álgebra linear).",
                                "Programação: Arrays bidimensionais e manipulação de bytes em linguagens como C/Python.",
                                "Física: Analogia com grades cristalinas ou matrizes em óptica quântica.",
                                "Segurança da Informação: Aplicação em protocolos como HTTPS."
                              ],
                              "realWorldApplication": "Essa representação é fundamental no AES usado em Wi-Fi (WPA2/3), VPNs, discos criptografados (BitLocker) e comunicações seguras (TLS/SSL), permitindo processar dados sensíveis como senhas e transações financeiras de forma eficiente e segura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Transformação SubBytes com S-boxes",
                        "description": "A operação SubBytes aplica uma substituição não linear byte a byte usando tabelas S-box pré-computadas, baseadas em inversão no campo finito GF(2^8) seguida de uma transformação afim, para introduzir confusão no algoritmo AES.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Explicar o propósito e construção da S-box",
                            "description": "Descrever como a S-box do AES é gerada: inverso multiplicativo em GF(2^8) seguido de matriz afim para linearização, garantindo propriedades de não linearidade e resistência a ataques diferenciais e lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Propósito da S-box no AES",
                                  "subSteps": [
                                    "Estude o papel da camada SubBytes na rodada do AES: introduzir não linearidade.",
                                    "Analise como a S-box protege contra ataques diferenciais e lineares.",
                                    "Compare com substituições lineares e por que elas falham em criptografia.",
                                    "Revise o contexto geral do AES: chaves, rodadas e transformações.",
                                    "Identifique propriedades desejadas: bijetividade, baixa probabilidade diferencial/lineares."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que a S-box é essencial para a segurança do AES, citando pelo menos dois ataques prevenidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do AES (FIPS 197)",
                                    "Vídeo introdutório sobre AES no YouTube",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Pense na S-box como um 'black box' que quebra padrões lineares; visualize ataques como 'atalhos' que ela bloqueia.",
                                  "learningObjective": "Entender o papel fundamental da S-box em fornecer não linearidade e resistência a ataques criptoanalíticos.",
                                  "commonMistakes": "Confundir S-box com permutações (ShiftRows/MixColumns); assumir que é arbitrária em vez de matematicamente projetada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Campo de Galois GF(2^8)",
                                  "subSteps": [
                                    "Defina GF(2^8) como extensão de GF(2) com polinômio irreducível x^8 + x^4 + x^3 + x + 1.",
                                    "Represente bytes como polinômios de grau <8 com coeficientes em {0,1}.",
                                    "Aprenda operações: XOR para soma, multiplicação polinomial modular para produto.",
                                    "Pratique representações: converta byte 0x53 para polinômio.",
                                    "Verifique propriedades de corpo: todo não-zero tem inverso."
                                  ],
                                  "verification": "Converta 3 bytes aleatórios para polinômios em GF(2^8) e realize uma multiplicação simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de polinômios irreducíveis",
                                    "Ferramenta online como GF(256) calculator",
                                    "SageMath ou Python com galois library"
                                  ],
                                  "tips": "Use representação hexadecimal para bytes e multiplique como polinômios, reduzindo modulo o polinômio primitivo.",
                                  "learningObjective": "Representar e operar em GF(2^8), base para o inverso multiplicativo da S-box.",
                                  "commonMistakes": "Esquecer redução modular após multiplicação; confundir soma (XOR) com multiplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Inverso Multiplicativo em GF(2^8)",
                                  "subSteps": [
                                    "Para entrada byte a ≠ 0, encontre b tal que a * b = 1 em GF(2^8).",
                                    "Use Algoritmo Estendido de Euclides para campos finitos.",
                                    "Implemente ou simule: compute inverso para entradas como 0x01, 0x53.",
                                    "Trate 0x00: mapeie para si mesmo (inverso não existe).",
                                    "Verifique: multiplique entrada pelo inverso e confirme resultado 1."
                                  ],
                                  "verification": "Calcule inversos para 5 bytes de teste e verifique multiplicações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Implementação Python/SageMath para GF inverso",
                                    "Tabela pré-computada de inversos GF(2^8)",
                                    "Calculadora manual para pequenos exemplos"
                                  ],
                                  "tips": "Memorize que inverso de 1 é 1; use script para automatizar e entender o algoritmo.",
                                  "learningObjective": "Computar eficientemente o inverso multiplicativo, primeira camada da S-box.",
                                  "commonMistakes": "Aplicar inverso modular inteiro em vez de GF; ignorar mapeamento de 00."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Transformação Afim para Linearização",
                                  "subSteps": [
                                    "Defina a matriz afim: multiplicação por matriz 8x8 fixa + vetor constante em GF(2).",
                                    "Matriz M: [[1,0,0,0,1,1,1,1], ...] (consulte FIPS 197).",
                                    "Vetor c: [1,1,0,0,0,1,1,0].",
                                    "Para vetor byte b (8 bits), compute M * b + c (XORs e permutações).",
                                    "Aplique após inverso: S(a) = A * inv(a) + c."
                                  ],
                                  "verification": "Compute S-box para 2 entradas conhecidas (ex: 0x53 -> 0xED) usando matriz.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz afim do AES impressa",
                                    "Python script para multiplicação matricial GF(2)",
                                    "Tabela S-box oficial para validação"
                                  ],
                                  "tips": "Trate como álgebra linear sobre GF(2): multiplicação é AND + XOR de linhas.",
                                  "learningObjective": "Executar transformação afim, adicionando confusão e difusão.",
                                  "commonMistakes": "Usar multiplicação aritmética em vez de GF(2); ordem errada de operações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir S-box Completa e Verificar Propriedades",
                                  "subSteps": [
                                    "Combine: para cada 0-255, compute inv, aplique afim.",
                                    "Gere tabela S-box ou use pré-computada.",
                                    "Verifique bijetividade: todos valores únicos.",
                                    "Analise propriedades: avalanche effect, probabilidades diferenciais baixas.",
                                    "Compare com S-boxes Rijndael originais."
                                  ],
                                  "verification": "Gere S-box parcial (10 entradas) e confirme matches com tabela oficial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python completo para gerar S-box",
                                    "Tabela S-box AES oficial",
                                    "Ferramentas como CrypTool para análise"
                                  ],
                                  "tips": "Implemente em código para automação; foque em por que afim 'lineariza' o inverso não-linear.",
                                  "learningObjective": "Construir S-box do zero e justificar suas propriedades criptográficas.",
                                  "commonMistakes": "Gerar tabela errada por bug na matriz; subestimar impacto da afim na resistência linear."
                                }
                              ],
                              "practicalExample": "Para entrada 0x53 (01010011 em binário): 1. Inverso em GF(2^8) é 0x8A. 2. Aplique matriz afim + c resulta em 0xED. Isso é verificável na tabela S-box oficial do AES.",
                              "finalVerifications": [
                                "Construa S-box para 5 entradas e compare com tabela oficial.",
                                "Explique verbalmente o fluxo: entrada -> inv GF -> afim -> saída.",
                                "Identifique 3 propriedades criptográficas da S-box.",
                                "Simule um ataque diferencial simples e mostre por que falha.",
                                "Implemente código que gera a S-box completa.",
                                "Responda quiz: 'Por que afim após inv?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do processo de construção (inv + afim).",
                                "Compreensão correta de GF(2^8) e operações.",
                                "Habilidade em calcular exemplos manuais ou via código.",
                                "Explicação clara do propósito (não-linearidade, resistências).",
                                "Identificação de propriedades e justificativas.",
                                "Uso correto de terminologia criptográfica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra abstrata (corpos finitos), álgebra linear (GF(2)).",
                                "Programação: Implementação em Python/SageMath para simulações criptográficas.",
                                "Engenharia: Design de hardware para lookup tables em AES accelerators.",
                                "Física: Analogia com spinors em computação quântica resistente a ataques."
                              ],
                              "realWorldApplication": "A S-box é usada em todo AES, protegendo comunicações HTTPS, VPNs, criptografia de disco (BitLocker), blockchain e protocolos IoT, garantindo confidencialidade contra espionagem em transações financeiras e dados pessoais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Aplicar a operação SubBytes em um estado",
                            "description": "Executar a substituição byte a byte em uma matriz estado 4x4 usando a tabela S-box padrão do AES, substituindo cada byte por seu correspondente na S-box indexado por (linha, coluna) em hexadecimal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a tabela S-box padrão do AES",
                                  "subSteps": [
                                    "Obtenha a tabela S-box oficial do AES em formato hexadecimal 16x16.",
                                    "Represente a S-box como uma matriz bidimensional onde linhas são os 4 bits altos (0-F) e colunas os 4 bits baixos (0-F).",
                                    "Copie a tabela para um papel ou ferramenta digital, garantindo que todos os 256 valores estejam corretos.",
                                    "Verifique alguns valores conhecidos, como S[0][0] = 63 e S[8][0] = 30.",
                                    "Anote a convenção de indexação: byte dividido em nibble alto (linha) e baixo (coluna)."
                                  ],
                                  "verification": "Conferir pelo menos 5 valores aleatórios da S-box com uma fonte confiável (ex: especificação AES).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela S-box impressa ou PDF da especificação FIPS-197, papel quadriculado, calculadora hexadecimal.",
                                  "tips": "Sempre trabalhe em hexadecimal para evitar erros de conversão.",
                                  "learningObjective": "Compreender a estrutura e indexação da S-box para substituições precisas.",
                                  "commonMistakes": "Confundir nibble alto com baixo; usar decimal em vez de hex."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar o estado inicial como matriz 4x4",
                                  "subSteps": [
                                    "Receba o estado de entrada como 16 bytes em hexadecimal (ex: 00112233445566778899aabbccddeeff).",
                                    "Organize em matriz 4x4 coluna por coluna (primeiros 4 bytes na coluna 0, próximos na coluna 1, etc.).",
                                    "Escreva a matriz claramente rotulada com linhas 0-3 e colunas 0-3.",
                                    "Converta cada byte para binário de 8 bits se necessário para identificar nibbles.",
                                    "Confirme que o estado tem exatamente 16 bytes únicos."
                                  ],
                                  "verification": "A matriz 4x4 deve corresponder exatamente aos bytes de entrada, verificada por recitação manual.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado 4x4, bytes de entrada do estado, lápis.",
                                  "tips": "Use convenção coluna-major do AES para evitar transposições.",
                                  "learningObjective": "Dominar a representação matricial do estado AES.",
                                  "commonMistakes": "Organizar row-major em vez de column-major; erros de transcrição de hex."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar SubBytes a cada byte do estado",
                                  "subSteps": [
                                    "Para cada byte na posição (i,j): extraia nibble alto (linha) e baixo (coluna).",
                                    "Consulte a S-box: novo_byte = S[linha][coluna].",
                                    "Substitua o byte original pelo novo valor na matriz de saída.",
                                    "Processe byte por byte, linha por linha ou coluna por coluna, anotando cada substituição.",
                                    "Mantenha uma tabela paralela de entrada vs. saída para rastreamento."
                                  ],
                                  "verification": "Comparar 100% dos 16 bytes substituídos com cálculos manuais em uma amostra de 4 bytes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz de estado inicial, S-box preparada, matriz de saída em branco.",
                                  "tips": "Processe uma coluna inteira por vez para manter o foco.",
                                  "learningObjective": "Executar substituições precisas usando indexação da S-box.",
                                  "commonMistakes": "Trocar nibbles alto/baixo; ler S-box incorretamente; pular bytes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e formatar o estado final SubBytes",
                                  "subSteps": [
                                    "Revise todos os 16 bytes da matriz de saída contra recálculos em 20% dos bytes.",
                                    "Converta a matriz de saída de volta para sequência linear de 16 bytes coluna-major.",
                                    "Compare com um exemplo conhecido ou simulador online para validação.",
                                    "Documente o antes/depois em formato hex legível.",
                                    "Registre qualquer discrepância e corrija."
                                  ],
                                  "verification": "Estado final deve coincidir 100% com aplicação correta da S-box em todos bytes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Matriz de saída, simulador AES online (opcional), fonte de exemplo validado.",
                                  "tips": "Use um verificador online apenas após tentativa manual para aprendizado ativo.",
                                  "learningObjective": "Garantir integridade da transformação SubBytes completa.",
                                  "commonMistakes": "Erros de arredondamento hex; inversão de matriz ao linearizar."
                                }
                              ],
                              "practicalExample": "Estado inicial (column-major): 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff. Matriz 4x4: [[00,44,88,cc],[11,55,99,dd],[22,66,aa,ee],[33,77,bb,ff]]. Após SubBytes: [[63,fc,ba,98],[ca,70,3d,5e],[27,bf,b4,41],[11,98,5d,52]] (exemplo parcial; calcular completo com S-box: ex. 00->63, 11->ca, etc.).",
                              "finalVerifications": [
                                "Todos os 16 bytes foram substituídos corretamente pela S-box.",
                                "Indexação de nibbles (alto=linha, baixo=coluna) aplicada sem erros.",
                                "Matriz final mantém estrutura 4x4 column-major.",
                                "Nenhum byte original permanece inalterado.",
                                "Saída em hex válido (00-FF).",
                                "Verificação cruzada com pelo menos 4 bytes contra S-box manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos bytes corretos (peso 50%).",
                                "Eficiência: Tempo dentro do estimado e sem erros comuns (20%).",
                                "Documentação: Matriz antes/depois clara e rotulada (15%).",
                                "Verificação: Evidência de auto-checagem em subpassos (10%).",
                                "Compreensão: Explicação oral da indexação S-box (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indexação matricial e operações em bases 16 (hexadecimal).",
                                "Programação: Implementação em loops para arrays bidimensionais.",
                                "Segurança da Informação: Fundamento de não-linearidade em criptografia.",
                                "Lógica: Divisão de bytes em nibbles e lookup tables."
                              ],
                              "realWorldApplication": "SubBytes é essencial no AES para proteção de dados em HTTPS/SSL, Wi-Fi WPA2/3, discos criptografados (BitLocker), VPNs e comunicações seguras em bancos/apps, confundindo ataques de análise diferencial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Entender o papel da confusão no SubBytes",
                            "description": "Analisar como o SubBytes quebra a linearidade dos ataques, medindo sua contribuição para a confusão no contexto do princípio Shannon de confusão e difusão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Princípios de Confusão e Difusão de Shannon",
                                  "subSteps": [
                                    "Ler a definição de confusão: tornar a relação entre plaintext, key e ciphertext o mais complexa possível.",
                                    "Estudar difusão: espalhar a influência de um bit por muitos bits.",
                                    "Analisar exemplos históricos como DES e por que AES melhora isso.",
                                    "Identificar métricas de confusão: non-linearidade, resistência a ataques lineares.",
                                    "Anotar diferenças entre confusão (non-linearity) e difusão (avalanches)."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras explicando confusão vs. difusão, com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo de Shannon 'Communication Theory of Secrecy Systems', diagrama AES.",
                                  "tips": "Use analogias: confusão como 'embaralhar cartas' (non-linear), difusão como 'espalhar baralho'.",
                                  "learningObjective": "Compreender os conceitos fundamentais de confusão no contexto criptográfico.",
                                  "commonMistakes": "Confundir confusão com difusão; achar que são sinônimos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Funcionamento do SubBytes e S-box no AES",
                                  "subSteps": [
                                    "Descrever o processo: cada byte do estado é substituído via S-box (lookup table de 256 entradas).",
                                    "Explicar construção da S-box: inverso no GF(2^8) + matriz de afinidade para non-linearidade.",
                                    "Implementar ou visualizar uma S-box em código ou tabela.",
                                    "Calcular SubBytes para inputs simples (ex: 0x00 -> 0x63).",
                                    "Observar propriedades: bijetiva, non-linear."
                                  ],
                                  "verification": "Calcular SubBytes para 3 bytes diferentes e listar resultados na tabela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela S-box AES, calculadora GF(2^8) ou Python script para S-box.",
                                  "tips": "Comece com bytes hex simples; use ferramentas online para GF(2^8).",
                                  "learningObjective": "Dominar o mecanismo técnico do SubBytes.",
                                  "commonMistakes": "Ignorar o papel da matriz de afinidade; tratar S-box como simples substituição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Como SubBytes Quebra Linearidade e Introduz Confusão",
                                  "subSteps": [
                                    "Estudar ataques lineares: aproximações lineares S(a) ≈ b.",
                                    "Verificar non-linearidade da S-box: testar bias em XORs lineares.",
                                    "Comparar S-box com funções lineares (ex: identidade): mostrar diferença em outputs.",
                                    "Analisar gradiente de Walsh: alta non-linearidade indica boa confusão.",
                                    "Simular mudança de 1 bit no input e observar mudança no output."
                                  ],
                                  "verification": "Plotar ou tabular 4 pares input/output mostrando quebra de linearidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de análise linear (SageMath ou Python com sympy), paper AES.",
                                  "tips": "Foque em 1-bit diff: espere ~50% Hamming distance no output para confusão.",
                                  "learningObjective": "Identificar mecanismos matemáticos de confusão no SubBytes.",
                                  "commonMistakes": "Confundir non-linearidade com aleatoriedade total; subestimar S-box como 'apenas lookup'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Medir a Contribuição do SubBytes para Confusão no AES",
                                  "subSteps": [
                                    "Calcular critério de confusão: non-linearity score da S-box (máximo possível).",
                                    "Comparar com outras rodadas AES: SubBytes como principal fonte de confusão.",
                                    "Simular AES parcial sem SubBytes: mostrar vulnerabilidade linear.",
                                    "Quantificar: avalanche parcial no SubBytes (~4-5 bits mudam por 1 bit input).",
                                    "Concluir papel no ciclo completo: confusão por SubBytes, difusão por ShiftRows/MixColumns."
                                  ],
                                  "verification": "Relatório com métricas: non-linearity > 112, avalanche stats.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Script Python para avalanche/non-linearity, benchmarks AES.",
                                  "tips": "Use bibliotecas como Crypto: AES.new() para testes; compare com S-boxes fracas.",
                                  "learningObjective": "Quantificar e validar o impacto da confusão do SubBytes.",
                                  "commonMistakes": "Atribuir toda confusão ao AES; ignorar interações com outras transformações."
                                }
                              ],
                              "practicalExample": "Pegue o byte 0x53 (plaintext comum). Aplique SubBytes: S(0x53) = 0xed. Mude para 0x52 (1 bit flip): S(0x52) = 0xf2. Note Hamming distance 6/8 bits: ilustra quebra de linearidade e confusão forte.",
                              "finalVerifications": [
                                "Explicar em 2 minutos o papel da S-box na confusão sem consultar notas.",
                                "Calcular corretamente non-linearidade para um subconjunto da S-box.",
                                "Simular AES round sem SubBytes e identificar aproximação linear.",
                                "Comparar métricas de confusão SubBytes vs. ShiftRows.",
                                "Responder quiz: 'Por que SubBytes resiste a ataques lineares?'",
                                "Desenhar diagrama fluxo confusão no AES."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de confusão (90%+).",
                                "Profundidade análise: inclusão de métricas matemáticas (non-linearity, avalanche).",
                                "Exemplos concretos: pelo menos 3 cálculos SubBytes com diffs.",
                                "Conexão Shannon: ligação explícita com princípios originais.",
                                "Clareza explicação: diagrama ou tabela legível.",
                                "Originalidade: insight sobre contribuição única do SubBytes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra sobre GF(2^8), funções booleanas non-lineares.",
                                "Física: Teoria da informação, entropia e ruído.",
                                "História: Evolução de S-boxes desde DES para AES.",
                                "Engenharia: Design de hardware para lookup tables eficientes."
                              ],
                              "realWorldApplication": "No HTTPS/TLS, SubBytes no AES-128 protege comunicações bancárias contra cryptanalysis linear, impedindo hackers de decifrarem sessões Wi-Fi ou VPNs via aproximações lineares em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Transformação MixColumns",
                        "description": "A operação MixColumns atua linearmente sobre cada coluna da matriz estado (4 bytes), multiplicando-a por uma matriz fixa no campo GF(2^8), promovendo difusão horizontal para que a mudança em um bit afete múltiplos bits de saída.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Descrever o funcionamento matemático do MixColumns",
                            "description": "Explicar a multiplicação matricial fixa [[02,03,01,01],[01,02,03,01],[01,01,02,03],[03,01,01,02]] sobre cada coluna da matriz estado, usando aritmética polinomial em GF(2^8=283).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Campo de Galois GF(2^8) e Representação Polinomial",
                                  "subSteps": [
                                    "Estude o polinômio irredutível m(x) = x^8 + x^4 + x^3 + x + 1 (hex 11B).",
                                    "Represente um byte b7 b6 ... b0 como polinômio b7 x^7 + ... + b0.",
                                    "Aprenda adição XOR (soma coeficientes mod 2).",
                                    "Entenda redução modular: divida por m(x) e pegue resto.",
                                    "Pratique conversão byte <-> polinômio para bytes exemplo como 0x53."
                                  ],
                                  "verification": "Converta corretamente 3 bytes exemplo para polinômios e vice-versa, sem erros em coeficientes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela de polinômios GF(2^8)",
                                    "Calculadora binária ou papel para XOR"
                                  ],
                                  "tips": [
                                    "Lembre-se: multiplicação é convolução circular mod m(x). Use tabelas pré-computadas para prática."
                                  ],
                                  "learningObjective": "Representar bytes como polinômios em GF(2^8) e executar operações básicas.",
                                  "commonMistakes": [
                                    "Confundir XOR com OR lógico.",
                                    "Esquecer redução modular após multiplicação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Multiplicações por Constantes 0x02 e 0x03 (xtime)",
                                  "subSteps": [
                                    "Implemente multiplicação por 0x02: shift left 1, rotacione se bit 8=1 e XOR com 0x1B.",
                                    "Para 0x03: some resultado de *0x02 com o byte original (XOR).",
                                    "Pratique com bytes exemplo: compute 0x02 * 0x57 = 0xAE.",
                                    "Verifique usando tabelas de log/antilog ou expansão polinomial.",
                                    "Codifique uma função simples em pseudocódigo para xtime."
                                  ],
                                  "verification": "Calcule corretamente *0x02 e *0x03 para 5 bytes aleatórios, matching tabelas padrão AES.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Tabela xtime AES",
                                    "Editor de código ou planilha para testes"
                                  ],
                                  "tips": [
                                    "xtime é shift left + condicional XOR 0x1B. Teste edge cases como 0x00 e 0xFF."
                                  ],
                                  "learningObjective": "Executar multiplicações matriciais primitivas usadas na matriz MixColumns.",
                                  "commonMistakes": [
                                    "Não rotacionar corretamente bit 8 para *0x02.",
                                    "Usar aritmética inteira em vez de GF(2^8)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Matriz MixColumns e Operações Matriciais",
                                  "subSteps": [
                                    "Memorize a matriz: [[0x02,0x03,0x01,0x01], [0x01,0x02,0x03,0x01], [0x01,0x01,0x02,0x03], [0x03,0x01,0x01,0x02]].",
                                    "Entenda multiplicação matriz-coluna: nova_col[i] = XOR de (matriz[i][j] * coluna[j]) para j=0..3.",
                                    "Visualize matriz estado AES como 4x4 bytes, processada coluna por coluna.",
                                    "Pratique decomposição: cada saída é soma XOR de 4 produtos.",
                                    "Desenhe diagrama da matriz aplicada a uma coluna genérica."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como a matriz transforma uma coluna simbólica.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Diagrama matriz MixColumns",
                                    "Papel quadriculado para desenhos matriciais"
                                  ],
                                  "tips": [
                                    "Pense em colunas verticais da matriz estado. Cada MixColumns é independente por coluna."
                                  ],
                                  "learningObjective": "Explicar estrutura matricial e por que ela difunde bits.",
                                  "commonMistakes": [
                                    "Confundir linhas com colunas.",
                                    "Aplicar matriz a linhas em vez de colunas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar MixColumns a uma Coluna Completa e Verificar",
                                  "subSteps": [
                                    "Pegue coluna exemplo: [0xD4, 0xE0, 0xB8, 0x1E].",
                                    "Compute cada entrada: b0' = 02*D4 XOR 03*E0 XOR 01*B8 XOR 01*1E.",
                                    "Calcule passo a passo todos os 4 bytes da nova coluna.",
                                    "Compare com resultado conhecido: [0x04, 0xE0, 0x48, 0x28].",
                                    "Repita para segunda coluna para matriz completa."
                                  ],
                                  "verification": "Produza saída correta para coluna exemplo sem consultar tabelas.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Calculadora GF(2^8) ou código Python simples",
                                    "Exemplos AES padrão"
                                  ],
                                  "tips": [
                                    "Compute produtos intermediários primeiro, então XOR todos. Use hex para rastrear."
                                  ],
                                  "learningObjective": "Executar transformação MixColumns end-to-end em uma coluna.",
                                  "commonMistakes": [
                                    "Erros de cálculo em xtime individuais.",
                                    "XOR incorreto na soma final."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Descrição Matemática Completa do MixColumns",
                                  "subSteps": [
                                    "Escreva fórmula geral: state_col' = M * state_col em GF(2^8).",
                                    "Explique difusão: cada byte de saída depende de todos os 4 de entrada.",
                                    "Discuta inversa MixColumns para decriptação.",
                                    "Implemente em pseudocódigo ou código para matriz 4x4.",
                                    "Teste com matriz estado completa."
                                  ],
                                  "verification": "Forneça descrição escrita precisa e código funcional.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Especificação AES NIST FIPS-197",
                                    "Ambiente de programação"
                                  ],
                                  "tips": [
                                    "Enfatize independência por colunas para eficiência."
                                  ],
                                  "learningObjective": "Descrever funcionamento matemático de forma clara e precisa.",
                                  "commonMistakes": [
                                    "Omitir contexto GF(2^8).",
                                    "Ignorar inversa ou propriedades."
                                  ]
                                }
                              ],
                              "practicalExample": "Para coluna [0xD4, 0xE0, 0xB8, 0x1E]:\n- b0' = 0x02*0xD4=0xA4, 0x03*0xE0=0xB4, 0x01*0xB8=0xB8, 0x01*0x1E=0x1E → XOR=0x04\nResultado: [0x04, 0xE0, 0x48, 0x28]",
                              "finalVerifications": [
                                "Explica corretamente multiplicações por 0x02/0x03 com redução GF(2^8).",
                                "Aplica matriz a coluna exemplo produzindo saída exata.",
                                "Descreve fórmula matricial e processamento coluna-por-coluna.",
                                "Identifica difusão: 1 bit alterado afeta múltiplos bytes de saída.",
                                "Implementa pseudocódigo funcional sem erros.",
                                "Discute relação com SubBytes/ShiftRows para rodada AES completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão em operações GF(2^8): 100% correto em xtime.",
                                "Compreensão matricial: explica XOR de 4 termos por saída.",
                                "Exemplo prático: computa coluna completa matching padrão.",
                                "Descrição clara: cobre polinômio, matriz, aplicação.",
                                "Profundidade: menciona inversa e propriedades de difusão.",
                                "Aplicação: liga a contexto AES (encriptação segura)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação matriz-vetor sobre corpo finito.",
                                "Teoria de Códigos: aritmética em campos finitos para correção de erros.",
                                "Programação: implementação eficiente em C/Python para cripto.",
                                "Matemática Discreta: polinômios sobre GF(2).",
                                "Segurança da Informação: difusão em cifras block."
                              ],
                              "realWorldApplication": "MixColumns no AES garante difusão em protocolos como HTTPS/TLS, VPNs, Wi-Fi WPA2/3, assegurando que alterações mínimas no plaintext espalhem-se amplamente no ciphertext para resistência a ataques diferenciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Computar MixColumns em uma coluna específica",
                            "description": "Realizar o cálculo passo a passo de uma coluna de entrada (ex: [a0,a1,a2,a3]) resultando em nova coluna com operações xtime (multiplicação por 02 e 03) e XORs em GF(2^8).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a coluna de entrada e recordar as fórmulas de MixColumns",
                                  "subSteps": [
                                    "Represente a coluna de entrada como um array de 4 bytes em hexadecimal: [a0, a1, a2, a3].",
                                    "Escreva as quatro equações de saída do MixColumns:\n  b0 = (02 ⊕ a0) ⊕ (03 ⊕ a1) ⊕ a2 ⊕ a3\n  b1 = a0 ⊕ (02 ⊕ a1) ⊕ (03 ⊕ a2) ⊕ a3\n  b2 = a0 ⊕ a1 ⊕ (02 ⊕ a2) ⊕ (03 ⊕ a3)\n  b3 = (03 ⊕ a0) ⊕ a1 ⊕ a2 ⊕ (02 ⊕ a3)\n  Onde ⊕ é XOR e multiplicações estão em GF(2^8).",
                                    "Confirme o procedimento para xtime(x) = multiplicação por 02: rotacione à esquerda (<<1); se o bit 7 (0x80) estava set antes da rotação, XOR com 0x1B.",
                                    "Lembre que multiplicação por 03 é xtime(x) XOR x.",
                                    "Anote todos os bytes necessários para multiplicações: a0,a1,a2,a3 para 02 e 03."
                                  ],
                                  "verification": "Verifique se as equações estão corretas comparando com a matriz MixColumns padrão do AES e se xtime/mul03 estão definidos precisamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, tabela de referência AES (opcional), calculadora hexadecimal/binária.",
                                  "tips": "Sempre trabalhe em hexadecimal para facilitar XORs; converta para binário apenas se necessário para xtime.",
                                  "learningObjective": "Compreender a estrutura matricial do MixColumns e preparar dados para cálculos precisos em GF(2^8).",
                                  "commonMistakes": "Confundir os coeficientes da matriz (ex: colocar 03 onde é 02); esquecer que operações são em campo finito, não aritmética comum."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar multiplicações por 02 (xtime) e por 03 para cada byte da coluna",
                                  "subSteps": [
                                    "Para cada ai (i=0 a 3), calcule xtime(ai): converta para binário, rotacione <<1, verifique bit 7 original, aplique XOR 0x1B se necessário, reconverta para hex.",
                                    "Calcule mul03(ai) = xtime(ai) XOR ai para cada i.",
                                    "Anote os resultados em uma tabela: xtime(a0), mul03(a0), xtime(a1), etc., totalizando 8 valores.",
                                    "Verifique um xtime manualmente em binário para confirmação (ex: xtime(0x80) = 0x1B).",
                                    "Garanta que todos resultados estão em 8 bits (0x00 a 0xFF)."
                                  ],
                                  "verification": "Compare um ou dois xtime com valores conhecidos (ex: xtime(0x57)=0xAE) ou implementações online para validação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado para binário/hex, tabela xtime pré-computada (opcional para verificação).",
                                  "tips": "Faça xtime em binário passo a passo para visualizar rotação e redução polinomial; memorize que 0x1B é o polinômio irredutível.",
                                  "learningObjective": "Dominar multiplicações escalares em GF(2^8), fundamentais para difusão no AES.",
                                  "commonMistakes": "Esquecer XOR com 0x1B quando bit 7 é 1; rotacionar após verificar bit errado; não truncar a 8 bits."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar XORs para calcular cada byte de saída b0, b1, b2, b3",
                                  "subSteps": [
                                    "Para b0: XOR sequencial xtime(a0) ^ mul03(a1) ^ a2 ^ a3.",
                                    "Para b1: a0 ^ xtime(a1) ^ mul03(a2) ^ a3.",
                                    "Para b2: a0 ^ a1 ^ xtime(a2) ^ mul03(a3).",
                                    "Para b3: mul03(a0) ^ a1 ^ a2 ^ xtime(a3).",
                                    "Anote cada XOR intermediário para rastrear (ex: para b0, temp1 = xtime(a0)^mul03(a1), temp2=temp1^a2, etc.)."
                                  ],
                                  "verification": "Recalcule um bi XORando de novo; resultado deve ser byte único 0x00-0xFF.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mesmos do step anterior; tabela para anotar XORs.",
                                  "tips": "XOR é bit a bit: use tabelas hex para rapidez (ex: 0x11 ^ 0x22 = 0x33); agrupe pares para simplificar.",
                                  "learningObjective": "Aplicar XORs corretamente para combinar contribuições matriciais no MixColumns.",
                                  "commonMistakes": "Usar + em vez de XOR; confundir ordem dos termos nas equações; errar coeficientes (ex: usar 02 onde é 01)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar a coluna de saída",
                                  "subSteps": [
                                    "Forme a nova coluna [b0, b1, b2, b3] em hex.",
                                    "Valide com um exemplo conhecido ou ferramenta online AES MixColumns.",
                                    "Converta para binário um byte para confirmar ausência de carry-over além de 8 bits.",
                                    "Discuta como isso difunde bits (um bit mudado afeta múltiplos bytes de saída).",
                                    "Documente o processo completo para reutilização."
                                  ],
                                  "verification": "Aplique MixColumns inverso (se conhecido) ou compare com implementação em código simples.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Calculadora ou script Python simples para AES MixColumns.",
                                  "tips": "Teste com entrada zero: saída deve ser zero; entrada [1,0,0,0] difunde adequadamente.",
                                  "learningObjective": "Validar implementação do MixColumns e entender seu papel na difusão criptográfica.",
                                  "commonMistakes": "Ignorar wrap-around em 8 bits; não verificar contra referências."
                                }
                              ],
                              "practicalExample": "Entrada: [0x11, 0x22, 0x33, 0x44]\nxtime: 0x22, 0x44, 0x66, 0x88\nmul03: 0x33, 0x66, 0x55, 0xCC\nb0: 0x22 ^ 0x66 ^ 0x33 ^ 0x44 = 0x33\nb1: 0x11 ^ 0x44 ^ 0x55 ^ 0x44 = 0x44\nb2: 0x11 ^ 0x22 ^ 0x66 ^ 0xCC = 0x99\nb3: 0x33 ^ 0x22 ^ 0x33 ^ 0x88 = 0xAA\nSaída: [0x33, 0x44, 0x99, 0xAA]",
                              "finalVerifications": [
                                "Todos bytes de saída estão no intervalo 0x00-0xFF.",
                                "Recálculo de pelo menos dois bi confirma XORs corretos.",
                                "xtime para cada ai bate com método bit-shift + 0x1B.",
                                "Entrada zero produz saída zero.",
                                "Mudança em um bit de entrada afeta múltiplos bits de saída.",
                                "Compatível com ferramenta online AES (ex: CyberChef)."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nas multiplicações xtime e mul03.",
                                "XORs executados sem erros aritméticos.",
                                "Correta identificação e aplicação dos coeficientes matriciais.",
                                "Verificações finais incluem pelo menos duas validações independentes.",
                                "Explicação clara de GF(2^8) redução polinomial.",
                                "Tempo total dentro de 40 minutos com documentação completa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em corpos finitos (GF(2^8)) e álgebra linear (multiplicação matricial).",
                                "Programação: Implementação de xtime e MixColumns em linguagens como Python ou C para simulações criptográficas.",
                                "Segurança da Informação: Entendimento de difusão em cifras de bloco como AES.",
                                "Eletrônica Digital: Representação binária, shifts e XORs em hardware (ex: FPGA para AES)."
                              ],
                              "realWorldApplication": "O MixColumns é essencial no AES para garantir difusão: altera a dependência estatística entre bytes de entrada e saída, fortalecendo a criptografia usada em HTTPS/SSL, VPNs, discos criptografados (BitLocker) e protocolos como WPA2/WPA3, protegendo dados sensíveis contra ataques de análise diferencial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Analisar a difusão proporcionada pelo MixColumns",
                            "description": "Demonstrar que uma mudança em um bit de entrada afeta todos os 32 bits de saída da matriz estado após MixColumns, ilustrando o princípio de difusão de Shannon.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a operação MixColumns e o princípio de difusão",
                                  "subSteps": [
                                    "Estude a matriz de MixColumns fixa do AES: [[02,03,01,01],[01,02,03,01],[03,01,02,01],[01,03,01,02]] no campo GF(2^8).",
                                    "Revise multiplicação no GF(2^8) usando polinômio irredutível x^8 + x^4 + x^3 + x + 1.",
                                    "Explique o princípio de difusão de Shannon: uma mudança mínima na entrada deve afetar substancialmente a saída.",
                                    "Identifique que MixColumns opera coluna por coluna na matriz de estado 4x4.",
                                    "Anote como cada saída depende de todos os 4 bytes de entrada da coluna."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando MixColumns e difusão, confirmando compreensão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação AES (FIPS 197), papel e caneta para anotações, calculadora para GF(2^8).",
                                  "tips": "Visualize a matriz como transformação linear para entender espalhamento.",
                                  "learningObjective": "Entender os fundamentos matemáticos do MixColumns e seu papel na difusão.",
                                  "commonMistakes": "Confundir multiplicação GF(2^8) com aritmética modular comum; ignorar redução polinomial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar matrizes de estado original e modificada",
                                  "subSteps": [
                                    "Crie uma matriz de estado inicial simples, e.g., todos bytes 00 exceto um byte como 80 (binário 10000000) na posição (0,0).",
                                    "Represente a matriz em hexadecimal e binário para visualização clara.",
                                    "Altere exatamente um bit no byte escolhido, e.g., inverta o bit mais significativo para 00.",
                                    "Copie a matriz alterada e destaque a única mudança.",
                                    "Verifique que apenas um bit difere entre original e modificada."
                                  ],
                                  "verification": "Compare binários lado a lado; confirme exatamente 1 bit diferente em toda a matriz 128 bits.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou editor de texto para matrizes hex/bin, tabela de conversão bin-hex.",
                                  "tips": "Use um estado com mudança em bit alto (MSB) para efeito avalanche claro.",
                                  "learningObjective": "Preparar inputs controlados para isolar efeito de um bit na difusão.",
                                  "commonMistakes": "Alterar mais de um bit acidentalmente; esquecer representação binária completa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar MixColumns às duas matrizes",
                                  "subSteps": [
                                    "Para cada coluna da matriz original, multiplique pela matriz MixColumns usando GF(2^8).",
                                    "Calcule manualmente ou use ferramenta para GF multiplications (02*x = xtime(x), etc.).",
                                    "Repita para a matriz modificada.",
                                    "Registre saídas em hex e converta para binário completo (32 bits por coluna).",
                                    "Salve resultados em tabelas comparativas."
                                  ],
                                  "verification": "Confirme cálculos cruzando com implementações conhecidas ou calculadora GF(2^8).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Implementação Python simples para GF(2^8) ou calculadora online, papel quadriculado.",
                                  "tips": "Implemente função xtime para agilizar: xtime(b) = (b<<1) xor (0x1b if b&0x80 else 0).",
                                  "learningObjective": "Executar computações MixColumns para observar espalhamento prático.",
                                  "commonMistakes": "Erros em redução GF(2^8); calcular XOR como soma em vez de módulo 2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e quantificar a difusão",
                                  "subSteps": [
                                    "Compare binários das saídas original vs. modificada bit a bit.",
                                    "Conte bits alterados nas 4 colunas (deve afetar todos os 32 bits na coluna alterada e propagar).",
                                    "Calcule taxa de difusão: número de bits mudados / 128 * 100%.",
                                    "Repita com mudança em outro bit/coluna para generalizar.",
                                    "Conclua que uma mudança em um bit afeta todos os 32 bits de saída."
                                  ],
                                  "verification": "Gere relatório mostrando contagem de bits hamming distance ≈32 na coluna afetada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto para contagem de bits, ferramenta Hamming distance.",
                                  "tips": "Use diff tools ou scripts para contagem automática de bits diferentes.",
                                  "learningObjective": "Quantificar difusão e validar princípio de Shannon no MixColumns.",
                                  "commonMistakes": "Focar só na coluna alterada, ignorando propagação; arredondar incorretamente Hamming."
                                }
                              ],
                              "practicalExample": "Matriz original coluna 0: [80,00,00,00] (80=10000000b). Após MixColumns: [BE, D6, 9F, C2] (todos bits espalhados). Altere para [00,00,00,00]: [00,00,00,00]. Comparação binária mostra 25/32 bits diferentes na coluna 0, provando difusão total.",
                              "finalVerifications": [
                                "Uma mudança em qualquer bit de entrada altera todos os 32 bits da coluna de saída.",
                                "Cálculos GF(2^8) corretos validados por ferramenta independente.",
                                "Taxa de difusão >90% na coluna afetada.",
                                "Explicação escrita liga resultado ao princípio de Shannon.",
                                "Teste repetido em 2 posições diferentes confirma consistência.",
                                "Matrizes originais/alteradas e saídas documentadas completamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos MixColumns (sem erros GF).",
                                "Análise bit-a-bit completa e contagem Hamming exata.",
                                "Conexão clara com difusão de Shannon.",
                                "Generalização para qualquer bit de entrada.",
                                "Relatório estruturado com tabelas e conclusões.",
                                "Criatividade em exemplos adicionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear sobre campos finitos (GF(2^8)).",
                                "Programação: Implementar simulação AES em Python/C.",
                                "Física: Analogia com propagação de ondas (difusão).",
                                "Segurança da Informação: Avaliação de avalanche em cifras."
                              ],
                              "realWorldApplication": "Em AES usado em HTTPS/SSL, Wi-Fi WPA2/3, esta difusão garante que pequenas mudanças em chaves/plains espalhem amplamente, resistindo a ataques diferenciais e lineares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.4",
                        "name": "Expansão de Chaves e AddRoundKey",
                        "description": "A expansão de chaves gera subchaves para cada rodada a partir da chave mestra, e AddRoundKey XORa a matriz estado com a subchave rodada, garantindo dependência em todas as bits da chave.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.4.1",
                            "name": "Explicar o processo de expansão de chaves no AES",
                            "description": "Descrever os passos: rotação de palavras, SubWord com S-box, Rcon (XOR com constantes por rodada), e derivação de novas palavras a partir das anteriores para preencher o schedule de subchaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a Chave Inicial como Palavras de 32 Bits",
                                  "subSteps": [
                                    "Converta a chave inicial (ex: 128 bits) para bytes e agrupe em 4 palavras iniciais (w0, w1, w2, w3), cada uma com 4 bytes (32 bits).",
                                    "Represente cada palavra em hexadecimal para facilitar cálculos.",
                                    "Entenda que o schedule de chaves terá Nb * (Nr + 1) palavras, onde Nb=4 para AES-128, Nr=10.",
                                    "Anote as posições: w[i] para i=0 a 43 (para AES-128).",
                                    "Visualize o estado inicial das palavras em uma tabela ou array."
                                  ],
                                  "verification": "Confirme que w0 a w3 correspondem exatamente à chave inicial em hex.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Chave de exemplo em hex (ex: 2b7e151628aed2a6abf7158809cf4f3c)",
                                    "Calculadora hex/binária",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Use ferramentas online como CyberChef para conversões iniciais, mas faça manualmente para entender.",
                                  "learningObjective": "Compreender como a chave simétrica é dividida em palavras para expansão.",
                                  "commonMistakes": [
                                    "Confundir ordem de bytes (big-endian vs little-endian)",
                                    "Erros de transcrição de hex",
                                    "Ignorar o comprimento total do schedule"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Transformação de Expansão (RotWord, SubWord e Rcon)",
                                  "subSteps": [
                                    "Pegue w3 (última palavra do grupo de 4) e aplique RotWord: rotacione bytes à esquerda (byte0 vai para byte3).",
                                    "Aplique SubWord: substitua cada byte pela S-box correspondente (tabela de substituição não-linear).",
                                    "XOR o resultado com Rcon[i], onde i é o número da rodada (Rcon[1] para w4, etc.; Rcon tem apenas o primeiro byte não-zero).",
                                    "Essa transformação gera temp, usada para derivar a próxima palavra.",
                                    "Consulte tabelas padrão: S-box e Rcon (Rcon[i] = [rc[i], 0, 0, 0], rc[i] = 2^i mod (2^8-1) com redução)."
                                  ],
                                  "verification": "Calcule temp para w4 e compare com valor esperado (ex: para chave exemplo, temp = d4bf5d30).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela S-box impressa ou digital",
                                    "Tabela Rcon até rodada 10",
                                    "Chave exemplo"
                                  ],
                                  "tips": "Memorize que RotWord é ciclico simples; pratique com 1-2 exemplos antes.",
                                  "learningObjective": "Dominar as operações não-lineares que introduzem difusão na expansão.",
                                  "commonMistakes": [
                                    "Rotacionar na direção errada",
                                    "Usar S-box de inversa",
                                    "XOR Rcon em todos bytes em vez de só o primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Novas Palavras por XOR com Anteriores",
                                  "subSteps": [
                                    "w4 = temp XOR w0.",
                                    "w5 = w4 XOR w1.",
                                    "w6 = w5 XOR w2.",
                                    "w7 = w6 XOR w3.",
                                    "Note que isso propaga dependências lineares, garantindo que todas palavras dependam da chave inicial."
                                  ],
                                  "verification": "Verifique que w4 a w7 foram geradas corretamente e que w7 XOR w3 = w6, etc. (propriedade de XOR).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com w0-w3 calculadas",
                                    "Calculadora XOR hex"
                                  ],
                                  "tips": "XOR é bit a bit; use tabelas de XOR hex para agilizar (ex: 0x2b XOR 0xd4 = 0xdf).",
                                  "learningObjective": "Entender a propagação linear via XOR para preencher o schedule.",
                                  "commonMistakes": [
                                    "XOR na ordem errada (ex: w0 XOR temp em vez de temp XOR w0)",
                                    "Pular verificações de consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar o Processo para Completar o Schedule de Chaves",
                                  "subSteps": [
                                    "Repita a partir do Step 2 para w8: use w7 como base para próxima temp com Rcon[2].",
                                    "Continue até w44 (para AES-128: 4*(10+1)=44 palavras).",
                                    "Agrupe em matrizes de estado 4x4 para cada round key.",
                                    "Para AES-192/256, ajuste Nk (6/8 palavras iniciais) e aplique transformação a cada Nk palavras.",
                                    "Valide o schedule completo comparando com implementações conhecidas."
                                  ],
                                  "verification": "Gere o schedule completo para a chave exemplo e confirme primeiras rodadas (ex: round 1 key inicia com  a0fafe17... ).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Script Python simples para verificação (opcional)",
                                    "Tabelas S-box/Rcon completas"
                                  ],
                                  "tips": "Faça por blocos de 4 palavras para evitar erros; automatize só após manual.",
                                  "learningObjective": "Executar a expansão iterativa completa para qualquer AES-128.",
                                  "commonMistakes": [
                                    "Índice errado de Rcon (começa em 1)",
                                    "Não aplicar transformação só quando i mod 4 == 0"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando chave AES-128: 2b7e151628aed2a6abf7158809cf4f3c\nw0=2b7e1516, w1=28aed2a6, w2=abf71588, w3=09cf4f3c\nRotWord(w3)=cf4f3c09 -> SubWord=8d5526c3 -> XOR Rcon[1]=d4bf5d30 (=w4)\nw5=d4bf5d30 XOR 28aed2a6=fc173de5, etc. Gere até round 10.",
                              "finalVerifications": [
                                "Descreva verbalmente os 4 passos da expansão sem consultar notas.",
                                "Calcule manualmente w4-w7 para uma nova chave aleatória.",
                                "Explique por que Rcon usa potências de 2 no GF(2^8).",
                                "Gere schedule completo e identifique round key 1.",
                                "Compare sua expansão com uma implementação Python (ex: pycryptodome).",
                                "Identifique erros comuns em uma expansão errada fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de RotWord, SubWord e XOR (sem erros hex).",
                                "Completude: todos steps e iterações cobertos.",
                                "Clareza na explicação de dependências entre palavras.",
                                "Correta indexação de Rcon e condições de aplicação da transformação.",
                                "Demonstração de entendimento de propriedades criptográficas (difusão/confusão).",
                                "Uso correto de exemplos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra booleana, operações em GF(2^8), vetores em (Z/2Z)^128.",
                                "Programação: Implementar expansão em Python/C para automação e testes.",
                                "Física/Engenharia: Analogia com expansão de sinais em comunicações seguras.",
                                "História: Evolução de DES para AES (Rijndael) pelo NIST."
                              ],
                              "realWorldApplication": "A expansão de chaves no AES é crucial para protocolos como TLS/HTTPS (proteção de sites), WPA3 em Wi-Fi, VPNs (ex: OpenVPN), e criptografia de disco (BitLocker), garantindo chaves únicas por rodada para segurança contra ataques lineares/diferença."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.4.2",
                            "name": "Executar AddRoundKey em um estado",
                            "description": "Aplicar XOR byte a byte entre a matriz estado 4x4 e a subchave rodada correspondente (também 4x4 bytes), verificando que é sua própria inversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as Matrizes de Estado e Subchave Rodada",
                                  "subSteps": [
                                    "Represente o estado como uma matriz 4x4 de bytes em hexadecimal, preenchida coluna por coluna conforme convenção AES.",
                                    "Obtenha ou crie a subchave rodada expandida correspondente, também como matriz 4x4 de bytes.",
                                    "Anote as matrizes em formato de grade clara para visualização (linhas e colunas numeradas).",
                                    "Confirme que ambas as matrizes têm exatamente 16 bytes válidos (00-FF em hex)."
                                  ],
                                  "verification": "Matrizes de entrada estão corretamente formatadas como 4x4, com bytes em hex válidos e ordem column-major.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Papel quadriculado ou planilha",
                                    "Caneta",
                                    "Exemplos de matrizes AES em hexadecimal (de documentação oficial)"
                                  ],
                                  "tips": "Sempre use representação column-major (preenchimento por colunas) para evitar erros de alinhamento.",
                                  "learningObjective": "Compreender e preparar corretamente as representações matriciais usadas na operação AddRoundKey do AES.",
                                  "commonMistakes": [
                                    "Confundir ordem row-major com column-major.",
                                    "Usar valores decimais em vez de hexadecimais.",
                                    "Ignorar o tamanho exato de 16 bytes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a Operação XOR Byte a Byte",
                                  "subSteps": [
                                    "Para cada posição (i,j) de 0 a 3 na matriz: calcule novo_estado[i][j] = estado[i][j] XOR subchave[i][j].",
                                    "Realize o XOR bit a bit para cada byte, convertendo para binário se necessário (ex: 0x1A ^ 0x0F = 0x15).",
                                    "Preencha uma nova matriz 4x4 com os 16 resultados XOR.",
                                    "Converta todos os resultados para hexadecimal de dois dígitos.",
                                    "Revise visualmente os cálculos para os primeiros e últimos bytes."
                                  ],
                                  "verification": "Nova matriz de estado contém os 16 bytes resultantes do XOR correto, verificados manualmente em pelo menos 4 posições aleatórias.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora com suporte a XOR hexadecimal (ex: app Windows Calculator ou Python REPL)",
                                    "Tabela de XOR bitwise pré-calculada"
                                  ],
                                  "tips": "Lembre-se: XOR é comutativo e associativo; verifique bit por bit para bytes complexos (ex: 1^1=0, 0^1=1).",
                                  "learningObjective": "Aplicar precisamente a operação XOR em todas as posições da matriz 4x4.",
                                  "commonMistakes": [
                                    "Misalignamento entre matrizes de estado e subchave.",
                                    "Confundir XOR com OR (|) ou AND (&).",
                                    "Erros de carry-over em cálculos manuais (XOR não tem carry)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar que AddRoundKey é sua Própria Inversa",
                                  "subSteps": [
                                    "Aplique a operação AddRoundKey novamente no novo estado, usando a MESMA subchave rodada.",
                                    "Compare byte a byte o resultado com o estado original.",
                                    "Confirme que todos os 16 bytes coincidem exatamente.",
                                    "Registre qualquer discrepância e corrija o cálculo anterior se necessário.",
                                    "Documente a propriedade: AddRoundKey(state, key) = AddRoundKey(result, key) = state original."
                                  ],
                                  "verification": "Estado original é recuperado 100% após segunda aplicação, provando a inversa.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Mesmas matrizes do passo anterior",
                                    "Folha para comparação lado a lado"
                                  ],
                                  "tips": "Essa propriedade decorre do fato de XOR ser involutório: A ⊕ B ⊕ B = A.",
                                  "learningObjective": "Demonstrar e validar a propriedade inversa da operação AddRoundKey.",
                                  "commonMistakes": [
                                    "Usar subchave errada na segunda aplicação.",
                                    "Erros propagados do passo 2 não detectados.",
                                    "Ignorar diferenças sutis em bytes altos (ex: 0xFF vs 0xEF)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e Refletir sobre a Operação",
                                  "subSteps": [
                                    "Escreva as três matrizes (original, após 1ª XOR, após 2ª XOR) em um relatório claro.",
                                    "Explique em palavras o que aconteceu em pelo menos 2 bytes específicos.",
                                    "Identifique padrões observados (ex: bytes que mudam pouco).",
                                    "Pense em como implementar isso em código (pseudocódigo).",
                                    "Responda: Por que essa operação é crucial no AES?"
                                  ],
                                  "verification": "Relatório completo com matrizes, explicações e reflexões pessoais.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Editor de texto ou caderno",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Use diagramas para mostrar antes/depois visualmente.",
                                  "learningObjective": "Consolidar o aprendizado através de documentação e reflexão.",
                                  "commonMistakes": [
                                    "Documentação incompleta ou ilegível.",
                                    "Não conectar à teoria AES mais ampla."
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo concreto: Estado inicial (hex):\n[[0x19, 0x3d, 0x37, 0x25], [0x11, 0x06, 0x1e, 0x69], [0x18, 0x04, 0x0b, 0x1d], [0x01, 0x12, 0x03, 0x23]]\nSubchave rodada: [[0x0d, 0xb8, 0x1e, 0x27], [0xbf, 0xb4, 0x41, 0x11], [0xf1, 0x5a, 0xfa, 0x33], [0x03, 0x85, 0x87, 0xa2]]\nApós AddRoundKey: [[0x12, 0x65, 0x29, 0x12], [0xae, 0xb2, 0x3f, 0x7a], [0xc9, 0xbe, 0xb1, 0x2e], [0x02, 0x97, 0x84, 0x21]]\nAplicando novamente retorna exatamente ao estado original.",
                              "finalVerifications": [
                                "Todos os 16 bytes da nova matriz são XOR corretos (verificados manualmente).",
                                "Segunda aplicação de AddRoundKey recupera o estado original 100%.",
                                "Matrizes mantêm formato 4x4 column-major sem transposições.",
                                "Resultados expressos corretamente em hex de dois dígitos.",
                                "Nenhum byte inválido (fora de 00-FF)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos 16 XORs: 100% correto (20 pts).",
                                "Verificação da inversa demonstrada corretamente (20 pts).",
                                "Clareza na apresentação das matrizes e cálculos (15 pts).",
                                "Identificação e correção de erros comuns (15 pts).",
                                "Reflexão sobre aplicação no AES (15 pts).",
                                "Tempo total dentro de 45-60 min (10 pts).",
                                "Documentação completa e organizada (15 pts)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise e álgebra booleana (XOR como adição modular 2).",
                                "Programação: Loops aninhados para matrizes e funções bitwise em linguagens como Python/C.",
                                "Segurança da Informação: Integração em rodadas do AES para difusão/confusão.",
                                "Física/Engenharia: Analogia com circuitos lógicos digitais (portas XOR)."
                              ],
                              "realWorldApplication": "AddRoundKey é executada em cada rodada do AES, algoritmo padrão para cifragem simétrica em HTTPS/TLS, Wi-Fi (WPA3), VPNs (IPsec), criptografia de disco (BitLocker/FileVault) e assinaturas digitais, protegendo bilhões de transações diárias contra interceptação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.4.3",
                            "name": "Verificar dependência de chaves em rodadas",
                            "description": "Analisar como a expansão garante que cada subchave dependa de todos os bits da chave mestra, prevenindo ataques de chave relacionada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo de Expansão de Chaves no AES",
                                  "subSteps": [
                                    "Estude a estrutura da chave mestra (128, 192 ou 256 bits) dividida em palavras de 32 bits.",
                                    "Descreva o processo: para i >= Nk, temp = RotWord(SubWord(w[i-1])), w[i] = w[i-Nk] XOR temp XOR Rcon[i/Nk].",
                                    "Implemente ou trace manualmente a expansão para as primeiras 4 palavras de uma chave de exemplo.",
                                    "Identifique como cada nova palavra depende da anterior via XOR.",
                                    "Anote o papel da S-box (SubWord) na não-linearidade."
                                  ],
                                  "verification": "Liste corretamente as 11 palavras de chave expandidas para uma chave de 128 bits de exemplo sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação AES (FIPS 197), papel e caneta ou editor de código Python para simulação.",
                                  "tips": "Use hexadecimal para facilitar cálculos manuais.",
                                  "learningObjective": "Compreender os componentes básicos da expansão de chaves e sua dependência sequencial.",
                                  "commonMistakes": "Confundir Nk (4 para 128 bits) com Nr (10 rodadas); ignorar Rcon."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Dependência Bit a Bit de Subchaves",
                                  "subSteps": [
                                    "Escolha uma subchave de rodada específica (ex: rodada 5) e trace sua origem de volta à chave mestra.",
                                    "Modele o XOR como adição em GF(2), mostrando que cada bit da subchave é XOR de bits ancestrais.",
                                    "Simule mudança em um bit da chave mestra e observe propagação através de RotWord, SubWord e XORs.",
                                    "Conte o número de bits da chave mestra que afetam cada bit da subchave (deve ser todos após difusão).",
                                    "Crie um diagrama de árvore de dependência para 2-3 bits."
                                  ],
                                  "verification": "Demonstre que alterar um bit na chave mestra afeta todos os bits em subchaves posteriores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de simulação AES (ex: Python com pycryptodome ou script customizado), planilha para tracing.",
                                  "tips": "Comece com chaves simples como todas zeros exceto um bit para isolar efeitos.",
                                  "learningObjective": "Mapear dependências exatas, provando difusão completa.",
                                  "commonMistakes": "Subestimar difusão da S-box; assumir independência linear sem XORs cumulativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Difusão Através de Múltiplas Rodadas",
                                  "subSteps": [
                                    "Trace dependências para subchaves de rodadas iniciais (1-2) vs. finais (9-10).",
                                    "Calcule a avalanche effect: % de bits alterados na subchave ao flipar um bit na chave mestra.",
                                    "Compare subchaves de rodadas consecutivas, destacando mistura via Nk palavras anteriores.",
                                    "Simule expansão completa e verifique unicidade de cada RdKey.",
                                    "Discuta como isso garante 'strict avalanche criterion' aproximado."
                                  ],
                                  "verification": "Avalanche effect > 45% para todas subchaves após rodada 3.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Script Python para automação de tracing e avalanche tests, FIPS 197 para referência.",
                                  "tips": "Use loops em código para testar múltiplos flips de bits.",
                                  "learningObjective": "Quantificar e visualizar difusão progressiva nas rodadas.",
                                  "commonMistakes": "Ignorar que RotWord e SubWord espalham bits localmente, mas XORs globais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Proteção Contra Ataques de Chave Relacionada",
                                  "subSteps": [
                                    "Defina related-key attack: atacante sabe relações entre chaves e observa plaintext/ciphertext.",
                                    "Explique como dependência total impede distinção de pares relacionados sem quebra completa.",
                                    "Simule um related-key differential: ΔK em uma rodada e veja impacto em AddRoundKey.",
                                    "Compare com cifras fracas (ex: DES reduzido) onde subchaves são independentes.",
                                    "Conclua com teorema: cada RdKey depende de toda Km via cadeia de XORs não-lineares."
                                  ],
                                  "verification": "Explique em 1 parágrafo por que AES resiste a related-key attacks em expansões padrão.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Artigos sobre related-key attacks em AES (ex: Biryukov et al.), simulador.",
                                  "tips": "Foque em reduced-round AES para vulnerabilidades conhecidas vs. full AES.",
                                  "learningObjective": "Conectar análise teórica a segurança prática contra ataques específicos.",
                                  "commonMistakes": "Confundir com known-key attacks; superestimar resistências em variantes não-padrão."
                                }
                              ],
                              "practicalExample": "Para chave mestra 0x2b7e151628aed2a6abf7158809cf4f3c, expanda para 11 palavras. Trace bit 0 da Km: afeta w[4] via XOR direto, espalha via S-box em w[5], e difunde a todas bits em w[10] após 3 XORs cumulativos. Simule flip: 100% bits em RdKey10 alterados.",
                              "finalVerifications": [
                                "Expansão completa gera 176 bytes únicos para AES-128.",
                                "Cada bit de RdKey[i] depende de todos 128 bits de Km.",
                                "Avalanche effect atinge 50% em média após rodada 4.",
                                "Nenhum par de chaves relacionadas com ΔK pequeno produz ΔCiphertext previsível.",
                                "Diagrama de dependência cobre todas rodadas sem lacunas.",
                                "Simulação em código confirma tracing manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão no tracing de dependências (sem erros em exemplos).",
                                "Quantificação correta de difusão (avalanche >45%).",
                                "Explicação clara de prevenção de related-key attacks.",
                                "Uso apropriado de termos técnicos (RotWord, SubWord, Rcon).",
                                "Criatividade em diagramas/simulações personalizadas.",
                                "Conexão explícita entre passos e segurança geral AES."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra booleana e polinômios em GF(2^8) para S-box.",
                                "Segurança da Informação: Análise diferencial e linear em criptoanálise.",
                                "Programação: Implementação de AES key schedule em Python/C.",
                                "Física: Analogia com difusão em sistemas caóticos."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS, garante que pequenas mudanças na chave senha resultem em ciphertexts imprevisíveis, protegendo contra ataques side-channel e related-key em VPNs, discos criptografados (BitLocker) e blockchain wallets."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.4.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Modos de Operação em Criptografia Simétrica",
                    "description": "Modos como ECB, CBC, CFB e OFB para cifrar dados de tamanho variável, incluindo vantagens e vulnerabilidades de cada um.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Modo ECB (Electronic Codebook)",
                        "description": "O modo ECB divide a mensagem em blocos independentes de tamanho fixo e cifra cada bloco separadamente com a mesma chave, sem dependência entre blocos. Vantagens: simplicidade e possibilidade de processamento paralelo. Vulnerabilidades: revela padrões na plaintext, como imagens ou textos repetidos, pois blocos idênticos produzem ciphertext idêntico.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Descrever o funcionamento do modo ECB",
                            "description": "Explicar passo a passo como o ECB processa blocos de plaintext independentes, incluindo encriptação e decriptação, e ilustrar com um exemplo simples de 2 blocos idênticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Criptografia de Bloco",
                                  "subSteps": [
                                    "Aprender o que é um algoritmo de cifragem de bloco, como AES, que opera em blocos fixos de tamanho (ex: 128 bits).",
                                    "Compreender a divisão do plaintext em blocos independentes do tamanho do algoritmo de bloco.",
                                    "Explicar que no modo ECB, não há dependência entre blocos, diferentemente de outros modos.",
                                    "Discutir a necessidade de padding para plaintexts não múltiplos do tamanho do bloco.",
                                    "Revisar o papel da chave simétrica na encriptação e decriptação."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito os fundamentos da criptografia de bloco e a independência de blocos no ECB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial do AES (NIST FIPS 197)",
                                    "Vídeo introdutório sobre criptografia de bloco (Khan Academy ou YouTube)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Visualize o plaintext como uma sequência de caixas (blocos) processadas separadamente.",
                                  "learningObjective": "Dominar os pré-requisitos conceituais para compreender o processamento independente no ECB.",
                                  "commonMistakes": [
                                    "Confundir ECB com stream ciphers que processam byte a byte.",
                                    "Ignorar a importância do padding, levando a erros de tamanho."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Processo de Encriptação no Modo ECB",
                                  "subSteps": [
                                    "Dividir o plaintext P em blocos independentes P1, P2, ..., Pn do tamanho do bloco.",
                                    "Para cada bloco Pi, aplicar a função de encriptação: Ci = E(K, Pi), onde E é o algoritmo de bloco e K a chave.",
                                    "Concatenar todos os Ci para formar o ciphertext C = C1 || C2 || ... || Cn.",
                                    "Observar que blocos Pi idênticos geram Ci idênticos.",
                                    "Verificar se padding foi aplicado corretamente no último bloco."
                                  ],
                                  "verification": "Esboçar o diagrama de encriptação para um plaintext de 2 blocos e confirmar independência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de simulação ECB (ex: CyberChef)",
                                    "Pseudocódigo de ECB em Python",
                                    "Quadro branco ou software de desenho (Draw.io)"
                                  ],
                                  "tips": "Pense no ECB como um 'livro de códigos' onde cada bloco tem sua entrada única na tabela.",
                                  "learningObjective": "Explicar precisamente os passos de encriptação ECB e sua independência de blocos.",
                                  "commonMistakes": [
                                    "Achar que há feedback ou IV envolvido, confundindo com CBC.",
                                    "Esquecer que a ordem dos blocos é preservada no ciphertext."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Processo de Decriptação no Modo ECB",
                                  "subSteps": [
                                    "Dividir o ciphertext C em blocos C1, C2, ..., Cn.",
                                    "Para cada bloco Ci, aplicar a função de decriptação: Pi = D(K, Ci), onde D é o algoritmo de decriptação.",
                                    "Concatenar todos os Pi, removendo padding se aplicável, para recuperar o plaintext.",
                                    "Confirmar que blocos Ci idênticos geram Pi idênticos.",
                                    "Testar com um ciphertext conhecido para validar."
                                  ],
                                  "verification": "Executar decriptação manual de um ciphertext simulado e recuperar o plaintext original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesma ferramenta de simulação usada na encriptação",
                                    "Exemplos de ciphertext/hexadecimal para prática",
                                    "Calculadora para operações XOR simples em demos"
                                  ],
                                  "tips": "A decriptação é simétrica e paralelizável, pois blocos são independentes.",
                                  "learningObjective": "Compreender e replicar os passos de decriptação ECB.",
                                  "commonMistakes": [
                                    "Usar a chave errada ou inverter encriptação/decriptação.",
                                    "Não remover padding, resultando em plaintext inválido."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Exemplo Simples de 2 Blocos Idênticos",
                                  "subSteps": [
                                    "Escolher plaintext simples: 'AAAABBBB' (2 blocos de 4 chars: 'AAAA' e 'AAAA' idênticos, assumindo bloco pequeno).",
                                    "Simular encriptação: C1 = E(K, 'AAAA'), C2 = E(K, 'AAAA') → C1 == C2.",
                                    "Mostrar ciphertext: C1 || C2 (blocos idênticos revelam padrão).",
                                    "Executar decriptação: P1 = D(K, C1), P2 = D(K, C2) → 'AAAA' e 'AAAA'.",
                                    "Analisar implicação: Padrões no plaintext vazam para ciphertext."
                                  ],
                                  "verification": "Criar e demonstrar o exemplo completo, destacando blocos idênticos no plaintext e ciphertext.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto para plaintext",
                                    "Conversor hex/binário online",
                                    "Script Python simples: from cryptography import * (opcional)"
                                  ],
                                  "tips": "Use blocos pequenos para cálculo manual; foque na repetição para destacar fraqueza.",
                                  "learningObjective": "Aplicar ECB em exemplo concreto para ilustrar processamento independente.",
                                  "commonMistakes": [
                                    "Usar blocos não idênticos, perdendo o ponto da ilustração.",
                                    "Ignorar que isso revela padrões, subestimando insegurança do ECB."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere plaintext 'AAAAAAAAAABBBBBB' com blocos de 10 bytes: Bloco1='AAAAAAAAAA', Bloco2='BBBBBBBBBB'. Para blocos idênticos, altere para 'AAAAAAAAAA' || 'AAAAAAAAAA'. Usando AES-ECB com chave fixa (ex: 'YELLOW SUBMARINE'), encripta produz C1 || C2 onde C1==C2 se P1==P2. Decriptação recupera exatamente o original, mas padrões repetem no ciphertext, permitindo análise de frequência.",
                              "finalVerifications": [
                                "Explicar corretamente a independência de blocos na encriptação e decriptação.",
                                "Demonstrar com diagrama como 2 blocos idênticos geram ciphertext idêntico.",
                                "Identificar pelo menos uma fraqueza do ECB relacionada a padrões.",
                                "Simular manualmente encriptação/decriptação de um plaintext de 2 blocos.",
                                "Comparar ECB com modo sem chaining em termos de paralelismo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos passos de encriptação (100% dos substeps corretos).",
                                "Clareza na ilustração do exemplo com blocos idênticos (diagrama legível).",
                                "Compreensão da independência: sem menção errada a IV ou chaining.",
                                "Análise crítica: mencionar vazamento de padrões no ciphertext.",
                                "Profundidade: incluir padding e concatenação corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em campos finitos (GF(2^8)) usadas em cifras de bloco.",
                                "Segurança da Informação: Análise de ataques chosen-plaintext em padrões repetitivos.",
                                "Programação: Implementação de ECB usando bibliotecas como cryptography em Python.",
                                "História da Computação: Evolução de modos de operação desde os anos 1970 (Data Encryption Standard).",
                                "Física: Analogia com multiplexação de sinais independentes."
                              ],
                              "realWorldApplication": "ECB é usado em sistemas legados ou quando blocos são pré-aleatorizados (ex: chaves derivadas), mas evitado para dados padronizados como texto/imagens devido a vazamento de padrões; serve como base educacional para entender modos mais seguros como CBC ou GCM em protocolos como TLS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Identificar vantagens do modo ECB",
                            "description": "Listar e justificar as vantagens, como paralelização na encriptação/decriptação e ausência de necessidade de IV (vetor de inicialização).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento básico do modo ECB",
                                  "subSteps": [
                                    "Leia a definição de ECB: cada bloco de texto plano é encriptado independentemente usando a mesma chave.",
                                    "Estude diagramas de ECB mostrando blocos paralelos.",
                                    "Compare visualmente com modos dependentes como CBC.",
                                    "Implemente um exemplo simples de ECB em pseudocódigo.",
                                    "Teste encriptação de múltiplos blocos idênticos."
                                  ],
                                  "verification": "Crie um diagrama simples do ECB e explique independência de blocos para um colega.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de criptografia simétrica (ex: Wikipedia ECB)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Pseudocódigo editor"
                                  ],
                                  "tips": "Foque na independência: cada bloco é tratado isoladamente, sem chain.",
                                  "learningObjective": "Compreender que no ECB, blocos são processados de forma independente, permitindo análise de vantagens.",
                                  "commonMistakes": [
                                    "Confundir ECB com modos em cadeia como CBC",
                                    "Achar que ECB usa IV",
                                    "Ignorar que blocos idênticos produzem ciphertext idêntico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar vantagem de paralelização na encriptação",
                                  "subSteps": [
                                    "Explique por que blocos independentes permitem processamento simultâneo.",
                                    "Simule encriptação paralela de 4 blocos em um diagrama.",
                                    "Calcule ganho de performance: tempo serial vs. paralelo (ex: 4 núcleos reduzem tempo em 75%).",
                                    "Pesquise benchmarks de AES-ECB em multi-thread.",
                                    "Discuta cenários onde paralelismo acelera (ex: big data)."
                                  ],
                                  "verification": "Demonstre com código ou diagrama que múltiplos blocos podem ser encriptados ao mesmo tempo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca crypto como OpenSSL ou Python cryptography",
                                    "Processador multi-core simulado",
                                    "Calculadora de performance"
                                  ],
                                  "tips": "Use threads ou GPU para visualizar speedup real.",
                                  "learningObjective": "Justificar como a independência de blocos permite paralelização total na encriptação, melhorando throughput.",
                                  "commonMistakes": [
                                    "Pensar que chave compartilhada impede paralelismo",
                                    "Confundir com decriptação",
                                    "Subestimar overhead de threads"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar paralelização na decriptação no ECB",
                                  "subSteps": [
                                    "Confirme que decriptação ECB também é independente por bloco.",
                                    "Compare com CBC onde decriptação é serial.",
                                    "Implemente exemplo de decriptação paralela de ciphertext.",
                                    "Meça tempo em ferramenta: serial vs. paralelo.",
                                    "Discuta aplicações em storage de grandes arquivos."
                                  ],
                                  "verification": "Execute teste cronometrado mostrando speedup na decriptação paralela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python com multiprocessing para AES-ECB",
                                    "Arquivo de teste grande (1MB ciphertext)"
                                  ],
                                  "tips": "Teste com dados reais para ver diferença prática.",
                                  "learningObjective": "Explicar que tanto encriptação quanto decriptação ECB suportam paralelismo completo, ao contrário de outros modos.",
                                  "commonMistakes": [
                                    "Achar que decriptação ECB precisa de chain",
                                    "Ignorar que ambos plaintext e ciphertext blocos são independentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar ausência de necessidade de IV e outras vantagens",
                                  "subSteps": [
                                    "Defina IV e por que modos como CBC precisam dele.",
                                    "Justifique que ECB não requer IV por independência.",
                                    "Liste vantagens: simplicidade, menor overhead, reutilização de chaves sem estado.",
                                    "Discuta cenários onde ausência de IV é benéfica (ex: chaves fixas).",
                                    "Compare tamanho de chave+IV vs. ECB puro."
                                  ],
                                  "verification": "Escreva parágrafo justificando por que ECB dispensa IV sem comprometer segurança básica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela comparativa de modos de operação",
                                    "Especificação NIST SP 800-38A"
                                  ],
                                  "tips": "Lembre: ECB sacrifica hiding de padrões por simplicidade.",
                                  "learningObjective": "Identificar e justificar ausência de IV como vantagem em simplicidade e performance.",
                                  "commonMistakes": [
                                    "Confundir IV com nonce",
                                    "Pensar que ECB é mais seguro sem IV",
                                    "Esquecer desvantagens de padrões"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Compilar e justificar lista completa de vantagens do ECB",
                                  "subSteps": [
                                    "Liste todas: paralelização enc/dec, sem IV, simplicidade, hardware-friendly.",
                                    "Justifique cada uma com evidência (ex: benchmarks, specs).",
                                    "Crie tabela: Vantagem | Justificativa | Exemplo.",
                                    "Debata quando usar ECB vs. outros.",
                                    "Revise e refine a lista."
                                  ],
                                  "verification": "Apresente lista de 4+ vantagens com justificativas em documento formatado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets para tabela",
                                    "Artigos sobre performance de modos AES"
                                  ],
                                  "tips": "Priorize quantificáveis como '4x speedup em 4 cores'.",
                                  "learningObjective": "Produzir lista acionável de vantagens ECB com justificativas robustas.",
                                  "commonMistakes": [
                                    "Listar desvantagens como vantagens",
                                    "Falta de justificativa técnica",
                                    "Generalizações sem evidência"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao encriptar uma imagem PNG grande (milhões de pixels), divida em blocos de 128 bits (AES). Com ECB, processe todos blocos em paralelo usando GPU, reduzindo tempo de horas para segundos, sem precisar de IV ou chain de dependências.",
                              "finalVerifications": [
                                "Liste pelo menos 4 vantagens corretas do ECB.",
                                "Justifique paralelização com exemplo de speedup.",
                                "Explique ausência de IV com comparação a CBC.",
                                "Crie diagrama mostrando independência de blocos.",
                                "Demonstre código simples de ECB paralelo.",
                                "Discuta limitação contextual (não para dados com padrões)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Vantagens corretas sem confusão com outros modos.",
                                "Profundidade de justificativas: Evidências como benchmarks ou specs.",
                                "Completude: Cobertura de paralelismo enc/dec e IV.",
                                "Clareza: Explicações concisas e diagramas eficazes.",
                                "Aplicação prática: Exemplos relevantes e realistas.",
                                "Originalidade: Análise além de cópia de fontes."
                              ],
                              "crossCurricularConnections": [
                                "Computação Paralela: Conceitos de threads e speedup em multi-core/GPU.",
                                "Matemática: Funções bijectivas e modularidade em blocos.",
                                "Eficiência Algorítmica: Análise de tempo O(n) vs. serial.",
                                "Engenharia de Software: Trade-offs simplicidade vs. segurança.",
                                "Física/Química: Analogia com processos independentes em sistemas."
                              ],
                              "realWorldApplication": "Em sistemas de licenciamento de software onde chaves são curtas e padrões não são problema, ECB permite encriptação ultra-rápida e paralela de metadados; ou em hardware dedicado como smart cards para operações simples sem estado."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Reconhecer vulnerabilidades do modo ECB",
                            "description": "Analisar ataques como detecção de padrões em imagens cifradas (ex: pinguim em ECB) e demonstrar por que não é seguro para dados com repetições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o funcionamento básico do modo ECB",
                                  "subSteps": [
                                    "Divida uma mensagem plaintext em blocos fixos de tamanho igual ao do algoritmo de cifra (ex: 128 bits para AES).",
                                    "Aplique a função de cifra simétrica a cada bloco independentemente, usando a mesma chave.",
                                    "Concatene os blocos cifrados para formar o ciphertext.",
                                    "Observe que não há dependência entre blocos: cada um é tratado isoladamente.",
                                    "Compare com outros modos como CBC, destacando a ausência de IV ou chaining."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando plaintext dividido em blocos e ciphertext correspondente, confirmando independência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Documentação de AES/ECB (ex: Wikipedia ou tutorial de criptografia)"
                                  ],
                                  "tips": "Visualize os blocos como 'caixas separadas' que não se comunicam.",
                                  "learningObjective": "Explicar como o ECB processa dados em blocos independentes.",
                                  "commonMistakes": [
                                    "Confundir ECB com modos que usam IV ou chaining.",
                                    "Achar que ECB embaralha toda a mensagem de uma vez."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a propriedade de determinação no ECB",
                                  "subSteps": [
                                    "Crie um plaintext com blocos idênticos (ex: repetir 'AAA...A' em múltiplos blocos).",
                                    "Cifre com ECB e observe que blocos iguais no plaintext geram blocos iguais no ciphertext.",
                                    "Teste com plaintexts ligeiramente diferentes para confirmar que pequenas mudanças afetam apenas um bloco.",
                                    "Registre o padrão: ECB preserva padrões de repetição do plaintext no ciphertext.",
                                    "Discuta semanticamente: isso vaza informação sobre a estrutura do plaintext."
                                  ],
                                  "verification": "Gere dois ciphertexts de plaintexts com blocos repetidos e confirme visualmente padrões idênticos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef ou Python com pycryptodome/AES-ECB",
                                    "Exemplo de código: from Crypto.Cipher import AES; cipher = AES.new(key, AES.MODE_ECB)"
                                  ],
                                  "tips": "Use plaintexts curtos e repetitivos para facilitar a visualização dos padrões.",
                                  "learningObjective": "Reconhecer que ECB é determinístico por bloco, revelando repetições.",
                                  "commonMistakes": [
                                    "Ignorar padding e achar que todos os blocos são naturalmente iguais.",
                                    "Confundir com ofuscação em vez de detecção de padrões."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar vulnerabilidade com cifragem de imagens (exemplo do pinguim)",
                                  "subSteps": [
                                    "Obtenha uma imagem com padrões repetidos, como o famoso pinguim do Linux Tux.",
                                    "Converta a imagem em bytes e cifre com AES-ECB bloco a bloco.",
                                    "Compare a imagem original com a cifrada: observe contornos e padrões visíveis no ciphertext.",
                                    "Experimente com uma imagem aleatória (sem padrões) para contrastar: ECB falha mais em dados estruturados.",
                                    "Analise pixels como blocos: áreas uniformes (ex: fundo preto) cifram igual, revelando formas."
                                  ],
                                  "verification": "Exiba side-by-side imagem original e ECB-cifrada, apontando pelo menos 3 padrões visíveis (ex: olhos, bico).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Imagem do pinguim Tux (disponível online)",
                                    "Ferramenta: CyberChef (plug-in ECB) ou script Python para cifrar imagem",
                                    "Visualizador de imagens hex/binário"
                                  ],
                                  "tips": "Use imagens coloridas para padrões mais evidentes; teste tamanhos de bloco variados.",
                                  "learningObjective": "Visualizar como ECB falha em esconder padrões multimídia.",
                                  "commonMistakes": [
                                    "Usar modo errado (ex: CBC) acidentalmente.",
                                    "Achar que ruído esconde tudo, ignorando blocos uniformes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos em dados com repetições e testar ataques",
                                  "subSteps": [
                                    "Crie plaintext com repetições naturais (ex: logs de rede, JSON com campos iguais).",
                                    "Cifre com ECB e detecte padrões: frequência de análise ou dicionário de blocos.",
                                    "Simule ataque de detecção: conte blocos duplicados no ciphertext para inferir repetições no plaintext.",
                                    "Discuta cenários: ECB inseguro para texto, imagens, dados biométricos com padrões.",
                                    "Compare com modos seguros (CBC, GCM) que mascaram padrões."
                                  ],
                                  "verification": "Em um plaintext repetitivo, identifique e liste pelo menos 2 blocos duplicados no ciphertext correspondente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de dados repetitivos (texto JSON ou log)",
                                    "Script Python para análise de blocos duplicados",
                                    "Referência: Crytopals Set 2 Challenge 12 (ECB oracle)"
                                  ],
                                  "tips": "Foquem em dados reais: emails, senhas hashadas não colidem assim.",
                                  "learningObjective": "Demonstrar por que ECB não é seguro para dados com redundância.",
                                  "commonMistakes": [
                                    "Subestimar repetições em dados reais como HTML ou protocolos.",
                                    "Confundir com ataques de chave, focando só em padrões."
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe a imagem do pinguim Tux, cifre-a com AES-128-ECB usando uma chave fixa (ex: 16 bytes de zeros). Abra o ciphertext como imagem: o formato do pinguim permanece visível devido a blocos de pixels idênticos cifrando igual, permitindo reconstruir o animal sem a chave.",
                              "finalVerifications": [
                                "Explicar verbalmente por que blocos plaintext idênticos vazam no ECB.",
                                "Identificar padrões em uma imagem ECB-cifrada sem ver o original.",
                                "Listar 3 dados reais onde ECB falharia (ex: imagens, logs, biometria).",
                                "Comparar ECB vs CBC em um diagrama de repetições.",
                                "Detectar ECB em um ciphertext desconhecido por blocos duplicados.",
                                "Simular ataque simples: inferir tamanho de bloco por padding."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de determinação por bloco (80%+ correta).",
                                "Qualidade do experimento com imagem: padrões destacados claramente.",
                                "Análise profunda de repetições em dados reais (exemplos relevantes).",
                                "Diagrama ou código funcional demonstrando ECB.",
                                "Conexão com segurança: explicar 'não use ECB' com razões.",
                                "Criatividade em verificações finais personalizadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções determinísticas e propriedades injetoras.",
                                "Probabilidade: Análise de frequência de blocos em criptoanálise.",
                                "Artes Digitais: Processamento de imagens e detecção de padrões.",
                                "Ética em TI: Implicações de privacidade em dados vazados.",
                                "Física: Analogia com difração de ondas preservando padrões."
                              ],
                              "realWorldApplication": "ECB revela estruturas em protocolos legados como SSL antigo ou armazenamento inseguro de imagens médicas/biometria; moderno usa GCM/CBC para apps como WhatsApp, HTTPS, evitando vazamento de padrões em mensagens repetidas ou fotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Modo CBC (Cipher Block Chaining)",
                        "description": "No modo CBC, cada bloco de plaintext é XORado com o ciphertext do bloco anterior antes da encriptação, usando um IV para o primeiro bloco. Vantagens: oculta padrões e permite encriptação de dados variáveis. Vulnerabilidades: erro de propagação em um bloco afeta o próximo na decriptação; padding oracle attacks.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Explicar o processo de encriptação e decriptação no CBC",
                            "description": "Detalhar o uso do IV e XOR entre plaintext e ciphertext anterior, com diagrama conceitual e exemplo numérico simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes básicos do modo CBC",
                                  "subSteps": [
                                    "Defina o que é Cipher Block Chaining (CBC) e sua diferença em relação ao ECB.",
                                    "Explique o papel do Initialization Vector (IV): um bloco aleatório de tamanho igual ao bloco da cifra.",
                                    "Descreva os blocos de plaintext (P1, P2, ...), ciphertext (C1, C2, ...) e a chave secreta compartilhada.",
                                    "Revise a operação XOR bitwise como base para chaining.",
                                    "Esboce um diagrama conceitual vazio mostrando IV → C1 → C2."
                                  ],
                                  "verification": "Desenhe um diagrama simples identificando IV, P1, C1 corretamente e explique cada componente em voz alta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para diagrama, acesso a um recurso online sobre XOR (ex: Khan Academy).",
                                  "tips": "Use cores diferentes no diagrama para IV (azul), plaintext (verde) e ciphertext (vermelho).",
                                  "learningObjective": "Compreender os elementos fundamentais do CBC e sua importância para evitar padrões no ciphertext.",
                                  "commonMistakes": "Confundir IV com chave (IV é público e único por mensagem); ignorar que IV não é secreto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o processo de encriptação no CBC",
                                  "subSteps": [
                                    "Para o primeiro bloco: XOR(IV, P1) e depois aplique a cifra de bloco (E_k) para obter C1.",
                                    "Para blocos subsequentes: XOR(C_{i-1}, P_i) e aplique E_k para obter C_i.",
                                    "Note que o IV é usado apenas no primeiro bloco e transmitido junto com o ciphertext.",
                                    "Desenhe setas no diagrama: IV XOR P1 → E_k → C1; C1 XOR P2 → E_k → C2.",
                                    "Simule manualmente com números pequenos para um bloco."
                                  ],
                                  "verification": "Reproduza o diagrama de encriptação com 2 blocos e verbalize a fórmula C_i = E_k(P_i XOR C_{i-1}) (C0=IV).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para diagrama, calculadora para XOR manual (ex: 1010 XOR 1100 = 0110).",
                                  "tips": "Lembre-se: chaining usa ciphertext anterior, tornando cada bloco dependente do anterior.",
                                  "learningObjective": "Dominar a sequência de XOR e encriptação bloco a bloco.",
                                  "commonMistakes": "Usar plaintext anterior em vez de ciphertext; esquecer de aplicar E_k após XOR."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o processo de decriptação no CBC",
                                  "subSteps": [
                                    "Para o primeiro bloco: Aplique a decriptação de bloco (D_k) em C1 para obter P1' = D_k(C1) XOR IV.",
                                    "Para blocos subsequentes: P_i' = D_k(C_i) XOR C_{i-1}.",
                                    "Desenhe setas reversas no diagrama: C1 → D_k → XOR IV → P1; C2 → D_k → XOR C1 → P2.",
                                    "Enfatize que o receptor precisa do IV e da chave para iniciar.",
                                    "Simule a decriptação reversa do exemplo de encriptação."
                                  ],
                                  "verification": "Descreva e desenhe o fluxo de decriptação, confirmando que P_i' = P_i original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo diagrama do step 2, atualizado com setas de decriptação.",
                                  "tips": "Decriptação é 'inversa': D_k primeiro, depois XOR com o 'anterior' apropriado (IV ou C prev).",
                                  "learningObjective": "Entender como o chaining é revertido sem perda de dependências.",
                                  "commonMistakes": "XOR antes de D_k na decriptação; usar P_{i-1} em vez de C_{i-1}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar com exemplo numérico simples e diagrama completo",
                                  "subSteps": [
                                    "Escolha exemplo: Chave k fixa (simulada), IV=0001, P1=1011, P2=1100 (blocos de 4 bits).",
                                    "Calcule encriptação: C1 = E_k(0001 XOR 1011)=E_k(1010); assuma E_k(1010)=0011. C2=E_k(0011 XOR 1100)=E_k(1111)=0101.",
                                    "Calcule decriptação: P1=D_k(0011) XOR 0001; P2=D_k(0101) XOR 0011.",
                                    "Desenhe diagrama completo com valores numéricos.",
                                    "Discuta por que CBC é mais seguro que ECB (sem padrões idênticos para plaintext idêntico)."
                                  ],
                                  "verification": "Execute o exemplo numérico do início ao fim e confirme recuperação perfeita do plaintext.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de XOR bitwise impressa, software como Python (opcional) para simular.",
                                  "tips": "Use blocos pequenos (4-8 bits) para cálculos manuais fáceis.",
                                  "learningObjective": "Aplicar conceitualmente CBC em um cenário numérico concreto.",
                                  "commonMistakes": "Erro em cálculos XOR; não transmitir IV com ciphertext."
                                }
                              ],
                              "practicalExample": "Exemplo numérico: IV=0001 (4 bits), P1=1011, P2=1100. Assuma E_k simples: inverte bits. C1=E_k(0001 XOR 1011)=E_k(1010)=0101. C2=E_k(0101 XOR 1100)=E_k(1101)=0010. Decriptação: D_k(C1)=1010 XOR 0001=1011=P1; D_k(C2)=1101 XOR 0101=1000? Wait, ajuste E_k para consistência: use E_k(x)=x XOR 1111. Então C1=(0001 XOR 1011) XOR 1111=1010 XOR 1111=0101; etc. Transmita IV+C1+C2.",
                              "finalVerifications": [
                                "Desenhar diagrama completo de encriptação/decriptação com 2 blocos.",
                                "Explicar verbalmente o papel do IV sem erros.",
                                "Simular exemplo numérico com recuperação correta do plaintext.",
                                "Comparar CBC vs ECB: blocos idênticos em P produzem C diferentes.",
                                "Identificar que IV deve ser único por mensagem.",
                                "Descrever dependência em cadeia: erro em um C_i afeta todos subsequentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de XOR e aplicação de E_k/D_k (100% correto).",
                                "Clareza do diagrama conceitual com labels e setas.",
                                "Correção no exemplo numérico (cálculos XOR exatos).",
                                "Explicação fluida da diferença encriptação vs decriptação.",
                                "Compreensão de segurança: menção à quebra de padrões.",
                                "Uso correto de terminologia (IV, chaining, bloco)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise XOR e aritmética modular.",
                                "Segurança da Informação: Princípios de confidencialidade e autenticação.",
                                "Programação: Implementação em linguagens como Python (cryptography lib).",
                                "Física/Engenharia: Analogia com correntes (chaining) em circuitos.",
                                "História da Computação: Evolução de DES/AES modos de operação."
                              ],
                              "realWorldApplication": "Usado em protocolos como TLS/SSL antigos para HTTPS, proteção de dados em disco (BitLocker), VPNs (IPsec), garantindo que mensagens idênticas gerem ciphertexts diferentes via IV, prevenindo ataques de análise de padrões."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Listar vantagens e requisitos do modo CBC",
                            "description": "Descrever benefícios como segurança contra padrões repetidos e necessidade de IV único por mensagem, além de processamento sequencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Funcionamento Básico do Modo CBC",
                                  "subSteps": [
                                    "Revise o processo de criptografia em bloco simétrica (ex: AES).",
                                    "Estude o papel do IV (Initialization Vector) no primeiro bloco.",
                                    "Analise o chaining: cada bloco plaintext é XORado com o ciphertext anterior antes da criptografia.",
                                    "Observe o processo de decriptação, que requer o IV inicial e chaining reverso.",
                                    "Desenhe um diagrama simples de 3 blocos para visualizar o fluxo."
                                  ],
                                  "verification": "Explique em suas próprias palavras como um bloco plaintext é processado no segundo e subsequentes blocos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de fluxo CBC (imprimir ou desenhar)",
                                    "Exemplos visuais de ECB vs CBC online (ex: dcode.fr)",
                                    "Blocos de exemplo: P1, P2, P3 com IV"
                                  ],
                                  "tips": "Pense no CBC como uma 'corrente' onde cada elo depende do anterior para quebrar padrões.",
                                  "learningObjective": "Entender o mecanismo de chaining que diferencia CBC de modos paralelizáveis como ECB.",
                                  "commonMistakes": [
                                    "Confundir XOR com adição simples.",
                                    "Achar que IV é criptografado diretamente (é XORado).",
                                    "Ignorar que decriptação não requer IV após o primeiro bloco."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Listar Vantagens do Modo CBC",
                                  "subSteps": [
                                    "Compare CBC com ECB: observe padrões repetidos em ECB para plaintexts idênticos.",
                                    "Liste a difusão: um bit alterado afeta todos os blocos subsequentes.",
                                    "Discuta segurança contra ataques de texto plano conhecido.",
                                    "Explique aleatoriedade: mensagens idênticas produzem cifras diferentes com IV único.",
                                    "Registre pelo menos 4 vantagens em uma tabela comparativa."
                                  ],
                                  "verification": "Crie uma lista de 4 vantagens com justificativa breve para cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa ECB vs CBC (preparar template)",
                                    "Ferramenta online de criptografia (ex: CyberChef)",
                                    "Exemplos de plaintext repetido"
                                  ],
                                  "tips": "Use exemplos concretos como 'AAA...BBB' para ver padrões em ECB desaparecendo em CBC.",
                                  "learningObjective": "Reconhecer como CBC melhora a confidencialidade em relação a modos inseguros.",
                                  "commonMistakes": [
                                    "Superestimar paralelização (CBC é sequencial).",
                                    "Esquecer que vantagem depende de IV único.",
                                    "Confundir com autenticação (CBC não provê integridade)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar e Listar Requisitos do Modo CBC",
                                  "subSteps": [
                                    "Identifique necessidade de IV único por mensagem (não reutilizável).",
                                    "Especifique que IV deve ser imprevisível e não secreto.",
                                    "Discuta processamento sequencial: não paraleliza criptografia.",
                                    "Note dependência do ciphertext anterior para cada bloco.",
                                    "Liste requisitos de implementação: tamanho IV = tamanho bloco, padding se necessário."
                                  ],
                                  "verification": "Enumere 5 requisitos com explicação de consequências de violação (ex: reutilizar IV).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação AES-CBC (RFC 3602)",
                                    "Lista de requisitos template",
                                    "Exemplos de falhas (ex: BEAST attack relacionado)"
                                  ],
                                  "tips": "Lembre: IV único previne matching de blocos iniciais entre mensagens.",
                                  "learningObjective": "Compreender pré-condições para uso seguro do CBC.",
                                  "commonMistakes": [
                                    "Pensar IV como chave (é público).",
                                    "Achar que CBC permite paralelização total.",
                                    "Ignorar padding PKCS#7 para mensagens não múltiplas de bloco."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Vantagens e Requisitos em uma Visão Completa",
                                  "subSteps": [
                                    "Compile listas de vantagens e requisitos em um documento único.",
                                    "Crie mnemônicos ou bullet points memoráveis.",
                                    "Teste recitando sem consultar notas.",
                                    "Compare com outros modos (CFB, OFB) brevemente.",
                                    "Prepare para aplicação prática."
                                  ],
                                  "verification": "Recite verbalmente ou escreva as listas sem erros em 2 minutos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento de síntese (Google Docs ou papel)",
                                    "Flashcards para recitação"
                                  ],
                                  "tips": "Agrupe: Vantagens (segurança/difusão), Requisitos (IV/sequencial).",
                                  "learningObjective": "Consolidar conhecimento para listagem fluida e precisa.",
                                  "commonMistakes": [
                                    "Listar vantagens como requisitos.",
                                    "Omitir contexto sequencial como desvantagem implícita.",
                                    "Generalizar demais sem especificidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando CyberChef ou Python (pycryptodome), criptografe 'Attack at dawn!!' duas vezes com AES-CBC: mesma chave/IV mostra padrões em ECB mas cifras diferentes em CBC; altere IV na segunda para variar completamente.",
                              "finalVerifications": [
                                "Lista pelo menos 4 vantagens corretas do CBC.",
                                "Explica corretamente o papel do IV único e suas consequências.",
                                "Identifica processamento sequencial como requisito.",
                                "Diferencia CBC de ECB com exemplo de padrão repetido.",
                                "Sintetiza lista completa sem consulta em menos de 3 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% das vantagens/requisitos corretos (40%).",
                                "Profundidade: justificativas claras para cada item (30%).",
                                "Clareza na listagem: organizada e concisa (15%).",
                                "Exemplo prático demonstrado corretamente (10%).",
                                "Compreensão de trade-offs (sequencial vs paralelo) (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise XOR e funções de difusão.",
                                "Segurança da Informação: Análise de ataques como chosen-plaintext.",
                                "Programação: Implementação de modos de operação em bibliotecas como OpenSSL.",
                                "Probabilidade: Conceitos de aleatoriedade e imprevisibilidade em IVs."
                              ],
                              "realWorldApplication": "O modo CBC é usado em protocolos como TLS 1.0/1.1 para HTTPS, protegendo dados de sites bancários contra análise de padrões em tráfego repetitivo, embora substituído por AEAD em versões modernas por vulnerabilidades conhecidas."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Analisar vulnerabilidades do modo CBC",
                            "description": "Discutir propagação de erros, malleability (alteração de blocos) e ataques como padding oracle, com exemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Propagação de Erros no Modo CBC",
                                  "subSteps": [
                                    "Revise o funcionamento básico do modo CBC: cada bloco de plaintext é XORed com o ciphertext anterior antes da encriptação.",
                                    "Analise como um erro de 1 bit no ciphertext afeta o próximo bloco de plaintext durante a decriptação.",
                                    "Simule manualmente a propagação: altere um bit em um bloco e observe o impacto nos blocos subsequentes.",
                                    "Compare com modos como ECB (sem propagação) para destacar a diferença.",
                                    "Documente os efeitos em plaintext e IV (Initialization Vector)."
                                  ],
                                  "verification": "Crie um diagrama mostrando a propagação de um erro de bit em 3 blocos consecutivos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação oficial do CBC (ex: NIST SP 800-38A)",
                                    "Ferramenta de simulação como Python com pycryptodome",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use blocos pequenos (ex: 8 bits) para simulações manuais para facilitar o entendimento visual.",
                                  "learningObjective": "Explicar como erros no ciphertext se propagam apenas no bloco seguinte no CBC.",
                                  "commonMistakes": [
                                    "Confundir propagação com modos como CTR (sem propagação)",
                                    "Ignorar o papel do IV na propagação inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Malleability e Alteração de Blocos no CBC",
                                  "subSteps": [
                                    "Defina malleability: capacidade de alterar ciphertext para modificar plaintext previsivelmente sem chave.",
                                    "Demonstre flip de bits: XOR no ciphertext de um bloco altera o plaintext correspondente no mesmo bloco.",
                                    "Explique independência entre blocos: alterações não afetam blocos anteriores, mas sim o próximo.",
                                    "Implemente um exemplo em código: modifique um ciphertext e decripte para ver mudanças no plaintext.",
                                    "Discuta implicações para autenticação: CBC não fornece integridade."
                                  ],
                                  "verification": "Modifique um ciphertext CBC e verifique se o plaintext alterado corresponde à operação esperada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca Python pycryptodome ou cryptography",
                                    "Exemplos de código CBC de repositórios GitHub",
                                    "Editor de texto/hex para manipular ciphertexts"
                                  ],
                                  "tips": "Sempre use mensagens com padding padrão (PKCS#7) para testes realistas.",
                                  "learningObjective": "Demonstrar como malleability permite ataques chosen-ciphertext sem conhecimento da chave.",
                                  "commonMistakes": [
                                    "Achar que malleability afeta todos os blocos igualmente",
                                    "Esquecer de ajustar o próximo bloco para manter padding válido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o Ataque Padding Oracle no CBC",
                                  "subSteps": [
                                    "Explique o oracle: servidor que indica se padding é válido durante decriptação.",
                                    "Descreva o ataque byte-a-byte: teste o último byte manipulando IV ou bloco anterior.",
                                    "Simule o processo: para um bloco de 16 bytes, ~128 tentativas por byte.",
                                    "Implemente um PoC simples em Python simulando o oracle.",
                                    "Analise complexidade: O(128 * block_size) queries para um bloco."
                                  ],
                                  "verification": "Implemente e execute um ataque padding oracle bem-sucedido em uma mensagem de teste.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código de exemplo padding oracle (ex: de Matasano Crypto Challenges)",
                                    "Servidor local com Flask para simular oracle",
                                    "pycryptodome para CBC"
                                  ],
                                  "tips": "Comece com block size pequeno para depuração rápida.",
                                  "learningObjective": "Executar um ataque padding oracle e recuperar plaintext completo.",
                                  "commonMistakes": [
                                    "Não alinhar XOR corretamente nos testes",
                                    "Ignorar validação de padding em múltiplos bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Vulnerabilidades com Exemplos Práticos",
                                  "subSteps": [
                                    "Compile exemplos reais: POODLE (SSLv3 CBC padding oracle), BEAST (malleability em TLS).",
                                    "Crie um relatório comparando as três vulnerabilidades (erro, malleability, padding).",
                                    "Discuta mitigações: use AEAD modes como GCM, HMAC para integridade.",
                                    "Teste cenários híbridos: combine malleability com padding oracle.",
                                    "Avalie impacto em protocolos modernos."
                                  ],
                                  "verification": "Escreva um resumo de 1 página com exemplos e mitigações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre POODLE/BEAST",
                                    "Ferramentas como Wireshark para capturar tráfego TLS CBC",
                                    "Documentação IETF sobre TLS 1.3"
                                  ],
                                  "tips": "Use diagramas Mermaid ou Draw.io para visualizar ataques.",
                                  "learningObjective": "Integrar conhecimentos para analisar cenários de ataque CBC completos.",
                                  "commonMistakes": [
                                    "Superestimar segurança de CBC com IV randômico",
                                    "Confundir CBC com modos autenticados"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um servidor web simples em Python (Flask) que aceita CBC-encrypted POST requests com PKCS#7 padding. Simule um padding oracle retornando 'Padding inválido' ou sucesso. Use um cliente para realizar um padding oracle attack e recupere uma mensagem secreta como 'flag{cbc_vulns_explained}' de um endpoint protegido.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito como um erro de 1 bit propaga no CBC.",
                                "Demonstrar malleability alterando 'Attack!' para 'Hello!' em um ciphertext.",
                                "Executar um padding oracle attack completo em uma mensagem de 16 bytes.",
                                "Identificar pelo menos 3 mitigações para cada vulnerabilidade.",
                                "Analisar um exemplo real como POODLE em termos de CBC flaws."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da propagação de erros (sem confusão com outros modos).",
                                "Correta implementação e demonstração de malleability sem erros de padding.",
                                "Sucesso no PoC de padding oracle com recuperação total do plaintext.",
                                "Profundidade na análise de exemplos reais e mitigações.",
                                "Clareza em diagramas e código comentado.",
                                "Capacidade de conectar vulnerabilidades a impactos de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações XOR e aritmética modular em blocos.",
                                "Programação: Implementação de criptografia em Python/JavaScript.",
                                "Segurança da Informação: Análise de side-channels e oracles.",
                                "Redes: Vulnerabilidades em protocolos TLS/SSL."
                              ],
                              "realWorldApplication": "Em protocolos legados como SSLv3/TLS 1.0, exploits como POODLE usaram padding oracle em CBC para roubar cookies de sessão; hoje, migração para GCM previne isso, mas análise é crucial para auditar sistemas antigos ou bibliotecas crypto inseguras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Modo CFB (Cipher Feedback)",
                        "description": "O modo CFB transforma um algoritmo de bloco em stream cipher: o feedback do ciphertext é usado para gerar o keystream via XOR com plaintext. Vantagens: auto-sincronização após erro, útil para streams. Vulnerabilidades: propagação de erros limitada, mas sensível a perdas de bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Descrever o mecanismo de feedback no CFB",
                            "description": "Explicar como o ciphertext é retroalimentado no cifrador para produzir keystream, incluindo tamanhos de segmento e exemplo com IV.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a inicialização do modo CFB com IV",
                                  "subSteps": [
                                    "Explicar o conceito de Initialization Vector (IV) como um valor inicial não secreto, mas único por mensagem.",
                                    "Descrever que o IV tem tamanho igual ao bloco do cifrador (ex: 128 bits para AES).",
                                    "Mostrar como o IV é a primeira entrada para o cifrador de bloco.",
                                    "Discutir a importância do IV para evitar reutilização de keystream.",
                                    "Esboçar o diagrama inicial do processo CFB."
                                  ],
                                  "verification": "Desenhar um diagrama simples mostrando o IV entrando no cifrador e produzindo o primeiro keystream.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama do modo CFB de fontes como Wikipedia ou NIST"
                                  ],
                                  "tips": "Sempre use um novo IV para cada sessão de criptografia para manter a segurança.",
                                  "learningObjective": "Compreender o papel crítico do IV na inicialização do CFB.",
                                  "commonMistakes": "Confundir IV com a chave secreta ou reutilizá-lo em múltiplas mensagens."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o keystream inicial a partir do IV",
                                  "subSteps": [
                                    "Cifrar o IV com a chave simétrica para obter um bloco completo de keystream.",
                                    "Explicar que o keystream gerado tem tamanho igual ao bloco do cifrador.",
                                    "Introduzir o parâmetro de segmento s (1 ≤ s ≤ tamanho do bloco), onde apenas os primeiros s bits do keystream são usados.",
                                    "Mostrar a operação XOR entre os s bits de plaintext e keystream para produzir s bits de ciphertext.",
                                    "Verificar que o processo transforma o cifrador de bloco em stream cipher."
                                  ],
                                  "verification": "Calcular manualmente o primeiro keystream e XOR com um plaintext exemplo usando números binários pequenos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora binária ou Python para XOR",
                                    "Documentação AES ou cifrador simples"
                                  ],
                                  "tips": "Use s = tamanho do bloco para simplicidade inicial, depois experimente s menor.",
                                  "learningObjective": "Dominar a geração do primeiro keystream e a operação XOR inicial.",
                                  "commonMistakes": "Usar todo o bloco de keystream sem considerar o tamanho s, levando a erros em segmentos parciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o mecanismo de feedback do ciphertext",
                                  "subSteps": [
                                    "Shiftar o registrador de entrada (inicialmente IV) à esquerda por s bits, descartando os s bits mais significativos.",
                                    "Inserir os s bits de ciphertext recém-gerados nos bits menos significativos do registrador.",
                                    "Cifrar o novo registrador para gerar o próximo bloco de keystream.",
                                    "Repetir o XOR com o próximo segmento de plaintext.",
                                    "Explicar que isso cria dependência sequencial, tornando o modo auto-sincronizante após perda de s bits."
                                  ],
                                  "verification": "Simular o shift e inserção em um diagrama ou código simples para dois segmentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para binários",
                                    "Ferramenta online como CyberChef para simulação CFB"
                                  ],
                                  "tips": "Visualize o registrador como uma fila deslizante onde ciphertext 'empurra' os bits velhos para fora.",
                                  "learningObjective": "Entender precisamente como o ciphertext é retroalimentado no cifrador.",
                                  "commonMistakes": "Esquecer o shift à esquerda, resultando em keystream repetido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar tamanhos de segmento e completar um exemplo prático",
                                  "subSteps": [
                                    "Discutir variações: s=1 para stream puro, s=bloco para modo full-feedback.",
                                    "Executar um exemplo completo com múltiplos segmentos.",
                                    "Mostrar como processar mensagens mais longas que múltiplos blocos.",
                                    "Explicar implicações de segurança (ex: IV único evita ataques de keystream reutilizado).",
                                    "Comparar brevemente com outros modos como CBC."
                                  ],
                                  "verification": "Reproduzir um exemplo numérico completo com pelo menos 3 segmentos e verificar saídas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo numérico impresso",
                                    "Biblioteca Python cryptography para validação"
                                  ],
                                  "tips": "Comece com blocos pequenos (4-8 bits) para cálculos manuais fáceis.",
                                  "learningObjective": "Aplicar o mecanismo completo incluindo tamanhos s e exemplos.",
                                  "commonMistakes": "Ignorar padding ou assumir s sempre igual ao bloco."
                                }
                              ],
                              "practicalExample": "Exemplo com cifrador de bloco 4 bits, chave K fixa (encrypt_K(0000)=1101, encrypt_K(0111)=1001). IV=0000, s=4. Segmento PT1=1010 → Keystream1=1101 → CT1=0111. Novo registrador: 0000 <<4 (descarta, insere 0111)=0111. PT2=0011 → Keystream2=1001 → CT2=1010. PT3=1111 → Novo reg=0111<<4 |1010=1010 (ajustado), etc. Isso demonstra o feedback sequencial.",
                              "finalVerifications": [
                                "Desenhar diagrama completo do processo CFB com pelo menos 3 iterações.",
                                "Explicar verbalmente o feedback de ciphertext para um colega.",
                                "Calcular corretamente um exemplo com s diferente do tamanho do bloco.",
                                "Identificar o que acontece se IV for reutilizado.",
                                "Simular perda de um segmento e mostrar auto-sincronização.",
                                "Comparar saída de uma ferramenta com cálculo manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do shift e inserção de ciphertext.",
                                "Correta explicação do papel do IV e tamanho s.",
                                "Exemplo prático numérico sem erros de XOR ou feedback.",
                                "Compreensão de implicações de segurança do feedback.",
                                "Diagrama claro e rotulado.",
                                "Identificação de erros comuns no processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise XOR e shift de bits.",
                                "Ciência da Computação: Algoritmos de cifradores de bloco e stream.",
                                "Segurança da Informação: Análise de modos de operação e vetores de ataque.",
                                "Engenharia de Software: Implementação de primitivas criptográficas em código.",
                                "Física/Engenharia: Conceitos de feedback em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "O modo CFB é utilizado em protocolos como OpenPGP, IPsec (em variantes) e bibliotecas como OpenSSL para criptografar streams de dados em redes onde perda de pacotes ocorre, permitindo auto-sincronização rápida sem retransmitir toda a mensagem, comum em comunicações VoIP seguras ou armazenamento de dados em disco."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Identificar vantagens do modo CFB",
                            "description": "Destacar auto-sincronização após perda de um bloco e adequação para canais ruidosos ou streams.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Funcionamento Básico do Modo CFB",
                                  "subSteps": [
                                    "Estude a estrutura do CFB: inicialização com IV, encriptação de blocos usando cifrador em modo feedback.",
                                    "Entenda o processo de feedback: saída do cifrador é XORed com plaintext para gerar ciphertext, que é alimentado de volta.",
                                    "Identifique que o CFB processa dados em segmentos menores (byte/bit), simulando um stream cipher."
                                  ],
                                  "verification": "Desenhe um diagrama simples do fluxo CFB e explique verbalmente ou por escrito como o feedback ocorre.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de modos de operação (NIST SP 800-38A)",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta"
                                  ],
                                  "tips": "Visualize o CFB como um 'shift register' onde o estado evolui com cada iteração.",
                                  "learningObjective": "Compreender os mecanismos de feedback que habilitam o comportamento stream-like do CFB.",
                                  "commonMistakes": "Confundir CFB com CBC, ignorando que CFB usa ciphertext anterior como IV para o próximo bloco."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Auto-Sincronização Após Perda de Bloco",
                                  "subSteps": [
                                    "Simule perda de um bloco inteiro: observe que após o bloco perdido, o próximo IV é derivado do ciphertext recém-recebido.",
                                    "Calcule manualmente um exemplo com chaves pequenas: mostre que após 1 bloco perdido, a sincronização é restaurada em até o tamanho do bloco.",
                                    "Compare com modos não auto-sincronizáveis como CBC, onde perda requer reinício."
                                  ],
                                  "verification": "Simule em código ou papel uma perda de bloco e confirme que a descriptografia prossegue corretamente após.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com pycryptodome para simulação CFB",
                                    "Exemplos de código NIST para modos de operação"
                                  ],
                                  "tips": "Use blocos pequenos (ex: AES-64 bits para teste) para facilitar cálculos manuais.",
                                  "learningObjective": "Identificar como o feedback do ciphertext permite resincronização automática.",
                                  "commonMistakes": "Acreditar que CFB resincroniza instantaneamente; leva até o tamanho do bloco."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Adequação para Canais Ruidosos e Streams",
                                  "subSteps": [
                                    "Discuta cenários de streams: CFB não requer múltiplos de bloco, processa incrementalmente.",
                                    "Examine tolerância a ruído: perdas parciais são mitigadas pela auto-sincronização local.",
                                    "Teste com dados de tamanho arbitrário: encripte/decripte streams sem padding."
                                  ],
                                  "verification": "Encripte uma mensagem de tamanho não-múltiplo de bloco e confirme descriptografia sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca OpenSSL ou pycryptodome para testes de stream",
                                    "Gerador de texto aleatório"
                                  ],
                                  "tips": "Pense em aplicações como teletipo ou rede serial onde dados chegam continuamente.",
                                  "learningObjective": "Reconhecer por que CFB é ideal para transmissão em tempo real com perdas.",
                                  "commonMistakes": "Ignorar que CFB ainda requer blocos completos para feedback, mas é mais resiliente que ECB."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Comparar Vantagens do Modo CFB",
                                  "subSteps": [
                                    "Liste vantagens: auto-sincronização, stream processing, resiliência a perdas.",
                                    "Compare tabela com CBC, OFB, CTR: destaque superioridade em canais ruidosos.",
                                    "Crie um resumo escrito das 3 principais vantagens com exemplos."
                                  ],
                                  "verification": "Produza uma tabela comparativa e explique as vantagens em 1 parágrafo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela comparativa de modos NIST",
                                    "Planilha ou Markdown para tabela"
                                  ],
                                  "tips": "Use mnemônicos: CFB = 'Cipher Feedback' para 'Continuous Flow Backup'.",
                                  "learningObjective": "Articular claramente as vantagens únicas do CFB em contextos específicos.",
                                  "commonMistakes": "Superestimar segurança; lembre que CFB não provê autenticação."
                                }
                              ],
                              "practicalExample": "Em uma transmissão de dados sensoriais de um drone via rádio com interferência ocasional, use CFB para encriptar o stream de vídeo. Se um pacote for perdido devido a ruído, o receptor resincroniza automaticamente após o próximo pacote completo, permitindo continuidade sem perda total da sessão.",
                              "finalVerifications": [
                                "Explica corretamente o mecanismo de auto-sincronização após perda de bloco.",
                                "Identifica que CFB processa streams sem padding rígido.",
                                "Lista pelo menos duas vantagens em canais ruidosos vs. outros modos.",
                                "Simula com sucesso um cenário de perda e recuperação.",
                                "Compara CFB com CBC destacando resiliência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da auto-sincronização (80% dos detalhes corretos).",
                                "Capacidade de simular e demonstrar perda/recuperação.",
                                "Identificação clara de adequação para streams/canais ruidosos.",
                                "Comparação válida com outros modos de operação.",
                                "Uso correto de terminologia criptográfica (feedback, IV derivado).",
                                "Resumo conciso e sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Tolerância a falhas em protocolos TCP/UDP.",
                                "Matemática: Operações XOR e funções de fluxo em álgebra booleana.",
                                "Segurança da Informação: Análise de risco em comunicações adversárias.",
                                "Engenharia de Software: Design de APIs stream-oriented."
                              ],
                              "realWorldApplication": "O modo CFB é utilizado em sistemas de comunicação segura como links de satélite (ex: MIL-STD-188) e protocolos de rede móvel (parte de IPsec), onde perdas de pacotes por ruído são comuns, garantindo continuidade de streams criptografados sem reinicialização frequente."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Avaliar vulnerabilidades do modo CFB",
                            "description": "Analisar propagação de erros (um bit errado afeta s bits seguintes) e possíveis ataques de manipulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Funcionamento Básico do Modo CFB",
                                  "subSteps": [
                                    "Estude a definição do modo CFB: inicialização com IV, feedback do ciphertext no próximo bloco de plaintext.",
                                    "Implemente um diagrama simples do processo de encriptação e decriptação em CFB.",
                                    "Compare CFB com modos como ECB e CBC para destacar diferenças em feedback.",
                                    "Simule manualmente um bloco de encriptação com s=8 bits usando um cifrador de bloco fictício.",
                                    "Identifique o papel do shift register de tamanho s no processo."
                                  ],
                                  "verification": "Desenhe e explique corretamente o fluxograma do CFB em um papel ou ferramenta digital.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de modos de operação (NIST SP 800-38A)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Cifrador de bloco exemplo (AES em Python/OpenSSL)"
                                  ],
                                  "tips": "Comece com s=1 para simplificar, depois expanda para s=8 ou bloco completo.",
                                  "learningObjective": "Compreender o mecanismo de feedback no CFB para análise posterior de vulnerabilidades.",
                                  "commonMistakes": [
                                    "Confundir CFB com OFB (sem uso de plaintext no feedback)",
                                    "Ignorar o tamanho s do shift register",
                                    "Assumir independência total entre blocos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propagação de Erros no Modo CFB",
                                  "subSteps": [
                                    "Defina propagação de erros: um bit flip no ciphertext afeta o shift register e os próximos s-1 bits.",
                                    "Simule um erro de 1 bit no ciphertext e trace o impacto na decriptação subsequente.",
                                    "Calcule matematicamente: erro em posição i afeta bits i até i+s-1 na plaintext.",
                                    "Compare com CBC (propagação total no bloco) e CTR (sem propagação).",
                                    "Teste com código: injete erro e observe saída corrompida."
                                  ],
                                  "verification": "Simule um erro e documente corretamente o padrão de propagação para 3 cenários diferentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com pycryptodome para simulação CFB",
                                    "Planilha para tracing manual de bits",
                                    "Exemplos de NIST sobre error propagation"
                                  ],
                                  "tips": "Use mensagens curtas (64 bits) para tracing manual; automatize com script para validação.",
                                  "learningObjective": "Quantificar e visualizar como erros se propagam limitadamente no CFB.",
                                  "commonMistakes": [
                                    "Subestimar impacto em s=bloco completo (sem auto-sincronização)",
                                    "Confundir encriptação com decriptação",
                                    "Ignorar recuperação após s bits"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Ataques de Manipulação no Modo CFB",
                                  "subSteps": [
                                    "Estude malleability: atacante pode flipar bits no ciphertext para alterar plaintext previsivelmente.",
                                    "Analise padding oracle se aplicável, ou chosen-ciphertext attacks via feedback.",
                                    "Simule um ataque: modifique ciphertext para injetar 'known plaintext' em posição desejada.",
                                    "Discuta limitações: propagação torna manipulação precisa difícil após s bits.",
                                    "Revise exemplos históricos de exploits em CFB (ex: protocolos legados)."
                                  ],
                                  "verification": "Descreva um ataque passo-a-passo e demonstre com simulação onde 1 bit flip altera plaintext específico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python para CFB malleability demo",
                                    "Artigos sobre CFB attacks (Schneier 'Applied Cryptography')",
                                    "Ferramenta como CyberChef para manipulação hex"
                                  ],
                                  "tips": "Foque em ataques locais; note que CFB não é CPA-secure sem autenticação.",
                                  "learningObjective": "Reconhecer como o feedback permite manipulações controladas no CFB.",
                                  "commonMistakes": [
                                    "Achar CFB imune a malleability como modos autenticados",
                                    "Ignorar necessidade de MAC/AEAD",
                                    "Confundir com modos stream puros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Avaliação Geral de Vulnerabilidades",
                                  "subSteps": [
                                    "Liste prós/contras: auto-sincronização vs malleability e propagação limitada.",
                                    "Compare com modos modernos (GCM, CTR+Poly1305) em termos de segurança.",
                                    "Avalie cenários de uso: streaming onde perda de bits é aceitável.",
                                    "Proponha mitigações: sempre usar com autenticação.",
                                    "Crie um relatório resumindo vulnerabilidades principais."
                                  ],
                                  "verification": "Escreva um parágrafo avaliando se CFB é adequado para aplicações modernas, justificando com evidências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela comparativa de modos (Wikipedia/Cryptopals)",
                                    "NIST recomendações FIPS 800-38",
                                    "Notebook para relatório"
                                  ],
                                  "tips": "Use matriz de vulnerabilidades (erro, malleability, replay) para estruturar.",
                                  "learningObjective": "Integrar análises para uma avaliação holística das fraquezas do CFB.",
                                  "commonMistakes": [
                                    "Superestimar auto-sincronização como solução completa",
                                    "Ignorar evolução para AEAD",
                                    "Não contextualizar com usos históricos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma transmissão de mensagem 'HELLO WORLD' em CFB-AES com s=8. Injeta um bit flip no 5º byte do ciphertext. Observe: o 5º byte da plaintext é corrompido, mais os próximos 7 bytes garbage, mas sincroniza após. Demonstre manipulação: flip para alterar 'H' para 'X' previsivelmente.",
                              "finalVerifications": [
                                "Explicar propagação: 1 bit errado afeta exatamente s bits seguintes.",
                                "Simular e documentar um ataque de bit flip com impacto controlado.",
                                "Comparar CFB vs CBC em resiliência a erros de transmissão.",
                                "Identificar 3 mitigações essenciais para uso seguro de CFB.",
                                "Avaliar se CFB é recomendado hoje (não, prefira GCM)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da propagação de erros (s bits exatos).",
                                "Demonstração prática de malleability com código/simulação.",
                                "Análise correta de ataques, incluindo limitações do feedback.",
                                "Conexões claras com modos alternativos e melhores práticas.",
                                "Relatório coeso sem erros conceituais comuns.",
                                "Criatividade em exemplos reais ou hipotéticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para shift registers e análise de propagação.",
                                "Programação: Implementação de cifradores em Python para simulações.",
                                "Segurança da Informação: Conceitos de malleability e AEAD.",
                                "Redes: Resiliência a erros em canais ruidosos (streaming).",
                                "História da Computação: Evolução de modos legados em protocolos como IPsec."
                              ],
                              "realWorldApplication": "Em sistemas legados como alguns protocolos de rádio ou satélite antigos, onde auto-sincronização após perda de bits é vital; hoje evitado em favor de GCM em TLS/HTTPS devido a malleability explorável em ataques chosen-ciphertext sem autenticação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.4",
                        "name": "Modo OFB (Output Feedback)",
                        "description": "No modo OFB, o output do cifrador (keystream) é XORado com plaintext, e o output é retroalimentado independentemente do ciphertext. Vantagens: sem propagação de erros, stream cipher seguro. Vulnerabilidades: IV reutilizado compromete múltiplas mensagens.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.4.1",
                            "name": "Explicar o funcionamento independente do OFB",
                            "description": "Detalhar geração de keystream recursivo a partir de IV, XOR com plaintext e ausência de dependência de ciphertext.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico do Modo OFB e o Papel do IV",
                                  "subSteps": [
                                    "Revise o que é um modo de operação em criptografia simétrica e liste exemplos comuns (CBC, CTR, OFB).",
                                    "Explique o IV (Initialization Vector) como um valor inicial aleatório ou único usado para inicializar o processo.",
                                    "Descreva como o OFB transforma uma cifra de bloco em um gerador de keystream semelhante a um stream cipher.",
                                    "Diferencie OFB de modos que usam feedback de ciphertext, destacando a independência.",
                                    "Esboce o diagrama inicial: IV → Encriptação → Keystream."
                                  ],
                                  "verification": "Crie um diagrama simples no papel ou ferramenta digital mostrando IV fluindo para o primeiro keystream sem input de plaintext.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; notas de aula sobre modos de operação.",
                                  "tips": "Use setas coloridas no diagrama para diferenciar fluxo de keystream de plaintext.",
                                  "learningObjective": "Entender que o OFB inicia exclusivamente com IV e chave, sem dependência inicial de dados.",
                                  "commonMistakes": "Confundir IV com chave; assumir que IV é secreto (geralmente não é)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o Primeiro Keystream e Realizar a Encriptação",
                                  "subSteps": [
                                    "Defina a operação: Keystream1 = Encrypt(Key, IV).",
                                    "Calcule Ciphertext1 = Plaintext1 XOR Keystream1.",
                                    "Explique o XOR bit a bit como operação reversível.",
                                    "Simule com exemplo numérico: IV=0000, Plaintext1=1010, assumindo Encrypt resulta em 1111 → Keystream1=1111, Ciphertext1=0101.",
                                    "Verifique que ciphertext não é usado para próximo passo."
                                  ],
                                  "verification": "Calcule manualmente um exemplo com blocos de 4 bits e confirme que Ciphertext1 = P1 XOR Encrypt(K, IV).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora binária ou Python para XOR; tabela de verdade de XOR.",
                                  "tips": "Use blocos pequenos (4-8 bits) para cálculos manuais fáceis.",
                                  "learningObjective": "Dominar a geração inicial de keystream e sua combinação com plaintext via XOR.",
                                  "commonMistakes": "Usar ciphertext em vez de keystream para feedback; esquecer que XOR é simétrico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Processo Recursivo de Geração de Keystream",
                                  "subSteps": [
                                    "Descreva o feedback: Próximo OIV = Keystream anterior (não ciphertext).",
                                    "Keystream2 = Encrypt(Key, Keystream1), Ciphertext2 = Plaintext2 XOR Keystream2.",
                                    "Continue recursivamente para blocos subsequentes.",
                                    "Simule segundo bloco no exemplo anterior: OIV2=1111 → Keystream2=Encrypt(K,1111), etc.",
                                    "Enfatize recursão: cada keystream depende só da sequência anterior de keystreams."
                                  ],
                                  "verification": "Gere keystream para 3 blocos em sequência e liste a cadeia: IV → KS1 → KS2 → KS3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou código Python simples para simular encriptação fictícia.",
                                  "tips": "Pense como uma 'semente' que evolui sozinha, independente dos dados.",
                                  "learningObjective": "Compreender a recursão que garante independência do plaintext/ciphertext.",
                                  "commonMistakes": "Confundir feedback de OFB (keystream) com CFB (ciphertext) ou CBC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Decriptação e Independência Total do Ciphertext",
                                  "subSteps": [
                                    "Explique que decriptação é idêntica: gere keystream do IV e XOR com ciphertext.",
                                    "Plaintext1 = Ciphertext1 XOR Keystream1 (mesmo KS gerado independentemente).",
                                    "Simule decriptação no exemplo: 0101 XOR 1111 = 1010.",
                                    "Compare com modos dependentes (ex: CBC requer ciphertext anterior para próximo).",
                                    "Discuta vantagens: tolerância a erros de transmissão, uso em broadcast."
                                  ],
                                  "verification": "Decripte o ciphertext gerado anteriormente usando o mesmo processo e confirme recuperação do plaintext original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo exemplo numérico do passo 2; diagrama de encriptação vs decriptação.",
                                  "tips": "Desenhe diagramas paralelos de enc/decriptação para visualizar simetria.",
                                  "learningObjective": "Reconhecer que OFB permite decriptação sem acesso sequencial ao ciphertext anterior.",
                                  "commonMistakes": "Assumir que decriptação precisa de plaintext anterior; ignorar reutilização de IV."
                                }
                              ],
                              "practicalExample": "Considere uma mensagem 'HELLO' dividida em blocos de 4 bytes. IV = [0x00,0x00,0x00,0x00]. Usando AES-128 com chave fixa, gere KS1 = AES(K, IV), C1 = 'HELL' XOR KS1. KS2 = AES(K, KS1), C2 = 'LO..' XOR KS2. Na decriptação, receptor gera KS idêntico de IV e XOR com C obtém 'HELLO' sem precisar de C1 para C2.",
                              "finalVerifications": [
                                "Gere keystream recursivo para 4 blocos sem usar ciphertext em nenhum feedback.",
                                "Decripte uma mensagem criptografada em OFB e confirme plaintext original.",
                                "Compare diagrama OFB vs CBC mostrando ausência de seta de ciphertext para próximo bloco.",
                                "Explique verbalmente por que OFB é seguro para streams com perda de pacotes.",
                                "Identifique em código fonte se o feedback usa output da encriptação ou ciphertext.",
                                "Simule erro em um ciphertext e verifique que só afeta um bloco."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do feedback recursivo (keystream, não ciphertext).",
                                "Correta simulação numérica de pelo menos 2 blocos de keystream.",
                                "Explicação clara da simetria enc/dec e independência.",
                                "Uso correto de terminologia (IV, OIV, keystream, XOR).",
                                "Diagrama visual preciso sem erros de fluxo.",
                                "Identificação de vantagens sobre modos dependentes de ciphertext."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise XOR e recursão em sequências.",
                                "Programação: Implementação de geradores de stream em Python ou C++.",
                                "Segurança da Informação: Análise de modos resistentes a erros de transmissão.",
                                "Engenharia de Software: Uso em protocolos de rede como TLS streams."
                              ],
                              "realWorldApplication": "No protocolo WEP (antigo Wi-Fi), OFB-like modes protegem broadcasts sem retransmissão; em streaming de vídeo criptografado (Netflix DRM), permite perda de pacotes sem corromper o stream inteiro, gerando keystream independente por frame."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.4.2",
                            "name": "Enumerar vantagens do modo OFB",
                            "description": "Mencionar ausência de propagação de erros, paralelização na decriptação e uso em canais ruidosos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento básico do modo OFB",
                                  "subSteps": [
                                    "Examine o diagrama do modo OFB: o cifrador é alimentado com o IV inicial e gera um keystream via feedback.",
                                    "Entenda que tanto encriptação quanto decriptação usam XOR com o mesmo keystream independente do plaintext ou ciphertext.",
                                    "Simule manualmente um ciclo de OFB com um bloco pequeno (ex: AES com 128 bits).",
                                    "Compare com modos como ECB para destacar a geração sequencial do keystream.",
                                    "Anote como o keystream é pré-computável no lado receptor."
                                  ],
                                  "verification": "Desenhe e explique corretamente o fluxograma do OFB em um papel ou ferramenta digital.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de OFB (impresso ou online), calculadora para XOR manual, acesso a documentação de criptografia (ex: Wikipedia ou NIST).",
                                  "tips": "Use cores diferentes no diagrama para distinguir keystream, plaintext e ciphertext.",
                                  "learningObjective": "Compreender a mecânica independente do keystream na encriptação e decriptação.",
                                  "commonMistakes": "Confundir OFB com CFB, achando que depende do plaintext anterior."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a ausência de propagação de erros",
                                  "subSteps": [
                                    "Simule um erro de bit em um ciphertext de OFB e observe o impacto no próximo bloco.",
                                    "Compare com CBC: em CBC, erro propaga até o próximo bloco inteiro.",
                                    "Calcule estatisticamente: em OFB, apenas 1 bit afetado vs propagação em outros modos.",
                                    "Teste com ferramenta como CyberChef ou Python (pycryptodome) inserindo ruído.",
                                    "Documente o resultado: recuperação imediata após o bloco com erro."
                                  ],
                                  "verification": "Demonstre via simulação que um erro em um bit não afeta blocos subsequentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta online CyberChef, script Python simples para OFB, exemplos de ciphertexts.",
                                  "tips": "Comece com chaves e IV conhecidos para facilitar verificação.",
                                  "learningObjective": "Identificar como OFB limita erros a um único bloco.",
                                  "commonMistakes": "Ignorar que o erro no keystream afeta apenas o bloco atual, não sincronização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar paralelização na decriptação",
                                  "subSteps": [
                                    "Gere múltiplos keystreams em paralelo pré-computando blocos independentes.",
                                    "Compare com modos sequenciais como CBC, que requerem processamento serial.",
                                    "Implemente um exemplo em pseudocódigo mostrando threads paralelas para keystream.",
                                    "Meça tempo: simule decriptação de 1MB em série vs paralelo.",
                                    "Discuta escalabilidade em hardware multi-core."
                                  ],
                                  "verification": "Escreva pseudocódigo que decripte blocos em paralelo usando OFB.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (VS Code), biblioteca pycryptodome para teste, timer para benchmark.",
                                  "tips": "Use IVs derivados para blocos paralelos, mantendo sincronização.",
                                  "learningObjective": "Reconhecer suporte à paralelização inerente ao OFB na decriptação.",
                                  "commonMistakes": "Confundir paralelização de encriptação (limitada) com decriptação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir adequação a canais ruidosos e sintetizar vantagens",
                                  "subSteps": [
                                    "Pesquise cenários reais: rádio, satélites com alta taxa de erro de bit (BER).",
                                    "Liste vantagens: não-propagação + recuperação rápida + keystream reutilizável.",
                                    "Compare com stream ciphers puros como RC4 (evite uso hoje).",
                                    "Enumere as 3 principais vantagens em bullet points com justificativas.",
                                    "Crie um quadro comparativo OFB vs CBC/CTR para canais ruidosos."
                                  ],
                                  "verification": "Produza uma lista enumerada de pelo menos 3 vantagens com evidências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Artigos NIST sobre modos de operação, quadro comparativo em Excel/Google Sheets.",
                                  "tips": "Foque em métricas como BER tolerância para concretude.",
                                  "learningObjective": "Sintetizar e enumerar vantagens do OFB de forma clara e fundamentada.",
                                  "commonMistakes": "Omitir contexto de canais ruidosos ou exagerar segurança (OFB não é autenticação)."
                                }
                              ],
                              "practicalExample": "Em uma transmissão de dados via rádio amador com ruído atmosférico (BER 10^-4), use OFB com AES-128: um burst de erro corrompe um bloco de 16 bytes, mas os 100KB subsequentes são recuperados perfeitamente após re-sincronização do keystream, permitindo comunicação contínua sem retransmissão total.",
                              "finalVerifications": [
                                "Liste corretamente as 3 vantagens principais: não-propagação de erros, paralelização na decriptação e adequação a canais ruidosos.",
                                "Explique com diagrama como um erro de bit afeta apenas o bloco atual em OFB.",
                                "Demonstre via código ou simulação a geração paralela de keystream.",
                                "Compare OFB com CBC em um quadro, destacando superioridade em ruído.",
                                "Aplique as vantagens a um cenário real como telecomunicações.",
                                "Responda a perguntas sobre limitações do OFB (ex: sem autenticação)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: todas as vantagens citadas com justificativa correta (30%)",
                                "Completude: pelo menos 3 vantagens enumeradas com exemplos (25%)",
                                "Clareza na explicação: uso de diagramas/simulações (20%)",
                                "Profundidade comparativa: distinção de outros modos (15%)",
                                "Aplicação prática: ligação a cenários reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações XOR e teoria de códigos de correção de erros.",
                                "Física: Modelos de canais ruidosos (modelo BSC - Binary Symmetric Channel).",
                                "Engenharia de Telecomunicações: Protocolos de transmissão em ambientes hostis.",
                                "Segurança da Informação: Análise de trade-offs em modos de operação."
                              ],
                              "realWorldApplication": "O modo OFB é usado em sistemas de comunicação satelital e rádio militar (ex: padrões MIL-STD), onde ruído e interferência são comuns, permitindo decriptação paralela em GPUs para streams de vídeo em tempo real sem perda catastrófica por erros transitórios."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.4.3",
                            "name": "Discutir vulnerabilidades do modo OFB",
                            "description": "Explicar riscos de reutilização de IV/keystream e ataques two-time pad, com exemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Funcionamento Básico do Modo OFB",
                                  "subSteps": [
                                    "Explicar a inicialização do contador com IV e chave simétrica",
                                    "Descrever o processo iterativo de encriptação do bloco de feedback para gerar keystream",
                                    "Mostrar como o keystream é XORado com a plaintext para produzir ciphertext",
                                    "Ilustrar a decriptação, que usa o mesmo processo de geração de keystream",
                                    "Comparar brevemente com stream ciphers puros"
                                  ],
                                  "verification": "Desenhar um diagrama de fluxo do processo OFB e explicar verbalmente cada etapa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de blocos OFB",
                                    "Ferramenta online como CyberChef para simulação"
                                  ],
                                  "tips": "Visualize o OFB como um gerador de keystream autônomo, independente da plaintext.",
                                  "learningObjective": "Compreender o mecanismo de geração de keystream no modo OFB.",
                                  "commonMistakes": [
                                    "Confundir feedback com plaintext",
                                    "Achar que IV é parte do keystream final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar IV e Keystream no Contexto OFB",
                                  "subSteps": [
                                    "Definir IV como vetor de inicialização único por mensagem",
                                    "Explicar como IV inicia o primeiro bloco de feedback",
                                    "Descrever keystream como sequência de blocos criptografados derivados iterativamente",
                                    "Discutir a independência do keystream em relação à plaintext",
                                    "Enfatizar a criticidade da unicidade do IV para cada mensagem"
                                  ],
                                  "verification": "Explicar em uma frase por que o IV deve ser único e listar componentes do keystream.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas sobre modos de operação",
                                    "Exemplo de pseudocódigo para geração de keystream"
                                  ],
                                  "tips": "Pense no IV como uma 'semente' única para o gerador de keystream.",
                                  "learningObjective": "Identificar o papel preciso do IV e keystream no OFB.",
                                  "commonMistakes": [
                                    "Reutilizar IV em múltiplas mensagens",
                                    "Confundir IV com nonce"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Riscos da Reutilização de IV/Keystream",
                                  "subSteps": [
                                    "Simular reutilização de IV com mesma chave para duas mensagens diferentes",
                                    "Mostrar matematicamente que keystream KS é idêntico para ambas",
                                    "Demonstrar que C1 = P1 XOR KS e C2 = P2 XOR KS implica C1 XOR C2 = P1 XOR P2",
                                    "Explicar vazamento de informações via XOR das plaintexts",
                                    "Discutir impacto em padrões de texto (pattern attacks)"
                                  ],
                                  "verification": "Calcular manualmente XOR de dois ciphertexts e interpretar o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora binária ou Python para XOR",
                                    "Exemplos numéricos simples (blocos de 8 bits)"
                                  ],
                                  "tips": "Use blocos pequenos para cálculos manuais e veja o padrão emergir.",
                                  "learningObjective": "Reconhecer as consequências matemáticas da reutilização de keystream.",
                                  "commonMistakes": [
                                    "Ignorar que XOR é reversível",
                                    "Subestimar vazamento parcial de plaintext"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Ataque Two-Time Pad em OFB",
                                  "subSteps": [
                                    "Definir two-time pad como uso do mesmo pad (keystream) duas vezes",
                                    "Comparar com one-time pad seguro vs. two-time vulnerável",
                                    "Detalhar passos do ataque: obter C1 e C2, computar C1 XOR C2 = P1 XOR P2",
                                    "Mostrar recuperação de plaintext conhecido (known-plaintext attack)",
                                    "Analisar extensões para múltiplas mensagens (m-time pad)"
                                  ],
                                  "verification": "Descrever os passos exatos de um atacante explorando two-time pad em OFB.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo sobre two-time pad",
                                    "Simulador de criptografia em Python"
                                  ],
                                  "tips": "Lembre-se: qualquer repetição de keystream permite ataques diferenciais.",
                                  "learningObjective": "Explicar o mecanismo e execução do ataque two-time pad.",
                                  "commonMistakes": [
                                    "Confundir com ataques de padding oracle",
                                    "Achar que OFB é seguro como CTR"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Exemplos e Lições de Vulnerabilidades OFB",
                                  "subSteps": [
                                    "Fornecer exemplo numérico: P1=1010, P2=1100, KS=1111 → C1=0101, C2=0011 → C1 XOR C2=0110=P1 XOR P2",
                                    "Discutir cenários reais como protocolos legados usando OFB",
                                    "Explicar mitigações: IVs únicos e aleatórios por mensagem",
                                    "Comparar com modos mais seguros como GCM ou CTR",
                                    "Refletir sobre melhores práticas em implementação criptográfica"
                                  ],
                                  "verification": "Criar e resolver um exemplo próprio de ataque two-time pad.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Blocos binários impressos",
                                    "Código Python para OFB vulnerável"
                                  ],
                                  "tips": "Teste seu exemplo em código para validar o vazamento.",
                                  "learningObjective": "Aplicar conceitos a exemplos concretos e derivar lições práticas.",
                                  "commonMistakes": [
                                    "Omitir aleatoriedade no IV",
                                    "Ignorar contexto de chave compartilhada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um chat seguro usando OFB, se o mesmo IV for usado para duas mensagens 'HELLO' e 'WORLD' com a mesma chave, um atacante interceptando ambos os ciphertexts pode computar C1 XOR C2 para obter 'HELLO' XOR 'WORLD', revelando padrões linguísticos e potencialmente quebrando o sigilo via análise diferencial.",
                              "finalVerifications": [
                                "Explicar corretamente por que reutilizar IV em OFB gera keystream idêntico.",
                                "Demonstrar matematicamente o vazamento P1 XOR P2 em um two-time pad.",
                                "Identificar OFB como inadequado para mensagens de tamanho variável sem IV único.",
                                "Listar pelo menos duas mitigações para vulnerabilidades OFB.",
                                "Diferenciar OFB de modos seguros como CTR.",
                                "Aplicar conceito a um exemplo hipotético de rede."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do processo de keystream e papel do IV (80% cobertura).",
                                "Correção matemática no ataque two-time pad com exemplo válido.",
                                "Profundidade de análise de riscos e vazamentos de informação.",
                                "Clareza na distinção entre OFB e outros modos de operação.",
                                "Inclusão de exemplos práticos e mitigações relevantes.",
                                "Capacidade de verbalizar conceitos sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações XOR, álgebra booleana e propriedades reversíveis.",
                                "Segurança da Informação: Análise de ameaças criptográficas e design seguro.",
                                "Programação: Implementação e depuração de algoritmos criptográficos.",
                                "Redes de Computadores: Protocolos de comunicação segura e IV management."
                              ],
                              "realWorldApplication": "Em sistemas como VPNs antigas ou protocolos IoT legados, falhas em gerenciar IVs no OFB permitiram ataques que vazaram dados sensoriais; hoje, isso reforça o uso de modos AEAD como AES-GCM em TLS para prevenir reutilização de keystream e garantir confidencialidade em comunicações reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Criptoanálise Básica de Criptosistemas Simétricos",
                    "description": "Técnicas de análise como ataques de força bruta, diferencial e linear aplicados a algoritmos simétricos como DES e AES.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Ataque de Força Bruta",
                        "description": "Técnica de criptoanálise que consiste em testar todas as chaves possíveis de um criptossistema simétrico até encontrar a correta, aplicada a algoritmos como DES e AES.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Compreender o conceito de ataque de força bruta",
                            "description": "Explicar o que é um ataque de força bruta, sua aplicação em criptosistemas simétricos como DES (56 bits) e AES (128-256 bits), e o impacto da complexidade exponencial no espaço de chaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição básica de ataque de força bruta",
                                  "subSteps": [
                                    "Defina ataque de força bruta como tentativa sistemática de todas as chaves possíveis até encontrar a correta.",
                                    "Diferencie de outros ataques, como dicionário ou rainbow tables.",
                                    "Explique que ignora a estrutura do algoritmo, testando exaustivamente.",
                                    "Discuta premissas: acesso ao ciphertext e plaintext correspondente ou oráculo de descriptografia.",
                                    "Identifique cenários onde é aplicável: chaves curtas ou fracas."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e compare com fontes confiáveis como Wikipedia ou livros de criptografia.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook e internet para pesquisa",
                                    "Livro ou PDF sobre criptografia básica"
                                  ],
                                  "tips": [
                                    "Use analogias como tentar todas as combinações de um cofre",
                                    "Anote exemplos cotidianos como adivinhar PIN de 4 dígitos"
                                  ],
                                  "learningObjective": "Compreender o conceito fundamental e suas premissas.",
                                  "commonMistakes": [
                                    "Confundir com ataques inteligentes que exploram fraquezas algorítmicas",
                                    "Ignorar a necessidade de plaintext ou oráculo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar aplicação em criptosistemas simétricos como DES",
                                  "subSteps": [
                                    "Revise DES: chave de 56 bits efetivos, bloco de 64 bits.",
                                    "Calcule espaço de chaves: 2^56 ≈ 7.2 x 10^16 possibilidades.",
                                    "Estime tempo: com 10^9 chaves/segundo, leva cerca de 2.280 anos.",
                                    "Discuta DES como obsoleto devido a força bruta viável com hardware moderno.",
                                    "Simule cálculo manual para chaves menores (ex: 8 bits)."
                                  ],
                                  "verification": "Calcule e documente o tempo estimado para quebrar DES com velocidades realistas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python para potências de 2",
                                    "Artigo sobre DES e sua quebra"
                                  ],
                                  "tips": [
                                    "Use notação científica para grandes números",
                                    "Compare com hardware atual como GPUs"
                                  ],
                                  "learningObjective": "Aplicar o conceito ao DES e quantificar viabilidade.",
                                  "commonMistakes": [
                                    "Esquecer bits de paridade em DES (64 bits totais, 56 efetivos)",
                                    "Subestimar velocidade de teste moderno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar AES e comparação com DES",
                                  "subSteps": [
                                    "Revise AES: chaves de 128, 192 ou 256 bits.",
                                    "Calcule espaços: 2^128 (imenso), 2^256 (astronômico).",
                                    "Compare tempos: AES-128 com 10^18 chaves/segundo levaria bilhões de anos.",
                                    "Discuta por que AES é resistente: complexidade exponencial.",
                                    "Crie tabela comparativa DES vs AES."
                                  ],
                                  "verification": "Crie e preencha tabela comparativa de espaços de chaves e tempos estimados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Documentação oficial AES (FIPS 197)"
                                  ],
                                  "tips": [
                                    "Visualize com gráficos logarítmicos",
                                    "Use unidades como 'anos do universo' para 2^256"
                                  ],
                                  "learningObjective": "Comparar viabilidade entre algoritmos simétricos.",
                                  "commonMistakes": [
                                    "Confundir bits de chave com bits de bloco",
                                    "Ignorar avanços em hardware paralelo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender o impacto da complexidade exponencial",
                                  "subSteps": [
                                    "Explique crescimento exponencial: dobrar bits multiplica espaço por 2^n.",
                                    "Discuta lei de Moore vs exponencial: hardware dobra a cada 18 meses, mas 2^128 cresce muito mais.",
                                    "Analise trade-offs: custo computacional vs segurança.",
                                    "Debata mitigações: chaves longas, salting, iterações (ex: PBKDF2).",
                                    "Reflita sobre implicações futuras com computação quântica (Grover)."
                                  ],
                                  "verification": "Escreva parágrafo explicando por que chaves longas tornam força bruta impraticável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico de crescimento exponencial",
                                    "Artigo sobre lei de Moore"
                                  ],
                                  "tips": [
                                    "Desenhe curva exponencial vs linear",
                                    "Considere custo energético de ataques"
                                  ],
                                  "learningObjective": "Internalizar por que tamanho da chave importa exponencialmente.",
                                  "commonMistakes": [
                                    "Pensar linearmente em vez de exponencial",
                                    "Subestimar futuro hardware"
                                  ]
                                }
                              ],
                              "practicalExample": "Use Python para simular força bruta em cifra simples com chave de 4 bits: gere todas 16 chaves, teste descriptografia de um texto conhecido e meça tempo. Expanda para 8 bits e observe explosão de tempo.",
                              "finalVerifications": [
                                "Explique força bruta em 1 minuto sem notas.",
                                "Calcule tempo para DES e AES-128 com precisão.",
                                "Diferencie DES obsoleto de AES seguro.",
                                "Crie tabela comparativa correta.",
                                "Descreva 3 mitigações contra força bruta.",
                                "Explique impacto exponencial com exemplo numérico."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e completa de força bruta (20%)",
                                "Cálculos corretos de espaços de chaves (25%)",
                                "Comparação precisa DES vs AES (20%)",
                                "Explicação clara de complexidade exponencial (20%)",
                                "Exemplos e analogias relevantes (10%)",
                                "Ausência de equívocos comuns (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de potências de 2 e notação científica.",
                                "Física: Analogia com entropia e termodinâmica computacional.",
                                "História: Evolução DES para AES e quebras históricas.",
                                "Ética: Implicações de segurança cibernética e privacidade.",
                                "Probabilidade: Espaço de busca e birthday paradox."
                              ],
                              "realWorldApplication": "Em segurança de senhas (ex: cracking WiFi WPA2 com chaves fracas), validação de força de chaves em apps bancários, e design de protocolos como HTTPS onde AES resiste a supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Calcular a complexidade de um ataque de força bruta",
                            "description": "Determinar o número de operações necessárias para um ataque de força bruta em DES (2^56 tentativas) e AES-128 (2^128 tentativas), considerando hardware moderno e custo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Ataque de Força Bruta e Complexidade Computacional",
                                  "subSteps": [
                                    "Defina ataque de força bruta como tentativa exaustiva de todas as chaves possíveis.",
                                    "Explique que a complexidade é medida pelo número de tentativas: 2^n para chave de n bits.",
                                    "Discuta por que DES usa 56 bits efetivos e AES-128 usa 128 bits.",
                                    "Identifique fatores que afetam a viabilidade: taxa de tentativas por segundo e custo.",
                                    "Calcule exemplos simples como 2^10 = 1024 para ilustrar crescimento exponencial."
                                  ],
                                  "verification": "Resuma em uma frase a complexidade de um ataque de força bruta e liste os fatores chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas sobre DES e AES",
                                    "Calculadora científica",
                                    "Artigo sobre história do DES"
                                  ],
                                  "tips": "Use analogias como 'tentar todas as combinações de um cadeado' para visualizar o crescimento exponencial.",
                                  "learningObjective": "Entender o conceito base de complexidade em ataques de força bruta.",
                                  "commonMistakes": [
                                    "Confundir tamanho da chave com bits totais (DES tem 64 bits, mas 56 efetivos)",
                                    "Ignorar que nem todas as chaves são tentadas sequencialmente em paralelo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Número de Tentativas para DES (2^56)",
                                  "subSteps": [
                                    "Calcule 2^56 exatamente (aprox. 7.2 x 10^16 tentativas).",
                                    "Estime taxa de hardware moderno: ex. 1 bilhão (10^9) chaves/segundo em uma GPU.",
                                    "Calcule tempo em segundos: 2^56 / 10^9 ≈ 7.2 x 10^7 segundos.",
                                    "Converta para unidades reais: dias, anos (cerca de 2.3 anos em uma máquina).",
                                    "Considere paralelismo: 1000 GPUs reduzem para ~0.8 dias."
                                  ],
                                  "verification": "Forneça o cálculo exato de 2^56 e tempo estimado para 10^9 chaves/s.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para potências de 2",
                                    "Tabela de taxas de hash para DES"
                                  ],
                                  "tips": "Use log2 para aproximações: log10(2^56) ≈ 56 * 0.3010 = 16.856, então 10^16.856.",
                                  "learningObjective": "Dominar cálculo preciso de tentativas e tempo para DES.",
                                  "commonMistakes": [
                                    "Esquecer de converter segundos para anos corretamente",
                                    "Subestimar taxa real de hardware (use valores realistas de 2010s para DES)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Número de Tentativas para AES-128 (2^128)",
                                  "subSteps": [
                                    "Calcule 2^128 (aprox. 3.4 x 10^38 tentativas).",
                                    "Estime taxa moderna: ex. 10^12 chaves/segundo em cluster de GPUs/ASICs.",
                                    "Calcule tempo: 2^128 / 10^12 ≈ 3.4 x 10^26 segundos (bilhões de anos).",
                                    "Compare com idade do universo (~10^17 segundos) para contextualizar impraticabilidade.",
                                    "Discuta por que AES-128 é considerado seguro contra força bruta."
                                  ],
                                  "verification": "Mostre cálculo de 2^128 e explique por que é inviável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora avançada ou script Python",
                                    "Referências sobre benchmarks AES"
                                  ],
                                  "tips": "Para números grandes, use notação científica e compare com escalas conhecidas como partículas no universo.",
                                  "learningObjective": "Aplicar cálculos exponenciais a AES-128 e interpretar resultados.",
                                  "commonMistakes": [
                                    "Confundir 2^128 com 128! (fatorial)",
                                    "Usar taxa irrealista como 10^18 sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Custo Computacional e Comparar DES vs AES-128",
                                  "subSteps": [
                                    "Estime custo: energia/elétrico para hardware (ex. $0.1/kWh, 1kW por máquina).",
                                    "Calcule custo total para DES: viável (~milhões de dólares), para AES: astronômico.",
                                    "Compare: DES quebrado em 1998 por máquina dedicada; AES intacto.",
                                    "Discuta implicações: escolha de tamanho de chave baseado em custo/risco.",
                                    "Crie tabela comparativa de tempo/custo para ambos."
                                  ],
                                  "verification": "Apresente tabela comparativa com tempos e custos estimados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets",
                                    "Dados de custo de computação em nuvem (AWS/GCP)"
                                  ],
                                  "tips": "Use custo por hash-second de serviços em nuvem para estimativas realistas.",
                                  "learningObjective": "Integrar custo real e comparar segurança prática.",
                                  "commonMistakes": [
                                    "Ignorar overhead como setup paralelo",
                                    "Não considerar avanços futuros em hardware (mas foque em 'moderno')"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando um cluster de 1.000 GPUs NVIDIA A100 (taxa ~10^12 hashes/s para DES), calcule que DES-56 leva ~2 horas, mas AES-128 levaria 10^20 anos, custando trilhões de dólares – demonstrando por que migramos de DES.",
                              "finalVerifications": [
                                "Calcula corretamente 2^56 ≈ 7.2e16 e 2^128 ≈ 3.4e38.",
                                "Estima tempo realista para DES com hardware moderno (<1 dia com cluster).",
                                "Explica inviabilidade de AES-128 com comparação à idade do universo.",
                                "Inclui custo computacional em dólares para ambos.",
                                "Compara DES vs AES em tabela com unidades consistentes.",
                                "Identifica DES como quebrado historicamente por força bruta."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos exponenciais (sem erros de ordem de magnitude).",
                                "Uso de taxas de hardware realistas e fontes citadas.",
                                "Interpretação correta de resultados (viável vs impraticável).",
                                "Inclusão de conversões de unidades (segundos para anos, custo em $).",
                                "Clareza na comparação e implicações para segurança.",
                                "Estrutura lógica com tabela ou gráfico comparativo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de potências, logaritmos e notação científica.",
                                "Física: Desempenho e limitações de hardware (GPUs, termodinâmica computacional).",
                                "Economia: Análise custo-benefício de ataques computacionais.",
                                "História da Ciência: Quebra do DES em 1998 e evolução da criptografia.",
                                "Ética: Implicações de segurança em sistemas críticos (bancos, governos)."
                              ],
                              "realWorldApplication": "Avaliar a segurança de protocolos como TLS/SSL em comunicações web, justificando o uso de AES-256 em vez de DES obsoleto, e informar decisões em cibersegurança corporativa ou design de sistemas criptográficos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Identificar limitações e contramedidas",
                            "description": "Analisar por que ataques de força bruta são impraticáveis para chaves longas como AES-256 e discutir contramedidas como aumento do tamanho da chave e uso de chaves derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Ataque de Força Bruta",
                                  "subSteps": [
                                    "Defina ataque de força bruta como tentativa sistemática de todas as chaves possíveis.",
                                    "Explique que o sucesso depende do tamanho do espaço de chaves (2^n para n bits).",
                                    "Discuta taxa de tentativas realistas (ex: 10^9 por segundo em hardware moderno).",
                                    "Calcule tentativas médias necessárias: 2^(n-1).",
                                    "Relacione com AES-256: espaço de 2^256 chaves possíveis."
                                  ],
                                  "verification": "Resuma em uma frase o que é força bruta e por que depende do tamanho da chave.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, documento sobre AES (Wikipedia ou RFC 3602).",
                                  "tips": "Use analogias como tentar todas as combinações de um cofre para fixar o conceito.",
                                  "learningObjective": "Entender os fundamentos matemáticos e computacionais do ataque de força bruta.",
                                  "commonMistakes": "Confundir força bruta com ataques inteligentes como dicionário."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Complexidade Computacional para AES-256",
                                  "subSteps": [
                                    "Calcule 2^256 ≈ 1.1579 × 10^77 tentativas totais.",
                                    "Estime tempo com 1 trilhão de tentativas/segundo: anos necessários (use fórmula t = 2^(n-1) / taxa).",
                                    "Compare com idade do universo (~10^17 segundos) para contextualizar.",
                                    "Considere custos energéticos: energia para computar 2^256 operações.",
                                    "Use ferramentas online para visualização de números grandes."
                                  ],
                                  "verification": "Produza cálculo escrito mostrando tempo > 10^50 anos para AES-256.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica ou Python (script simples para potências de 2), tabela de prefixos SI.",
                                  "tips": "Divida o expoente: 2^10 ≈ 10^3, então 2^256 ≈ 10^(256*log10(2)) ≈ 10^77.",
                                  "learningObjective": "Dominar cálculos exponenciais para avaliar viabilidade de força bruta.",
                                  "commonMistakes": "Ignorar fator médio (tentar metade do espaço) ou superestimar velocidade de hardware."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Limitações Práticas Além do Tempo",
                                  "subSteps": [
                                    "Discuta limitações de hardware: superaquecimento, custo de data centers.",
                                    "Avalie energia: compare com consumo global anual de eletricidade.",
                                    "Considere armazenamento: guardar chaves testadas requer espaço impossível.",
                                    "Aborde avanços quânticos (Grover: reduz para 2^(n/2), ainda impraticável para 256 bits).",
                                    "Liste barreiras econômicas e logísticas."
                                  ],
                                  "verification": "Liste 3 limitações não-temporais com justificativas breves.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Artigos sobre consumo energético de Bitcoin mining, calculadora de energia.",
                                  "tips": "Pesquise 'brute force AES-256 time' para dados reais e cite fontes.",
                                  "learningObjective": "Identificar restrições reais além da teoria matemática.",
                                  "commonMistakes": "Focar só em tempo, ignorando recursos finitos da Terra."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Contramedidas Eficazes",
                                  "subSteps": [
                                    "Explique aumento de tamanho da chave: AES-256 vs AES-128 (2^128 ainda grande).",
                                    "Descreva derivação de chaves (PBKDF2, Argon2): adiciona custo por iteração.",
                                    "Compare: força bruta em chave derivada requer computar função lenta milhões de vezes.",
                                    "Mencione autenticação (HMAC) e rotação de chaves como extras.",
                                    "Avalie trade-offs: segurança vs performance."
                                  ],
                                  "verification": "Escreva parágrafo comparando AES-128 vs derivada de 128 bits.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação PBKDF2 (RFC 8018), exemplos de código em Python (hashlib).",
                                  "tips": "Teste derivação: timeit() em Python para ver lentidão intencional.",
                                  "learningObjective": "Aplicar contramedidas para mitigar força bruta na prática.",
                                  "commonMistakes": "Confundir derivação com alongamento simples de senha."
                                }
                              ],
                              "practicalExample": "Calcule brute-force para AES-256: com 10^18 tentativas/seg (supercomputador), leva ~3.67 × 10^59 anos. Contramedida: use PBKDF2 com 100.000 iterações em senha de 12 chars, elevando custo efetivo em 10^5x.",
                              "finalVerifications": [
                                "Explica corretamente por que 2^256 é impraticável com hardware atual.",
                                "Calcula tempo/energia com precisão razoável (ordem de magnitude).",
                                "Lista pelo menos 2 contramedidas com mecanismos.",
                                "Distingue limitações teóricas de práticas.",
                                "Compara AES-256 com chaves menores.",
                                "Menciona impactos quânticos sem exagerar."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de espaço de chaves (90%+ correto).",
                                "Profundidade na análise de limitações (cobre tempo, energia, custo).",
                                "Clareza na explicação de contramedidas (exemplos concretos).",
                                "Uso de evidências/ fontes (citações ou cálculos verificáveis).",
                                "Capacidade de analogias para comunicação eficaz.",
                                "Identificação de trade-offs em contramedidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e exponenciação para cálculos de complexidade.",
                                "Física: Consumo energético e termodinâmica em computação massiva.",
                                "Economia: Custos de infraestrutura para ataques em escala.",
                                "Química/Engenharia: Materiais para hardware de alta performance."
                              ],
                              "realWorldApplication": "Em bancos e HTTPS (TLS com AES-256), protege transações financeiras contra nações-estado; contramedidas como HKDF em apps evitam vazamentos de senhas fracas em breaches como Equifax."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Criptoanálise Diferencial",
                        "description": "Método estatístico que explora diferenças entre pares de textos claros e cifrados para recuperar a chave em criptosistemas de blocos como DES e variantes do AES.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Entender os princípios da criptoanálise diferencial",
                            "description": "Descrever o uso de pares de entrada-saída (ΔP, ΔC) e probabilidades de diferenças para quebrar rodadas de cifras como DES, com base em referências como Schneier (1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceitos Fundamentais da Criptoanálise Diferencial",
                                  "subSteps": [
                                    "Estude a definição de criptoanálise diferencial como um ataque que explora probabilidades de diferenças em entradas e saídas de cifras de bloco.",
                                    "Revise o funcionamento básico de cifras de rodadas, como DES, focando em S-boxes e expansões lineares.",
                                    "Entenda o papel das chaves parciais em ataques diferenciais.",
                                    "Leia trechos introdutórios de Schneier (1996) sobre o histórico do ataque diferencial.",
                                    "Anote os componentes chave: plaintexts pares, ciphertexts pares e chaves."
                                  ],
                                  "verification": "Explique em suas palavras o que é criptoanálise diferencial e liste 3 componentes essenciais.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Applied Cryptography' de Schneier (1996)",
                                    "Notas de aula sobre DES",
                                    "Vídeos introdutórios no YouTube sobre DES"
                                  ],
                                  "tips": [
                                    "Comece com cifras simples como uma S-box única para visualizar diferenças.",
                                    "Use diagramas para mapear transformações de rodadas."
                                  ],
                                  "learningObjective": "Compreender os fundamentos teóricos e o contexto histórico da criptoanálise diferencial.",
                                  "commonMistakes": [
                                    "Confundir com criptoanálise linear.",
                                    "Ignorar o papel probabilístico do ataque.",
                                    "Não diferenciar de ataques de força bruta."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição e Uso de Pares de Entrada-Saída (ΔP, ΔC)",
                                  "subSteps": [
                                    "Defina ΔP como a diferença XOR entre dois plaintexts pares (P1, P2).",
                                    "Defina ΔC como a diferença XOR entre dois ciphertexts pares (C1, C2).",
                                    "Aprenda a gerar pares de plaintexts com diferenças específicas (ex: uma diferença ativa em bits selecionados).",
                                    "Simule manualmente o cálculo de ΔP e ΔC para uma rodada única de uma cifra simples.",
                                    "Discuta como ΔP propaga através de rodadas para produzir ΔC com alta probabilidade."
                                  ],
                                  "verification": "Gere um par de plaintexts com ΔP específico e calcule ΔC esperado para uma S-box.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora ou Python para XOR",
                                    "Diagrama de S-box do DES",
                                    "Ferramenta online de simulador DES"
                                  ],
                                  "tips": [
                                    "Use representação hexadecimal para diferenças para facilitar cálculos.",
                                    "Sempre verifique XOR com testes unitários simples."
                                  ],
                                  "learningObjective": "Dominar a notação e geração de pares diferenciais (ΔP, ΔC).",
                                  "commonMistakes": [
                                    "Usar soma em vez de XOR para diferenças.",
                                    "Escolher pares com múltiplas diferenças ativas inicialmente.",
                                    "Confundir entrada e saída em múltiplas rodadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo de Probabilidades de Diferenças",
                                  "subSteps": [
                                    "Estude distribuições de diferenças em S-boxes: conte pares de entrada com Δ-in e Δ-out específicos.",
                                    "Calcule probabilidades diferenciais: P(ΔC | ΔP) = número de pares favoráveis / total de pares.",
                                    "Construa uma característica diferencial: tabela de probabilidades para propagação através de rodadas.",
                                    "Aprenda sobre bias e probabilidade total de uma característica (produto das probabilidades por rodada).",
                                    "Implemente um script simples para contar distribuições em uma S-box."
                                  ],
                                  "verification": "Calcule a probabilidade diferencial para uma entrada-saída específica em uma S-box do DES.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Tabela de S-boxes do DES",
                                    "Python ou SageMath para contagem",
                                    "Exemplos de Schneier (1996, Capítulo 7)"
                                  ],
                                  "tips": [
                                    "Comece com S-boxes pequenas (4x4) para prática.",
                                    "Registre probabilidades em uma tabela para visualização."
                                  ],
                                  "learningObjective": "Calcular e interpretar probabilidades em ataques diferenciais.",
                                  "commonMistakes": [
                                    "Contar apenas pares únicos em vez de todos os pares.",
                                    "Multiplicar probabilidades sem considerar independência.",
                                    "Ignorar diferenças de alta probabilidade (ex: 0 ou todas 1s)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação em Cifras de Rodadas como DES",
                                  "subSteps": [
                                    "Analise uma característica diferencial de 14 rodadas para DES (exemplo clássico de Biham e Shamir).",
                                    "Entenda como pares com ΔP específica levam a ΔC previsível após várias rodadas.",
                                    "Discuta recuperação de chaves parciais: quando ΔC=0, a chave de rodada é candidata via XOR.",
                                    "Simule um ataque diferencial em DES reduzido (3-4 rodadas).",
                                    "Avalie limitações: DES foi projetado resistente com S-boxes escolhidas para baixa probabilidade diferencial."
                                  ],
                                  "verification": "Descreva passos para quebrar 3 rodadas de DES usando um par diferencial e liste chaves candidatas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Implementação DES em Python (Crypto library)",
                                    "Paper 'Differential Cryptanalysis of DES-like Cryptosystems' de Biham/Shamir",
                                    "Simulador online de DES reduzido"
                                  ],
                                  "tips": [
                                    "Use muitos pares (2^20+) em simulações para estatística válida.",
                                    "Foque em uma diferença ativa por rodada para simplificar."
                                  ],
                                  "learningObjective": "Aplicar princípios diferenciais para atacar cifras reais como DES.",
                                  "commonMistakes": [
                                    "Aplicar a cifras modernas como AES (resistentes).",
                                    "Subestimar número de pares necessários.",
                                    "Não considerar chaves conhecidas em rodadas finais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma S-box 4x4 simplificada. Para ΔP = 0x3 (0011 em binário), conte pares (in1, in2) onde in1 XOR in2 = 0x3 e out1 XOR out2 = 0x1. Probabilidade = 2/16 = 0.125. Propague isso por 3 rodadas em DES reduzido, gerando 2^47 pares para encontrar chaves candidatas.",
                              "finalVerifications": [
                                "Explique ΔP e ΔC com um exemplo numérico.",
                                "Calcule probabilidade para uma S-box real do DES.",
                                "Descreva uma característica diferencial de 4 rodadas.",
                                "Liste passos para recuperar uma subchave em DES.",
                                "Compare eficácia com força bruta.",
                                "Identifique por que DES é resistente a ataques completos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de pares diferenciais (ΔP, ΔC).",
                                "Correção nos cálculos de probabilidades (erro <5%).",
                                "Qualidade da característica diferencial construída.",
                                "Capacidade de simular ataque em DES reduzido.",
                                "Análise de limitações e contra-medidas.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e estatística para distribuições de diferenças.",
                                "Programação: Implementação de simuladores em Python para contagem de pares.",
                                "Estatística: Análise de amostras grandes para validação probabilística.",
                                "História da Computação: Evolução de cifras e ataques (DES vs AES).",
                                "Segurança da Informação: Implicações em design de criptosistemas modernos."
                              ],
                              "realWorldApplication": "A criptoanálise diferencial é usada para avaliar a segurança de novos cifradores de bloco, como no design do AES (resistente a diferenciais). Profissionais em cibersegurança simulam ataques para certificar algoritmos em protocolos como TLS/SSL, prevenindo brechas em sistemas bancários e comunicações governamentais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Aplicar criptoanálise diferencial ao DES",
                            "description": "Simular um ataque diferencial simplificado no DES, identificando S-boxes vulneráveis e calculando probabilidades de chaves parciais após múltiplas rodadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura do DES e princípios de criptoanálise diferencial",
                                  "subSteps": [
                                    "Estude a estrutura geral do DES: 16 rodadas Feistel, expansão de 32 para 48 bits, S-boxes e P-box.",
                                    "Aprenda diferenças XOR (Δ) e como elas se propagam em funções não-lineares como S-boxes.",
                                    "Identifique características diferenciais: pares (input, output) com alta probabilidade de propagação.",
                                    "Revise probabilidades de S-boxes do DES publicadas por Biham e Shamir.",
                                    "Anote as S-boxes mais vulneráveis (ex: S5 com probabilidade 4/64 para certas diferenças)."
                                  ],
                                  "verification": "Crie um diagrama da estrutura DES com anotações de propagação diferencial e liste 3 pares de entrada/saída para uma S-box.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação DES (FIPS 46-3)",
                                    "Tabelas de S-boxes DES",
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Comece com uma única rodada para simplificar; use XOR em binário para visualizar diferenças.",
                                  "learningObjective": "Compreender como diferenças se comportam no DES e identificar pontos fracos iniciais.",
                                  "commonMistakes": [
                                    "Confundir expansão/permutação com substituição",
                                    "Ignorar alinhamento de bits na propagação",
                                    "Usar probabilidades erradas das S-boxes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar pares de plaintexts e chaves com diferenças controladas",
                                  "subSteps": [
                                    "Escolha uma diferença ΔP inicial de 16 bits (ex: 0x0040 para ativação específica na S-box).",
                                    "Gere pares de plaintexts (P, P') tal que P XOR P' = ΔP.",
                                    "Selecione uma chave parcial ou subchaves para as primeiras rodadas.",
                                    "Prepare estruturas diferenciais: colete muitos pares que sobrevivam a rodadas iniciais.",
                                    "Calcule a probabilidade esperada de sobrevivência para o par escolhido."
                                  ],
                                  "verification": "Liste 10 pares de plaintexts com a mesma ΔP e calcule a probabilidade teórica de propagação na primeira rodada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora binária ou Python para XOR",
                                    "Tabelas de probabilidades diferenciais DES",
                                    "Planilha Excel para rastrear pares"
                                  ],
                                  "tips": "Use diferenças de 2 bits ativos para maximizar probabilidade; teste com código para automação.",
                                  "learningObjective": "Dominar seleção de pares diferenciais otimizados para o DES.",
                                  "commonMistakes": [
                                    "Escolher ΔP com baixa probabilidade",
                                    "Não alinhar diferenças com posições de S-boxes",
                                    "Gerar poucos pares para estatística"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular propagação diferencial através das rodadas do DES",
                                  "subSteps": [
                                    "Implemente a função de rodada DES em código (expansão, XOR com subchave, S-boxes, P-box).",
                                    "Propague Δ através de 3-4 rodadas: calcule Δ após cada S-box para pares sobreviventes.",
                                    "Identifique S-boxes vulneráveis onde Δ output é baixa (ex: prob > 1/64).",
                                    "Filtre pares que não propagam corretamente e conte sobreviventes.",
                                    "Visualize o caminho diferencial com um grafo ou tabela."
                                  ],
                                  "verification": "Execute simulação para 1000 pares e mostre tabela de contagens por rodada, destacando S-boxes com >10% sobrevivência.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python ou SageMath para simulação DES",
                                    "Código fonte DES simplificado",
                                    "Debugger para rastrear bits"
                                  ],
                                  "tips": "Implemente modularmente: função separada para cada rodada; use loops para múltiplos pares.",
                                  "learningObjective": "Simular com precisão a propagação diferencial em múltiplas rodadas.",
                                  "commonMistakes": [
                                    "Erro na implementação de S-boxes",
                                    "Ignorar permutações entre rodadas",
                                    "Sobreestimar sobreviventes sem filtragem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular probabilidades de chaves parciais e avaliar vulnerabilidades",
                                  "subSteps": [
                                    "Para pares finais com Δ conhecido, teste chaves candidatas parciais via S-boxes (2^6 = 64 testes por S-box ativa).",
                                    "Calcule probabilidade de cada chave parcial: #pares corretos / total pares.",
                                    "Agregue probabilidades sobre rodadas para estimar chaves totais.",
                                    "Compare com chaves reais e meça redução de espaço de busca.",
                                    "Documente S-boxes mais vulneráveis e razões (ex: não-linearidade fraca)."
                                  ],
                                  "verification": "Relatório com probabilidades para 3 chaves parciais e identificação de pelo menos 2 S-boxes vulneráveis.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python estendido para teste de chaves",
                                    "Gráficos de probabilidade (Matplotlib)",
                                    "Referências Biham-Shamir"
                                  ],
                                  "tips": "Paralelize testes de chaves; foque em 4 rodadas para viabilidade computacional.",
                                  "learningObjective": "Quantificar efetividade do ataque e isolar fraquezas específicas do DES.",
                                  "commonMistakes": [
                                    "Testar todas 56 bits da chave prematuramente",
                                    "Confundir probabilidade condicional",
                                    "Não normalizar contagens de pares"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um ataque diferencial de 3 rodadas no DES com ΔP = 0x0400 (ativa S1 e S5). Use pares como P=0x00000000, P'=0x00000400. Após filtragem, teste 64 chaves na última S-box ativa: encontre chave correta com probabilidade 14/64 em S5, confirmando vulnerabilidade.",
                              "finalVerifications": [
                                "Simulação produz >5% de pares sobreviventes após 3 rodadas para Δ escolhida.",
                                "Corretamente identifica S5 como vulnerável com prob >10/64 para pelo menos um par diferencial.",
                                "Calcula redução de espaço de chaves de 2^48 para <2^40 em 4 rodadas.",
                                "Código simula rodada DES sem erros em testes unitários.",
                                "Relatório explica propagação com diagramas precisos.",
                                "Probabilidades batem com tabelas conhecidas de literatura."
                              ],
                              "assessmentCriteria": [
                                "Precisão na propagação diferencial (sem erros de bits).",
                                "Eficiência na seleção de pares (alta taxa de sobrevivência).",
                                "Correção nos cálculos probabilísticos (margem <5%).",
                                "Identificação correta de S-boxes vulneráveis com evidências.",
                                "Clareza no relatório e visualizações.",
                                "Criatividade em otimizações ou extensões do ataque."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria das probabilidades e cadeias de Markov para propagação.",
                                "Programação: Implementação de algoritmos criptográficos em Python.",
                                "Estatística: Análise de distribuições de pares e testes de hipótese.",
                                "História da Computação: Evolução de DES para AES.",
                                "Segurança da Informação: Princípios de design criptográfico resistente."
                              ],
                              "realWorldApplication": "Essa habilidade permite avaliar vulnerabilidades em sistemas legados usando DES (ainda em alguns dispositivos IoT antigos), auxiliar na migração para AES, e compreender ataques em competições CTF ou auditorias de segurança, destacando a necessidade de chiffrement resistentes a diferenciais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Analisar resistência do AES à criptoanálise diferencial",
                            "description": "Explicar o design do AES (wide-trail strategy) que resiste a ataques diferenciais, com exemplos de tentativas falhas e complexidade superior a 2^100.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Criptoanálise Diferencial e Estrutura do AES",
                                  "subSteps": [
                                    "Estude a definição de pares diferenciais e probabilidades em criptoanálise diferencial.",
                                    "Revise as rodadas do AES: SubBytes, ShiftRows, MixColumns e AddRoundKey.",
                                    "Identifique pontos fracos potenciais em cifras de bloco como DES para contrastar com AES.",
                                    "Desenhe o fluxo de dados do AES-128, destacando transformações não-lineares.",
                                    "Calcule o número de rodadas do AES (10 para AES-128) e seu tamanho de chave."
                                  ],
                                  "verification": "Crie um diagrama anotado das rodadas do AES e liste 3 pares diferenciais básicos.",
                                  "estimatedTime": "1-1.5 hours",
                                  "materials": [
                                    "Especificação oficial do AES (FIPS 197)",
                                    "Artigo 'Differential Cryptanalysis' de Biham e Shamir",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta"
                                  ],
                                  "tips": [
                                    "Comece com AES-128 para simplicidade antes de generalizar.",
                                    "Use representações em bytes para visualizar diferenças."
                                  ],
                                  "learningObjective": "Compreender os blocos básicos necessários para analisar ataques diferenciais no AES.",
                                  "commonMistakes": [
                                    "Confundir criptoanálise diferencial com linear.",
                                    "Ignorar o papel do MixColumns na difusão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Wide-Trail Strategy no Design do AES",
                                  "subSteps": [
                                    "Explique o conceito de wide-trail: maximizar o número de diferenças ativas em colunas.",
                                    "Analise o MixColumns como transformador linear que espalha diferenças uniformemente.",
                                    "Estude propriedades do SubBytes: alta não-linearidade e resistência a diferenças fixas.",
                                    "Descreva como ShiftRows garante difusão horizontal.",
                                    "Calcule o peso de Hamming mínimo para trilhas diferenciais de 4 rodadas."
                                  ],
                                  "verification": "Escreva uma explicação de 200 palavras sobre como a wide-trail funciona no AES.",
                                  "estimatedTime": "1.5-2 hours",
                                  "materials": [
                                    "Paper 'The Design of Rijndael' de Daemen e Rijmen",
                                    "SageMath ou Python com biblioteca pycryptodome para simulações",
                                    "Tabelas de propriedades diferenciais do S-box do AES"
                                  ],
                                  "tips": [
                                    "Visualize trilhas com matrizes 4x4 representando estados.",
                                    "Foquem em probabilidades condicionais baixas (cerca de 2^-6 por S-box)."
                                  ],
                                  "learningObjective": "Dominar o mecanismo de design wide-trail que confere resistência diferencial ao AES.",
                                  "commonMistakes": [
                                    "Subestimar o impacto do ShiftRows na aleatoriedade.",
                                    "Confundir trilhas ativas com diferenças zero."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Propagação de Diferenças e Resistência em Rodadas Múltiplas",
                                  "subSteps": [
                                    "Simule propagação de uma diferença única através de 2-4 rodadas do AES.",
                                    "Calcule probabilidades de trilhas diferenciais usando tabelas de S-box.",
                                    "Demonstre como a wide-trail garante pelo menos 25 diferenças ativas em 4 rodadas.",
                                    "Compare com cifras fracas: mostre por que DES falha em poucas rodadas.",
                                    "Estime a complexidade de um ataque full-round usando bornes inferiores."
                                  ],
                                  "verification": "Gere um relatório com cálculos de probabilidade para uma trilha específica.",
                                  "estimatedTime": "2-2.5 hours",
                                  "materials": [
                                    "Script Python para simulação diferencial (ex: usar Crypto library)",
                                    "Tabelas de diferenças diferenciais do AES (disponíveis online)",
                                    "Calculadora ou software como Mathematica para probabilidades"
                                  ],
                                  "tips": [
                                    "Use diferenças de entrada com peso baixo para otimizar simulações.",
                                    "Registre probabilidades em log2 para facilitar comparações."
                                  ],
                                  "learningObjective": "Aplicar análise quantitativa para provar alta complexidade de ataques diferenciais.",
                                  "commonMistakes": [
                                    "Esquecer chaves round adicionadas que truncam diferenças.",
                                    "Overestimar probabilidades ignorando condições wide-trail."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Exemplos de Ataques Falhos e Complexidade Superior a 2^100",
                                  "subSteps": [
                                    "Revise ataques diferenciais conhecidos no AES reduzido (ex: 4-6 rodadas).",
                                    "Analise por que falham em full AES: complexidade > 2^100 para AES-128.",
                                    "Discuta truncados vs. full differentials e limites teóricos.",
                                    "Calcule bornes: Nr * log2(1/p) onde p é probabilidade por rodada.",
                                    "Debata melhorias em ataques (ex: rebound attacks) e por que ainda ineficazes."
                                  ],
                                  "verification": "Apresente 2 exemplos de ataques falhos com cálculos de complexidade.",
                                  "estimatedTime": "1.5-2 hours",
                                  "materials": [
                                    "Papers como 'New Differential Attacks on AES' de Grassi et al.",
                                    "Base de dados de ataques em ciphers (ePrint archive)",
                                    "Ferramenta MILP solver para otimização de trilhas (opcional)"
                                  ],
                                  "tips": [
                                    "Compare complexidades com 2^128 (segurança full).",
                                    "Foque em ataques práticos vs. teóricos."
                                  ],
                                  "learningObjective": "Avaliar evidências empíricas e teóricas da resistência do AES a diferenciais.",
                                  "commonMistakes": [
                                    "Confundir ataques em AES reduzido com full-round.",
                                    "Ignorar overhead computacional real."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um script Python usando a biblioteca cryptography para simular 1000 pares diferenciais em 4 rodadas do AES, meça a probabilidade observada de saída não-zero e compare com o borne teórico da wide-trail (esperado ~2^-99), confirmando resistência.",
                              "finalVerifications": [
                                "Explicar verbalmente a wide-trail strategy em 2 minutos.",
                                "Calcular corretamente a complexidade mínima de um ataque diferencial full-round no AES-128.",
                                "Identificar 3 componentes do AES que contribuem para resistência diferencial.",
                                "Simular uma trilha diferencial curta e prever sua probabilidade.",
                                "Discutir por que ataques em AES reduzido não escalam para full.",
                                "Comparar resistência do AES com DES em termos de rodadas necessárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da wide-trail e suas propriedades matemáticas (30%).",
                                "Correção nos cálculos de probabilidades e complexidades (25%).",
                                "Profundidade na análise de exemplos de ataques falhos (20%).",
                                "Clareza em diagramas e simulações práticas (15%).",
                                "Integração de conceitos teóricos com evidências empíricas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para análise de MixColumns e matrizes de difusão.",
                                "Computação: Programação para simulações de criptoanálise em Python/SageMath.",
                                "Estatística: Probabilidades e distribuições em trilhas diferenciais.",
                                "Engenharia: Design de sistemas seguros resistentes a falhas adversariais.",
                                "Física: Analogias com difusão de partículas em redes."
                              ],
                              "realWorldApplication": "Em protocolos como HTTPS/TLS e VPNs, a resistência diferencial do AES garante que dados sensíveis (ex: transações bancárias) permaneçam seguros contra ataques de chosen-plaintext em cenários reais de rede, previnendo vazamentos mesmo com poder computacional massivo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Criptoanálise Linear",
                        "description": "Técnica que aproxima operações não-lineares (como S-boxes) por expressões lineares sobre GF(2), aplicada para recuperar chaves em DES e AES.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Compreender os fundamentos da criptoanálise linear",
                            "description": "Definir máscaras de entrada/saída, bias probabilístico e trilhas lineares, com exemplos em cifras de blocos simétricos conforme Paar & Pelzl (2010).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender máscaras de entrada e saída em criptoanálise linear",
                                  "subSteps": [
                                    "Estude a representação binária de entradas e saídas em S-boxes de cifras de blocos.",
                                    "Aprenda a definir uma máscara de entrada como um vetor de bits que seleciona paridades lineares.",
                                    "Identifique máscaras de saída correspondentes para formar aproximações lineares.",
                                    "Pratique notação XOR para expressar relações lineares: Γ_in ⊕ Γ_out ≈ S-box input.",
                                    "Revise exemplos básicos de máscaras em cifras como DES (conforme Paar & Pelzl, 2010)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que são máscaras e forneça um exemplo com 16 bits.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Understanding Cryptography' de Paar & Pelzl (2010), Capítulo relevante",
                                    "Bloco de notas para cálculos binários",
                                    "Ferramenta online de conversor binário/hex"
                                  ],
                                  "tips": [
                                    "Comece com S-boxes pequenas (4x4) para visualizar máscaras facilmente.",
                                    "Use tabelas para listar todas as combinações possíveis de máscaras."
                                  ],
                                  "learningObjective": "Definir e representar máscaras de entrada/saída para aproximações lineares em S-boxes.",
                                  "commonMistakes": [
                                    "Confundir máscara com chave de cifra.",
                                    "Ignorar o papel do XOR na paridade linear.",
                                    "Usar máscaras não-binárias (decimal)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o bias probabilístico em aproximações lineares",
                                  "subSteps": [
                                    "Defina bias como |Pr[Γ_in ⊕ Γ_out = S(input)] - 1/2| para uma aproximação linear.",
                                    "Calcule probabilidades exatas contando ocorrências em tabelas de S-box.",
                                    "Compare biases zero (linearidade perfeita) vs. non-zero (aproximação útil).",
                                    "Pratique cálculo de bias para múltiplas máscaras em uma S-box exemplo.",
                                    "Analise como biases são tabulados em cifras conhecidas (ex: DES S-boxes)."
                                  ],
                                  "verification": "Calcule o bias de uma máscara específica em uma S-box fornecida e justifique o resultado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou Python para contar probabilidades",
                                    "Tabelas de S-boxes de DES (Paar & Pelzl, 2010)",
                                    "Calculadora para frações"
                                  ],
                                  "tips": [
                                    "Automatize contagens com scripts simples para S-boxes grandes.",
                                    "Lembre-se: bias é absoluto para indicar força da aproximação."
                                  ],
                                  "learningObjective": "Calcular e interpretar o bias probabilístico de uma aproximação linear.",
                                  "commonMistakes": [
                                    "Calcular probabilidade ao invés de bias.",
                                    "Esquecer de subtrair 1/2 ou tomar valor absoluto.",
                                    "Confundir bias com probabilidade bruta."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e analisar trilhas lineares",
                                  "subSteps": [
                                    "Defina uma trilha linear como sequência de aproximações lineares ao longo de rodadas de cifra.",
                                    "Aprenda a propagar máscaras através de operações de cifra (addRoundKey, SubBytes, ShiftRows, MixColumns em AES-like).",
                                    "Combine biases de trilhas multiplicando probabilidades (aproximação logarítmica para bias total).",
                                    "Identifique trilhas de alta probabilidade buscando biases não-zero consecutivos.",
                                    "Desenhe diagramas de trilhas para uma cifra de 2-3 rodadas."
                                  ],
                                  "verification": "Construa uma trilha linear simples de 2 rodadas e calcule seu bias total.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Papel e lápis para diagramas de trilhas",
                                    "Software SageMath ou Python crypto libs",
                                    "Exemplos do livro Paar & Pelzl (2010)"
                                  ],
                                  "tips": [
                                    "Use log(2* bias) para somar biases em trilhas longas.",
                                    "Foque em trilhas de input/output para ataques práticos."
                                  ],
                                  "learningObjective": "Construir trilhas lineares e estimar seu bias agregado em cifras de blocos.",
                                  "commonMistakes": [
                                    "Não propagar máscaras corretamente em MixColumns.",
                                    "Somar biases ao invés de multiplicar probabilidades.",
                                    "Ignorar dependências entre rodadas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos em exemplos de cifras de blocos simétricos",
                                  "subSteps": [
                                    "Estude o ataque linear clássico em DES (Matsui's L0/L1, Paar & Pelzl).",
                                    "Analise biases em S-boxes de DES e construa trilhas conhecidas.",
                                    "Simule uma cifra toy (ex: SPECK ou Reduced-Round AES) para prática.",
                                    "Compare com cifras modernas resistentes (AES com biases mínimos).",
                                    "Discuta limitações e defesas contra criptoanálise linear."
                                  ],
                                  "verification": "Descreva uma trilha linear em DES e explique por que ela é efetiva.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Implementação DES em Python (disponível online)",
                                    "Artigo de Matsui (1993) ou Capítulo Paar & Pelzl",
                                    "Ferramentas de simulação crypto como Crypto101"
                                  ],
                                  "tips": [
                                    "Use cifras reduzidas para experimentos factíveis em computador pessoal.",
                                    "Verifique biases com brute-force em implementações."
                                  ],
                                  "learningObjective": "Aplicar fundamentos da criptoanálise linear a cifras reais como DES.",
                                  "commonMistakes": [
                                    "Aplicar DES diretamente sem entender diferenças com AES.",
                                    "Superestimar biases em cifras modernas.",
                                    "Confundir teoria com implementação prática."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma S-box 4x4 simplificada (ex: saída para input 00=11, 01=00, etc.), máscara entrada 11 (paridade dos 2 bits), saída 10. Conte ocorrências: 3/4 vezes igual, bias = |0.75 - 0.5| = 0.25. Estenda para trilha de 2 rodadas em cifra toy propagando máscaras.",
                              "finalVerifications": [
                                "Defina corretamente máscaras de entrada/saída com exemplo binário.",
                                "Calcule bias de uma aproximação linear em S-box com precisão.",
                                "Construa uma trilha linear de 2 rodadas e estime bias total.",
                                "Explique aplicação em DES conforme Paar & Pelzl (2010).",
                                "Identifique por que AES é mais resistente que DES a ataques lineares.",
                                "Liste 3 limitações da criptoanálise linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de máscaras, bias e trilhas (90% correto).",
                                "Correção matemática em cálculos de bias e propagação (sem erros aritméticos).",
                                "Profundidade nos exemplos com cifras de blocos (referência a Paar & Pelzl).",
                                "Capacidade de diagramar trilhas lineares claramente.",
                                "Compreensão de implicações práticas e defesas.",
                                "Criatividade em estender conceitos a cenários novos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e estatística para biases.",
                                "Álgebra Linear: Espaços vetoriais sobre GF(2).",
                                "Segurança da Informação: Análise de vulnerabilidades criptográficas.",
                                "Programação: Implementação de simulações em Python/SageMath.",
                                "Física: Analogias com interferência quântica em cripto quântica."
                              ],
                              "realWorldApplication": "Avaliar segurança de protocolos como TLS/SSL contra ataques lineares em cifras simétricas; designers de cripto usam para criar S-boxes com biases mínimos, essencial em banking, VPNs e proteção de dados governamentais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Executar um ataque linear no DES",
                            "description": "Construir uma aproximação linear para 14 rodadas do DES, calculando o bias e estimando chaves candidatas usando pares de textos conhecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Aproximações Lineares nas S-boxes do DES",
                                  "subSteps": [
                                    "Estude a estrutura das 8 S-boxes do DES e suas propriedades lineares.",
                                    "Identifique máscaras lineares com alto bias para cada S-box usando tabelas pré-computadas.",
                                    "Selecione aproximações lineares ótimas para as S-boxes envolvidas em ataques lineares conhecidos.",
                                    "Calcule o bias individual para cada aproximação linear selecionada.",
                                    "Documente as máscaras de entrada, saída e o bias para pelo menos 4 S-boxes chave."
                                  ],
                                  "verification": "Lista completa de aproximações lineares com biases calculados corretamente, comparada com referências padrão.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Documentação DES (FIPS 46-3), tabelas de bias lineares (Handbook of Applied Cryptography), calculadora ou Python para tabelas.",
                                  "tips": "Comece com S-box 1 e S-box 6, que têm as melhores aproximações.",
                                  "learningObjective": "Dominar a análise linear das S-boxes do DES para construir aproximações compostas.",
                                  "commonMistakes": "Confundir máscaras de paridade com XOR direto; ignorar o bias de 0.5 como neutro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Aproximação Linear para 14 Rodadas do DES",
                                  "subSteps": [
                                    "Revise a estrutura de rodada do DES: expansão, S-boxes, P-box e XOR com subchave.",
                                    "Una aproximações lineares das S-boxes através das P-boxes para formar uma cadeia de 14 rodadas.",
                                    "Aplique a propriedade de linearidade da expansão e P-box para propagar máscaras.",
                                    "Derive as máscaras lineares para plaintext, ciphertext e chaves parciais.",
                                    "Valide a aproximação usando diagramas de ronda conhecidos (ex: Matsui's L2)."
                                  ],
                                  "verification": "Diagrama completo da aproximação linear com máscaras corretas para P, C e K, bias composto calculável.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Diagramas de ataque linear DES (papers de Mitsuru Matsui), software de desenho (Draw.io), implementações DES em Python.",
                                  "tips": "Use notação Γ para máscaras e siga convenções de paridade ímpar.",
                                  "learningObjective": "Construir uma aproximação linear multi-rodada válida para DES.",
                                  "commonMistakes": "Erro na propagação através da P-box; esquecer XOR com subchave afeta linearidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Bias e Planejar Coleta de Pares",
                                  "subSteps": [
                                    "Multiplique biases individuais das S-boxes para estimar o bias composto da aproximação.",
                                    "Use a fórmula de Matsui: número de pares necessários ≈ 2 / bias² para confiança de 90%.",
                                    "Gere ou colete 2^20 a 2^43 pares plaintext-ciphertext conhecidos.",
                                    "Implemente função para computar o lado esquerdo da equação linear para cada par.",
                                    "Estruture dados para análise estatística (contadores de 0 e 1)."
                                  ],
                                  "verification": "Bias composto calculado (ex: ~2^-26) e plano de pares com estimativa de dados necessários.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy/Pandas, gerador de pares DES (pycryptodome), paper de Matsui 1994.",
                                  "tips": "Logaritme o bias para facilitar multiplicações.",
                                  "learningObjective": "Quantificar a viabilidade do ataque via bias e requisitos de dados.",
                                  "commonMistakes": "Subestimar bias devido a aproximações fracas; não considerar ruído aleatório."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar o Ataque e Estimar Chaves Candidatas",
                                  "subSteps": [
                                    "Compute o lado esquerdo (P XOR C) e lado direito (aproximação de subchaves) para todos os pares.",
                                    "Para cada bit de chave candidato, conte desvios e selecione o com maior |contador|.",
                                    "Estime subchaves parciais iterativamente, testando combinações prováveis.",
                                    "Recupere a chave completa testando candidatos em um par de verificação.",
                                    "Avalie taxa de sucesso com múltiplas execuções."
                                  ],
                                  "verification": "Chave correta recuperada com pares suficientes; ranking de candidatos mostra top-1 correto.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Script Python completo para ataque linear DES, máquina com >16GB RAM para grandes datasets.",
                                  "tips": "Otimize com contadores de 64-bit; processe em lotes para eficiência.",
                                  "learningObjective": "Implementar e executar um ataque linear prático no DES.",
                                  "commonMistakes": "Overflow em contadores; não normalizar pela expectativa de 0.5."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Analisar Resultados do Ataque",
                                  "subSteps": [
                                    "Teste todas chaves candidatas em um conjunto de validação separado.",
                                    "Meça precisão: % de bits corretos, chaves top-50 contendo a correta.",
                                    "Compare bias empírico vs teórico.",
                                    "Analise impacto de ruído e otimize aproximação se necessário.",
                                    "Documente lições e limitações (ex: DES-56 bits viável, AES não)."
                                  ],
                                  "verification": "Relatório com métricas: sucesso >95% com 2^43 pares, análise estatística.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Conjunto de teste plaintext-ciphertext, ferramentas de profiling Python.",
                                  "tips": "Use testes estatísticos (chi-quadrado) para validar desvios.",
                                  "learningObjective": "Avaliar robustez do ataque e interpretar resultados criptoanalíticos.",
                                  "commonMistakes": "Overfitting a um par; ignorar dependências entre subchaves."
                                }
                              ],
                              "practicalExample": "Usando a aproximação linear L2 de Matsui para 14 rodadas: máscara P=0x00400082, C=0x00800800, K14=0x00010010 (bias ~2^-26). Com 2^43 pares conhecidos, conte para cada bit de K14: se mais pares satisfazem P·mask_P + C·mask_C = K14·mask_K, selecione 0 ou 1 baseado no desvio máximo. Recupere K14 corretamente em 99% dos casos, propagando para chave cheia.",
                              "finalVerifications": [
                                "Aproximação linear para 14 rodadas produz bias teórico próximo de 2^-26.",
                                "Ataque recupera pelo menos 47/56 bits da chave com 2^43 pares.",
                                "Implementação computa corretamente contadores para todos candidatos de subchave.",
                                "Teste em validação confirma chave correta no top-1 ou top-4.",
                                "Análise empírica alinha com teoria (desvio ~bias * N^{1/2}).",
                                "Código roda eficientemente sem erros de overflow."
                              ],
                              "assessmentCriteria": [
                                "Precisão do bias composto (±10% do valor padrão).",
                                "Número de pares necessários ≤ 2^44 para sucesso >90%.",
                                "Correção das máscaras lineares (match com Matsui).",
                                "Eficiência da implementação (tempo <24h em hardware padrão).",
                                "Qualidade da documentação e análise de erros.",
                                "Sucesso na recuperação da chave em simulações múltiplas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear sobre GF(2), teoria da probabilidade e desvios.",
                                "Estatística: Testes de hipótese, distribuição binomial para biases.",
                                "Programação: Otimização de algoritmos, manipulação de big data com NumPy.",
                                "Segurança da Informação: Avaliação de vulnerabilidades em cifras.",
                                "Física Computacional: Modelagem de sistemas complexos via aproximações."
                              ],
                              "realWorldApplication": "Em avaliações de segurança de sistemas legados usando DES (ex: smart cards antigos, protocolos obsoletos); treinamento de analistas em agências como NSA para quebrar cifras fracas; compreensão de porquê AES substituiu DES, auxiliando design de criptosistemas resistentes a linear cryptanalysis."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Avaliar a segurança do AES contra ataques lineares",
                            "description": "Discutir ataques lineares reduzidos no AES (ex.: 6 rodadas) e por que o design completo resiste com margens de segurança amplas (Menezes, 1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Ataques Lineares no AES",
                                  "subSteps": [
                                    "Estude a definição de aproximações lineares e máscaras lineares no contexto de cifras de substituição-permutação como o AES.",
                                    "Revise a estrutura do AES: rodadas, SubBytes, ShiftRows, MixColumns e AddRoundKey.",
                                    "Aprenda a calcular a probabilidade de uma aproximação linear ativa usando o teorema de Matsui.",
                                    "Identifique máscaras lineares comuns para S-box do AES e operações lineares (ShiftRows e MixColumns).",
                                    "Pratique derivando uma aproximação linear trivial para uma única S-box."
                                  ],
                                  "verification": "Crie um diagrama de uma aproximação linear de 1 rodada do AES e calcule sua probabilidade (deve ser próxima de 2^{-2}).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Handbook of Applied Cryptography (Menezes et al., Capítulo 7)",
                                    "Documentação oficial do AES (FIPS 197)",
                                    "Ferramenta online como Crypto101 ou SageMath para simulações"
                                  ],
                                  "tips": "Use diagramas visuais para representar máscaras binárias; foque em probabilidades não-zero.",
                                  "learningObjective": "Explicar como ataques lineares exploram correlações lineares entre entrada e saída do AES.",
                                  "commonMistakes": [
                                    "Confundir ataques lineares com diferenciais",
                                    "Ignorar o impacto do MixColumns na linearidade",
                                    "Assumir probabilidades uniformes para S-box"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Ataques Lineares em Versões Reduzidas do AES",
                                  "subSteps": [
                                    "Pesquise ataques lineares em AES-4 e AES-6: leia papers como o de Leurent (2009) para AES-6 com 2^{39} textos conhecidos.",
                                    "Construa uma trilha linear iterativa para 4 rodadas, identificando aproximações de alta probabilidade.",
                                    "Estenda para 6 rodadas reduzidas, calculando a complexidade total do ataque (chaves parciais e textos conhecidos).",
                                    "Compare com birthday bound: verifique por que AES-6 é 'quebrado' mas ainda impraticável.",
                                    "Implemente uma busca simples de máscaras lineares usando código Python ou Sage."
                                  ],
                                  "verification": "Descreva um ataque linear em AES-6, incluindo número de rodadas, textos conhecidos e chaves parciais (deve citar complexidade ~2^{40}).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Paper 'Improved Linear Attacks on AES' (Leurent, 2009)",
                                    "Implementação em Python da biblioteca Cryptodome ou SageMath",
                                    "Tabelas de máscaras lineares do AES (disponíveis em tutoriais de criptoanálise)"
                                  ],
                                  "tips": "Comece com AES-4 para ganhar confiança antes de AES-6; use logaritmos para lidar com probabilidades pequenas.",
                                  "learningObjective": "Identificar e quantificar ataques lineares viáveis em AES com rodadas reduzidas.",
                                  "commonMistakes": [
                                    "Superestimar probabilidades sem considerar bias acumulado",
                                    "Esquecer chaves parciais nas rodadas iniciais/finais",
                                    "Não normalizar pela birthday paradox"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o Design do AES e Margens de Segurança",
                                  "subSteps": [
                                    "Estude a estratégia Wide-Trail do Rijndael: como MixColumns e ShiftRows difundem linearidade.",
                                    "Calcule margens de segurança: AES-128 tem 10 rodadas, ataques cobrem ≤7-8, margem de 2-3 rodadas.",
                                    "Analise propriedades das S-box: máxima probabilidade linear ~2^{-2.1}, não ótima para linear.",
                                    "Discuta o papel do round key AddRoundKey em quebrar trilhas lineares.",
                                    "Compare com referências: Menezes (1996) discute margens amplas contra lineares."
                                  ],
                                  "verification": "Explique por que uma trilha linear de 8 rodadas falha no AES-128 completo (margem insuficiente para probabilidade >2^{-128}).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "AES Proposal (Daemen & Rijmen, 1999)",
                                    "Handbook of Applied Cryptography (Seção 7.6)",
                                    "Ferramentas de visualização como AES Animator online"
                                  ],
                                  "tips": "Pense em termos de 'segurança por rodadas extras'; memorize margens: AES-128/192/256 têm 10/12/14 rodadas.",
                                  "learningObjective": "Demonstrar como o design do AES proporciona margens contra extensões de ataques lineares.",
                                  "commonMistakes": [
                                    "Ignorar difusão do MixColumns",
                                    "Confundir margens com rodadas totais",
                                    "Assumir S-box linearmente perfeita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Concluir a Resistência do AES Completo",
                                  "subSteps": [
                                    "Sintetize: compare complexidades de ataques lineares vs. exaustivo (2^{128} para AES-128).",
                                    "Discuta avanços recentes: ataques em 9 rodadas? Ainda longe do prático.",
                                    "Avalie impacto: AES permanece padrão NIST apesar de ataques teóricos.",
                                    "Debata futuro: quantum threats (Grover) vs. lineares clássicos.",
                                    "Escreva um relatório resumindo segurança linear do AES."
                                  ],
                                  "verification": "Argumente convincentemente por que AES resiste a ataques lineares no mundo real (margens >2 rodadas, complexidade >>2^{100}).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NIST Report on AES (2000)",
                                    "Recent survey papers on AES cryptanalysis (Eurocrypt proceedings)",
                                    "Ferramenta de escrita como Overleaf para relatório"
                                  ],
                                  "tips": "Use métricas quantitativas (data/time complexity) para apoiar conclusões.",
                                  "learningObjective": "Avaliar holisticamente a segurança do AES contra criptoanálise linear.",
                                  "commonMistakes": [
                                    "Exagerar ameaças de ataques reduzidos",
                                    "Ignorar trade-offs práticos (memória, tempo)",
                                    "Não considerar evoluções pós-2000"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um ataque linear em AES-4 usando SageMath: derive máscaras para SubBytes e MixColumns, calcule probabilidade de 2^{-16}, e estenda iterativamente para ver por que falha em 10 rodadas devido a bias <2^{-128}.",
                              "finalVerifications": [
                                "Explicar uma aproximação linear ativa no AES com probabilidade exata.",
                                "Descrever ataque em AES-6 com complexidades precisas.",
                                "Calcular margem de segurança para AES-128 contra lineares.",
                                "Comparar AES com DES em resistência linear.",
                                "Discutir por que AES não foi enfraquecido apesar de ataques teóricos.",
                                "Identificar limitações de ataques lineares em hardware real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de máscaras e probabilidades lineares (80%+ correto).",
                                "Compreensão quantitativa de complexidades de ataque vs. exaustivo.",
                                "Análise correta das margens de segurança do design AES.",
                                "Uso apropriado de referências (Menezes, Daemen).",
                                "Capacidade de sintetizar em avaliação geral de segurança.",
                                "Clareza em diagramas ou simulações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear sobre GF(2^8) e equações lineares.",
                                "Física: Analogia com interferência quântica em superposição linear.",
                                "Engenharia de Software: Implementação segura de AES em bibliotecas como OpenSSL.",
                                "Ética em TI: Implicações de fraquezas criptográficas em privacidade digital.",
                                "Estatística: Cálculo de bias e testes de significância em probabilidades."
                              ],
                              "realWorldApplication": "Avaliar AES em protocolos como TLS/HTTPS (protege 90% do tráfego web); entender resistência linear assegura confiança em sistemas bancários, VPNs e blockchain, prevenindo breaches como o Heartbleed onde AES permaneceu intacto."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Comparar ataques diferencial e linear",
                            "description": "Comparar eficiência, requisitos de dados e complexidade entre criptoanálises diferencial e linear em contextos de DES e AES.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Criptoanálise Diferencial",
                                  "subSteps": [
                                    "Estude a definição e história da criptoanálise diferencial, focando em DES.",
                                    "Aprenda sobre pares de entrada-saída diferenciais e probabilidades de diferença.",
                                    "Analise os requisitos de dados: número de pares plaintext-ciphertext necessários.",
                                    "Examine a complexidade computacional e eficiência em ataques a rodadas reduzidas de DES.",
                                    "Identifique limitações práticas em implementações reais."
                                  ],
                                  "verification": "Resuma em um diagrama os passos de um ataque diferencial básico em DES e calcule uma probabilidade de diferencial ativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação oficial do DES (NIST FIPS 46-3)",
                                    "Artigo seminal de Biham e Shamir sobre diferencial",
                                    "Ferramenta SageMath ou Python com pycryptodome"
                                  ],
                                  "tips": "Use tabelas S-box do DES para mapear diferenças; foque em probabilidades > 2^-6 para diferenciais viáveis.",
                                  "learningObjective": "Compreender os princípios probabilísticos e requisitos de dados da criptoanálise diferencial.",
                                  "commonMistakes": [
                                    "Confundir diferenças XOR com adição modular",
                                    "Ignorar iterações de rodadas e propagação de probabilidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Fundamentos da Criptoanálise Linear",
                                  "subSteps": [
                                    "Defina criptoanálise linear e sua aplicação inicial em DES por Matsui.",
                                    "Estude aproximações lineares: máscaras de entrada, saída e chaves com probabilidades de bias.",
                                    "Calcule requisitos de dados baseados na equação de Matsui (cerca de 2^43 pares para DES full).",
                                    "Analise complexidade: tempo de ataque via algoritmo LFSR ou Guess-and-Determine.",
                                    "Compare com diferencial em termos de cobertura de S-boxes."
                                  ],
                                  "verification": "Construa uma aproximação linear de alta probabilidade para uma S-box do DES e estime o bias.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo de Mitsuru Matsui (1993)",
                                    "Implementação em Python de análise linear",
                                    "Ferramentas como CryptoMiniSat para resolução de equações"
                                  ],
                                  "tips": "Represente aproximações como XOR de bits par/impar; priorize biases próximos de 2^-2.",
                                  "learningObjective": "Dominar aproximações lineares e métricas de viabilidade para ataques lineares.",
                                  "commonMistakes": [
                                    "Confundir bias com probabilidade absoluta",
                                    "Subestimar overhead de correlação em múltiplas aproximações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Métricas Gerais: Eficiência, Dados e Complexidade",
                                  "subSteps": [
                                    "Tabule eficiência: sucesso rate vs. custo computacional para ambos ataques.",
                                    "Compare requisitos de dados: diferencial tipicamente 2^47 pares para DES vs. 2^43 para linear.",
                                    "Avalie complexidade temporal: diferencial O(2^47) vs. linear O(2^43) para DES.",
                                    "Discuta trade-offs: diferencial mais intuitivo, linear mais eficiente em alguns cenários.",
                                    "Crie uma tabela comparativa quantitativa."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com valores exatos para DES e justifique com referências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas comparativas de ataques (Livro 'Handbook of Applied Cryptography')",
                                    "Planilha Excel ou Jupyter Notebook"
                                  ],
                                  "tips": "Use notação big-O para complexidade; normalize por rodadas atacadas.",
                                  "learningObjective": "Quantificar e contrastar as três métricas principais entre os ataques.",
                                  "commonMistakes": [
                                    "Comparar apenas DES sem generalizar",
                                    "Ignorar avanços como linear-diferencial híbrido"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação a DES e AES",
                                  "subSteps": [
                                    "Para DES: detalhe ataque diferencial Biham-Shamir (14 rodadas) vs. linear Matsui (full 16 rodadas).",
                                    "Para AES: discuta diferencial em 4-6 rodadas vs. linear em 6-8 rodadas (S-boxes resistentes).",
                                    "Compare por cifrador: dados necessários (AES dif ~2^40 vs. lin ~2^45 para reduzido).",
                                    "Avalie por que AES resiste melhor: estrutura SPN vs. Feistel.",
                                    "Simule um mini-ataque em código para ambos."
                                  ],
                                  "verification": "Execute simulação em Python mostrando quebra de 2 rodadas DES/AES e compare workloads.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código fonte para mini-DES/AES em Python",
                                    "Referências AES (FIPS 197)",
                                    "Ambiente Jupyter com bibliotecas crypto"
                                  ],
                                  "tips": "Comece com rodadas reduzidas; use profiling para medir complexidade real.",
                                  "learningObjective": "Aplicar comparações concretas aos cifradores simétricos padrão.",
                                  "commonMistakes": [
                                    "Generalizar DES para AES sem notar diferenças em S-boxes",
                                    "Omitir impacto de chaves derivadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python um ataque diferencial em 2 rodadas de mini-DES (requer ~1000 pares) vs. linear (requer ~500 pares com bias 0.1), meça tempo de execução e dados usados, plotando eficiência em gráfico.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças em probabilidades diferenciais vs. biases lineares.",
                                "Preencher tabela comparativa precisa para DES full-round.",
                                "Simular e relatar resultados de ataque reduzido em AES.",
                                "Identificar por que linear foi mais prático para quebrar DES primeiro.",
                                "Discutir limitações em hardware moderno (ex: custo energético).",
                                "Comparar com ataques modernos como biclique."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa nas métricas (dados, tempo, probabilidade): 30%",
                                "Profundidade na análise DES/AES específica: 25%",
                                "Clareza na tabela/diagrama comparativo: 20%",
                                "Validade da simulação prática: 15%",
                                "Identificação de trade-offs e limitações: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e estatística (distribuições XOR, testes de chi-quadrado para bias)",
                                "Algoritmos: Complexidade computacional e otimização (LFSR, SAT solvers)",
                                "Segurança da Informação: Avaliação de riscos em cifradores",
                                "Física/Engenharia: Impacto em hardware criptográfico (side-channels)"
                              ],
                              "realWorldApplication": "Avaliar vulnerabilidades em protocolos legados como SSL/TLS com DES; projetar cifradores resistentes como AES-256; consultoria em auditorias de segurança para bancos e governos, prevenindo quebras por supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Criptosistemas com Chave Pública",
                "description": "Análise de criptosistemas assimétricos que empregam pares de chaves pública e privada, como RSA e ECC.",
                "totalSkills": 50,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Criptografia Assimétrica",
                    "description": "Conceitos fundamentais de criptosistemas que utilizam pares de chaves pública e privada para encriptação e decriptação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Par de Chaves Pública e Privada",
                        "description": "Conceito central da criptografia assimétrica, onde cada usuário possui um par de chaves matemáticamente relacionadas: a chave pública é compartilhada abertamente e a chave privada é mantida em segredo absoluto.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir Chave Pública",
                            "description": "Explicar que a chave pública é usada para encriptar mensagens ou verificar assinaturas digitais, sendo distribuída livremente sem comprometer a segurança do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Criptografia Assimétrica Básica",
                                  "subSteps": [
                                    "Pesquisar a diferença entre criptografia simétrica e assimétrica.",
                                    "Identificar problemas da simétrica, como troca segura de chaves.",
                                    "Explicar o conceito de par de chaves (pública e privada).",
                                    "Visualizar analogia: caixa forte com duas chaves diferentes.",
                                    "Anotar vantagens da assimétrica em um resumo curto."
                                  ],
                                  "verification": "Escrever um parágrafo comparando simétrica e assimétrica, destacando o papel do par de chaves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet para artigos sobre criptografia",
                                    "Vídeo introdutório (ex: Khan Academy Criptografia)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas como 'cadeado aberto' para chave pública para fixar o conceito.",
                                  "learningObjective": "Diferenciar criptografia simétrica de assimétrica e entender a base do par de chaves.",
                                  "commonMistakes": [
                                    "Confundir chave pública com senha compartilhada",
                                    "Ignorar o problema de distribuição de chaves na simétrica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Gerar Conceitualmente a Chave Pública",
                                  "subSteps": [
                                    "Estudar algoritmos comuns como RSA: chave pública como (n, e).",
                                    "Explicar que a chave pública deriva da privada via funções matemáticas unidirecionais.",
                                    "Simular geração: escolher primos p e q, calcular n = p*q.",
                                    "Entender que a pública é o módulo e expoente público.",
                                    "Documentar passos matemáticos em pseudocódigo."
                                  ],
                                  "verification": "Gerar um exemplo numérico simples de chave pública (com números pequenos) e explicar cada parâmetro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou ferramenta online para fatoração (ex: Wolfram Alpha)",
                                    "Documentação RSA básica",
                                    "Papel e caneta para cálculos"
                                  ],
                                  "tips": "Comece com números pequenos (p=3, q=5) para evitar erros de cálculo.",
                                  "learningObjective": "Definir tecnicamente a chave pública e seu processo de geração.",
                                  "commonMistakes": [
                                    "Revelar a privada ao calcular a pública",
                                    "Confundir módulo n com expoente e"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Usos da Chave Pública",
                                  "subSteps": [
                                    "Descrever encriptação: receptor usa pública do remetente para encriptar.",
                                    "Explicar verificação de assinaturas: remetente assina com privada, receptor verifica com pública.",
                                    "Diferenciar: encriptação protege confidencialidade, assinatura garante autenticidade.",
                                    "Simular fluxo: diagrama de mensagem encriptada e assinada.",
                                    "Listar protocolos que usam (ex: PGP, SSH)."
                                  ],
                                  "verification": "Criar um diagrama de fluxo mostrando encriptação e verificação de assinatura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (ex: Draw.io ou papel)",
                                    "Exemplos de fluxos PGP online"
                                  ],
                                  "tips": "Pense em 'qualquer um encripta, só dono descripta' para fixar.",
                                  "learningObjective": "Identificar e diferenciar os dois usos principais da chave pública.",
                                  "commonMistakes": [
                                    "Invertar papéis: usar pública para descriptar",
                                    "Confundir encriptação com assinatura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Segurança e Distribuição da Chave Pública",
                                  "subSteps": [
                                    "Explicar segurança: baseada em problemas difíceis (fatoração, log discreto).",
                                    "Discutir distribuição: publicar em diretórios públicos sem risco.",
                                    "Abordar ataques: por que fatorar n é computacionalmente caro.",
                                    "Estudar revogação e certificados (CA).",
                                    "Debater mitos: 'pública não é secreta, mas segura'."
                                  ],
                                  "verification": "Escrever uma justificativa de 5 frases sobre por que distribuir a pública é seguro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos sobre RSA e segurança",
                                    "Vídeo sobre ataques quânticos (opcional)"
                                  ],
                                  "tips": "Compare com telefone: número público, conversa privada.",
                                  "learningObjective": "Compreender por que a chave pública pode ser distribuída livremente.",
                                  "commonMistakes": [
                                    "Achar que pública precisa ser secreta",
                                    "Subestimar complexidade matemática"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao enviar um email confidencial via PGP: obtenha a chave pública do destinatário de um keyserver, use-a para encriptar a mensagem no cliente de email (ex: Thunderbird com Enigmail), envie livremente pela internet; só a chave privada do destinatário descripta.",
                              "finalVerifications": [
                                "Definir chave pública em suas palavras, incluindo componentes matemáticos.",
                                "Explicar como usá-la para encriptar uma mensagem.",
                                "Descrever o processo de verificação de assinatura digital.",
                                "Justificar matematicamente por que sua distribuição não compromete a segurança.",
                                "Diferenciar de chave privada em um fluxograma.",
                                "Identificar um protocolo real que a usa (ex: HTTPS)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e componentes da chave pública (80% correto).",
                                "Compreensão clara dos dois usos principais (encriptação e verificação).",
                                "Explicação convincente da segurança na distribuição livre.",
                                "Uso correto de analogias e exemplos práticos.",
                                "Ausência de confusões com conceitos simétricos ou privados.",
                                "Capacidade de simular geração simples numericamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números, Primos e Fatoração.",
                                "História: Evolução da Criptografia (Diffie-Hellman, RSA 1977).",
                                "Ética e Cidadania: Privacidade Digital e Regulamentações (LGPD/GDPR).",
                                "Física/Informática: Ameaças Quânticas a Criptosistemas Assimétricos.",
                                "Segurança da Informação: Certificados Digitais e PKI."
                              ],
                              "realWorldApplication": "Na web segura (HTTPS/TLS), navegadores usam chaves públicas de servidores para encriptar tráfego; em blockchains como Bitcoin, para verificar transações assinadas; em apps de mensagens (Signal/WhatsApp) para autenticação inicial de contatos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Definir Chave Privada",
                            "description": "Descrever a chave privada como o segredo único do usuário, utilizada exclusivamente para decriptar mensagens encriptadas com a chave pública correspondente ou para criar assinaturas digitais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Fundamental da Chave Privada",
                                  "subSteps": [
                                    "Leia a definição oficial: chave privada é um segredo matemático único gerado para um usuário.",
                                    "Identifique propriedades chave: confidencialidade absoluta, usada apenas pelo dono.",
                                    "Compare com segredos cotidianos, como senha de banco, para fixar a ideia de unicidade.",
                                    "Anote em suas palavras: 'É o segredo que só eu conheço'.",
                                    "Pesquise origem do termo em contextos de criptografia assimétrica."
                                  ],
                                  "verification": "Escreva uma definição de 1-2 frases e compare com fontes confiáveis como Wikipedia ou RFCs de criptografia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Acesso à internet para Wikipedia 'Private Key'",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use analogia de uma fechadura mágica onde só sua chave abre, mas todos podem tentar trancar.",
                                  "learningObjective": "Compreender a chave privada como segredo único e confidencial do usuário.",
                                  "commonMistakes": [
                                    "Confundir com chave pública compartilhável",
                                    "Achar que é visível ou transmissível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Relação com a Chave Pública",
                                  "subSteps": [
                                    "Revise geração de par de chaves: pública derivada da privada via funções matemáticas unidirecionais.",
                                    "Desenhe um diagrama: Privada → Pública (fácil), Pública → Privada (impossível).",
                                    "Entenda assimetria: pública para encriptar, privada para decriptar.",
                                    "Simule com ferramenta online: gere par de chaves RSA e observe diferenças.",
                                    "Registre: 'Pública é derivada, mas não revela a privada'."
                                  ],
                                  "verification": "Crie um diagrama simples e explique para um colega ou grave um vídeo de 1 minuto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta online como Cryptography.io ou jsfiddle RSA demo",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Pense em matemática: funções de mão única como f(x) = x² (fácil calcular, difícil inverter sem raiz).",
                                  "learningObjective": "Diferenciar e relacionar chave privada com sua contraparte pública.",
                                  "commonMistakes": [
                                    "Acreditar que chaves são simétricas",
                                    "Ignorar a dependência matemática unidirecional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Usos Exclusivos da Chave Privada",
                                  "subSteps": [
                                    "Estude decriptação: recebe mensagem encriptada com pública, usa privada para recuperar texto plano.",
                                    "Aprenda assinatura digital: assina hash da mensagem com privada; outros verificam com pública.",
                                    "Compare fluxos: Encriptação (Pública → Privada), Assinatura (Privada → Pública).",
                                    "Pratique com exemplo: 'Assinatura garante autoria, decriptação garante privacidade'.",
                                    "Liste 3 cenários: email seguro, transação blockchain, autenticação SSH."
                                  ],
                                  "verification": "Descreva os dois usos principais em um fluxograma e teste com ferramenta de assinatura digital online.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Site como RSA Labs demo ou OpenSSL playground",
                                    "Vídeo Khan Academy sobre assinaturas digitais"
                                  ],
                                  "tips": "Lembre: Privada nunca sai do seu dispositivo; é como sua assinatura manuscrita única.",
                                  "learningObjective": "Dominar os dois usos principais: decriptar e assinar.",
                                  "commonMistakes": [
                                    "Confundir assinatura com encriptação",
                                    "Achar que privada é usada para encriptar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reforçar Segurança e Melhores Práticas",
                                  "subSteps": [
                                    "Discuta riscos: exposição leva a comprometimento total do par de chaves.",
                                    "Aprenda armazenamento: hardware wallets, módulos HSM, nunca em texto plano.",
                                    "Estude rotação de chaves e backup criptografado.",
                                    "Simule violação: 'Se privada vaza, gere novo par e revogue o antigo'.",
                                    "Crie checklist pessoal de segurança para chaves privadas."
                                  ],
                                  "verification": "Elabore um plano de segurança de 5 itens e autoavalie contra guidelines NIST.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NIST SP 800-57 guidelines PDF",
                                    "Vídeo sobre key management no YouTube"
                                  ],
                                  "tips": "Trate como sua identidade digital: proteja como passaporte.",
                                  "learningObjective": "Entender implicações de segurança e práticas para manter a chave privada.",
                                  "commonMistakes": [
                                    "Armazenar em nuvem sem criptografia",
                                    "Compartilhar para 'conveniência'"
                                  ]
                                }
                              ],
                              "practicalExample": "Você gera um par de chaves RSA. Um amigo encripta uma mensagem secreta com sua chave pública e envia. Você usa a privada para decriptar e ler 'Parabéns pelo aprendizado!'. Depois, assina uma resposta com a privada; o amigo verifica com sua pública, confirmando autoria.",
                              "finalVerifications": [
                                "Explique em 2 minutos o que é chave privada e seus usos sem consultar notas.",
                                "Diferencie corretamente de chave pública em uma comparação escrita.",
                                "Gere um par de chaves simples e demonstre decriptação/assinatura.",
                                "Identifique 3 riscos de exposição e soluções.",
                                "Crie um fluxograma completo do ciclo assimétrico.",
                                "Responda quiz de 10 perguntas sobre conceitos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição exata sem erros comuns (30%)",
                                "Clareza na explicação: linguagem acessível e exemplos relevantes (25%)",
                                "Compreensão de usos: distinção clara entre decriptar e assinar (20%)",
                                "Conhecimento de segurança: menção a práticas NIST-like (15%)",
                                "Criatividade em analogias: uso efetivo para fixação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números primos e funções unidirecionais (ex: RSA).",
                                "Ética e Cidadania: Privacidade de dados e leis como LGPD/GDPR.",
                                "História da Computação: Evolução de Diffie-Hellman a criptografia moderna.",
                                "Física/Engenharia: Analogias com mecânica quântica em cripto pós-quântica."
                              ],
                              "realWorldApplication": "Em wallets de criptomoedas como Bitcoin, a chave privada assina transações para provar propriedade sem revelar o saldo; em HTTPS/TLS, decripta tráfego seguro em sites como bancos online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Explicar Geração de Pares de Chaves",
                            "description": "Entender o processo matemático de geração de pares de chaves, baseado em problemas difíceis como fatoração de números grandes ou logaritmo discreto, garantindo que a pública não revele a privada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Básicos de Criptografia Assimétrica",
                                  "subSteps": [
                                    "Defina chaves pública e privada e seu papel na criptografia assimétrica.",
                                    "Explique por que a chave pública pode ser compartilhada enquanto a privada deve ser secreta.",
                                    "Discuta a necessidade de problemas matemáticos difíceis para garantir segurança.",
                                    "Identifique exemplos comuns como RSA e Diffie-Hellman.",
                                    "Diferencie de criptografia simétrica."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo os princípios e identifique um problema matemático chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um navegador para vídeos introdutórios sobre criptografia (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'casa com fechadura aberta para todos, mas só você tem a chave interna'.",
                                  "learningObjective": "Entender os fundamentos conceituais de pares de chaves assimétricos.",
                                  "commonMistakes": [
                                    "Confundir assimétrica com simétrica",
                                    "Achar que a chave pública pode derivar a privada facilmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Problema Matemático Subjacente: Fatoração de Números Grandes (RSA)",
                                  "subSteps": [
                                    "Aprenda sobre números primos e o produto de dois primos grandes.",
                                    "Entenda por que fatorar um semiprimo grande é computacionalmente difícil.",
                                    "Estude o Teorema de Euler e a função totiente φ(n).",
                                    "Discuta o logaritmo discreto como alternativa para outros sistemas.",
                                    "Calcule exemplos pequenos manualmente."
                                  ],
                                  "verification": "Fatore um número composto pequeno (ex: 15=3*5) e explique por que 3233 é difícil.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Ferramenta online de fatoração (ex: factordb.com)",
                                    "Livro ou PDF sobre teoria dos números"
                                  ],
                                  "tips": "Comece com números pequenos para praticar antes de escalar para grandes.",
                                  "learningObjective": "Dominar o problema matemático que sustenta a geração de chaves RSA.",
                                  "commonMistakes": [
                                    "Ignorar a importância de primos grandes e aleatórios",
                                    "Confundir φ(n) com n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar um Par de Chaves RSA Passo a Passo com Exemplo Numérico",
                                  "subSteps": [
                                    "Escolha dois primos pequenos p=61 e q=53; calcule n=p*q=3233.",
                                    "Calcule φ(n)=(p-1)(q-1)=3000.",
                                    "Escolha e=17 (coprimo com φ(n)); calcule d=2753 tal que (e*d) mod φ(n)=1.",
                                    "Chave pública: (n=3233, e=17); chave privada: (n=3233, d=2753).",
                                    "Teste encriptando uma mensagem simples."
                                  ],
                                  "verification": "Gere o par de chaves manualmente e encripte/desencripte 'A' (65).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou Python com sympy para MDC",
                                    "Papel quadriculado para cálculos"
                                  ],
                                  "tips": "Use o Algoritmo Estendido de Euclides para encontrar d.",
                                  "learningObjective": "Executar a geração de chaves RSA com números concretos.",
                                  "commonMistakes": [
                                    "Escolher e não coprimo com φ(n)",
                                    "Erros em cálculos modulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedades de Segurança e Explorar Variações",
                                  "subSteps": [
                                    "Confirme que conhecer (n,e) não revela d facilmente.",
                                    "Teste a reversibilidade: encripte com pública e decripte com privada.",
                                    "Discuta padding (OAEP) e tamanho de chaves (2048 bits+).",
                                    "Compare com ElGamal baseado em log discreto.",
                                    "Avalie ataques conhecidos como fatoração quântica (Shor)."
                                  ],
                                  "verification": "Explique por que sua chave pública não compromete a privada e simule um ataque falho.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script Python simples para teste RSA",
                                    "Artigo sobre RSA attacks"
                                  ],
                                  "tips": "Use ferramentas como OpenSSL para gerar chaves reais e inspecionar.",
                                  "learningObjective": "Validar a segurança do processo de geração.",
                                  "commonMistakes": [
                                    "Achar que chaves pequenas são seguras",
                                    "Ignorar entropia na geração de primos"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere um par de chaves RSA usando Python: from cryptography.hazmat.primitives.asymmetric import rsa; key = rsa.generate_private_key(public_exponent=65537, key_size=2048). Inspecione private_key.private_numbers() e public_key.public_numbers() para ver n, e e d derivado.",
                              "finalVerifications": [
                                "Explicar o processo de geração RSA em 5 minutos sem notas.",
                                "Gerar manualmente um par de chaves com primos pequenos e testar encriptação.",
                                "Identificar por que fatoração é o gargalo de segurança.",
                                "Diferenciar RSA de Diffie-Hellman.",
                                "Discutir impactos de chaves fracas.",
                                "Simular um ataque e explicar falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de n, φ(n), e e d.",
                                "Clareza na explicação conceitual de assimetria.",
                                "Uso correto de terminologia (semiprimo, coprimo, etc.).",
                                "Demonstração de verificação de segurança.",
                                "Inclusão de exemplos práticos e erros comuns evitados.",
                                "Conexão com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Números (Matemática: primos, MDC, módulos).",
                                "Algoritmos e Complexidade Computacional (Ciência da Computação).",
                                "Probabilidade e Estatística (geração de primos aleatórios).",
                                "Física Quântica (ameaças futuras com computadores quânticos).",
                                "Ética em TI (segurança de dados e privacidade)."
                              ],
                              "realWorldApplication": "Geração de chaves para certificados SSL/TLS em servidores web (HTTPS), assinaturas digitais em blockchain (Bitcoin wallets) e comunicação segura em apps como Signal ou WhatsApp end-to-end encryption."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Processo de Encriptação e Decriptação Assimétrica",
                        "description": "Mecanismo onde a encriptação é realizada com a chave pública do destinatário e a decriptação só é possível com a chave privada dele, proporcionando confidencialidade sem compartilhamento prévio de segredos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Descrever Encriptação com Chave Pública",
                            "description": "Detalhar como qualquer remetente usa a chave pública do receptor para transformar uma mensagem legível (plaintext) em ciphertext ilegível, permitindo envio seguro pela rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Criptografia Assimétrica",
                                  "subSteps": [
                                    "Defina chave pública como a chave que pode ser compartilhada abertamente para encriptar mensagens.",
                                    "Defina chave privada como a chave secreta mantida apenas pelo receptor para decriptar.",
                                    "Explique plaintext como a mensagem original legível e ciphertext como a versão ilegível após encriptação.",
                                    "Diferencie de criptografia simétrica, onde a mesma chave é usada para encriptar e decriptar.",
                                    "Identifique os papéis: remetente (encripta com chave pública do receptor) e receptor (decripta com chave privada)."
                                  ],
                                  "verification": "Crie um glossário com definições corretas e explique para um parceiro de estudo.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Vídeo introdutório sobre criptografia assimétrica (ex: Khan Academy)"
                                  ],
                                  "tips": "Use a analogia de uma 'caixa de correio trancada': qualquer um coloca a carta (encripta), só o dono abre (decripta).",
                                  "learningObjective": "Dominar os termos básicos e o propósito da encriptação com chave pública.",
                                  "commonMistakes": [
                                    "Confundir chave pública com privada",
                                    "Achar que chave pública decripta mensagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Geração e Distribuição de Chaves Públicas",
                                  "subSteps": [
                                    "Descreva como um par de chaves (pública e privada) é gerado usando algoritmos como RSA.",
                                    "Explique que a chave pública é publicada em diretórios públicos, sites ou certificados.",
                                    "Discuta como o remetente obtém a chave pública do receptor de forma segura (ex: via servidor confiável).",
                                    "Enfatize que a chave privada nunca é compartilhada.",
                                    "Ilustre com um diagrama simples: Receptor gera chaves → Publica pública → Remetente baixa."
                                  ],
                                  "verification": "Desenhe um fluxograma da geração e distribuição de chaves e valide com uma fonte online.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (ex: Draw.io)",
                                    "Exemplo de chave pública RSA de um tutorial"
                                  ],
                                  "tips": "Pense na chave pública como um 'endereço público' que qualquer um pode usar para enviar, mas só você recebe.",
                                  "learningObjective": "Saber como chaves públicas são disponibilizadas para uso universal.",
                                  "commonMistakes": [
                                    "Acreditar que chaves são geradas pelo remetente",
                                    "Ignorar a importância da confiança na distribuição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Processo de Encriptação Passo a Passo",
                                  "subSteps": [
                                    "Remetente obtém a chave pública do receptor de um diretório confiável.",
                                    "Remetente aplica o algoritmo de encriptação (ex: RSA) à mensagem plaintext usando a chave pública.",
                                    "O algoritmo transforma o plaintext em ciphertext matemático ilegível.",
                                    "Remetente envia o ciphertext pela rede aberta, onde pode ser interceptado mas não lido.",
                                    "Explique que qualquer um pode ver o ciphertext, mas sem chave privada, é inútil."
                                  ],
                                  "verification": "Escreva uma descrição narrativa do processo e simule com texto simples (plaintext → ciphertext fictício).",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Calculadora ou simulador online de RSA (ex: Crypto101 tools)",
                                    "Papel para simular encriptação"
                                  ],
                                  "tips": "Represente matematicamente simples: ciphertext = (plaintext ^ e) mod n, onde e e n são da chave pública.",
                                  "learningObjective": "Articular precisamente como a chave pública transforma plaintext em ciphertext seguro.",
                                  "commonMistakes": [
                                    "Pensar que encriptação usa chave privada do remetente",
                                    "Subestimar a irreversibilidade sem chave privada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a Segurança e o Fluxo Completo da Encriptação",
                                  "subSteps": [
                                    "Descreva por que é seguro: só a chave privada correspondente pode reverter o processo.",
                                    "Integre o fluxo: Geração → Distribuição → Encriptação → Transmissão → (Decriptação futura).",
                                    "Discuta ataques comuns (ex: man-in-the-middle na obtenção da chave) e mitigações (certificados).",
                                    "Compare com envio sem encriptação para destacar benefícios.",
                                    "Pratique explicando o processo inteiro em 1 minuto."
                                  ],
                                  "verification": "Grave um vídeo curto explicando o processo e autoavalie por clareza e precisão.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Gravador de vídeo ou app de notas de voz",
                                    "Diagrama completo de criptografia assimétrica"
                                  ],
                                  "tips": "Enfatize 'qualquer remetente' pode usar a mesma chave pública, escalando para múltiplos usuários.",
                                  "learningObjective": "Descrever o processo completo com ênfase na segurança da encriptação pública.",
                                  "commonMistakes": [
                                    "Omitir que rede é insegura mas processo protege",
                                    "Confundir com autenticação"
                                  ]
                                }
                              ],
                              "practicalExample": "Alice quer enviar 'Senha: 123456' para Bob via email. Bob publica sua chave pública RSA em seu site. Alice baixa a chave, usa um software como GPG para encriptar a mensagem em ciphertext (ex: 'Kj9#xP2mQ...'). Ela envia o email; um hacker intercepta, mas não lê sem a chave privada de Bob. Bob decripta facilmente.",
                              "finalVerifications": [
                                "Explique verbalmente o processo para um colega sem erros conceituais.",
                                "Desenhe um diagrama preciso mostrando plaintext → chave pública → ciphertext.",
                                "Simule encriptação simples com ferramenta online e descreva os passos usados.",
                                "Diferencie corretamente de criptografia simétrica em uma comparação escrita.",
                                "Responda a perguntas hipotéticas sobre ataques à encriptação pública."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre chaves, plaintext e ciphertext.",
                                "Clareza e estrutura: Descrição lógica e sequencial do processo.",
                                "Profundidade: Inclusão de distribuição de chaves e razões de segurança.",
                                "Uso de exemplos: Analogias ou ilustrações práticas eficazes.",
                                "Completude: Cobertura de fluxo completo sem omissões chave.",
                                "Comunicação: Capacidade de explicar de forma concisa e acessível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números primos e exponenciação modular (base do RSA).",
                                "História: Evolução da criptografia desde Enigma até criptografia moderna pós-1976 (Diffie-Hellman).",
                                "Ética e Direito: Privacidade de dados, regulamentações como GDPR e implicações de segurança digital.",
                                "Física/Engenharia: Analogias com sistemas de bloqueio quântico e computação quântica ameaçando RSA."
                              ],
                              "realWorldApplication": "Essencial para protocolos como HTTPS (TLS/SSL) em sites bancários, onde navegadores usam chaves públicas de servidores para encriptar dados de cartão; emails seguros com PGP/S/MIME; blockchain e criptomoedas para transações seguras sem confiança centralizada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Descrever Decriptação com Chave Privada",
                            "description": "Explicar o processo reverso, onde apenas o detentor da chave privada pode recuperar o plaintext original do ciphertext, demonstrando a assimetria do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Criptografia Assimétrica",
                                  "subSteps": [
                                    "Relembre a diferença entre criptografia simétrica e assimétrica: na assimétrica, usa-se par de chaves (pública e privada).",
                                    "Identifique que a chave pública é usada para encriptar e a privada para decriptar.",
                                    "Entenda que o ciphertext é o resultado da encriptação do plaintext com a chave pública.",
                                    "Visualize o fluxo: remetente encripta com chave pública do destinatário; apenas detentor da privada decripta.",
                                    "Discuta a assimetria: qualquer um encripta, só o dono decripta."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo assimétrico em 3 frases claras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de criptografia assimétrica (impresso ou digital)",
                                    "Vídeo introdutório de 5 minutos sobre RSA"
                                  ],
                                  "tips": "Use desenhos simples para representar chaves e fluxos de dados.",
                                  "learningObjective": "Compreender os papéis distintos das chaves pública e privada.",
                                  "commonMistakes": [
                                    "Confundir chave privada com pública",
                                    "Achar que qualquer um pode decriptar com a pública"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Papel Exclusivo da Chave Privada",
                                  "subSteps": [
                                    "Descreva a chave privada como o 'segredo' matemático que inverte a encriptação pública.",
                                    "Explique que ela é gerada a partir de números primos grandes (ex: em RSA, d é inverso modular de e mod φ(n)).",
                                    "Enfatize a confidencialidade: nunca compartilhada, armazenada de forma segura.",
                                    "Compare com uma fechadura: pública é a forma de fechar, privada é a única chave para abrir.",
                                    "Discuta por que roubar a pública não permite decriptar: computacionalmente inviável sem privada."
                                  ],
                                  "verification": "Responda: 'Por que a chave pública sozinha não decripta?' em uma frase precisa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha com equações básicas RSA: c = m^e mod n; m = c^d mod n",
                                    "Calculadora modular online"
                                  ],
                                  "tips": "Associe a privada a uma 'senha pessoal' para fixar a exclusividade.",
                                  "learningObjective": "Identificar a chave privada como elemento único de decriptação.",
                                  "commonMistakes": [
                                    "Pensar que chave privada é compartilhada",
                                    "Ignorar a base matemática da exclusividade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Processo Passo a Passo de Decriptação",
                                  "subSteps": [
                                    "Receba o ciphertext (c) enviado pelo remetente.",
                                    "Aplique a fórmula de decriptação: plaintext (m) = c^d mod n, onde d e n são da chave privada.",
                                    "Execute os cálculos modulares: eleve c à potência d e reduza módulo n.",
                                    "Converta o resultado numérico de volta para texto legível (ex: ASCII ou base64).",
                                    "Valide o plaintext recuperado comparando com o esperado (em testes)."
                                  ],
                                  "verification": "Simule decriptação manual com números pequenos e confirme o plaintext original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de RSA (ex: cryptool.org)",
                                    "Papel e caneta para cálculos manuais"
                                  ],
                                  "tips": "Comece com números pequenos (ex: p=3, q=11) para praticar sem calculadora.",
                                  "learningObjective": "Dominar a sequência exata do processo de decriptação.",
                                  "commonMistakes": [
                                    "Erro em expoentes modulares",
                                    "Confundir ordem das operações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a Assimétrica e Segurança do Processo",
                                  "subSteps": [
                                    "Compare decriptação bem-sucedida com tentativa falha usando chave errada (gera lixo).",
                                    "Explique a segurança baseada em problemas difíceis (ex: fatoração de n em primos).",
                                    "Discuta ataques possíveis (ex: roubo de privada) e defesas (hardware seguro).",
                                    "Ilustre com diagrama: encriptação → transmissão → decriptação exclusiva.",
                                    "Reflita sobre implicações: garante confidencialidade em canais públicos."
                                  ],
                                  "verification": "Crie um diagrama completo do processo e explique para um par.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Python com biblioteca cryptography",
                                    "Exemplo de chaves geradas (pública/privada)"
                                  ],
                                  "tips": "Teste decriptação com código simples para ver na prática.",
                                  "learningObjective": "Aplicar o processo para demonstrar assimetria e segurança.",
                                  "commonMistakes": [
                                    "Subestimar dificuldade computacional da quebra",
                                    "Omitir validação do plaintext"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine Alice envia 'Olá' (plaintext 424 para ASCII simples) encriptado com chave pública de Bob (e=3, n=33). Ciphertext c = 424^3 mod 33 = 14. Bob decripta com privada d=7: 14^7 mod 33 = 424 mod 256 = 'Olá'. Qualquer outro com pública falha.",
                              "finalVerifications": [
                                "Descreva o processo de decriptação em 5 passos sem consultar notas.",
                                "Explique por que só a chave privada funciona.",
                                "Simule decriptação com exemplo numérico pequeno.",
                                "Identifique 3 motivos de segurança da assimetria.",
                                "Compare com encriptação simétrica em um parágrafo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do fluxo assimétrico (90% correto).",
                                "Uso correto de terminologia (plaintext, ciphertext, mod n, etc.).",
                                "Explicação clara da exclusividade da chave privada.",
                                "Inclusão de exemplo prático viável.",
                                "Demonstração de compreensão matemática básica.",
                                "Identificação de erros comuns e prevenções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números.",
                                "Segurança da Informação: Autenticação e confidencialidade.",
                                "Física/Engenharia: Protocolos de comunicação segura (ex: satélites).",
                                "História da Computação: Evolução desde Diffie-Hellman."
                              ],
                              "realWorldApplication": "Em HTTPS/TLS, servidores usam chaves privadas para decriptar sessões seguras de bancos e e-mails, protegendo transações financeiras de eavesdroppers em redes públicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Comparar com Criptografia Simétrica",
                            "description": "Analisar as diferenças: na simétrica usa-se a mesma chave para encriptar/decriptar (problema de distribuição), enquanto na assimétrica resolve isso com pares de chaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios da Criptografia Simétrica",
                                  "subSteps": [
                                    "Estude o conceito básico: usa uma única chave secreta para encriptar e decriptar mensagens.",
                                    "Identifique algoritmos comuns como AES e DES.",
                                    "Analise vantagens: velocidade e eficiência para grandes volumes de dados.",
                                    "Note desvantagens iniciais: necessidade de compartilhar a chave de forma segura.",
                                    "Crie um diagrama simples mostrando o processo de encriptação/decryptação."
                                  ],
                                  "verification": "Desenhe e explique um fluxograma do processo simétrico sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Vídeo introdutório sobre AES (YouTube)"
                                  ],
                                  "tips": "Use analogias como uma caixa de segurança com uma única chave para fixar o conceito.",
                                  "learningObjective": "Compreender os fundamentos operacionais da criptografia simétrica.",
                                  "commonMistakes": [
                                    "Confundir simétrica com assimétrica prematuramente",
                                    "Ignorar a velocidade como principal vantagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Princípios da Criptografia Assimétrica",
                                  "subSteps": [
                                    "Aprenda sobre pares de chaves: pública para encriptar e privada para decriptar.",
                                    "Estude algoritmos como RSA e ECC.",
                                    "Desenhe um diagrama mostrando como a chave pública é compartilhada abertamente.",
                                    "Compare a segurança baseada em problemas matemáticos difíceis (ex: fatoração de números primos).",
                                    "Teste conceitualmente enviando uma mensagem 'encriptada' com chave pública."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como uma mensagem é decriptada apenas pelo dono da chave privada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama online",
                                    "Artigo ou vídeo sobre RSA"
                                  ],
                                  "tips": "Pense na chave pública como um cadeado aberto que qualquer um pode usar, mas só o dono fecha.",
                                  "learningObjective": "Dominar o mecanismo de pares de chaves na criptografia assimétrica.",
                                  "commonMistakes": [
                                    "Achar que a chave pública pode decriptar",
                                    "Subestimar a complexidade computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Mecanismos de Encriptação e Decriptação",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: chaves (uma vs. par), processo de encriptação/decryptação.",
                                    "Discuta diferenças em segurança: simétrica depende de sigilo da chave compartilhada.",
                                    "Analise desempenho: simétrica mais rápida para dados, assimétrica para chaves pequenas.",
                                    "Identifique cenários: simétrica para armazenamento, assimétrica para troca inicial.",
                                    "Simule uma troca de mensagens em ambos os sistemas."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças precisas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Exemplos de código Python simples para demo (opcional)"
                                  ],
                                  "tips": "Foque em fluxos visuais para destacar diferenças no uso de chaves.",
                                  "learningObjective": "Identificar e articular diferenças fundamentais nos processos.",
                                  "commonMistakes": [
                                    "Generalizar que assimétrica é sempre melhor",
                                    "Esquecer impacto no desempenho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Problema de Distribuição de Chaves e Soluções",
                                  "subSteps": [
                                    "Descreva o problema na simétrica: como entregar a chave sem interceptação?",
                                    "Explique como assimétrica resolve: envie chave pública livremente.",
                                    "Discuta híbridos: assimétrica para trocar chave simétrica (ex: TLS).",
                                    "Avalie riscos: ataques man-in-the-middle na assimétrica sem certificados.",
                                    "Conclua com prós/contras em contextos reais."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que assimétrica resolve o problema de distribuição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação TLS/HTTPS",
                                    "Vídeo sobre handshake SSL"
                                  ],
                                  "tips": "Use o exemplo de enviar uma senha por correio para ilustrar o risco simétrico.",
                                  "learningObjective": "Compreender o problema central e sua resolução assimétrica.",
                                  "commonMistakes": [
                                    "Achar que assimétrica elimina todas as necessidades de confiança",
                                    "Ignorar ataques como falsificação de chaves públicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma comunicação segura: Alice usa RSA assimétrica para enviar uma chave AES simétrica a Bob, que então usa AES para encriptar um arquivo grande. Compare com tentar enviar a chave AES diretamente (risco de interceptação).",
                              "finalVerifications": [
                                "Pode explicar a diferença no número e uso de chaves entre simétrica e assimétrica?",
                                "Identifica corretamente o problema de distribuição de chaves na simétrica?",
                                "Descreve como a assimétrica resolve esse problema com pares de chaves?",
                                "Cita exemplos reais como HTTPS usando híbrido?",
                                "Preenche tabela comparativa sem erros conceituais?",
                                "Discute prós/contras de cada em cenários específicos?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos mecanismos de chaves (simétrica vs. assimétrica).",
                                "Clareza na identificação do problema de distribuição e solução.",
                                "Uso de diagramas ou tabelas para ilustrar diferenças.",
                                "Inclusão de exemplos práticos e cenários de uso.",
                                "Análise equilibrada de vantagens/desvantagens.",
                                "Compreensão de aplicações híbridas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e problemas de fatoração (RSA).",
                                "História: Evolução da criptografia desde Enigma até moderna.",
                                "Segurança da Informação: Protocolos como TLS/SSL.",
                                "Física/Engenharia: Computação quântica ameaçando assimétrica."
                              ],
                              "realWorldApplication": "Em protocolos como HTTPS, criptografia assimétrica (RSA) é usada no handshake para trocar chaves simétricas (AES), garantindo distribuição segura sem pré-compartilhamento, essencial para e-commerce e banking online."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Assinatura Digital e Autenticação",
                        "description": "Uso da chave privada para assinar mensagens, permitindo que a chave pública verifique a autenticidade e integridade, provando a origem sem revelar o conteúdo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Explicar Criação de Assinatura Digital",
                            "description": "Descrever como o remetente aplica uma função hash à mensagem e encripta o hash com sua chave privada, gerando uma assinatura que prova autoria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Hash e Criptografia Assimétrica",
                                  "subSteps": [
                                    "Estude o que é uma função hash: uma função unidirecional que gera um valor fixo (digest) a partir de qualquer mensagem.",
                                    "Revise pares de chaves assimétricas: chave pública para verificação e chave privada para assinatura.",
                                    "Entenda as propriedades do hash: determinística, de saída fixa, resistente a colisões e pré-imagem.",
                                    "Diferencie hash de encriptação: hash não é reversível, enquanto encriptação é.",
                                    "Exemplo simples: hash de 'Olá' sempre produz o mesmo digest, independentemente do tamanho da entrada."
                                  ],
                                  "verification": "Resuma em suas palavras as diferenças entre hash e encriptação, e liste 3 propriedades de uma boa função hash.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação sobre SHA-256",
                                    "Vídeo introdutório sobre criptografia assimétrica (ex: Khan Academy)",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": "Use analogias: hash é como uma impressão digital única de um documento.",
                                  "learningObjective": "Identificar e explicar os papéis de funções hash e chaves assimétricas na assinatura digital.",
                                  "commonMistakes": [
                                    "Confundir função hash com encriptação simétrica",
                                    "Achar que hash é reversível",
                                    "Ignorar a importância da resistência a colisões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Função Hash à Mensagem Original",
                                  "subSteps": [
                                    "Prepare a mensagem original (ex: texto de um email ou documento).",
                                    "Selecione uma função hash padrão como SHA-256.",
                                    "Calcule o hash: aplique a função à mensagem inteira para gerar o digest.",
                                    "Verifique o tamanho do digest (ex: 256 bits para SHA-256).",
                                    "Armazene o digest temporariamente para o próximo passo."
                                  ],
                                  "verification": "Gere o hash de uma mensagem de teste usando uma ferramenta online (ex: sha256.online) e confirme o resultado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta online de hash (SHA-256)",
                                    "Mensagem de teste (arquivo .txt)",
                                    "Calculadora de hash local como OpenSSL"
                                  ],
                                  "tips": "Sempre hasheie a mensagem completa para evitar ataques de padding.",
                                  "learningObjective": "Executar o cálculo de hash corretamente e entender por que só o hash é assinado, não a mensagem inteira.",
                                  "commonMistakes": [
                                    "Hashear apenas parte da mensagem",
                                    "Usar hash fraco como MD5",
                                    "Não normalizar a mensagem (ex: quebras de linha)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encriptar o Hash com a Chave Privada para Gerar a Assinatura",
                                  "subSteps": [
                                    "Obtenha sua chave privada do par assimétrico (ex: RSA 2048 bits).",
                                    "Aplique o algoritmo de encriptação assimétrica ao digest do hash usando a chave privada.",
                                    "Gere a assinatura: resultado é um bloco de dados encriptado do tamanho da chave.",
                                    "Formate a assinatura em base64 para transmissão fácil.",
                                    "Teste se a encriptação falha por chave inválida."
                                  ],
                                  "verification": "Use uma biblioteca como Python cryptography para assinar um hash de teste e exiba a assinatura gerada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca Python cryptography ou ferramenta como OpenSSL",
                                    "Par de chaves gerado (openssl genrsa)",
                                    "Editor de código"
                                  ],
                                  "tips": "Mantenha a chave privada segura; nunca a compartilhe.",
                                  "learningObjective": "Gerar uma assinatura digital válida a partir do hash usando chave privada.",
                                  "commonMistakes": [
                                    "Usar chave pública para assinar",
                                    "Encriptar a mensagem inteira em vez do hash",
                                    "Ignorar padding no RSA"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar a Assinatura à Mensagem e Explicar a Prova de Autoria",
                                  "subSteps": [
                                    "Anexe a assinatura ao pacote da mensagem (mensagem + hash + assinatura).",
                                    "Explique como o receptor verifica: descriptografa assinatura com chave pública para obter hash e compara com hash recalculado.",
                                    "Discuta propriedades: não repúdio (só dono da privada assina), integridade e autoria.",
                                    "Simule o processo completo de envio.",
                                    "Reflita sobre ataques possíveis (ex: roubo de chave privada)."
                                  ],
                                  "verification": "Descreva o fluxo completo em um diagrama simples e explique por que prova autoria.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Ferramenta de diagrama online (Draw.io)",
                                    "Exemplo de código completo de assinatura"
                                  ],
                                  "tips": "Pense no receptor: a chave pública deve ser confiável via certificado.",
                                  "learningObjective": "Explicar o processo inteiro e suas garantias de segurança.",
                                  "commonMistakes": [
                                    "Confundir criação com verificação",
                                    "Achar que assinatura encripta a mensagem",
                                    "Subestimar necessidade de hash para eficiência"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao enviar um contrato digital por email, Alice calcula o SHA-256 do PDF do contrato (digest: abc123...), encripta esse digest com sua chave privada RSA gerando a assinatura 'XYZ789=', anexa tudo ao email. Bob verifica descriptografando com a chave pública de Alice e comparando hashes, confirmando autoria e integridade.",
                              "finalVerifications": [
                                "Descrever verbalmente os 4 passos da criação de assinatura digital.",
                                "Calcular corretamente o hash de uma mensagem de teste.",
                                "Gerar uma assinatura válida usando ferramenta ou código.",
                                "Explicar por que só o hash é assinado e não a mensagem inteira.",
                                "Desenhar um diagrama do fluxo remetente-receptor.",
                                "Identificar 3 propriedades garantidas pela assinatura digital."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de função hash (determinística, fixa, unidirecional).",
                                "Correta distinção entre chave privada (assinatura) e pública (verificação).",
                                "Demonstração prática de cálculo de hash e assinatura.",
                                "Compreensão de eficiência: assinar hash reduz tamanho.",
                                "Explicação clara de prova de autoria e não repúdio.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números primos e funções modulares no RSA.",
                                "Direito: Validade legal de assinaturas digitais (ex: Lei 14.063/2020 no Brasil).",
                                "História: Evolução da criptografia de Enigma à era digital.",
                                "Informática: Aplicações em blockchain e certificados SSL/TLS."
                              ],
                              "realWorldApplication": "Assinaturas digitais são usadas em contratos eletrônicos (DocuSign), transações blockchain (Bitcoin), certificados HTTPS para sites seguros e validação de software atualizações, garantindo autoria, integridade e não repúdio em comunicações digitais globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Explicar Verificação de Assinatura",
                            "description": "Detalhar o processo de decriptar a assinatura com a chave pública do remetente, comparar com o hash da mensagem recebida para validar autenticidade e não-repúdio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da assinatura digital",
                                  "subSteps": [
                                    "Identificar a mensagem original (M).",
                                    "Explicar o cálculo do hash da mensagem (H(M)) usando uma função hash como SHA-256.",
                                    "Descrever a assinatura (S) como o resultado da criptografia de H(M) com a chave privada do remetente.",
                                    "Explicar o papel da chave pública do remetente na verificação.",
                                    "Diferenciar autenticidade (origem) e não-repúdio (impossibilidade de negar envio)."
                                  ],
                                  "verification": "Desenhar um diagrama dos componentes e rotulá-los corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Documentação de funções hash (ex: SHA-256)"
                                  ],
                                  "tips": "Use analogias como selo de cera para visualizar não-repúdio.",
                                  "learningObjective": "Entender os elementos fundamentais envolvidos na verificação de assinatura digital.",
                                  "commonMistakes": [
                                    "Confundir chave pública com privada",
                                    "Ignorar o papel do hash na integridade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Receber a mensagem assinada e preparar os dados",
                                  "subSteps": [
                                    "Receber o par: mensagem recebida (M') e assinatura (S).",
                                    "Obter a chave pública do remetente (Kp_remetente) de uma fonte confiável (ex: certificado).",
                                    "Verificar se todos os dados estão presentes e intactos.",
                                    "Armazenar temporariamente M', S e Kp_remetente para processamento."
                                  ],
                                  "verification": "Listar os três elementos recebidos e confirmar sua disponibilidade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Exemplo de mensagem assinada fictícia",
                                    "Chave pública sample (ex: em PEM)"
                                  ],
                                  "tips": "Sempre valide a fonte da chave pública para evitar ataques man-in-the-middle.",
                                  "learningObjective": "Preparar corretamente os inputs necessários para a verificação.",
                                  "commonMistakes": [
                                    "Usar chave errada",
                                    "Não verificar integridade inicial dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o hash da mensagem recebida",
                                  "subSteps": [
                                    "Aplicar a mesma função hash usada na assinatura à mensagem M' para obter H(M').",
                                    "Garantir que a função hash seja idêntica (ex: SHA-256).",
                                    "Registrar o valor do hash calculado.",
                                    "Comparar conceitualmente com o hash original (ainda não decriptado)."
                                  ],
                                  "verification": "Executar cálculo manual ou com ferramenta e anotar o hash resultante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta online de hash (ex: sha256.online)",
                                    "Mensagem de exemplo"
                                  ],
                                  "tips": "Pequenas alterações em M' mudam drasticamente H(M'), testando integridade.",
                                  "learningObjective": "Dominar o cálculo de hash para verificação de integridade.",
                                  "commonMistakes": [
                                    "Usar função hash diferente",
                                    "Hash de mensagem alterada sem notar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decriptar a assinatura com a chave pública",
                                  "subSteps": [
                                    "Aplicar a operação de decriptografia à assinatura S usando Kp_remetente para obter H'(M).",
                                    "Explicar que isso recupera o hash original assinado pelo remetente.",
                                    "Registrar o valor decriptado H'(M).",
                                    "Verificar se o resultado é um hash válido (tamanho e formato)."
                                  ],
                                  "verification": "Simular decriptografia com ferramenta (ex: OpenSSL) e confirmar hash recuperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Exemplo de assinatura e chave pública"
                                  ],
                                  "tips": "Na prática, use bibliotecas como cryptography em Python para automação.",
                                  "learningObjective": "Executar a decriptografia assimétrica corretamente.",
                                  "commonMistakes": [
                                    "Confundir encriptação com decriptação",
                                    "Chave pública inválida"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar hashes e concluir a verificação",
                                  "subSteps": [
                                    "Comparar H(M') com H'(M): se iguais, assinatura válida.",
                                    "Se iguais: mensagem autêntica, íntegra e não repudiável.",
                                    "Se diferentes: rejeitar (possível falsificação ou alteração).",
                                    "Documentar o resultado e razões.",
                                    "Discutir implicações de falha na verificação."
                                  ],
                                  "verification": "Afirmar 'Hashes iguais: válido' ou 'Diferentes: inválido' com evidência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Hashes calculados dos steps anteriores"
                                  ],
                                  "tips": "Igualdade bit a bit é crucial; use ferramentas hex para comparação precisa.",
                                  "learningObjective": "Interpretar o resultado da comparação para validar autenticidade e não-repúdio.",
                                  "commonMistakes": [
                                    "Aceitar hashes próximos mas não idênticos",
                                    "Ignorar contexto de não-repúdio"
                                  ]
                                }
                              ],
                              "practicalExample": "Verificar um email assinado digitalmente: Receba email com anexo assinatura (S), calcule hash do corpo (H(M')), decripte S com chave pública do remetente via ferramenta como GPG, compare hashes. Se iguais, confirme autenticidade do banco enviando extrato.",
                              "finalVerifications": [
                                "Descrever o processo completo em 5 passos sem erros.",
                                "Explicar diferença entre hash calculado e decriptado.",
                                "Identificar quando a verificação falha e por quê.",
                                "Simular verificação com exemplo numérico simples.",
                                "Diferenciar verificação de assinatura de encriptação de confidencialidade.",
                                "Relacionar com não-repúdio em contratos digitais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da decriptação com chave pública (100%).",
                                "Correta compreensão do papel do hash na integridade (90%+).",
                                "Uso correto de terminologia (autenticidade, não-repúdio).",
                                "Capacidade de simular processo em ferramenta prática.",
                                "Identificação de erros comuns em cenários hipotéticos.",
                                "Clareza na explicação de falhas na verificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e propriedades colisão-resistentes.",
                                "Segurança da Informação: Protocolos como PGP/S-MIME.",
                                "Programação: Implementação em Python com bibliotecas cryptography.",
                                "Direito Digital: Validade legal de assinaturas eletrônicas (ex: ICP-Brasil)."
                              ],
                              "realWorldApplication": "Validação de atualizações de software (ex: GitHub commits assinados), certificados SSL/TLS em sites HTTPS, transações blockchain (ex: Bitcoin signatures) e documentos oficiais assinados digitalmente para evitar fraudes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1",
                              "10.1.3.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Geração de Pares de Chaves",
                    "description": "Processo de criação das chaves pública e privada, baseado em problemas matemáticos difíceis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Problemas Matemáticos Difíceis",
                        "description": "Fundamentos matemáticos que garantem a segurança da geração de pares de chaves, baseados em problemas computacionalmente intratáveis sem conhecimento prévio.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar problemas matemáticos difíceis",
                            "description": "Reconhecer e listar problemas como fatoração de inteiros grandes (usado no RSA), logaritmo discreto (usado no Diffie-Hellman) e problema do resíduo quadrático, explicando sua relevância para criptosistemas de chave pública.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Problemas Matemáticos Difíceis em Criptografia",
                                  "subSteps": [
                                    "Defina o que são problemas matemáticos difíceis: problemas computacionalmente intratáveis com computadores atuais, mas potencialmente solucionáveis teoricamente.",
                                    "Discuta por que eles são fundamentais para a segurança de criptosistemas assimétricos.",
                                    "Classifique tipos de problemas: baseados em números primos, logaritmos e resíduos quadráticos.",
                                    "Pesquise exemplos históricos de falhas quando problemas foram 'quebrados'.",
                                    "Anote as propriedades chave: unidirecionalidade (fácil em uma direção, difícil na inversa)."
                                  ],
                                  "verification": "Escreva uma definição de 100 palavras e liste 3 propriedades chave; revise se cobre unidirecionalidade e relevância para cripto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook ou editor de texto",
                                    "Artigo introdutório sobre criptografia assimétrica (ex: Wikipedia - Public-key cryptography)"
                                  ],
                                  "tips": [
                                    "Use analogias como 'fechadura de um sentido' para visualizar unidirecionalidade.",
                                    "Foquem em complexidade computacional, não em soluções matemáticas exatas."
                                  ],
                                  "learningObjective": "Compreender o papel fundamental dos problemas difíceis na base teórica da criptografia de chave pública.",
                                  "commonMistakes": [
                                    "Confundir dificuldade computacional com impossibilidade matemática.",
                                    "Ignorar o contexto histórico de evoluções em hardware que ameaçam esses problemas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Descrever a Fatoração de Inteiros Grandes",
                                  "subSteps": [
                                    "Explique o problema: dado N = p*q (p e q primos grandes), encontrar p e q é difícil.",
                                    "Relacione com RSA: chaves públicas usam N, privadas usam p e q.",
                                    "Estude algoritmos como Trial Division (lento) vs. Number Field Sieve (estado da arte).",
                                    "Calcule um exemplo pequeno: fatorar 91 = 7*13 manualmente.",
                                    "Discuta tamanho típico: N com 2048 bits (~617 dígitos)."
                                  ],
                                  "verification": "Descreva o problema em 50 palavras e resolva fatoração de um N de 20 bits; confirme se liga corretamente ao RSA.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou Python para fatoração simples",
                                    "Vídeo tutorial sobre RSA (ex: Khan Academy)"
                                  ],
                                  "tips": [
                                    "Comece com números pequenos para intuição antes de escalar.",
                                    "Lembre: dificuldade cresce exponencialmente com bits."
                                  ],
                                  "learningObjective": "Reconhecer a fatoração como pilar do RSA e sua inquebrabilidade prática.",
                                  "commonMistakes": [
                                    "Pensar que primos pequenos são irrelevantes; sempre use primos grandes.",
                                    "Confundir fatoração com primalidade (teste fácil)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Logaritmo Discreto e Problema do Resíduo Quadrático",
                                  "subSteps": [
                                    "Defina Logaritmo Discreto (DLP): dado g^x ≡ y mod p, encontrar x é difícil.",
                                    "Relacione com Diffie-Hellman: troca de chaves usa DLP para segurança.",
                                    "Descreva Resíduo Quadrático (QRP): dado y e p primo, encontrar x tal que x² ≡ y mod p.",
                                    "Mencione uso em esquemas como Rabin ou Paillier.",
                                    "Compare dificuldades: todos NP-intermediários, sem P=NP conhecido."
                                  ],
                                  "verification": "Liste definições e usos para DLP e QRP; crie um exemplo mod 17 para cada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para cálculos modulares",
                                    "Recurso online: Crypto101 ou livro 'Handbook of Applied Cryptography' PDF"
                                  ],
                                  "tips": [
                                    "Use grupos cíclicos pequenos (p=17) para praticar cálculos.",
                                    "Visualize DLP como 'senha escondida em exponenciação modular'."
                                  ],
                                  "learningObjective": "Identificar DLP e QRP como problemas chave para Diffie-Hellman e outros sistemas.",
                                  "commonMistakes": [
                                    "Confundir log discreto com log contínuo.",
                                    "Ignorar que QRP é mais fácil em alguns casos (teste de Legendre)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar Problemas e Explicar Relevância para Criptosistemas de Chave Pública",
                                  "subSteps": [
                                    "Compile lista: Fatoração, DLP, QRP + bônus como Elliptic Curve DLP.",
                                    "Explique relevância: baseiam trapdoors em funções unidirecionais.",
                                    "Discuta ameaças: computadores quânticos (Shor quebra fatoração/DLP).",
                                    "Crie tabela comparativa: Problema | Criptossistema | Dificuldade Estimada.",
                                    "Sintetize: por que chave pública depende desses (sem canal seguro prévio)."
                                  ],
                                  "verification": "Produza uma lista com 3 problemas, descrições curtas e criptosistemas associados; autoavalie completude.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown",
                                    "Resumo de criptografia pós-quântica (ex: NIST page)"
                                  ],
                                  "tips": [
                                    "Use tabela para memorização visual.",
                                    "Ligue sempre problema -> cripto -> mundo real."
                                  ],
                                  "learningObjective": "Capacitar listar e contextualizar problemas difíceis em criptografia assimétrica.",
                                  "commonMistakes": [
                                    "Listar problemas irrelevantes como fatoriais.",
                                    "Subestimar impacto quântico na relevância futura."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de app de chat seguro, identifique que para implementar RSA, você precisa confiar na dificuldade da fatoração de um módulo de 2048 bits; teste gerando chaves e verificando se pode fatorar facilmente (não pode), simulando um atacante.",
                              "finalVerifications": [
                                "Liste corretamente os 3 problemas principais com definições precisas.",
                                "Explique ligação de cada um a pelo menos um criptossistema específico.",
                                "Crie tabela comparativa com propriedades chave.",
                                "Identifique uma ameaça comum (ex: quântica) a todos.",
                                "Descreva um exemplo prático para cada problema.",
                                "Autoavalie compreensão com quiz de 5 perguntas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições matemáticas (80%+ correto).",
                                "Correta associação a criptosistemas (todos os 3 ligados).",
                                "Profundidade na explicação de relevância (inclui unidirecionalidade).",
                                "Uso de exemplos concretos e verificáveis.",
                                "Clareza na lista e tabela (legível e organizada).",
                                "Reconhecimento de limitações futuras (quântica)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (grupos, módulos, primalidade).",
                                "Ciência da Computação: Algoritmos e Complexidade (NP vs P).",
                                "Física: Computação Quântica (algoritmo de Shor).",
                                "Engenharia de Software: Implementação de bibliotecas crypto (OpenSSL).",
                                "História da Computação: Evolução de chaves públicas (1970s)."
                              ],
                              "realWorldApplication": "Esses problemas sustentam a segurança de HTTPS/TLS em navegadores, assinaturas digitais em blockchain (Bitcoin) e VPNs corporativas, protegendo trilhões em transações diárias contra ataques de força bruta."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Explicar a dificuldade computacional",
                            "description": "Descrever por que esses problemas são difíceis de resolver com computadores atuais, comparando com algoritmos eficientes para o inverso, e mencionar o papel de heurísticas como o tempo exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os Problemas Matemáticos Difíceis em Criptografia",
                                  "subSteps": [
                                    "Liste os principais problemas usados em criptosistemas de chave pública, como fatoração de inteiros grandes (RSA) e logaritmo discreto (Diffie-Hellman).",
                                    "Descreva brevemente cada problema: fatoração envolve decompor um número N = p*q em primos p e q; log discreto encontra x tal que g^x ≡ h mod p.",
                                    "Explique que esses problemas não têm algoritmos conhecidos de tempo polinomial.",
                                    "Pesquise exemplos históricos, como o desafio de fatorar RSA-129 em 1994.",
                                    "Anote por que são 'difíceis': tempo computacional impraticável para tamanhos reais (ex: 2048 bits)."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama listando 3 problemas difíceis com descrições curtas e valide com uma fonte confiável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook, acesso à internet para artigos sobre RSA e Diffie-Hellman, calculadora para números pequenos.",
                                  "tips": "Use analogias simples, como 'encontrar agulha no palheiro', para fixar conceitos.",
                                  "learningObjective": "Compreender os problemas fundamentais que sustentam a segurança da criptografia assimétrica.",
                                  "commonMistakes": "Confundir com problemas fáceis como soma ou multiplicação; ignorar o tamanho dos números (bits)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar com Operações Eficientes (o Inverso)",
                                  "subSteps": [
                                    "Descreva o problema inverso: multiplicar dois primos grandes p e q para obter N é rápido (polinomial).",
                                    "Implemente um exemplo simples em Python: multiplique dois primos de 100 dígitos e meça o tempo.",
                                    "Compare tempos: fatorar N leva anos em supercomputadores, enquanto multiplicar leva milissegundos.",
                                    "Discuta funções trapdoor: fáceis em uma direção, difíceis na inversa sem chave privada.",
                                    "Crie uma tabela comparativa: Tempo Multiplicação vs Fatoração para diferentes tamanhos."
                                  ],
                                  "verification": "Execute o código Python e gere a tabela; confirme que multiplicação é <1s para números grandes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python/IDLE), biblioteca sympy para primos grandes.",
                                  "tips": "Comece com números pequenos para testar, depois escale para demonstrar eficiência.",
                                  "learningObjective": "Diferenciar problemas computacionalmente fáceis de difíceis, destacando assimetria.",
                                  "commonMistakes": "Achar que todos os problemas matemáticos são difíceis; não escalar exemplos para realismo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Complexidade Computacional e Tempo Exponencial",
                                  "subSteps": [
                                    "Defina complexidade: polinomial (P) vs exponencial (NP-difícil).",
                                    "Explique trial division para fatoração: O(√N) tentativas, exponencial em bits de N.",
                                    "Discuta melhores algoritmos como GNFS: ainda subexponencial, mas impraticável para 2048 bits.",
                                    "Mencione heurísticas: métodos aproximados como pollard rho, mas falham em casos adversos.",
                                    "Calcule: para 1024 bits, 2^50 operações ≈ séculos em hardware atual."
                                  ],
                                  "verification": "Escreva uma equação de complexidade e calcule tempo estimado para um N de 2048 bits.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de cálculo ou Python para cálculos de complexidade, gráficos de crescimento exponencial.",
                                  "tips": "Use logaritmos para bits: dificuldade dobra a cada bit extra.",
                                  "learningObjective": "Dominar noções de tempo exponencial e por que computadores atuais falham.",
                                  "commonMistakes": "Confundir exponencial com linear; superestimar poder de brute-force moderno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar o Papel das Heurísticas e Implicações",
                                  "subSteps": [
                                    "Explique heurísticas: atalhos probabilísticos que aceleram em média, mas não garantem.",
                                    "Discuta limites: sem prova de P=NP, assumimos segurança.",
                                    "Relacione à geração de chaves: escolher p,q primos grandes torna inverso difícil.",
                                    "Crie um fluxograma: Geração Chave → Problema Difícil → Segurança.",
                                    "Reflita: impacto de computadores quânticos (Shor quebra RSA)."
                                  ],
                                  "verification": "Produza o fluxograma e explique verbalmente para um par ou gravando áudio.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io ou papel), vídeo curto sobre algoritmo Shor.",
                                  "tips": "Ensaie explicação em 2 minutos para clareza.",
                                  "learningObjective": "Integrar conceitos em uma narrativa coesa sobre dificuldade computacional.",
                                  "commonMistakes": "Ignorar heurísticas como 'solução'; não mencionar ameaças futuras como quânticos."
                                }
                              ],
                              "practicalExample": "Em RSA, Alice gera chaves: escolhe primos p=61, q=53, N=3233 (fácil de multiplicar). Bob tenta fatorar 3233 sem saber p,q: trial division testa até √3233≈57, demorado para N real de 2048 bits. Heurísticas como Fermat testam falsos positivos, mas GNFS ainda leva meses.",
                              "finalVerifications": [
                                "Explique em 2 minutos por que fatorar é difícil vs multiplicar, sem notas.",
                                "Resolva: 'Por que heurísticas não quebram RSA comercial?'",
                                "Crie tabela comparativa de tempos para 512/1024/2048 bits.",
                                "Identifique problema em: 'RSA usa soma modular como base'.",
                                "Descreva impacto de Shor em fatoração.",
                                "Gere par de chaves RSA-100 e explique segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Correta distinção entre fácil/difícil e complexidades.",
                                "Clareza: Uso de analogias e exemplos concretos.",
                                "Profundidade: Inclusão de heurísticas, tempos exponenciais e comparações.",
                                "Originalidade: Explicação em palavras próprias, não copiada.",
                                "Completude: Cobertura de inverso, heurísticas e implicações.",
                                "Evidências: Cálculos, códigos ou diagramas suportam argumentos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, modularidade).",
                                "Física: Computação Quântica (algoritmo Shor).",
                                "História: Evolução da Criptografia (Enigma a RSA).",
                                "Ciência da Computação: Complexidade (P vs NP).",
                                "Ética: Implicações de segurança digital em privacidade."
                              ],
                              "realWorldApplication": "Essa compreensão sustenta a confiança em protocolos como HTTPS/TLS para banking online, e-mails criptografados (PGP) e blockchain (Bitcoin), onde chaves públicas protegem transações sem revelar privadas, resistindo a ataques de nações-estado."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Relacionar problemas à segurança das chaves",
                            "description": "Explicar como a segurança da chave privada depende da dificuldade de inverter o processo de geração da chave pública, usando exemplos de ataques bem-sucedidos se o problema for resolvido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de Geração de Pares de Chaves em Criptosistemas Públicos",
                                  "subSteps": [
                                    "Estude um exemplo concreto como o RSA: escolha dois primos grandes p e q, compute n = p * q (chave pública) e φ(n) = (p-1)(q-1) para a chave privada d.",
                                    "Entenda que a chave pública (n, e) é compartilhada, enquanto a privada (d) é secreta.",
                                    "Desenhe um diagrama do fluxo: gerador → chave pública → inverso difícil → chave privada.",
                                    "Compare com ECC (Elliptic Curve Cryptography), onde o problema é o logaritmo discreto elíptico.",
                                    "Pratique gerando um par de chaves pequeno usando uma ferramenta online ou Python (biblioteca cryptography)."
                                  ],
                                  "verification": "Crie um diagrama anotado do processo e explique verbalmente para um par ou grave um vídeo de 1 minuto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook, acesso a Python ou ferramenta online como RSA key generator (ex: cryptool.org), vídeo tutorial sobre RSA.",
                                  "tips": "Use números pequenos inicialmente (ex: p=61, q=53) para cálculos manuais e entender o conceito.",
                                  "learningObjective": "Compreender os passos exatos de geração de chaves e identificar qual informação é pública vs. privada.",
                                  "commonMistakes": "Confundir chave pública com privada ou achar que n é a chave privada diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Problema Matemático Difícil Subjacente",
                                  "subSteps": [
                                    "Para RSA, identifique a fatoração de n em p e q como o problema central (Integer Factorization Problem).",
                                    "Pesquise complexidade computacional: O(n^{1/3}) para fatoração geral, intratável para n de 2048 bits.",
                                    "Para ECC, explique o Elliptic Curve Discrete Logarithm Problem (ECDLP).",
                                    "Liste propriedades matemáticas: primos grandes, módulo grande, one-way functions.",
                                    "Resolva um problema pequeno: dado n=15 (3*5), fatorize e veja como obter chaves privadas."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras nomeando o problema e sua complexidade, com exemplo fatorado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta para cálculos, Wikipedia ou Khan Academy sobre problemas NP-intermediários.",
                                  "tips": "Lembre-se: dificuldade é assintótica; computadores atuais não conseguem para chaves fortes.",
                                  "learningObjective": "Mapear precisamente o problema matemático à etapa de inversão da geração de chaves.",
                                  "commonMistakes": "Achar que o problema é só 'multiplicação reversa' sem contexto de fatoração ou log discreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Dependência da Segurança da Chave Privada na Dificuldade do Problema",
                                  "subSteps": [
                                    "Descreva: segurança = dificuldade computacional de inverter (extrair privada de pública).",
                                    "Discuta one-way functions: fácil forward (pública de privada), difícil backward.",
                                    "Analise impacto: se inverter for fácil, qualquer um com pública obtém privada.",
                                    "Compare com chaves simétricas: aqui, assimetria vem do problema matemático.",
                                    "Crie uma tabela: 'Se problema resolvido → Ataque possível → Consequências (ex: descriptografar tudo)'."
                                  ],
                                  "verification": "Redija um parágrafo explicando a dependência e justifique com equação RSA básica (c = m^e mod n → m = c^d mod n).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto, quadro branco virtual (ex: Jamboard), referência: 'Cryptography and Network Security' PDF.",
                                  "tips": "Use analogia: trancar porta com cadeado (fácil fechar, difícil abrir sem chave).",
                                  "learningObjective": "Articular como a hardness assumption sustenta toda a criptografia assimétrica.",
                                  "commonMistakes": "Ignorar que segurança é probabilística/heurística, não prova matemática absoluta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Exemplos de Ataques Bem-Sucedidos se o Problema for Resolvido",
                                  "subSteps": [
                                    "Exemplo histórico: Fatoração de RSA-129 em 1994 (computadores da época).",
                                    "Hipotético moderno: Quantum computer com Shor's algorithm quebra RSA em horas.",
                                    "Cenário Bitcoin: Derivar chave privada de pública exposta via ECDLP resolvido → roubo de wallet.",
                                    "Liste ataques: chosen ciphertext, padding oracle, mas foque em quebra matemática.",
                                    "Simule: Use ferramenta para 'quebrar' chave fraca e descriptografar mensagem."
                                  ],
                                  "verification": "Desenvolva um caso de estudo curto (300 palavras) com exemplo real ou simulado de ataque.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta como SageMath para simular Shor ou fatoração, artigos sobre RSA challenges.",
                                  "tips": "Pesquise 'RSA Factoring Challenge' para casos reais; foque em consequências práticas.",
                                  "learningObjective": "Ilustrar falhas catastróficas se a suposição de dificuldade falhar.",
                                  "commonMistakes": "Confundir ataques side-channel (ex: timing) com quebra matemática pura."
                                }
                              ],
                              "practicalExample": "Em uma transação Bitcoin, a chave pública é derivada da privada via ECC. Se alguém resolvesse o ECDLP (invertesse), poderia gastar moedas de qualquer endereço público conhecido, como no hack hipotético de Mt. Gox ampliado.",
                              "finalVerifications": [
                                "Explica corretamente o processo de geração e o problema matemático associado.",
                                "Descreve com precisão como a inversão compromete a chave privada.",
                                "Fornece pelo menos um exemplo histórico ou hipotético de ataque.",
                                "Identifica limitações atuais (ex: computadores quânticos).",
                                "Cria diagrama ou tabela resumindo dependências de segurança.",
                                "Responde perguntas de follow-up sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção dos conceitos matemáticos e criptográficos (30%).",
                                "Clareza de explicação: Linguagem acessível com analogias (25%).",
                                "Uso de exemplos: Relevância e concretude dos ataques (20%).",
                                "Profundidade: Cobertura de subproblemas e complexidades (15%).",
                                "Originalidade: Diagramas ou tabelas personalizados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (fatoração, logaritmos discretos).",
                                "Física: Computação Quântica (algoritmo de Shor).",
                                "História: Evolução da Criptografia (Enigma a RSA).",
                                "Ética: Implicações de segurança digital e privacidade."
                              ],
                              "realWorldApplication": "Garante segurança em protocolos como HTTPS (TLS com RSA/ECC), assinaturas digitais em blockchain e autenticação em apps bancários, protegendo bilhões de transações diárias contra eavesdropping e falsificações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Seleção de Parâmetros Iniciais",
                        "description": "Escolha aleatória e verificação de parâmetros criptográficos iniciais, como números primos grandes, essenciais para a geração segura de chaves.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Gerar números primos grandes probabilisticamente",
                            "description": "Utilizar testes probabilísticos de primalidade (como Miller-Rabin) para selecionar primos grandes (ex.: 1024 bits), garantindo que sejam adequados para criptografia sem fatoração fácil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos dos testes probabilísticos de primalidade, com foco no Miller-Rabin",
                                  "subSteps": [
                                    "Estudar a decomposição de números ímpares como 2^s * d + 1, onde d é ímpar.",
                                    "Compreender o teste de Fermat e suas limitações (pseudoprimos).",
                                    "Aprender o algoritmo Miller-Rabin: escolha de bases 'a' e verificação de condições modulares.",
                                    "Analisar a probabilidade de erro: para k iterações, erro < 4^-k.",
                                    "Revisar exemplos matemáticos para números pequenos (ex: testar 561, pseudoprimo)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o algoritmo Miller-Rabin para um número exemplo e calcular manualmente uma iteração.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação oficial Miller-Rabin (Wikipedia ou papers), caderno para cálculos manuais, calculadora modular online."
                                  ],
                                  "tips": "Comece com números pequenos para visualizar o algoritmo antes de escalar para grandes.",
                                  "learningObjective": "Compreender a teoria por trás do teste probabilístico Miller-Rabin e sua eficiência para primos grandes.",
                                  "commonMistakes": [
                                    "Confundir teste determinístico com probabilístico.",
                                    "Ignorar a necessidade de múltiplas bases 'a' para reduzir erro.",
                                    "Não decompor corretamente n-1 = 2^s * d."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o teste Miller-Rabin em Python",
                                  "subSteps": [
                                    "Definir função para decompor n-1 em 2^s * d.",
                                    "Implementar exponenciação modular eficiente usando pow(a, d, n).",
                                    "Codificar a lógica principal: para cada base 'a' em lista de witnesses, verificar condições.",
                                    "Testar com números conhecidos: primos (ex: 17) e compostos (ex: 91).",
                                    "Adicionar suporte para números grandes usando int Python (arbitrário precisão)."
                                  ],
                                  "verification": "Executar o teste em 10 números conhecidos e confirmar 100% de acerto para casos pequenos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python 3+, editor de código (VS Code), bibliotecas: random, math (nativas)."
                                  ],
                                  "tips": "Use witnesses fortes como [2, 3, 5, 7, 11] para 1024 bits, garantindo erro < 2^-80.",
                                  "learningObjective": "Desenvolver uma implementação funcional e eficiente do Miller-Rabin.",
                                  "commonMistakes": [
                                    "Não tratar casos especiais: n=2,3 (primos), n par.",
                                    "Erro em loop de squaring quando r != s-1.",
                                    "Usar pow sem módulo, causando overflow desnecessário."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar candidatos aleatórios grandes (1024 bits)",
                                  "subSteps": [
                                    "Usar random.getrandbits(1024) para gerar número ímpar aleatório.",
                                    "Garantir que o número esteja no intervalo [2^1023, 2^1024 -1] e ímpar.",
                                    "Implementar função para gerar múltiplos candidatos se necessário.",
                                    "Verificar tamanho exato com bit_length().",
                                    "Testar geração de 100 candidatos e medir distribuição."
                                  ],
                                  "verification": "Gerar 50 candidatos e confirmar que todos têm exatamente 1024 bits e são ímpares.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python random module, script de teste."
                                  ],
                                  "tips": "Sempre comece com números ímpares para evitar testes desnecessários em pares.",
                                  "learningObjective": "Gerar números aleatórios criptograficamente adequados para candidatos a primos.",
                                  "commonMistakes": [
                                    "Gerar números pares ou com bit_length incorreto.",
                                    "Não usar random forte (use secrets para produção).",
                                    "Ignorar bias em geração aleatória."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Miller-Rabin iterativamente para encontrar um primo provável",
                                  "subSteps": [
                                    "Criar loop: gerar candidato, aplicar Miller-Rabin com k=40 iterações.",
                                    "Parar após encontrar primo provável ou limite de tentativas (ex: 10000).",
                                    "Registrar estatísticas: tentativas, taxa de sucesso (~1/ln(n)).",
                                    "Opcional: testar com bibliotecas como sympy.isprime para validação.",
                                    "Exportar o primo encontrado em formato hexadecimal."
                                  ],
                                  "verification": "Gerar um primo de 1024 bits em <1 minuto e validar com ferramenta externa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código dos steps anteriores, sympy (opcional para verificação)."
                                  ],
                                  "tips": "Para 1024 bits, espere ~3000 tentativas; otimize witnesses para velocidade.",
                                  "learningObjective": "Integrar geração e teste para produzir primos grandes adequados à criptografia.",
                                  "commonMistakes": [
                                    "k muito baixo, risco de pseudoprimos.",
                                    "Loop infinito sem limite de tentativas.",
                                    "Não medir performance."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar adequação do primo para criptografia",
                                  "subSteps": [
                                    "Confirmar probabilidade de primalidade > 1-2^-100.",
                                    "Verificar se primo é 'forte' (Sophie Germain opcional para Diffie-Hellman).",
                                    "Testar resistência básica: não divisível por primos pequenos (<10^6).",
                                    "Analisar tempo de geração e tamanho.",
                                    "Documentar o processo em relatório."
                                  ],
                                  "verification": "Produzir relatório com primo, stats e validação externa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código completo, ferramenta como factordb.com para checagem."
                                  ],
                                  "tips": "Use múltiplos witnesses recomendados por FIPS 186-4 para padrões cripto.",
                                  "learningObjective": "Avaliar se o primo gerado atende requisitos de segurança criptográfica.",
                                  "commonMistakes": [
                                    "Aceitar primos fracos sem múltiplos testes.",
                                    "Ignorar checagem de divisores pequenos antes de Miller-Rabin."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python: def miller_rabin(n, k=40): ... Em seguida, def generate_prime(bits=1024): while True: n = random.getrandbits(bits) | 1; if n % 2 == 0: continue; if miller_rabin(n, k): return n. Exemplo de saída: Primo de 1024 bits: 0xC3A7F2D9... (309 dígitos). Tempo médio: 0.5s em CPU moderna.",
                              "finalVerifications": [
                                "O algoritmo Miller-Rabin identifica corretamente primos e compostos em testes unitários.",
                                "Primo gerado tem exatamente 1024 bits e passa 40 iterações com witnesses fortes.",
                                "Probabilidade de erro < 2^-80, adequada para criptografia.",
                                "Geração completa em <5 minutos, com <10000 tentativas.",
                                "Validação externa (ex: sympy ou OpenSSL) confirma primalidade.",
                                "Relatório documenta stats e código fonte."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% acerto em benchmarks conhecidos.",
                                "Eficiência: Tempo de teste Miller-Rabin <1ms por candidato.",
                                "Segurança: Uso de witnesses suficientes para erro negligible.",
                                "Escalabilidade: Funciona para 1024+ bits sem modificações.",
                                "Documentação: Código comentado e relatório claro.",
                                "Robustez: Trata edge cases (n<2, n par)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primalidade, módulo).",
                                "Probabilidade: Análise de erro probabilístico.",
                                "Algoritmos: Exponenciação modular eficiente.",
                                "Segurança da Informação: Fundamentos de criptografia assimétrica.",
                                "Programação: Manipulação de big integers em Python."
                              ],
                              "realWorldApplication": "Geração de chaves primas para RSA (ex: certificados SSL/TLS), Diffie-Hellman (VPNs), assinatura digital (blockchain), garantindo segurança contra fatoração em computadores atuais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Aplicar algoritmos probabilísticos na geração",
                            "description": "Implementar conceitualmente a geração probabilística de parâmetros, diferenciando de métodos determinísticos e justificando o uso de aleatoriedade para resistir a ataques.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Diferenciar métodos determinísticos de probabilísticos na geração de parâmetros criptográficos",
                                  "subSteps": [
                                    "Revise conceitos básicos de geração determinística: funções fixas baseadas em sementes previsíveis ou sequências fixas.",
                                    "Estude geração probabilística: uso de geradores de números aleatórios (RNG) para introduzir entropia.",
                                    "Analise exemplos: geração de primos em RSA determinística (testes exaustivos) vs probabilística (Miller-Rabin).",
                                    "Compare vantagens: determinístico é reproduzível, probabilístico resiste a ataques de canal lateral.",
                                    "Documente diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 5 diferenças chave listadas e explicadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de criptografia (RFC 6979, manuais OpenSSL), editor de texto.",
                                  "tips": "Use diagramas de fluxo para visualizar o processo de geração em cada método.",
                                  "learningObjective": "Compreender as diferenças fundamentais e implicações de segurança entre abordagens determinísticas e probabilísticas.",
                                  "commonMistakes": "Confundir aleatoriedade com imprevisibilidade; ignorar que determinístico pode ser seguro se a semente for secreta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar algoritmos probabilísticos específicos para geração de parâmetros",
                                  "subSteps": [
                                    "Aprenda sobre testes de primalidade probabilísticos como Miller-Rabin e sua dependência em witnesses aleatórios.",
                                    "Explore geração de números aleatórios criptograficamente seguros (CSPRNG) como /dev/urandom ou Fortuna.",
                                    "Analise o algoritmo para geração de primos seguros: selecione candidato aleatório, teste probabilisticamente.",
                                    "Estude justificação teórica: probabilidade de erro < 4^{-t} para t iterações.",
                                    "Implemente pseudocódigo para Miller-Rabin com aleatoriedade."
                                  ],
                                  "verification": "Pseudocódigo funcional para Miller-Rabin com pelo menos 3 witnesses aleatórios.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livros de criptografia (Handbook of Applied Cryptography), Python com biblioteca sympy para testes.",
                                  "tips": "Comece com pequenos números para testar e visualize distribuições de aleatoriedade.",
                                  "learningObjective": "Dominar algoritmos probabilísticos chave e sua implementação conceitual.",
                                  "commonMistakes": "Usar RNG não criptográfico (rand() em C); subestimar número de iterações necessárias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar conceitualmente geração probabilística de parâmetros iniciais",
                                  "subSteps": [
                                    "Defina parâmetros: tamanho de bits (ex: 1024 para p em RSA), fonte de entropia.",
                                    "Gere candidato aleatório no intervalo [2^{n-1}, 2^n -1].",
                                    "Aplique testes probabilísticos iterativamente até encontrar primo provável.",
                                    "Integre com geração de chaves: gere p e q probabilisticamente para n = p*q.",
                                    "Simule em código ou diagrama o processo completo."
                                  ],
                                  "verification": "Diagrama ou código conceitual que gera um primo provável de 512 bits com sucesso.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Ambiente Python/Jupyter com sympy ou gmpy2, gerador de aleatoriedade seguro.",
                                  "tips": "Monitore tempo de execução para otimizar número de iterações.",
                                  "learningObjective": "Aplicar algoritmos probabilísticos para gerar parâmetros criptográficos viáveis.",
                                  "commonMistakes": "Selecionar candidatos pares ou divisíveis por pequenos primos; não validar tamanho do primo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar o uso de aleatoriedade e analisar resistência a ataques",
                                  "subSteps": [
                                    "Explique como aleatoriedade impede ataques de predição ou exaustão.",
                                    "Discuta ataques contra determinístico: reutilização de chaves se semente comprometida.",
                                    "Analise benefícios probabilísticos: chaves únicas por execução, resistência a side-channels.",
                                    "Compare métricas: entropia, probabilidade de colisão, tempo de geração.",
                                    "Escreva relatório justificando escolha probabilística para cenários reais."
                                  ],
                                  "verification": "Relatório de 300 palavras com análise de pelo menos 2 ataques mitigados pela aleatoriedade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre falhas em RNG (Dual_EC_DRBG), ferramentas de análise de entropia (ent).",
                                  "tips": "Use exemplos históricos como Debian OpenSSL bug para ilustrar riscos.",
                                  "learningObjective": "Justificar probabilisticamente o design seguro de geração de chaves.",
                                  "commonMistakes": "Ignorar entropia insuficiente em ambientes virtuais; superestimar segurança de testes únicos."
                                }
                              ],
                              "practicalExample": "Em RSA, gere p como primo de 1024 bits: selecione r aleatório em [2^1023, 2^1024-1], teste Miller-Rabin com 40 witnesses aleatórios até passar; repita para q, então n=p*q. Isso garante chaves únicas resistentes a ataques de fatoração conhecidos.",
                              "finalVerifications": [
                                "Geração bem-sucedida de primo provável com probabilidade de erro < 2^{-80}.",
                                "Código/diagrama diferencia corretamente determinístico vs probabilístico.",
                                "Justificativa inclui pelo menos 3 ataques mitigados pela aleatoriedade.",
                                "Parâmetros gerados atendem standards (ex: FIPS 186-4).",
                                "Análise de entropia confirma CSPRNG usado.",
                                "Tempo de geração razoável (<1s para 1024 bits em hardware moderno)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% diferenciação correta entre métodos.",
                                "Detalhe na implementação: pseudocódigo completo e testável.",
                                "Profundidade de justificativa: análise quantitativa de segurança.",
                                "Criatividade em exemplos: aplicação realista ao contexto de chaves públicas.",
                                "Completude: todos substeps e verificações atendidos.",
                                "Clareza: explicações acessíveis sem jargão excessivo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (primalidade, testes probabilísticos).",
                                "Probabilidade e Estatística: Análise de erros em testes Monte Carlo.",
                                "Segurança da Informação: Modelos de ameaça e criptoanálise.",
                                "Programação: Implementação de algoritmos em linguagens seguras."
                              ],
                              "realWorldApplication": "Na geração de certificados TLS/SSL em navegadores e servidores, algoritmos probabilísticos como em OpenSSL garantem chaves efêmeras únicas por sessão, prevenindo ataques como Logjam ou reutilização de chaves em ataques nation-state."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Verificar propriedades dos parâmetros",
                            "description": "Avaliar critérios como tamanho mínimo dos primos, diferença entre eles (para RSA) e resistência a ataques como Fermat, garantindo entropia suficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar tamanho mínimo e propriedades básicas dos primos candidatos",
                                  "subSteps": [
                                    "Selecionar primos candidatos p e q com pelo menos 1024 bits cada (para RSA moderno).",
                                    "Confirmar que ambos são ímpares e congruentes a 3 mod 4 (recomendado para otimização).",
                                    "Calcular o módulo n = p * q e verificar se tem o tamanho esperado (ex: 2048 bits).",
                                    "Garantir que p e q não sejam muito próximos do quadrado de uma raiz inteira.",
                                    "Documentar os valores de bit length usando funções como bit_length() em Python."
                                  ],
                                  "verification": "Executar len(bin(p)) - 2 >= 1024 e similar para q; imprimir n.bit_length() == 2048.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com bibliotecas sympy ou gmpy2; calculadora de bits.",
                                  "tips": "Use geradores de primos seguros como sympy.nextprime() para candidatos iniciais.",
                                  "learningObjective": "Compreender por que primos grandes previnem ataques de força bruta e fatoração.",
                                  "commonMistakes": "Escolher primos pequenos (abaixo de 1024 bits) ou pares (primos >2 são ímpares)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a diferença absoluta entre os primos p e q",
                                  "subSteps": [
                                    "Calcular diff = |p - q|.",
                                    "Verificar se diff > 2^(bit_length/4) (ex: para 1024 bits, diff > 2^256).",
                                    "Garantir que diff não seja muito pequeno para evitar Fermat factoring.",
                                    "Testar múltiplas faixas: diff deve ser pelo menos 100 bits de diferença.",
                                    "Registrar a razão diff / min(p,q) > 1/2^100."
                                  ],
                                  "verification": "Assert diff.bit_length() >= 100 e diff > threshold calculado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python interpreter; função abs(p - q).",
                                  "tips": "Primos próximos facilitam ataques; mire em diferenças aleatórias e grandes.",
                                  "learningObjective": "Identificar vulnerabilidades em pares de primos próximos para segurança RSA.",
                                  "commonMistakes": "Ignorar a diferença, assumindo que primos aleatórios sempre são distantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar resistência a ataques probabilísticos como Fermat e Miller-Rabin",
                                  "subSteps": [
                                    "Implementar ou usar teste de Fermat: verificar a^(n-1) ≡ 1 mod n para bases aleatórias a.",
                                    "Executar Miller-Rabin com 40+ iterações e bases fortes (2,3,5,...).",
                                    "Verificar falhas em testes conhecidos como Solovay-Strassen se disponível.",
                                    "Rodar pelo menos 100 rodadas de testes compostos para confiança > 2^-80.",
                                    "Rejeitar candidatos que falhem qualquer teste."
                                  ],
                                  "verification": "Biblioteca retorna True para is_prime(p, confidence=80); nenhum erro em logs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Sympy (sympy.isprime()) ou código custom Miller-Rabin.",
                                  "tips": "Testes determinísticos para tamanhos < 2^64; probabilísticos para maiores.",
                                  "learningObjective": "Aplicar testes de primalidade para detectar números compostos disfarçados.",
                                  "commonMistakes": "Usar apenas teste de divisibilidade simples, ignorando testes avançados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir entropia suficiente na geração e propriedades finais",
                                  "subSteps": [
                                    "Verificar fonte de entropia: usar /dev/urandom ou secrets module em Python.",
                                    "Calcular entropia de Shannon ou min-entropy dos candidatos (> 0.99 bits/bit).",
                                    "Confirmar ausência de bias: histograma de bits deve ser uniforme.",
                                    "Testar para low Hamming weight ou padrões previsíveis.",
                                    "Gerar relatório final com métricas de entropia."
                                  ],
                                  "verification": "Ferramentas como ent (entropia tester) mostram chi-square p-value > 0.01.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python secrets/os.urandom; ferramentas dieharder ou NIST STS.",
                                  "tips": "Nunca use random() para chaves; sempre criptograficamente seguro.",
                                  "learningObjective": "Avaliar qualidade de aleatoriedade para prevenir side-channel attacks.",
                                  "commonMistakes": "Gerar primos com random padrão, levando a entropia baixa."
                                }
                              ],
                              "practicalExample": "Gere p e q como primos de 1024 bits usando sympy.randprime(2**1023, 2**1024). Verifique: p.bit_length()==1024, |p-q|>2**100, sympy.isprime(p, trials=50)==True, e teste entropia com bin(p).count('1') ≈ 512.",
                              "finalVerifications": [
                                "Primos p e q têm >=1024 bits cada.",
                                "Diferença |p-q| > 2^(bits/4).",
                                "Passam Miller-Rabin com 40+ iterações.",
                                "Entropia > 0.99 bits/bit.",
                                "n = p*q tem bit_length() exato e sem fatores óbvios.",
                                "Nenhum teste de primalidade falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de tamanho e diferença (100% correto).",
                                "Implementação correta de testes probabilísticos (sem falsos positivos).",
                                "Uso de fontes de entropia seguras documentadas.",
                                "Relatório completo com verificações e evidências.",
                                "Identificação de pelo menos 3 vulnerabilidades potenciais.",
                                "Tempo dentro do estimado com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (testes de primalidade, congruências).",
                                "Probabilidade: Análise de testes probabilísticos e entropia.",
                                "Segurança da Informação: Vulnerabilidades criptográficas.",
                                "Programação: Implementação eficiente em Python com big integers."
                              ],
                              "realWorldApplication": "Em bibliotecas como OpenSSL ou implementações RSA em browsers/bancos, garantindo chaves resistentes a ataques quânticos iniciais e fatoração clássica, prevenindo roubo de dados em HTTPS/TLS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Cálculo das Chaves Pública e Privada",
                        "description": "Processo algorítmico para derivar a chave pública a partir da privada, usando operações modulares e funções totiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Calcular o módulo e o totiente no RSA",
                            "description": "Computar n = p * q e φ(n) = (p-1)(q-1) a partir de primos selecionados, explicando o papel de n como parte da chave pública.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar primos p e q adequados para RSA",
                                  "subSteps": [
                                    "Identifique critérios para primos em RSA: devem ser grandes (ex: 1024 bits ou mais em produção), primos distintos e gerados de forma segura.",
                                    "Use ferramentas como geradores de primos (ex: OpenSSL ou Python com sympy) para selecionar p e q. Para exemplo educacional, escolha p=61 e q=53.",
                                    "Verifique primalidade usando testes como Miller-Rabin ou divisibilidade por primos pequenos.",
                                    "Registre os valores selecionados em um documento ou caderno para rastreamento.",
                                    "Discuta por que primos grandes evitam fatoração via algoritmos como Pollard's Rho."
                                  ],
                                  "verification": "Confirme que p e q são primos distintos usando um teste de primalidade online ou software, e anote os valores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software Python (sympy.isprime), tabela de primos pequenos para verificação manual"
                                  ],
                                  "tips": "Comece com primos pequenos para prática, mas enfatize escala para aplicações reais.",
                                  "learningObjective": "Entender a importância da escolha de primos seguros na geração de chaves RSA.",
                                  "commonMistakes": [
                                    "Escolher números compostos como 'primos'",
                                    "Selecionar p e q iguais",
                                    "Ignorar tamanho dos primos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o módulo n = p * q",
                                  "subSteps": [
                                    "Multiplique p por q usando multiplicação de números grandes: divida em partes se manual (ex: p=61, q=53 → 61*50=3050, 61*3=183, total 3233).",
                                    "Use software para números grandes (ex: Python int ou BigInteger em Java) se p e q forem >10^100.",
                                    "Anote o resultado de n e verifique multiplicação inversa: fatorar n deve retornar p e q.",
                                    "Explique que n é o módulo para operações modulares em RSA.",
                                    "Teste com exemplo: 61*53=3233."
                                  ],
                                  "verification": "Verifique n / p = q (exato) e n / q = p (exato), sem resto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou Python para multiplicação grande",
                                    "Papel e caneta para cálculo manual"
                                  ],
                                  "tips": "Use Python: n = p * q; print(n) para simplicidade.",
                                  "learningObjective": "Dominar o cálculo preciso do módulo n e seu papel como base para criptografia modular.",
                                  "commonMistakes": [
                                    "Erro aritmético na multiplicação",
                                    "Confundir ordem de p e q",
                                    "Usar números pequenos sem escalar para real"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o totiente φ(n) = (p-1)(q-1)",
                                  "subSteps": [
                                    "Calcule p-1 e q-1 separadamente (ex: 61-1=60, 53-1=52).",
                                    "Multiplique (p-1) por (q-1): similar a step 2, gerencie números grandes.",
                                    "Verifique fórmula: φ(n) conta inteiros coprimos a n até n-1, válida pois p e q primos.",
                                    "Anote φ(n) e confirme com exemplo: 60*52=3120.",
                                    "Explique uso: base para escolher e tal que gcd(e, φ(n))=1."
                                  ],
                                  "verification": "Confirme φ(n) = (p-1)(q-1) e que φ(n) < n, com exemplo numérico batendo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmos da step 2: Python ou calculadora",
                                    "Referência: Teorema de Euler para totiente"
                                  ],
                                  "tips": "Automatize: phi = (p-1)*(q-1) em código para evitar erros manuais.",
                                  "learningObjective": "Compreender e calcular o indicador de Euler φ(n) para RSA.",
                                  "commonMistakes": [
                                    "Esquecer subtrair 1 de p ou q",
                                    "Multiplicar p*q em vez de (p-1)(q-1)",
                                    "Confundir com n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o papel de n na chave pública RSA e verificar o processo",
                                  "subSteps": [
                                    "Descreva: n é publicado na chave pública (n, e), permitindo encriptação sem revelar p/q.",
                                    "Simule: Dado n=3233, e=17, encripte mensagem m=65: c = m^e mod n.",
                                    "Verifique segurança: Fatorar n é difícil para primos grandes.",
                                    "Documente todo processo em relatório: p, q, n, φ(n), explicação.",
                                    "Discuta ataques: se n pequeno, fatorável (ex: Fermat factorization)."
                                  ],
                                  "verification": "Escreva parágrafo explicando n e demonstre encriptação simples com n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python para simular RSA parcial (pow(m, e, n))",
                                    "Documentação escrita"
                                  ],
                                  "tips": "Use exemplos visuais como diagramas de chaves RSA.",
                                  "learningObjective": "Integrar cálculos ao contexto de segurança RSA, enfatizando n público.",
                                  "commonMistakes": [
                                    "Achar n privado",
                                    "Ignorar dificuldade computacional da fatoração",
                                    "Não ligar a encriptação"
                                  ]
                                }
                              ],
                              "practicalExample": "Selecione p=61 (primo), q=53 (primo). n = 61*53 = 3233. φ(n) = 60*52 = 3120. Chave pública: (3233, 17) onde gcd(17,3120)=1. Encripte 'A' (65): 65^17 mod 3233 = 2790.",
                              "finalVerifications": [
                                "n = p * q calculado corretamente sem erros aritméticos.",
                                "φ(n) = (p-1)(q-1) exato e menor que n.",
                                "p e q confirmados como primos via teste.",
                                "Explicação escrita do papel de n na chave pública.",
                                "Simulação de encriptação com n funciona.",
                                "Documentação completa com valores e passos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de n e φ(n) (100% exato).",
                                "Seleção adequada de primos com verificação de primalidade.",
                                "Explicação clara e correta do papel de n (rubrica: 1-5).",
                                "Uso correto de ferramentas para números grandes.",
                                "Compreensão de implicações de segurança (teste conceitual).",
                                "Relatório bem estruturado e completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primalidade, totiente de Euler, fatoração).",
                                "Computação: Algoritmos de multiplicação grande (Karatsuba), programação segura.",
                                "Segurança da Informação: Princípios de criptografia assimétrica.",
                                "Física/Engenharia: Aplicações em comunicações quânticas-resistentes."
                              ],
                              "realWorldApplication": "No RSA, n é essencial para protocolos como HTTPS/TLS em navegadores, assinaturas digitais em blockchain (Bitcoin), e VPNs, protegendo transações bancárias e e-mails contra interceptação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Selecionar e calcular expoentes público e privado",
                            "description": "Escolher e coprimo e calcular d = e^{-1} mod φ(n), demonstrando como a chave privada d permite descriptografar mensagens cifradas com e.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e selecionar o expoente público e coprimo com φ(n)",
                                  "subSteps": [
                                    "Revise o valor de φ(n) calculado anteriormente a partir de p e q primos.",
                                    "Liste os fatores primos de φ(n) para identificar números coprimos.",
                                    "Escolha um e pequeno e comum (ex: 3, 17, 65537) que seja primo e maior que 1.",
                                    "Calcule gcd(e, φ(n)) usando o algoritmo de Euclides para confirmar coprimos.",
                                    "Se gcd ≠ 1, selecione outro e e repita."
                                  ],
                                  "verification": "Confirme que gcd(e, φ(n)) = 1 e anote o par (e, φ(n)).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora gráfica ou software como Python (sympy.gcd), papel e lápis.",
                                  "tips": "Prefira e=65537 para eficiência em aplicações reais, mas use valores pequenos para aprendizado.",
                                  "learningObjective": "Identificar e validar um expoente público válido coprimo com φ(n).",
                                  "commonMistakes": "Escolher e que divide φ(n), ignorando que e deve ser ímpar e >1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o expoente privado d usando inverso modular",
                                  "subSteps": [
                                    "Aplique o Algoritmo Estendido de Euclides para encontrar x tal que e*x ≡ 1 mod φ(n).",
                                    "Execute os passos do algoritmo: divida e por φ(n), rastreie coeficientes.",
                                    "Resolva as equações lineares retroativamente para obter d = x mod φ(n).",
                                    "Garanta que 1 ≤ d < φ(n) ajustando se necessário.",
                                    "Use ferramentas computacionais para validar o resultado manual."
                                  ],
                                  "verification": "Verifique que (e * d) mod φ(n) = 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela para Euclides estendido, Python (sympy.mod_inverse) ou Wolfram Alpha.",
                                  "tips": "Pratique com φ(n) pequeno primeiro; memorize passos do algoritmo estendido.",
                                  "learningObjective": "Dominar o cálculo do inverso modular via Euclides estendido.",
                                  "commonMistakes": "Erros nos coeficientes durante back-substitution, ou esquecer o módulo φ(n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a validade do par de chaves (e, d)",
                                  "subSteps": [
                                    "Calcule e * d e reduza módulo φ(n) para confirmar ≡ 1.",
                                    "Teste propriedades: e deve ser coprimo, d único mod φ(n).",
                                    "Gere a chave pública (n, e) e privada (n, d).",
                                    "Simule uma exponenciação modular simples para checar.",
                                    "Documente o par completo de chaves."
                                  ],
                                  "verification": "e * d ≡ 1 mod φ(n) e ambos coprimos com n.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora modular, planilha Excel para potências.",
                                  "tips": "Automatize verificações com código para evitar erros aritméticos.",
                                  "learningObjective": "Validar matematicamente o par de chaves RSA.",
                                  "commonMistakes": "Confundir mod n com mod φ(n) na verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar descriptografia usando a chave privada d",
                                  "subSteps": [
                                    "Escolha uma mensagem m < n (ex: número representando letra).",
                                    "Cifre: c = m^e mod n.",
                                    "Descriptografe: m' = c^d mod n.",
                                    "Compare m' com m original.",
                                    "Repita com múltiplas mensagens para robustez."
                                  ],
                                  "verification": "m' = m para todas mensagens testadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software para exponenciação modular rápida (Python pow(base, exp, mod)).",
                                  "tips": "Use pow(m, e, n) em Python para eficiência em grandes expoentes.",
                                  "learningObjective": "Compreender empiricamente por que d reverte a cifragem e.",
                                  "commonMistakes": "Usar expoentes errados ou esquecer redução módulo n."
                                }
                              ],
                              "practicalExample": "Exemplo: p=61, q=53, n=3233, φ(n)=3120. Escolha e=17 (gcd(17,3120)=1). d=17^{-1} mod 3120=2753 (17*2753=46801, 46801 mod 3120=1). Mensagem m=65, c=65^17 mod 3233=2790, m'=2790^2753 mod 3233=65.",
                              "finalVerifications": [
                                "gcd(e, φ(n))=1 confirmado.",
                                "d calculado satisfaz e*d ≡1 mod φ(n).",
                                "Descriptografia funciona para 3+ mensagens teste.",
                                "Chaves pública (n,e) e privada (n,d) documentadas.",
                                "Explicação verbal do teorema de Euler justifica o processo.",
                                "Sem erros aritméticos em cálculos manuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de gcd e inverso modular (100% correto).",
                                "Explicação clara do papel de φ(n) e coprimos.",
                                "Demonstração bem-sucedida de cifragem/descriptografia.",
                                "Identificação de pelo menos 2 erros comuns evitados.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Conexão com segurança teórica do RSA."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (Euclides, Teorema de Euler).",
                                "Álgebra: Sistemas lineares e módulos.",
                                "Física: Modelos de segurança quântica vs clássica.",
                                "História: Evolução da criptografia (Rivest-Shamir-Adleman)."
                              ],
                              "realWorldApplication": "Geração de chaves RSA para HTTPS/TLS em navegadores, assinatura digital em blockchain, proteção de e-mails (PGP) e autenticação em VPNs, garantindo confidencialidade em comunicações digitais globais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Verificar validade do par de chaves",
                            "description": "Testar se e * d ≡ 1 mod φ(n) e simular uma cifragem/desifragem básica para validar que o par funciona corretamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e revisar os componentes do par de chaves",
                                  "subSteps": [
                                    "Liste os primos p e q usados na geração de n = p * q.",
                                    "Confirme o valor de n e calcule φ(n) = (p-1)*(q-1) se necessário.",
                                    "Identifique a chave pública (e, n) e a privada (d, n).",
                                    "Verifique se e é coprimo com φ(n), i.e., gcd(e, φ(n)) = 1.",
                                    "Registre todos os valores em uma tabela para referência."
                                  ],
                                  "verification": "Todos os componentes estão corretamente listados e φ(n) calculado sem erros aritméticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto; calculadora para multiplicações grandes.",
                                  "tips": "Use uma tabela para organizar: p, q, n, φ(n), e, d.",
                                  "learningObjective": "Entender e reunir todos os pré-requisitos para validação do par de chaves.",
                                  "commonMistakes": "Erro no cálculo de φ(n), como esquecer de subtrair 1 de p e q; confundir e com d."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a condição de inverso modular: e * d ≡ 1 mod φ(n)",
                                  "subSteps": [
                                    "Calcule o produto e * d.",
                                    "Compute (e * d) mod φ(n) usando divisão euclidiana ou algoritmo modular.",
                                    "Confirme se o resultado é exatamente 1.",
                                    "Se não for 1, identifique o erro na geração de d (usando extended Euclidean algorithm).",
                                    "Documente o cálculo passo a passo."
                                  ],
                                  "verification": "O resultado de (e * d) mod φ(n) é igual a 1, com cálculo documentado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora modular ou Python (pow(e*d, 1, phi_n)); papel para passos manuais.",
                                  "tips": "Use o comando Python 'pow(e * d, 1, phi_n)' para verificação rápida.",
                                  "learningObjective": "Dominar a verificação matemática fundamental da corretude do par de chaves.",
                                  "commonMistakes": "Erro em operações modulares; esquecer de reduzir o produto antes do mod."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular cifragem de uma mensagem de teste",
                                  "subSteps": [
                                    "Escolha uma mensagem m onde 0 < m < n (ex: m=42).",
                                    "Calcule a cifra c = m^e mod n.",
                                    "Registre m, e, n e o resultado c.",
                                    "Verifique se c está entre 0 e n-1.",
                                    "Teste com pelo menos duas mensagens diferentes para robustez."
                                  ],
                                  "verification": "Cálculo de c = m^e mod n é correto e documentado para múltiplas mensagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de exponenciação modular (Python: pow(m, e, n)); calculadora.",
                                  "tips": "Sempre use exponenciação modular eficiente para evitar números grandes.",
                                  "learningObjective": "Aplicar a chave pública para cifragem correta.",
                                  "commonMistakes": "Escolher m >= n; erros em exponenciação sem redução modular."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular desifragem e validar recuperação da mensagem",
                                  "subSteps": [
                                    "Usando c da etapa anterior, calcule m' = c^d mod n.",
                                    "Compare m' com a mensagem original m.",
                                    "Confirme m' == m para todas as mensagens testadas.",
                                    "Analise qualquer discrepância e corrija.",
                                    "Conclua com uma declaração de validade do par."
                                  ],
                                  "verification": "Todas as mensagens são perfeitamente recuperadas (m' == m).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo software da cifragem (Python: pow(c, d, n)).",
                                  "tips": "Teste mensagens variadas, incluindo próximas de n, para detectar falhas.",
                                  "learningObjective": "Confirmar funcionalidade completa do par de chaves via ciclo cifrar-desifrar.",
                                  "commonMistakes": "Confundir expoentes e/d; não reduzir mod n corretamente."
                                }
                              ],
                              "practicalExample": "Exemplo: p=5, q=11, n=55, φ(n)=40, e=3, d=27. Verifique: 3*27=81, 81 mod 40=1 ✓. Mensagem m=9: c=9^3 mod55=729 mod55=4. Desifra: 4^27 mod55=9 ✓. m=2: c=8, desifra=2 ✓.",
                              "finalVerifications": [
                                "e * d ≡ 1 mod φ(n) confirmado.",
                                "Pelo menos 3 mensagens cifradas e desifras corretamente recuperadas.",
                                "Todos cálculos documentados sem erros aritméticos.",
                                "Nenhum vazamento de informação na cifra (c != m).",
                                "Par de chaves funciona para mensagens < n.",
                                "Teste com mensagem aleatória próxima de n succeeds."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em todos os cálculos modulares (100%).",
                                "Documentação completa de passos e resultados.",
                                "Uso correto de ferramentas para eficiência.",
                                "Identificação e correção de erros comuns.",
                                "Explicação clara da importância da validação.",
                                "Testes abrangentes com múltiplas mensagens."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (inversos modulares, Euler's totient).",
                                "Matemática: Álgebra Modular e Exponenciação.",
                                "Segurança da Informação: Princípios de Criptografia Assimétrica.",
                                "Programação: Implementação em Python para automação de cálculos."
                              ],
                              "realWorldApplication": "Validação de chaves RSA em protocolos como HTTPS/TLS para comunicações seguras, assinatura digital em certificados SSL, e sistemas de blockchain para transações criptografadas, garantindo que chaves geradas funcionem corretamente antes do uso em produção."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.4",
                            "name": "Discutir generalização para outros sistemas",
                            "description": "Comparar o processo RSA com geração em ElGamal ou ECC, destacando diferenças nos parâmetros e cálculos baseados em log discreto ou curvas elípticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o processo de geração de chaves no RSA",
                                  "subSteps": [
                                    "Relembrar a escolha de dois números primos grandes p e q.",
                                    "Calcular n = p * q e φ(n) = (p-1)*(q-1).",
                                    "Selecionar e coprimo com φ(n) e calcular d = e⁻¹ mod φ(n).",
                                    "Chave pública: (n, e); chave privada: (n, d).",
                                    "Identificar os cálculos baseados em fatoração de inteiros."
                                  ],
                                  "verification": "Escrever um resumo de 5 linhas descrevendo o processo RSA e confirmar que todos os passos estão corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou software como Python para primos"
                                  ],
                                  "tips": "Use números pequenos para testes iniciais, como p=5, q=11.",
                                  "learningObjective": "Compreender os parâmetros e cálculos fundamentais do RSA.",
                                  "commonMistakes": "Confundir φ(n) com n ou escolher e não coprimo com φ(n)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a geração de chaves no ElGamal",
                                  "subSteps": [
                                    "Escolher um primo grande p e um gerador primitivo g no campo Z_p.",
                                    "Selecionar x aleatório (privado) entre 1 e p-2.",
                                    "Calcular y = g^x mod p (pública).",
                                    "Chave pública: (p, g, y); chave privada: x.",
                                    "Destacar o uso do logaritmo discreto."
                                  ],
                                  "verification": "Gerar um exemplo numérico simples com p=23, g=5 e verificar y.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação ElGamal (Wikipedia ou livro de criptografia)",
                                    "Ferramenta online para log discreto"
                                  ],
                                  "tips": "Teste com p pequeno para entender o módulo.",
                                  "learningObjective": "Dominar os parâmetros e o problema do log discreto no ElGamal.",
                                  "commonMistakes": "Escolher g não primitivo ou x maior que p-2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a geração de chaves em ECC (Criptografia de Curvas Elípticas)",
                                  "subSteps": [
                                    "Selecionar uma curva elíptica y² = x³ + ax + b mod p.",
                                    "Escolher ponto base G de ordem grande n.",
                                    "Selecionar d aleatório (privado) entre 1 e n-1.",
                                    "Calcular Q = d * G (pública).",
                                    "Chave pública: (curva, G, Q); privada: d."
                                  ],
                                  "verification": "Desenhar uma curva simples e computar Q para d=2, G=(x,y).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca SageMath ou Python com cryptography",
                                    "Tutoriais ECC como Crypto101"
                                  ],
                                  "tips": "Use curvas padrão como secp256k1 para exemplos reais.",
                                  "learningObjective": "Entender os cálculos baseados no problema do log discreto em curvas elípticas.",
                                  "commonMistakes": "Ignorar a ordem n ou confundir multiplicação escalar com modular."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e discutir generalizações",
                                  "subSteps": [
                                    "Criar uma tabela comparando parâmetros: RSA (p,q,n), ElGamal (p,g,x,y), ECC (curva,G,d,Q).",
                                    "Analisar diferenças nos problemas subjacentes: fatoração vs log discreto vs ECDLP.",
                                    "Discutir eficiência: RSA maior chaves, ECC menor para mesma segurança.",
                                    "Generalizar: Todos baseados em problemas difíceis; trade-offs em performance e segurança.",
                                    "Explorar quando usar cada um (ex: ECC em mobile)."
                                  ],
                                  "verification": "Produzir uma tabela de comparação e explicação em 200 palavras.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Artigos comparativos como 'Post-Quantum Crypto'"
                                  ],
                                  "tips": "Use cores na tabela para destacar similaridades/diferenças.",
                                  "learningObjective": "Capacitar a discutir generalizações e escolhas de sistemas.",
                                  "commonMistakes": "Afirmar que RSA usa log discreto (é fatoração)."
                                }
                              ],
                              "practicalExample": "Compare RSA com p=61, q=53 (n=3233) vs ElGamal com p=23, g=5, x=6 (y=8) vs ECC secp256r1 com d=7, G base. Destaque: RSA multiplica primos; ElGamal expoente mod p; ECC multiplica ponto.",
                              "finalVerifications": [
                                "Explicar corretamente os parâmetros de cada sistema sem erros.",
                                "Identificar o problema matemático subjacente de cada um.",
                                "Criar uma tabela de comparação precisa.",
                                "Discutir pelo menos duas vantagens/desvantagens de cada.",
                                "Generalizar para novos sistemas como lattice-based.",
                                "Responder perguntas sobre eficiência computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos parâmetros e cálculos (30%)",
                                "Profundidade na comparação de problemas matemáticos (25%)",
                                "Clareza na tabela e explicações (20%)",
                                "Capacidade de generalização e insights (15%)",
                                "Uso correto de terminologia criptográfica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, log discreto, grupos elípticos)",
                                "Física: Curvas elípticas em mecânica quântica",
                                "História: Evolução da criptografia pós-Enigma",
                                "Informática: Implementação em linguagens como Python/OpenSSL"
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS (RSA/ECC para handshake), Bitcoin (ECC secp256k1 para carteiras), VPNs (ElGamal variantes em IKE), garantindo privacidade em comunicações seguras e blockchain."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Algoritmo RSA",
                    "description": "Princípios do RSA, incluindo escolha de primos, exponenciação modular e operações de encriptação e decriptação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Escolha de Números Primos",
                        "description": "Princípios para seleção de números primos grandes e seguros no algoritmo RSA, incluindo métodos probabilísticos de teste de primalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Explicar a importância de primos grandes no RSA",
                            "description": "Descrever por que o RSA requer números primos grandes e distintos (p e q) para garantir a segurança do módulo n = p*q, destacando a dificuldade de fatoração de números compostos grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Algoritmo RSA",
                                  "subSteps": [
                                    "Revise o funcionamento básico do RSA: chaves pública (e, n) e privada (d, n).",
                                    "Identifique os papéis de p e q como primos secretos.",
                                    "Explique como n é calculado como p * q.",
                                    "Discuta por que n é público, mas p e q devem permanecer privados.",
                                    "Compare com um cofre onde a combinação (p e q) é escondida pelo produto (n)."
                                  ],
                                  "verification": "Resuma em uma frase o papel de p, q e n no RSA.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre RSA (Khan Academy ou YouTube)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas como multiplicação de dois números grandes para visualizar n.",
                                  "learningObjective": "Compreender os componentes essenciais do RSA e sua dependência em primos.",
                                  "commonMistakes": [
                                    "Confundir chaves pública e privada",
                                    "Achar que n é secreto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Base de Segurança: Dificuldade de Fatoração",
                                  "subSteps": [
                                    "Aprenda o que é fatoração: decompor n em p e q.",
                                    "Teste fatoração manual com n pequeno (ex: 15 = 3*5).",
                                    "Discuta por que fatorar n pequeno é fácil, mas grande é computacionalmente caro.",
                                    "Introduza o conceito de complexidade computacional (exponencial vs polinomial).",
                                    "Relacione com o problema da fatoração como 'fácil de multiplicar, difícil de dividir'."
                                  ],
                                  "verification": "Fatore um n pequeno fornecido e explique por que um n de 2048 bits é inviável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para fatoração simples",
                                    "Artigo sobre complexidade da fatoração"
                                  ],
                                  "tips": "Comece com exemplos minúsculos para construir intuição antes de escalar.",
                                  "learningObjective": "Reconhecer que a segurança do RSA repousa na dificuldade de fatorar n sem p e q.",
                                  "commonMistakes": [
                                    "Achar que fatoração é sempre difícil",
                                    "Ignorar o tamanho de n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Necessidade de Primos Grandes e Distintos",
                                  "subSteps": [
                                    "Explique por que p e q devem ser primos: evita fatores extras que facilitam fatoração.",
                                    "Discuta distinção: p ≠ q evita padrões detectáveis e acelera ataques.",
                                    "Calcule tamanho típico: p e q ~1024 bits cada, n ~2048 bits.",
                                    "Compare segurança: n=2048 bits resiste a supercomputadores atuais.",
                                    "Aborde testes de primalidade (ex: Miller-Rabin) para gerar primos grandes."
                                  ],
                                  "verification": "Justifique em 3 pontos por que primos pequenos comprometeriam o RSA.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de geração de primos (ex: Wolfram Alpha)",
                                    "Tabela de tamanhos de chaves RSA"
                                  ],
                                  "tips": "Visualize bits como 'dígitos' para entender escala: 1024 bits = ~10^300.",
                                  "learningObjective": "Explicar precisamente por que primos grandes e distintos são cruciais para n seguro.",
                                  "commonMistakes": [
                                    "Usar primos iguais",
                                    "Subestimar testes de primalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Consequências e Verificações Práticas",
                                  "subSteps": [
                                    "Simule ataque em RSA com primos pequenos usando ferramenta online.",
                                    "Gere um par p, q pequeno, calcule n e fatora de volta.",
                                    "Discuta ataques reais: Fermat, Pollard's rho em n fracos.",
                                    "Explore impacto: quebra de RSA expõe comunicações seguras.",
                                    "Conclua com recomendação: use bibliotecas como OpenSSL para primos seguros."
                                  ],
                                  "verification": "Crie um exemplo RSA fraco, fature-o e explique a vulnerabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com sympy para fatoração",
                                    "Simulador RSA online"
                                  ],
                                  "tips": "Registre tempo de fatoração para comparar pequeno vs simulação grande.",
                                  "learningObjective": "Aplicar conhecimento para demonstrar riscos de primos inadequados.",
                                  "commonMistakes": [
                                    "Não testar distinção de p e q",
                                    "Ignorar overhead computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere p=61 (primo), q=53 (primo distinto), n=3233. Explique que fatorar 3233 manualmente é viável (61*53), mas para p=2^1024 + algo e q similar, n resiste a bilhões de anos de computação. Demonstre em Python: fatorar n pequeno leva segundos, simule grande como impossível.",
                              "finalVerifications": [
                                "Explica verbalmente o papel de p, q e n no RSA.",
                                "Identifica corretamente a dificuldade da fatoração como base de segurança.",
                                "Justifica uso de primos grandes com exemplo numérico.",
                                "Diferencia impactos de primos pequenos vs grandes.",
                                "Descreve testes de primalidade básicos.",
                                "Simula um ataque bem-sucedido em RSA fraco."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de n = p*q e segredo de p/q (90%+ correto).",
                                "Compreensão profunda da complexidade da fatoração (exemplos concretos).",
                                "Explicação clara de 'primos grandes' com métricas (bits, tempo).",
                                "Identificação de erros comuns em escolha de primos.",
                                "Uso de analogias e exemplos práticos eficazes.",
                                "Conexão com segurança real-world sem exageros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primalidade, fatoração).",
                                "Computação: Algoritmos e Complexidade (P vs NP).",
                                "Física: Computação Quântica (Shor's algorithm ameaça RSA).",
                                "História: Evolução da Criptografia (de Enigma a RSA).",
                                "Ética: Implicações de segurança digital em privacidade."
                              ],
                              "realWorldApplication": "No HTTPS (TLS/SSL), bancos usam RSA com primos de 2048+ bits para negociações seguras de chaves; assinaturas digitais em software (ex: código Microsoft) dependem disso para verificar autenticidade, protegendo transações globais de bilhões de dólares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Aplicar testes probabilísticos de primalidade",
                            "description": "Utilizar algoritmos como Miller-Rabin para verificar se um número grande é primo com alta probabilidade, simulando a geração de primos seguros para RSA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Teóricos do Teste Miller-Rabin",
                                  "subSteps": [
                                    "Estude o Pequeno Teorema de Fermat: Para primo p e a não múltiplo de p, a^{p-1} ≡ 1 mod p.",
                                    "Aprenda a decomposição de n-1 = 2^s * d, onde d é ímpar.",
                                    "Entenda o conceito de testemunha: Para base a, compute a^d mod n e quadrados sucessivos até 2^r * d.",
                                    "Saiba que se para alguma a, não satisfaz as condições, n é composto; senão, provavelmente primo.",
                                    "Analise a probabilidade de erro: Com k testemunhas aleatórias, erro < 4^{-k}."
                                  ],
                                  "verification": "Explique em um parágrafo os passos matemáticos do algoritmo e resolva manualmente para n=91 e a=2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação oficial do Miller-Rabin (Wikipedia ou paper original)",
                                    "Calculadora modular online",
                                    "Vídeo tutorial sobre testes de primalidade probabilísticos"
                                  ],
                                  "tips": "Comece com exemplos pequenos para visualizar os quadrados sucessivos; use Python para computações modulares grandes.",
                                  "learningObjective": "Dominar os princípios matemáticos que garantem a corretude probabilística do teste.",
                                  "commonMistakes": [
                                    "Confundir com o teste determinístico de Fermat",
                                    "Ignorar a necessidade de múltiplas testemunhas para alta confiança",
                                    "Erro na decomposição de n-1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Algoritmo Miller-Rabin em Python",
                                  "subSteps": [
                                    "Defina funções auxiliares: pow_mod(base, exp, mod) para exponenciação modular eficiente.",
                                    "Escreva função para decompor n-1 em s e d.",
                                    "Implemente a função witness(a, n, s, d): Verifique condições de primalidade para uma base a.",
                                    "Crie a função principal is_probable_prime(n, k): Escolha k bases aleatórias e teste.",
                                    "Adicione tratamento de casos base: n < 2 composto, n=2,3 primo; pares ímpares."
                                  ],
                                  "verification": "Execute o código para n=561 (número de Carmichael) com k=10; deve detectar como composto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3 com bibliotecas random e math",
                                    "Editor de código como VS Code",
                                    "Exemplos de código open-source de Miller-Rabin"
                                  ],
                                  "tips": "Use pow(a, b, n) built-in do Python para eficiência; teste com k=1 primeiro para depuração.",
                                  "learningObjective": "Desenvolver uma implementação funcional e eficiente do teste.",
                                  "commonMistakes": [
                                    "Não usar exponenciação modular (leva a overflow)",
                                    "Escolher bases múltiplas de n",
                                    "Esquecer de verificar se n é par"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar e Validar o Algoritmo com Conjuntos Conhecidos",
                                  "subSteps": [
                                    "Compile listas de primos pequenos (ex: 2,3,5,...,10007) e compostos (ex: 91,561,1105).",
                                    "Execute testes com k=5,10,20 e registre falsos positivos/negativos.",
                                    "Meça performance: Tempo para n de 100, 1000, 1024 bits.",
                                    "Compare com bibliotecas como sympy.isprime() para validação.",
                                    "Analise probabilidade: Simule 1000 testes em pseudoprimos fortes."
                                  ],
                                  "verification": "Gere relatório com tabela de resultados: 100% acerto em 50 números conhecidos; tempo <1s para 1024 bits.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Listas de primos e compostos (de sites como OEIS)",
                                    "Biblioteca sympy para comparação",
                                    "Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Use witnesses fixas determinísticas para números < 2^64 para testes reproducíveis.",
                                  "learningObjective": "Garantir confiabilidade através de testes extensivos.",
                                  "commonMistakes": [
                                    "Usar k muito baixo levando a falsos positivos",
                                    "Não testar números grandes",
                                    "Ignorar overflow em linguagens sem bigints"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Geração de Primos Seguros para RSA",
                                  "subSteps": [
                                    "Implemente função generate_prime(bits): Gere candidato randômico ímpar de tamanho bits.",
                                    "Aplique Miller-Rabin com k=40 até encontrar provável primo.",
                                    "Gere par p,q e n=p*q; verifique tamanho e primalidade.",
                                    "Simule chaves RSA: Compute phi(n), e=65537, d inverso modular.",
                                    "Avalie segurança: Probabilidade de n não primo < 2^{-128} com k=40.",
                                    "verification: "
                                  ],
                                  "Gere e exiba um primo de 1024 bits e n RSA; confirme com ferramenta externa (ex: openssl prime).estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca cryptography ou pycryptodome para comparação",
                                    "Ferramenta openssl para validação",
                                    "Documentação RSA FIPS 186-4"
                                  ],
                                  "tips": "Aumente k para números maiores; use trial division primeiro para fatores pequenos.",
                                  "learningObjective": "Integrar o teste em pipeline de geração de chaves criptográficas.",
                                  "commonMistakes": [
                                    "Gerar primos muito pequenos para RSA moderno",
                                    "Não verificar se p e q são distintos",
                                    "Subestimar k necessário para segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente Miller-Rabin para testar se n = 2**64 - 59 (um primo conhecido de 64 bits) é primo com k=20 testemunhas aleatórias. Em seguida, tente enganar com n=561 e mostre que é detectado como composto após poucas testemunhas.",
                              "finalVerifications": [
                                "O código corretamente classifica 20 primos e 20 compostos conhecidos como Miller-Rabin.",
                                "Gera um provável primo de 1024 bits em <10 segundos.",
                                "Explica a probabilidade de erro para k=40 (< 2^{-80}).",
                                "Integra em função RSA que gera n sem fatores pequenos.",
                                "Relatório inclui tempos de execução e análise de falsos positivos.",
                                "Validação cruzada com sympy ou openssl confirma resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% em testes padrão; erro probabilístico entendido.",
                                "Eficiência: Exponenciação modular O(log n); tempo escalável.",
                                "Código: Limpo, comentado, com funções modulares e tratamento de erros.",
                                "Compreensão: Explicação teórica correta em relatório.",
                                "Aplicação: Geração bem-sucedida de chaves RSA simuladas.",
                                "Análise: Métricas de performance e segurança documentadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática - Teoria dos Números: Teoremas de Fermat e Euler.",
                                "Probabilidade e Estatística: Análise de erro probabilístico.",
                                "Programação: Algoritmos eficientes e big integers.",
                                "Segurança da Informação: Geração de chaves criptográficas.",
                                "Física Computacional: Simulações de sistemas quânticos resistentes."
                              ],
                              "realWorldApplication": "No algoritmo RSA usado em HTTPS, VPNs e assinaturas digitais, testes como Miller-Rabin permitem gerar primos de 2048+ bits rapidamente (segundos vs. dias determinísticos), garantindo chaves seguras para bilhões de transações diárias sem comprometer a probabilidade de erro abaixo de níveis quânticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Calcular o módulo n",
                            "description": "Multiplicar dois primos grandes p e q para obter n, entendendo que n é público e sua fatoração é computacionalmente inviável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Papel do Módulo n no RSA",
                                  "subSteps": [
                                    "Estude a definição de n como o produto de dois primos grandes distintos p e q.",
                                    "Aprenda que n é publicado como parte da chave pública, enquanto p e q permanecem secretos.",
                                    "Entenda o teorema fundamental da aritmética: todo inteiro tem fatoração única em primos.",
                                    "Pesquise a complexidade computacional da fatoração de n grandes (ex: milhões de bits).",
                                    "Compare com exemplos pequenos para visualizar a escalabilidade da dificuldade."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que n é seguro apesar de ser público.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial do RSA (Wikipedia ou Khan Academy)",
                                    "Vídeo introdutório sobre RSA (5-10 min)"
                                  ],
                                  "tips": "Foque na assimetria: fácil multiplicar, difícil fatorar.",
                                  "learningObjective": "Dominar o fundamento matemático e de segurança de n em criptosistemas assimétricos.",
                                  "commonMistakes": [
                                    "Confundir n com φ(n)",
                                    "Acreditar que n deve ser primo",
                                    "Subestimar o tamanho necessário para p e q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Primos Grandes p e q Apropriados",
                                  "subSteps": [
                                    "Revise testes de primalidade simples (divisibilidade por primos menores).",
                                    "Escolha p e q com pelo menos 512 bits cada (use geradores online para prática).",
                                    "Garanta que p e q sejam primos distintos e de tamanho similar.",
                                    "Verifique se p-1 e q-1 têm fatores grandes (para φ(n) seguro).",
                                    "Documente a escolha com justificativa de primalidade."
                                  ],
                                  "verification": "Liste p e q escolhidos e prove que são primos usando um teste básico ou ferramenta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de primos (ex: Wolfram Alpha)",
                                    "Biblioteca Python sympy.isprime()"
                                  ],
                                  "tips": "Para prática inicial, use primos de 100-200 bits; escale para maiores.",
                                  "learningObjective": "Selecionar primos adequados para garantir a segurança de n.",
                                  "commonMistakes": [
                                    "Escolher números pares ou divisíveis por pequenos primos",
                                    "Usar p = q",
                                    "Ignorar o tamanho equilibrado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular n = p × q",
                                  "subSteps": [
                                    "Represente p e q em formato de big integers (use calculadora ou script).",
                                    "Execute a multiplicação direta: n = p * q.",
                                    "Verifique o resultado com divisão inversa parcial (n / p deve dar q).",
                                    "Armazene n em formato hexadecimal ou decimal para uso posterior.",
                                    "Teste com múltiplos tamanhos para observar crescimento exponencial."
                                  ],
                                  "verification": "Confirme que p * q = n e q * p = n (comutatividade).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com int nativo para big numbers",
                                    "Calculadora gráfica ou Wolfram Alpha"
                                  ],
                                  "tips": "Use linguagens com suporte nativo a big ints como Python para evitar overflow.",
                                  "learningObjective": "Executar multiplicação precisa de primos grandes para formar n.",
                                  "commonMistakes": [
                                    "Overflow em linguagens com ints limitados",
                                    "Erros de digitação em números grandes",
                                    "Confundir multiplicação com exponenciação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedades e Entender Segurança de n",
                                  "subSteps": [
                                    "Calcule o tamanho de n em bits (aprox. soma dos bits de p e q).",
                                    "Tente fatorar n manualmente ou com ferramentas para números pequenos.",
                                    "Discuta ataques conhecidos (ex: Fermat, Pollard's rho) e por que falham para n grandes.",
                                    "Compare tempo de multiplicação vs. fatoração estimado.",
                                    "Prepare n para próximo passo do RSA (calcular φ(n))."
                                  ],
                                  "verification": "Demonstre uma tentativa falha de fatoração e explique o motivo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de fatoração online (para pequenos n)",
                                    "Artigo sobre complexidade de fatoração (GNFS)"
                                  ],
                                  "tips": "Use n pequeno para fatorar e extrapole para 2048 bits (anos de computação).",
                                  "learningObjective": "Validar n e internalizar a base da segurança RSA.",
                                  "commonMistakes": [
                                    "Achar fatoração trivial para todos n",
                                    "Ignorar requisitos de tamanho",
                                    "Revelar p/q acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Selecione p = 61 (primo) e q = 53 (primo). Calcule n = 61 × 53 = 3233. Fatore 3233 de volta: teste divisores até √3233 ≈ 56,8, encontrando 53 × 61. Para p/q de 1024 bits, n tem 2048 bits e fatoração exige supercomputadores por anos.",
                              "finalVerifications": [
                                "Calcula n corretamente para p/q dados de 100+ bits.",
                                "Explica verbalmente a inviabilidade computacional da fatoração.",
                                "Seleciona p/q primos sem erros comuns.",
                                "Verifica n com multiplicação inversa.",
                                "Discute impacto do tamanho de n na segurança.",
                                "Prepara n para φ(n) sem vazamento de segredos."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na multiplicação p × q.",
                                "Seleção correta de primos grandes e distintos.",
                                "Compreensão demonstrada da segurança via fatoração difícil.",
                                "Uso adequado de ferramentas para big integers.",
                                "Verificações completas de propriedades de n.",
                                "Explicação clara de conceitos em relatório curto."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Aritmética Modular.",
                                "Computação: Algoritmos de Primalidade e Big Integer Arithmetic.",
                                "Segurança da Informação: Criptografia Assimétrica e Ataques de Fatoração.",
                                "Física/Engenharia: Complexidade Computacional e Hardware para Cripto."
                              ],
                              "realWorldApplication": "n forma a base da chave pública RSA usada em HTTPS/SSL para sites seguros, VPNs, assinaturas digitais em software (ex: códigos de atualização do Windows) e criptomoedas como Bitcoin para transações seguras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Exponenciação Modular",
                        "description": "Operação fundamental no RSA para computar potências eficientemente em aritmética modular.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Compreender exponenciação modular",
                            "description": "Definir a^b mod n e explicar sua relevância no RSA devido ao teorema de Euler e à propriedade de que (m^e)^d ≡ m mod n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Básica de Exponenciação Modular",
                                  "subSteps": [
                                    "Leia a definição: a^b mod n é o resto da divisão de a elevado à potência b por n.",
                                    "Entenda que computamos potências grandes sem calcular o número inteiro completo, reduzindo módulo n a cada multiplicação.",
                                    "Pratique com expoentes pequenos: calcule 3^4 mod 7 manualmente.",
                                    "Compare com exponenciação comum para destacar a diferença na redução de tamanho.",
                                    "Anote a fórmula geral e um pseudocódigo simples para iteração."
                                  ],
                                  "verification": "Calcule corretamente 2^5 mod 11 (resultado: 32 mod 11 = 10) e explique o processo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Sempre reduza o módulo após cada multiplicação para evitar números grandes.",
                                  "learningObjective": "Definir precisamente a^b mod n e realizar cálculos básicos.",
                                  "commonMistakes": [
                                    "Calcular a^b completamente antes do mod n",
                                    "Esquecer de reduzir intermediariamente",
                                    "Confundir base e expoente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Propriedades e o Teorema de Euler",
                                  "subSteps": [
                                    "Estude a propriedade: se gcd(a, n) = 1, então a^{φ(n)} ≡ 1 mod n, onde φ é a função totiente de Euler.",
                                    "Calcule φ(n) para n = p*q (primos distintos) como (p-1)(q-1).",
                                    "Demonstre com exemplo: para n=15 (3*5), φ(15)=8, verifique 2^8 mod 15 = 1.",
                                    "Entenda redução de expoente: a^b mod n = a^{b mod φ(n)} mod n se gcd(a,n)=1.",
                                    "Registre exemplos onde gcd(a,n)>1 e note que a propriedade pode falhar."
                                  ],
                                  "verification": "Explique o Teorema de Euler e calcule φ(35) = 24, verificando 3^{24} mod 35 ≡ 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de função totiente",
                                    "Papel para cálculos"
                                  ],
                                  "tips": "Verifique sempre se a e n são coprimos antes de aplicar Euler.",
                                  "learningObjective": "Compreender e aplicar o Teorema de Euler na exponenciação modular.",
                                  "commonMistakes": [
                                    "Aplicar Euler sem coprimos",
                                    "Erro no cálculo de φ(n)",
                                    "Confundir φ(n) com n-1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Computação Eficiente com Exponenciação Rápida",
                                  "subSteps": [
                                    "Aprenda o algoritmo de exponenciação por quadrado: divida expoente em binário.",
                                    "Exemplo: 5^13 mod 17 – converta 13 para binário (1101), compute quadrados e multiplique.",
                                    "Implemente passo a passo: inicialize resultado=1, processe bits do expoente da MSB.",
                                    "Teste com 7^11 mod 13.",
                                    "Compare tempo com método ingênuo para grandes expoentes."
                                  ],
                                  "verification": "Compute 3^19 mod 23 usando exponenciação rápida e obtenha 18.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha para binário"
                                  ],
                                  "tips": "Use representação binária do expoente para minimizar multiplicações (O(log b)).",
                                  "learningObjective": "Dominar método eficiente para potências grandes.",
                                  "commonMistakes": [
                                    "Erro na ordem dos bits binários",
                                    "Esquecer de modular após quadrado",
                                    "Multiplicar incorretamente nos bits 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar Exponenciação Modular ao Algoritmo RSA",
                                  "subSteps": [
                                    "Revise RSA: chaves pública (e,n), privada (d,n); cripto m^e mod n, decripto (m^e)^d mod n = m.",
                                    "Explique por que funciona: pela propriedade (m^e)^d ≡ m mod n via Euler, já que ed ≡ 1 mod φ(n).",
                                    "Simule mini-RSA: p=5, q=11, n=55, φ=40, e=3, d=27; criptografe m=9.",
                                    "Verifique decripto: 9^3 mod 55 = 729 mod 55 = 44; 44^27 mod 55 = 9.",
                                    "Discuta segurança: dificuldade de fatorar n grande torna d secreto."
                                  ],
                                  "verification": "Explique a equação fundamental do RSA e simule um ciclo completo de cripto/decripto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de RSA impressos",
                                    "Software como Python para verificação opcional"
                                  ],
                                  "tips": "Lembre: eficiência da exponenciação modular permite chaves grandes viáveis.",
                                  "learningObjective": "Relacionar exponenciação modular à segurança do RSA.",
                                  "commonMistakes": [
                                    "Confundir e e d",
                                    "Ignorar coprimalidade de m e n",
                                    "Erro na escolha de primos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em RSA com n=3233 (53*61), φ(n)=3120, e=17, d=2753. Para mensagem m=65, c=65^17 mod 3233=2790; decripto 2790^2753 mod 3233=65, usando exponenciação rápida para viabilidade computacional.",
                              "finalVerifications": [
                                "Definir corretamente a^b mod n com exemplo numérico.",
                                "Explicar Teorema de Euler e calcular φ(n) para n composto.",
                                "Realizar exponenciação modular eficiente para b>100.",
                                "Simular ciclo RSA completo com números pequenos.",
                                "Discutir por que (m^e)^d ≡ m mod n.",
                                "Identificar quando Euler não se aplica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculos (sem erros aritméticos).",
                                "Compreensão conceitual de propriedades (Euler e redução).",
                                "Eficiência no uso de algoritmos (exponenciação rápida).",
                                "Conexão clara com RSA e segurança.",
                                "Explicações claras e exemplos originais.",
                                "Identificação de erros comuns e precauções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (função totiente, coprimos).",
                                "Ciência da Computação: Algoritmos eficientes e complexidade O(log n).",
                                "História: Evolução da criptografia (de Césari a RSA moderno).",
                                "Física: Computação quântica (Shor quebra RSA via fatoração).",
                                "Engenharia: Implementação em hardware para aceleração criptográfica."
                              ],
                              "realWorldApplication": "Fundamental no RSA para protocolos como HTTPS/SSL/TLS, garantindo comunicações seguras em bancos online, e-mails criptografados (PGP) e assinaturas digitais em blockchain, permitindo transações financeiras globais sem intermediários inseguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Implementar algoritmo de exponenciação rápida",
                            "description": "Aplicar o método 'square-and-multiply' para calcular eficientemente a^b mod n, reduzindo o número de multiplicações modulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios do Algoritmo Square-and-Multiply",
                                  "subSteps": [
                                    "Estude a representação binária do expoente b, pois o algoritmo processa bit a bit da MSB para LSB.",
                                    "Aprenda a regra básica: para cada bit 1, multiplique pelo acumulador; sempre eleve ao quadrado o resultado atual.",
                                    "Analise um exemplo manual: calcule 3^13 mod 35 bit a bit (13 em binário: 1101).",
                                    "Compare com exponenciação ingênua para ver redução de multiplicações (de O(b) para O(log b)).",
                                    "Desenhe um fluxograma do processo iterativo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o processo para um exemplo simples e compare contagens de operações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Documentação do algoritmo online (Wikipedia: Exponentiation by squaring)"
                                  ],
                                  "tips": "Sempre processe bits do mais significativo para o menos significativo para minimizar erros.",
                                  "learningObjective": "Entender como o algoritmo reduz complexidade de O(b) para O(log b) usando propriedades de expoentes.",
                                  "commonMistakes": [
                                    "Confundir ordem dos bits (LSB vs MSB)",
                                    "Esquecer de modularizar após cada multiplicação",
                                    "Não elevar ao quadrado em todos os passos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever Pseudocódigo e Implementar Função Básica",
                                  "subSteps": [
                                    "Escreva pseudocódigo iterativo: inicialize result=1, processe bits de b do MSB ao LSB.",
                                    "Escolha uma linguagem (ex: Python) e implemente a função sem módulo inicialmente: def power(a, b):",
                                    "Teste com expoentes pequenos: power(2, 10) deve ser 1024.",
                                    "Adicione comentários explicando cada linha, especialmente o loop e as condições if bit==1.",
                                    "Execute e debugue com print statements para rastrear valores intermediários."
                                  ],
                                  "verification": "A função retorna valores corretos para 5 expoentes de teste sem módulo (ex: 2^10=1024, 3^5=243).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Python instalado"
                                  ],
                                  "tips": "Use loop while b > 0 e b = b >> 1 para shift de bits eficiente.",
                                  "learningObjective": "Implementar corretamente a lógica core do square-and-multiply em pseudocódigo e código real.",
                                  "commonMistakes": [
                                    "Inicializar result com a em vez de 1",
                                    "Shift incorreto de bits",
                                    "Multiplicar em vez de elevar ao quadrado no passo square"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Operações Modulares e Otimizações",
                                  "subSteps": [
                                    "Modifique a função para incluir mod n em cada multiplicação: result = (result * result) % n e (result * a) % n.",
                                    "Implemente versão recursiva opcionalmente para comparação, mas foque na iterativa por eficiência.",
                                    "Adicione handling para casos edge: b=0 (retorna 1), n=1 (retorna 0), a=0.",
                                    "Meça performance com timeit para comparar com pow(a,b,n) built-in do Python.",
                                    "Otimize usando int64 ou bibliotecas para grandes números se necessário."
                                  ],
                                  "verification": "Função fast_pow(a, b, n) retorna mesmo resultado que pow(a,b,n) para 10 casos com n>1.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com timeit module",
                                    "Exemplos de números grandes (ex: a=17, b=12345, n=35)"
                                  ],
                                  "tips": "Sempre aplique % n imediatamente para evitar overflow em inteiros grandes.",
                                  "learningObjective": "Adaptar o algoritmo para aritmética modular, essencial em criptografia.",
                                  "commonMistakes": [
                                    "Overflow sem % n",
                                    "Não tratar b=0 corretamente",
                                    "Usar / em vez de % para módulo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Analisar Eficiência",
                                  "subSteps": [
                                    "Crie suite de testes: unit tests para exemplos RSA-like (ex: 3^13 mod 35 = 27).",
                                    "Compare número de multiplicações: conte manualmente vs implementação.",
                                    "Teste com expoentes grandes (b=2^20) e meça tempo vs método ingênuo.",
                                    "Documente análise Big O: prove O(log b) multiplicações.",
                                    "Integre em contexto RSA: use para encriptar/decifrar mensagem simples."
                                  ],
                                  "verification": "Todos testes passam, performance é pelo menos 10x melhor que loop ingênuo para b grande.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pytest ou unittest em Python",
                                    "Relógio/cronômetro para timing"
                                  ],
                                  "tips": "Use assert statements para automação de testes.",
                                  "learningObjective": "Validar implementação através de testes e análise de performance.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Confundir modular exponentiation com power simples",
                                    "Ignorar overflow em testes grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente fast_pow(3, 13, 35): bin(13)=1101. Inicie result=1. Bit1: square=1, mult=3%35=3. Bit1: square=9, mult=9*3=27%35=27. Bit0: square=729%35=14. Bit1: square=196%35=21, mult=21*3=63%35=28. Resultado correto: 27, com apenas 7 operações vs 13 no método ingênuo.",
                              "finalVerifications": [
                                "Função retorna resultados idênticos ao pow(a,b,n) built-in para 20 casos variados.",
                                "Contagem de multiplicações é O(log b), verificada por logging.",
                                "Sem erros de overflow ou timeouts em b até 2^30.",
                                "Edge cases (b=0,1; a=0,1; n=1) tratados corretamente.",
                                "Integração bem-sucedida em exemplo RSA simples (encripta 'A' com chaves públicas).",
                                "Código comentado e legível com docstring."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% de testes passam (40%).",
                                "Eficiência: Redução comprovada de operações (25%).",
                                "Clareza: Código bem estruturado e documentado (15%).",
                                "Robustez: Trata edge cases e overflow (10%).",
                                "Análise: Explicação escrita de Big O e comparação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação binária, propriedades de expoentes (a^{2k} = (a^k)^2).",
                                "Algoritmos e Estruturas de Dados: Análise de complexidade O(log n).",
                                "Criptografia: Base para RSA e Diffie-Hellman.",
                                "Programação: Manipulação de bits, otimização de loops."
                              ],
                              "realWorldApplication": "Esse algoritmo é o coração da exponenciação modular em RSA, usado diariamente em HTTPS, assinaturas digitais e blockchain para encriptar comunicações seguras na web, bancos e apps como WhatsApp."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Verificar propriedades matemáticas",
                            "description": "Demonstrar que a^d ≡ 1 mod φ(n) onde φ é a função totiente de Euler, base da corretude do RSA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a função totiente de Euler φ(n) para n = p × q",
                                  "subSteps": [
                                    "Identifique os fatores primos distintos p e q tais que n = p × q.",
                                    "Aplique a fórmula φ(n) = (p - 1) × (q - 1).",
                                    "Realize a multiplicação e verifique se o resultado é correto comparando com valores conhecidos ou fatorando n.",
                                    "Anote φ(n) para uso posterior.",
                                    "Confirme que p e q são primos usando teste de primalidade simples (divisores até sqrt)."
                                  ],
                                  "verification": "O valor de φ(n) está correto e pode ser validado manualmente ou com calculadora para o exemplo dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel e caneta",
                                    "Tabela de números primos ou software como Python (sympy.isprime)"
                                  ],
                                  "tips": "Escolha p e q grandes mas gerenciáveis para cálculos manuais; use n=33 (p=3, q=11) como exemplo inicial.",
                                  "learningObjective": "Dominar o cálculo da função totiente de Euler para números semiprimos, fundamental em criptografia.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair 1 de p e q",
                                    "Usar fatores não primos",
                                    "Confundir φ(n) com n - p - q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar que gcd(a, n) = 1",
                                  "subSteps": [
                                    "Escolha uma base a (1 < a < n) aleatória.",
                                    "Calcule gcd(a, p) e gcd(a, q) usando o algoritmo euclidiano.",
                                    "Se algum gcd > 1, rejeite a e escolha outra.",
                                    "Confirme gcd(a, n) = 1 explicitamente.",
                                    "Documente o processo euclidiano passo a passo."
                                  ],
                                  "verification": "O algoritmo euclidiano retorna 1 para gcd(a, n), comprovado por passos escritos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para divisões"
                                  ],
                                  "tips": "Comece com a pequeno como 2 ou 5 para simplicidade; lembre que a deve ser coprimo com ambos p e q.",
                                  "learningObjective": "Aplicar o algoritmo euclidiano para verificar coprimaridade, pré-requisito do Teorema de Euler.",
                                  "commonMistakes": [
                                    "Parar cedo no algoritmo euclidiano",
                                    "Escolher a múltiplo de p ou q",
                                    "Confundir gcd(a,n) com gcd(a,φ(n))"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar exponenciação modular a^{φ(n)} mod n",
                                  "subSteps": [
                                    "Converta o expoente φ(n) para binário para método quadrado-e-multiplicar.",
                                    "Inicialize resultado = 1 e base = a mod n.",
                                    "Para cada bit do expoente (direita para esquerda): square base, se bit=1 multiplique no resultado, mod n a cada passo.",
                                    "Registre todos os passos intermediários.",
                                    "Obtenha o resultado final."
                                  ],
                                  "verification": "Resultado computado coincide com cálculo independente (ex: Python pow(a, phi_n, n) == 1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela de squaring",
                                    "Calculadora ou Python para verificação opcional"
                                  ],
                                  "tips": "Use método binário para evitar cálculos enormes; pratique com expoente pequeno primeiro.",
                                  "learningObjective": "Executar exponenciação modular eficiente, essencial para viabilidade computacional em RSA.",
                                  "commonMistakes": [
                                    "Esquecer mod n após cada operação",
                                    "Erro na representação binária do expoente",
                                    "Overflow em cálculos manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a congruência a^{φ(n)} ≡ 1 mod n e relacionar com RSA",
                                  "subSteps": [
                                    "Compare o resultado da exponenciação com 1.",
                                    "Explique o Teorema de Euler: se gcd(a,n)=1, então a^{φ(n)} ≡ 1 mod n.",
                                    "Relacione com RSA: como e d ≡ 1 mod φ(n), então m^{e d} ≡ m^1 ≡ m mod n.",
                                    "Teste com múltiplos a's para robustez.",
                                    "Conclua a demonstração."
                                  ],
                                  "verification": "Resultado é exatamente 1 e explicação escrita liga à corretude do RSA.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resultados dos passos anteriores",
                                    "Notas sobre RSA"
                                  ],
                                  "tips": "Use o exemplo para ilustrar como isso prova reversibilidade da encriptação/descriptografia.",
                                  "learningObjective": "Compreender como o Teorema de Euler fundamenta a corretude matemática do algoritmo RSA.",
                                  "commonMistakes": [
                                    "Ignorar condição gcd=1",
                                    "Confundir mod n com mod φ(n)",
                                    "Não ligar à propriedade ed ≡1 mod φ(n)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=33 (p=3, q=11), φ(n)=20, a=2 (gcd(2,33)=1). Usando exponenciação modular: 2^20 mod 33 = 1. Passos: binário 10100, squares e multiplies levam a 1, confirmando o teorema. No RSA, isso assegura (m^e)^d ≡ m mod 33.",
                              "finalVerifications": [
                                "φ(n) calculado corretamente como (p-1)(q-1).",
                                "gcd(a, n) = 1 verificado via Euclides.",
                                "a^{φ(n)} mod n = 1 obtido via exponenciação modular.",
                                "Explicação clara da ligação com inverso modular ed ≡ 1 mod φ(n).",
                                "Teste com pelo menos dois valores de a diferentes.",
                                "Sem erros aritméticos nos cálculos intermediários."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos matemáticos (φ(n), gcd, exponenciação).",
                                "Uso correto e eficiente do método de exponenciação modular.",
                                "Compreensão demonstrada do Teorema de Euler e sua aplicação ao RSA.",
                                "Documentação completa de subpassos e verificações.",
                                "Identificação e correção de erros comuns durante o processo.",
                                "Relacionamento lógico com a corretude do RSA."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Números (Matemática: funções totientes, congruências).",
                                "Algoritmos (Ciência da Computação: Euclides, exponenciação modular).",
                                "Segurança Cibernética (aplicações práticas em criptosistemas).",
                                "Álgebra Abstrata (grupos multiplicativos mod n)."
                              ],
                              "realWorldApplication": "Essa propriedade matemática é a base da corretude do RSA, usado em protocolos como HTTPS/TLS para encriptar comunicações na web, assinaturas digitais em blockchain e proteção de dados em apps bancários, garantindo que apenas a chave privada reverta a encriptação pública."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Geração de Chaves Públicas e Privadas",
                        "description": "Processo de seleção de expoentes e geração do par de chaves no RSA.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Escolher expoente público e",
                            "description": "Selecionar e coprimo com φ(n), tipicamente pequeno como 65537, garantindo eficiência e segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender φ(n) e seus requisitos matemáticos",
                                  "subSteps": [
                                    "Calcule φ(n) = (p-1)(q-1) para primos p e q distintos",
                                    "Explique que φ(n) conta os inteiros coprimos com n até n-1",
                                    "Discuta por que e deve ser coprimo com φ(n): gcd(e, φ(n)) = 1",
                                    "Identifique que e deve ser ímpar e 1 < e < φ(n)",
                                    "Revise o Teorema de Euler para justificar a invertibilidade"
                                  ],
                                  "verification": "Calcule φ(n) corretamente para p=61, q=53 e prove gcd(e, φ(n))=1 para e=17",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Python para gcd",
                                    "Documentação RSA (Wikipedia ou textbook)"
                                  ],
                                  "tips": "Sempre verifique se p e q são primos antes de calcular φ(n)",
                                  "learningObjective": "Dominar o cálculo de φ(n) e os critérios básicos para e",
                                  "commonMistakes": [
                                    "Usar φ(n) = n-1 em vez de (p-1)(q-1)",
                                    "Esquecer que e deve ser coprimo apenas com φ(n), não com n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar expoentes públicos comuns e suas propriedades",
                                  "subSteps": [
                                    "Liste expoentes pequenos: 3, 17, 65537 (primos de Fermat)",
                                    "Explique vantagens de e pequeno: acelera criptografia (exponenciação rápida)",
                                    "Calcule o número de bits de e e compare com φ(n)",
                                    "Discuta por que 65537 é ideal: 2^16 +1, multiplica por si mesmo rapidamente",
                                    "Avalie riscos de e muito pequeno (ex: ataques se mal escolhido)"
                                  ],
                                  "verification": "Justifique por que 65537 é preferido sobre 3 em aplicações modernas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de primos de Fermat",
                                    "Artigo sobre eficiência RSA (ex: RFC 8017)"
                                  ],
                                  "tips": "Prefira 65537 se φ(n) > 65537 para máxima eficiência",
                                  "learningObjective": "Conhecer e selecionar expoentes otimizados para segurança e performance",
                                  "commonMistakes": [
                                    "Escolher e par (deve ser ímpar)",
                                    "Ignorar que e deve ser < φ(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar coprimaridade entre e e φ(n)",
                                  "subSteps": [
                                    "Implemente o algoritmo Euclides para calcular gcd(e, φ(n))",
                                    "Teste múltiplos candidatos e até encontrar gcd=1",
                                    "Use ferramentas como Python's math.gcd() para validação",
                                    "Analise fatores primos de φ(n) para prever coprimaridade",
                                    "Registre o processo para reprodutibilidade"
                                  ],
                                  "verification": "Execute gcd(65537, 3120) e confirme =1; repita para e=3",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código Python ou SageMath",
                                    "Função gcd online"
                                  ],
                                  "tips": "Comece testando e=65537; se falhar, teste menores como 17 ou 3",
                                  "learningObjective": "Aplicar algoritmo de Euclides para validar escolha de e",
                                  "commonMistakes": [
                                    "Confundir gcd com n ao invés de φ(n)",
                                    "Não testar múltiplos e"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e validar a escolha em um exemplo RSA completo",
                                  "subSteps": [
                                    "Gere chaves completas: n, φ(n), escolha e, calcule d = e^{-1} mod φ(n)",
                                    "Use extended Euclidean para encontrar d",
                                    "Teste criptografia/decrypt com mensagem simples",
                                    "Compare performance com diferentes e (tempo de exponenciação)",
                                    "Documente trade-offs de segurança vs. eficiência"
                                  ],
                                  "verification": "Gere par (e,d) válido e descriptografe 'Olá RSA' corretamente",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python para RSA (biblioteca pycryptodome ou implementado)",
                                    "Ambiente Jupyter"
                                  ],
                                  "tips": "Use pow(base, exp, mod) para exponenciação eficiente",
                                  "learningObjective": "Integrar escolha de e em geração de chaves RSA funcional",
                                  "commonMistakes": [
                                    "Calcular d mod n ao invés de mod φ(n)",
                                    "Escolher e não coprimo levando a d inexistente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para p=61, q=53: n=3233, φ(n)=(60)(52)=3120. Teste e=65537: gcd(65537,3120)=1 (ok, mas e>φ(n), use 17). gcd(17,3120)=1. Calcule d=2753 (17*2753=1 mod 3120). Criptografe m=65: c=2790, descriptografe ok.",
                              "finalVerifications": [
                                "Calcule φ(n) e gcd(e,φ(n))=1 corretamente para novos p,q",
                                "Explique por que 65537 otimiza RSA",
                                "Liste 3 critérios para e e justifique cada um",
                                "Implemente geração de chaves com e escolhido",
                                "Identifique erro em exemplo inválido (ex: e=4)",
                                "Compare tempos de criptografia para e=3 vs 65537"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo de φ(n) e gcd",
                                "Justificativa clara para escolha de e (segurança/eficiência)",
                                "Correção na implementação e verificação de chaves",
                                "Análise de trade-offs e erros comuns evitados",
                                "Criatividade em exemplos práticos e conexões reais",
                                "Documentação completa e reprodutível"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (função totiente, Euclides estendido)",
                                "Algoritmos: Otimização de exponenciação modular",
                                "Segurança da Informação: Princípios de criptografia assimétrica",
                                "Programação: Implementação em Python/Sage para validação",
                                "Física/Engenharia: Aplicações em comunicações seguras"
                              ],
                              "realWorldApplication": "Na geração de certificados SSL/TLS para sites HTTPS (ex: bancos usam 65537 para equilibrar segurança quântica-resistente parcial e velocidade em servidores web), garantindo que chaves públicas sejam eficientes sem comprometer descriptografia privada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Calcular expoente privado d",
                            "description": "Computar d como o inverso modular de e módulo φ(n), usando o algoritmo estendido de Euclides.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os valores de entrada e verificar coprimos",
                                  "subSteps": [
                                    "Confirme que você tem n, φ(n) e e disponíveis.",
                                    "Verifique se gcd(e, φ(n)) = 1 usando o algoritmo de Euclides padrão.",
                                    "Se gcd ≠ 1, selecione um novo e.",
                                    "Documente os valores iniciais: r0 = φ(n), r1 = e.",
                                    "Inicialize a tabela do Euclides estendido com colunas para ri, si, ti."
                                  ],
                                  "verification": "gcd(e, φ(n)) = 1 confirmado e tabela inicializada corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software de cálculo (ex: Python ou Wolfram Alpha)",
                                    "Papel e caneta para tabela"
                                  ],
                                  "tips": "Sempre anote os valores exatos para evitar erros de transcrição.",
                                  "learningObjective": "Entender os pré-requisitos para a existência do inverso modular.",
                                  "commonMistakes": "Esquecer de verificar gcd=1, levando a chaves inválidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar as divisões sucessivas do algoritmo de Euclides",
                                  "subSteps": [
                                    "Defina s0=1, t0=0 para r0=φ(n); s1=0, t1=1 para r1=e.",
                                    "Enquanto r_{i+1} ≠ 0, calcule qi = floor(ri / r_{i+1}), ri+2 = ri - qi * r_{i+1}.",
                                    "Atualize si+2 = si - qi * si+1; ti+2 = ti - qi * ti+1.",
                                    "Continue até r_k = 1 (gcd).",
                                    "Registre todos os quotientes qi na tabela."
                                  ],
                                  "verification": "Tabela preenchida até gcd=1 sem erros aritméticos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela impressa ou planilha Excel",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use uma tabela com colunas: i, ri, si, ti para visualização clara.",
                                  "learningObjective": "Dominar a fase iterativa do Euclides estendido para gerar coeficientes de Bézout.",
                                  "commonMistakes": "Erro nos sinais dos coeficientes si e ti durante atualizações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a substituição reversa para encontrar o coeficiente s",
                                  "subSteps": [
                                    "O último não-zero ri=1 tem si como o inverso desejado.",
                                    "Se s negativo, adicione múltiplos de φ(n) até positivo: d = s mod φ(n).",
                                    "Expresse 1 como combinação linear: 1 = s*e + t*φ(n).",
                                    "Ignore t, foque em s como candidato a d.",
                                    "Ajuste d para 0 < d < φ(n)."
                                  ],
                                  "verification": "1 = s*e + t*φ(n) verificado manualmente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para equações",
                                    "Software simbólico opcional (SymPy)"
                                  ],
                                  "tips": "Back-substitua passo a passo das equações para validar s.",
                                  "learningObjective": "Aplicar substituição reversa para isolar o inverso modular.",
                                  "commonMistakes": "Não ajustar s negativo, resultando em d inválido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar o expoente privado d",
                                  "subSteps": [
                                    "Calcule d * e mod φ(n) e confirme = 1.",
                                    "Garanta que 1 < d < φ(n).",
                                    "Teste com potências: e^d mod n deve ser 1 (opcional para verificação).",
                                    "Documente o par (e, d) como chaves.",
                                    "Salve valores para uso em RSA."
                                  ],
                                  "verification": "e * d ≡ 1 mod φ(n) confirmado.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Calculadora modular",
                                    "Implementação Python simples"
                                  ],
                                  "tips": "Use pow(e, d, phi_n) em Python para verificação rápida.",
                                  "learningObjective": "Validar a correção do inverso modular.",
                                  "commonMistakes": "Verificação modular incorreta devido a overflow aritmético."
                                }
                              ],
                              "practicalExample": "Para n=187 (p=11, q=17), φ(n)=160, e=7: Aplicando Euclides estendido: 160=22*7+6, 7=1*6+1, 6=6*1+0. Back-sub: 1=7-1*6, 6=160-22*7 → 1=23*7 -1*160. Assim d=23 (23 mod 160). Verificação: 7*23=161 ≡1 mod 160.",
                              "finalVerifications": [
                                "gcd(e, φ(n)) = 1 confirmado.",
                                "d * e ≡ 1 mod φ(n).",
                                "1 < d < φ(n).",
                                "Combinação linear 1 = s*e + t*φ(n) balanceada.",
                                "Sem erros aritméticos na tabela.",
                                "d funciona em teste de descriptografia RSA básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos aritméticos (100% correto).",
                                "Tabela do Euclides estendido completa e organizada.",
                                "Explicação clara da substituição reversa.",
                                "Verificação modular executada e documentada.",
                                "Identificação e correção de erros comuns.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Aritmética Modular.",
                                "Programação: Implementação do Euclides estendido em Python ou C++.",
                                "Segurança da Informação: Geração de chaves assimétricas.",
                                "Álgebra Linear: Coeficientes de Bézout como solução de equações diofantinas."
                              ],
                              "realWorldApplication": "O expoente privado d é essencial na geração de chaves RSA, usado em protocolos como HTTPS, assinaturas digitais (ex: certificados SSL/TLS) e criptografia de emails (PGP), protegendo transações bancárias e comunicações seguras na internet."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Formar as chaves",
                            "description": "Gerar chave pública (n, e) e chave privada (n, d), entendendo sua distribuição e uso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar dois números primos grandes p e q",
                                  "subSteps": [
                                    "Escolha dois números primos distintos e grandes (ex: maiores que 100 para fins educacionais)",
                                    "Verifique a primalidade usando testes como Miller-Rabin ou divisão por primos menores",
                                    "Garanta que p e q sejam de tamanho similar para segurança",
                                    "Registre os valores escolhidos",
                                    "Considere o tamanho em bits para aplicações reais (ex: 1024 bits)"
                                  ],
                                  "verification": "Confirme que p e q são primos testando divisibilidade por números até sqrt(p) e sqrt(q)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software de primalidade (ex: Python com sympy.isprime)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use primos conhecidos para testes iniciais, como 61 e 53",
                                  "learningObjective": "Entender a importância de primos grandes e distintos na segurança do RSA",
                                  "commonMistakes": [
                                    "Escolher números compostos",
                                    "Usar primos iguais",
                                    "Ignorar o tamanho dos primos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o módulo n = p * q",
                                  "subSteps": [
                                    "Multiplique p por q para obter n",
                                    "Verifique o cálculo multiplicando de volta p * q",
                                    "Registre n como o módulo público",
                                    "Entenda que n será compartilhado publicamente",
                                    "Considere o tamanho de n em bits (deve ser soma dos bits de p e q)"
                                  ],
                                  "verification": "Divida n por p ou q e confirme que resulta no outro primo",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora grande ou Python para multiplicação de grandes números"
                                  ],
                                  "tips": "Use ferramentas computacionais para números reais grandes",
                                  "learningObjective": "Compreender n como produto público dos primos secretos",
                                  "commonMistakes": [
                                    "Erro de cálculo na multiplicação",
                                    "Confundir n com φ(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a função totiente φ(n) = (p-1)(q-1)",
                                  "subSteps": [
                                    "Subtraia 1 de p e de q",
                                    "Multiplique os resultados: (p-1) * (q-1)",
                                    "Verifique o cálculo",
                                    "Entenda que φ(n) conta números coprimos com n até n-1",
                                    "Registre φ(n) como valor secreto"
                                  ],
                                  "verification": "Confirme que φ(n) = n - p - q + 1",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se da fórmula derivada da propriedade de Euler para n=pq",
                                  "learningObjective": "Dominar o cálculo de φ(n) essencial para escolher e e d",
                                  "commonMistakes": [
                                    "Esquecer de subtrair 1",
                                    "Multiplicar errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escolher o expoente público e coprimo com φ(n)",
                                  "subSteps": [
                                    "Escolha e pequeno e ímpar, como 3, 17 ou 65537",
                                    "Verifique que gcd(e, φ(n)) = 1 usando algoritmo de Euclides",
                                    "Prefira 65537 por ser primo Fermat e eficiente",
                                    "Registre e como parte da chave pública",
                                    "Teste múltiplos e se necessário"
                                  ],
                                  "verification": "Execute gcd(e, φ(n)) e confirme resultado 1",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Implementação de gcd em Python ou calculadora"
                                  ],
                                  "tips": "65537 é padrão por razões de performance",
                                  "learningObjective": "Aprender critérios para e: coprimo e eficiente",
                                  "commonMistakes": [
                                    "Escolher e não coprimo",
                                    "Usar e par"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calcular o expoente privado d = e^{-1} mod φ(n)",
                                  "subSteps": [
                                    "Use o algoritmo estendido de Euclides para encontrar d tal que e * d ≡ 1 mod φ(n)",
                                    "Implemente ou use função modular_inverse",
                                    "Verifique: (e * d) % φ(n) == 1",
                                    "Registre d como secreto",
                                    "Forme chaves: pública (n, e), privada (n, d)"
                                  ],
                                  "verification": "Confirme e * d ≡ 1 mod φ(n)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com pow(e, -1, phi) ou sympy.mod_inverse"
                                  ],
                                  "tips": "Bibliotecas facilitam para números grandes",
                                  "learningObjective": "Entender inverso multiplicativo modular",
                                  "commonMistakes": [
                                    "Erro no algoritmo de Euclides",
                                    "Não verificar a congruência"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: p=61, q=53. n=61*53=3233. φ(n)=(60*52)=3120. e=17 (gcd(17,3120)=1). d=2753 (17*2753 % 3120 =1). Chave pública: (3233,17), privada: (3233,2753).",
                              "finalVerifications": [
                                "p e q são primos distintos",
                                "n = p * q correto",
                                "φ(n) = (p-1)(q-1) correto",
                                "gcd(e, φ(n)) = 1",
                                "e * d ≡ 1 mod φ(n)",
                                "Chaves formatadas corretamente: pública (n,e), privada (n,d)"
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos matemáticos",
                                "Correta verificação de primalidade e coprimaridade",
                                "Explicação conceitual de cada passo",
                                "Escolha adequada de primos e e",
                                "Uso correto de ferramentas para grandes números",
                                "Compreensão da assimetria das chaves"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números, aritmética modular, algoritmo de Euclides",
                                "Programação: Implementação em Python ou Java para criptografia",
                                "Segurança da Informação: Fundamentos de PKI e certificados digitais",
                                "Física: Resistência quântica (Shor's algorithm ameaça RSA)"
                              ],
                              "realWorldApplication": "Geração de chaves para certificados SSL/TLS em HTTPS, assinaturas digitais em blockchain, criptografia de e-mails (PGP) e autenticação em VPNs, garantindo comunicações seguras na internet."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.4",
                        "name": "Operações de Encriptação e Decriptação",
                        "description": "Aplicação das chaves para encriptar e decriptar mensagens no RSA.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.4.1",
                            "name": "Executar encriptação RSA",
                            "description": "Calcular o texto cifrado c = m^e mod n a partir de uma mensagem m usando a chave pública.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os componentes da encriptação RSA",
                                  "subSteps": [
                                    "Obtenha a chave pública composta por n (módulo) e e (expoente público).",
                                    "Receba a mensagem m como um número inteiro onde 0 ≤ m < n.",
                                    "Se a mensagem for texto, converta caracteres para valores numéricos usando um mapeamento simples (ex: ord('A')=65).",
                                    "Verifique que m < n para garantir validade.",
                                    "Anote todos os valores em um papel para referência."
                                  ],
                                  "verification": "Confirme que n, e e m estão anotados corretamente e m < n.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Use números pequenos para prática manual; assuma chaves válidas fornecidas.",
                                  "learningObjective": "Identificar e validar os insumos necessários para encriptação RSA.",
                                  "commonMistakes": [
                                    "Confundir n com φ(n)",
                                    "Usar m >= n",
                                    "Ignorar conversão de texto para int"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter mensagem para representação numérica apropriada",
                                  "subSteps": [
                                    "Se m for texto, divida em blocos menores que n (ex: um caractere por vez).",
                                    "Converta cada caractere usando valor ASCII (ex: 'A' → 65).",
                                    "Ajuste se necessário para m < n (use padding ou bloco único para simplicidade).",
                                    "Para mensagem numérica direta, confirme o valor.",
                                    "Liste todos os valores m_i prontos para encriptação."
                                  ],
                                  "verification": "Você tem uma lista de inteiros m_i todos menores que n.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela ASCII impressa",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Para iniciantes, use mensagens numéricas pequenas como m=5 ou m=2.",
                                  "learningObjective": "Transformar dados de entrada em formato numérico compatível com RSA.",
                                  "commonMistakes": [
                                    "Exceder tamanho de bloco sem padding",
                                    "Usar encoding errado como UTF-8 em vez de ASCII simples",
                                    "Não tratar multi-blocos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a exponenciação modular m^e mod n",
                                  "subSteps": [
                                    "Use o método de exponenciação por quadrado para eficiência: inicialize result=1, base=m.",
                                    "Para cada bit de e de MSB a LSB: se bit=1, result = (result * base) mod n; base = (base * base) mod n.",
                                    "Exemplo manual: para e=3 (bin 11), compute step-by-step.",
                                    "Realize todas multiplicações e aplique mod n imediatamente para evitar números grandes.",
                                    "Registre cálculos intermediários."
                                  ],
                                  "verification": "O resultado c satisfaz c ≡ m^e (mod n) testando com calculadora se disponível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para cálculos",
                                    "Calculadora para verificação opcional"
                                  ],
                                  "tips": "Sempre reduza mod n após cada operação para manter números gerenciáveis.",
                                  "learningObjective": "Executar exponenciação modular eficientemente sem overflow.",
                                  "commonMistakes": [
                                    "Calcular m^e sem mod, causando números enormes",
                                    "Erro na ordem dos bits binários de e",
                                    "Esquecer mod após multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e formatar o texto cifrado",
                                  "subSteps": [
                                    "Confirme c < n e 0 ≤ c.",
                                    "Se múltiplos blocos, concatene os c_i.",
                                    "Converta c para representação legível (ex: decimal, hex ou back to chars se aplicável).",
                                    "Teste com mensagem conhecida: ex. m=5, e=3, n=33 → c=26.",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Encripte uma mensagem teste e confirme resultado esperado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel com cálculos anteriores"
                                  ],
                                  "tips": "Use hex para output longo: format(c, 'x').",
                                  "learningObjective": "Validar e apresentar o ciphertext corretamente.",
                                  "commonMistakes": [
                                    "Não verificar c < n",
                                    "Perder blocos em mensagens longas",
                                    "Confundir ciphertext com plaintext"
                                  ]
                                }
                              ],
                              "practicalExample": "Chave pública: n=33 (p=3,q=11), e=3. Mensagem: m=5 (representa 'E' simplificado). Passos: 5^1 mod33=5; 5^2=25 mod33=25; 5^3=(25*5)=125 mod33=125-3*33=125-99=26. Ciphertext c=26.",
                              "finalVerifications": [
                                "Calcule corretamente m=2 → c=8 com n=33,e=3.",
                                "Calcule m=5 → c=26 com n=33,e=3.",
                                "Explique por que mod n é essencial.",
                                "Converta 'A' (65) com n=3233,e=17 (ajuste se >n).",
                                "Identifique erro em cálculo errado intencional."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em todos cálculos modulares (100% correto).",
                                "Eficiência: uso de exponenciação por quadrado sem cálculos desnecessários.",
                                "Correta preparação e validação de insumos (m < n).",
                                "Documentação clara de passos intermediários.",
                                "Capacidade de aplicar a exemplo novo independente.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números.",
                                "Segurança da Informação: Fundamentos de criptografia assimétrica.",
                                "Programação: Implementação de pow(m, e, n) em Python ou JavaScript.",
                                "Física/Engenharia: Aplicações em comunicações seguras (ex: satélites)."
                              ],
                              "realWorldApplication": "A encriptação RSA protege comunicações online em HTTPS/TLS, e-mails seguros (PGP), assinaturas digitais em software e transações bancárias, garantindo confidencialidade sem compartilhamento de chaves secretas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.4.2",
                            "name": "Executar decriptação RSA",
                            "description": "Recuperar a mensagem original m = c^d mod n usando a chave privada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reunir e validar os parâmetros da decriptação RSA",
                                  "subSteps": [
                                    "Identifique o ciphertext c, o expoente privado d e o módulo n fornecidos.",
                                    "Verifique se c, d e n são inteiros positivos e c < n.",
                                    "Converta os valores para inteiros se estiverem em formato de string ou decimal.",
                                    "Registre os valores em um documento ou variável para referência.",
                                    "Confirme que d é o inverso multiplicativo de e módulo φ(n), se conhecido."
                                  ],
                                  "verification": "Todos os parâmetros estão corretamente identificados e validados sem erros de tipo ou range.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Valores de exemplo de c, d, n",
                                    "Calculadora ou editor de texto"
                                  ],
                                  "tips": "Use um exemplo pequeno para prática inicial, como n=3233, d=2753, c=2790.",
                                  "learningObjective": "Compreender e preparar os componentes essenciais da chave privada RSA.",
                                  "commonMistakes": [
                                    "Confundir d com e",
                                    "Usar valores onde c >= n",
                                    "Ignorar validação de inteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente computacional para cálculo modular",
                                  "subSteps": [
                                    "Instale Python 3.x se não estiver disponível.",
                                    "Abra um interpretador Python ou IDE como Jupyter Notebook.",
                                    "Defina variáveis para c, d e n usando atribuições simples.",
                                    "Teste operações básicas modulares, como pow(2, 3, 5) == 3.",
                                    "Prepare uma função wrapper para o cálculo: def decrypt(c, d, n): return pow(c, d, n)."
                                  ],
                                  "verification": "Ambiente roda sem erros e pow() funciona corretamente com teste simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de código (VS Code, Jupyter)"
                                  ],
                                  "tips": "A função pow(c, d, n) é otimizada para exponentiação modular eficiente.",
                                  "learningObjective": "Configurar ferramentas para computação segura de grandes expoentes.",
                                  "commonMistakes": [
                                    "Usar ** em vez de pow() para grandes números (lento ou overflow)",
                                    "Esquecer de importar módulos desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o cálculo de decriptação m = c^d mod n",
                                  "subSteps": [
                                    "Atribua os valores reais a c, d, n no código.",
                                    "Execute m = pow(c, d, n) e imprima o resultado.",
                                    "Registre o tempo de execução para números grandes.",
                                    "Repita com um segundo conjunto de valores para validação.",
                                    "Compare com cálculo manual para exemplos pequenos."
                                  ],
                                  "verification": "O valor de m é calculado corretamente e corresponde ao plaintext esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python preparado",
                                    "Exemplos de teste"
                                  ],
                                  "tips": "Para depuração, use valores pequenos primeiro antes de escalar.",
                                  "learningObjective": "Executar com precisão a operação core da decriptação RSA.",
                                  "commonMistakes": [
                                    "Overflow em linguagens sem suporte bigint",
                                    "Erro de sintaxe em pow()",
                                    "Confundir ordem dos argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar o plaintext recuperado",
                                  "subSteps": [
                                    "Converta m para string ou caractere se for codificação numérica (ex: chr(m)).",
                                    "Re-encripte m com chave pública para verificar ciclo completo.",
                                    "Teste com múltiplos ciphertexts do mesmo plaintext.",
                                    "Documente o processo e resultados em um relatório.",
                                    "Discuta limitações como padding (ex: OAEP não coberto aqui)."
                                  ],
                                  "verification": "Plaintext recuperado é idêntico ao original e ciclo de encriptação/decriptação fecha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Chave pública correspondente (e, n)",
                                    "Ferramentas de conversão de bytes"
                                  ],
                                  "tips": "Sempre teste o round-trip: encrypt(decrypt(c)) == c.",
                                  "learningObjective": "Validar a corretude da decriptação e entender implicações práticas.",
                                  "commonMistakes": [
                                    "Ignorar codificação de mensagem (numérico vs texto)",
                                    "Não testar round-trip"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: n=3233 (p=61, q=53), e=17, d=2753, m=65 ('A'), c=2790. Calcule m = 2790^2753 mod 3233 → 65. Em Python: pow(2790, 2753, 3233) retorna 65.",
                              "finalVerifications": [
                                "Cálculo de m é correto para pelo menos 3 exemplos variados.",
                                "Explicação clara do papel de d como inverso de e.",
                                "Demonstração de round-trip com encriptação pública.",
                                "Identificação de erros potenciais em implementações manuais.",
                                "Conversão correta de m para mensagem legível.",
                                "Uso eficiente de pow() sem timeouts em números de 1024 bits."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: m exato sem erros de arredondamento.",
                                "Eficiência computacional: uso de algoritmos modulares otimizados.",
                                "Compreensão conceitual: explicação correta de por que funciona.",
                                "Validação robusta: testes múltiplos e edge cases.",
                                "Documentação: passos claros e reproduzíveis.",
                                "Tempo de execução: dentro do esperado para tamanhos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e Teorema de Euler.",
                                "Segurança da Informação: Autenticação e confidencialidade.",
                                "História: Evolução da criptografia de Rivest-Shamir-Adleman.",
                                "Computação: Algoritmos de Big Integer e eficiência.",
                                "Física: Ameaças quânticas ao RSA (Shor's algorithm)."
                              ],
                              "realWorldApplication": "Usado em protocolos como HTTPS/SSL para proteger comunicações web, assinaturas digitais em software, e transações bancárias seguras, garantindo que apenas o detentor da chave privada acesse dados sensíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.4.3",
                            "name": "Simular um ciclo completo RSA",
                            "description": "Realizar geração de chaves, encriptação e decriptação com números pequenos para verificar a corretude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar primos e gerar chaves pública e privada",
                                  "subSteps": [
                                    "Escolha dois números primos pequenos e distintos, como p=3 e q=11.",
                                    "Calcule n = p * q = 33.",
                                    "Calcule φ(n) = (p-1) * (q-1) = 2 * 10 = 20.",
                                    "Escolha e coprimo com φ(n), como e=3 (verifique gcd(3,20)=1).",
                                    "Calcule d como o inverso modular de e módulo φ(n): resolva 3d ≡ 1 mod 20, teste valores até encontrar d=7 (3*7=21≡1 mod 20)."
                                  ],
                                  "verification": "Confirme que n=33, φ(n)=20, gcd(e,φ(n))=1 e e*d ≡1 mod φ(n).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para fatoração ou gcd opcional"
                                  ],
                                  "tips": "Use primos muito pequenos para cálculos manuais; liste múltiplos de e até exceder φ(n) para encontrar inverso.",
                                  "learningObjective": "Entender a geração de chaves RSA usando aritmética modular básica.",
                                  "commonMistakes": [
                                    "Escolher p e q não primos",
                                    "Erro no cálculo de φ(n)",
                                    "Não verificar coprimos de e"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e encriptar a mensagem",
                                  "subSteps": [
                                    "Escolha uma mensagem simples representada por um número m < n, como m=5 (representando 'E').",
                                    "Calcule o expoente: m^e = 5^3 = 125.",
                                    "Reduza módulo n: 125 mod 33 = 125 - 3*33 = 125 - 99 = 26, então c=26.",
                                    "Registre a chave pública (n=33, e=3) e o ciphertext c=26."
                                  ],
                                  "verification": "Confirme que c = m^e mod n foi calculado corretamente sem usar ferramentas automatizadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de potências para cálculo manual"
                                  ],
                                  "tips": "Calcule potências passo a passo: m^2 mod n primeiro, depois multiplique por m.",
                                  "learningObjective": "Dominar o cálculo de encriptação RSA com expoentes modulares.",
                                  "commonMistakes": [
                                    "Esquecer o módulo n no cálculo",
                                    "Usar m >= n",
                                    "Erro aritmético em potências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decriptar o ciphertext",
                                  "subSteps": [
                                    "Use a chave privada (d=7, n=33) no ciphertext c=26.",
                                    "Calcule c^d = 26^7 mod 33 passo a passo:",
                                    "26^2 mod 33 = 676 mod 33 = 16",
                                    "26^4 = (26^2)^2 = 16^2 = 256 mod 33 = 31 (ou 25? Espere: ajuste correto: 16^2=256, 33*7=231,256-231=25)",
                                    "Continue: 26^1=26, ^2=16, ^3=26*16=416 mod33=20 (416-12*33=416-396=20), ^4=26*20=520 mod33=25 (520-15*33=520-495=25), ^5=26*25=650 mod33=23 (650-19*33=650-627=23), ^6=26*23=598 mod33=4 (598-18*33=598-594=4), ^7=26*4=104 mod33=5 (104-3*33=104-99=5).",
                                    "Obtenha m' = 5."
                                  ],
                                  "verification": "Verifique se o resultado da decriptação m' é igual ao m original (5).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Folha para rastrear potências intermediárias"
                                  ],
                                  "tips": "Use 'quadrado e multiplique' para expoentes: calcule potências de 2 e multiplique conforme binário do expoente.",
                                  "learningObjective": "Executar decriptação RSA manualmente e entender por que funciona.",
                                  "commonMistakes": [
                                    "Perder o rastreamento em expoentes altos",
                                    "Erro no módulo repetido",
                                    "Confundir chaves pública/privada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e analisar o ciclo completo",
                                  "subSteps": [
                                    "Compare m original (5) com m' decriptado (5).",
                                    "Teste com outra mensagem, como m=4: c=4^3=64 mod33=31, então 31^7 mod33 deve ser 4.",
                                    "Discuta por que funciona: pelo teorema de Euler, m^{φ(n)} ≡1 mod n para m coprimo n.",
                                    "Identifique limitações: números pequenos não são seguros.",
                                    "Registre o ciclo completo: chaves, m -> c -> m'."
                                  ],
                                  "verification": "Ambas mensagens encriptadas/decriptadas corretamente e explicação do teorema fornecida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para testes adicionais"
                                  ],
                                  "tips": "Teste múltiplas mensagens para reforçar confiança nos cálculos.",
                                  "learningObjective": "Validar a corretude do RSA e conectar à teoria matemática subjacente.",
                                  "commonMistakes": [
                                    "Não testar segunda mensagem",
                                    "Ignorar casos onde gcd(m,n)>1",
                                    "Não ligar ao teorema de Euler"
                                  ]
                                }
                              ],
                              "practicalExample": "Com p=3, q=11: n=33, φ=20, e=3, d=7. Mensagem m=5 ('E'). Encripta: 5^3 mod33=26. Decripta: 26^7 mod33=5. Ciclo completo verificado.",
                              "finalVerifications": [
                                "Chaves geradas corretamente: n, φ(n), e coprimo, d inverso.",
                                "Encriptação produz c único para m dado.",
                                "Decriptação recupera m exato.",
                                "Teste com pelo menos duas mensagens diferentes.",
                                "Explicação verbal do porquê RSA funciona (Euler/Fermat).",
                                "Identificação de vulnerabilidades em números pequenos."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos modulares (sem erros aritméticos).",
                                "Execução completa do ciclo sem ferramentas computacionais.",
                                "Compreensão demonstrada via verificação de inverso e teorema.",
                                "Uso correto de subpassos para expoentes grandes.",
                                "Análise de erros comuns evitados e explicados.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, números primos, teorema de Euler.",
                                "História: Evolução da criptografia de CésAR a RSA moderna.",
                                "Segurança da Informação: Fundamentos de chaves assimétricas.",
                                "Programação: Implementação em Python (pow(m,e,n) para eficiência)."
                              ],
                              "realWorldApplication": "RSA protege comunicações HTTPS (sites seguros), e-mails encriptados (PGP), assinaturas digitais em software e transações financeiras, garantindo confidencialidade sem troca prévia de chaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Criptografia de Curva Elíptica (ECC)",
                    "description": "Fundamentos da ECC, curvas elípticas sobre campos finitos e suas aplicações em criptosistemas assimétricos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Fundamentos de Curvas Elípticas",
                        "description": "Introdução aos conceitos matemáticos básicos das curvas elípticas, incluindo sua equação padrão e propriedades geométricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir a equação de uma curva elíptica",
                            "description": "Explicar a forma da equação de Weierstrass y² = x³ + ax + b e suas condições para que a curva seja não-singular (4a³ + 27b² ≠ 0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral da equação de Weierstrass",
                                  "subSteps": [
                                    "Pesquise brevemente a história das curvas elípticas e a forma de Weierstrass.",
                                    "Identifique os componentes: variáveis x e y, e coeficientes a e b.",
                                    "Escreva a equação y² = x³ + a x + b várias vezes para memorização.",
                                    "Desenhe um esboço aproximado do gráfico para visualizar a forma.",
                                    "Compare com outras curvas cúbicas para destacar diferenças."
                                  ],
                                  "verification": "Reescreva a equação corretamente de memória e explique cada termo verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica ou app como Desmos/GeoGebra"
                                  ],
                                  "tips": "Pense na equação como uma parábola invertida em y para melhor visualização.",
                                  "learningObjective": "Memorizar e compreender a estrutura exata da equação y² = x³ + a x + b.",
                                  "commonMistakes": [
                                    "Escrever y² = x³ + a x² + b (adicionar termo quadrático)",
                                    "Confundir com y = x³ + a x + b (equação implícita errada)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o papel dos parâmetros a e b",
                                  "subSteps": [
                                    "Analise como variações em a afetam a curvatura (a negativo cria 'laços').",
                                    "Teste valores de b para ver shifts verticais no gráfico.",
                                    "Plote pelo menos dois exemplos: um com a=0, b=0 e outro com a=-1, b=1.",
                                    "Discuta simetria: par em x e ímpar em y.",
                                    "Registre observações sobre o comportamento assintótico."
                                  ],
                                  "verification": "Altere a e b em um plotador e descreva as mudanças observadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Desmos, GeoGebra ou Python com Matplotlib)",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Use cores diferentes para plotar múltiplas curvas e comparar.",
                                  "learningObjective": "Entender como a e b moldam a geometria da curva.",
                                  "commonMistakes": [
                                    "Ignorar que a controla 'abertura' horizontal",
                                    "Pensar que b é o intercepto y (não é diretamente)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender a condição de não-singularidade",
                                  "subSteps": [
                                    "Derive intuitivamente por que singularidade ocorre (ponto onde derivadas somem).",
                                    "Memorize a fórmula do discriminante: Δ = -16(4a³ + 27b²).",
                                    "Calcule Δ para exemplos: verifique se Δ ≠ 0 garante suavidade.",
                                    "Encontre um exemplo singular (ex: a=0, b=0) e plote para ver o 'nó'.",
                                    "Explique o significado: curva não-singular é um grupo abeliano."
                                  ],
                                  "verification": "Calcule Δ para três pares (a,b) dados e classifique cada curva.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios com valores de a e b"
                                  ],
                                  "tips": "Lembre: 4a³ + 27b² é o núcleo; o -16 é convenção, foque no ≠0.",
                                  "learningObjective": "Dominar a condição 4a³ + 27b² ≠ 0 para curvas lisas.",
                                  "commonMistakes": [
                                    "Calcular 4a³ + 27a² em vez de b²",
                                    "Confundir com discriminante quadrático"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e aplicar a definição completa",
                                  "subSteps": [
                                    "Escolha uma curva padrão de ECC (ex: secp256k1) e confirme sua equação e Δ.",
                                    "Crie sua própria curva não-singular e valide.",
                                    "Explique verbalmente a definição completa para um 'aluno'.",
                                    "Resolva um problema: dado a e b, é elíptica? Por quê?",
                                    "Documente tudo em um relatório curto."
                                  ],
                                  "verification": "Apresente uma curva válida com cálculo de Δ e gráfico suave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência de curvas ECC (Wikipedia ou RFC)",
                                    "Notebook"
                                  ],
                                  "tips": "Use curvas reais de cripto para motivação prática.",
                                  "learningObjective": "Integrar forma e condição em uma definição precisa.",
                                  "commonMistakes": [
                                    "Usar curvas singulares como exemplos válidos",
                                    "Esquecer verificação numérica de Δ"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a curva y² = x³ - 3x + 2. Calcule Δ = -16(4(-3)³ + 27(2)²) = -16(-108 + 108) = 0 (singular, tem nó em (1,0)). Agora, y² = x³ - x: Δ = -16(4(-1)³ + 27(0)) = -16(-4) = 64 ≠ 0 (não-singular). Plote ambas no Desmos para comparar.",
                              "finalVerifications": [
                                "Escrever corretamente y² = x³ + a x + b sem erros.",
                                "Explicar verbalmente o papel de a e b.",
                                "Calcular Δ para pelo menos dois exemplos com precisão.",
                                "Identificar uma curva singular e justificar.",
                                "Plotar uma curva não-singular e descrever sua suavidade.",
                                "Definir 'curva elíptica' em contexto de ECC."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação de Weierstrass (obrigatória).",
                                "Correta formulação e cálculo do discriminante Δ ≠ 0.",
                                "Demonstração de plots com variações de a e b.",
                                "Explicação clara de singular vs. não-singular.",
                                "Uso de exemplos reais de criptografia.",
                                "Relatório estruturado com verificações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra: Polinômios cúbicos e discriminantes.",
                                "Geometria Algébrica: Singularidades e suavidade.",
                                "Criptografia: Base para ECC em segurança digital.",
                                "Física: Modelos de curvas em mecânica quântica.",
                                "Programação: Implementação em Python/SageMath."
                              ],
                              "realWorldApplication": "Na Criptografia de Curva Elíptica (ECC), usada em Bitcoin (secp256k1), protocolos TLS/SSL e chaves SSH, a equação não-singular garante operações de grupo eficientes para chaves públicas compactas e seguras contra ataques."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Identificar pontos em uma curva elíptica",
                            "description": "Descrever os pontos na curva, incluindo o ponto no infinito como elemento neutro, e como representar pontos afins e no infinito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação padrão de uma curva elíptica",
                                  "subSteps": [
                                    "Estude a forma da equação de Weierstrass: y² = x³ + ax + b, onde 4a³ + 27b² ≠ 0.",
                                    "Verifique a condição discriminante para garantir que é uma curva elíptica suave.",
                                    "Identifique os parâmetros a e b em exemplos simples, como y² = x³ - x.",
                                    "Plote graficamente uma curva elíptica usando ferramentas como Desmos ou GeoGebra.",
                                    "Discuta o campo finito vs. reais, focando inicialmente em reais para visualização."
                                  ],
                                  "verification": "Capacidade de escrever a equação corretamente e verificar o discriminante para um exemplo dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software de plotagem (Desmos, GeoGebra)",
                                    "Papel e lápis para anotações"
                                  ],
                                  "tips": "Comece com curvas simples sobre reais para intuição visual antes de campos finitos.",
                                  "learningObjective": "Dominar a forma canônica da equação elíptica e suas propriedades básicas.",
                                  "commonMistakes": [
                                    "Confundir com parábolas ou hipérboles",
                                    "Esquecer a condição discriminante"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar pontos afins na curva",
                                  "subSteps": [
                                    "Para um ponto candidato (x, y), substitua na equação e resolva y² = x³ + ax + b.",
                                    "Encontre pares (x, y) onde y é real e satisfaz a equação exatamente.",
                                    "Liste todos os pontos afins para uma curva pequena, como y² = x³ - 7x + 6.",
                                    "Pratique resolvendo para x fixo e encontrando y correspondente.",
                                    "Use plotagem para validar pontos visuais."
                                  ],
                                  "verification": "Listar corretamente pelo menos 5 pontos afins para uma curva dada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de álgebra computacional (SageMath ou Python com sympy)",
                                    "Folha de exercícios com curvas exemplo"
                                  ],
                                  "tips": "Teste valores inteiros pequenos para x para encontrar soluções fáceis.",
                                  "learningObjective": "Saber localizar e validar pontos afins que satisfazem a equação da curva.",
                                  "commonMistakes": [
                                    "Pontos que não satisfazem exatamente a equação",
                                    "Ignorar soluções negativas de y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o ponto no infinito como elemento neutro",
                                  "subSteps": [
                                    "Defina o ponto no infinito, denotado O ou ∞, como o elemento identidade na operação de grupo.",
                                    "Explique que é obtido pela interseção das retas verticais no plano projetivo.",
                                    "Represente graficamente como o 'ponto no topo' em plots de curvas elípticas.",
                                    "Verifique propriedades: P + O = P para qualquer ponto P.",
                                    "Compare com o zero em grupos aditivos."
                                  ],
                                  "verification": "Explicar em palavras próprias o papel do ponto no infinito e desenhar sua representação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de curva elíptica com ponto no infinito",
                                    "Vídeo tutorial sobre geometria projetiva básica"
                                  ],
                                  "tips": "Pense nele como o 'fim da linha vertical' quando linhas paralelas se encontram no infinito.",
                                  "learningObjective": "Entender conceitualmente o ponto no infinito e seu papel como neutro.",
                                  "commonMistakes": [
                                    "Confundir com o centro da curva (0,0)",
                                    "Pensar que é um ponto afin (x,y) finito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Representar e listar todos os pontos de uma curva elíptica",
                                  "subSteps": [
                                    "Combine pontos afins e o ponto no infinito para o conjunto completo de pontos E(R).",
                                    "Para uma curva exemplo, liste: todos afins + O.",
                                    "Discuta representação em código: tuplas (x,y) para afins, 'O' ou None para infinito.",
                                    "Pratique em campos finitos simples, como F_5, para ECC.",
                                    "Crie uma tabela resumindo pontos."
                                  ],
                                  "verification": "Produzir uma lista completa de pontos para uma curva dada, incluindo O.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de curvas em campos finitos",
                                    "Notebook Jupyter com código Python para listar pontos"
                                  ],
                                  "tips": "Use loops em Python para brute-force pontos em campos pequenos.",
                                  "learningObjective": "Representar completamente o conjunto de pontos de uma curva elíptica.",
                                  "commonMistakes": [
                                    "Esquecer o ponto no infinito",
                                    "Listar pontos que não estão na curva"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a curva y² = x³ - x sobre os reais. Pontos afins incluem (0,0), (1,0), (-1,0). Adicione o ponto no infinito O. Em código Python: pontos = [(0,0), (1,0), (-1,0), 'O']. Plote e verifique.",
                              "finalVerifications": [
                                "Lista corretamente pontos afins para uma curva dada.",
                                "Identifica o ponto no infinito e explica seu papel neutro.",
                                "Representa graficamente a curva com O.",
                                "Distingue pontos afins de O em representações.",
                                "Aplica a um exemplo em campo finito simples.",
                                "Explica como pontos formam um grupo abeliano."
                              ],
                              "assessmentCriteria": [
                                "Precisão na substituição da equação (100% correto).",
                                "Inclusão obrigatória do ponto no infinito.",
                                "Explicação conceitual clara do elemento neutro.",
                                "Uso correto de representações (tuplas vs. símbolo O).",
                                "Validação visual ou computacional de pontos.",
                                "Capacidade de generalizar para campos finitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra abstrata (grupos abelianos).",
                                "Física: Geometria projetiva em relatividade.",
                                "Ciência da Computação: Implementação em bibliotecas criptográficas como OpenSSL.",
                                "Engenharia: Otimização em protocolos IoT seguros."
                              ],
                              "realWorldApplication": "Em Criptografia de Curva Elíptica (ECC), identificar pontos é fundamental para operações de adição de pontos, base de chaves públicas em Bitcoin, TLS/SSL e mensagens seguras em apps como WhatsApp, permitindo criptografia eficiente em dispositivos móveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Entender o grupo aditivo das curvas elípticas",
                            "description": "Reconhecer que os pontos da curva formam um grupo abeliano sob a operação de adição de pontos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os axiomas de um grupo abeliano",
                                  "subSteps": [
                                    "Defina um grupo: conjunto com operação binária que satisfaz fechamento, associatividade, identidade e inversos.",
                                    "Explique o que torna um grupo abeliano: comutatividade (a + b = b + a).",
                                    "Liste exemplos familiares de grupos abelianos, como (ℤ, +) ou (ℝ, +).",
                                    "Discuta por que a comutatividade é crucial para aplicações em criptografia.",
                                    "Compare com grupos não-abelianos para destacar diferenças."
                                  ],
                                  "verification": "Escreva uma definição precisa e liste os 5 axiomas com exemplos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra abstrata (ex: Dummit & Foote), vídeo Khan Academy sobre grupos.",
                                  "tips": "Use analogias cotidianas, como soma de números, para fixar conceitos.",
                                  "learningObjective": "Compreender os requisitos formais para um conjunto formar um grupo abeliano.",
                                  "commonMistakes": "Confundir identidade com zero aditivo ou esquecer a comutatividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a operação de adição de pontos em curvas elípticas",
                                  "subSteps": [
                                    "Revise a equação de Weierstrass: y² = x³ + ax + b sobre um corpo finito.",
                                    "Descreva geometricamente: linha através de P e Q intersecta a curva em R', então R = -R'.",
                                    "Explique o caso especial: duplicação de ponto (P + P = 2P).",
                                    "Defina o ponto no infinito O como identidade.",
                                    "Pratique desenhando a adição em uma curva simples como y² = x³ - x."
                                  ],
                                  "verification": "Desenhe e calcule manualmente P + Q para pontos dados em uma curva.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software SageMath ou GeoGebra para visualização, papel e lápis para esboços.",
                                  "tips": "Sempre verifique se a linha intersecta em três pontos distintos.",
                                  "learningObjective": "Dominar a regra geométrica e algébrica para somar dois pontos.",
                                  "commonMistakes": "Esquecer de refletir sobre o eixo x ou lidar incorretamente com P + O."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar as propriedades do grupo aditivo",
                                  "subSteps": [
                                    "Prove fechamento: mostre que P + Q está sempre na curva.",
                                    "Demonstre associatividade: (P + Q) + R = P + (Q + R) usando coordenadas.",
                                    "Confirme identidade: P + O = P e O + P = P.",
                                    "Mostre inversos: -P é o reflexo de P, e P + (-P) = O.",
                                    "Verifique comutatividade: P + Q = Q + P pela simetria geométrica."
                                  ],
                                  "verification": "Escreva provas curtas para cada propriedade usando uma curva exemplo.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Artigo 'Elliptic Curve Cryptography' de Washington, calculadora simbólica como SymPy.",
                                  "tips": "Use corpos finitos pequenos (ex: GF(5)) para computações manuais rápidas.",
                                  "learningObjective": "Validar que os pontos formam um grupo abeliano sob adição.",
                                  "commonMistakes": "Assumir associatividade sem prova ou ignorar o ponto no infinito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar exemplos e aplicações iniciais",
                                  "subSteps": [
                                    "Calcule múltiplos escalares: kP para k=1 a 5 em uma curva sobre GF(7).",
                                    "Visualize o grupo inteiro para uma curva pequena (ex: todos pontos em GF(11)).",
                                    "Discuta ordem do grupo e teorema de Lagrange.",
                                    "Conecte à ECDH: como a dificuldade de log discreto surge aqui.",
                                    "Resolva um exercício: encontre o inverso de um ponto dado."
                                  ],
                                  "verification": "Compute a tabela de Cayley parcial e verifique propriedades.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "SageMath notebook, tabela de pontos pré-computada para GF(p pequeno).",
                                  "tips": "Comece com curvas de campo primo pequeno para evitar cálculos longos.",
                                  "learningObjective": "Aplicar o conhecimento em exemplos concretos e ver a estrutura grupal.",
                                  "commonMistakes": "Erros aritméticos em campos finitos, como modular incorretamente."
                                }
                              ],
                              "practicalExample": "Considere a curva y² = x³ + 2x + 2 sobre GF(5). Pontos: O, (0,2), (0,3), (3,1), (3,4). Calcule (0,2) + (3,1): linha y = 2x + 2 mod 5 intersecta em R', reflita para obter soma (1,1). Verifique propriedades na tabela de adição.",
                              "finalVerifications": [
                                "Explicar verbalmente as 5 propriedades do grupo com exemplos.",
                                "Calcular corretamente 3 somas de pontos diferentes.",
                                "Identificar o inverso de 2 pontos arbitrários.",
                                "Desenhar a adição geométrica para duplicação.",
                                "Listar todos pontos de uma curva pequena e sua ordem.",
                                "Discutir por que é abeliano em 1 frase."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de adição (100% correto).",
                                "Compreensão demonstrada em provas de propriedades (completa e lógica).",
                                "Uso correto de aritmética modular em exemplos.",
                                "Visualizações claras e precisas.",
                                "Conexão explícita à criptografia.",
                                "Ausência de erros comuns como inverso errado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra abstrata: grupos e corpos finitos.",
                                "Geometria algébrica: interseções de curvas.",
                                "Teoria dos números: log discreto e primitividade.",
                                "Criptografia: base para ECC em protocolos seguros.",
                                "Computação: implementação eficiente em bibliotecas como OpenSSL."
                              ],
                              "realWorldApplication": "Em criptografia de curva elíptica (ECC), usada em Bitcoin para assinaturas digitais eficientes, TLS/SSL para navegação segura e WhatsApp para criptografia ponta-a-ponta, onde a estrutura grupal abeliana permite chaves públicas compactas e computação rápida em dispositivos móveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Curvas Elípticas sobre Campos Finitos",
                        "description": "Estudo das curvas elípticas definidas sobre campos finitos F_p ou F_{2^m}, essenciais para aplicações criptográficas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Definir curvas elípticas sobre F_p",
                            "description": "Explicar como definir uma curva elíptica sobre um campo primo F_p, com coeficientes em F_p e operações módulo p.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Campo Finito F_p",
                                  "subSteps": [
                                    "Escolha um número primo p ≥ 3 para evitar casos especiais de característica 2 ou 3.",
                                    "Defina F_p como o conjunto {0, 1, ..., p-1} com operações de adição e multiplicação módulo p.",
                                    "Verifique propriedades de campo: todo não-zero tem inverso multiplicativo usando Algoritmo Estendido de Euclides.",
                                    "Pratique representações: todos coeficientes serão inteiros mod p.",
                                    "Entenda que operações na curva serão sempre mod p."
                                  ],
                                  "verification": "Liste 3 propriedades de F_p e compute 5x7 mod 17 corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou Python para mods"
                                  ],
                                  "tips": "Sempre reduza mod p imediatamente para evitar números grandes.",
                                  "learningObjective": "Dominar aritmética modular em campos primos.",
                                  "commonMistakes": [
                                    "Confundir adição modular com subtração",
                                    "Esquecer de reduzir negativos mod p (use p + resíduo)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar a Forma da Equação de Weierstrass",
                                  "subSteps": [
                                    "Aprenda a forma curta: y² = x³ + a x + b, onde a, b ∈ F_p.",
                                    "Escolha a e b aleatoriamente em F_p, preferencialmente pequenos para exemplos.",
                                    "Escreva a equação explicitamente com mod p.",
                                    "Identifique que isso define uma curva elíptica afim.",
                                    "Note que para char ≠2,3, essa é a forma padrão."
                                  ],
                                  "verification": "Escreva a equação para p=17, a=2, b=3.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Quadro branco ou software como SageMath",
                                    "Tabela de primos pequenos"
                                  ],
                                  "tips": "Use a=0 para curvas simples como y²=x³+b inicialmente.",
                                  "learningObjective": "Reconhecer e escrever a equação padrão de uma curva elíptica sobre F_p.",
                                  "commonMistakes": [
                                    "Usar forma longa desnecessariamente",
                                    "Esquecer que a,b devem ser em F_p"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Não-Singularidade via Discriminante",
                                  "subSteps": [
                                    "Calcule o discriminante Δ = -16 (4a³ + 27b²) mod p.",
                                    "Compute 4a³ mod p: primeiro a², depois a³, multiplique por 4.",
                                    "Compute 27b² mod p: b², vezes 27 mod p.",
                                    "Some e verifique Δ ≠ 0 mod p (não múltiplo de p).",
                                    "Se Δ=0, mude a ou b e repita."
                                  ],
                                  "verification": "Para p=23, a=1, b=1, compute Δ e confirme ≠0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora modular ou script Python simples",
                                    "Fórmula anotada de Δ"
                                  ],
                                  "tips": "Fatore 16 como conveniente mod p; use inversos se necessário.",
                                  "learningObjective": "Validar que a curva é elíptica (lisa, não singular).",
                                  "commonMistakes": [
                                    "Erro em potências mod p",
                                    "Confundir Δ=0 como válido"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir o Conjunto de Pontos E(F_p)",
                                  "subSteps": [
                                    "Encontre todos (x,y) ∈ F_p × F_p tal que y² ≡ x³ + a x + b mod p.",
                                    "Para cada x=0 a p-1, compute rhs = x³ + a x + b mod p.",
                                    "Verifique se rhs é quadrado quadrático em F_p (Legendre symbol ou teste exaustivo).",
                                    "Adicione o ponto no infinito O como identidade.",
                                    "Liste todos pontos para p pequeno."
                                  ],
                                  "verification": "Liste todos pontos de y² = x³ + x + 1 sobre F_5.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou código Python para loop sobre x,y",
                                    "Tabela de resíduos quadráticos mod p"
                                  ],
                                  "tips": "Para p pequeno (<50), brute force; senão, use algoritmos eficientes.",
                                  "learningObjective": "Construir explicitamente E(F_p) como conjunto finito.",
                                  "commonMistakes": [
                                    "Esquecer ponto no infinito",
                                    "Não verificar y² == rhs mod p para ambos y e -y"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Introduzir Estrutura Grupal Básica",
                                  "subSteps": [
                                    "Defina adição de pontos: regras geométricas traduzidas para fórmulas mod p.",
                                    "Mencione que E(F_p) forma grupo abeliano sob adição de pontos.",
                                    "Verifique associatividade implicitamente via propriedades.",
                                    "Note ordem #E(F_p) ≈ p por Hasse.",
                                    "Prepare para aplicações criptográficas."
                                  ],
                                  "verification": "Descreva ponto O e adição P + (-P) = O.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de adição de pontos (imagem ou desenho)",
                                    "Referência Silverman AEC"
                                  ],
                                  "tips": "Visualize com desenhos antes de fórmulas.",
                                  "learningObjective": "Entender E(F_p) como grupo para ECC.",
                                  "commonMistakes": [
                                    "Confundir multiplicação escalar com adição",
                                    "Ignorar casos singulares em fórmulas"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina a curva secp256k1 usada no Bitcoin: p = 2^256 - 2^32 - 977, a=0, b=7. Compute Δ mod p (≠0). Liste pontos para p=5 análogo: y² = x³ + 7 mod 5 (simplificado).",
                              "finalVerifications": [
                                "Corretamente define F_p e suas operações.",
                                "Escreve equação y² = x³ + ax + b com a,b ∈ F_p.",
                                "Calcula Δ corretamente e verifica ≠0 mod p.",
                                "Lista pontos E(F_p) para p≤11 sem erros.",
                                "Identifica O como ponto no infinito.",
                                "Explica por que Δ garante não-singularidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão em aritmética modular (90% correto).",
                                "Validação completa de Δ com passos mostrados.",
                                "Lista exaustiva de pontos para exemplo dado.",
                                "Explicação clara da definição sem omissões.",
                                "Uso correto de terminologia (F_p, Weierstrass, etc.).",
                                "Aplicação em exemplo prático sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Números: Campos finitos e símbolos de Legendre.",
                                "Álgebra Abstrata: Grupos abelianos finitos.",
                                "Programação: Implementar em Python/Sage para automação.",
                                "Geometria Algébrica: Curvas como variedades.",
                                "Criptografia: Base para ECDH/ECDSA."
                              ],
                              "realWorldApplication": "Definir curvas sobre F_p é fundamental para ECC em protocolos como Bitcoin (secp256k1), HTTPS/TLS (curvas NIST), e dispositivos IoT, permitindo chaves públicas compactas e computação eficiente em grupos de ordem ~p."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Calcular o número de pontos na curva (teorema de Hasse)",
                            "description": "Aplicar o teorema de Hasse para estimar o cardinal do grupo de pontos: |#E(F_p) - (p+1)| ≤ 2√p.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição de pontos em uma curva elíptica sobre F_p",
                                  "subSteps": [
                                    "Revise a equação de Weierstrass: y² = x³ + ax + b mod p, onde p é primo e o discriminante Δ ≠ 0 mod p.",
                                    "Identifique os pontos finitos: para cada x em {0,1,...,p-1}, resolva y² ≡ x³ + ax + b mod p.",
                                    "Inclua o ponto no infinito O.",
                                    "Calcule o número total de pontos #E(F_p) somando soluções para cada x mais O.",
                                    "Verifique se a curva é não-singular."
                                  ],
                                  "verification": "Liste todos os pontos de uma curva simples mod 5 e confirme #E(F_5).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, calculadora modular, tabela de quadrados mod p.",
                                  "tips": "Comece com p pequeno (ex: p=5) para praticar contagem manual.",
                                  "learningObjective": "Definir e enumerar pontos em E(F_p) corretamente.",
                                  "commonMistakes": "Esquecer o ponto no infinito ou soluções y=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o teorema de Hasse",
                                  "subSteps": [
                                    "Estude a declaração: |#E(F_p) - (p+1)| ≤ 2√p.",
                                    "Interprete: o número de pontos está entre p+1 - 2√p e p+1 + 2√p.",
                                    "Derive intuitivamente a partir da teoria de Weil (opcional, foque na fórmula).",
                                    "Calcule limites inferior e superior para um p dado.",
                                    "Compare com contagens exatas de exemplos pequenos."
                                  ],
                                  "verification": "Para p=7, calcule limites e verifique se #E(F_7) está dentro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre teorema de Hasse, calculadora para √p.",
                                  "tips": "Use ≈ para √p inicialmente, depois exato.",
                                  "learningObjective": "Citar e interpretar a desigualdade de Hasse.",
                                  "commonMistakes": "Confundir ≤ 2√p com = p+1 ou errar o sinal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o teorema para estimar #E(F_p)",
                                  "subSteps": [
                                    "Escolha uma curva E: y² = x³ + ax + b mod p.",
                                    "Calcule p+1, 2√p (arredonde se necessário).",
                                    "Defina intervalo: [p+1 - 2√p, p+1 + 2√p].",
                                    "Estime #E(F_p) dentro desse intervalo.",
                                    "Compare com contagem exata se p pequeno."
                                  ],
                                  "verification": "Para p=11, curva y²=x³+x+1, estime e conte pontos exatos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como SageMath ou Python para mod p, ou manual.",
                                  "tips": "Automatize contagem com loop: para x in 0..p-1, cheque legendre_symbol.",
                                  "learningObjective": "Calcular limites de Hasse para dada curva e p.",
                                  "commonMistakes": "Errar arredondamento de √p ou inverter limites."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar precisão e discutir implicações em ECC",
                                  "subSteps": [
                                    "Conte #E(F_p) exato para sua curva.",
                                    "Confirme se está dentro dos limites de Hasse.",
                                    "Calcule trace t = #E(F_p) - (p+1), verifique |t| ≤ 2√p.",
                                    "Discuta por que isso importa: curvas com #E(F_p) primo para subgrupos seguros.",
                                    "Teste com p maior usando software."
                                  ],
                                  "verification": "Gere relatório: limites, contagem exata, conformidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "SageMath ou PARI/GP para contagem automática.",
                                  "tips": "Use função EllipticCurve(p,[a,b]).cardinality() em Sage.",
                                  "learningObjective": "Validar Hasse e relacionar com segurança ECC.",
                                  "commonMistakes": "Ignorar que Hasse é limite, não valor exato."
                                }
                              ],
                              "practicalExample": "Para a curva y² = x³ + 2x + 2 sobre F_17 (p=17): Calcule √17≈4.123, 2√17≈8.246. Limites: 17+1-8.246≈9.754 → 10 a 18+8.246≈26.246 →26. Contagem exata: 20 pontos (dentro dos limites).",
                              "finalVerifications": [
                                "Cita corretamente a fórmula de Hasse.",
                                "Calcula limites para p=23 com precisão.",
                                "Enumera pontos de E(F_5) manualmente.",
                                "Valida uma curva com software e compara.",
                                "Explica 'trace' t em contexto.",
                                "Identifica curva violando Hasse (impossível)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação e interpretação de Hasse (100%).",
                                "Cálculos corretos de limites para 3 ps diferentes.",
                                "Contagem exata manual para p≤11 sem erros.",
                                "Uso correto de ferramentas computacionais.",
                                "Conexão clara com aplicações em ECC.",
                                "Relatório estruturado com exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Números: Símbolos de Legendre para soluções quadráticas.",
                                "Álgebra Linear: Grupos abelianos de curvas elípticas.",
                                "Criptografia: Seleção de curvas seguras (ex: secp256k1).",
                                "Computação: Algoritmos Schoof para contagem exata.",
                                "Probabilidade: Distribuição de #E(F_p) via conjectura Sato-Tate."
                              ],
                              "realWorldApplication": "Em criptografia de curva elíptica (Bitcoin, TLS), o teorema de Hasse garante que #E(F_p) ≈ p, permitindo subgrupos de ordem ~p para chaves seguras de 256 bits com p~2^256, otimizando eficiência computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Escolher curvas seguras para criptografia",
                            "description": "Discutir critérios para seleção de curvas elípticas criptograficamente fortes, como curvas com ordem primo grande e subgrupos de ordem grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os critérios fundamentais de segurança para curvas elípticas",
                                  "subSteps": [
                                    "Estudar a definição de ordem da curva elíptica (número de pontos no grupo)",
                                    "Aprender sobre a importância de ordens primo grandes (pelo menos 2^256 para segurança atual)",
                                    "Analisar o cofator h (idealmente h=1 para subgrupo de ordem prima)",
                                    "Explorar a distinção entre curvas com ordem composta e as seguras",
                                    "Revisar propriedades do campo finito subjacente (tamanho do primo p)"
                                  ],
                                  "verification": "Listar e explicar verbalmente ou por escrito pelo menos 4 critérios principais com exemplos matemáticos simples",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação RFC 7748, site SafeCurves (safecurves.cr.yp.to), calculadora de curvas elípticas online",
                                  "tips": "Use diagramas para visualizar o grupo de pontos da curva",
                                  "learningObjective": "Identificar e justificar os critérios matemáticos essenciais para a força criptográfica de uma curva",
                                  "commonMistakes": "Confundir a ordem da curva com o tamanho do campo finito ou ignorar o cofator"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar curvas elípticas recomendadas e padrões industriais",
                                  "subSteps": [
                                    "Pesquisar curvas NIST (secp256r1, secp384r1) e suas especificações",
                                    "Analisar curvas 'safe' como Curve25519 e Ed25519, destacando twists e resistências",
                                    "Comparar curvas via tabelas de parâmetros (ordem n, p, h)",
                                    "Ler sobre curvas não recomendadas (ex: curvas com seed duvidosa ou vulneráveis a ataques)",
                                    "Verificar implementações em bibliotecas como OpenSSL ou libsodium"
                                  ],
                                  "verification": "Criar uma tabela comparativa de 3 curvas seguras vs. 1 insegura, justificando escolhas",
                                  "estimatedTime": "3 horas",
                                  "materials": "Tabelas de parâmetros IANA, código fonte de bibliotecas criptográficas, artigos de Bernstein sobre SafeCurves",
                                  "tips": "Priorize curvas com 'constant-time' implementations para evitar side-channels",
                                  "learningObjective": "Reconhecer curvas padronizadas e seguras usadas na prática",
                                  "commonMistakes": "Aceitar curvas NIST sem questionar controvérsias sobre geração de parâmetros"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar vulnerabilidades comuns e ataques a curvas elípticas",
                                  "subSteps": [
                                    "Estudar ataques como MOV, anomalous curves e small subgroup",
                                    "Aprender sobre rigididade (rigidity) e complete addition formulas",
                                    "Avaliar resistências a ataques de ladder (ex: Curve25519 vs. secp256k1)",
                                    "Discutir side-channel attacks e mitigações (montgomery vs. weierstrass)",
                                    "Verificar curvas contra critérios SafeCurves (ladder, etc.)"
                                  ],
                                  "verification": "Identificar 3 vulnerabilidades em uma curva dada e propor alternativas seguras",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Artigos SafeCurves, papers sobre ataques ECC (ex: Smart's attack), ferramentas como sage para simular",
                                  "tips": "Simule ataques em curvas pequenas para entender impactos",
                                  "learningObjective": "Avaliar riscos específicos de curvas e mitigações necessárias",
                                  "commonMistakes": "Subestimar ataques não-matemáticos como side-channels"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a seleção de curvas para cenários criptográficos",
                                  "subSteps": [
                                    "Definir requisitos de segurança (ex: 128 bits para um protocolo)",
                                    "Selecionar e justificar uma curva baseada em critérios aprendidos",
                                    "Implementar um teste simples (ex: gerar chaves com a curva escolhida)",
                                    "Documentar trade-offs (desempenho vs. segurança)",
                                    "Revisar seleção com pares ou auto-avaliação"
                                  ],
                                  "verification": "Produzir um relatório de 1 página justificando a escolha de uma curva para um caso de uso específico",
                                  "estimatedTime": "2 horas",
                                  "materials": "Bibliotecas Python (cryptography.io ou tinyec), ambiente de programação",
                                  "tips": "Considere o ecossistema: compatibilidade com hardware e software",
                                  "learningObjective": "Aplicar critérios para selecionar curvas seguras em contextos reais",
                                  "commonMistakes": "Escolher curvas exóticas sem suporte amplo ou auditoria"
                                }
                              ],
                              "practicalExample": "Para implementar ECDH em um app de mensagens seguras, escolha Curve25519: ordem primo de 256 bits (n ≈ 2^255), cofator 8 (aceitável com validação), resistente a ladders e twists, otimizada para software rápido e usada em Signal Protocol.",
                              "finalVerifications": [
                                "Explicar matematicamente por que uma ordem primo grande previne ataques de Pollard's rho",
                                "Listar e justificar 3 curvas seguras para diferentes níveis de segurança",
                                "Identificar falhas em uma curva vulnerável (ex: brainpoolP256r1 em certos contextos)",
                                "Demonstrar verificação de parâmetros de uma curva via código",
                                "Discutir quando evitar curvas NIST em favor de alternativas modernas",
                                "Avaliar trade-offs de performance para uma aplicação mobile"
                              ],
                              "assessmentCriteria": [
                                "Precisão e profundidade na explicação de critérios matemáticos (40%)",
                                "Capacidade de comparar curvas com evidências (30%)",
                                "Identificação correta de vulnerabilidades e mitigações (20%)",
                                "Qualidade da justificativa em cenários práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Grupos Abelianos",
                                "Segurança da Informação: Análise de Ameaças e Auditoria Criptográfica",
                                "Desenvolvimento de Software: Implementação Segura de Primitivas Criptográficas",
                                "Ética e Política: Confiança em Padrões Governamentais (NIST)"
                              ],
                              "realWorldApplication": "Na implementação de TLS 1.3 para sites HTTPS, selecionar curvas como x25519 garante negociações de chaves rápidas e seguras contra ataques quânticos iniciais, protegendo bilhões de transações diárias em e-commerce e banking."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Operações Aritméticas em ECC",
                        "description": "Operações fundamentais como adição, duplicação de pontos e multiplicação escalar, base para algoritmos criptográficos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Realizar adição de pontos distintos",
                            "description": "Implementar a fórmula de adição de pontos P + Q para P ≠ ±Q: λ = (y_Q - y_P)/(x_Q - x_P), x_R = λ² - x_P - x_Q, y_R = λ(x_P - x_R) - y_P (módulo p).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os componentes do problema",
                                  "subSteps": [
                                    "Especificar a equação da curva elíptica y² = x³ + a x + b módulo p.",
                                    "Identificar as coordenadas dos pontos P = (x_P, y_P) e Q = (x_Q, y_Q).",
                                    "Confirmar que P ≠ ±Q (x_P ≠ x_Q ou y_P ≠ y_Q e y_P ≠ -y_Q mod p).",
                                    "Verificar se P e Q estão na curva (satisfazem a equação).",
                                    "Preparar método para inverso modular (ex: Algoritmo Estendido de Euclides)."
                                  ],
                                  "verification": "Checklist completo com todos os parâmetros anotados e condições atendidas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software para operações modulares (ex: Python com pow para inverso)"
                                  ],
                                  "tips": "Reduza todos os valores módulo p imediatamente para evitar erros de escala.",
                                  "learningObjective": "Identificar e validar todos os pré-requisitos para a adição de pontos distintos.",
                                  "commonMistakes": [
                                    "Esquecer de verificar P ≠ ±Q, levando a fórmulas erradas",
                                    "Não reduzir coeficientes mod p inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a inclinação λ da reta secante",
                                  "subSteps": [
                                    "Computar numerador: y_Q - y_P módulo p.",
                                    "Computar denominador: x_Q - x_P módulo p.",
                                    "Calcular o inverso modular do denominador módulo p (inv_den = den^(-1) mod p).",
                                    "Multiplicar: λ = (y_Q - y_P) * inv_den módulo p.",
                                    "Verificar se λ está entre 0 e p-1."
                                  ],
                                  "verification": "λ produz o mesmo resultado se recalculado; teste com exemplo conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Implementação do Algoritmo Estendido de Euclides",
                                    "Biblioteca modular (ex: sympy.mod_inverse)"
                                  ],
                                  "tips": "Use pow(den, p-2, p) em Python para inverso por Fermat se p primo.",
                                  "learningObjective": "Dominar o cálculo de inclinação usando inverso modular.",
                                  "commonMistakes": [
                                    "Calcular inverso sem módulo p",
                                    "Confundir subtração com adição no numerador/denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a coordenada x_R",
                                  "subSteps": [
                                    "Elevar λ ao quadrado: λ² módulo p.",
                                    "Subtrair x_P: temp = λ² - x_P módulo p.",
                                    "Subtrair x_Q: x_R = temp - x_Q módulo p.",
                                    "Confirmar x_R entre 0 e p-1.",
                                    "Anotar valor intermediário para próximo passo."
                                  ],
                                  "verification": "x_R difere de x_P e x_Q (esperado para pontos distintos).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora modular"
                                  ],
                                  "tips": "Sempre aplique mod p após cada operação para manter números pequenos.",
                                  "learningObjective": "Aplicar corretamente a fórmula x_R = λ² - x_P - x_Q mod p.",
                                  "commonMistakes": [
                                    "Esquecer subtrações duplas",
                                    "Não modularizar λ² antes de subtrair"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a coordenada y_R e verificar",
                                  "subSteps": [
                                    "Computar x_P - x_R módulo p.",
                                    "Multiplicar por λ: temp = λ * (x_P - x_R) módulo p.",
                                    "Subtrair y_P: y_R = temp - y_P módulo p.",
                                    "Verificar se (x_R, y_R) satisfaz y_R² = x_R³ + a x_R + b mod p.",
                                    "Confirmar y_R entre 0 e p-1 (ou ajustar sinal se necessário)."
                                  ],
                                  "verification": "Ponto R está na curva e P + R ≈ Q ou similar (teste geométrico conceitual).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para equação da curva",
                                    "Script Python para validação rápida"
                                  ],
                                  "tips": "y_R deve ser o reflexo da interseção da reta com a curva.",
                                  "learningObjective": "Completar a fórmula y_R = λ(x_P - x_R) - y_P mod p e validar.",
                                  "commonMistakes": [
                                    "Erro de sinal em y_R (confundir com duplicação)",
                                    "Não verificar se R está na curva"
                                  ]
                                }
                              ],
                              "practicalExample": "Curva y² = x³ + 2x + 2 mod 17. P=(5,1), Q=(10,6). λ=(6-1)/(10-5)=5*inv(5)=5*7=35≡1 mod17 (pois 5*7=35-2*17=1). x_R=1²-5-10=-14≡3 mod17. y_R=1*(5-3)-1=2-1=1 mod17. R=(3,1) satisfaz 1²=1, 3³+2*3+2=27+6+2=35≡1 mod17.",
                              "finalVerifications": [
                                "Ponto R=(x_R, y_R) satisfaz a equação da curva módulo p.",
                                "Todos os cálculos intermediários (λ, x_R) foram reduzidos mod p.",
                                "Inverso modular usado está correto (den * inv_den ≡1 mod p).",
                                "P + Q resulta em R distinto de P e Q.",
                                "Repetição do cálculo produz o mesmo R.",
                                "Teste com software (ex: SageMath) confirma o resultado."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos modulares (sem erros aritméticos).",
                                "Correto uso do inverso modular para λ.",
                                "Aplicação exata das fórmulas sem variações indevidas.",
                                "Verificação final da curva realizada.",
                                "Eficiência nos passos (tempo dentro do estimado).",
                                "Explicação clara de cada subpasso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e inversos (Teoria dos Números).",
                                "Programação: Implementação de funções em Python/Sage para ECC.",
                                "Álgebra: Geometria projetiva e grupos abelianos.",
                                "Criptografia: Base para escalar multiplicação em ECC.",
                                "Computação: Otimização para grandes p em criptosistemas."
                              ],
                              "realWorldApplication": "Operação essencial na Criptografia de Curva Elíptica (ECC), usada em ECDSA para assinaturas digitais em Bitcoin, TLS/SSL para segurança web, e chaves eficientes em dispositivos IoT com baixa potência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Executar duplicação de pontos",
                            "description": "Calcular 2P usando λ = (3x_P² + a)/(2y_P), x_{2P} = λ² - 2x_P, y_{2P} = λ(x_P - x_{2P}) - y_P (módulo p).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os parâmetros da curva elíptica e o ponto P",
                                  "subSteps": [
                                    "Identifique os parâmetros da curva: a, b e módulo p (campo primo).",
                                    "Confirme que o ponto P=(x_P, y_P) está na curva, verificando y_P² ≡ x_P³ + a x_P + b (mod p).",
                                    "Certifique-se de que y_P ≠ 0 (ponto não é o infinito).",
                                    "Anote todos os valores em uma tabela para referência rápida.",
                                    "Converta todos os valores para o campo finito F_p se necessário."
                                  ],
                                  "verification": "Verifique a equação da curva para P e liste os parâmetros corretamente sem erros aritméticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, calculadora modular ou software como Python/SageMath.",
                                  "tips": "Sempre trabalhe módulo p desde o início para evitar números grandes.",
                                  "learningObjective": "Entender e validar os componentes necessários para duplicação de pontos em ECC.",
                                  "commonMistakes": "Esquecer de verificar se P está na curva ou usar y_P=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a inclinação λ",
                                  "subSteps": [
                                    "Calcule o numerador: 3 x_P² + a (módulo p).",
                                    "Calcule o denominador: 2 y_P (módulo p).",
                                    "Encontre o inverso multiplicativo do denominador módulo p (usando Algoritmo Estendido de Euclides).",
                                    "Multiplique numerador pelo inverso para obter λ (módulo p).",
                                    "Registre λ com todas as reduções mod p."
                                  ],
                                  "verification": "Confirme que λ * (2 y_P) ≡ (3 x_P² + a) (mod p).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora para inversos modulares, tabela de inversos pré-computados se p pequeno.",
                                  "tips": "Use o algoritmo estendido de Euclides para inversos; pratique com p pequenos primeiro.",
                                  "learningObjective": "Dominar o cálculo da inclinação para duplicação usando aritmética modular.",
                                  "commonMistakes": "Erro no cálculo do inverso ou esquecer a redução mod p no numerador."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a coordenada x_{2P}",
                                  "subSteps": [
                                    "Calcule λ² (módulo p).",
                                    "Calcule 2 x_P (módulo p).",
                                    "Subtraia: x_{2P} = λ² - 2 x_P (módulo p).",
                                    "Reduza o resultado final módulo p para 0 ≤ x_{2P} < p.",
                                    "Anote x_{2P} e verifique cálculos intermediários."
                                  ],
                                  "verification": "Reexecute a subtração para confirmar x_{2P} ≡ λ² - 2 x_P (mod p).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para cálculos quadráticos modulares.",
                                  "tips": "Quadrados mod p podem ser computados como (λ mod p)² mod p.",
                                  "learningObjective": "Aplicar a fórmula de x para o dobro do ponto com precisão modular.",
                                  "commonMistakes": "Não reduzir λ² mod p antes da subtração, levando a negativos ou grandes números."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a coordenada y_{2P}",
                                  "subSteps": [
                                    "Calcule a diferença: x_P - x_{2P} (módulo p).",
                                    "Multiplique por λ: λ (x_P - x_{2P}) (módulo p).",
                                    "Subtraia y_P: y_{2P} = λ (x_P - x_{2P}) - y_P (módulo p).",
                                    "Ajuste para o intervalo [0, p-1] se negativo.",
                                    "Registre o ponto 2P = (x_{2P}, y_{2P})."
                                  ],
                                  "verification": "Verifique a fórmula diretamente com os valores calculados.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Mesmos da etapa anterior.",
                                  "tips": "Lide com negativos adicionando p até positivo.",
                                  "learningObjective": "Completar a fórmula de duplicação para y, garantindo consistência modular.",
                                  "commonMistakes": "Erro no sinal da subtração final ou não modularizar a diferença x_P - x_{2P}."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar o resultado final",
                                  "subSteps": [
                                    "Substitua 2P na equação da curva: y_{2P}² ?≡ x_{2P}³ + a x_{2P} + b (mod p).",
                                    "Opcionalmente, calcule 2*(2P) ou compare com adição P+P.",
                                    "Confirme que 2P ≠ O (ponto no infinito).",
                                    "Documente todos os cálculos em um relatório.",
                                    "Teste com um segundo ponto se possível."
                                  ],
                                  "verification": "A equação da curva segura para 2P e todos os passos auditáveis.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Calculadora para potências cúbicas mod p.",
                                  "tips": "Use exponenciação rápida para x³ mod p.",
                                  "learningObjective": "Validar a duplicação garantindo integridade na curva.",
                                  "commonMistakes": "Ignorar verificação da curva, aceitando erros propagados."
                                }
                              ],
                              "practicalExample": "Curva elíptica: y² = x³ + 2x + 2 (mod 17), ponto P = (5, 1). Cálculo: λ = (3*25 + 2)*inv(2) = 9*9 = 13 (mod 17). x_{2P} = 13² - 10 = 169 - 10 = 16 - 10 = 6 (mod 17). y_{2P} = 13*(5-6) - 1 = 13*(-1) -1 = -14 ≡ 3 (mod 17). Verificação: 3²=9, 6³+2*6+2=216+12+2=230≡9 (mod 17). Assim, 2P=(6,3).",
                              "finalVerifications": [
                                "y_{2P}² ≡ x_{2P}³ + a x_{2P} + b (mod p)",
                                "λ * 2 y_P ≡ 3 x_P² + a (mod p)",
                                "Todos os cálculos intermediários reduzidos corretamente mod p",
                                "y_P ≠ 0 e P na curva inicialmente",
                                "x_{2P} e y_{2P} no intervalo [0, p-1]",
                                "Sem erros de sinal nas fórmulas"
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos modulares (100% correto)",
                                "Uso correto do inverso multiplicativo",
                                "Verificação da curva para P e 2P",
                                "Documentação clara de passos e valores",
                                "Tempo de execução dentro do estimado",
                                "Identificação e correção de erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e inversos",
                                "Ciência da Computação: Implementação em código (ex: Python com pow para mod)",
                                "Álgebra: Geometria de curvas elípticas",
                                "Criptografia: Base para multiplicação escalar em ECC"
                              ],
                              "realWorldApplication": "A duplicação de pontos é fundamental na multiplicação escalar de pontos em ECC, usada em protocolos como ECDSA para assinaturas digitais em Bitcoin, TLS/SSL para segurança web e dispositivos IoT com chaves efêmeras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Computar multiplicação escalar kP",
                            "description": "Descrever algoritmos eficientes como double-and-add para calcular kP eficientemente, base do problema do log discreto elíptico (ECDLP).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Multiplicação Escalar kP",
                                  "subSteps": [
                                    "Defina multiplicação escalar kP como adicionar o ponto P a si mesmo k vezes na curva elíptica.",
                                    "Compare o método ingênuo (adição repetida k vezes) com métodos eficientes, destacando O(k) vs O(log k).",
                                    "Revise operações básicas: adição de pontos P + Q e duplicação 2P.",
                                    "Entenda a representação binária de k, pois é base para algoritmos eficientes.",
                                    "Discuta o contexto no ECDLP, onde computar kP é fácil, mas encontrar k dado P e kP é difícil."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o método ingênuo é ineficiente para k grande (ex: k=2^256).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas sobre aritmética elíptica",
                                    "Exemplos de curvas elípticas (secp256k1)",
                                    "Calculadora modular"
                                  ],
                                  "tips": "Visualize pontos na curva elíptica usando ferramentas como GeoGebra ou SageMath para intuição.",
                                  "learningObjective": "Entender o problema e a necessidade de algoritmos eficientes como double-and-add.",
                                  "commonMistakes": [
                                    "Confundir adição de pontos com duplicação",
                                    "Ignorar aritmética modular na curva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Algoritmo Double-and-Add",
                                  "subSteps": [
                                    "Represente k em binário: k = (b_m b_{m-1} ... b_0)_2.",
                                    "Inicialize Q = ponto identidade O.",
                                    "Para cada bit de k da MSB para LSB: duplique Q (Q = 2Q), e se bit=1, adicione P (Q = Q + P).",
                                    "Alternativa: Right-to-left (inicialize R=P, escaneie LSB para MSB).",
                                    "Analise complexidade: O(log k) duplicações e O(log k) adições no pior caso."
                                  ],
                                  "verification": "Escreva o pseudocódigo completo do double-and-add e trace para k=13 (1101 em binário).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Tabela de bits binários para números pequenos",
                                    "SageMath ou Python para simulação"
                                  ],
                                  "tips": "Comece com k pequeno (ex: 5=101_2) para praticar o tracing manual.",
                                  "learningObjective": "Dominar o fluxo exato do algoritmo double-and-add e sua eficiência logarítmica.",
                                  "commonMistakes": [
                                    "Errar a ordem dos bits (MSB vs LSB)",
                                    "Esquecer de duplicar antes de condicionalmente adicionar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo em Código",
                                  "subSteps": [
                                    "Escolha uma biblioteca: use Python com tinyec ou implemente operações básicas.",
                                    "Defina a curva elíptica (ex: y² = x³ + 7 mod 751, P=(0,1)).",
                                    "Codifique funções point_add e point_double.",
                                    "Implemente scalar_mult(k, P) usando double-and-add.",
                                    "Teste com k=3, esperando 3P."
                                  ],
                                  "verification": "Execute o código para k=10 e verifique se resultado coincide com adição manual.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python IDE",
                                    "Biblioteca tinyec ou elliptic-curve",
                                    "Documentação ECC básica"
                                  ],
                                  "tips": "Modularize funções separadamente e teste cada uma com casos conhecidos.",
                                  "learningObjective": "Implementar funcionalmente o double-and-add em código executável.",
                                  "commonMistakes": [
                                    "Overflow em coordenadas modulares",
                                    "Não tratar ponto ao infinito corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Eficiência e Conexão com ECDLP",
                                  "subSteps": [
                                    "Meça tempo de execução para k crescentes (2^10, 2^20, 2^30).",
                                    "Compare com método ingênuo para demonstrar ganho logarítmico.",
                                    "Discuta variações: windowed NAF para otimização extra.",
                                    "Explique como kP eficiente sustenta ECC, mas ECDLP é difícil (não existe inverso eficiente).",
                                    "Resolva exercício: encontre k dado P e Q=kP para k pequeno."
                                  ],
                                  "verification": "Gere gráfico de tempo vs log(k) e explique tendência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código do Step 3",
                                    "Ferramenta de profiling (timeit em Python)",
                                    "Artigos sobre ECDLP"
                                  ],
                                  "tips": "Use k aleatórios grandes gerados por secrets.token_bytes para realismo.",
                                  "learningObjective": "Avaliar performance e ligar ao problema criptográfico fundamental.",
                                  "commonMistakes": [
                                    "Confundir facilidade de kP com facilidade de log discreto",
                                    "Ignorar custos de adição vs duplicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Na curva y² = x³ + 7 mod 751 com P=(0,1), compute 13P usando double-and-add. 13=1101_2: Comece Q=O. Bit3=1: Q=P. Duplique Q=2P. Bit2=1: Q=2P+P=3P, duplique=6P. Bit1=0: duplique=12P. Bit0=1: 12P+P=13P. Resultado: coordenadas finais mod 751.",
                              "finalVerifications": [
                                "Computa corretamente 5P e 7P manualmente para P dado.",
                                "Implementa código que roda kP para k=2^128 sem timeout.",
                                "Explica diferença entre double-and-add e square-and-multiply.",
                                "Identifica quando usar left-to-right vs right-to-left.",
                                "Liga kP eficiente à segurança de ECC contra ataques de força bruta."
                              ],
                              "assessmentCriteria": [
                                "Precisão no pseudocódigo e tracing (sem erros em bits).",
                                "Correção da implementação codificada (testes passam).",
                                "Análise de complexidade O(log k) demonstrada.",
                                "Conexão clara com ECDLP e aplicações criptográficas.",
                                "Eficiência observada em benchmarks.",
                                "Tratamento edge cases (k=0, k=1, P=identidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e geometria algébrica.",
                                "Algoritmos e Estruturas de Dados: Representação binária e recursão.",
                                "Programação: Implementação de primitivas criptográficas.",
                                "Teoria da Computação: Complexidade logarítmica vs linear."
                              ],
                              "realWorldApplication": "A multiplicação escalar kP via double-and-add é o coração de protocolos ECC como ECDSA (usado em Bitcoin para assinaturas) e ECDH (key exchange em TLS/HTTPS), permitindo chaves de 256 bits com segurança equivalente a RSA-3072, otimizando performance em dispositivos IoT e mobiles."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.4",
                        "name": "Aplicações em Criptosistemas Assimétricos",
                        "description": "Uso da ECC em protocolos como troca de chaves e assinaturas digitais, com vantagens sobre outros sistemas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.4.1",
                            "name": "Entender ECDH (Elliptic Curve Diffie-Hellman)",
                            "description": "Explicar o protocolo ECDH para troca de chaves compartilhadas usando multiplicação escalar em curvas elípticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Curvas Elípticas e Operações Básicas",
                                  "subSteps": [
                                    "Estude a equação de Weierstrass: y² = x³ + ax + b mod p.",
                                    "Aprenda a adição de pontos: fórmula para P + Q em uma curva elíptica.",
                                    "Compreenda o ponto no infinito como elemento identidade.",
                                    "Pratique inversão de pontos: -P.",
                                    "Explore propriedades do grupo abeliano formado pelos pontos."
                                  ],
                                  "verification": "Resolva 3 problemas de adição de pontos manualmente e verifique com uma ferramenta como SageMath.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "SageMath ou Python com biblioteca cryptography",
                                    "Artigo 'Elliptic Curve Cryptography' da Wikipedia",
                                    "Vídeo introdutório sobre ECC no YouTube (ex: 3Blue1Brown)"
                                  ],
                                  "tips": "Visualize as curvas usando plotters online para melhor intuição geométrica.",
                                  "learningObjective": "Dominar as operações básicas em curvas elípticas para preparar o terreno para multiplicação escalar.",
                                  "commonMistakes": [
                                    "Confundir adição de pontos com soma cartesiana",
                                    "Esquecer a redução modular",
                                    "Ignorar o ponto no infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Multiplicação Escalar em Curvas Elípticas",
                                  "subSteps": [
                                    "Entenda multiplicação escalar como k * P = P + P + ... + P (k vezes).",
                                    "Aprenda o algoritmo de double-and-add para eficiência.",
                                    "Implemente double-and-add em pseudocódigo.",
                                    "Teste com exemplo: 5 * P usando adições.",
                                    "Discuta a dificuldade do problema log discreto elíptico (ECDLP)."
                                  ],
                                  "verification": "Implemente e execute multiplicação escalar 3 * G em SageMath, confirmando o resultado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "SageMath instalado",
                                    "Pseudocódigo de double-and-add impresso",
                                    "Calculadora modular online"
                                  ],
                                  "tips": "Use representação binária do escalar para otimizar o double-and-add.",
                                  "learningObjective": "Implementar e compreender a operação central do ECDH: multiplicação escalar.",
                                  "commonMistakes": [
                                    "Usar multiplicação ingênua (lenta para grandes k)",
                                    "Erros em shifts binários no double-and-add",
                                    "Confundir ECDLP com fatoração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Protocolo Diffie-Hellman Clássico",
                                  "subSteps": [
                                    "Revise DH modular: g^a mod p e g^b mod p, chave compartilhada g^{ab} mod p.",
                                    "Identifique vulnerabilidades resolvidas por ECC (chaves menores).",
                                    "Simule DH com números pequenos: p=23, g=5, a=6, b=15.",
                                    "Explique o problema log discreto como base de segurança.",
                                    "Compare complexidade computacional com ECC."
                                  ],
                                  "verification": "Calcule manualmente uma troca DH e verifique a chave compartilhada coincide para ambos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para cálculos modulares",
                                    "Calculadora Python para modpow"
                                  ],
                                  "tips": "Sempre reduza mod p após cada operação para evitar números grandes.",
                                  "learningObjective": "Entender a troca de chaves assimétrica básica antes da adaptação elíptica.",
                                  "commonMistakes": [
                                    "Expor chaves privadas",
                                    "Confundir exponenciação modular com multiplicação simples",
                                    "Man-in-the-middle não detectado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Protocolo ECDH: Integração e Simulação Completa",
                                  "subSteps": [
                                    "Defina parâmetros: curva (ex: secp256r1), ponto base G.",
                                    "Alice: gera dA privado, QA = dA * G público.",
                                    "Bob: gera dB privado, QB = dB * G público.",
                                    "Troca: Alice computa dA * QB, Bob dB * QA → ambos dA*dB*G.",
                                    "Simule em código com curvas pequenas."
                                  ],
                                  "verification": "Execute simulação em código onde chaves compartilhadas de Alice e Bob coincidem exatamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com ecpy ou cryptography library",
                                    "Documentação NIST para curvas P-256",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use curvas de teste como secp192k1 para depuração rápida.",
                                  "learningObjective": "Executar e validar o protocolo ECDH end-to-end.",
                                  "commonMistakes": [
                                    "Reutilizar chaves privadas",
                                    "Não validar pontos públicos",
                                    "Ignorar coordenadas comprimidas"
                                  ]
                                }
                              ],
                              "practicalExample": "Alice e Bob querem uma chave compartilhada segura. Usando curva secp256r1 com G base: Alice escolhe dA=12345 secreto, envia QA=dA*G. Bob dB=67890 secreto, envia QB=dB*G. Alice computa dA*QB = 12345*67890*G. Bob dB*QA=67890*12345*G. Resultado idêntico usado para AES simétrico, sem nunca transmitir a chave.",
                              "finalVerifications": [
                                "Explique verbalmente os 4 passos do ECDH sem consultar notas.",
                                "Simule ECDH com parâmetros pequenos e confirme chave compartilhada.",
                                "Identifique por que ECDLP garante segurança (sem resolver log discreto).",
                                "Compare ECDH vs DH em termos de tamanho de chaves e performance.",
                                "Implemente ECDH básico em Python sem bibliotecas prontas.",
                                "Discuta ataques possíveis (ex: invalid curve) e defesas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática de multiplicação escalar (90% correto).",
                                "Correta simulação de troca com chaves coincidentes.",
                                "Compreensão de segurança baseada em ECDLP.",
                                "Eficiência na implementação (usa double-and-add).",
                                "Identificação de pelo menos 3 diferenças chave ECDH vs DH.",
                                "Explicação clara de aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grupos abelianos, logaritmo discreto, álgebra abstrata.",
                                "Física: Geometria de curvas e simetria em mecânica quântica.",
                                "Ciência da Computação: Algoritmos eficientes, programação criptográfica.",
                                "Segurança da Informação: Protocolos de autenticação e integridade.",
                                "Engenharia: Otimização de chaves em dispositivos IoT."
                              ],
                              "realWorldApplication": "ECDH é usado no handshake TLS 1.3 para HTTPS (navegação segura), Signal Protocol no WhatsApp para mensagens criptografadas end-to-end, e VPNs como WireGuard para túneis seguros, permitindo trocas rápidas de chaves em dispositivos móveis com baixa bateria."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.3"
                            ]
                          },
                          {
                            "id": "10.1.3.4.4.2",
                            "name": "Descrever ECDSA (Elliptic Curve Digital Signature Algorithm)",
                            "description": "Detalhar o algoritmo ECDSA para assinaturas digitais baseadas em ECDLP, incluindo geração de chaves, assinatura e verificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Curvas Elípticas e ECDLP",
                                  "subSteps": [
                                    "Estude a equação de curva elíptica y² = x³ + ax + b mod p.",
                                    "Aprenda sobre o grupo cíclico gerado pelo ponto base G.",
                                    "Compreenda o problema do logaritmo discreto elíptico (ECDLP): dada P = kG, encontrar k.",
                                    "Identifique parâmetros de domínio: p, a, b, G, n (ordem de G), h (cofator).",
                                    "Revise por que ECC é mais eficiente que RSA para tamanhos de chave equivalentes."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os quatro componentes principais do ECDLP e liste três parâmetros de domínio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NIST sobre curvas elípticas (P-256)",
                                    "Calculadora modular online",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": [
                                    "Visualize curvas elípticas com ferramentas como GeoGebra.",
                                    "Lembre-se: ECDLP é a base da segurança, similar ao DLP em grupos multiplicativos."
                                  ],
                                  "learningObjective": "Compreender os princípios matemáticos subjacentes ao ECDSA.",
                                  "commonMistakes": [
                                    "Confundir ECC com criptografia simétrica.",
                                    "Ignorar o módulo primo p na aritmética.",
                                    "Achar que G é o ponto gerador único."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Geração de Pares de Chaves ECDSA",
                                  "subSteps": [
                                    "Selecione uma curva elíptica e parâmetros de domínio estabelecidos (ex: secp256k1).",
                                    "Gere uma chave privada d aleatória: 1 ≤ d < n.",
                                    "Calcule a chave pública Q = d * G usando multiplicação escalar de ponto.",
                                    "Armazene o par (d, Q) de forma segura, com d nunca exposto.",
                                    "Verifique que Q está no grupo gerado por G."
                                  ],
                                  "verification": "Gere um par de chaves exemplo com d=123 e valide Q manualmente ou via código simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca Python cryptography ou OpenSSL",
                                    "Documentação secp256k1",
                                    "Editor de código"
                                  ],
                                  "tips": [
                                    "Use geradores de números aleatórios criptograficamente seguros para d.",
                                    "Teste com curvas pequenas para depuração manual."
                                  ],
                                  "learningObjective": "Dominar o processo de geração de chaves assimétricas em ECDSA.",
                                  "commonMistakes": [
                                    "Escolher d = 1 ou n (inseguro).",
                                    "Confundir multiplicação escalar com adição de pontos.",
                                    "Expor d publicamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processo de Geração de Assinatura ECDSA",
                                  "subSteps": [
                                    "Calcule o hash da mensagem m: e = HASH(m), truncado para tamanho de n.",
                                    "Gere efêmero k aleatório: 1 ≤ k < n.",
                                    "Compute ponto R = k * G; r = x_R mod n (se r=0, regenere k).",
                                    "Calcule s = k⁻¹ * (e + r * d) mod n (se s=0, regenere k).",
                                    "A assinatura é (r, s); descarte k."
                                  ],
                                  "verification": "Assine uma mensagem de teste 'Hello' e valide os valores r e s não nulos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Implementação ECDSA em Python (ecdsa library)",
                                    "Mensagem de teste fixa",
                                    "Calculadora para inverso modular"
                                  ],
                                  "tips": [
                                    "k deve ser fresco e secreto por assinatura.",
                                    "Use SHA-256 para hash em curvas P-256."
                                  ],
                                  "learningObjective": "Executar e entender o algoritmo de assinatura passo a passo.",
                                  "commonMistakes": [
                                    "Reutilizar k (leva a vazamento de d).",
                                    "Erro no truncamento de e.",
                                    "Não verificar r ou s = 0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processo de Verificação de Assinatura ECDSA",
                                  "subSteps": [
                                    "Obtenha e = HASH(m), (r, s), Q (chave pública).",
                                    "Verifique 0 < r, s < n; senão, inválida.",
                                    "Calcule w = s⁻¹ mod n.",
                                    "Compute u1 = e * w mod n, u2 = r * w mod n.",
                                    "Calcule ponto S = u1 * G + u2 * Q; se x_S mod n = r, válida.",
                                    "Caso contrário, assinatura inválida."
                                  ],
                                  "verification": "Verifique a assinatura gerada no Step 3 com uma chave pública conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python para verificação",
                                    "Chave pública de teste",
                                    "Hash da mensagem original"
                                  ],
                                  "tips": [
                                    "A verificação não requer d ou k, provando não-repúdio.",
                                    "Implemente com coordenadas comprimidas para eficiência."
                                  ],
                                  "learningObjective": "Validar assinaturas ECDSA sem acesso à chave privada.",
                                  "commonMistakes": [
                                    "Esquecer de verificar intervalos de r e s.",
                                    "Erro na ordem das operações em S.",
                                    "Usar hash errado da mensagem."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Propriedades de Segurança e Comparações",
                                  "subSteps": [
                                    "Discuta ataques: reutilização de k, bias em RNG, side-channels.",
                                    "Compare ECDSA com DSA: ECC oferece chaves menores para segurança igual.",
                                    "Revise padrões: FIPS 186-4, uso em Bitcoin (secp256k1).",
                                    "Estude falhas históricas como Sony PS3 (k reutilizado).",
                                    "Explore extensões como deterministic ECDSA (RFC 6979)."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças de segurança entre ECDSA e RSA.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigos sobre falhas ECDSA",
                                    "Comparação de benchmarks ECC vs RSA",
                                    "Documentação RFC 6979"
                                  ],
                                  "tips": [
                                    "Sempre use bibliotecas auditadas como OpenSSL.",
                                    "Entenda que segurança = 128 bits para P-256."
                                  ],
                                  "learningObjective": "Avaliar robustez e melhores práticas do ECDSA.",
                                  "commonMistakes": [
                                    "Subestimar importância de k randômico.",
                                    "Confundir tamanho de curva com bits de segurança.",
                                    "Ignorar ataques de timing."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Bitcoin, ECDSA com secp256k1 assina transações: gere chave privada d, pública Q; para gastar 1 BTC, assine a transação com k fresco, produzindo (r,s); nós verificam usando Q pública para prevenir gastos duplos.",
                              "finalVerifications": [
                                "Descreva os passos de assinatura e verificação sem consultar notas.",
                                "Gere e verifique uma assinatura ECDSA em código para uma mensagem fixa.",
                                "Explique como reutilizar k compromete d.",
                                "Liste parâmetros de uma curva padrão como P-256.",
                                "Compare eficiência computacional de ECDSA vs RSA-2048.",
                                "Identifique um ataque side-channel possível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática de cada fase (geração, assinatura, verificação).",
                                "Correta identificação de parâmetros e operações modulares.",
                                "Compreensão de dependências de segurança (ex: aleatoriedade de k).",
                                "Capacidade de implementar/verificar exemplo prático.",
                                "Análise de falhas comuns e mitigações.",
                                "Conexão clara com aplicações reais como blockchain."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra abstrata, teoria de grupos e aritmética modular.",
                                "Segurança da Informação: Protocolos de autenticação e não-repúdio.",
                                "Ciência da Computação: Otimização de algoritmos e programação criptográfica.",
                                "Física: Analogias com mecânica quântica em pós-quântica.",
                                "Economia: Aplicações em criptomoedas e contratos inteligentes."
                              ],
                              "realWorldApplication": "ECDSA é usado em Bitcoin para assinaturas de transações, TLS/SSL para autenticação de servidores, SSH para chaves de acesso remoto, e passaportes eletrônicos (ePassports) para verificação de identidade digital segura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.4.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.4.3",
                            "name": "Comparar ECC com RSA",
                            "description": "Analisar vantagens da ECC: chaves menores para segurança equivalente, eficiência computacional e aplicações em dispositivos restritos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de RSA e ECC",
                                  "subSteps": [
                                    "Estude o princípio do RSA: multiplicação de dois grandes primos e dificuldade de fatoração.",
                                    "Revise o princípio da ECC: operações em curvas elípticas sobre campos finitos e problema do logaritmo discreto elíptico.",
                                    "Identifique métricas comuns de comparação: tamanho de chave, segurança e custo computacional.",
                                    "Crie um quadro comparativo inicial com colunas para RSA e ECC.",
                                    "Pesquise níveis de segurança NIST equivalentes (ex: 128-bit, 256-bit)."
                                  ],
                                  "verification": "Quadro comparativo preenchido com fundamentos corretos de ambos os algoritmos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NIST sobre níveis de segurança",
                                    "Artigos introdutórios sobre RSA e ECC",
                                    "Ferramenta de quadro como Google Sheets ou papel"
                                  ],
                                  "tips": "Use diagramas visuais para ilustrar as curvas elípticas vs. aritmética modular do RSA.",
                                  "learningObjective": "Compreender as bases matemáticas que diferenciam RSA e ECC para uma comparação justa.",
                                  "commonMistakes": [
                                    "Confundir logaritmo discreto com fatoração",
                                    "Ignorar campos finitos na ECC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Tamanhos de Chaves para Segurança Equivalente",
                                  "subSteps": [
                                    "Consulte tabelas NIST: ECC 256-bit ≈ RSA 3072-bit para 128-bit de segurança.",
                                    "Calcule ou liste tamanhos: RSA precisa de chaves 4-10x maiores que ECC.",
                                    "Discuta impacto: armazenamento, transmissão e gerenciamento de chaves.",
                                    "Simule com exemplos numéricos: tamanho em bytes (ECC: 32 bytes vs. RSA: 384 bytes).",
                                    "Registre vantagens da ECC em cenários de banda limitada."
                                  ],
                                  "verification": "Tabela com pelo menos 3 níveis de segurança comparados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela NIST SP 800-57",
                                    "Calculadora de tamanho de chave online",
                                    "Planilha para simulações"
                                  ],
                                  "tips": "Memorize: ECC oferece 'bang for the buck' em tamanho de chave.",
                                  "learningObjective": "Quantificar como ECC proporciona segurança equivalente com chaves menores.",
                                  "commonMistakes": [
                                    "Usar tamanhos não equivalentes, como ECC 256 vs. RSA 2048",
                                    "Esquecer overhead de padding no RSA"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Eficiência Computacional",
                                  "subSteps": [
                                    "Meça operações: ECC usa point additions/multiplications vs. exponentiações modulares no RSA.",
                                    "Compare benchmarks: tempo de assinatura/verificações (ECC 10-100x mais rápida em dispositivos restritos).",
                                    "Teste com ferramentas: use OpenSSL para medir tempos em uma máquina local.",
                                    "Avalie consumo de energia e CPU em cenários móveis.",
                                    "Registre métricas: operações por segundo ou ciclos de clock."
                                  ],
                                  "verification": "Gráfico ou tabela com benchmarks comparativos de pelo menos 2 operações (signature/verify).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Biblioteca Python cryptography para testes",
                                    "Hardware de teste (PC e emulador móvel)"
                                  ],
                                  "tips": "Execute testes múltiplos e calcule médias para precisão.",
                                  "learningObjective": "Demonstrar superioridade computacional da ECC em termos de velocidade e recursos.",
                                  "commonMistakes": [
                                    "Testar em hardware inadequado sem normalizar",
                                    "Ignorar otimizações modernas como EdDSA"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Aplicações e Vantagens em Dispositivos Restritos",
                                  "subSteps": [
                                    "Identifique usos: ECC em IoT, smartphones, Bitcoin (secp256k1), TLS 1.3.",
                                    "Compare cenários: RSA em servidores legacy vs. ECC em wearables.",
                                    "Discuta limitações: ECC mais complexa para implementar corretamente.",
                                    "Crie um resumo de prós/contras: ECC vence em mobile/IoT, RSA em compatibilidade.",
                                    "Preveja tendências: migração para ECC pós-quântica híbrida."
                                  ],
                                  "verification": "Relatório de 1 página com exemplos de aplicações e recomendações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Casos de estudo: Bitcoin whitepaper, RFC 8446 (TLS 1.3)",
                                    "Artigos sobre IoT security"
                                  ],
                                  "tips": "Pense em dispositivos reais como smartwatches ou sensores.",
                                  "learningObjective": "Aplicar comparações a contextos reais, destacando nichos da ECC.",
                                  "commonMistakes": [
                                    "Superestimar universalidade da ECC",
                                    "Ignorar ataques side-channel específicos da ECC"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dispositivo IoT como um sensor ambiental, use ECC-256 para assinatura de dados (chave 32 bytes, assinatura rápida <1ms) vs. RSA-3072 (chave 384 bytes, assinatura >10ms), economizando bateria e memória em rede de baixa largura.",
                              "finalVerifications": [
                                "Lista precisa de tamanhos de chaves equivalentes NIST.",
                                "Benchmarks demonstrando eficiência da ECC.",
                                "Identificação de 3 aplicações reais onde ECC supera RSA.",
                                "Quadro comparativo completo com prós/contras.",
                                "Explicação verbal clara das vantagens em dispositivos restritos.",
                                "Recomendação contextualizada para um cenário dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual nas comparações matemáticas e de segurança (30%)",
                                "Profundidade de análise computacional com evidências (25%)",
                                "Relevância de exemplos práticos e aplicações (20%)",
                                "Clareza e estrutura do quadro/relatório (15%)",
                                "Identificação correta de limitações e erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Números e Geometria Algébrica (curvas elípticas).",
                                "Engenharia Elétrica: Otimização de energia em sistemas embarcados.",
                                "Física Computacional: Impacto quântico (Shor's algorithm em ambos).",
                                "Economia Digital: Eficiência em blockchain e criptomoedas."
                              ],
                              "realWorldApplication": "Na implementação de protocolos TLS em smartphones e IoT (ex: WhatsApp end-to-end encryption usa ECC), permitindo comunicações seguras com baixo consumo de bateria e dados limitados, essencial para 5G e edge computing."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.4.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Segurança e Criptoanálise Básica",
                    "description": "Ameaças comuns, como ataques de fatoração, e requisitos de segurança em criptosistemas com chave pública.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Requisitos de Segurança em Criptosistemas com Chave Pública",
                        "description": "Conceitos fundamentais de segurança, incluindo confidencialidade, integridade, autenticidade e não-repúdio, e como eles são atendidos por chaves públicas e privadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar os requisitos básicos de segurança",
                            "description": "Listar e explicar confidencialidade, integridade, autenticidade e não-repúdio em criptosistemas públicos, com exemplos de violações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais dos Requisitos de Segurança",
                                  "subSteps": [
                                    "Defina confidencialidade como a garantia de que apenas partes autorizadas acessem a informação.",
                                    "Defina integridade como a proteção contra modificações não autorizadas dos dados.",
                                    "Defina autenticidade como a verificação da identidade das partes envolvidas.",
                                    "Defina não-repúdio como a impossibilidade de negar a autoria ou recebimento de uma mensagem.",
                                    "Relacione esses conceitos especificamente a criptosistemas com chave pública (ex: RSA)."
                                  ],
                                  "verification": "Crie um glossário pessoal com definições curtas para cada termo e confira com fontes confiáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre criptografia",
                                    "Vídeo introdutório sobre segurança da informação (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas, como confidencialidade sendo um envelope selado.",
                                  "learningObjective": "Identificar e definir os quatro requisitos básicos de segurança em criptosistemas públicos.",
                                  "commonMistakes": "Confundir confidencialidade com privacidade ou ignorar o contexto de chaves públicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar Confidencialidade e Integridade em Criptosistemas Públicos",
                                  "subSteps": [
                                    "Explique como a confidencialidade é alcançada via criptografia assimétrica (chave pública para encriptar, privada para decriptar).",
                                    "Descreva mecanismos como hashes (ex: SHA-256) para integridade.",
                                    "Compare com criptografia simétrica para destacar diferenças em sistemas públicos.",
                                    "Discuta como chaves públicas são distribuídas sem comprometer a confidencialidade.",
                                    "Crie um diagrama simples de fluxo de encriptação/decriptação."
                                  ],
                                  "verification": "Desenhe um fluxograma mostrando como confidencialidade e integridade são implementadas e explique oralmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Documentação RSA de fontes como Wikipedia ou NIST"
                                  ],
                                  "tips": "Lembre-se: chave pública é 'porta aberta para todos', mas só o dono da privada abre.",
                                  "learningObjective": "Explicar mecanismos de confidencialidade e integridade usando exemplos de chaves públicas.",
                                  "commonMistakes": "Achar que chave pública compromete confidencialidade automaticamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Autenticidade e Não-Repúdio",
                                  "subSteps": [
                                    "Descreva assinaturas digitais para autenticidade (hash + encriptação com chave privada).",
                                    "Explique não-repúdio: receptor verifica assinatura com chave pública do remetente.",
                                    "Diferencie autenticidade (quem enviou?) de não-repúdio (não pode negar envio).",
                                    "Estude certificados digitais (PKI) para validar chaves públicas.",
                                    "Simule um processo de assinatura digital passo a passo."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como uma assinatura digital garante ambos os requisitos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de assinaturas digitais em OpenSSL",
                                    "Artigo sobre PKI do Mozilla"
                                  ],
                                  "tips": "Pense em não-repúdio como um 'carimbo digital irrevogável'.",
                                  "learningObjective": "Diferenciar e explicar autenticidade e não-repúdio em contextos de chave pública.",
                                  "commonMistakes": "Confundir não-repúdio com confidencialidade ou subestimar o papel das chaves privadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Analisar Exemplos de Violações",
                                  "subSteps": [
                                    "Liste violações de confidencialidade: interceptação de chave pública mal gerenciada (ex: ataque man-in-the-middle).",
                                    "Exemplos de integridade: colisão de hash ou alteração pós-hash.",
                                    "Violações de autenticidade: falsificação de chaves ou certificados revocados.",
                                    "Não-repúdio falho: negação plausível sem assinatura digital.",
                                    "Crie uma tabela resumindo requisito, mecanismo e violação exemplo."
                                  ],
                                  "verification": "Apresente a tabela e responda perguntas sobre cenários hipotéticos de violações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Casos reais como Heartbleed ou ataques a SSL",
                                    "Planilha Google Sheets para tabela"
                                  ],
                                  "tips": "Use notícias recentes de breaches para tornar exemplos memoráveis.",
                                  "learningObjective": "Listar e exemplificar violações dos quatro requisitos em criptosistemas públicos.",
                                  "commonMistakes": "Dar exemplos genéricos sem ligar a chaves públicas ou exagerar complexidade."
                                }
                              ],
                              "practicalExample": "Em um email criptografado com PGP: o remetente assina com chave privada (autenticidade/não-repúdio), encripta com pública do receptor (confidencialidade). Se o hash for alterado em trânsito (violação de integridade), o receptor detecta ao verificar a assinatura.",
                              "finalVerifications": [
                                "Liste os quatro requisitos sem hesitação.",
                                "Explique cada um com um mecanismo criptográfico específico.",
                                "Identifique violações em um cenário dado.",
                                "Diferencie corretamente autenticidade de não-repúdio.",
                                "Descreva o papel das chaves pública/privada em cada requisito.",
                                "Crie um diagrama de um criptosistema seguro atendendo todos os requisitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições dos quatro requisitos (0-5 pontos).",
                                "Explicação clara de mecanismos em chaves públicas (0-5 pontos).",
                                "Qualidade e relevância dos exemplos de violações (0-5 pontos).",
                                "Uso correto de terminologia criptográfica (0-5 pontos).",
                                "Capacidade de síntese em tabela ou diagrama (0-5 pontos).",
                                "Compreensão de interdependências entre requisitos (0-5 pontos)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e algoritmos como RSA.",
                                "Ética: Implicações de violações em privacidade e responsabilidade digital.",
                                "Direito: Leis de proteção de dados (GDPR) e validade de assinaturas digitais.",
                                "História: Evolução da criptografia desde Enigma até moderna PKI."
                              ],
                              "realWorldApplication": "Em comunicações seguras como HTTPS (confidencialidade/integridade via TLS), assinaturas em contratos digitais (autenticidade/não-repúdio), ou blockchain para transações irrevogáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Explicar o papel das chaves na segurança",
                            "description": "Descrever como chaves públicas e privadas garantem os requisitos de segurança, diferenciando de criptosistemas simétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Criptosistemas Simétricos",
                                  "subSteps": [
                                    "Defina criptografia simétrica e liste exemplos como AES e DES.",
                                    "Explique o problema da distribuição de chaves: mesma chave para cifrar e decifrar.",
                                    "Descreva os requisitos de segurança básicos: confidencialidade, integridade e autenticação.",
                                    "Identifique limitações: risco de interceptação da chave compartilhada.",
                                    "Crie um diagrama simples de comunicação simétrica."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de comunicação simétrica sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; vídeo introdutório sobre AES.",
                                  "tips": "Use analogias como uma caixa de correio compartilhada para ilustrar riscos.",
                                  "learningObjective": "Compreender as bases e limitações da criptografia simétrica.",
                                  "commonMistakes": "Confundir simétrica com assimétrica prematuramente; ignorar problemas de distribuição de chaves."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Criptosistemas Assimétricos e Chaves",
                                  "subSteps": [
                                    "Defina chaves públicas e privadas: pública para cifrar, privada para decifrar.",
                                    "Explique o par de chaves gerado matematicamente (ex: RSA baseado em fatoração).",
                                    "Descreva o processo: receptor publica chave pública, remetente cifra com ela.",
                                    "Discuta propriedades matemáticas: fácil gerar/verificar, difícil reverter sem privada.",
                                    "Gere um par de chaves simples usando uma ferramenta online simulada."
                                  ],
                                  "verification": "Gere e identifique corretamente um par de chaves públicas/privadas em uma ferramenta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta online como RSA key generator (ex: cryptool.org); notas sobre RSA.",
                                  "tips": "Pense na chave pública como um cadeado aberto que qualquer um pode usar, mas só o dono fecha.",
                                  "learningObjective": "Distinguir e gerar pares de chaves assimétricas.",
                                  "commonMistakes": "Inverter papéis das chaves; achar que chaves são senhas simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Garantia de Requisitos de Segurança pelas Chaves",
                                  "subSteps": [
                                    "Confidencialidade: só privada decifra mensagem cifrada com pública.",
                                    "Autenticação: assinatura com privada, verificada com pública.",
                                    "Integridade: hashes assinados detectam alterações.",
                                    "Não-repúdio: assinatura privada prova autoria inescapável.",
                                    "Compare com simétrico: sem necessidade de compartilhar segredo."
                                  ],
                                  "verification": "Escreva uma tabela comparando como cada requisito é atendido em simétrico vs assimétrico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela em Excel ou papel; exemplos de assinaturas digitais.",
                                  "tips": "Use fluxogramas para visualizar fluxos de cifragem e assinatura.",
                                  "learningObjective": "Mapear como chaves assimétricas garantem os quatro requisitos de segurança.",
                                  "commonMistakes": "Esquecer não-repúdio; confundir autenticação com confidencialidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Sintetizar Conceitos",
                                  "subSteps": [
                                    "Resuma diferenças chave: distribuição, escalabilidade, usos.",
                                    "Discuta cenários onde simétrico é preferido (velocidade) vs assimétrico (segurança de chave).",
                                    "Analise um ataque hipotético: MITM em simétrico vs assimétrico.",
                                    "Crie uma explicação em 1 minuto para um leigo.",
                                    "Resolva exercícios de diferenciação."
                                  ],
                                  "verification": "Grave ou escreva uma explicação clara de 1-2 minutos diferenciando os sistemas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Gravador de áudio; exercícios de criptografia online.",
                                  "tips": "Pratique com analogias: simétrico como amigos compartilhando segredo, assimétrico como correio com cadeado público.",
                                  "learningObjective": "Sintetizar e diferenciar papéis das chaves em contextos de segurança.",
                                  "commonMistakes": "Superestimar segurança simétrica; ignorar híbridos como TLS."
                                }
                              ],
                              "practicalExample": "Em um email confidencial usando PGP: Alice cifra com chave pública de Bob (confidencialidade), assina com sua privada (autenticação e não-repúdio). Bob decifra com privada e verifica assinatura com pública de Alice, garantindo integridade sem compartilhar chaves secretas, ao contrário de um chat simétrico onde a chave compartilhada pode vazar.",
                              "finalVerifications": [
                                "Explicar corretamente os papéis de chaves públicas e privadas.",
                                "Listar e descrever os quatro requisitos de segurança garantidos.",
                                "Diferenciar simétrico de assimétrico com exemplos.",
                                "Gerar e usar um par de chaves em uma simulação.",
                                "Identificar falhas em cenários de ataque hipotéticos.",
                                "Explicar não-repúdio com um exemplo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de chaves e requisitos (30%).",
                                "Profundidade de explicação: detalhes matemáticos e processos (25%).",
                                "Diferenciação clara: comparação simétrico vs assimétrico (20%).",
                                "Uso de exemplos e analogias: clareza e relevância (15%).",
                                "Verificações práticas: diagramas e simulações funcionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e algoritmos como fatoração prima (RSA).",
                                "História: Evolução da criptografia de Enigma a Diffie-Hellman.",
                                "Física/Engenharia: Aplicações em comunicações quânticas seguras.",
                                "Ética: Implicações de privacidade e vigilância digital."
                              ],
                              "realWorldApplication": "Em HTTPS/TLS para navegação segura: servidores usam chaves públicas para estabelecer sessões, garantindo que dados de cartões de crédito sejam confidenciais e transações autênticas, prevenindo fraudes em e-commerce global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Avaliar níveis de segurança",
                            "description": "Discutir métricas como força computacional e tamanho de chaves para resistir a ataques em sistemas como RSA e Diffie-Hellman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de níveis de segurança em criptografia",
                                  "subSteps": [
                                    "Definir segurança computacional e suas bases probabilísticas.",
                                    "Explicar o conceito de 'quebra' de um criptossistema por adversários.",
                                    "Identificar métricas principais: força computacional e tamanho de chaves.",
                                    "Diferenciar segurança incondicional de condicional.",
                                    "Revisar princípios como redução e oráculos."
                                  ],
                                  "verification": "Resumir em um parágrafo os conceitos chave e métricas, sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Criptografia Moderna' de Katz e Lindell (capítulos iniciais)",
                                    "Notas de aula sobre criptografia básica",
                                    "Vídeos introdutórios no YouTube sobre segurança computacional"
                                  ],
                                  "tips": "Use analogias como 'força de uma fechadura' para visualizar força computacional.",
                                  "learningObjective": "Entender as bases teóricas para avaliação de segurança em criptosistemas.",
                                  "commonMistakes": [
                                    "Confundir segurança com inviolabilidade absoluta",
                                    "Ignorar o aspecto probabilístico da segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a força computacional e complexidade de ataques",
                                  "subSteps": [
                                    "Estudar funções de complexidade: exponencial vs polinomial.",
                                    "Calcular tempo estimado para ataques brute-force em diferentes potências computacionais.",
                                    "Discutir impacto de hardware (CPUs, GPUs, ASICs) na força computacional.",
                                    "Exemplificar com curvas de segurança NIST para chaves simétricas e assimétricas.",
                                    "Comparar força em cenários atuais vs futuros (ex: computadores quânticos)."
                                  ],
                                  "verification": "Resolver 3 problemas de cálculo de tempo de ataque e explicar resultados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python para simulações",
                                    "Tabelas NIST de força computacional",
                                    "Artigo 'Post-Quantum Cryptography' do NIST"
                                  ],
                                  "tips": "Use logs para estimar tempos: 2^80 operações ≈ 10^24 anos em hardware atual.",
                                  "learningObjective": "Quantificar a resistência de sistemas contra ataques baseados em poder computacional.",
                                  "commonMistakes": [
                                    "Subestimar avanços em hardware",
                                    "Confundir bits de segurança com tamanho de chave diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o impacto do tamanho de chaves em RSA e Diffie-Hellman",
                                  "subSteps": [
                                    "Explicar como o tamanho de módulo afeta segurança em RSA (fatoração).",
                                    "Detalhar segurança em Diffie-Hellman (log discreto).",
                                    "Consultar recomendações atuais: RSA-2048, DH-2048+.",
                                    "Simular redução de segurança com chaves menores (ex: RSA-1024).",
                                    "Discutir curvas elípticas como alternativa (ECDHE)."
                                  ],
                                  "verification": "Criar tabela comparativa de tamanhos de chaves vs bits de segurança para RSA/DH.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta online como Keylength.com",
                                    "Documentação IETF RFC 3766",
                                    "Python com biblioteca cryptography para testes"
                                  ],
                                  "tips": "Lembre: segurança RSA ≈ 0.5 * log2(tamanho módulo) em bits aproximados.",
                                  "learningObjective": "Relacionar tamanho de chaves com resistência prática a ataques conhecidos.",
                                  "commonMistakes": [
                                    "Ignorar ataques side-channel que não dependem só do tamanho",
                                    "Usar tamanhos obsoletos sem contexto histórico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e comparar níveis de segurança em cenários reais",
                                  "subSteps": [
                                    "Avaliar RSA vs DH em termos de vulnerabilidades (ex: padding oracles em RSA).",
                                    "Discutir migração para post-quântico (ex: rejeitar DH pequeno).",
                                    "Realizar análise de risco para um sistema hipotético (ex: VPN corporativa).",
                                    "Recomendar configurações seguras baseadas em guidelines (NIST, ECRYPT).",
                                    "Debater trade-offs: segurança vs performance."
                                  ],
                                  "verification": "Produzir relatório de 1 página avaliando segurança de um par de chaves RSA/DH específico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Guidelines NIST SP 800-57",
                                    "Ferramentas como OpenSSL para gerar/testar chaves",
                                    "Relatórios de vulnerabilidades CVE relacionadas"
                                  ],
                                  "tips": "Sempre valide com múltiplas fontes; NIST é referência ouro.",
                                  "learningObjective": "Aplicar métricas para julgar e recomendar níveis de segurança adequados.",
                                  "commonMistakes": [
                                    "Focar só em teoria sem performance prática",
                                    "Recomendar chaves sem considerar contexto de uso"
                                  ]
                                }
                              ],
                              "practicalExample": "Avalie a segurança de um sistema usando RSA-1024 para assinatura digital em um servidor web: calcule bits de segurança (~80), tempo estimado para fatoração com supercomputador atual (viável em meses), e recomende upgrade para RSA-3072 (128+ bits).",
                              "finalVerifications": [
                                "Explicar corretamente força computacional e seu impacto em ataques.",
                                "Calcular bits de segurança para chaves RSA/DH de tamanhos variados.",
                                "Identificar quando um tamanho de chave é inadequado (ex: <2048 bits hoje).",
                                "Comparar RSA e DH em cenários de ataque específicos.",
                                "Propor recomendações baseadas em standards atuais.",
                                "Discutir limitações futuras como computação quântica."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual nas métricas de segurança (90%+ correto).",
                                "Capacidade de cálculos quantitativos sem erros.",
                                "Uso de exemplos reais e standards (NIST/ECRYPT).",
                                "Análise equilibrada de trade-offs (segurança/performance).",
                                "Clareza na comunicação de avaliações.",
                                "Identificação de erros comuns em configurações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (fatoração, log discreto).",
                                "Física: Computação Quântica e Algoritmo de Shor.",
                                "Engenharia de Software: Implementação segura de protocolos (TLS).",
                                "Ética: Implicações de segurança em privacidade e dados sensíveis."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS para sites bancários, avaliar se chaves DH de 1024 bits em servidores antigos são vulneráveis a ataques Logjam, recomendando upgrades para garantir confidencialidade contra nações-estado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Ameaças Comuns em Criptosistemas com Chave Pública",
                        "description": "Principais vulnerabilidades, com foco em ataques como fatoração de inteiros e problemas de log discreto.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Descrever o ataque de fatoração em RSA",
                            "description": "Explicar como a fatoração do módulo n compromete a chave privada em RSA, incluindo exemplos com números pequenos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Geração de Chaves no RSA",
                                  "subSteps": [
                                    "Escolha dois números primos grandes e distintos, p e q.",
                                    "Calcule n = p * q (módulo público).",
                                    "Calcule φ(n) = (p-1)*(q-1) (função totiente de Euler).",
                                    "Escolha e tal que 1 < e < φ(n) e gcd(e, φ(n)) = 1 (expoente público).",
                                    "Calcule d tal que d * e ≡ 1 mod φ(n) (expoente privado, usando algoritmo estendido de Euclides)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os passos de geração de chaves e calcule φ(n) para p=5, q=11.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou calculadora; referência rápida ao algoritmo RSA.",
                                  "tips": "Lembre-se: n é público, mas p e q são secretos; sua multiplicação é fácil, mas fatoração é difícil para números grandes.",
                                  "learningObjective": "Compreender os componentes fundamentais das chaves RSA e seu relacionamento.",
                                  "commonMistakes": "Confundir e com d ou esquecer que φ(n) requer p-1 e q-1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Papel Crítico do Módulo n",
                                  "subSteps": [
                                    "Reconheça que n é o produto de dois primos grandes e é publicado como parte da chave pública (n, e).",
                                    "Entenda que a segurança do RSA depende da dificuldade computacional de fatorar n em p e q.",
                                    "Discuta por que n pequeno é vulnerável: fatoração é viável com testes simples.",
                                    "Compare com n grande: requer tempo exponencial para fatorar.",
                                    "Liste propriedades de p e q que facilitam ataques se mal escolhidos (ex: próximos um do outro)."
                                  ],
                                  "verification": "Descreva em uma frase por que fatorar n quebra o RSA e dê um exemplo de n pequeno (ex: 15=3*5).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Quadro ou software de desenho para diagramas de chaves RSA.",
                                  "tips": "Pense em n como uma 'caixa preta' cujo conteúdo (p,q) protege d.",
                                  "learningObjective": "Explicar por que a fatoração de n é a fraqueza central do RSA.",
                                  "commonMistakes": "Achar que conhecer e permite fatorar n diretamente; e é coprimo com φ(n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender o Processo de Fatoração e Recuperação da Chave Privada",
                                  "subSteps": [
                                    "Com n fatorado em p e q, recalcule φ(n) = (p-1)*(q-1).",
                                    "Use o algoritmo estendido de Euclides para encontrar d = e⁻¹ mod φ(n).",
                                    "Demonstre que agora você pode descriptografar: m = c^d mod n para qualquer cifra c.",
                                    "Explique matematicamente: sem p e q, calcular d diretamente é impraticável.",
                                    "Teste com ferramenta online de Euclides para validar."
                                  ],
                                  "verification": "Dado n=15, e=3, p=3, q=5, calcule φ(n) e d corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou Python/IDLE para Euclides estendido; tabela de primos pequenos.",
                                  "tips": "Pratique o inverso modular manualmente primeiro com números minúsculos.",
                                  "learningObjective": "Dominar os passos exatos para comprometer a chave privada via fatoração.",
                                  "commonMistakes": "Erro no cálculo de φ(n) ou inverso modular; confundir mod φ(n) com mod n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Exemplo Prático com Números Pequenos",
                                  "subSteps": [
                                    "Gere chaves: p=61, q=53, n=3233, φ(n)=3120, e=17, d=2753.",
                                    "Fatore n=3233 em 53*61 usando divisão por primos até √n.",
                                    "Recalcule φ(n)=(53-1)*(61-1)=52*60=3120.",
                                    "Verifique d: 17*2753 mod 3120 =1.",
                                    "Cifre m=65: c=65^17 mod 3233=2790; descriptografe 2790^2753 mod 3233=65."
                                  ],
                                  "verification": "Reproduza o exemplo completo e descriptografe uma mensagem teste corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou script Python simples para potências modulares.",
                                  "tips": "Use trial division para fatorar: teste divisores ímpares até √n ≈57.",
                                  "learningObjective": "Aplicar o ataque de fatoração em um cenário concreto.",
                                  "commonMistakes": "Erros aritméticos em potências modulares; não reduzir mod n a cada passo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Implicações e Medidas de Proteção",
                                  "subSteps": [
                                    "Discuta por que RSA usa primos de 1024+ bits: fatoração leva séculos.",
                                    "Mencione algoritmos de fatoração: trial division, Pollard's rho, GNFS.",
                                    "Explique mitigações: geradores de primos seguros, padding (OAEP).",
                                    "Relacione com ameaças quânticas (algoritmo de Shor).",
                                    "Compare com alternativas como ECC."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo riscos e proteções do ataque de fatoração.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Artigos ou vídeos curtos sobre história da fatoração RSA (ex: RSA-129 challenge).",
                                  "tips": "Foquem em 'por quê' grandeza importa, não em fatorar números reais grandes.",
                                  "learningObjective": "Contextualizar o ataque no panorama de segurança criptográfica.",
                                  "commonMistakes": "Subestimar dificuldade prática; achar que computadores modernos fatoram 2048 bits facilmente."
                                }
                              ],
                              "practicalExample": "Exemplo: Chave pública (n=3233, e=17). Fatore n=3233=53*61. φ(n)=52*60=3120. d=17⁻¹ mod 3120=2753. Cifra 'A'(65): 65^17 mod 3233=2790. Descriptografa: 2790^2753 mod 3233=65. Ataque bem-sucedido!",
                              "finalVerifications": [
                                "Fatore corretamente n pequeno e recupere d.",
                                "Explicar o teorema chinês do resto como base da descriptografia RSA.",
                                "Descrever sequência: n → p,q → φ(n) → d.",
                                "Executar cripto/descripto completo pós-fatoração.",
                                "Identificar limitação: ataque só funciona se n for fatorável rapidamente.",
                                "Comparar tempo de fatoração para n=15 vs n=1024 bits."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação da dependência de segurança em fatoração (90-100%).",
                                "Correção matemática em exemplo com números pequenos (sem erros aritméticos).",
                                "Clareza na descrição do fluxo de ataque (passos sequenciais lógicos).",
                                "Inclusão de verificação prática (cifra/descripto funciona).",
                                "Profundidade em implicações (menciona tamanho de chaves e algoritmos).",
                                "Uso de terminologia correta (φ(n), inverso modular, etc.)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, totiente de Euler, Euclides estendido).",
                                "Matemática: Algoritmos de Fatoração e Complexidade Computacional.",
                                "Física/Quântica: Algoritmo de Shor e Computação Quântica.",
                                "História: Evolução da Criptografia (desafio RSA-129 fatorado em 1994)."
                              ],
                              "realWorldApplication": "Na cibersegurança, entender o ataque de fatoração justifica o uso de chaves RSA de 2048+ bits em protocolos como HTTPS/TLS; motiva transição para pós-quântica (ex: lattice-based crypto) e é base para auditorias de chaves fracas em certificados SSL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Identificar outras ameaças comuns",
                            "description": "Listar e exemplificar ataques como log discreto em Diffie-Hellman e ataques de texto plano escolhido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Protocolo Diffie-Hellman",
                                  "subSteps": [
                                    "Explicar o problema do log discreto e sua relevância para DH.",
                                    "Descrever o protocolo DH passo a passo: escolha de p, g, cálculo de chaves públicas e privadas.",
                                    "Identificar por que DH é vulnerável ao log discreto se p for pequeno.",
                                    "Resolver um exemplo numérico simples de DH com números pequenos.",
                                    "Discutir mitigações como uso de grupos elípticos."
                                  ],
                                  "verification": "Capacidade de explicar DH e resolver um exemplo numérico corretamente em um quiz.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook, calculadora, artigo sobre DH (RFC 2631), ferramenta online como DH calculator.",
                                  "tips": "Use números primos pequenos inicialmente para facilitar cálculos manuais.",
                                  "learningObjective": "Compreender a base matemática do DH e sua vulnerabilidade principal.",
                                  "commonMistakes": "Confundir chaves públicas com privadas ou ignorar a necessidade de p grande."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Ataque de Log Discreto em Diffie-Hellman",
                                  "subSteps": [
                                    "Definir formalmente o problema do log discreto: dado g^a mod p, encontrar a.",
                                    "Explorar métodos de ataque: baby-step giant-step, Pollard's rho.",
                                    "Simular um ataque em um DH fraco com p=101, g=2.",
                                    "Analisar complexidade computacional e impacto em chaves fracas.",
                                    "Comparar com DH moderno (DH-2048 ou ECDH)."
                                  ],
                                  "verification": "Implementar ou simular um ataque baby-step em código simples e verificar recuperação da chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python ou SageMath para simulação, vídeo tutorial sobre baby-step giant-step.",
                                  "tips": "Comece com p pequeno (<1000) para testar algoritmos manualmente.",
                                  "learningObjective": "Dominar o mecanismo e detecção do ataque de log discreto em DH.",
                                  "commonMistakes": "Subestimar o tempo de computação para p grande ou confundir com fatoração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Ataques de Texto Plano Escolhido (CPA)",
                                  "subSteps": [
                                    "Definir CPA: atacante envia plaintexts escolhidos e observa ciphertexts.",
                                    "Exemplificar em RSA sem padding: m^e mod n revela m se e pequeno.",
                                    "Discutir oráculos de descriptografia e ataques padding como PKCS#1 v1.5.",
                                    "Simular um cenário CPA em um criptossistema híbrido fraco.",
                                    "Explicar por que OAEP ou padding híbrido mitiga CPA."
                                  ],
                                  "verification": "Descrever um ataque CPA passo a passo e identificar vulnerabilidades em um diagrama dado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Documentação OpenSSL, exemplos de código em Python (pycryptodome), diagramas de ataques CPA.",
                                  "tips": "Pense como um atacante: o que você aprenderia de múltiplos pares plaintext-ciphertext?",
                                  "learningObjective": "Identificar e exemplificar ataques CPA em PKI.",
                                  "commonMistakes": "Confundir CPA com CCA (chosen-ciphertext) ou ignorar padding."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar e Exemplificar Outras Ameaças Comuns em PKI",
                                  "subSteps": [
                                    "Listar ameaças: man-in-the-middle em DH sem autenticação, ataques a geradores de números aleatórios, side-channels (timing/power).",
                                    "Exemplificar cada uma com cenários reais (ex: Logjam para DH export-grade).",
                                    "Criar uma tabela comparativa: ameaça, alvo, exemplo, mitigação.",
                                    "Praticar identificando ameaças em protocolos como TLS 1.0 vs 1.3.",
                                    "Discutir ataques quânticos como Shor em DH/RSA."
                                  ],
                                  "verification": "Produzir uma lista de 8 ameaças com exemplos e mitigações, revisada por pares.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Lista de CWE relacionadas a crypto (CWE-327), relatórios de vulnerabilidades (Logjam, POODLE).",
                                  "tips": "Agrupe ameaças por tipo: matemáticas, implementações, protocolos.",
                                  "learningObjective": "Capacidade de listar e contextualizar múltiplas ameaças em PKI.",
                                  "commonMistakes": "Focar só em uma ameaça ou listar sem exemplos concretos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação e Análise Integrada",
                                  "subSteps": [
                                    "Analisar um caso real: ataque Logjam em servidores web.",
                                    "Criar flashcards com ameaças e respostas.",
                                    "Simular uma auditoria: dado um setup DH, identificar riscos.",
                                    "Debater mitigações em grupo ou autoavaliação.",
                                    "Testar conhecimento com quiz interativo."
                                  ],
                                  "verification": "Aprovação em quiz com 90% de acerto sobre identificação de ameaças.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas como testssl.sh, Anki para flashcards, casos de estudo (Heartbleed, mas focado em PKI).",
                                  "tips": "Use mnemonics para lembrar ameaças: 'DLCP-MIS' (Discrete Log, Chosen Plaintext, MITM, Implementation, Side-channel).",
                                  "learningObjective": "Aplicar conhecimento para identificar ameaças em cenários reais.",
                                  "commonMistakes": "Generalizar demais sem ligar a PKI específica."
                                }
                              ],
                              "practicalExample": "Em um chat app usando DH para key exchange sem autenticação, um atacante usa baby-step giant-step para resolver log discreto em um grupo fraco (p=1024 bits export-grade), recuperando a chave de sessão e lendo mensagens. Identifique o risco e sugira usar ECDH com curvas seguras.",
                              "finalVerifications": [
                                "Listar corretamente log discreto e CPA com definições precisas.",
                                "Exemplificar pelo menos 3 ataques adicionais em PKI (ex: MITM, weak RNG, side-channel).",
                                "Simular um ataque simples em ferramenta ou código.",
                                "Explicar mitigações para cada ameaça listada.",
                                "Identificar vulnerabilidades em um diagrama de protocolo DH/TLS.",
                                "Produzir tabela comparativa de ameaças com exemplos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: definições e exemplos corretos (30%)",
                                "Completude: cobertura de todas as ameaças principais (25%)",
                                "Profundidade: explicação de mecanismos e mitigações (20%)",
                                "Exemplos práticos: relevância e concretude (15%)",
                                "Clareza e organização: uso de tabelas/diagramas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Problemas de log discreto e teoria dos números.",
                                "Segurança de Redes: Integração em protocolos como TLS/IPsec.",
                                "Programação: Implementação e teste de ataques em Python/Sage.",
                                "Ética em TI: Implicações de vulnerabilidades em privacidade.",
                                "Física/Engenharia: Ataques side-channel (power analysis)."
                              ],
                              "realWorldApplication": "Auditar configurações TLS em servidores web para detectar grupos DH fracos vulneráveis a Logjam, ou revisar apps mobile para CPA em criptografia híbrida, prevenindo breaches como os vistos no WhatsApp early versions ou Equifax (RSA fraco)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Analisar impactos de ataques",
                            "description": "Avaliar consequências de ataques bem-sucedidos em protocolos reais, como quebra de sessões seguras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar ataques comuns em criptosistemas de chave pública",
                                  "subSteps": [
                                    "Liste ataques como Man-in-the-Middle (MitM), ataques de replay e padding oracle.",
                                    "Descreva o mecanismo básico de cada ataque em termos de chaves públicas/privadas.",
                                    "Classifique-os por tipo: confidencialidade, integridade ou autenticação.",
                                    "Pesquise exemplos históricos como o ataque Lucky Thirteen em TLS.",
                                    "Crie um diagrama simples mostrando o fluxo do ataque."
                                  ],
                                  "verification": "Crie uma tabela com 5 ataques, seus mecanismos e classificações; revise com um colega ou ferramenta de linting.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação RFC de TLS (RFC 5246), diagramas online de ataques (ex: OWASP), papel e caneta ou ferramenta como Draw.io.",
                                  "tips": "Comece com ataques visuais para fixar conceitos; use analogias como 'chave falsa na porta'.",
                                  "learningObjective": "Compreender os mecanismos fundamentais de ataques para basear análises de impacto.",
                                  "commonMistakes": "Confundir ataques de chave simétrica com assimétrica; ignorar dependências de protocolos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar protocolos reais vulneráveis e cenários de sucesso",
                                  "subSteps": [
                                    "Analise protocolos como TLS 1.2, SSH e PGP, focando em handshakes de chave pública.",
                                    "Identifique vulnerabilidades conhecidas, como POODLE ou BEAST em sessões seguras.",
                                    "Simule um ataque bem-sucedido usando Wireshark para capturar tráfego criptografado.",
                                    "Documente o ponto exato de quebra da sessão segura.",
                                    "Compare com versões corrigidas (ex: TLS 1.3)."
                                  ],
                                  "verification": "Capture e anote um tráfego TLS simulado mostrando quebra hipotética; valide com checklist de elementos chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Wireshark, servidor local com OpenSSL, tutoriais de captura de pacotes (ex: Wireshark wiki).",
                                  "tips": "Use ambientes de teste isolados para evitar riscos reais; foque em logs de handshake.",
                                  "learningObjective": "Mapear ataques a protocolos reais para contextualizar impactos.",
                                  "commonMistakes": "Não diferenciar falhas de implementação de falhas criptográficas; superestimar simplicidade de ataques."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear consequências imediatas e em cascata",
                                  "subSteps": [
                                    "Avalie violações CIA (Confidencialidade, Integridade, Disponibilidade) por ataque.",
                                    "Liste impactos como roubo de sessões, falsificação de mensagens ou DoS.",
                                    "Quantifique: ex., número de sessões quebradas em um ataque em massa.",
                                    "Considere vetores secundários como escalada de privilégios pós-quebra.",
                                    "Crie um fluxograma de impactos em cadeia."
                                  ],
                                  "verification": "Produza um relatório de 1 página com fluxograma e 3 exemplos quantificados; auto-avaliação por rubrica.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de diagramação (Lucidchart ou Excalidraw), relatórios de CVEs (ex: Heartbleed CVE-2014-0160).",
                                  "tips": "Use matriz CIA para estruturar; pense em 'o que acontece em 5 minutos vs. 5 dias'.",
                                  "learningObjective": "Desenvolver habilidade em decompor impactos multicamadas de ataques.",
                                  "commonMistakes": "Focar só em impactos técnicos, ignorando operacionais; subestimar propagação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impactos sistêmicos e propor métricas",
                                  "subSteps": [
                                    "Analise efeitos econômicos, reputacionais e regulatórios (ex: GDPR multas).",
                                    "Defina métricas como tempo de exposição, custo de mitigação e perda de dados.",
                                    "Compare casos reais: Equifax breach vs. ataques menores.",
                                    "Discuta lições aprendidas e resiliência futura.",
                                    "Sintetize em um resumo executivo."
                                  ],
                                  "verification": "Escreva um resumo de 300 palavras com métricas; apresente e receba feedback.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Relatórios de breaches (ex: Verizon DBIR), calculadoras de custo de breach (IBM Cost of Data Breach).",
                                  "tips": "Priorize dados reais de breaches para credibilidade; use escalas qualitativas/quantitativas.",
                                  "learningObjective": "Integrar análise técnica com implicações holísticas.",
                                  "commonMistakes": "Ignorar contexto não-técnico; usar números inventados sem fontes."
                                }
                              ],
                              "practicalExample": "Analise o impacto do ataque Heartbleed (CVE-2014-0160) em sessões HTTPS: um atacante lê 64KB de memória por heartbeat, expondo chaves privadas, levando à quebra de milhões de sessões seguras, roubo de certificados e exposição de dados de usuários em sites como Yahoo.",
                              "finalVerifications": [
                                "Pode listar e explicar 4 impactos CIA de um ataque específico em TLS.",
                                "Cria diagramas precisos de fluxo de ataque e consequências.",
                                "Quantifica riscos com métricas reais de casos históricos.",
                                "Identifica pelo menos 3 vetores de mitigação pós-análise.",
                                "Compara impactos em 2 protocolos diferentes.",
                                "Produz relatório coeso ligando técnica a implicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: 30% (mecanismos e protocolos corretos).",
                                "Profundidade de análise: 25% (cascata de impactos detalhada).",
                                "Uso de evidências: 20% (citações de CVEs/RFCs).",
                                "Clareza e estrutura: 15% (diagramas e resumos legíveis).",
                                "Criatividade em conexões: 10% (métricas e cenários realistas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números em ataques como fatoração RSA.",
                                "Ética e Sociedade: Implicações de privacidade em breaches massivos.",
                                "Economia: Cálculo de custos de ataques cibernéticos.",
                                "Direito: Conformidade com regulamentações como GDPR pós-ataque."
                              ],
                              "realWorldApplication": "Em equipes de cibersegurança, analisa impactos para priorizar patches em infraestruturas críticas, como bancos ou hospitais, ajudando a estimar riscos em auditorias de conformidade e relatórios de incidentes para stakeholders."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Criptoanálise Básica Aplicada a Chave Pública",
                        "description": "Técnicas elementares de análise criptográfica, incluindo modelos de ataque e resistências probabilísticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Classificar modelos de ataque",
                            "description": "Diferenciar ataques ciphertext-only, known-plaintext, chosen-plaintext e chosen-ciphertext em contextos de chave pública.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Criptografia Assimétrica e Criptoanálise",
                                  "subSteps": [
                                    "Explique o que é criptografia de chave pública e seus componentes principais (chave pública e privada).",
                                    "Defina criptoanálise como a tentativa de quebrar sistemas criptográficos sem a chave secreta.",
                                    "Liste os quatro modelos de ataque básicos: ciphertext-only (COA), known-plaintext (KPA), chosen-plaintext (CPA) e chosen-ciphertext (CCA).",
                                    "Discuta por que esses modelos são relevantes em sistemas de chave pública como RSA.",
                                    "Identifique o nível crescente de poder do atacante nos modelos (COA < KPA < CPA < CCA)."
                                  ],
                                  "verification": "Resuma em uma tabela comparativa os quatro modelos com uma frase curta para cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre RSA e criptografia assimétrica",
                                    "Diagrama de fluxo de ataques criptográficos"
                                  ],
                                  "tips": "Use mnemônicos: COA (só ciphertext), KPA (conhece plaintext), CPA (escolhe plaintext), CCA (escolhe ciphertext).",
                                  "learningObjective": "Compreender o contexto e hierarquia dos modelos de ataque em chave pública.",
                                  "commonMistakes": [
                                    "Confundir chave pública com simétrica",
                                    "Ignorar que CCA é o mais poderoso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Detalhes de Cada Modelo de Ataque",
                                  "subSteps": [
                                    "Para COA: Descreva cenário onde atacante tem apenas ciphertext capturado e tenta recuperar plaintext ou chave.",
                                    "Para KPA: Explique quando atacante conhece pares plaintext-ciphertext e usa para deduzir chave.",
                                    "Para CPA: Detalhe como atacante escolhe plaintexts e obtém ciphertexts correspondentes via oráculo.",
                                    "Para CCA: Descreva acesso a oráculo de descriptografia (exceto para o ciphertext alvo).",
                                    "Forneça exemplos simples matemáticos para cada em contexto RSA."
                                  ],
                                  "verification": "Escreva uma definição precisa e um exemplo para cada um dos quatro ataques.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de ataques em RSA (documentos PDF ou vídeos tutoriais)",
                                    "Ferramenta de notas como Notion ou papel"
                                  ],
                                  "tips": "Visualize com fluxogramas: desenhe o atacante interagindo com o oráculo em CPA/CCA.",
                                  "learningObjective": "Dominar definições e cenários específicos de cada ataque.",
                                  "commonMistakes": [
                                    "Pensar que CPA permite descriptografia (não, só encriptação)",
                                    "Confundir KPA com CPA"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Ataques em Contextos de Chave Pública",
                                  "subSteps": [
                                    "Compare níveis de informação disponível ao atacante em chave pública vs. simétrica.",
                                    "Analise por que RSA é vulnerável a CPA/CCA se padding inadequado (ex: PKCS#1 v1.5).",
                                    "Discuta IND-CPA e IND-CCA como noções de segurança semântica.",
                                    "Identifique ataques híbridos comuns em protocolos reais.",
                                    "Crie uma matriz de comparação: linhas (ataques), colunas (info atacante, viabilidade em RSA)."
                                  ],
                                  "verification": "Preencha uma matriz comparativa correta sem consultar materiais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigo sobre segurança RSA (ex: Bleichenbacher's attack)",
                                    "Planilha Excel ou Google Sheets para matriz"
                                  ],
                                  "tips": "Lembre: em chave pública, atacante sempre conhece chave pública, o que afeta todos os modelos.",
                                  "learningObjective": "Diferenciar impactos específicos em criptosistemas assimétricos.",
                                  "commonMistakes": [
                                    "Aplicar lógica de chave simétrica diretamente",
                                    "Subestimar CCA em esquemas sem IND-CCA"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação de Cenários de Ataque",
                                  "subSteps": [
                                    "Analise 5 cenários hipotéticos e classifique cada um como COA, KPA, CPA ou CCA.",
                                    "Simule um ataque CPA contra RSA com ferramenta online (ex: CrypTool).",
                                    "Debata limitações: quando um ataque CPA se torna CCA?",
                                    "Crie seu próprio cenário e classifique-o.",
                                    "Avalie segurança de um protocolo simples (ex: envio de email criptografado)."
                                  ],
                                  "verification": "Classifique corretamente 5 cenários fornecidos ou criados, explicando o raciocínio.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Lista de 10 cenários de ataques (gerados ou de quizzes online)",
                                    "CrypTool ou SageMath para simulações"
                                  ],
                                  "tips": "Pergunte: 'O atacante escolhe o quê?' para distinguir CPA/CCA de passivos.",
                                  "learningObjective": "Aplicar classificação em cenários reais e simulados.",
                                  "commonMistakes": [
                                    "Classificar KPA como CPA por ter 'plaintext'",
                                    "Ignorar contexto de chave pública"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede Wi-Fi pública, você captura um ciphertext RSA de uma sessão HTTPS. Sem mais dados, é COA. Se você conhece o header HTTP padrão (plaintext parcial), torna-se KPA. Se controla o servidor para encriptar textos escolhidos, é CPA. Se pode descriptografar exceto o alvo, é CCA.",
                              "finalVerifications": [
                                "Liste e defina os 4 modelos sem erros.",
                                "Classifique corretamente 5 cenários variados.",
                                "Explique por que CCA é o mais forte em chave pública.",
                                "Identifique um ataque real (ex: Padding Oracle) como CCA.",
                                "Monte uma tabela comparativa precisa.",
                                "Discuta IND-CPA vs IND-CCA brevemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusões entre modelos).",
                                "Uso correto de exemplos contextualizados em chave pública.",
                                "Profundidade na matriz comparativa (cobertura de viabilidades).",
                                "Classificação precisa em exercícios (90%+ acerto).",
                                "Explicações claras de diferenças hierárquicas.",
                                "Integração de conceitos como oráculos e IND-segurança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e complexidade computacional em RSA.",
                                "Segurança Cibernética: Análise de vulnerabilidades em protocolos TLS/SSL.",
                                "Redes de Computadores: Interceptação de tráfego em ataques Man-in-the-Middle.",
                                "Ética e Direito: Implicações legais de criptoanálise em comunicações.",
                                "Inteligência Artificial: Uso de ML em ataques COA modernos."
                              ],
                              "realWorldApplication": "Avaliar a segurança de sistemas como HTTPS, PGP e blockchain wallets, determinando se assumem CPA ou CCA security, ajudando a escolher algoritmos resistentes como OAEP-padded RSA ou post-quânticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Entender criptoanálise probabilística",
                            "description": "Explicar o papel de algoritmos probabilísticos na resistência a ataques, com exemplos de padding e randomização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da criptoanálise probabilística",
                                  "subSteps": [
                                    "Defina criptoanálise e diferencie abordagens determinísticas de probabilísticas.",
                                    "Estude o conceito de probabilidade em contextos criptográficos, incluindo entropia e aleatoriedade.",
                                    "Analise por que ataques determinísticos falham em sistemas probabilísticos.",
                                    "Revise exemplos históricos de falhas em criptosistemas sem probabilidade.",
                                    "Registre anotações sobre os princípios chave."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos principais e compartilhe com um colega para feedback.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook ou papel para anotações",
                                    "Artigo introdutório sobre criptoanálise (ex: Wikipedia - Cryptanalysis)"
                                  ],
                                  "tips": "Comece com definições simples antes de mergulhar em fórmulas matemáticas.",
                                  "learningObjective": "Identificar e explicar os pilares da criptoanálise probabilística.",
                                  "commonMistakes": [
                                    "Confundir probabilidade com aleatoriedade pura",
                                    "Ignorar o papel da entropia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar algoritmos probabilísticos na criptografia",
                                  "subSteps": [
                                    "Estude algoritmos como OAEP (Optimal Asymmetric Encryption Padding) e seu uso probabilístico.",
                                    "Analise como a randomização é incorporada em cifras como ElGamal probabilístico.",
                                    "Compare cifras determinísticas (ex: RSA sem padding) com probabilísticas.",
                                    "Implemente um exemplo simples de randomização em pseudocódigo.",
                                    "Discuta vantagens em termos de segurança semântica."
                                  ],
                                  "verification": "Crie um diagrama comparativo entre algoritmos determinísticos e probabilísticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Documentação oficial de OAEP (RFC 8018)"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o impacto da probabilidade.",
                                  "learningObjective": "Descrever o papel de algoritmos probabilísticos na elevação da resistência a ataques.",
                                  "commonMistakes": [
                                    "Subestimar a necessidade de fontes de entropia de alta qualidade",
                                    "Confundir padding com autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos práticos de padding e randomização",
                                  "subSteps": [
                                    "Implemente padding PKCS#7 em um exemplo de criptografia simétrica.",
                                    "Teste randomização em um cenário de chave pública, como hybrid encryption.",
                                    "Simule um ataque chosen-plaintext em uma versão sem padding e observe falhas.",
                                    "Meça a distribuição de cifras geradas com e sem randomização.",
                                    "Documente os resultados em uma tabela comparativa."
                                  ],
                                  "verification": "Execute o código e capture screenshots das distribuições de output.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com bibliotecas cryptography ou pycryptodome",
                                    "Ambiente Jupyter Notebook"
                                  ],
                                  "tips": "Use geradores de números aleatórios seguros como secrets module em Python.",
                                  "learningObjective": "Aplicar padding e randomização em exemplos concretos.",
                                  "commonMistakes": [
                                    "Usar random() em vez de cryptographically secure random",
                                    "Não testar múltiplas execuções para verificar não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar resistência a ataques e sintetizar conhecimentos",
                                  "subSteps": [
                                    "Estude ataques como padding oracle e como probabilidade mitiga.",
                                    "Analise cenários de side-channel onde probabilidade ainda ajuda.",
                                    "Crie um relatório explicando como esses mecanismos previnem ataques.",
                                    "Debata limitações, como dependência de entropia.",
                                    "Prepare um exemplo de explicação oral ou escrita."
                                  ],
                                  "verification": "Responda a 5 perguntas hipotéticas sobre cenários de ataque.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos sobre ataques padding oracle (ex: POODLE)",
                                    "Ferramentas de simulação online de criptografia"
                                  ],
                                  "tips": "Pense em termos de 'o que o atacante sabe' versus 'o que ele pode prever'.",
                                  "learningObjective": "Explicar com exemplos como a probabilidade confere resistência.",
                                  "commonMistakes": [
                                    "Acreditar que probabilidade torna invulnerável a todos os ataques",
                                    "Ignorar ataques quânticos em contextos clássicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de mensagens seguras como Signal, implemente randomização no padding de mensagens antes de criptografar com RSA híbrido, testando que mensagens idênticas geram cifras diferentes, resistindo a ataques de análise de padrões.",
                              "finalVerifications": [
                                "Explicar em suas palavras o papel da probabilidade na criptografia.",
                                "Identificar falhas em um criptossistema sem randomização.",
                                "Implementar e testar um padding simples.",
                                "Discutir limitações de entropia insuficiente.",
                                "Comparar dois algoritmos probabilísticos.",
                                "Simular um ataque e demonstrar mitigação."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (entende probabilidade vs. determinismo).",
                                "Profundidade nos exemplos de padding/randomização.",
                                "Capacidade de análise de ataques e resistências.",
                                "Clareza na explicação oral/escrita.",
                                "Criatividade em aplicações práticas.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Distribuições.",
                                "Estatística: Testes de Entropia e Análise de Aleatoriedade.",
                                "Física: Fontes de Ruído Quântico para RNG.",
                                "Ciência da Computação: Algoritmos e Complexidade.",
                                "Ética: Implicações de Segurança em Privacidade Digital."
                              ],
                              "realWorldApplication": "Na segurança de protocolos web como TLS 1.3, padding probabilístico e randomização (ex: em AEAD modes) previnem ataques como BEAST e Lucky Thirteen, garantindo confidencialidade em comunicações HTTPS cotidianas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1",
                              "10.1.3.5.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Criptoanálise Básica",
                "description": "Técnicas fundamentais para atacar e quebrar sistemas criptográficos, identificando vulnerabilidades.",
                "totalSkills": 50,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Modelos de Ataque em Criptoanálise",
                    "description": "Classificação fundamental dos ataques: ciphertext-only, known-plaintext, chosen-plaintext e chosen-ciphertext.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Ataque Apenas-Cifrado (Ciphertext-Only Attack)",
                        "description": "Modelo de ataque onde o criptoanalista possui apenas acesso ao texto cifrado (ciphertext) e tenta recuperar o texto plano ou a chave secreta, explorando padrões estatísticos ou fraquezas no algoritmo de cifragem.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Definir o Ataque Apenas-Cifrado",
                            "description": "Explicar as premissas do ataque, incluindo o que o atacante sabe (apenas ciphertext) e os objetivos (recuperar plaintext ou chave), com exemplos de frequência de letras em idiomas naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Ataque Apenas-Cifrado",
                                  "subSteps": [
                                    "Pesquise a definição padrão de um ataque apenas-cifrado em fontes confiáveis como livros de criptografia ou sites acadêmicos.",
                                    "Identifique que esse é o modelo de ataque mais restritivo, onde o atacante tem acesso apenas ao texto cifrado.",
                                    "Compare brevemente com outros modelos de ataque (conhecido-plaintext, chosen-plaintext) para contextualizar.",
                                    "Anote as características principais: passivo, sem interação com o sistema de cifragem.",
                                    "Registre exemplos históricos iniciais, como análise de frequência em cifra de substituição monoalfabética."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras com pelo menos 50 palavras e compare com fontes originais para precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Criptografia e Segurança de Rede' ou site Khan Academy Criptografia",
                                    "Caderno de anotações",
                                    "Acesso à internet"
                                  ],
                                  "tips": "Use analogias como 'tentar adivinhar um texto embaralhado só olhando as letras misturadas'.",
                                  "learningObjective": "Compreender o conceito fundamental e sua posição no espectro de ataques criptoanalíticos.",
                                  "commonMistakes": [
                                    "Confundir com ataques que usam plaintext conhecido.",
                                    "Achar que é impossível sem mais informações (na verdade, é viável para cifras fracas)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Conhecimento do Atacante (Premissas de Entrada)",
                                  "subSteps": [
                                    "Liste explicitamente o que o atacante sabe: apenas o ciphertext capturado (ex: interceptação de mensagens).",
                                    "Especifique o que o atacante NÃO sabe: plaintext original, chave de cifragem, algoritmo exato (embora suspeite).",
                                    "Discuta suposições comuns: linguagem natural do plaintext (inglês, português), comprimento suficiente do ciphertext.",
                                    "Crie um diagrama simples mostrando 'Atacante → Ciphertext' sem setas para plaintext ou chave.",
                                    "Explique por que apenas ciphertext é suficiente para ataques em cifras fracas."
                                  ],
                                  "verification": "Crie uma tabela comparativa 'Sabe / Não Sabe' e revise se todos os elementos estão corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Exemplos de ciphertexts online (ex: dcode.fr)",
                                    "Documentação de criptoanálise"
                                  ],
                                  "tips": "Pense em cenários reais: espião interceptando rádio inimigo.",
                                  "learningObjective": "Dominar as premissas exatas de entrada para o modelo de ataque apenas-cifrado.",
                                  "commonMistakes": [
                                    "Incluir conhecimento implícito como 'algoritmo público' sem justificativa.",
                                    "Ignorar suposições sobre idioma ou estatísticas linguísticas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os Objetivos do Ataque",
                                  "subSteps": [
                                    "Estabeleça objetivos primários: recuperar o plaintext original ou a chave de cifragem.",
                                    "Explique que recuperar a chave permite descriptografar mensagens futuras.",
                                    "Discuta objetivos secundários: inferir propriedades do algoritmo ou padrões de uso.",
                                    "Diferencie entre ataques parciais (algumas mensagens) e totais (chave completa).",
                                    "Escreva uma declaração clara: 'Dado apenas C, encontrar P tal que D_C(P) = C ou encontrar K.'"
                                  ],
                                  "verification": "Formule os objetivos em uma frase formal e teste explicando para um colega ou gravando áudio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io para fluxogramas",
                                    "Notas anteriores"
                                  ],
                                  "tips": "Use notação matemática simples: C = E_K(P), onde E é encriptação.",
                                  "learningObjective": "Articular precisamente os alvos do ataque para guiar análises futuras.",
                                  "commonMistakes": [
                                    "Focar só em plaintext, ignorando recuperação de chave.",
                                    "Confundir objetivos com métodos de ataque."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Exemplos de Frequência de Letras",
                                  "subSteps": [
                                    "Reúna tabelas de frequência de letras para português/inglês (ex: E mais comum ~12-13%).",
                                    "Gere ou pegue um ciphertext de substituição monoalfabética simples.",
                                    "Conte frequências no ciphertext e mapeie para plaintext esperado.",
                                    "Demonstre como isso leva à quebra parcial ou total.",
                                    "Compare antes/depois para visualizar o sucesso do ataque."
                                  ],
                                  "verification": "Aplique a análise a um ciphertext de 100 caracteres e recupere pelo menos 70% do plaintext.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como cryptii.com ou dcode.fr",
                                    "Tabela de frequências impressa",
                                    "Texto cifrado exemplo"
                                  ],
                                  "tips": "Comece com ciphertext curto para prática rápida; ignore espaços/pontuação inicialmente.",
                                  "learningObjective": "Aplicar premissas e objetivos em um exemplo concreto de análise de frequência.",
                                  "commonMistakes": [
                                    "Usar frequências erradas para o idioma.",
                                    "Não considerar digrafos/trigramas para precisão."
                                  ]
                                }
                              ],
                              "practicalExample": "Capture um ciphertext monoalfabético de uma mensagem em português: 'ZMXMNZMXM'. Conte frequências (Z=40%, M=60%). Sabendo que 'A' é comum (~15%), mas 'E' é mais (~13%), mapeie Z→E, M→S para quebrar como 'ESSESESS'. Isso recupera plaintext parcial só com ciphertext.",
                              "finalVerifications": [
                                "Defina corretamente o ataque em 1 parágrafo sem erros factuais.",
                                "Liste precisamente o que atacante sabe/não sabe.",
                                "Explique objetivos com notação matemática básica.",
                                "Aplique análise de frequência a um exemplo e recupere >50% plaintext.",
                                "Diferencie de outros modelos de ataque.",
                                "Crie diagrama visual das premissas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% correto nas premissas e objetivos (30%).",
                                "Clareza na explicação: linguagem acessível e sem ambiguidades (20%).",
                                "Exemplo prático: análise de frequência funcional e correta (25%).",
                                "Profundidade: inclusão de suposições linguísticas e limitações (15%).",
                                "Originalidade: explicação em palavras próprias, não copiada (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística e análise de frequências probabilísticas.",
                                "História: Uso em WWII para quebrar códigos Enigma (fase inicial).",
                                "Linguística: Propriedades estatísticas de idiomas naturais.",
                                "Informática: Programação para contadores de frequência em Python."
                              ],
                              "realWorldApplication": "Em cibersegurança moderna, entender ataques apenas-cifrado ajuda a avaliar cifras fracas como substituição em mensagens antigas ou malwares primitivos; historicamente, essencial para Aliados decifrarem comunicações Axis só com interceptações de rádio."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Identificar Exemplos Históricos",
                            "description": "Analisar casos reais como a quebra do cifrão simples de substituição monoalfabética usando análise de frequência, referenciando Schneier (2015).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Cifras de Substituição Monoalfabética",
                                  "subSteps": [
                                    "Defina o que é uma cifra de substituição monoalfabética: cada letra do plaintext é substituída por uma única letra do ciphertext usando uma chave fixa.",
                                    "Estude exemplos básicos de encriptação manual com uma tabela de substituição.",
                                    "Identifique fraquezas inerentes, como preservação das frequências relativas de letras.",
                                    "Compare com cifras modernas para contextualizar a evolução.",
                                    "Anote a importância histórica em comunicações antigas."
                                  ],
                                  "verification": "Crie uma cifra monoalfabética simples e descriptografe-a manualmente sem chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Applied Cryptography de Bruce Schneier (2015, Capítulo 1)",
                                    "Vídeos introdutórios no YouTube sobre cifras clássicas",
                                    "Papel e lápis para tabelas de substituição"
                                  ],
                                  "tips": "Comece com o alfabeto inglês padrão e foque em letras comuns como E, T, A.",
                                  "learningObjective": "Explicar o funcionamento e limitações de cifras monoalfabéticas.",
                                  "commonMistakes": [
                                    "Confundir com polialfabéticas como Vigenère",
                                    "Ignorar variações culturais em frequências de letras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Análise de Frequência de Letras",
                                  "subSteps": [
                                    "Colete frequências padrão de letras em inglês: E(12.7%), T(9.1%), A(8.2%), etc.",
                                    "Aprenda a contar frequências em um texto cifrado longo (mínimo 100 caracteres).",
                                    "Mapeie as letras mais frequentes do ciphertext para as do plaintext.",
                                    "Ajuste iterativamente a chave parcial testando palavras comuns.",
                                    "Use ferramentas simples como planilhas para visualizar gráficos de barras."
                                  ],
                                  "verification": "Aplique análise de frequência a um texto cifrado curto e recupere 70% do plaintext.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabelas de frequência de letras (online ou Schneier 2015)",
                                    "Planilha Excel/Google Sheets",
                                    "Textos cifrados de exemplo online (ex: dcode.fr)"
                                  ],
                                  "tips": "Priorize bigramas (ex: TH, HE) após unigramas para refinar.",
                                  "learningObjective": "Realizar análise estatística básica para quebrar cifras monoalfabéticas.",
                                  "commonMistakes": [
                                    "Usar textos curtos onde estatísticas falham",
                                    "Não considerar espaços ou pontuação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pesquisar Exemplos Históricos de Quebras",
                                  "subSteps": [
                                    "Identifique casos como a cifra confederada na Guerra Civil Americana (1861-1865).",
                                    "Estude a quebra por Friedman e equipe usando análise de frequência.",
                                    "Pesquise outros: cifra de Mary Queen of Scots ou comunicações romanas de Augusto.",
                                    "Registre contexto histórico: impacto na guerra ou política.",
                                    "Extraia lições: necessidade de cifras mais complexas."
                                  ],
                                  "verification": "Liste 3 exemplos com datas, contextos e métodos de quebra.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Schneier (2015, seções sobre história da criptografia)",
                                    "Wikipedia: Frequency Analysis, Confederate Cipher",
                                    "Livros: The Codebreakers de Kahn"
                                  ],
                                  "tips": "Use fontes primárias ou acadêmicas para precisão.",
                                  "learningObjective": "Associar teoria a eventos históricos reais.",
                                  "commonMistakes": [
                                    "Focar só em WWII, ignorando exemplos clássicos",
                                    "Não verificar fontes confiáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar um Exemplo Histórico com Análise de Frequência",
                                  "subSteps": [
                                    "Selecione texto cifrado confederado (disponível online).",
                                    "Conte frequências e mapeie para inglês padrão.",
                                    "Descriptografe iterativamente, validando com contexto histórico.",
                                    "Compare resultado com descriptografias conhecidas.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Descriptografe com precisão >80% e explique mismatches.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Texto cifrado confederado (ex: sites de criptografia histórica)",
                                    "Ferramentas: CyberChef ou papel",
                                    "Schneier (2015) para validação"
                                  ],
                                  "tips": "Trabalhe com textos longos para melhor estatística.",
                                  "learningObjective": "Aplicar criptoanálise a caso real de ciphertext-only attack.",
                                  "commonMistakes": [
                                    "Parar na primeira tentativa sem iterações",
                                    "Ignorar anagramas em palavras parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Referenciar Schneier e Extrair Lições",
                                  "subSteps": [
                                    "Leia trechos de Schneier (2015) sobre análise de frequência.",
                                    "Compare com exemplos históricos estudados.",
                                    "Discuta evolução para cifras polialfabéticas e modernas (AES).",
                                    "Identifique lições para design criptográfico atual.",
                                    "Crie um resumo conectando ao modelo de ataque ciphertext-only."
                                  ],
                                  "verification": "Escreva parágrafo citando Schneier e ligando a 2 exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Applied Cryptography (2015) - capítulos iniciais",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use citações APA para precisão acadêmica.",
                                  "learningObjective": "Contextualizar história na criptografia contemporânea.",
                                  "commonMistakes": [
                                    "Não citar fontes corretamente",
                                    "Subestimar impacto em cibersegurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a cifra confederada da Guerra Civil: texto 'QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD' mapeado via frequência (E->Z, T->L, etc.), revelando 'THIS IS A SECRET MESSAGE' após iterações, como descrito em histórias de criptoanálise.",
                              "finalVerifications": [
                                "Citar corretamente 3+ exemplos históricos com detalhes.",
                                "Descriptografar texto monoalfabético com >80% acurácia.",
                                "Explicar papel da análise de frequência em ataques ciphertext-only.",
                                "Referenciar Schneier (2015) com contexto relevante.",
                                "Identificar 2 lições para criptografia moderna.",
                                "Produzir relatório visual com gráficos de frequência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de exemplos históricos (30%)",
                                "Correta aplicação de análise de frequência (25%)",
                                "Profundidade de análise e verificações (20%)",
                                "Referenciação acadêmica e conexões (15%)",
                                "Clareza em relatórios e exemplos práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "História: Guerras e comunicações secretas",
                                "Matemática: Estatística e probabilidades",
                                "Língua: Análise linguística de frequências",
                                "Cibersegurança: Evolução de protocolos",
                                "Ética: Implicações de interceptações"
                              ],
                              "realWorldApplication": "Em cibersegurança, entender quebras históricas como a confederada informa design de cifragem resistente a ataques ciphertext-only, essencial em proteção de dados em redes modernas, evitando fraquezas em IoT ou comunicações antigas legadas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Avaliar Vulnerabilidades",
                            "description": "Discutir como algoritmos determinísticos são suscetíveis a esse ataque devido a padrões no ciphertext, contrastando com algoritmos probabilísticos (Paar & Pelzl, 2010).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Algoritmos Determinísticos e Probabilísticos",
                                  "subSteps": [
                                    "Defina algoritmo determinístico: mesma plaintext e chave sempre produzem o mesmo ciphertext.",
                                    "Defina algoritmo probabilístico: introduz aleatoriedade, produzindo ciphertexts diferentes para a mesma plaintext e chave.",
                                    "Estude exemplos: Cifra de César (determinístico) vs. AES em modo CBC com IV aleatório (probabilístico).",
                                    "Leia seção relevante de Paar & Pelzl (2010) sobre propriedades de cifradores.",
                                    "Anote diferenças em termos de previsibilidade e padrões."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre os dois tipos de algoritmos com exemplos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Understanding Cryptography' de Paar & Pelzl (2010), notas de aula, acesso a documentação de AES.",
                                  "tips": "Use diagramas para visualizar o processo de encriptação em ambos os casos.",
                                  "learningObjective": "Diferenciar algoritmos determinísticos e probabilísticos e suas implicações em padrões de saída.",
                                  "commonMistakes": "Confundir modo de operação com o algoritmo base; ignorar o papel do IV em modos probabilísticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Suscetibilidade de Algoritmos Determinísticos a COA",
                                  "subSteps": [
                                    "Gere múltiplos ciphertexts com a mesma plaintext e chave usando um cifrador determinístico (ex: ECB mode).",
                                    "Identifique padrões no ciphertext: blocos idênticos para plaintexts idênticos.",
                                    "Simule um COA: observe como frequência de padrões revela informações sobre plaintext.",
                                    "Discuta como atacantes exploram isso sem chave ou plaintext conhecida.",
                                    "Registre observações em uma tabela comparativa de ciphertexts."
                                  ],
                                  "verification": "Demonstre geração de ciphertexts idênticos e aponte padrões visíveis no output.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de criptografia como OpenSSL ou Python com pycryptodome, planilha para tabelas.",
                                  "tips": "Use textos repetitivos como 'AAA...BBB' para plaintext para destacar padrões claramente.",
                                  "learningObjective": "Reconhecer como padrões previsíveis no ciphertext facilitam ataques apenas-cifrado em cifradores determinísticos.",
                                  "commonMistakes": "Usar modos probabilísticos por engano; não repetir encriptações suficientes para ver padrões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar com Algoritmos Probabilísticos",
                                  "subSteps": [
                                    "Gere ciphertexts com o mesmo plaintext e chave em modo probabilístico (ex: CBC com IV aleatório).",
                                    "Compare outputs: note ausência de padrões repetidos devido à aleatoriedade.",
                                    "Explique matematicamente: probabilidade de colisões vs. determinismo puro.",
                                    "Simule COA em ambos e compare dificuldade de extração de informações.",
                                    "Referencie Paar & Pelzl (2010) para exemplos teóricos."
                                  ],
                                  "verification": "Produza pelo menos 10 ciphertexts probabilísticos e prove que nenhum padrão idêntico emerge.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Mesmas ferramentas de criptografia, calculadora para probabilidades simples.",
                                  "tips": "Fixe a chave mas varie IV para simular encriptações independentes.",
                                  "learningObjective": "Compreender por que a aleatoriedade mitiga vulnerabilidades a COA.",
                                  "commonMistakes": "Reutilizar IV acidentalmente, criando padrões falsos; subestimar impacto da aleatoriedade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Documentar Vulnerabilidades",
                                  "subSteps": [
                                    "Classifique algoritmos comuns como determinísticos ou probabilísticos (ex: DES-ECB vs. AES-GCM).",
                                    "Avalie risco de COA para cada: alta para determinísticos, baixa para probabilísticos.",
                                    "Crie um relatório resumindo suscetibilidades e recomendações.",
                                    "Discuta cenários reais onde falhas determinísticas foram exploradas.",
                                    "Autoavalie compreensão respondendo a perguntas de verificação."
                                  ],
                                  "verification": "Submeta relatório com classificações corretas e análise de pelo menos 3 algoritmos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Lista de algoritmos criptográficos, template de relatório.",
                                  "tips": "Priorize algoritmos históricos vs. modernos para contexto.",
                                  "learningObjective": "Aplicar conceitos para avaliar vulnerabilidades reais em cifradores.",
                                  "commonMistakes": "Classificar incorretamente modos de operação; ignorar contexto histórico."
                                }
                              ],
                              "practicalExample": "Usando Python e pycryptodome, encripte 'HELLO WORLD' 5 vezes com AES-ECB (determinístico): todos os ciphertexts são idênticos, revelando padrões. No modo CBC com IV novo: cada um é único, frustrando análise de frequência em COA.",
                              "finalVerifications": [
                                "Explique por que AES-ECB falha em COA mas AES-CBC resiste.",
                                "Identifique padrões em um ciphertext ECB fornecido.",
                                "Gere e compare 3 pares de ciphertexts determinísticos vs. probabilísticos.",
                                "Resuma argumento de Paar & Pelzl (2010) sobre suscetibilidade.",
                                "Avalie risco de COA para um cifrador dado como 'alto/baixo/médio' com justificativa.",
                                "Discuta uma vulnerabilidade histórica ligada a determinismo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção determinístico vs. probabilístico (30%)",
                                "Identificação correta de padrões em ciphertexts (25%)",
                                "Análise comparativa profunda e referenciada (20%)",
                                "Exemplos práticos gerados e documentados (15%)",
                                "Clareza e estrutura do relatório final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise probabilística e teoria da informação.",
                                "Segurança da Informação: Modelos de ameaça e melhores práticas.",
                                "História da Computação: Cifradores como Enigma e lições aprendidas.",
                                "Programação: Implementação de criptografia em Python/Java."
                              ],
                              "realWorldApplication": "Em sistemas bancários, uso de ECB determinístico expôs dados de cartões em imagens satélites (ataque de mosaico); modos probabilísticos como GCM previnem isso, essenciais em HTTPS e blockchain para proteger transações contra eavesdroppers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Ataque Texto-Plano Conhecido (Known-Plaintext Attack)",
                        "description": "Modelo onde o atacante tem acesso a pares de texto plano e texto cifrado correspondentes, permitindo explorar relações diretas para derivar a chave ou o algoritmo.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Definir o Ataque Texto-Plano Conhecido",
                            "description": "Descrever o cenário, incluindo fontes comuns de plaintext conhecido como cabeçalhos de protocolos (ex: HTTP), e os objetivos de recuperação da chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Ataques Baseados em Texto-Plano",
                                  "subSteps": [
                                    "Revise os modelos básicos de criptoanálise, incluindo ciphertext-only, known-plaintext, chosen-plaintext e chosen-ciphertext.",
                                    "Identifique que ataques known-plaintext assumem acesso a pares plaintext-ciphertext conhecidos.",
                                    "Compare com outros ataques para destacar a vantagem do known-plaintext.",
                                    "Estude o papel do texto-plano conhecido na quebra de cifras.",
                                    "Anote diferenças chave entre known-plaintext e outros modelos."
                                  ],
                                  "verification": "Crie um diagrama comparando os 4 modelos de ataque e explique verbalmente ou por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Artigo introdutório sobre criptoanálise (ex: Wikipedia - Known-plaintext attack)"
                                  ],
                                  "tips": "Use tabelas para comparações visuais; foque em exemplos históricos como Enigma.",
                                  "learningObjective": "Compreender o contexto dos ataques known-plaintext dentro da criptoanálise.",
                                  "commonMistakes": [
                                    "Confundir com chosen-plaintext attack",
                                    "Ignorar a importância de pares conhecidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Precisamente o Ataque Texto-Plano Conhecido",
                                  "subSteps": [
                                    "Defina formalmente: um ataque onde o adversário tem acesso a plaintexts conhecidos e seus correspondentes ciphertexts.",
                                    "Descreva o cenário: o atacante conhece partes do plaintext devido a padrões ou estruturas previsíveis.",
                                    "Explique que o objetivo é recuperar a chave ou descriptografar outros textos.",
                                    "Escreva uma definição em suas próprias palavras.",
                                    "Teste a definição com um exemplo simples de cifra de substituição."
                                  ],
                                  "verification": "Escreva uma definição de 50-100 palavras e valide com uma fonte confiável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de criptografia (ex: Handbook of Applied Cryptography PDF)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Inclua termos como 'par (P, C)' onde P é plaintext e C é ciphertext conhecidos.",
                                  "learningObjective": "Formular uma definição precisa e completa do known-plaintext attack.",
                                  "commonMistakes": [
                                    "Definir muito vagamente sem mencionar pares conhecidos",
                                    "Confundir com brute-force"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Fontes Comuns de Plaintext Conhecido",
                                  "subSteps": [
                                    "Liste fontes: cabeçalhos HTTP (ex: 'GET / HTTP/1.1\\r\\nHost:'), campos fixos em protocolos como TLS handshakes.",
                                    "Explore outros exemplos: rodapés de emails, formatos de arquivos padronizados (PDF headers).",
                                    "Pesquise casos reais como ataques em WEP Wi-Fi ou cifras antigas.",
                                    "Crie uma tabela com 5 fontes comuns e seus plaintexts conhecidos.",
                                    "Discuta como protocolos modernos mitigam isso (ex: padding aleatório)."
                                  ],
                                  "verification": "Apresente uma lista de 5 fontes com exemplos de plaintext e explique relevância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Internet para pesquisa (RFCs HTTP/TLS)",
                                    "Capturas de pacotes Wireshark (opcional)"
                                  ],
                                  "tips": "Use ferramentas como Wireshark para visualizar headers reais; foque em protocolos cotidianos.",
                                  "learningObjective": "Reconhecer e exemplificar fontes reais de plaintext conhecido em cenários práticos.",
                                  "commonMistakes": [
                                    "Limitar a exemplos teóricos sem fontes reais",
                                    "Ignorar protocolos modernos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever os Objetivos e Processo de Recuperação da Chave",
                                  "subSteps": [
                                    "Explique objetivos: recuperar a chave secreta ou descriptografar mensagens adicionais.",
                                    "Descreva o processo: usar pares (P,C) para resolver equações criptográficas (ex: em cifras lineares).",
                                    "Ilustre com um exemplo matemático simples, como atacar cifra de Vigenère com known-plaintext.",
                                    "Discuta limitações e quando o ataque é viável.",
                                    "Resuma o impacto em sistemas criptográficos."
                                  ],
                                  "verification": "Desenvolva um fluxograma do processo de ataque e simule com um toy example.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para simulação simples",
                                    "Exemplos de código cripto (ex: GitHub repos)"
                                  ],
                                  "tips": "Comece com cifras fracas para entender; evite pular matemática.",
                                  "learningObjective": "Articular os objetivos e passos para recuperação de chaves via known-plaintext.",
                                  "commonMistakes": [
                                    "Focar só em definição sem objetivos",
                                    "Superestimar viabilidade em cifras modernas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um tráfego HTTP criptografado com cifra fraca, o cabeçalho 'HTTP/1.1 200 OK\\r\\n' é plaintext conhecido. Com vários pacotes capturados, um atacante usa pares (P,C) para resolver a chave RC4 em ataques WEP-like, permitindo descriptografar o resto do conteúdo.",
                              "finalVerifications": [
                                "Definição correta do known-plaintext attack recitada sem erros.",
                                "Lista precisa de 3+ fontes de plaintext conhecido com exemplos.",
                                "Explicação clara dos objetivos de recuperação da chave.",
                                "Diagrama ou tabela comparando com outros ataques.",
                                "Exemplo prático HTTP ou similar demonstrado.",
                                "Discussão de mitigações modernas incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição (80% match com fontes padrão).",
                                "Profundidade de exemplos de plaintext conhecido (mínimo 3 reais).",
                                "Clareza na descrição de objetivos e processo.",
                                "Uso correto de terminologia criptográfica.",
                                "Criatividade em conexões práticas e limitações.",
                                "Completude da estrutura (todos elementos presentes)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares e álgebra para resolver chaves.",
                                "Redes de Computadores: Análise de protocolos como HTTP/TLS.",
                                "História: Quebra da Enigma na WWII via known-plaintext.",
                                "Segurança da Informação: Mitigações em cifras modernas (AES-GCM)."
                              ],
                              "realWorldApplication": "Esse ataque foi crucial na quebra do WEP Wi-Fi nos anos 2000, onde IVs repetidos e headers conhecidos permitiram recuperação de chaves, levando à depreciação do protocolo e adoção do WPA2/3."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Aplicar em Cifragem Simétrica",
                            "description": "Demonstrar como resolver chaves em cifras como Vigenère com plaintext conhecido, usando equações modulares (Menezes, 1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Cifra de Vigenère e o Ataque Known-Plaintext",
                                  "subSteps": [
                                    "Revise a fórmula da cifra de Vigenère: C_i = (P_i + K_j) mod 26, onde j = i mod len(K).",
                                    "Explique o ataque known-plaintext: use pares conhecidos (P, C) para derivar K via K_j = (C_i - P_i) mod 26.",
                                    "Identifique que múltiplos pares por posição da chave permitem resolver shifts repetidos.",
                                    "Discuta limitações: chave curta e plaintext longo são ideais.",
                                    "Estude referência: Menezes (1996), capítulo sobre cifras clássicas."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios e escreva a fórmula corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Menezes (1996) ou PDF online",
                                    "Papel e caneta",
                                    "Tabela alfabética A-Z (0-25)"
                                  ],
                                  "tips": "Use letras maiúsculas e ignore espaços/pontuação inicialmente.",
                                  "learningObjective": "Entender matematicamente como known-plaintext revela chaves simétricas em Vigenère.",
                                  "commonMistakes": [
                                    "Confundir adição modular com subtração",
                                    "Ignorar repetição da chave"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Pares de Plaintext e Ciphertext Conhecidos",
                                  "subSteps": [
                                    "Selecione ou crie um plaintext conhecido (ex: 'ATTACKATDAWN').",
                                    "Obtenha o ciphertext correspondente (ex: fornecido como 'LXFOPVEFRNHR').",
                                    "Alinhe pares letra a letra, numerando posições (1-based).",
                                    "Determine ou estime o comprimento da chave (k) via análise de frequência ou tentativa.",
                                    "Crie uma tabela com colunas: Posição, P_i, C_i."
                                  ],
                                  "verification": "Tabela completa com pelo menos 10 pares alinhados sem erros de alinhamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para mod 26",
                                    "Exemplo de texto criptografado"
                                  ],
                                  "tips": "Comece com plaintext repetitivo para múltiplos hits por posição da chave.",
                                  "learningObjective": "Preparar dados precisos para formular equações modulares.",
                                  "commonMistakes": [
                                    "Misalign pares P-C",
                                    "Esquecer converter letras para números (A=0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Equações Modulares para Cada Posição da Chave",
                                  "subSteps": [
                                    "Para cada posição j=1 a k: colete todos i onde i mod k = j.",
                                    "Para cada tal i: escreva K_j ≡ (C_i - P_i) mod 26.",
                                    "Verifique consistência: todos os (C_i - P_i) mod 26 devem ser iguais para o mesmo j.",
                                    "Se inconsistente, ajuste k ou verifique dados.",
                                    "Registre K_j candidato para cada j."
                                  ],
                                  "verification": "Lista de k equações consistentes, uma por posição da chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de pares do Step 2",
                                    "Folha para equações",
                                    "Calculadora modular"
                                  ],
                                  "tips": "Use Python ou app para calcular mod 26 rapidamente se manual for lento.",
                                  "learningObjective": "Traduzir pares conhecidos em sistema de congruências modulares.",
                                  "commonMistakes": [
                                    "Erro no índice mod k",
                                    "Subtração modular negativa sem ajuste (+26)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o Sistema e Recuperar a Chave Completa",
                                  "subSteps": [
                                    "Converta cada K_j numérico de volta para letra (0=A, 25=Z).",
                                    "Concatene K_1 a K_k para formar a chave string.",
                                    "Aplique a chave ao ciphertext inteiro para decifrar: P_i = (C_i - K_j) mod 26.",
                                    "Compare decifrado com known plaintext para validação parcial.",
                                    "Ajuste se necessário (ex: chave errada em uma posição)."
                                  ],
                                  "verification": "Chave completa decifra corretamente todos os pares conhecidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Chave parcial do Step 3",
                                    "Ciphertext completo",
                                    "Tabela alfabética"
                                  ],
                                  "tips": "Teste chave em porção extra de plaintext se disponível.",
                                  "learningObjective": "Resolver e validar chave via álgebra modular em contexto criptográfico.",
                                  "commonMistakes": [
                                    "Inversão errada de números para letras",
                                    "Não validar com decifração"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Analisar a Solução",
                                  "subSteps": [
                                    "Decifre todo o ciphertext com a chave encontrada.",
                                    "Analise texto plano resultante por sentido/coerência.",
                                    "Discuta força da cifra: por que known-plaintext quebra Vigenère?",
                                    "Compare com cifra César (k=1) para contrastar.",
                                    "Documente processo em relatório curto."
                                  ],
                                  "verification": "Texto plano coerente e relatório de 1 página.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Chave final",
                                    "Ciphertext total",
                                    "Editor de texto"
                                  ],
                                  "tips": "Procure padrões linguísticos (ex: ETAOIN no inglês) na decifração.",
                                  "learningObjective": "Avaliar robustez da solução e lições para criptoanálise.",
                                  "commonMistakes": [
                                    "Aceitar chave inconsistente",
                                    "Ignorar ruído no plaintext"
                                  ]
                                }
                              ],
                              "practicalExample": "Plaintext conhecido: 'ATTACKATDAWN' (repetitivo). Ciphertext: 'LXFOPVEFRNHR'. Comprimento chave estimado k=3. Posições 1,4,7,10: A,L,F,R → shifts (L-A=11, F-A=5? Espera consistência). Resolvendo: K1='L'-'A'=11→'L', mas use pares múltiplos para consistência. Chave final: 'LEMON' (exemplo padrão que cifra isso corretamente).",
                              "finalVerifications": [
                                "Chave decifra 100% dos pares known-plaintext corretamente.",
                                "Texto plano completo faz sentido linguístico.",
                                "Equações modulares são consistentes por posição da chave.",
                                "Processo documentado com tabelas e cálculos.",
                                "Tempo total dentro de 1.5 horas.",
                                "Nenhum erro aritmético modular detectado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas equações modulares (sem erros de cálculo).",
                                "Consistência na recuperação da chave (validação total).",
                                "Clareza na documentação de steps e tabelas.",
                                "Compreensão demonstrada em análise de limitações.",
                                "Eficiência: uso ótimo de pares conhecidos.",
                                "Criatividade em verificação extra (ex: frequência)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra modular e sistemas de congruências.",
                                "História: Criptografia na Segunda Guerra Mundial (máquinas Enigma semelhantes).",
                                "Linguística: Análise de frequência de letras em idiomas.",
                                "Segurança da Informação: Bases de ataques modernos em AES."
                              ],
                              "realWorldApplication": "Em inteligência militar, quebrar mensagens inimigas com trechos conhecidos (ex: cabeçalhos padrão); em cibersegurança forense, recuperar chaves de comunicações comprometidas; auditoria de sistemas legados usando cifras clássicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Comparar com Criptosistemas Públicos",
                            "description": "Explicar diferenças em chaves públicas onde known-plaintext pode revelar fraquezas em padding ou implementação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Ataque Known-Plaintext em Criptografia Simétrica",
                                  "subSteps": [
                                    "Defina Known-Plaintext Attack (KPA): atacante conhece pares plaintext-ciphertext.",
                                    "Explique como KPA explora chaves secretas compartilhadas em simétricos como AES ou DES.",
                                    "Discuta limitações: requer acesso a múltiplos pares e força computacional para quebrar chave.",
                                    "Estude exemplos históricos como quebra de DES com KPA.",
                                    "Anote diferenças chave: chave secreta oculta protege contra KPA direto."
                                  ],
                                  "verification": "Resuma em 3-5 frases as características do KPA em simétricos e liste 2 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre criptografia simétrica, diagrama de KPA.",
                                  "tips": "Use analogia de cofre com combinação secreta para visualizar proteção.",
                                  "learningObjective": "Compreender o papel da chave secreta na resistência a KPA em simétricos.",
                                  "commonMistakes": "Confundir KPA com Chosen-Plaintext; focar apenas em teoria sem exemplos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Fundamentos de Criptosistemas de Chave Pública",
                                  "subSteps": [
                                    "Descreva operação básica: chaves pública (para cifrar) e privada (para decifrar), ex. RSA.",
                                    "Explique que chave pública é conhecida por todos, privada é secreta.",
                                    "Estude algoritmos chave: RSA (modular exponentiation), ElGamal (DH-based).",
                                    "Discuta modos híbridos: simétrico dentro de assimétrico para eficiência.",
                                    "Identifique premissas de segurança: problema de fatoração ou log discreto."
                                  ],
                                  "verification": "Desenhe diagrama de fluxo de cifração/decifração em RSA com chaves públicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação RSA/ElGamal, calculadora modular online.",
                                  "tips": "Pratique cálculos manuais simples de RSA com números pequenos para internalizar.",
                                  "learningObjective": "Dominar como chaves públicas alteram modelo de ameaça em relação a simétricos.",
                                  "commonMistakes": "Ignorar que chave pública não revela privada diretamente; superestimar simplicidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto de Known-Plaintext em Chave Pública",
                                  "subSteps": [
                                    "Compare: em simétricos, KPA mira chave secreta; em públicos, chave pública já conhecida.",
                                    "Explique que KPA não quebra diretamente assimétrico, mas revela padrões em plaintexts conhecidos.",
                                    "Discuta como múltiplos pares (P,C) com mesma chave pública podem vazar info sobre padding.",
                                    "Estude cenários: atacante usa KPA para inferir nonce/IV ou estrutura de mensagem.",
                                    "Simule com ferramenta: cifrar plaintext conhecido com RSA pública e analisar ciphertext."
                                  ],
                                  "verification": "Gere 3 pares P-C com RSA pública e descreva o que KPA revela (ou não).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta online como CyberChef ou Python com cryptography lib.",
                                  "tips": "Sempre normalize plaintexts para isolar efeitos de padding.",
                                  "learningObjective": "Identificar por que KPA é menos direto em públicos devido a chaves expostas.",
                                  "commonMistakes": "Assumir KPA quebra chave privada; não considerar determinismo vs. probabilístico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Fraquezas em Padding e Implementação via KPA",
                                  "subSteps": [
                                    "Defina padding: PKCS#7/OAEP adiciona bytes para blocos fixos em RSA.",
                                    "Explique vulnerabilidades: padding oracle (timing/side-channel) com KPA acelera ataques.",
                                    "Estude casos: Bleichenbacher attack em RSA onde KPA + oracle recupera plaintext.",
                                    "Discuta implementações ruins: reutilização de chaves/nonces, padding malformado.",
                                    "Compare: simétricos usam IVs aleatórios; públicos precisam de padding híbrido seguro."
                                  ],
                                  "verification": "Descreva passo-a-passo um padding oracle attack usando KPA em pseudocódigo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos sobre Bleichenbacher, vídeo explicativo de padding oracles.",
                                  "tips": "Teste padding falhas com OpenSSL demo para ver erros em tempo real.",
                                  "learningObjective": "Reconhecer como KPA amplifica fraquezas não na primitiva, mas em padding/implementação.",
                                  "commonMistakes": "Focar só em primitiva cripto; ignorar contexto de uso (ex. TLS)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Comparação e Diferenças Chave",
                                  "subSteps": [
                                    "Crie tabela comparativa: KPA em simétrico vs. público (chaves, fraquezas, mitigações).",
                                    "Liste diferenças principais: segredo de chave, dependência de padding, complexidade ataque.",
                                    "Discuta mitigações: AEAD modes (GCM), padding seguro (OAEP), autenticação.",
                                    "Avalie impacto: KPA trivial em simétricos ruins; indireto mas letal em públicos mal impl.",
                                    "Formule conclusão: públicos mais resilientes a KPA puro, vulneráveis a impl. flaws."
                                  ],
                                  "verification": "Escreva parágrafo comparativo de 200 palavras cobrindo todas diferenças.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou Markdown para tabela, exemplos de código anterior.",
                                  "tips": "Use bullet points para tabela antes de expandir em texto.",
                                  "learningObjective": "Sintetizar diferenças holísticas para aplicação crítica.",
                                  "commonMistakes": "Generalizar demais; omitir mitigações modernas."
                                }
                              ],
                              "practicalExample": "Em um cenário TLS, atacante captura handshake com known plaintext (ex. 'HTTP/1.1') cifrado via RSA. Usando KPA + padding oracle (timing de erros servidor), recupera sessão chave sem quebrar RSA diretamente – contrastando com AES onde KPA miraria chave simétrica secretamente.",
                              "finalVerifications": [
                                "Explica corretamente por que chaves públicas tornam KPA menos sobre 'quebrar chave' e mais sobre impl.",
                                "Identifica pelo menos 2 fraquezas específicas (padding oracle, nonce reuse) exploráveis por KPA.",
                                "Cria tabela comparativa precisa entre simétrico e assimétrico.",
                                "Descreve mitigações como OAEP/GCM sem erros.",
                                "Simula ataque simples em ferramenta sem falhas.",
                                "Discute real-world como POODLE/Bleichenbacher."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (chaves públicas vs. secretas): 25%",
                                "Profundidade em fraquezas padding/impl.: 25%",
                                "Qualidade da comparação/tabela: 20%",
                                "Exemplos práticos e verificações: 15%",
                                "Clareza e estrutura da explicação: 10%",
                                "Inclusão de mitigações: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (fatoração, log discreto em RSA).",
                                "Segurança de Redes: Vulnerabilidades TLS/SSL como padding oracles.",
                                "Programação: Implementar simulações de KPA em Python (cryptography lib).",
                                "Ética/História: Impacto de ataques como Bleichenbacher em protocolos reais."
                              ],
                              "realWorldApplication": "Em cibersegurança, entender isso previne falhas em VPNs/email criptografados; p.ex., mitigar POODLE em servidores web ou auditar impl. RSA em apps blockchain para evitar vazamentos via KPA em padding fraco."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Ataque Texto-Plano Escolhido (Chosen-Plaintext Attack)",
                        "description": "Modelo mais poderoso onde o atacante pode escolher textos planos arbitrários e obter os cifrados correspondentes, frequentemente usado para testar oráculos de cifragem.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Definir o Ataque Texto-Plano Escolhido",
                            "description": "Explicar o acesso a um oráculo de cifragem e como isso permite gerar pares plaintext-ciphertext controlados para quebrar o sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Básica do Ataque Texto-Plano Escolhido (CPA)",
                                  "subSteps": [
                                    "Ler a definição formal: um atacante pode escolher plaintexts arbitrários e obter os ciphertexts correspondentes via oráculo.",
                                    "Comparar com ataques conhecidos (known-plaintext) e texto-cifra escolhido.",
                                    "Identificar o modelo de ameaça: acesso não adaptativo ao oráculo de cifragem.",
                                    "Anotar as premissas: cifrador é uma caixa-preta.",
                                    "Exemplificar com um diagrama simples de fluxo de ataque."
                                  ],
                                  "verification": "Explicar em 2-3 frases o que é CPA e sua diferença de outros ataques.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de ataques criptográficos (imprimir ou digital)",
                                    "Artigo da Wikipedia sobre Chosen-Plaintext Attack (em PT)"
                                  ],
                                  "tips": "Use analogias como 'enviar cartas codificadas para um inimigo e receber respostas codificadas'.",
                                  "learningObjective": "Dominar a definição conceitual do CPA e seu posicionamento em modelos de ataque.",
                                  "commonMistakes": "Confundir CPA com CCA (chosen-ciphertext attack); lembrar que CPA é só plaintext escolhido."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Conceito de Oráculo de Cifragem",
                                  "subSteps": [
                                    "Definir oráculo: função que cifra qualquer plaintext fornecido sem revelar a chave.",
                                    "Simular um oráculo em pseudocódigo: encrypt_oracle(plaintext) -> ciphertext.",
                                    "Discutir limitações: oráculo não descriptografa nem revela chave.",
                                    "Analisar acessos: quantos queries o atacante pode fazer (geralmente ilimitados no modelo).",
                                    "Diferenciar oráculos adaptativos vs. não adaptativos."
                                  ],
                                  "verification": "Implementar um pseudocódigo simples de oráculo e testá-lo mentalmente com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Vídeo curto sobre oráculos em criptoanálise (YouTube)"
                                  ],
                                  "tips": "Pense no oráculo como uma 'máquina de cifrar pública' controlada pelo atacante.",
                                  "learningObjective": "Entender o mecanismo do oráculo e seu papel essencial no CPA.",
                                  "commonMistakes": "Achar que o oráculo revela a chave diretamente; ele só gera pares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Pares Plaintext-Ciphertext Controlados",
                                  "subSteps": [
                                    "Escolher plaintexts estratégicos: repetições, padrões conhecidos (ex: todos 'A').",
                                    "Enviar queries ao oráculo e coletar pares (P1,C1), (P2,C2)...",
                                    "Analisar padrões nos ciphertexts recebidos para inferir estrutura do cifrador.",
                                    "Documentar pelo menos 5 pares em uma tabela.",
                                    "Testar hipóteses sobre o cifrador baseado nos pares."
                                  ],
                                  "verification": "Criar uma tabela com 3 pares exemplo e explicar como eles revelam informações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela de pares",
                                    "Simulador online de cifradores simples (ex: CyberChef)"
                                  ],
                                  "tips": "Comece com plaintexts simples para detectar vieses no cifrador.",
                                  "learningObjective": "Aprender a gerar e usar pares controlados para análise.",
                                  "commonMistakes": "Escolher plaintexts aleatórios sem estratégia; foque em padrões."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Pares para Quebrar o Sistema Cifrador",
                                  "subSteps": [
                                    "Identificar fraquezas: ex: em cifradores lineares, resolver sistema de equações.",
                                    "Construir ataque específico: frequência análise ou chave recovery.",
                                    "Simular quebra completa com exemplo simples (ex: cifra de César ou affine).",
                                    "Avaliar segurança: quando CPA quebra um cifrador.",
                                    "Discutir mitigações: modos de operação como CBC."
                                  ],
                                  "verification": "Descrever um cenário onde CPA quebra um cifrador e por quê.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Notebook com Python para simular ataque simples",
                                    "Exemplo de código para cifra affine"
                                  ],
                                  "tips": "Use matemática básica para resolver; não precisa de chave secreta.",
                                  "learningObjective": "Compreender como os pares controlados levam à quebra do sistema.",
                                  "commonMistakes": "Ignorar que CPA não sempre recupera a chave, mas compromete segurança semântica."
                                }
                              ],
                              "practicalExample": "Em um cifrador de substituição monoalfabética simples, o atacante envia plaintexts como 'AAAAA', 'BBBBB' etc. ao oráculo, recebe ciphertexts e mapeia a permutação da chave diretamente, quebrando o sistema em 26 queries.",
                              "finalVerifications": [
                                "Definir CPA corretamente incluindo oráculo.",
                                "Explicar geração de pares controlados.",
                                "Dar exemplo de quebra via CPA.",
                                "Diferenciar CPA de outros ataques.",
                                "Identificar quando CPA é efetivo.",
                                "Descrever mitigações básicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de CPA e oráculo (30%)",
                                "Clareza na explicação de pares controlados (25%)",
                                "Qualidade do exemplo prático (20%)",
                                "Compreensão de aplicações e limitações (15%)",
                                "Uso correto de terminologia criptográfica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares para cifradores affine.",
                                "Programação: Implementar oráculos em Python.",
                                "Segurança da Informação: Modelos de ameaça em protocolos.",
                                "Ética: Discussão sobre uso responsável em pentests."
                              ],
                              "realWorldApplication": "Em competições CTF e auditorias de segurança, CPA é usado para testar cifradores vulneráveis em apps web, como padding oracle indireto ou análise de protocolos IoT fracos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Simular em Protocolos",
                            "description": "Analisar vulnerabilidades em protocolos criptográficos onde o atacante envia mensagens escolhidas, como em ataques a RSA sem padding (Paar & Pelzl, 2010).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Ataque Chosen-Plaintext (CPA)",
                                  "subSteps": [
                                    "Estude a definição de CPA: atacante pode escolher plaintexts e obter ciphertexts correspondentes.",
                                    "Analise o oráculo de encriptação em protocolos criptográficos.",
                                    "Compare CPA com outros modelos como ciphertext-only attack.",
                                    "Identifique cenários onde CPA é aplicável, como em servidores públicos de encriptação.",
                                    "Revise exemplos teóricos de Paar & Pelzl (2010) sobre RSA sem padding."
                                  ],
                                  "verification": "Resuma em um diagrama o fluxo do CPA e explique verbalmente para um par.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Understanding Cryptography' de Paar & Pelzl",
                                    "Notas de aula sobre modelos de ataque",
                                    "Vídeo Khan Academy sobre criptoanálise"
                                  ],
                                  "tips": "Use diagramas para visualizar o oráculo; foque em interações atacante-oráculo.",
                                  "learningObjective": "Explicar o modelo CPA e seu papel em protocolos criptográficos.",
                                  "commonMistakes": [
                                    "Confundir CPA com chosen-ciphertext attack",
                                    "Ignorar restrições do oráculo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vulnerabilidades do RSA sem Padding",
                                  "subSteps": [
                                    "Revise o algoritmo RSA básico: chave pública (n,e), encriptação c = m^e mod n.",
                                    "Demonstre deterministicidade sem padding: mesma plaintext gera mesmo ciphertext.",
                                    "Estude o ataque de Hastad's broadcast: múltiplos ciphertexts para fatorar n.",
                                    "Explore recuperação de plaintexts via múltiplas consultas ao oráculo.",
                                    "Calcule manualmente um exemplo pequeno com n=15, e=3."
                                  ],
                                  "verification": "Resolva um problema manual: dado c1 e c2 de plaintexts conhecidos, recupere informações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SageMath ou Python com pow() para cálculos modulares",
                                    "Capítulo 10 de Paar & Pelzl",
                                    "Folha de exercícios RSA"
                                  ],
                                  "tips": "Comece com números pequenos para intuição; use calculadora modular.",
                                  "learningObjective": "Identificar por que RSA sem padding falha contra CPA.",
                                  "commonMistakes": [
                                    "Esquecer modularidade",
                                    "Assumir padding implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Ambiente de Simulação",
                                  "subSteps": [
                                    "Instale Python e bibliotecas: pycryptodome, sympy para fatoração.",
                                    "Implemente um oráculo RSA simples sem padding: função que recebe m e retorna m^e mod n.",
                                    "Crie um protocolo simulado: servidor que aceita plaintexts escolhidos.",
                                    "Teste o oráculo com plaintexts conhecidos.",
                                    "Prepare chaves RSA fracas (pequenas) para demonstração."
                                  ],
                                  "verification": "Execute o oráculo e confirme que plaintexts escolhidos geram ciphertexts corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "pip install pycryptodome sympy",
                                    "Código template de oráculo RSA"
                                  ],
                                  "tips": "Use Jupyter Notebook para experimentação interativa; debugue com print statements.",
                                  "learningObjective": "Montar um ambiente realista para simular protocolos vulneráveis.",
                                  "commonMistakes": [
                                    "Gerar chaves grandes demais para testes",
                                    "Incluir padding acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Executar a Simulação do Ataque",
                                  "subSteps": [
                                    "Escolha plaintexts estratégicos para explorar deterministicidade.",
                                    "Envie consultas ao oráculo para coletar múltiplos ciphertexts.",
                                    "Aplique técnica de recuperação: use CRT para Hastad se múltiplos n, ou fatoração.",
                                    "Recupere a mensagem secreta ou fatores de n.",
                                    "Automatize o ataque em um script Python."
                                  ],
                                  "verification": "O script recupera corretamente a mensagem secreta em <5 minutos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Script Python do oráculo",
                                    "Exemplos de código Hastad attack",
                                    "Sympy para gcd e factorint"
                                  ],
                                  "tips": "Registre todas consultas; otimize para eficiência computacional.",
                                  "learningObjective": "Simular um CPA bem-sucedido em RSA sem padding.",
                                  "commonMistakes": [
                                    "Consultas insuficientes",
                                    "Erros em cálculos modulares"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Lições Aprendidas",
                                  "subSteps": [
                                    "Compare ciphertexts obtidos com plaintexts esperados.",
                                    "Discuta mitigações: padding OAEP, chaves fortes.",
                                    "Avalie complexidade do ataque (tempo, consultas).",
                                    "Documente o ataque em relatório com código e saídas.",
                                    "Teste variações: adicione ruído ou padding parcial."
                                  ],
                                  "verification": "Escreva relatório de 1 página resumindo sucesso e falhas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Template de relatório",
                                    "Ferramentas de plotagem como matplotlib para visualizações"
                                  ],
                                  "tips": "Foque em generalizações além do exemplo; pense em escalabilidade.",
                                  "learningObjective": "Extrair insights de simulações para criptoanálise prática.",
                                  "commonMistakes": [
                                    "Ignorar mitigações",
                                    "Sobre-generalizar vulnerabilidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um servidor web usando RSA sem padding para encriptar senhas de login. Como atacante, envie plaintexts escolhidos (ex: 'admin', 'user') para o oráculo, colete ciphertexts e use Hastad's attack com 3 instâncias idênticas de n para recuperar uma senha secreta 'secretkey' via fatoração de n.",
                              "finalVerifications": [
                                "Explicar CPA e RSA sem padding em termos próprios.",
                                "Executar simulação end-to-end com recuperação bem-sucedida.",
                                "Identificar pelo menos 3 mitigações (ex: padding, chaves grandes).",
                                "Analisar log de ataques mostrando consultas e resultados.",
                                "Discutir limitações da simulação vs. mundo real.",
                                "Resolver variação do problema manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (20%): Definições corretas de CPA e RSA.",
                                "Implementação funcional (30%): Código roda sem erros, recupera alvo.",
                                "Análise profunda (20%): Identifica causas e mitigações.",
                                "Criatividade em testes (15%): Variações e edge cases.",
                                "Documentação clara (10%): Relatório bem estruturado.",
                                "Eficiência (5%): Tempo e consultas otimizados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (CRT, fatoração).",
                                "Programação: Implementação segura em Python.",
                                "Redes: Protocolos cliente-servidor e TLS.",
                                "Ética: Implicações de vulnerabilidades em sistemas reais.",
                                "Física: Analogias quânticas em cripto pós-quântica."
                              ],
                              "realWorldApplication": "Em protocolos legados como SSLv2 sem padding adequado, CPAs permitiram descriptografar tráfego de rede, como no ataque BEAST em TLS 1.0, destacando a necessidade de padding probabilístico em sistemas bancários e e-commerce modernos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Discutir Medidas de Defesa",
                            "description": "Explorar o uso de modos de operação como CBC com IV aleatório para mitigar esse ataque em cifragem simétrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Vulnerabilidades do Ataque CPA em Modos Inseguros",
                                  "subSteps": [
                                    "Explique o conceito de Chosen-Plaintext Attack (CPA) e como o atacante obtém textos cifrados para plaintexts escolhidos.",
                                    "Analise o modo ECB: demonstre como padrões no plaintext são preservados no ciphertext, facilitando CPA.",
                                    "Compare com OFB ou CTR sem nonce adequado, destacando vazamento de informações.",
                                    "Discuta por que chaves estáticas agravam o problema em cenários repetidos.",
                                    "Registre exemplos visuais de padrões ECB vs. modos seguros."
                                  ],
                                  "verification": "Crie um diagrama comparativo mostrando falhas ECB em CPA e confirme compreensão verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online como CyberChef para simular ECB"
                                  ],
                                  "tips": "Use imagens de pinguins cifrados em ECB para ilustrar padrões visíveis.",
                                  "learningObjective": "Compreender por que modos como ECB são vulneráveis a CPA.",
                                  "commonMistakes": [
                                    "Confundir CPA com CCA",
                                    "Ignorar impacto de plaintexts repetidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Modos de Operação em Cifragem Simétrica",
                                  "subSteps": [
                                    "Defina modos de operação e liste comuns: ECB, CBC, CFB, OFB, CTR.",
                                    "Explique o papel de um bloco de inicialização (IV ou nonce) em modos em cadeia.",
                                    "Discuta propriedades desejáveis: confusão, difusão e independência de mensagens.",
                                    "Compare semanticamente seguro vs. IND-CPA (Indistinguishability under CPA).",
                                    "Pesquise definições formais de segurança contra CPA."
                                  ],
                                  "verification": "Liste 3 modos e suas fraquezas contra CPA em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-38A",
                                    "Vídeo introdutório sobre modos de operação"
                                  ],
                                  "tips": "Lembre-se: IV não precisa ser secreto, mas deve ser imprevisível e único por mensagem.",
                                  "learningObjective": "Identificar modos de operação adequados para mitigar CPA.",
                                  "commonMistakes": [
                                    "Achar que todos os modos com IV são seguros",
                                    "Confundir IV com chave"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o Modo CBC com IV Aleatório",
                                  "subSteps": [
                                    "Descreva o algoritmo CBC: XOR do plaintext com ciphertext anterior ou IV.",
                                    "Explique geração de IV: aleatório, tamanho do bloco, único por mensagem.",
                                    "Simule cifragem/decifragem passo a passo com exemplo numérico simples (ex: AES-128).",
                                    "Mostre como IV aleatório torna cada mensagem 'fresca' e imprevisível.",
                                    "Implemente um pseudocódigo ou snippet Python para CBC."
                                  ],
                                  "verification": "Execute uma simulação manual de CBC com IV e verifique decifragem correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca pycryptodome para Python",
                                    "Bloco de notas para simulação manual"
                                  ],
                                  "tips": "Sempre transmita IV junto ao ciphertext, mas nunca reutilize.",
                                  "learningObjective": "Dominar o funcionamento técnico do CBC-IV contra CPA.",
                                  "commonMistakes": [
                                    "Reutilizar IV para mesma chave",
                                    "Não XORar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Mitigação de CPA e Melhores Práticas",
                                  "subSteps": [
                                    "Demonstre por que CBC-IV resiste a CPA: atacante não prevê próximo bloco sem IV futuro.",
                                    "Discuta limitações: malleability, padding oracle; sugira AEAD como GCM.",
                                    "Compare com CTR-IV: ambos IND-CPA se IV único.",
                                    "Estabeleça regras: IV aleatório por mensagem, nunca contador previsível.",
                                    "Debata trade-offs: performance vs. segurança."
                                  ],
                                  "verification": "Escreva um parágrafo explicando defesa CBC-IV vs. CPA e cite referências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo 'Chosen-Plaintext Attack' da Wikipedia",
                                    "RFC 5116 para padrões IV"
                                  ],
                                  "tips": "Para produção, use bibliotecas que gerenciem IV automaticamente.",
                                  "learningObjective": "Avaliar efetividade de CBC-IV e práticas recomendadas.",
                                  "commonMistakes": [
                                    "Achar CBC imune a todos ataques",
                                    "Ignorar autenticação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de mensagens seguras, use CBC com IV aleatório para cifrar 'Olá Mundo!' repetidamente. Em ECB, padrões emergem permitindo CPA para adivinhar estrutura; em CBC-IV, cada mensagem parece ruído aleatório, frustrando o atacante.",
                              "finalVerifications": [
                                "Explicar verbalmente como IV aleatório impede previsão em CPA.",
                                "Simular falha ECB vs. sucesso CBC em ferramenta online.",
                                "Listar 3 regras para uso seguro de IV.",
                                "Identificar quando CBC não basta (ex: sem autenticação).",
                                "Comparar CBC com GCM para cenários modernos.",
                                "Definir IND-CPA em termos simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de CBC e IV (sem erros conceituais).",
                                "Profundidade na análise de mitigação CPA (exemplos concretos).",
                                "Clareza em substeps e verificações (acionáveis e lógicos).",
                                "Uso correto de terminologia criptográfica.",
                                "Inclusão de limitações e melhores práticas.",
                                "Criatividade em exemplos práticos e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e aleatoriedade na geração de IV.",
                                "Programação: Implementação de CBC em linguagens como Python ou Java.",
                                "Segurança da Informação: Protocolos como TLS que usam modos semelhantes.",
                                "Ética: Implicações de falhas criptográficas em privacidade de dados."
                              ],
                              "realWorldApplication": "Em protocolos como HTTPS/TLS, CBC (ou sucessores) com IV aleatório protege tráfego web contra CPA, garantindo que atacadores em rede não decifrem sessões; essencial em apps bancários e VPNs para confidencialidade de dados sensíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.4",
                        "name": "Ataque Texto-Cifrado Escolhido (Chosen-Ciphertext Attack)",
                        "description": "Modelo avançado onde o atacante escolhe textos cifrados e obtém decriptações (exceto possivelmente o alvo), útil para explorar oráculos de decriptagem falhos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.4.1",
                            "name": "Definir o Ataque Texto-Cifrado Escolhido",
                            "description": "Descrever o cenário com oráculo de decriptagem e exceções para o ciphertext alvo, destacando sua relevância em esquemas híbridos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Ataques em Criptoanálise",
                                  "subSteps": [
                                    "Estude os tipos básicos de ataques: texto plano conhecido, texto plano escolhido, texto cifrado escolhido.",
                                    "Identifique diferenças entre ataques passivos e ativos em criptografia.",
                                    "Revise esquemas híbridos, combinando criptografia simétrica e assimétrica.",
                                    "Anote exemplos de ataques anteriores como CPA (Chosen-Plaintext Attack).",
                                    "Compare CCA com outros modelos de ataque."
                                  ],
                                  "verification": "Liste 3 diferenças entre CCA e CPA em um resumo escrito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notebook ou papel",
                                    "Material de aula sobre criptoanálise básica"
                                  ],
                                  "tips": "Use diagramas para visualizar os fluxos de ataque.",
                                  "learningObjective": "Compreender o contexto dos ataques de texto cifrado escolhido.",
                                  "commonMistakes": [
                                    "Confundir CCA com CPA",
                                    "Ignorar o papel do oráculo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito de Oráculo de Decriptagem",
                                  "subSteps": [
                                    "Defina oráculo como uma 'caixa preta' que executa decriptagem sem revelar a chave.",
                                    "Descreva como o atacante interage: envia ciphertext e recebe plaintext.",
                                    "Explique limitações: oráculo não revela chaves privadas.",
                                    "Simule uma consulta simples ao oráculo com um exemplo fictício.",
                                    "Discuta por que oráculos modelam acessos reais a serviços de decriptagem."
                                  ],
                                  "verification": "Crie um fluxograma simples do oráculo de decriptagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Documentação de criptografia"
                                  ],
                                  "tips": "Pense no oráculo como uma API de decriptagem pública.",
                                  "learningObjective": "Dominar o mecanismo do oráculo usado no CCA.",
                                  "commonMistakes": [
                                    "Achar que o oráculo revela a chave",
                                    "Esquecer que é uma simulação teórica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Modelo Formal do Ataque Texto-Cifrado Escolhido (CCA)",
                                  "subSteps": [
                                    "Descreva o cenário: atacante escolhe ciphertexts para decriptar via oráculo.",
                                    "Especifique a exceção: oráculo recusa o ciphertext alvo exato.",
                                    "Explique o objetivo: recuperar a plaintext do ciphertext alvo.",
                                    "Detalhe as fases: consultas pré e pós desafio.",
                                    "Formalize em termos matemáticos: Adv(A, Dec) onde Dec é o oráculo."
                                  ],
                                  "verification": "Escreva a definição completa do CCA em suas palavras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Referências como 'Handbook of Applied Cryptography'"
                                  ],
                                  "tips": "Use notação algébrica para clareza.",
                                  "learningObjective": "Articular precisamente o CCA com suas regras.",
                                  "commonMistakes": [
                                    "Omitir a exceção do ciphertext alvo",
                                    "Confundir com ataques de texto plano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Relevância em Esquemas Híbridos",
                                  "subSteps": [
                                    "Explique esquemas híbridos: assimétrica para chaves, simétrica para dados.",
                                    "Discuta vulnerabilidades CCA em híbridos sem IND-CCA segurança.",
                                    "Cite exemplos como Bleichenbacher's attack em PKCS#1.",
                                    "Analise por que CCA é crítico para autenticação e confidencialidade.",
                                    "Conclua com transformações para CCA-segurança (ex: OAEP)."
                                  ],
                                  "verification": "Relacione CCA a um esquema híbrido específico em um parágrafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos sobre ataques CCA",
                                    "Notebook"
                                  ],
                                  "tips": "Pesquise casos reais para ilustrar impacto.",
                                  "learningObjective": "Compreender aplicações práticas do CCA.",
                                  "commonMistakes": [
                                    "Subestimar impacto em protocolos modernos",
                                    "Ignorar padding oracles"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema híbrido como RSA-OAEP antigo, um atacante usa um oráculo de decriptagem (ex: servidor web) para enviar ciphertexts modificados do alvo, como c' = c * r^e, obtendo respostas que vazam bits da plaintext via respostas de erro, permitindo reconstruir a mensagem secreta sem o ciphertext alvo direto.",
                              "finalVerifications": [
                                "Explique o papel do oráculo e sua exceção em CCA.",
                                "Diferencie CCA de CPA com exemplos.",
                                "Descreva um cenário CCA em esquemas híbridos.",
                                "Identifique vulnerabilidades CCA em protocolos reais.",
                                "Defina IND-CCA segurança.",
                                "Simule uma consulta CCA em papel."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição do oráculo e exceção.",
                                "Clareza na descrição do cenário de ataque.",
                                "Correta distinção de outros modelos de ataque.",
                                "Relevância destacada em esquemas híbridos.",
                                "Uso de terminologia técnica apropriada.",
                                "Capacidade de exemplificar com cenários concretos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Informação e Probabilidade em ataques adaptativos.",
                                "Redes de Computadores: Vulnerabilidades em protocolos TLS/SSL.",
                                "Segurança da Informação: Modelos de segurança prováveis.",
                                "Programação: Implementação de oráculos em Python com bibliotecas como cryptography.",
                                "Ética: Implicações de ataques em privacidade digital."
                              ],
                              "realWorldApplication": "O CCA modela ataques como o Padding Oracle Attack de Vaudenay em CBC mode do TLS, explorado em implementações defeituosas de servidores web, permitindo decriptar tráfego HTTPS sem chaves, como no caso do ataque POODLE ou Bleichenbacher em S/MIME."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.2",
                            "name": "Exemplificar em Criptografia Pública",
                            "description": "Estudar o ataque CCA a PKCS#1 v1.5 em RSA, mostrando como modificações no ciphertext revelam informações (Menezes, 1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de RSA e Padding PKCS#1 v1.5",
                                  "subSteps": [
                                    "Estude o funcionamento básico do RSA: chave pública (n, e), chave privada (d), encriptação c = m^e mod n e decriptação m = c^d mod n.",
                                    "Analise o formato do padding PKCS#1 v1.5: 0x00 || 0x02 || PS (non-zero bytes) || 0x00 || M, onde PS é padding aleatório não-zero.",
                                    "Implemente uma função simples em Python para adicionar e remover o padding PKCS#1 v1.5.",
                                    "Teste com mensagens curtas para verificar se a decriptação remove o padding corretamente.",
                                    "Leia a seção relevante do Handbook of Applied Cryptography (Menezes, 1996, seção 8.1.1)."
                                  ],
                                  "verification": "Implemente e teste uma função de padding/depadding que funcione corretamente em 5 exemplos aleatórios sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python (biblioteca cryptography ou código customizado), Handbook of Applied Cryptography (PDF), Jupyter Notebook.",
                                  "tips": "Use números pequenos para chaves RSA inicialmente para facilitar cálculos manuais.",
                                  "learningObjective": "Compreender a estrutura exata do padding PKCS#1 v1.5 e sua vulnerabilidade potencial a ataques.",
                                  "commonMistakes": "Confundir PKCS#1 v1.5 com OAEP; ignorar a exigência de bytes não-zero no PS."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Modelo de Ataque CCA e a Vulnerabilidade Específica",
                                  "subSteps": [
                                    "Defina CCA: atacante pode submeter ciphertexts escolhidos para decriptação (exceto o alvo) e observar respostas.",
                                    "Estude o ataque de Bleichenbacher (1998, referenciado em Menezes): modificar ciphertext para forçar erros de decriptação reveladores.",
                                    "Identifique como padding inválido causa erros que vazam bits da mensagem via respostas do oráculo de decriptação.",
                                    "Simule conceitualmente: envie c' = c * r^e mod n e observe se o oráculo rejeita baseado no padding.",
                                    "Anote as condições para narrowing down a mensagem: multiplicar por r^e e usar respostas para inferir mensagem."
                                  ],
                                  "verification": "Escreva um diagrama ou pseudocódigo explicando como um ciphertext modificado revela 1 bit da mensagem.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Artigos: Bleichenbacher's Attack (RFC 8017), Handbook of Applied Cryptography (seção 8.1), quadro branco ou Draw.io.",
                                  "tips": "Pense no oráculo como uma black box que diz 'padding inválido' ou 'válido'.",
                                  "learningObjective": "Explicar como o CCA explora a não-malabilidade do padding PKCS#1 v1.5.",
                                  "commonMistakes": "Assumir que CCA permite decriptar o ciphertext alvo diretamente; confundir com CPA."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Simular o Ataque CCA Passo a Passo",
                                  "subSteps": [
                                    "Crie um oráculo de decriptação em Python que verifica PKCS#1 v1.5 e retorna 'válido/inválido' sem revelar a mensagem.",
                                    "Gere um ciphertext alvo c para uma mensagem secreta m.",
                                    "Execute iterações do ataque: escolha r aleatório, compute c' = c * r^e mod n, submeta ao oráculo e ajuste r baseado na resposta.",
                                    "Repita ~2^16 vezes para recuperar m byte a byte, demonstrando recuperação parcial.",
                                    "Registre logs de queries e respostas para visualizar o narrowing.",
                                    "verification]: "
                                  ],
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com pow() para RSA, bibliotecas como pycryptodome para chaves, script Jupyter.",
                                  "tips": "Use chaves RSA-1024 para simulação prática; limite iterações para demo.",
                                  "learningObjective": "Demonstrar praticamente como modificações no ciphertext vazam informações via oráculo.",
                                  "commonMistakes": "Implementar oráculo que vaza mensagem em vez de só validar padding; usar padding seguro por engano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Discutir Implicações",
                                  "subSteps": [
                                    "Compare o m recuperado com o original e calcule precisão do ataque.",
                                    "Explique por que PKCS#1 v1.5 é vulnerável (padding previsível) vs. OAEP (aleatoriedade forte).",
                                    "Discuta mitigações: usar RSA-OAEP, oráculos resistentes a padding oracles.",
                                    "Crie um relatório resumindo o ataque com números de queries necessárias.",
                                    "Pesquise impactos reais: ataques a SSL/TLS na era 90s."
                                  ],
                                  "verification": "Produza um relatório de 1 página com código, resultados e lições aprendidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor de texto, referências históricas (e.g., POODLE attack wiki).",
                                  "tips": "Enfatize a importância de 'não vazar info em erros'.",
                                  "learningObjective": "Avaliar vulnerabilidades históricas e transição para paddings seguros.",
                                  "commonMistakes": "Ignorar custo computacional real do ataque (milhões de queries)."
                                }
                              ],
                              "practicalExample": "Considere RSA com n=91 (7*13), e=5, d=41. Mensagem m='Hi' (padded). Ciphertext c. Modifique c' = c * 2^5 mod 91, submeta ao oráculo: se inválido, ajuste intervalo de m; repita para recuperar 'H' e 'i'.",
                              "finalVerifications": [
                                "Explica corretamente a estrutura PKCS#1 v1.5 e sua falha em CCA.",
                                "Implementa um oráculo que valida padding sem vazar mensagem.",
                                "Simula o ataque recuperando pelo menos 50% de uma mensagem de 8 bytes.",
                                "Identifica 3 diferenças entre PKCS#1 v1.5 e OAEP.",
                                "Descreve um cenário real onde padding oracle foi explorado (e.g., Bleichenbacher em S/MIME)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do padding e modelo CCA (30%)",
                                "Funcionalidade do código de simulação (40%)",
                                "Análise de resultados e implicações (20%)",
                                "Clareza do relatório e exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (modular arithmetic, expoentes).",
                                "Programação: Implementação segura de cripto (side-channel awareness).",
                                "Segurança da Informação: Análise de vulnerabilidades históricas.",
                                "História da Computação: Evolução de protocolos SSL/TLS."
                              ],
                              "realWorldApplication": "Esse ataque foi usado em protocolos como SSLv3 (POODLE variant), levando à adoção de TLS 1.2+ com padding seguro; hoje, previne breaches em e-commerce e banking ao garantir que erros de decriptação não vazem dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.4.3",
                            "name": "Comparar Forças Relativas",
                            "description": "Classificar a hierarquia de ataques (COA < KPA < CPA < CCA) e implicações para segurança semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as Definições Básicas dos Ataques em Criptoanálise",
                                  "subSteps": [
                                    "Pesquise e anote as definições de COA (Ciphertext-Only Attack), KPA (Known-Plaintext Attack), CPA (Chosen-Plaintext Attack) e CCA (Chosen-Ciphertext Attack).",
                                    "Identifique o que o atacante sabe em cada modelo: apenas ciphertext para COA, pares plaintext-ciphertext para KPA, etc.",
                                    "Crie um quadro comparativo simples listando os inputs disponíveis para o atacante em cada ataque.",
                                    "Leia exemplos históricos, como o breaking do Enigma com KPA.",
                                    "Registre as diferenças chave em um documento pessoal."
                                  ],
                                  "verification": "Você tem um quadro comparativo completo com definições e inputs para cada ataque.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Notebook ou editor de texto",
                                    "Acesso à internet para referências criptográficas básicas (ex: Wikipedia, Crypto101)"
                                  ],
                                  "tips": "Use tabelas para visualização clara; foque em 'o que o atacante controla'.",
                                  "learningObjective": "Dominar as definições e suposições de cada modelo de ataque.",
                                  "commonMistakes": [
                                    "Confundir CPA com CCA (CPA escolhe plaintext, CCA escolhe ciphertext)",
                                    "Ignorar que COA é o mais fraco por falta de informações adicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar a Hierarquia de Forças Relativas",
                                  "subSteps": [
                                    "Compare os ataques sequencialmente: COA < KPA < CPA < CCA, explicando por que cada um é mais forte (mais informações ou controle).",
                                    "Desenhe um diagrama de hierarquia com setas indicando 'implica' (ex: resistência a CCA implica resistência aos mais fracos).",
                                    "Escreva uma justificativa para cada desigualdade (ex: KPA > COA porque plaintext conhecido quebra mais esquemas).",
                                    "Teste o entendimento invertendo: liste cenários onde um ataque mais fraco falha mas um mais forte succeeds.",
                                    "Revise o diagrama com um colega ou auto-explicação em voz alta."
                                  ],
                                  "verification": "Diagrama de hierarquia completo com justificativas escritas para cada link.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama (Draw.io, Lucidchart)",
                                    "Referências de livros como 'Cryptography and Network Security' de Stallings"
                                  ],
                                  "tips": "Lembre-se: força aumenta com controle do atacante; hierarquia é estrita.",
                                  "learningObjective": "Visualizar e justificar a ordenação COA < KPA < CPA < CCA.",
                                  "commonMistakes": [
                                    "Pensar que CCA é mais fraco que CPA",
                                    "Esquecer que ataques mais fortes subsumem os mais fracos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Implicações para Segurança Semântica",
                                  "subSteps": [
                                    "Defina segurança semântica (IND-CPA, IND-CCA) e como ela se relaciona aos modelos de ataque.",
                                    "Explique por que esquemas IND-CCA seguros são semanticamente seguros contra todos os ataques inferiores.",
                                    "Estude exemplos: AES em modo CBC é IND-CPA mas não IND-CCA sem padding oracle fixes.",
                                    "Discuta trade-offs: esquemas CCA-secure são mais caros computacionalmente.",
                                    "Escreva um parágrafo resumindo implicações para design de criptosistemas."
                                  ],
                                  "verification": "Parágrafo escrito conectando hierarquia de ataques à segurança semântica.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Documentos sobre IND-CCA (ex: papers de Bellare-Rogaway)",
                                    "Simulador de criptografia online como CrypTool"
                                  ],
                                  "tips": "Foquem em 'semantic security' como indistinguibilidade de ciphertexts.",
                                  "learningObjective": "Conectar hierarquia de ataques às noções de segurança semântica.",
                                  "commonMistakes": [
                                    "Confundir IND-CPA com IND-CCA",
                                    "Ignorar que CCA security é gold standard para encryption pública"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Comparação com Exemplos Práticos",
                                  "subSteps": [
                                    "Escolha um esquema como RSA-OAEP e classifique sua resistência (CCA-secure).",
                                    "Simule um cenário: como um padding oracle permite CCA em CBC mode.",
                                    "Compare forças: liste 3 esquemas vulneráveis a CPA mas não CCA.",
                                    "Crie um quiz pessoal: 'Qual ataque quebra isso e por quê?'.",
                                    "Avalie um protocolo real (ex: TLS 1.3) em termos da hierarquia."
                                  ],
                                  "verification": "Quiz resolvido com pelo menos 5 perguntas sobre comparações.",
                                  "estimatedTime": "20-35 minutos",
                                  "materials": [
                                    "CrypTool ou Python com pycryptodome para simulações simples",
                                    "Documentação de TLS"
                                  ],
                                  "tips": "Use código simples para demonstrar vulnerabilidades.",
                                  "learningObjective": "Aplicar a comparação em cenários concretos.",
                                  "commonMistakes": [
                                    "Subestimar CCA em cenários reais como adaptive adversaries"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de mensagens seguras como Signal, o protocolo usa criptografia CCA-secure (Double Ratchet com X3DH). Se um atacante tem apenas ciphertexts (COA), falha; com known plaintext (KPA), ainda falha; mas chosen plaintext (CPA) testaria malleability. CCA security previne decryption oracles, garantindo forward secrecy.",
                              "finalVerifications": [
                                "Explicar corretamente a hierarquia COA < KPA < CPA < CCA com exemplos.",
                                "Identificar que IND-CCA implica segurança contra todos ataques inferiores.",
                                "Dar um exemplo real onde CCA é crítico (ex: padding oracle em TLS).",
                                "Desenhar diagrama de hierarquia sem erros.",
                                "Discutir trade-offs de segurança semântica.",
                                "Resolver quiz com 90% acurácia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e ordenação dos ataques (100% correto).",
                                "Profundidade nas justificativas de força relativa (inclui controle do atacante).",
                                "Conexão clara com segurança semântica (IND notions).",
                                "Uso de exemplos práticos e diagramas.",
                                "Identificação de erros comuns e mitigações.",
                                "Capacidade de aplicar a protocolos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade (indistinguibilidade probabilística).",
                                "Segurança da Informação: Modelos de ameaça e adversarial models.",
                                "Ciência da Computação: Algoritmos e complexidade computacional em provas de segurança.",
                                "Ética: Implicações de vulnerabilidades criptográficas em privacidade digital.",
                                "Física: Analogias com mecânica quântica em post-quantum crypto."
                              ],
                              "realWorldApplication": "No design de protocolos como HTTPS/TLS 1.3, engenheiros garantem CCA-security para prevenir ataques como Bleichenbacher oracle, protegendo transações bancárias e comunicações confidenciais contra adversários adaptativos com acesso parcial a oráculos de decrypt."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Análise de Frequência",
                    "description": "Técnica estatística para quebrar cifras de substituição monoalfabética explorando distribuições de caracteres.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Distribuição de Frequências em Linguagem Natural",
                        "description": "Compreender as frequências relativas de ocorrência de letras e caracteres em textos em português, base para identificar padrões estatísticos em mensagens.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar letras mais frequentes em português",
                            "description": "Reconhecer que as letras mais comuns em textos em português são E (12-13%), A (11-12%), O (10%), seguidas de S, R, I, N, etc., conforme estudos estatísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar as frequências padrão das letras em português",
                                  "subSteps": [
                                    "Estude a tabela de frequências: E (12-13%), A (11-12%), O (10%), S (7-8%), R (6-7%), I (6%), N (5%), etc.",
                                    "Crie um mnemônico ou flashcards para as top 10 letras: EAOSRINU...",
                                    "Repita a lista em voz alta 5 vezes, cobrindo a tabela.",
                                    "Escreva a lista de cor em um papel 3 vezes.",
                                    "Compare com fontes confiáveis como estudos de criptoanálise em português."
                                  ],
                                  "verification": "Recitar corretamente as top 5 letras e suas frequências aproximadas sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de frequências de letras em português (impressa ou digital)",
                                    "Flashcards vazios",
                                    "Caneta e papel"
                                  ],
                                  "tips": "Associe letras a palavras comuns: E em 'ele', A em 'a', O em 'o'.",
                                  "learningObjective": "Internalizar as distribuições estatísticas conhecidas das letras em textos em português.",
                                  "commonMistakes": [
                                    "Confundir com frequências do inglês (E,T,A,O,I,N)",
                                    "Ignorar variações por dialeto ou gênero textual",
                                    "Memorizar valores exatos em vez de faixas aproximadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e preparar um texto amostra em português",
                                  "subSteps": [
                                    "Selecione um texto neutro de 200-500 palavras (ex: notícia ou trecho de livro).",
                                    "Remova acentos, maiúsculas/minúsculas e pontuação para análise puramente alfabética.",
                                    "Conte o total de letras no texto usando uma ferramenta ou manualmente.",
                                    "Divida o texto em seções para facilitar contagem inicial.",
                                    "Registre o texto limpo em uma planilha com colunas para cada letra."
                                  ],
                                  "verification": "Texto preparado com contagem total de letras exata e sem caracteres não-alfabéticos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Texto em português (ex: artigo online)",
                                    "Editor de texto ou planilha (Google Sheets/Excel)",
                                    "Lista de alfabeto português"
                                  ],
                                  "tips": "Use Ctrl+H para substituições rápidas de pontuação e normalização de case.",
                                  "learningObjective": "Preparar dados limpos para análise de frequência, simulando pré-processamento em criptoanálise.",
                                  "commonMistakes": [
                                    "Incluir acentos como letras separadas",
                                    "Manter maiúsculas sem converter",
                                    "Escolher texto muito curto ou enviesado (ex: poesia)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar e calcular frequências das letras no texto",
                                  "subSteps": [
                                    "Conte ocorrências de cada letra (A-Z) no texto preparado.",
                                    "Calcule a porcentagem: (ocorrências / total letras) * 100.",
                                    "Ordene as letras por frequência decrescente.",
                                    "Arredonde porcentagens para 1 casa decimal e some para verificar 100%.",
                                    "Identifique as top 5 letras mais frequentes no seu texto."
                                  ],
                                  "verification": "Tabela completa com contagens, porcentagens e top 5 listadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha com texto preparado",
                                    "Calculadora ou funções do Excel (CONT.SE, SOMAR)",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "Use fórmulas automáticas na planilha para evitar erros de cálculo manual.",
                                  "learningObjective": "Aplicar contagem empírica para validar distribuições teóricas de letras.",
                                  "commonMistakes": [
                                    "Erros aritméticos em somas",
                                    "Esquecer de normalizar por total de letras",
                                    "Confundir contagem absoluta com relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar resultados com frequências padrão e concluir",
                                  "subSteps": [
                                    "Compare suas top 5 com as padrão: E,A,O,S,R devem dominar.",
                                    "Calcule desvios: diferença entre sua % e padrão para top letras.",
                                    "Discuta discrepâncias (ex: texto curto causa variação).",
                                    "Liste as 7 letras mais frequentes identificadas.",
                                    "Registre insights para criptoanálise (ex: E como letra mais provável)."
                                  ],
                                  "verification": "Relatório curto com comparação, top letras identificadas e insights.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de frequências padrão",
                                    "Sua planilha de contagem",
                                    "Modelo de relatório simples"
                                  ],
                                  "tips": "Gráficos de barras na planilha visualizam diferenças rapidamente.",
                                  "learningObjective": "Interpretar dados de frequência e conectá-los a aplicações em criptografia.",
                                  "commonMistakes": [
                                    "Ignorar amostra pequena como causa de variação",
                                    "Concluir sem comparar com padrão",
                                    "Listar incorretamente ordem baseada em dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Pegue o primeiro parágrafo de 'Dom Casmurro' de Machado de Assis. Limpe-o (remova pontuação, normalize case), conte letras: encontre E ~13%, A ~11%, confirme top como E,A,O,S,R. Use para quebrar cifra simples substituindo E por espaço.",
                              "finalVerifications": [
                                "Lista correta das top 7 letras: E,A,O,S,R,I,N com faixas de % aproximadas.",
                                "Contagem precisa em texto de 300+ letras sem erros aritméticos.",
                                "Identificação de pelo menos 3 discrepâncias explicáveis entre amostra e padrão.",
                                "Relatório escrito resumindo processo e conclusões.",
                                "Aplicação correta em exemplo de criptoanálise básica.",
                                "Gráfico ou tabela visual de frequências gerada."
                              ],
                              "assessmentCriteria": [
                                "Precisão das frequências memorizadas (90%+ correto nas top 5).",
                                "Qualidade da preparação do texto (limpo, sem erros de contagem total).",
                                "Correção matemática nos cálculos de porcentagem (soma ~100%).",
                                "Profundidade da comparação com padrões (inclui desvios e razões).",
                                "Clareza e completude do relatório final.",
                                "Criatividade na conexão com criptografia."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise de corpus textual e fonética.",
                                "Estatística: Distribuições empíricas e análise de variância.",
                                "Matemática: Porcentagens, ordenação e gráficos.",
                                "Português: Vocabulário comum e estrutura textual.",
                                "História da Computação: Bases da criptografia de Shannon."
                              ],
                              "realWorldApplication": "Em criptoanálise, como na quebra de cifras de substituição monoalfabética (ex: WWII ou ransomware moderno), onde mapeia-se letras cifradas para as mais frequentes em português para decifrar mensagens sem chave."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Calcular frequência absoluta e relativa",
                            "description": "Contar ocorrências de cada letra em um texto dado e calcular percentuais relativos para comparar com distribuições conhecidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o texto para análise",
                                  "subSteps": [
                                    "Copie o texto fornecido para um editor de texto ou planilha.",
                                    "Converta todo o texto para letras minúsculas para uniformizar.",
                                    "Remova espaços, pontuação e caracteres especiais, mantendo apenas letras do alfabeto.",
                                    "Conte o número total de letras após a limpeza.",
                                    "Registre o texto limpo e o total de caracteres."
                                  ],
                                  "verification": "Verifique se o texto limpo contém apenas letras minúsculas e se o total de caracteres foi contado corretamente comparando manualmente uma amostra.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto (Notepad, Google Docs), planilha (Excel ou Google Sheets)",
                                  "tips": "Use a função 'substituir tudo' para remover não-letras rapidamente.",
                                  "learningObjective": "Entender a importância da padronização de dados antes da análise quantitativa.",
                                  "commonMistakes": "Esquecer de converter maiúsculas para minúsculas ou incluir espaços no total."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a frequência absoluta de cada letra",
                                  "subSteps": [
                                    "Crie uma tabela com colunas para cada letra do alfabeto (A-Z).",
                                    "Percorra o texto limpo letra por letra, incrementando o contador para cada ocorrência.",
                                    "Some todas as contagens para confirmar que igualam o total de letras.",
                                    "Registre as contagens absolutas em uma tabela organizada.",
                                    "Destaque letras com zero ocorrências."
                                  ],
                                  "verification": "Some as frequências absolutas e confirme que o total bate com o comprimento do texto limpo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou papel e caneta para tabela manual",
                                  "tips": "Use fórmulas de contagem em planilhas (ex: CONT.SE no Excel) para automatizar.",
                                  "learningObjective": "Dominar o processo de contagem manual e automatizada de elementos discretos.",
                                  "commonMistakes": "Contar maiúsculas separadamente ou errar na soma total."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a frequência relativa (percentual)",
                                  "subSteps": [
                                    "Para cada letra, divida a frequência absoluta pelo total de letras e multiplique por 100.",
                                    "Arredonde os percentuais para duas casas decimais.",
                                    "Some todos os percentuais para verificar se aproximam de 100% (tolerância de 0.01%).",
                                    "Crie uma nova coluna na tabela com os percentuais relativos.",
                                    "Ordene as letras do maior para o menor percentual."
                                  ],
                                  "verification": "Confira que a soma dos percentuais é exatamente 100% e valide cálculos com uma calculadora.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora ou planilha com fórmulas (ex: =B2/$B$10*100)",
                                  "tips": "Use referências absolutas em planilhas (com $) para evitar erros ao copiar fórmulas.",
                                  "learningObjective": "Aplicar proporções e percentuais em conjuntos de dados reais.",
                                  "commonMistakes": "Dividir incorretamente (ex: por 100 antes) ou esquecer de somar para verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com distribuições conhecidas",
                                  "subSteps": [
                                    "Obtenha uma tabela de frequências esperadas para o idioma (ex: inglês: E=12.7%, T=9.1%).",
                                    "Calcule a diferença percentual entre sua tabela e a esperada para cada letra.",
                                    "Identifique as 3-5 letras com maiores desvios.",
                                    "Anote observações sobre similaridades e diferenças.",
                                    "Discuta implicações para criptoanálise (ex: idioma provável)."
                                  ],
                                  "verification": "Liste as top 3 letras mais frequentes em ambos e confirme se coincidem ou divergem logicamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de frequências padrão (impressa ou online), planilha para diferenças",
                                  "tips": "Pesquise 'letter frequency English' para dados precisos; foque em ETAOIN SHRDLU.",
                                  "learningObjective": "Interpretar dados comparativos para inferências em contextos analíticos.",
                                  "commonMistakes": "Usar frequências de idioma errado ou ignorar arredondamentos nas diferenças."
                                }
                              ],
                              "practicalExample": "Analise o texto cifrado 'XRII XMKII VJMKAF' (simulando uma cifra simples). Após limpeza: 'xriixmkii vjmkaf' -> letras: x:3, r:1, i:4, m:2, k:3, v:1, j:1, a:1, f:1 (total 17). Absoluta: I=23.5%, X/K=17.6%. Compare com inglês (E~12.7%): I alto sugere substituição por E.",
                              "finalVerifications": [
                                "Frequências absolutas somam exatamente o total de letras.",
                                "Frequências relativas somam 100%.",
                                "Comparação identifica pelo menos 3 letras com desvios >5%.",
                                "Tabela está organizada e legível.",
                                "Observações incluem implicações para o idioma ou cifra.",
                                "Cálculos validados com amostra manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos absolutos e relativos (erro <1%).",
                                "Completude da preparação do texto (apenas letras minúsculas).",
                                "Qualidade da comparação com distribuições padrão.",
                                "Clareza e organização da tabela final.",
                                "Profundidade das observações e interpretações.",
                                "Eficiência no uso de ferramentas (tempo dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de distribuição de frequências e percentuais.",
                                "Linguística: Padrões fonéticos e distribuição lexical em idiomas.",
                                "Matemática: Proporções, divisão e arredondamento.",
                                "História: Aplicações em criptografia clássica (ex: cifra de César)."
                              ],
                              "realWorldApplication": "Em criptoanálise, identificar o idioma do texto cifrado comparando frequências (ex: FBI usa para mensagens interceptadas); em análise de dados, monitorar padrões em logs de texto ou redes sociais para detecção de spam/phishing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Construir histograma de frequências",
                            "description": "Representar graficamente as frequências de letras em um texto para visualização intuitiva de padrões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o texto e contar frequências absolutas das letras",
                                  "subSteps": [
                                    "Selecione um texto curto de linguagem natural (ex: 100-200 caracteres).",
                                    "Converta todo o texto para minúsculas e remova espaços, pontuação e números.",
                                    "Crie uma tabela com 26 linhas, uma para cada letra do alfabeto (a-z).",
                                    "Percorra o texto letra por letra e incremente o contador para cada ocorrência.",
                                    "Some todas as contagens para obter o total de letras no texto."
                                  ],
                                  "verification": "Verifique se a soma das frequências equals o número total de letras no texto limpo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Texto de exemplo impresso ou escrito"
                                  ],
                                  "tips": "Use um marcador para riscar cada letra contada no texto original para evitar erros de contagem dupla.",
                                  "learningObjective": "Dominar a contagem precisa de frequências para análise de padrões linguísticos.",
                                  "commonMistakes": [
                                    "Esquecer de converter maiúsculas para minúsculas",
                                    "Incluir espaços ou pontuação nas contagens",
                                    "Erros aritméticos na soma final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar o layout e escalas do histograma",
                                  "subSteps": [
                                    "Ordene as letras alfabeticamente no eixo X (a-z).",
                                    "Determine a escala do eixo Y baseada na frequência máxima (ex: cada unidade = 1% ou 5 ocorrências).",
                                    "Escolha a largura das barras (uniforme para todas as letras) e o espaçamento.",
                                    "Desenhe os eixos: horizontal para letras, vertical para frequências.",
                                    "Marque os ticks no eixo Y de forma proporcional à escala escolhida."
                                  ],
                                  "verification": "Confira se a escala permite plotar a barra mais alta sem ultrapassar o gráfico e se todas as 26 letras cabem no eixo X.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Régua",
                                    "Lápis"
                                  ],
                                  "tips": "Use régua para eixos retos e ticks uniformes; reserve 20% extra de altura para a barra máxima.",
                                  "learningObjective": "Entender como escalas e proporções criam representações visuais precisas.",
                                  "commonMistakes": [
                                    "Escala muito comprimida causando barras sobrepostas",
                                    "Eixo X não alfabético",
                                    "Ticks irregulares no eixo Y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar as barras do histograma",
                                  "subSteps": [
                                    "Para cada letra, calcule a altura da barra multiplicando a frequência pela escala do eixo Y.",
                                    "Desenhe a barra vertical a partir da base do eixo X até a altura calculada.",
                                    "Preencha as barras com cor ou hachura para destaque visual.",
                                    "Mantenha largura e espaçamento consistentes entre barras.",
                                    "Verifique proporcionalidade comparando alturas visualmente."
                                  ],
                                  "verification": "Meça 3 barras aleatórias com régua para confirmar que as alturas correspondem às frequências escaladas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Régua",
                                    "Lápis de cor ou caneta"
                                  ],
                                  "tips": "Comece pelas letras com frequências altas para ganhar confiança; use lápis primeiro para ajustes.",
                                  "learningObjective": "Aplicar proporções matemáticas na construção gráfica de dados.",
                                  "commonMistakes": [
                                    "Barras de alturas desproporcionais às frequências",
                                    "Larguras variadas entre barras",
                                    "Sobreposição de barras adjacentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar com rótulos, título e análise inicial",
                                  "subSteps": [
                                    "Adicione rótulos no eixo X (letras a-z abaixo das barras).",
                                    "Rotule o eixo Y com 'Frequência Absoluta' e ticks numéricos.",
                                    "Coloque um título claro: 'Histograma de Frequências de Letras no Texto: [nome do texto]'.",
                                    "Identifique as 3 letras mais frequentes e anote padrões observados.",
                                    "Assine e date o gráfico."
                                  ],
                                  "verification": "O gráfico deve ter todos os rótulos legíveis, título descritivo e pelo menos uma observação de padrão.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta preta"
                                  ],
                                  "tips": "Use letra maiúscula para títulos e negrito para rótulos de eixos para melhor legibilidade.",
                                  "learningObjective": "Completar visualizações com elementos que facilitam a comunicação de dados.",
                                  "commonMistakes": [
                                    "Rótulos ilegíveis ou ausentes",
                                    "Título genérico sem referência ao texto",
                                    "Análise superficial sem identificação de picos"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto: 'a criptografia e fascinante'. Após limpeza: 'acriptografiaefascinante'. Frequências: a:4, c:2, e:2, f:1, g:1, i:3, n:2, o:1, p:1, r:2, s:2, t:2. Histograma com eixo Y em unidades de 1: barras altas para 'a' (4), 'i' (3), etc., revelando 'a' como mais comum.",
                              "finalVerifications": [
                                "Todas as 26 letras têm barras (zero para ausentes).",
                                "Alturas das barras são proporcionais às frequências contadas.",
                                "Eixos rotulados corretamente com escalas precisas.",
                                "Título inclui referência ao texto analisado.",
                                "Padrões visuais intuitivos (picos para letras comuns como 'a', 'e').",
                                "Soma das frequências bate com total de letras limpas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de frequências (erro <1%).",
                                "Proporcionalidade visual exata das barras.",
                                "Clareza e legibilidade do gráfico completo.",
                                "Escolha adequada de escala para o conjunto de dados.",
                                "Identificação correta de padrões de frequência.",
                                "Uso consistente de materiais e técnicas de desenho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e gráficos de barras.",
                                "Língua Portuguesa: Análise linguística de distribuição lexical.",
                                "Artes Visuais: Técnicas de representação gráfica e proporção.",
                                "História: Aplicação em criptoanálise histórica (ex: quebra de códigos Enigma)."
                              ],
                              "realWorldApplication": "Na criptoanálise, histogramas de frequência ajudam a identificar o idioma de mensagens cifradas comparando picos (ex: 'e' em inglês vs. 'a' em português), facilitando ataques de frequência em cifras de substituição simples usadas em espionagem e segurança digital."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Cifras de Substituição Monoalfabética",
                        "description": "Entender o mecanismo de cifras que aplicam uma permutação fixa única para cada letra do alfabeto, preservando frequências relativas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Reconhecer uma cifra monoalfabética",
                            "description": "Identificar textos cifrados onde cada letra plaintext é substituída por uma única letra ciphertext de forma consistente, sem repetições na chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de uma Cifra Monoalfabética",
                                  "subSteps": [
                                    "Leia a definição: cada letra do plaintext é substituída por uma única letra do ciphertext de forma consistente e biunívoca.",
                                    "Identifique propriedades chave: mapeamento 1:1, sem repetições na chave, preservação de frequências relativas.",
                                    "Distinga de outras cifras: monoalfabética vs. polialfabética (múltiplas substituições) ou transposição (reordenação).",
                                    "Estude exemplos visuais de mapeamento alfabético.",
                                    "Anote diferenças com cifras modernas como AES."
                                  ],
                                  "verification": "Explique em 3 frases o que diferencia uma cifra monoalfabética de uma polialfabética.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Vídeo introdutório sobre criptografia (ex: Khan Academy)"
                                  ],
                                  "tips": "Visualize o mapeamento como uma permutação do alfabeto inglês.",
                                  "learningObjective": "Dominar a definição e propriedades essenciais para reconhecimento.",
                                  "commonMistakes": [
                                    "Confundir com cifras de transposição que preservam letras mas mudam ordem.",
                                    "Achar que repetições na chave são permitidas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar e Analisar Símbolos Únicos no Texto Cifrado",
                                  "subSteps": [
                                    "Copie o texto cifrado em uma tabela ou planilha.",
                                    "Liste todas as letras únicas, ignorando maiúsculas/minúsculas.",
                                    "Conte o total de símbolos únicos (esperado: 20-26 para textos longos em inglês).",
                                    "Compare com o alfabeto fonte: se muito poucos (<15), pode não ser monoalfabética.",
                                    "Registre frequência absoluta de cada letra."
                                  ],
                                  "verification": "Para um texto dado, liste símbolos únicos e confirme contagem ≈26.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto cifrado exemplo (impresso ou digital)",
                                    "Planilha Excel ou papel quadriculado"
                                  ],
                                  "tips": "Use um conjunto (set) para evitar duplicatas ao listar.",
                                  "learningObjective": "Identificar indício primário de monoalfabética via cardinalidade do alfabeto cifrado.",
                                  "commonMistakes": [
                                    "Ignorar espaços/pontuação ao contar letras.",
                                    "Contar apenas as 10 mais frequentes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Distribuição de Frequências de Letras",
                                  "subSteps": [
                                    "Calcule frequências relativas (% de cada letra no texto).",
                                    "Compare com frequências padrão do inglês (E:12%, T:9%, A:8%, etc.).",
                                    "Identifique letras mais/menos frequentes no ciphertext.",
                                    "Procure por 'padrão de idioma natural': uma letra dominante (~12%), gradiente suave.",
                                    "Suspeite de não-monoalfabética se frequências uniformes ou binárias."
                                  ],
                                  "verification": "Gere gráfico de barras de frequências e compare com tabela padrão do inglês.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de frequências inglesas (online)",
                                    "Calculadora ou app de contagem de letras"
                                  ],
                                  "tips": "Ordene letras por frequência descendente para visualização rápida.",
                                  "learningObjective": "Usar análise de frequência como evidência de substituição monoalfabética.",
                                  "commonMistakes": [
                                    "Usar texto curto (<100 letras), onde estatísticas são imprecisas.",
                                    "Confundir com idiomas de baixa entropia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Consistência e Estrutura Geral",
                                  "subSteps": [
                                    "Cheque comprimentos de palavras: preservados na monoalfabética.",
                                    "Procure padrões repetidos: mesma palavra plaintext → mesma ciphertext.",
                                    "Teste hipóteses iniciais: assuma letra mais freq. é E, veja consistência.",
                                    "Elimine transposições: procure por anagramas óbvios ou grades.",
                                    "Confirme ausência de dígitos/símbolos misturados (indicaria cifra diferente)."
                                  ],
                                  "verification": "Identifique 2 padrões repetidos e explique por que indicam consistência monoalfabética.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de textos cifrados variados",
                                    "Dicionário inglês para checagem de palavras"
                                  ],
                                  "tips": "Foque em bigramas/trigramas comuns como 'TH' ou 'ING' mapeados consistentemente.",
                                  "learningObjective": "Confirmar reconhecimento via testes de consistência sem decifração completa.",
                                  "commonMistakes": [
                                    "Assumir monoalfabética sem checar repetições inconsistentes.",
                                    "Ignorar estrutura de sentenças."
                                  ]
                                }
                              ],
                              "practicalExample": "Texto cifrado: 'ZMWXMXKLMXYKI JXIXKXYWIXYKI' (Caesar shift 3 de 'CRYPTOGRAPHY ISFUNANDIMPORTANT'). Conte 21 letras únicas, freq. X~14% (como E), I~11% (T), padrão inglês preservado, repetições consistentes (ex: 'IXYKI' aparece duas vezes).",
                              "finalVerifications": [
                                "Conte símbolos únicos em 3 textos e classifique corretamente como monoalfabéticos.",
                                "Gere e compare gráficos de frequência com padrão inglês.",
                                "Identifique inconsistências em textos não-monoalfabéticos.",
                                "Explique verbalmente por que um texto é monoalfabético.",
                                "Teste consistência em padrões repetidos de 5 palavras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de símbolos únicos (±1 erro).",
                                "Correta identificação de top-5 letras frequentes vs. inglês.",
                                "Detecção de pelo menos 80% dos casos monoalfabéticos em testes.",
                                "Explicação clara de 3 propriedades chave.",
                                "Análise de consistência sem erros lógicos.",
                                "Tempo de reconhecimento <5 min para textos médios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e análise de distribuições.",
                                "História: Criptografia na Revolução Americana (ex: cifra de Vigenère como evolução).",
                                "Linguística: Análise de frequência em corpora textuais.",
                                "Estatística: Testes de hipótese sobre uniformidade vs. Zipf.",
                                "Informática: Algoritmos de contagem e ordenação."
                              ],
                              "realWorldApplication": "Em cibersegurança, reconhecer monoalfabéticas em comunicações antigas ou amador permite priorizar ataques; historiadores decifram documentos medievais; em forensics digitais, distingue cifragem fraca de protocolos modernos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Explicar preservação de frequências",
                            "description": "Demonstrar que uma substituição monoalfabética mantém as frequências relativas das letras, permitindo análise estatística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as frequências relativas de letras em texto plano",
                                  "subSteps": [
                                    "Colete um texto plano em português ou inglês de pelo menos 100 caracteres.",
                                    "Conte a ocorrência de cada letra, ignorando maiúsculas/minúsculas e não-letras.",
                                    "Calcule a frequência relativa de cada letra (ocorrências totais / comprimento do texto).",
                                    "Identifique as letras mais e menos frequentes (ex: E, A comuns; Z, Q raros).",
                                    "Crie um gráfico de barras para visualizar as frequências."
                                  ],
                                  "verification": "Frequências calculadas corretamente e gráfico gerado mostrando padrões conhecidos (ex: E ~12-13%).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto plano exemplo",
                                    "Planilha ou Python/Jupyter para contagem",
                                    "Gráfico tool como Excel ou Matplotlib"
                                  ],
                                  "tips": "Use textos reais como trechos de livros para autenticidade; foque em frequências absolutas primeiro.",
                                  "learningObjective": "Reconhecer padrões de frequência em linguagem natural como base para criptoanálise.",
                                  "commonMistakes": [
                                    "Ignorar case sensitivity",
                                    "Incluir espaços/pontuação nas contagens",
                                    "Usar amostras muito pequenas que distorcem frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o funcionamento de uma cifra de substituição monoalfabética",
                                  "subSteps": [
                                    "Defina uma chave de substituição: mapeamento 1:1 de cada letra plaintext para ciphertext (ex: A->X, B->M).",
                                    "Aplique a cifra a um texto plano conhecido, substituindo letra por letra.",
                                    "Explique que é uma permutação bijetiva: cada letra plaintext tem exatamente uma ciphertext única.",
                                    "Note que a ordem de substituição não altera contagens relativas.",
                                    "Verifique que nenhuma letra é mapeada para si mesma se for cifra afim, mas foque em preservação geral."
                                  ],
                                  "verification": "Texto cifrado gerado corretamente e mapeamento documentado sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Texto plano do Step 1",
                                    "Tabela de mapeamento manual ou script Python para cifrar"
                                  ],
                                  "tips": "Use uma chave aleatória gerada para simular cifra real; escreva a tabela de mapeamento visualmente.",
                                  "learningObjective": "Entender que substituição monoalfabética é uma reordenação das letras, não alterando contagens.",
                                  "commonMistakes": [
                                    "Confundir com polialfabética (múltiplas substituições)",
                                    "Permitir mapeamentos muitos-para-um",
                                    "Esquecer que é bijetiva"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar frequências no texto plano e cifrado",
                                  "subSteps": [
                                    "Conte as frequências no texto cifrado gerado no Step 2.",
                                    "Calcule frequências relativas no ciphertext da mesma forma que no plaintext.",
                                    "Compare os rankings: a letra mais comum no plaintext deve corresponder à mais comum no ciphertext.",
                                    "Crie gráficos lado a lado para visualização.",
                                    "Calcule correlação estatística (ex: Pearson) entre vetores de frequência para quantificar preservação."
                                  ],
                                  "verification": "Gráficos mostram matching de frequências relativas; correlação >0.9.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto cifrado do Step 2",
                                    "Ferramentas de contagem e gráfico do Step 1",
                                    "Biblioteca como SciPy para correlação"
                                  ],
                                  "tips": "Ordene letras por frequência para facilitar comparação; use textos longos para precisão.",
                                  "learningObjective": "Demonstrar empiricamente que frequências são preservadas sob substituição monoalfabética.",
                                  "commonMistakes": [
                                    "Erro na contagem do ciphertext",
                                    "Comparar frequências absolutas em vez de relativas",
                                    "Ignorar normalização por tamanho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar implicações para análise estatística em criptoanálise",
                                  "subSteps": [
                                    "Descreva como atacantes usam frequências conhecidas (ex: E mais comum) para mapear ciphertext de volta.",
                                    "Discuta limitações: textos curtos ou idiomas diferentes podem falhar.",
                                    "Simule um ataque parcial: assuma E->Z (mais comum) e teste decifração.",
                                    "Conclua que preservação permite quebra estatística sem chave.",
                                    "Reflita sobre por que cifras polialfabéticas evitam isso."
                                  ],
                                  "verification": "Explicação escrita ou verbal clara, com simulação de ataque bem-sucedida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dados de frequência dos Steps 1-3",
                                    "Tabela de frequências padrão por idioma"
                                  ],
                                  "tips": "Use analogia: 'é como embaralhar cartas sem mudar a quantidade de cada naipe'.",
                                  "learningObjective": "Conectar preservação de frequências à viabilidade da análise de frequência em criptoanálise.",
                                  "commonMistakes": [
                                    "Superestimar eficácia em textos curtos",
                                    "Confundir com análise bigrama",
                                    "Ignorar contexto linguístico"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto plano: 'HELLO WORLD' (frequências: H1,L3,O2,W1,R1,D1,E1). Cifra: H->Z, E->X, L->P, O->Q, etc. Ciphertext: 'ZXPPS PSQDE'. Frequências: P3 (L), Q2 (O), etc. – ranking preservado: L mais comum -> P mais comum.",
                              "finalVerifications": [
                                "Explica corretamente que mapeamento 1:1 preserva contagens relativas.",
                                "Calcula e compara frequências em exemplo prático com precisão.",
                                "Identifica letras mais/menos comuns corretamente em plaintext e ciphertext.",
                                "Demonstra correlação alta entre vetores de frequência.",
                                "Descreve como isso habilita análise de frequência para quebra da cifra.",
                                "Menciona limitações como comprimento de texto."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas contagens e comparações (100% correto).",
                                "Clareza na explicação conceitual da preservação.",
                                "Uso efetivo de visualizações (gráficos/comparações).",
                                "Profundidade na discussão de implicações criptoanalíticas.",
                                "Criatividade no exemplo prático e simulação de ataque.",
                                "Correção de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Cálculo de frequências relativas e correlação.",
                                "Matemática Discreta: Funções bijetivas e permutações.",
                                "História: Uso na quebra de códigos como o Zodiac Killer ou Enigma inicial.",
                                "Linguística: Variações de frequência por idioma.",
                                "Programação: Scripts para automação de contagens."
                              ],
                              "realWorldApplication": "Na Segunda Guerra Mundial, criptoanalistas aliados usaram análise de frequência para quebrar cifras monoalfabéticas japonesas (PURPLE), preservando mensagens secretas e salvando vidas; hoje, em forensics digitais e cibersegurança para analisar mensagens cifradas simples."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Gerar uma cifra monoalfabética simples",
                            "description": "Criar uma chave de substituição e cifrar um texto curto manualmente para praticar o conceito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e criar uma chave de substituição monoalfabética",
                                  "subSteps": [
                                    "Estude o alfabeto inglês (A-Z) e entenda que uma cifra monoalfabética mapeia cada letra para exatamente uma outra letra única, sem repetições.",
                                    "Crie uma permutação aleatória do alfabeto: liste A-Z e embaralhe para formar o alfabeto cifrado.",
                                    "Escreva a chave como pares: A→X, B→P, etc., garantindo mapeamento biunívoco (1:1).",
                                    "Teste a chave manualmente substituindo 2-3 letras para verificar unicidade.",
                                    "Anote a chave em uma tabela para referência rápida."
                                  ],
                                  "verification": "Verifique se cada letra do alfabeto plano tem uma correspondente única no cifrado e vice-versa, sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, tabela impressa do alfabeto inglês.",
                                  "tips": "Use um dado ou gerador aleatório online para embaralhar, mas anote manualmente para praticar.",
                                  "learningObjective": "Dominar a criação de uma chave de substituição biunívoca para cifras monoalfabéticas.",
                                  "commonMistakes": "Mapear uma letra para múltiplas (ex: A→X e A→Y) ou deixar letras sem mapeamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e preparar o texto plano (plaintext)",
                                  "subSteps": [
                                    "Escolha uma frase curta em inglês maiúsculo, com 10-20 letras, sem acentos ou números (ex: 'HELLO WORLD').",
                                    "Converta todo o texto para maiúsculas e remova espaços, pontuação ou caracteres especiais.",
                                    "Conte a frequência de cada letra no texto para análise posterior.",
                                    "Escreva o texto plano claramente separado do cifrado.",
                                    "Prepare uma linha em branco abaixo para o texto cifrado."
                                  ],
                                  "verification": "Confirme que o plaintext tem apenas letras A-Z maiúsculas, sem espaços ou símbolos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis para contagem de frequência.",
                                  "tips": "Escolha textos com letras comuns como E, T, A para praticar análise de frequência futura.",
                                  "learningObjective": "Preparar um texto plano padronizado adequado para cifragem manual.",
                                  "commonMistakes": "Manter minúsculas, espaços ou pontuação, que complicam a substituição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a cifra monoalfabética ao texto plano",
                                  "subSteps": [
                                    "Para cada letra do plaintext, consulte a chave e escreva a letra correspondente no ciphertext.",
                                    "Prossiga letra por letra, sem pular, para evitar erros de transcrição.",
                                    "Compare o ciphertext resultante com o plaintext para garantir comprimento igual.",
                                    "Reescreva o ciphertext agrupando em blocos de 5 letras para legibilidade.",
                                    "Anote qualquer observação sobre padrões emergentes no ciphertext."
                                  ],
                                  "verification": "O ciphertext deve ter o mesmo número de letras que o plaintext, com cada letra substituída corretamente pela chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Chave anotada do Step 1, plaintext preparado, papel para ciphertext.",
                                  "tips": "Cubra a chave parcialmente para simular condições reais de sigilo.",
                                  "learningObjective": "Executar cifragem manual precisa usando a chave criada.",
                                  "commonMistakes": "Substituir incorretamente (ex: confundir A→X com B→X) ou inverter mapeamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar a cifra gerada",
                                  "subSteps": [
                                    "Use a chave inversa (crie mapeando ciphertext de volta para plaintext) para decifrar o texto.",
                                    "Compare o decifrado com o plaintext original para confirmar exatidão.",
                                    "Teste com uma segunda frase curta para validar a chave.",
                                    "Analise se o ciphertext parece 'aleatório' (sem padrões óbvios).",
                                    "Documente a chave, plaintext e ciphertext para portfólio."
                                  ],
                                  "verification": "Decifragem perfeita restaura o plaintext original sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Chave original e inversa, ciphertext gerado.",
                                  "tips": "Crie a chave inversa sistematicamente: liste ciphertext A-Z e mapeie para plaintext.",
                                  "learningObjective": "Validar a funcionalidade bidirecional da cifra monoalfabética.",
                                  "commonMistakes": "Não criar chave inversa corretamente, levando a decifragem falha."
                                }
                              ],
                              "practicalExample": "Chave: A→D, B→E, C→F, ..., Z→C. Plaintext: 'HELLO'. Ciphertext: 'KHOOR' (H→K, E→H, L→O, L→O, O→R). Decifre de volta para verificar.",
                              "finalVerifications": [
                                "Chave é um mapeamento biunívoco (26 letras únicas para 26 únicas).",
                                "Ciphertext tem comprimento idêntico ao plaintext.",
                                "Decifragem usando chave inversa restaura plaintext perfeitamente.",
                                "Nenhum padrão óbvio no ciphertext (ex: repetições não preservadas).",
                                "Processo manual sem uso de ferramentas digitais.",
                                "Documentação completa: chave, plaintext, ciphertext e verificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão da chave: 100% biunívoca sem duplicatas.",
                                "Correção da cifragem: Todas as substituições exatas.",
                                "Preparação do plaintext: Apenas A-Z maiúsculas.",
                                "Verificação bidirecional: Decifragem bem-sucedida.",
                                "Clareza da documentação: Tabelas legíveis e organizadas.",
                                "Análise básica: Contagem de frequência incluída."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Permutações e funções bijetoras.",
                                "História: Cifras usadas por Júlio César e na Segunda Guerra Mundial.",
                                "Linguística: Análise de frequência de letras em idiomas.",
                                "Lógica: Construção de tabelas de mapeamento e verificação de unicidade."
                              ],
                              "realWorldApplication": "Cifras monoalfabéticas são base para criptografia moderna como cifras de César em apps de mensagens seguras; usadas em quebra-cabeças, jogos de espionagem e introdução a segurança cibernética em comunicações básicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Procedimento de Análise de Frequência",
                        "description": "Aplicar a técnica sistemática de mapeamento de frequências do texto cifrado para o plaintext esperado para quebrar a cifra.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Calcular frequências no texto cifrado",
                            "description": "Contar e ordenar as letras mais frequentes em um texto cifrado fornecido, criando uma lista de candidatos para mapeamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o texto cifrado para análise",
                                  "subSteps": [
                                    "Receba o texto cifrado fornecido.",
                                    "Converta todo o texto para letras maiúsculas.",
                                    "Remova espaços, pontuação e qualquer caractere não alfabético.",
                                    "Conte o número total de letras restantes.",
                                    "Verifique se o texto limpo contém apenas letras do alfabeto (A-Z)."
                                  ],
                                  "verification": "O texto final é composto exclusivamente por letras maiúsculas A-Z e o comprimento total é conhecido.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Texto cifrado fornecido",
                                    "Papel e caneta ou editor de texto/planilha (Excel ou Google Sheets)"
                                  ],
                                  "tips": "Mantenha uma cópia do texto original para referência; use funções de substituição em planilhas para agilizar.",
                                  "learningObjective": "Limpar e padronizar dados para garantir precisão na análise de frequências.",
                                  "commonMistakes": [
                                    "Ignorar diferenças entre maiúsculas e minúsculas",
                                    "Deixar caracteres não alfabéticos",
                                    "Erros de digitação durante a limpeza"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar as ocorrências de cada letra",
                                  "subSteps": [
                                    "Liste todas as 26 letras do alfabeto (A a Z).",
                                    "Para cada letra, percorra o texto limpo e conte suas ocorrências.",
                                    "Registre o número de ocorrências em uma tabela (letra | contagem).",
                                    "Some todas as contagens para verificar se iguala o comprimento total do texto.",
                                    "Opcionalmente, calcule a frequência percentual: (contagem / total) * 100."
                                  ],
                                  "verification": "A soma das contagens de todas as letras é igual ao comprimento do texto limpo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto limpo do passo 1",
                                    "Tabela ou planilha para registro"
                                  ],
                                  "tips": "Use traços ou colunas para marcar contagens manuais; em planilhas, utilize a função CONT.SE.",
                                  "learningObjective": "Desenvolver habilidade em contagem sistemática e validação de dados.",
                                  "commonMistakes": [
                                    "Contar letras erradas",
                                    "Esquecer de somar para validação",
                                    "Confundir letras semelhantes como 'O' e '0'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ordenar as letras por frequência decrescente",
                                  "subSteps": [
                                    "Crie uma lista com pares (letra, contagem) apenas para letras com contagem > 0.",
                                    "Ordene essa lista da maior para a menor contagem (decrescente).",
                                    "Em caso de empate, ordene alfabeticamente.",
                                    "Registre as top 10 letras mais frequentes.",
                                    "Visualize com um gráfico de barras simples se possível."
                                  ],
                                  "verification": "A lista está ordenada corretamente e as contagens batem com o passo anterior.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de contagens do passo 2",
                                    "Papel para ordenação ou planilha com função ORDENAR"
                                  ],
                                  "learningObjective": "Aprender a organizar dados quantitativos para análise prioritária.",
                                  "commonMistakes": [
                                    "Ordenar crescente em vez de decrescente",
                                    "Incluir letras com zero ocorrências",
                                    "Erros em empates"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar lista de candidatos para mapeamento",
                                  "subSteps": [
                                    "Consulte a tabela de frequências padrão do idioma (ex: Português: E=12.6%, A=11.7%, etc.).",
                                    "Mapeie as letras mais frequentes do cifrado para as mais frequentes do plain-text.",
                                    "Crie uma lista de 5-10 candidatos: 'Letra cifrada X (freq Y%) → candidatos: E, A, O'.",
                                    "Anote justificativas baseadas nas frequências.",
                                    "Salve a lista para uso em decifração posterior."
                                  ],
                                  "verification": "Lista contém mapeamentos lógicos baseados em frequências comparadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista ordenada do passo 3",
                                    "Tabela de frequências padrão do idioma (impressa ou online)"
                                  ],
                                  "tips": "Priorize as top 5; lembre que cifras podem distorcer ligeiramente as frequências.",
                                  "learningObjective": "Interpretar dados de frequência para hipóteses de decifração.",
                                  "commonMistakes": [
                                    "Usar frequências erradas do idioma",
                                    "Ignorar distorções em textos curtos",
                                    "Muitos candidatos por letra"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto cifrado: 'WJRMZB ZB WJV XLWBSXZ' (limpo: 'WJRMZBZBWJVXLWBSXZ', 17 letras). Contagens: W=4 (23.5%), Z=3 (17.6%), B=3 (17.6%), etc. Ordenado: W(4), Z(3), B(3), J(2), etc. Candidatos: W→E, Z→A, B→O (baseado em PT).",
                              "finalVerifications": [
                                "Soma das contagens equals comprimento do texto limpo.",
                                "Lista ordenada corretamente decrescente.",
                                "Top 3 letras mais frequentes identificadas.",
                                "Lista de candidatos inclui pelo menos 5 mapeamentos lógicos.",
                                "Frequências percentuais calculadas com precisão.",
                                "Justificativas baseadas em tabela padrão do idioma."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas contagens: 100% das letras corretas.",
                                "Ordenação perfeita sem erros de ranking.",
                                "Limpeza do texto completa e sem resíduos.",
                                "Mapeamentos coerentes com frequências padrão (>80% match lógico).",
                                "Apresentação clara da lista final.",
                                "Validação interna (soma total) realizada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de distribuições e percentuais.",
                                "Língua Portuguesa: Conhecimento de frequências letrais no idioma.",
                                "Matemática: Contagem, ordenação e análise quantitativa.",
                                "História: Aplicações em criptografia da Segunda Guerra Mundial."
                              ],
                              "realWorldApplication": "Na cibersegurança, analistas usam análise de frequência para quebrar cifras de substituição em comunicações interceptadas, como em inteligência militar ou forense digital."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2",
                              "10.1.4.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Mapear letras por frequência",
                            "description": "Associar a letra mais frequente do cifrado (ex: 'X') à mais frequente do plaintext (E), e assim sucessivamente, testando coerência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar tabela de frequências padrão do plaintext",
                                  "subSteps": [
                                    "Recuperar ou pesquisar as frequências relativas das letras em inglês (ex: E=12.7%, T=9.1%, A=8.2%, O=7.5%, I=7.0%).",
                                    "Listar as top 10-12 letras mais frequentes em ordem decrescente.",
                                    "Criar uma tabela ou lista com letras e percentuais aproximados.",
                                    "Ignorar maiúsculas/minúsculas e considerar apenas alfabeto inglês.",
                                    "Validar com uma fonte confiável como corpus de texto (ex: Brown Corpus)."
                                  ],
                                  "verification": "Tabela completa com top 10 letras e frequências corretas dentro de 1% de variação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de frequências de letras em inglês (impressa ou online)",
                                    "Papel e caneta ou planilha Excel/Google Sheets"
                                  ],
                                  "tips": "Memorize as top 5 (ETAOI) para agilizar futuras análises.",
                                  "learningObjective": "Compreender a distribuição estatística padrão de letras no plaintext em inglês.",
                                  "commonMistakes": [
                                    "Usar frequências de português ou outro idioma",
                                    "Incluir espaços ou pontuação nas contagens",
                                    "Ordenar incorretamente as top letras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular frequências no texto cifrado",
                                  "subSteps": [
                                    "Limpar o texto cifrado: converter para maiúsculas, remover não-letras.",
                                    "Contar ocorrências de cada letra única (A-Z).",
                                    "Calcular frequência relativa: (ocorrências da letra / total de letras) * 100.",
                                    "Ordenar as letras do cifrado por frequência decrescente.",
                                    "Listar top 10-12 letras com percentuais."
                                  ],
                                  "verification": "Lista ordenada de frequências do cifrado com totais somando 100%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto cifrado exemplo",
                                    "Planilha ou contador manual"
                                  ],
                                  "tips": "Use funções COUNTIF no Excel para contagens rápidas em textos longos.",
                                  "learningObjective": "Aplicar análise estatística para extrair padrões de frequência do cifrado.",
                                  "commonMistakes": [
                                    "Contar letras duplicadas incorretamente",
                                    "Esquecer de normalizar para percentuais",
                                    "Não ignorar caracteres não-alfabéticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer mapeamento inicial por frequência",
                                  "subSteps": [
                                    "Mapear 1ª mais frequente do cifrado → E (plaintext).",
                                    "Mapear 2ª → T, 3ª → A, 4ª → O, 5ª → I, e assim sucessivamente para top 8-10.",
                                    "Criar um dicionário ou tabela: Cifrado X → Plaintext E.",
                                    "Registrar percentuais lado a lado para comparação visual.",
                                    "Garantir que nenhum mapeamento seja duplicado."
                                  ],
                                  "verification": "Tabela de mapeamento inicial com top 10 pares letra→letra sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabelas de frequência do passo 1 e 2",
                                    "Papel quadriculado ou software de desenho"
                                  ],
                                  "tips": "Comece com top 5 para simplicidade; expanda se necessário.",
                                  "learningObjective": "Associar distribuições de frequência entre cifrado e plaintext.",
                                  "commonMistakes": [
                                    "Mapear letras de baixa frequência primeiro",
                                    "Ignorar proximidade percentual (ex: 15% cifrado → 9% T)",
                                    "Duplicar mapeamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar o mapeamento por coerência",
                                  "subSteps": [
                                    "Aplicar mapeamento parcial ao cifrado (substituir apenas letras mapeadas).",
                                    "Ler o texto resultante em busca de padrões: bigramas comuns (TH, HE), palavras parciais.",
                                    "Identificar incoerências (ex: sequência sem sentido) e trocar mapeamentos adjacentes.",
                                    "Iterar 2-3 vezes: reaplique e verifique até emergir texto legível.",
                                    "Documentar ajustes feitos e razões (ex: 'Troquei X de E para T por formar THE')."
                                  ],
                                  "verification": "Texto parcial legível com pelo menos 20-30% de palavras reconhecíveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto cifrado",
                                    "Chave de substituição parcial",
                                    "Dicionário inglês básico"
                                  ],
                                  "tips": "Procure por 'THE', 'AND', 'ING' como indicadores iniciais.",
                                  "learningObjective": "Validar mapeamento estatístico com análise linguística qualitativa.",
                                  "commonMistakes": [
                                    "Não testar parcial (aplicar tudo de uma vez)",
                                    "Ignorar contexto de palavras",
                                    "Parar na primeira iteração sem refinar"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto cifrado: 'XRST QEB DLIHE XRST NBOL'. Frequências cifrado: X(20%), R(15%), S(12%), T(10%), etc. Mapeamento inicial: X→E, R→T, S→A, T→O. Texto parcial: 'E O A O  QEB  L I H E  E O A O'. Teste revela 'XRST'→'THIS' (ajuste S→I, T→S). Resultado refinado: 'THIS IS THE FIRST THIS WORD'.",
                              "finalVerifications": [
                                "Mapeia corretamente top 5 letras de um cifrado exemplo.",
                                "Identifica e corrige pelo menos 2 incoerências no mapeamento.",
                                "Produz texto parcial legível (>20% coerente) de um cifrado curto.",
                                "Explica razões estatísticas e linguísticas para cada mapeamento.",
                                "Compara frequências com precisão <2% de erro.",
                                "Itera mapeamento até convergência em 3 tentativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão do mapeamento inicial (90% match com frequências padrão).",
                                "Qualidade da detecção de incoerências (pelo menos 80% resolvidas).",
                                "Legibilidade do texto decifrado parcial (palavras identificáveis).",
                                "Documentação completa de passos e ajustes.",
                                "Eficiência temporal (dentro de 75 minutos totais).",
                                "Uso correto de ferramentas e validações estatísticas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de distribuições e ordenação por frequência.",
                                "Linguística: Padrões de bigramas e frequência lexical em idiomas.",
                                "Matemática: Cálculo de percentuais e ordenação de dados.",
                                "História: Aplicações em criptoanálise da WWII (Enigma).",
                                "Programação: Implementação em scripts de contagem (Python Counter)."
                              ],
                              "realWorldApplication": "Em inteligência militar (ex: quebra de Enigma na WWII), análise forense de comunicações criptografadas, validação de segurança em apps de mensagens (WhatsApp end-to-end), e detecção de fraudes em textos codificados em finanças."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Descriptografar e validar parcialmente",
                            "description": "Aplicar o mapeamento parcial para decifrar o texto, identificar palavras conhecidas e refinar a chave iterativamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o mapeamento parcial inicial",
                                  "subSteps": [
                                    "Revise a tabela de análise de frequência do texto cifrado e do idioma alvo (ex: português).",
                                    "Mapeie as 5-10 letras mais frequentes do cifrado para as mais frequentes do idioma (ex: E no cifrado -> A no claro).",
                                    "Anote o mapeamento em uma tabela clara, incluindo letras não mapeadas como '?' ou espaços em branco.",
                                    "Verifique consistência: cada letra cifrada mapeia para apenas uma clara.",
                                    "Copie o texto cifrado para um local de trabalho separado."
                                  ],
                                  "verification": "Tabela de mapeamento completa com pelo menos 70% das letras principais mapeadas e sem conflitos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Papel ou planilha digital, tabela de frequências linguísticas, texto cifrado impresso ou digital.",
                                  "tips": "Comece com as letras mais frequentes para ganhos rápidos; use cores para diferenciar mapeamentos confirmados e provisórios.",
                                  "learningObjective": "Construir uma chave parcial precisa baseada em evidências estatísticas.",
                                  "commonMistakes": "Mapear múltiplas letras cifradas para a mesma clara; ignorar frequência de bigramas iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o mapeamento ao texto cifrado",
                                  "subSteps": [
                                    "Substitua cada letra cifrada pela correspondente no mapeamento, letra por letra.",
                                    "Mantenha espaços, pontuação e letras não mapeadas inalteradas para preservar estrutura.",
                                    "Escreva o texto parcialmente decifrado em uma linha abaixo do original para comparação.",
                                    "Leia em voz alta o texto parcial para detectar padrões iniciais.",
                                    "Registre o percentual aproximado de texto legível (ex: 40-60%)."
                                  ],
                                  "verification": "Texto parcial gerado com todas as substituições aplicadas corretamente e sem erros de transcrição.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Texto cifrado, tabela de mapeamento, lápis/caneta ou editor de texto simples.",
                                  "tips": "Trabalhe em seções curtas (10-20 palavras) para evitar fadiga; use maiúsculas para cifrado e minúsculas para claro.",
                                  "learningObjective": "Executar substituição sistemática para visualizar progresso na descriptografia.",
                                  "commonMistakes": "Esquecer de aplicar mapeamento a todas as ocorrências de uma letra; alterar espaços ou pontuação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar palavras e padrões conhecidos",
                                  "subSteps": [
                                    "Procure por palavras comuns no texto parcial (ex: 'o', 'de', 'a', 'que' em português).",
                                    "Identifique padrões como finais de palavras (ex: 'o', 'a', 's') ou inícios (ex: 'em', 'no').",
                                    "Compare com contexto esperado (ex: título ou tema conhecido do texto).",
                                    "Anote palavras candidatas e letras associadas.",
                                    "Marque letras não mapeadas que aparecem em posições suspeitas."
                                  ],
                                  "verification": "Lista de pelo menos 5 palavras ou padrões identificados com justificativa linguística.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Dicionário básico ou lista de palavras frequentes, texto parcial.",
                                  "tips": "Considere o comprimento da palavra e posição no texto; leia contextualmente como uma adivinhação guiada.",
                                  "learningObjective": "Usar conhecimento linguístico para validar e estender o mapeamento.",
                                  "commonMistakes": "Forçar palavras improváveis; ignorar frequência absoluta vs. contexto local."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar iterativamente a chave e validar",
                                  "subSteps": [
                                    "Atualize o mapeamento com novas associações de padrões identificados.",
                                    "Reaplique o mapeamento atualizado ao texto inteiro.",
                                    "Avalie melhorias: conte palavras legíveis e coerência geral.",
                                    "Repita o ciclo de identificação e refinamento até 70-80% de legibilidade.",
                                    "Documente mudanças na chave e razões para cada refinamento."
                                  ],
                                  "verification": "Chave refinada com pelo menos 2 iterações documentadas e texto parcial coerente.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": "Tabela de mapeamento atualizada, histórico de iterações, texto original.",
                                  "tips": "Limite a 3-4 refinamentos por sessão para evitar overfitting; teste com frases isoladas primeiro.",
                                  "learningObjective": "Iterar sistematicamente para convergir a uma descriptografia viável.",
                                  "commonMistakes": "Alterar mapeamentos confirmados sem evidência forte; parar cedo sem validação múltipla."
                                }
                              ],
                              "practicalExample": "Texto cifrado: 'XLMW ZQV ZM VBNLMW...' (cifra de 'Olá mundo este é um teste...'). Mapeamento inicial: X->O, L->L, M->A. Aplicação parcial: 'OLÁ ZQV ZÁ VBNLAW...'. Identifica 'OLÁ' e 'ZÁ' como 'é', refinando Z->É, Q->U, V->M para 'Olá éu é umlaé...'. Iteração revela mais.",
                              "finalVerifications": [
                                "Pelo menos 70% do texto parcial forma palavras reconhecíveis.",
                                "Chave mapeia consistentemente sem ambiguidades.",
                                "Identificadas 5+ palavras completas conhecidas.",
                                "Documentadas 2+ iterações com melhorias mensuráveis.",
                                "Texto parcial mantém estrutura gramatical plausível.",
                                "Nenhuma letra cifrada mapeada para múltiplas claras."
                              ],
                              "assessmentCriteria": [
                                "Precisão do mapeamento inicial (80%+ match com frequências).",
                                "Número e qualidade de padrões/palavras identificados.",
                                "Evidência de iterações iterativas com refinamentos lógicos.",
                                "Coerência geral do texto parcial gerado.",
                                "Documentação completa de passos e decisões.",
                                "Eficiência temporal dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística e análise de frequências.",
                                "Língua Portuguesa: Análise linguística e vocabulário frequente.",
                                "História: Criptografia em contextos militares (ex: Enigma).",
                                "Lógica e Resolução de Problemas: Iteração e depuração."
                              ],
                              "realWorldApplication": "Em segurança cibernética, analistas usam técnicas semelhantes para quebrar cifras simples em comunicações interceptadas; em forense digital, para decifrar mensagens em investigações criminais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Analisar limitações da técnica",
                            "description": "Discutir casos onde a análise falha, como textos curtos ou com distribuição atípica, e sugestões de melhorias como análise bigrama.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar limitações fundamentais da análise de frequência",
                                  "subSteps": [
                                    "Estude os pressupostos básicos da análise de frequência: texto longo, distribuição de letras similar à língua plaintext conhecida e cifra de substituição monoalfabética simples.",
                                    "Liste as principais limitações: dependência de amostras grandes, sensibilidade a variações linguísticas e ineficácia contra cifras polialfabéticas.",
                                    "Compare com frequências reais de letras em português (ex: E=12.6%, A=11.7%) para entender desvios.",
                                    "Registre em um quadro as suposições e suas violações potenciais.",
                                    "Discuta com um colega ou anote exemplos hipotéticos de falhas."
                                  ],
                                  "verification": "Lista completa de pelo menos 4 limitações fundamentais com explicações breves.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook, tabela de frequências de letras em português (impressa ou online), quadro branco ou app de notas.",
                                  "tips": "Comece pelos pressupostos para derivar limitações logicamente, evitando listas genéricas.",
                                  "learningObjective": "Compreender os fundamentos teóricos que limitam a análise de frequência.",
                                  "commonMistakes": "Confundir limitações com erros de implementação, como contagem manual incorreta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar casos específicos de falha",
                                  "subSteps": [
                                    "Selecione exemplos: texto curto (menos de 100 caracteres), distribuição atípica (ex: telegramas sem vogais comuns) e idiomas com morfologia diferente.",
                                    "Aplique análise de frequência a um texto criptografado curto e compare resultados com plaintext longo.",
                                    "Simule cenários: criptotexto com padding aleatório ou cifras com grupos de letras.",
                                    "Documente métricas de falha: desvio padrão alto nas frequências observadas vs. esperadas.",
                                    "Crie um relatório curto com gráficos de barras comparativos."
                                  ],
                                  "verification": "Relatório com 3 exemplos concretos de falha, incluindo dados numéricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Texto criptografado curto (gerado ou baixado), software de contagem de frequência (ex: Python ou Excel), calculadora.",
                                  "tips": "Use textos reais históricos, como mensagens de WWII curtas, para maior engajamento.",
                                  "learningObjective": "Reconhecer cenários práticos onde a técnica falha.",
                                  "commonMistakes": "Ignorar o impacto do tamanho da amostra, assumindo que 'qualquer texto' funciona."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar sugestões de melhorias e alternativas",
                                  "subSteps": [
                                    "Pesquise técnicas complementares: análise de bigramas/trigramas para capturar dependências.",
                                    "Discuta adaptações: normalização por tamanho de texto, uso de chi-quadrado para validação estatística.",
                                    "Teste uma melhoria: aplique análise de bigramas em um texto falho da etapa anterior.",
                                    "Avalie trade-offs: complexidade computacional vs. precisão.",
                                    "Liste 3-5 sugestões priorizadas por facilidade de implementação."
                                  ],
                                  "verification": "Lista de 4 sugestões com testes simples e resultados comparativos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Acesso à internet para tutoriais de bigramas, ferramenta de análise textual (ex: online frequency analyzer).",
                                  "tips": "Priorize melhorias simples como bigramas antes de métodos avançados.",
                                  "learningObjective": "Propor soluções práticas para superar limitações.",
                                  "commonMistakes": "Sugerir técnicas irrelevantes, como machine learning, sem contexto básico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar aplicação e mitigação das limitações",
                                  "subSteps": [
                                    "Crie um fluxograma de decisão: quando usar análise de frequência (texto longo >500 chars) vs. alternativas.",
                                    "Avalie cenários híbridos: combinar frequência com índices de coincidência.",
                                    "Redija um resumo executivo com recomendações.",
                                    "Autoavalie compreensão respondendo a perguntas de verificação.",
                                    "Compartilhe síntese em fórum ou discussão para feedback."
                                  ],
                                  "verification": "Fluxograma e resumo de 1 página com critérios de uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de fluxograma (ex: Draw.io, papel), resumo anterior.",
                                  "tips": "Use critérios quantitativos (ex: comprimento >300 chars) para decisões objetivas.",
                                  "learningObjective": "Integrar limitações em uma estratégia criptanalítica robusta.",
                                  "commonMistakes": "Superestimar a técnica, ignorando que 70% das falhas são por violações de pressupostos."
                                }
                              ],
                              "practicalExample": "Pegue um texto criptografado monoalfabético de 60 caracteres: 'XLMW MWXLMW...'. Aplique análise de frequência: a letra mais comum aparece 12% (esperado E=12.6%), mas variância alta leva a múltiplas chaves plausíveis. Com bigramas, nota padrões como 'TH' comuns, refinando a chave correta.",
                              "finalVerifications": [
                                "Lista e explica 5 limitações principais com exemplos.",
                                "Demonstra falha em texto curto com cálculo de frequência.",
                                "Propõe e testa pelo menos 2 melhorias (ex: bigramas).",
                                "Cria fluxograma de decisão para uso da técnica.",
                                "Avalia precisão em 3 cenários simulados.",
                                "Redige resumo com recomendações práticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações (25%)",
                                "Profundidade na análise de casos de falha com dados (25%)",
                                "Criatividade e viabilidade das sugestões de melhoria (20%)",
                                "Clareza do fluxograma e síntese (15%)",
                                "Uso correto de evidências quantitativas (10%)",
                                "Qualidade da documentação e exemplos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de qui-quadrado e distribuições de frequência",
                                "Linguística: Análise de padrões fonéticos e morfológicos em idiomas",
                                "Matemática: Probabilidade condicional em bigramas",
                                "História: Criptografia em guerras mundiais e limitações observadas"
                              ],
                              "realWorldApplication": "Em investigações cibernéticas, analistas da polícia usam isso para decidir se análise de frequência basta em mensagens interceptadas curtas de ransomware, optando por bigramas ou IA em casos atípicos, acelerando descriptografações em incidentes de segurança nacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Ataque por Texto Plano Conhecido",
                    "description": "Método que usa pares de texto plano e cifrado conhecidos para recuperar chaves ou padrões.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Princípio do Ataque por Texto Plano Conhecido (KPA)",
                        "description": "Fundamento teórico do método criptanalítico que explora pares conhecidos de texto plano (P) e texto cifrado (C) para derivar chaves ou padrões do algoritmo, conforme descrito em Schneier (2015) e Paar & Pelzl (2010).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir Ataque KPA",
                            "description": "Explicar o conceito de Known Plaintext Attack (KPA) como um modelo de ataque onde o criptoanalista possui acesso a múltiplos pares (P, C) e busca recuperar a chave secreta ou fraquezas no cifrador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Criptoanálise e Modelos de Ataque",
                                  "subSteps": [
                                    "Pesquise a definição de criptoanálise e seu papel na segurança de cifradores.",
                                    "Identifique e liste os principais modelos de ataque: ciphertext-only (COA), known-plaintext (KPA), chosen-plaintext (CPA) e chosen-ciphertext (CCA).",
                                    "Compare as premissas de cada modelo, destacando o que o atacante sabe.",
                                    "Crie um fluxograma ilustrando a hierarquia de dificuldade crescente dos ataques.",
                                    "Explique por que o modelo de ataque é crucial para avaliar cifradores."
                                  ],
                                  "verification": "Produza um fluxograma ou tabela comparativa dos modelos de ataque e explique verbalmente as diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook ou papel para fluxograma",
                                    "Acesso à internet para artigos introdutórios sobre criptoanálise",
                                    "Vídeo tutorial sobre modelos de ataque (ex: Khan Academy ou YouTube)"
                                  ],
                                  "tips": "Use analogias cotidianas, como 'adivinhar uma senha com pistas parciais', para fixar conceitos.",
                                  "learningObjective": "Compreender o contexto e a importância dos diferentes modelos de ataque na criptoanálise.",
                                  "commonMistakes": [
                                    "Confundir KPA com CPA (onde o atacante escolhe o plaintext)",
                                    "Subestimar a relevância das premissas do atacante",
                                    "Ignorar que COA é o mais fraco e CCA o mais forte"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Precisamente o Known Plaintext Attack (KPA)",
                                  "subSteps": [
                                    "Leia e memorize a definição: KPA ocorre quando o criptoanalista tem acesso a múltiplos pares plaintext-ciphertext (P, C) e visa recuperar a chave secreta ou detectar fraquezas no cifrador.",
                                    "Descreva as premissas exatas: P e C conhecidos, mas chave desconhecida; cifrador conhecido.",
                                    "Explique os objetivos principais: encontrar a chave ou provar insegurança do algoritmo.",
                                    "Diferencie KPA de outros ataques usando exemplos simples.",
                                    "Escreva a definição em suas próprias palavras, incluindo notação matemática básica (ex: E_k(P) = C)."
                                  ],
                                  "verification": "Escreva uma definição de KPA com premissas e objetivos, e recite sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência: Wikipedia ou livro 'Cryptography and Network Security' de Stallings (capítulo sobre criptoanálise)",
                                    "Notas de aula prévias sobre criptografia"
                                  ],
                                  "tips": "Use abreviações como 'KPA: pares (P,C) conhecidos → chave?' para memorização rápida.",
                                  "learningObjective": "Dominar a definição formal e as premissas do KPA.",
                                  "commonMistakes": [
                                    "Omitir 'múltiplos pares' na definição",
                                    "Confundir com ataques onde apenas um par é conhecido",
                                    "Esquecer que o cifrador é geralmente público"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Mecanismos e Exemplos do KPA",
                                  "subSteps": [
                                    "Analise como pares (P,C) permitem resolver para a chave em cifradores lineares (ex: cifra de Vigenère).",
                                    "Estude um exemplo clássico: quebra da cifra ADFGVX na WWI usando KPA.",
                                    "Simule manualmente um KPA simples com cifra de César: P='ATTACKATDAWN', C='KZZHCKK...' → encontre shift.",
                                    "Discuta limitações: KPA falha em cifradores modernos como AES se implementados corretamente.",
                                    "Registre equações ou passos algébricos usados na recuperação da chave."
                                  ],
                                  "verification": "Resolva um exemplo manual de KPA fornecido e explique cada passo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python REPL para simulações",
                                    "Exemplos impressos de cifras históricas",
                                    "Ferramenta online como CyberChef para cifragem rápida"
                                  ],
                                  "tips": "Comece com cifras fracas para ganhar confiança antes de exemplos complexos.",
                                  "learningObjective": "Aplicar o conceito de KPA em exemplos concretos para entender seu funcionamento.",
                                  "commonMistakes": [
                                    "Assumir que KPA sempre quebra qualquer cifrador",
                                    "Não considerar ruído ou padding nos pares (P,C)",
                                    "Ignorar que múltiplos pares aumentam a probabilidade de sucesso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Avaliar o KPA no Contexto Moderno",
                                  "subSteps": [
                                    "Compare KPA com ataques quânticos ou side-channel para contextualizar sua relevância hoje.",
                                    "Discuta defesas contra KPA: modos de operação como CBC, autenticação.",
                                    "Crie um resumo de 1 página: definição, exemplo, forças e fraquezas.",
                                    "Debata cenários onde KPA ainda é viável (ex: protocolos legados).",
                                    "Planeje uma implementação simples em código para testar KPA."
                                  ],
                                  "verification": "Apresente o resumo e responda a perguntas sobre defesas contra KPA.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para resumo",
                                    "Acesso a documentação de bibliotecas crypto como PyCryptodome",
                                    "Artigo sobre Enigma e KPA"
                                  ],
                                  "tips": "Ligue o KPA a notícias recentes de breaches para maior engajamento.",
                                  "learningObjective": "Integrar o KPA em um panorama mais amplo de criptoanálise e segurança.",
                                  "commonMistakes": [
                                    "Superestimar vulnerabilidade de cifradores modernos a KPA",
                                    "Não mencionar importância de chaves longas e aleatórias",
                                    "Confundir KPA com análise estatística pura"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma cifra de César usada em mensagens militares: Plaintext conhecido P = 'ATTACKATDAWN' resulta em C = 'KZZHCKK...' (shift=10). Com múltiplos pares como este, o analista testa shifts até E_k(P)=C para todos, recuperando k=10 e quebrando o cifrador para outras mensagens.",
                              "finalVerifications": [
                                "Defina KPA corretamente, incluindo premissas e objetivos, em menos de 1 minuto.",
                                "Explique a diferença entre KPA e CPA com um exemplo.",
                                "Resolva um KPA simples manualmente em uma cifra conhecida.",
                                "Liste 3 defesas contra KPA em sistemas modernos.",
                                "Crie um diagrama de um ataque KPA passo a passo.",
                                "Discuta um caso histórico real de KPA bem-sucedido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e premissas do KPA (30%)",
                                "Capacidade de diferenciar KPA de outros modelos de ataque (20%)",
                                "Qualidade de exemplos e simulações práticas (20%)",
                                "Compreensão de limitações e defesas (15%)",
                                "Clareza na comunicação e síntese do conceito (10%)",
                                "Criatividade em conexões com aplicações reais (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de sistemas de equações lineares para cifradores afins.",
                                "História: Análise de quebras criptográficas na Primeira e Segunda Guerra Mundial (Enigma, ADFGVX).",
                                "Programação: Implementação de KPA em Python usando bibliotecas como pycryptodome.",
                                "Probabilidade e Estatística: Análise de frequência em pares (P,C) para detecção de padrões.",
                                "Ética e Segurança: Discussão sobre implicações legais de criptoanálise em comunicações civis."
                              ],
                              "realWorldApplication": "O KPA foi crucial na quebra do código Enigma pelos Aliados na WWII, permitindo ler comunicações nazistas; hoje, é usado em forense digital para descriptografar malware ou tráfego de rede com plaintexts conhecidos como cabeçalhos HTTP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Identificar Modelo de Ataque KPA",
                            "description": "Diferenciar o KPA de outros modelos como ciphertext-only ou chosen plaintext, destacando que em KPA o texto plano é conhecido de fontes como cabeçalhos de protocolos (ex: HTTP headers).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Básica do Ataque KPA",
                                  "subSteps": [
                                    "Leia a definição oficial de Known Plaintext Attack (KPA): um ataque onde o atacante conhece pares de texto plano e texto cifrado correspondentes.",
                                    "Identifique os elementos chave: texto plano conhecido (plaintext) e seu ciphertext equivalente.",
                                    "Anote exemplos iniciais de texto plano previsível, como padrões fixos em protocolos.",
                                    "Resuma em suas palavras o que diferencia KPA de ataques sem conhecimento prévio.",
                                    "Crie um diagrama simples mostrando entrada (plaintext conhecido) e saída (ciphertext capturado)."
                                  ],
                                  "verification": "Você pode explicar KPA em 1-2 frases sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de criptoanálise básica (Wikipedia ou textbook PDF)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias cotidianas, como conhecer a mensagem original de uma carta cifrada simples.",
                                  "learningObjective": "Definir precisamente o modelo de ataque KPA e seus componentes essenciais.",
                                  "commonMistakes": [
                                    "Confundir KPA com ataques onde plaintext é escolhido pelo atacante (CPA)",
                                    "Ignorar que plaintext deve ser conhecido de antemão, não gerado."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar KPA com Outros Modelos de Ataque",
                                  "subSteps": [
                                    "Estude Ciphertext-Only Attack (COA): apenas ciphertext disponível, sem plaintext conhecido.",
                                    "Analise Chosen Plaintext Attack (CPA): atacante escolhe plaintext e obtém ciphertext.",
                                    "Crie uma tabela comparativa: colunas para COA, KPA, CPA; linhas para requisitos, força e exemplos.",
                                    "Destaque fraquezas: KPA é mais forte que COA por ter pares conhecidos.",
                                    "Teste compreensão respondendo: 'Por que KPA é viável em protocolos padronizados?'."
                                  ],
                                  "verification": "Complete a tabela comparativa sem erros e explique diferenças oralmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em branco (Google Sheets ou papel)",
                                    "Referências: artigos sobre modelos de criptoanálise"
                                  ],
                                  "tips": "Use cores na tabela para destacar similaridades e diferenças visuais.",
                                  "learningObjective": "Diferenciar KPA de COA e CPA com base em suposições do atacante.",
                                  "commonMistakes": [
                                    "Misturar KPA com CPA, achando que plaintext é 'escolhido' em vez de 'conhecido'",
                                    "Subestimar a importância do plaintext ser naturalmente disponível."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Fontes de Texto Plano Conhecido em Protocolos",
                                  "subSteps": [
                                    "Liste fontes comuns: cabeçalhos HTTP (ex: 'GET / HTTP/1.1'), campos fixos em TLS, IVs previsíveis.",
                                    "Analise um exemplo real: capture tráfego Wireshark com HTTPS e note headers plaintext em negociações.",
                                    "Classifique cenários: quando headers são conhecidos vs. quando são escolhidos.",
                                    "Simule: dado um ciphertext de header HTTP conhecido, identifique como KPA se aplica.",
                                    "Documente 3 fontes reais de plaintext em protocolos modernos."
                                  ],
                                  "verification": "Liste 3 fontes válidas de plaintext conhecido com exemplos específicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark (ferramenta gratuita)",
                                    "Amostras de pacotes HTTP/TLS capturados"
                                  ],
                                  "tips": "Foquem em protocolos legados ou mal implementados onde padrões são fixos.",
                                  "learningObjective": "Reconhecer fontes práticas de plaintext conhecido, como headers de protocolos.",
                                  "commonMistakes": [
                                    "Assumir que todo tráfego é plaintext desconhecido",
                                    "Confundir headers negociados com headers fixos/padrão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Diferenciação em Cenários",
                                  "subSteps": [
                                    "Resolva 3 cenários hipotéticos: um COA, um KPA, um CPA; classifique cada um.",
                                    "Em um exercício hands-on, dado um par plaintext/ciphertext de HTTP header, confirme KPA.",
                                    "Crie seu próprio exemplo de KPA usando cifra simples (ex: Caesar com header conhecido).",
                                    "Avalie: 'Este cenário é KPA? Por quê?' para casos mistos.",
                                    "Revise erros e reforce diferenças chave."
                                  ],
                                  "verification": "Classifique corretamente 5 cenários de teste fornecidos ou auto-criados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online (ex: CryptoPals challenges)",
                                    "Ferramenta de cifra online simples"
                                  ],
                                  "tips": "Comece com exemplos simples antes de protocolos reais para construir confiança.",
                                  "learningObjective": "Aplicar identificação de KPA em cenários reais e hipotéticos com precisão.",
                                  "commonMistakes": [
                                    "Classificar incorretamente cenários com plaintext parcial como não-KPA",
                                    "Ignorar contexto de protocolos na diferenciação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ataque a um servidor web usando HTTPS fraco, o atacante captura tráfego e conhece o header HTTP padrão 'GET /index.html HTTP/1.1\\r\\nHost: example.com\\r\\n'. Com o ciphertext correspondente, aplica KPA para recuperar a chave de sessão, diferenciando de COA (sem header conhecido) ou CPA (sem escolha pelo atacante).",
                              "finalVerifications": [
                                "Defina KPA corretamente, incluindo plaintext de fontes como headers.",
                                "Diferencie KPA de COA e CPA em uma tabela comparativa.",
                                "Identifique 3 fontes reais de plaintext conhecido em protocolos.",
                                "Classifique 5 cenários como KPA ou não-KPA com justificativa.",
                                "Explique por que KPA é relevante em criptoanálise moderna.",
                                "Crie um exemplo pessoal de KPA válido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e componentes de KPA (80%+ correto).",
                                "Correta diferenciação de outros modelos (COA/CPA) sem confusões.",
                                "Identificação relevante de fontes de plaintext (ex: protocolos).",
                                "Qualidade de exemplos práticos e cenários simulados.",
                                "Compreensão demonstrada em verificações finais (sem erros comuns).",
                                "Uso de diagramas/tabelas para clareza visual."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise de protocolos como HTTP/TLS.",
                                "Matemática: Probabilidade e estatística em padrões de texto.",
                                "Segurança da Informação: Implicações em cibersegurança prática.",
                                "Programação: Scripts para captura e análise de tráfego (Python/Wireshark).",
                                "História da Computação: Evolução de ataques criptográficos."
                              ],
                              "realWorldApplication": "Na cibersegurança, KPA é usado para quebrar criptografia em malwares que usam chaves fracas com payloads conhecidos, ou em forense digital para decifrar comunicações com headers padrão, ajudando agências como NSA ou empresas de segurança a mitigar vazamentos em protocolos legados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Explicar Assunções do KPA",
                            "description": "Descrever as premissas necessárias para um KPA bem-sucedido, incluindo repetibilidade do cifrador e disponibilidade de pares suficientes, com referência a Menezes (1996).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição e Contexto do Ataque por Texto Plano Conhecido (KPA)",
                                  "subSteps": [
                                    "Leia a definição de KPA de fontes confiáveis, como Menezes (1996).",
                                    "Identifique o papel do atacante: acesso parcial a plaintexts e ciphertexts.",
                                    "Anote o objetivo do KPA: recuperar a chave ou descriptografar mensagens adicionais.",
                                    "Compare KPA com outros ataques (ex: ciphertext-only) para contextualizar assunções.",
                                    "Registre diferenças entre cenários ideais e reais."
                                  ],
                                  "verification": "Resuma em 3-5 frases o que é KPA e por que assunções são necessárias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Handbook of Applied Cryptography (Menezes, 1996) - Capítulo 1 ou seção relevante",
                                    "Notas de aula sobre criptoanálise básica"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de ataque: plaintext conhecido → ciphertext → chave derivada.",
                                  "learningObjective": "Compreender o contexto fundamental do KPA para identificar premissas corretas.",
                                  "commonMistakes": [
                                    "Confundir KPA com ataques que requerem chave parcial",
                                    "Ignorar que KPA é passivo e não altera mensagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a Assunção de Pares Plaintext-Ciphertext Suficientes e Conhecidos",
                                  "subSteps": [
                                    "Defina 'pares conhecidos': attacker sabe P e C para o mesmo cifrador.",
                                    "Discuta 'suficiência': número mínimo de pares depende do algoritmo (ex: 10-100 para cifras simples).",
                                    "Exemplifique com cifras monoalfabéticas: 25-50 pares para quebrar.",
                                    "Calcule exemplos: probabilidade de sucesso com N pares.",
                                    "Relacione com disponibilidade: fontes como cabeçalhos de protocolos ou mensagens padronizadas."
                                  ],
                                  "verification": "Liste 3 fontes reais de pares conhecidos e justifique por que são 'suficientes'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de protocolos como HTTP headers",
                                    "Ferramenta de simulação de cifras (ex: CrypTool)"
                                  ],
                                  "tips": "Pense em tráfego de rede: headers fixos fornecem plaintexts previsíveis.",
                                  "learningObjective": "Dominar a premissa central de dados conhecidos no KPA.",
                                  "commonMistakes": [
                                    "Assumir que um par é suficiente",
                                    "Confundir com chosen plaintext"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar a Assunção de Repetibilidade do Cifrador (Determinismo)",
                                  "subSteps": [
                                    "Explique determinismo: mesma plaintext + chave → mesma ciphertext sempre.",
                                    "Contraste com cifradores probabilísticos (ex: CBC mode com IV randômico).",
                                    "Discuta impactos: sem repetibilidade, pares múltiplos perdem utilidade.",
                                    "Cite Menezes (1996): assunção explícita para ataques conhecidos.",
                                    "Teste conceitualmente: simule cifrador não-determinístico e observe falha no KPA."
                                  ],
                                  "verification": "Descreva um contraexemplo onde falta de repetibilidade invalida KPA.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Capítulo 7 de Menezes (1996) sobre modos de operação",
                                    "Simulador Python simples para cifras"
                                  ],
                                  "tips": "Lembre: modos como ECB são determinísticos; use para testes.",
                                  "learningObjective": "Entender por que o cifrador deve ser não-estocástico para KPA funcionar.",
                                  "commonMistakes": [
                                    "Confundir repetibilidade com reversibilidade",
                                    "Ignorar IVs em cifras modernas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Todas as Assunções e Referenciar Menezes (1996)",
                                  "subSteps": [
                                    "Liste as 3 assunções principais: pares suficientes, repetibilidade, algoritmo vulnerável.",
                                    "Extraia citações diretas de Menezes sobre KPA.",
                                    "Discuta limitações: KPA falha em cifras modernas como AES-GCM.",
                                    "Crie um fluxograma das assunções para sucesso do KPA.",
                                    "Prepare explicação oral ou escrita integrando tudo."
                                  ],
                                  "verification": "Escreva um parágrafo explicando assunções com referência precisa a Menezes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "PDF ou cópia de Menezes (1996)",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use bullet points para assunções; memorize página da referência.",
                                  "learningObjective": "Integrar assunções em uma explicação coesa e referenciada.",
                                  "commonMistakes": [
                                    "Omitir referência bibliográfica",
                                    "Listar assunções irrelevantes como 'chave fraca'"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cenário de interceptação de mensagens Enigma na WWII, os Aliados conheciam plaintexts repetitivos como 'WETTERBERICHT' (relatórios meteorológicos) e seus ciphertexts correspondentes. Com repetibilidade da máquina Enigma (determinística para configurações fixas) e pares suficientes (dezenas por dia), aplicaram KPA para mapear rotores e quebrar códigos diários, conforme documentado em histórias criptográficas.",
                              "finalVerifications": [
                                "Liste verbalmente as três assunções principais do KPA com exemplos.",
                                "Explique por que repetibilidade é crucial, citando um contraexemplo.",
                                "Identifique fontes reais de pares plaintext-ciphertext em protocolos modernos.",
                                "Resuma a posição de Menezes (1996) sobre assunções do KPA.",
                                "Crie um diagrama simples mostrando fluxo de assunções para sucesso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pares conhecidos e suficiência (peso: 25%).",
                                "Explicação clara de repetibilidade/determinismo com exemplos (peso: 25%).",
                                "Referência correta e contextual a Menezes (1996) (peso: 20%).",
                                "Integração de assunções em narrativa coesa (peso: 15%).",
                                "Uso de exemplos práticos e verificações lógicas (peso: 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de conjuntos de dados pareados (pares P-C).",
                                "História: Aplicações em criptografia de guerra (Enigma, WWII).",
                                "Matemática: Equações de frequência e probabilidades em cifras.",
                                "Segurança da Informação: Avaliação de vulnerabilidades modernas."
                              ],
                              "realWorldApplication": "Na cibersegurança atual, analistas usam KPA para quebrar cifras fracas em malwares ou tráfego de IoT, onde headers padronizados fornecem plaintexts conhecidos e repetitivos, permitindo recuperação de chaves e mitigação de ataques em tempo real."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Exemplos Clássicos de Ataques KPA",
                        "description": "Aplicações históricas do KPA em cifras simétricas como Vigenère e DES, ilustrando como pares conhecidos revelam padrões repetitivos ou chaves parciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Analisar KPA na Cifra de Vigenère",
                            "description": "Demonstrar como usar pares (P, C) conhecidos para resolver equações modulares e recuperar a chave polialfabética, simulando com exemplos manuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Mecanismo de Encriptação da Cifra de Vigenère",
                                  "subSteps": [
                                    "Revise a fórmula básica: C_i = (P_i + K_{(i mod len(K))}) mod 26, onde letras são mapeadas para 0-25 (A=0, B=1, ..., Z=25).",
                                    "Estude como a chave é repetida ciclicamente para coincidir com o comprimento do texto plano.",
                                    "Pratique convertendo letras para números e vice-versa usando uma tabela modular.",
                                    "Identifique que em KPA, rearranjando para K_j = (C_i - P_i) mod 26 para posições i onde i mod len(K) = j.",
                                    "Anote exemplos simples de encriptação manual com chave curta."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula invertida para recuperar K a partir de um par (P,C) único.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela alfabética A-Z (0-25)",
                                    "Calculadora para operações mod 26"
                                  ],
                                  "tips": "Sempre subtraia P de C e aplique mod 26 para shifts positivos; use A=0 como referência.",
                                  "learningObjective": "Dominar a matemática modular subjacente à Vigenère e sua inversão para KPA.",
                                  "commonMistakes": [
                                    "Esquecer o mod 26, resultando em números negativos ou >25",
                                    "Confundir índices de posição (0-based vs 1-based)",
                                    "Não mapear corretamente letras para números"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Alinhar Pares de Texto Plano Conhecido (P) e Cifra (C)",
                                  "subSteps": [
                                    "Colete múltiplos pares (P, C) alinhados, garantindo que tenham pelo menos o comprimento da chave suspeita.",
                                    "Converta todos os caracteres de P e C para valores numéricos (A=0, etc.).",
                                    "Calcule shifts parciais S_i = (C_i - P_i) mod 26 para cada posição i.",
                                    "Registre os shifts em uma tabela por posição, destacando repetições para offsets da chave.",
                                    "Assuma ou estime o comprimento da chave L (ex: via exame de repetições ou Kasiski se necessário)."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 10 shifts calculados corretamente de um exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para tabelas",
                                    "Exemplo de pares P/C impresso ou anotado",
                                    "Tabela modular"
                                  ],
                                  "tips": "Alinhe P e C caractere por caractere; ignore espaços ou use apenas maiúsculas.",
                                  "learningObjective": "Preparar dados de KPA de forma precisa para análise modular.",
                                  "commonMistakes": [
                                    "Misalignment de P e C",
                                    "Erros de conversão letra-número (ex: confundir maiúsculas/minúsculas)",
                                    "Não normalizar shifts para 0-25"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Recuperar Componentes da Chave por Posição Modular",
                                  "subSteps": [
                                    "Para cada posição j de 0 a L-1, colete todos S_i onde i mod L = j.",
                                    "Verifique consistência: shifts para mesma j devem ser iguais (ou vote pela maioria se ruído).",
                                    "Atribua K_j = shift mais frequente para posição j.",
                                    "Converta K_j de volta para letra (0=A, etc.).",
                                    "Registre a chave candidata como sequência de letras recuperadas."
                                  ],
                                  "verification": "Demonstre recuperação de pelo menos 3 letras de chave de shifts agrupados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de shifts do Step 2",
                                    "Folha para agrupamento por mod L",
                                    "Chave de verificação parcial"
                                  ],
                                  "tips": "Comece com L pequeno (3-7); use frequência para resolver ambiguidades.",
                                  "learningObjective": "Agrupar e resolver equações modulares por offset da chave polialfabética.",
                                  "commonMistakes": [
                                    "Cálculo errado de i mod L",
                                    "Ignorar variações em shifts (devem ser idênticos)",
                                    "Não converter números de volta para letras coerentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Chave e Simular Descriptografia Completa",
                                  "subSteps": [
                                    "Aplique a chave recuperada para descriptografar um texto cifra mais longo: P_i = (C_i - K_{(i mod L)}) mod 26.",
                                    "Converta resultados numéricos para texto legível e cheque por palavras sensatas.",
                                    "Compare com texto plano conhecido adicional para validar.",
                                    "Ajuste L ou chave se necessário e reitere.",
                                    "Documente o processo completo com antes/depois."
                                  ],
                                  "verification": "Descriptografe com sucesso um texto teste produzindo texto plano inteligível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto cifra longo para teste",
                                    "Chave recuperada do Step 3",
                                    "Tabela alfabética"
                                  ],
                                  "tips": "Teste com trechos conhecidos primeiro; chave correta produz inglês legível.",
                                  "learningObjective": "Validar a chave via descriptografia e iterar se falhar.",
                                  "commonMistakes": [
                                    "Erro na subtração modular na descriptografia",
                                    "Não iterar L se verificação falhar",
                                    "Aceitar texto gibberish como válido"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: Chave secreta 'LEMON' (L=4, shifts: L=11,E=4,M=12,O=14,N=13). Pares conhecidos: P='ATTACKATDAWN' (0,19,19,0,2,10,0,19,3,0,23,0,13), C='LFDSEARLYMG' (shifts calculados: 11,0,0,0,0,4,19,0,0,0,0,0 → agrupado por mod4: pos0=L(11), pos1=E(4), pos2=M(12? ajuste exemplo), pos3=O(14? via múltiplos). Recupere 'LEMO' e estenda para 'LEMON'. Descriptografe C='LFDSEARLYMGFU' → 'ATTACKATDAWNAX'.",
                              "finalVerifications": [
                                "Recupere corretamente a chave de um exemplo com L=5 usando 20+ pares.",
                                "Descriptografe texto adicional com 95%+ de precisão sem erros modulares.",
                                "Explique o processo em 1 minuto sem consultar notas.",
                                "Identifique e corrija um erro introduzido em shifts dados.",
                                "Gere shifts consistentes para uma chave inventada e inverta.",
                                "Aplique a pares com ruído leve (1 erro) e resolva via votação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos modulares (100% correto).",
                                "Capacidade de agrupar shifts por posição chave corretamente.",
                                "Validação bem-sucedida via descriptografia legível.",
                                "Documentação clara de tabelas e passos.",
                                "Tempo de execução dentro de 2 horas totais.",
                                "Explicação oral fluida do método KPA."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números.",
                                "História: Criptografia na Segunda Guerra Mundial (máquinas Enigma semelhantes).",
                                "Linguística: Análise de frequência e padrões textuais.",
                                "Programação: Implementação em Python para automação (ex: ord(), chr())."
                              ],
                              "realWorldApplication": "Em cibersegurança, KPA é usado para quebrar cifras fracas em comunicações antigas ou mal implementadas, como em análise forense de dados criptografados em investigações ou recuperação de chaves em protocolos legados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Aplicar KPA em Cifras de Substituição Simples",
                            "description": "Executar um ataque KPA em cifra de César ou monoalfabética, identificando deslocamentos via frequência de letras conhecidas no texto plano.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Textos Plano Conhecido e Cifrado",
                                  "subSteps": [
                                    "Obtenha o fragmento de texto plano conhecido (ex: início de mensagem padrão).",
                                    "Obtenha o texto cifrado correspondente da mesma posição.",
                                    "Alinhe os textos caractere por caractere para identificar pares exatos.",
                                    "Liste todas as letras únicas do texto plano e suas posições.",
                                    "Ignore espaços, pontuação e foque apenas em letras (normalizar para maiúsculas)."
                                  ],
                                  "verification": "Textos alinhados com comprimento idêntico e pares iniciais listados sem desalinhamentos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, exemplos de texto plano e cifrado fornecidos",
                                  "tips": "Use uma tabela de duas colunas para alinhamento visual rápido.",
                                  "learningObjective": "Preparar dados precisos para mapeamento de letras.",
                                  "commonMistakes": "Desalinhar textos por ignorar comprimento ou espaços; não normalizar case."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Pares de Letras Correspondentes",
                                  "subSteps": [
                                    "Para cada letra no texto plano, anote a letra equivalente no texto cifrado.",
                                    "Crie uma lista de pares únicos (ex: P: 'H' -> C: 'K').",
                                    "Verifique consistência: mesma letra plano sempre mapeia para mesma cifrada.",
                                    "Identifique letras comuns como 'E', 'T', 'A' para priorizar.",
                                    "Registre qualquer inconsistência como possível erro nos dados."
                                  ],
                                  "verification": "Lista de 3-5 pares únicos sem contradições detectadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de mapeamento em papel ou planilha simples",
                                  "tips": "Comece pelos pares mais frequentes para confiança inicial.",
                                  "learningObjective": "Estabelecer correspondências diretas entre alfabeto plano e cifrado.",
                                  "commonMistakes": "Duplicar pares inconsistentes ou ignorar letras repetidas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Deslocamento para Cifra de César ou Tabela Simples",
                                  "subSteps": [
                                    "Para César: Calcule shift = (posição C - posição P) mod 26 (A=0, B=1...).",
                                    "Valide o shift com todos os pares conhecidos.",
                                    "Para monoalfabética simples: Construa tabela parcial de substituição.",
                                    "Teste shift/tabela em fragmento conhecido para confirmação.",
                                    "Ajuste se necessário com base em múltiplos pares."
                                  ],
                                  "verification": "Shift único (ex: 3) consistente em 100% dos pares ou tabela sem conflitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Alfabeto numerado (A=0 a Z=25), calculadora para operações modulares",
                                  "tips": "Use fórmula shift = (C - P + 26) % 26 para evitar negativos.",
                                  "learningObjective": "Derivar a chave de descriptografia a partir de pares conhecidos.",
                                  "commonMistakes": "Esquecer módulo 26 levando a shifts inválidos; testar apenas um par."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Descriptografia e Validar Resultado",
                                  "subSteps": [
                                    "Aplique shift inverso (-shift mod 26) ou tabela inversa ao texto cifrado completo.",
                                    "Escreva o texto plano resultante caractere por caractere.",
                                    "Compare com partes conhecidas para matching perfeito.",
                                    "Leia o texto inteiro para verificar legibilidade e sentido.",
                                    "Documente o processo com shift/tabela usada."
                                  ],
                                  "verification": "Texto descriptografado legível, matches known plaintext e sem anomalias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Texto cifrado completo, tabela de shift/tabela",
                                  "tips": "Descriptografe em blocos pequenos para minimizar erros de transcrição.",
                                  "learningObjective": "Executar descriptografia completa usando KPA.",
                                  "commonMistakes": "Aplicar shift positivo em vez de negativo; erros de transcrição."
                                }
                              ],
                              "practicalExample": "Texto plano conhecido: 'HELLO WORLD'. Texto cifrado correspondente: 'KHOOR ZRUOG' (César shift 3). Pares: H->K (7→10, shift=3), E->H (4→7, shift=3). Aplique shift -3: K(10)-3=7(H), resulta em 'HELLO WORLD' completo.",
                              "finalVerifications": [
                                "Todos os pares conhecidos mapeiam corretamente no resultado.",
                                "Texto descriptografado é legível e faz sentido contextual.",
                                "Shift ou tabela é consistente em todo o alfabeto testado.",
                                "Nenhuma inconsistência ou erro de cálculo detectado.",
                                "Processo documentado com pares e shift explicados.",
                                "Cobertura de pelo menos 70% do texto cifrado sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e alinhamento de pares (100% correto).",
                                "Cálculo exato do shift ou tabela sem erros modulares.",
                                "Descriptografia completa e válida do texto inteiro.",
                                "Detecção e explicação de qualquer inconsistência nos dados.",
                                "Documentação clara do processo passo a passo.",
                                "Tempo de execução eficiente com verificações intermediárias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e operações em Z/26Z.",
                                "Linguística: Frequência de letras em idiomas naturais.",
                                "História: Criptografia romana (César) e evolução de cifras.",
                                "Informática: Implementação algorítmica de descriptografia."
                              ],
                              "realWorldApplication": "Em cibersegurança, KPA quebra cifras fracas quando plaintext parcial é conhecido (ex: cabeçalhos HTTP, assinaturas de emails), essencial em forense digital e análise de malwares com payloads previsíveis."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Estudar KPA no DES",
                            "description": "Explicar vulnerabilidades do DES a KPA com textos planos padronizados (ex: ECB mode), usando tabelas de busca pré-computadas para subchaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o funcionamento básico do DES e o modo ECB",
                                  "subSteps": [
                                    "Estude a estrutura do DES: 16 rodadas de Feistel com expansão, S-boxes e permutações.",
                                    "Revise o modo ECB: cada bloco de plaintext é criptografado independentemente com a mesma chave.",
                                    "Identifique como ECB revela padrões no ciphertext se plaintexts padronizados forem usados.",
                                    "Analise por que ECB não ofusca repetições de blocos iguais.",
                                    "Desenhe um diagrama simples do processo DES-ECB."
                                  ],
                                  "verification": "Desenhe e explique um diagrama do DES-ECB com 3 blocos de plaintext idênticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do DES (FIPS 46-3)",
                                    "Papel e caneta para diagramas",
                                    "Vídeo tutorial sobre DES no YouTube"
                                  ],
                                  "tips": "Comece com um overview visual; foque em como subchaves são derivadas da chave principal.",
                                  "learningObjective": "Entender a arquitetura do DES e vulnerabilidades introduzidas pelo modo ECB.",
                                  "commonMistakes": "Confundir ECB com CBC; ignorar que DES usa 64-bit blocks com 56-bit key."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender os conceitos de Known Plaintext Attack (KPA)",
                                  "subSteps": [
                                    "Defina KPA: atacante conhece pares plaintext-ciphertext e visa recuperar a chave.",
                                    "Compare com outros ataques (CPA, CCA) para contextualizar.",
                                    "Explique por que DES é suscetível: chave curta (56 bits) e estrutura Feistel previsível.",
                                    "Discuta pré-requisitos: acesso a plaintexts padronizados como all-zeros ou padrões PNG.",
                                    "Liste vantagens do KPA em cifras block como DES."
                                  ],
                                  "verification": "Escreva uma definição de KPA e liste 3 razões da vulnerabilidade do DES.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo 'Known-plaintext attack' na Wikipedia",
                                    "Slides sobre criptoanálise básica"
                                  ],
                                  "tips": "Use analogias: como um cofre com combinação curta onde você vê entradas/saídas.",
                                  "learningObjective": "Dominar os princípios teóricos do KPA e sua aplicabilidade ao DES.",
                                  "commonMistakes": "Achar que KPA requer plaintext completo; na verdade, blocos suficientes bastam."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e usar textos planos padronizados em ECB",
                                  "subSteps": [
                                    "Liste padrões comuns: all-zero blocks, PNG headers, ou arquivos padronizados.",
                                    "Simule criptografia ECB com plaintext padronizado usando ferramenta online.",
                                    "Observe padrões no ciphertext: blocos idênticos para plaintexts idênticos.",
                                    "Colete pares (plaintext conhecido, ciphertext) de um exemplo DES-ECB.",
                                    "Documente 4-5 pares de blocos para análise."
                                  ],
                                  "verification": "Gere e liste 3 pares plaintext-ciphertext de um padrão ECB.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta online DES encryptor (ex: CyberChef)",
                                    "Arquivo de teste PNG para padrões"
                                  ],
                                  "tips": "Use CyberChef para criptografar rapidamente sem codar.",
                                  "learningObjective": "Reconhecer como padrões ECB facilitam KPA no DES.",
                                  "commonMistakes": "Usar modos não-ECB; não alinhar blocos de 64 bits corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar tabelas de busca pré-computadas para recuperar subchaves",
                                  "subSteps": [
                                    "Entenda tabelas rainbow/time-memory trade-off para subchaves DES (16 subchaves de 48 bits).",
                                    "Use uma tabela pré-computada para matching de pares plaintext-ciphertext na primeira rodada.",
                                    "Recupere subchaves sequencialmente: comece pela rodada 1, avance par-a-par.",
                                    "Combine subchaves para derivar a chave mestra DES.",
                                    "Verifique descriptografando um novo ciphertext com a chave recuperada."
                                  ],
                                  "verification": "Recupere uma subchave de exemplo e valide descriptografando um bloco.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "Tabelas pré-computadas DES KPA (disponíveis em repositórios GitHub)",
                                    "Script Python simples para lookup",
                                    "Calculadora hex/binária"
                                  ],
                                  "tips": "Baixe tabelas prontas; foque em rodadas iniciais onde ataques são mais viáveis.",
                                  "learningObjective": "Executar KPA prático no DES usando lookups pré-computados.",
                                  "commonMistakes": "Ignorar paridade da chave DES; confundir subchave com chave full."
                                }
                              ],
                              "practicalExample": "Considere um ciphertext DES-ECB de um arquivo PNG: primeiros blocos são headers padronizados (ex: 89 50 4E 47 0D 0A 1A 0A). Com tabelas rainbow para rodada 1, match o output da expansão/permutação com ciphertext, recuperando subchave1 em segundos. Prossiga para rodadas subsequentes, obtendo a chave full em minutos.",
                              "finalVerifications": [
                                "Explicar verbalmente a vulnerabilidade ECB-KPA no DES.",
                                "Listar 3 textos planos padronizados úteis para KPA.",
                                "Demonstrar recuperação de pelo menos 2 subchaves com tabela.",
                                "Descriptografar um bloco teste com chave recuperada.",
                                "Discutir limitações: DES3 não é tão vulnerável.",
                                "Comparar tempo de ataque vs brute-force."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do processo DES e ECB (80%+ correção).",
                                "Número e qualidade de pares plaintext-ciphertext coletados.",
                                "Correção na recuperação de subchaves via tabelas.",
                                "Clareza na explicação de erros comuns evitados.",
                                "Profundidade da análise de vulnerabilidades.",
                                "Criatividade em exemplos práticos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise, XOR e funções de permutação.",
                                "História da Computação: Evolução do DES para AES.",
                                "Segurança da Informação: Princípios de design criptográfico moderno.",
                                "Programação: Implementação de lookups em Python ou C."
                              ],
                              "realWorldApplication": "Em forensics digitais, recuperar chaves DES de tráfego antigo em ECB (ex: comunicações legadas em bancos ou governos pré-2000), ou analisar vazamentos onde padrões como HTTP headers são conhecidos, demonstrando por que DES foi depreciado pelo NIST em 2005."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Recuperação de Chaves e Contra-medidas",
                        "description": "Técnicas para extrair chaves via KPA em criptosistemas simétricos e públicos, além de estratégias de mitigação como modos de operação seguros (Paar & Pelzl, 2010).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Derivar Chaves de Pares (P, C)",
                            "description": "Implementar algoritmo para resolver E(P, K) = C e encontrar K, usando XOR em cifras de fluxo ou brute-force em cifras de bloco curtas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio de Derivação de Chaves com Pares (P, C)",
                                  "subSteps": [
                                    "Estude a definição de E(P, K) = C, onde E é a função de encriptação.",
                                    "Revise operações bitwise XOR para cifras de fluxo.",
                                    "Analise brute-force para cifras de bloco com chaves curtas (ex: 8-16 bits).",
                                    "Identifique pré-requisitos: conhecimento de Python ou linguagem similar para implementação.",
                                    "Colete exemplos simples de pares (P, C) para prática."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como K = P XOR C para cifras de fluxo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de XOR bitwise",
                                    "Notebook Jupyter ou editor de código",
                                    "Exemplos de pares (P, C)"
                                  ],
                                  "tips": "Comece com XOR manual em papel para blocos pequenos antes de codificar.",
                                  "learningObjective": "Entender matematicamente como derivar K de pares conhecidos (P, C).",
                                  "commonMistakes": "Confundir XOR com outras operações como adição modular; ignorar padding em blocos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Recuperação de Chave via XOR para Cifras de Fluxo",
                                  "subSteps": [
                                    "Escreva função para encriptar: def encrypt(p, k): return bytes([a ^ b for a,b in zip(p,k)])",
                                    "Implemente descriptografia conhecida: def derive_key(p, c): return bytes([a ^ b for a,b in zip(p,c)])",
                                    "Teste com P = b'hello', assumindo keystream repetido ou conhecido.",
                                    "Adapte para keystreams periódicos (ex: RC4-like simples).",
                                    "Valide com múltiplos pares (P1,C1), (P2,C2) para keystream longo."
                                  ],
                                  "verification": "Função derive_key retorna K correto que re-encripta P para C.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3 com biblioteca bytes",
                                    "Exemplos de cifras de fluxo como Vigenère adaptado para bytes"
                                  ],
                                  "tips": "Use zip_longest para keystreams mais longos que P.",
                                  "learningObjective": "Codificar algoritmo XOR-based para recuperar keystream/chave diretamente.",
                                  "commonMistakes": "Não converter strings para bytes corretamente; esquecer de alinhar comprimentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Brute-Force para Cifras de Bloco com Chaves Curtas",
                                  "subSteps": [
                                    "Defina cifra de bloco simples (ex: ECB com XOR por bloco de 8 bytes).",
                                    "Gere todas chaves possíveis (ex: 2^16 = 65536 chaves).",
                                    "Para cada K candidato, verifique se encrypt(P, K) == C.",
                                    "Otimize com paralelismo ou early-stop ao encontrar match.",
                                    "Registre tempo de execução para análise de viabilidade."
                                  ],
                                  "verification": "Script encontra K correta em <1 segundo para chaves de 16 bits.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com itertools.product para brute-force",
                                    "Relógio de tempo (timeit)"
                                  ],
                                  "tips": "Comece com chave de 8 bits para testar velocidade antes de escalar.",
                                  "learningObjective": "Aplicar busca exaustiva para recuperar chaves curtas em blocos.",
                                  "commonMistakes": "Implementar modo CBC em vez de ECB; overflow em loops grandes sem otimização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Implementações e Analisar Limitações",
                                  "subSteps": [
                                    "Crie conjunto de testes: 5 pares (P,C) variados.",
                                    "Execute derivação XOR e brute-force, compare resultados.",
                                    "Meça precisão, tempo e escalabilidade (ex: 24 bits viável?).",
                                    "Documente casos falha (ex: keystream não periódico).",
                                    "Discuta contra-medidas como chaves longas ou IVs."
                                  ],
                                  "verification": "Todos testes passam com 100% acurácia e relatório de performance.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Script de testes unitários (unittest ou pytest)",
                                    "Gráficos de tempo vs tamanho chave"
                                  ],
                                  "tips": "Use logging para rastrear chaves testadas em brute-force.",
                                  "learningObjective": "Validar robustez das implementações e identificar limites práticos.",
                                  "commonMistakes": "Testes insuficientes; ignorar endianness em inteiros."
                                }
                              ],
                              "practicalExample": "Dado P = b'Attack at dawn' e C = b'Miijfx vflhr', usando cifra de fluxo XOR com keystream repetido de 5 bytes. Derive keystream K = b'Hello' rodando XOR byte-a-byte: primeiro byte 'A'^'M' = 'H', etc. Para bloco: P bloco de 4 bytes, brute-force 16-bit K até match.",
                              "finalVerifications": [
                                "Função XOR recupera keystream idêntico para múltiplos pares (P,C).",
                                "Brute-force encontra K correta em tempo esperado (<1s para 16 bits).",
                                "Re-encriptação com K derivada produz C original.",
                                "Testes com 10+ pares variados passam sem erros.",
                                "Relatório inclui tempos e limitações (ex: 32 bits inviável).",
                                "Código é limpo, comentado e modular."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: 30% (K derivada válida).",
                                "Eficiência: 25% (otimizações em brute-force).",
                                "Robustez: 20% (lida com tamanhos variados).",
                                "Documentação: 15% (comentários e relatório).",
                                "Criatividade em testes: 10% (casos edge inclusos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise e teoria de conjuntos finitos.",
                                "Programação: Algoritmos de busca e manipulação de bytes.",
                                "Segurança da Informação: Princípios de criptoanálise.",
                                "Física/Engenharia: Analogia com sinais e ruído em comunicações."
                              ],
                              "realWorldApplication": "Em pentests para quebrar cifras fracas em IoT ou apps legados; análise forense de tráfego criptografado conhecido; desenvolvimento de sistemas seguros evitando chaves curtas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Avaliar Vulnerabilidades em Criptosistemas Públicos",
                            "description": "Discutir KPA em RSA ou AES com chaves públicas, identificando cenários onde texto plano previsível (ex: padding oracles) permite ataques.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Known Plaintext Attack (KPA) em Criptosistemas Públicos",
                                  "subSteps": [
                                    "Estude a definição de KPA: atacante conhece parte do plaintext e ciphertext correspondente.",
                                    "Revise criptosistemas assimétricos como RSA, focando na chave pública (n, e).",
                                    "Analise como plaintext previsível (ex: headers HTTP, XML tags) facilita KPA.",
                                    "Compare KPA com outros ataques como CPA e CCA.",
                                    "Identifique pré-condições para KPA ser viável em cenários reais."
                                  ],
                                  "verification": "Resuma em um parágrafo como KPA explora chaves públicas em RSA.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação RSA (Wikipedia, Crypto101), Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar plaintext conhecido vs. desconhecido.",
                                  "learningObjective": "Explicar o mecanismo de KPA e sua aplicabilidade em RSA com chaves públicas.",
                                  "commonMistakes": [
                                    "Confundir KPA com chosen plaintext attack",
                                    "Ignorar que RSA usa chaves públicas expostas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vulnerabilidades em RSA com Plaintext Previsível",
                                  "subSteps": [
                                    "Examine ataques em RSA com exponentes pequenos (e=3) e mensagens curtas previsíveis.",
                                    "Simule recuperação parcial de plaintext usando equações modulares (m^e mod n).",
                                    "Estude casos onde padding PKCS#1 v1.5 é previsível, permitindo ataques de Bleichenbacher.",
                                    "Implemente um exemplo simples de KPA em Python usando pow() para descriptografia parcial.",
                                    "Discuta limitações: quando plaintext não é suficientemente previsível."
                                  ],
                                  "verification": "Execute um script Python que demonstre recuperação de mensagem conhecida em RSA.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com pycryptodome, Exemplos de código RSA no GitHub"
                                  ],
                                  "tips": "Comece com mensagens pequenas (< n^{1/e}) para evitar erros de padding.",
                                  "learningObjective": "Identificar cenários específicos onde plaintext previsível quebra RSA via KPA.",
                                  "commonMistakes": [
                                    "Usar chaves grandes sem testar modularidade",
                                    "Esquecer de considerar o tamanho do bloco"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Padding Oracle Attacks como Extensão de KPA",
                                  "subSteps": [
                                    "Entenda padding oracles: servidor revela se padding é válido sem descriptografar fully.",
                                    "Analise o ataque em modo CBC para AES (híbrido com RSA) ou RSA-OAEP falhas.",
                                    "Descreva o algoritmo: decrypt byte-by-byte manipulando ciphertext.",
                                    "Simule um padding oracle em código, demonstrando recuperação completa de plaintext.",
                                    "Compare com KPA puro: oracle fornece mais info que plaintext conhecido estático."
                                  ],
                                  "verification": "Crie um mock server que responda padding validity e recupere uma mensagem secreta.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Tutoriais Padding Oracle (Vaudenay paper), Python Flask para mock server"
                                  ],
                                  "tips": "Use XOR properties em CBC para manipular blocos adjacentes.",
                                  "learningObjective": "Modelar padding oracle como side-channel amplificando KPA em chaves públicas.",
                                  "commonMistakes": [
                                    "Confundir oracle com full decryption",
                                    "Ignorar IV manipulation"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Vulnerabilidades e Discutir Contra-medidas",
                                  "subSteps": [
                                    "Avalie um criptosistema dado (ex: RSA com padding fraco) quanto a KPA/padding oracle risks.",
                                    "Liste contra-medidas: OAEP padding, authenticated encryption (AEAD), constant-time impl.",
                                    "Crie um checklist para auditoria de vulnerabilidades em chaves públicas.",
                                    "Debata trade-offs: performance vs. security em cenários reais.",
                                    "Documente um relatório de vulnerabilidade fictício."
                                  ],
                                  "verification": "Produza um relatório identificando 3 vulnerabilidades e 3 fixes em um cenário hipotético.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "OWASP Crypto Cheat Sheet, Ferramentas como testssl.sh"
                                  ],
                                  "tips": "Priorize contra-medidas que evitam info leaks (ex: no padding feedback).",
                                  "learningObjective": "Aplicar análise para avaliar e mitigar vulnerabilidades em criptosistemas públicos.",
                                  "commonMistakes": [
                                    "Recomendar soluções obsoletas como PKCS#1 v1.5 sem caveats",
                                    "Subestimar side-channels"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um servidor web usando RSA para encryptar cookies de sessão com padding previsível. Use KPA para recuperar um cookie conhecido ('user=admin') e estenda para padding oracle em AES-CBC híbrido, decryptando uma mensagem secreta byte-by-byte via respostas HTTP 500/200 indicando padding validity.",
                              "finalVerifications": [
                                "Explicar KPA em RSA com plaintext previsível em <2 minutos.",
                                "Implementar e demonstrar um padding oracle attack simples.",
                                "Identificar 3 cenários reais onde isso ocorre (ex: SSLv2, old XML encryption).",
                                "Propor contra-medidas corretas para um dado criptosistema vulnerável.",
                                "Auditar um snippet de código crypto quanto a KPA risks."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre KPA e padding oracle (90%+ correto).",
                                "Profundidade de sub-steps implementados em exemplos práticos.",
                                "Correção matemática em simulações RSA (verificação modular).",
                                "Criatividade e relevância em contra-medidas propostas.",
                                "Clareza no relatório de avaliação de vulnerabilidades.",
                                "Cobertura de erros comuns evitados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (módulos, expoentes).",
                                "Redes: Protocolos TLS/SSL e hybrid crypto schemes.",
                                "Programação: Implementação segura de crypto APIs.",
                                "Ética: Implicações de auditorias de segurança em sistemas públicos."
                              ],
                              "realWorldApplication": "Auditar sites vulneráveis a padding oracles (ex: POODLE attack em TLS), recuperar chaves em cenários forenses digitais, ou fortalecer APIs REST com chaves públicas contra KPA em payloads JSON previsíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Propor Contra-medidas ao KPA",
                            "description": "Recomendar práticas como uso de IVs randômicos, modos CBC/CTR e ofuscação de texto plano em protocolos, com exemplos de Schneier (2015).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Known Plaintext Attack (KPA)",
                                  "subSteps": [
                                    "Estude a definição de KPA: atacante conhece pares plaintext-ciphertext.",
                                    "Analise exemplos clássicos, como quebra de chaves em DES com plaintext conhecido.",
                                    "Identifique vulnerabilidades comuns, como IVs fixos ou padrões repetitivos no plaintext.",
                                    "Leia trechos relevantes de Schneier (2015) sobre ataques a cifras de bloco.",
                                    "Anote 3 casos reais onde KPA foi explorado."
                                  ],
                                  "verification": "Crie um diagrama explicando como KPA recupera chaves e compartilhe com um colega para feedback.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Applied Cryptography' de Schneier (2015)",
                                    "Notas de aula sobre criptoanálise",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Foquem em padrões previsíveis no plaintext, como headers de protocolos.",
                                  "learningObjective": "Compreender as premissas e impactos do KPA em sistemas criptográficos.",
                                  "commonMistakes": [
                                    "Confundir KPA com CPA (Chosen Plaintext Attack)",
                                    "Ignorar o papel do modo de operação na vulnerabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Uso de Initialization Vectors (IVs) Randômicos",
                                  "subSteps": [
                                    "Explique o que é um IV e por que IVs fixos facilitam KPA.",
                                    "Implemente um exemplo simples em Python usando AES com IV fixo vs. randômico.",
                                    "Teste criptografia/decryptografia de um plaintext conhecido com IVs diferentes.",
                                    "Calcule entropia de IVs randômicos usando ferramentas como random.org.",
                                    "Documente como IVs randômicos quebram a correlação em ataques KPA."
                                  ],
                                  "verification": "Execute código que falha com IV fixo em KPA simulado e succeeds com IV randômico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com pycryptodome",
                                    "Editor de código (VS Code)",
                                    "Documentação AES NIST"
                                  ],
                                  "tips": "Sempre transmita o IV junto ao ciphertext, mas nunca reutilize-o.",
                                  "learningObjective": "Dominar o papel de IVs randômicos na prevenção de KPA.",
                                  "commonMistakes": [
                                    "Reutilizar IVs para o mesmo plaintext",
                                    "Usar IVs previsíveis como contadores sem sal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Modos de Operação Seguros: CBC e CTR",
                                  "subSteps": [
                                    "Compare modos ECB (vulnerável a KPA) com CBC e CTR.",
                                    "Implemente CBC em Python: criptografe plaintext conhecido e observe chaining.",
                                    "Simule CTR como stream cipher e teste contra KPA.",
                                    "Analise Schneier (2015) sobre falhas em modos inadequados.",
                                    "Crie um tabela comparativa de resistência a KPA para ECB, CBC, CTR."
                                  ],
                                  "verification": "Gere ciphertexts em CBC/CTR e demonstre que KPA não recupera chaves facilmente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Biblioteca cryptography Python",
                                    "Exemplos de código GitHub sobre modos AES",
                                    "Schneier (2015) capítulos sobre modos"
                                  ],
                                  "tips": "Em CBC, o IV atua como primeiro bloco; em CTR, como nonce inicial.",
                                  "learningObjective": "Aplicar modos CBC/CTR para mitigar riscos de KPA.",
                                  "commonMistakes": [
                                    "Usar ECB por simplicidade",
                                    "Ignorar padding em CBC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Ofuscação de Plaintext e Propor Contra-medidas Integradas",
                                  "subSteps": [
                                    "Discuta ofuscação: padding randômico, salting ou formatação não-padrão.",
                                    "Projete um protocolo simples (ex: chat seguro) com ofuscação + IV randômico + CBC.",
                                    "Avalie trade-offs: segurança vs. performance.",
                                    "Refira exemplos de Schneier sobre protocolos robustos.",
                                    "Escreva uma proposta de contra-medidas para um cenário KPA hipotético."
                                  ],
                                  "verification": "Apresente uma proposta escrita com pelo menos 3 contra-medidas justificadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta para design de protocolo",
                                    "Ferramentas Wireshark para simular tráfego",
                                    "Referências Schneier"
                                  ],
                                  "tips": "Combine múltiplas camadas: ofuscação + IV + modo seguro.",
                                  "learningObjective": "Propor soluções holísticas contra KPA em contextos reais.",
                                  "commonMistakes": [
                                    "Focar só em algoritmos, ignorar design de protocolo",
                                    "Sobrecarregar com ofuscação desnecessária"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de mensagens como WhatsApp, proponha: usar AES-256-CBC com IV de 16 bytes randômico por mensagem, adicionar padding randômico ao plaintext (ex: misturar timestamps falsos), e ofuscar headers de protocolo para evitar padrões conhecidos, prevenindo KPA mesmo se atacante interceptar mensagens rotineiras.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 razões pelas quais IV fixo falha em KPA.",
                                "Implementar e testar código CBC com IV randômico sem vazamentos.",
                                "Propor contra-medidas para um protocolo dado em 5 minutos.",
                                "Identificar KPA em um ciphertext ECB fornecido.",
                                "Comparar CBC vs. CTR em tabela com prós/contras para KPA.",
                                "Referenciar Schneier corretamente em uma proposta."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas explicações de contra-medidas (90%+ correto).",
                                "Criatividade e integração de múltiplas técnicas (IV, modo, ofuscação).",
                                "Código funcional e testado sem erros de KPA simulado.",
                                "Referências adequadas a Schneier (2015) e padrões NIST.",
                                "Clareza na proposta escrita, com exemplos concretos.",
                                "Compreensão de trade-offs (segurança vs. usabilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e entropia em IVs randômicos.",
                                "Redes de Computadores: Design de protocolos seguros contra eavesdropping.",
                                "Segurança da Informação: Análise de risco em sistemas distribuídos.",
                                "Programação: Implementação prática de criptografia em Python.",
                                "Ética: Implicações de falhas criptográficas em privacidade de dados."
                              ],
                              "realWorldApplication": "Em sistemas como HTTPS/TLS (usando IVs em AEAD modes derivados de CBC/CTR) ou VPNs (IPsec com ofuscação), essas contra-medidas previnem KPA em tráfego com padrões conhecidos, como headers HTTP, protegendo chaves em comunicações globais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Ataque por Texto Plano Escolhido",
                    "description": "Exploração onde o analista escolhe textos planos para obter textos cifrados e deduzir a chave.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Definição e Fundamentos do Ataque por Texto Plano Escolhido",
                        "description": "Compreensão básica do que é um ataque por texto plano escolhido (CPA), incluindo sua definição formal e o contexto em criptoanálise básica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Definir Ataque por Texto Plano Escolhido",
                            "description": "Explicar que no CPA o criptoanalista pode escolher textos planos arbitrários e obter os textos cifrados correspondentes de um oráculo de criptografia para deduzir a chave secreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Criptoanálise e Ataques Básicos",
                                  "subSteps": [
                                    "Revisar criptografia simétrica e o papel da chave secreta.",
                                    "Estudar ataques conhecidos: ciphertext-only (COA) e known-plaintext (KPA).",
                                    "Identificar limitações desses ataques e necessidade de modelos mais poderosos.",
                                    "Explorar a hierarquia de ataques (do mais fraco ao mais forte)."
                                  ],
                                  "verification": "Listar e diferenciar COA, KPA e introduzir CPA corretamente em um resumo escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Apostila de Introdução à Criptografia",
                                    "Vídeo sobre ataques básicos (YouTube: 'Criptoanálise Básica')",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar a hierarquia de ataques e memorize as siglas.",
                                  "learningObjective": "Entender o contexto histórico e conceitual dos ataques à criptografia.",
                                  "commonMistakes": "Confundir KPA (texto plano conhecido) com CPA (texto plano escolhido pelo atacante)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Oráculo de Criptografia",
                                  "subSteps": [
                                    "Definir oráculo como uma 'caixa preta' que encripta plaintexts fornecidos.",
                                    "Explicar que o oráculo usa uma chave secreta desconhecida.",
                                    "Discutir interações: atacante envia plaintext arbitrário e recebe ciphertext.",
                                    "Analisar restrições: sem descriptografia ou acesso à chave.",
                                    "Simular mentalmente consultas ao oráculo."
                                  ],
                                  "verification": "Desenhar um fluxograma do oráculo e descrever 3 consultas exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (Draw.io)",
                                    "Exemplos de oráculos em Python (código simples de cifra)"
                                  ],
                                  "tips": "Pense no oráculo como um serviço web que só encripta, sem revelar nada além do ciphertext.",
                                  "learningObjective": "Dominar o modelo de oráculo como base para ataques adaptativos.",
                                  "commonMistakes": "Achar que o oráculo permite descriptografar; ele só encripta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente o Ataque por Texto Plano Escolhido (CPA)",
                                  "subSteps": [
                                    "Estabelecer definição: atacante escolhe plaintexts arbitrários e obtém ciphertexts para deduzir a chave.",
                                    "Descrever o adversário CPA: acessa oráculo ilimitado de encriptação.",
                                    "Explicar objetivo: distinguir cifradores ou recuperar chave com alta probabilidade.",
                                    "Comparar com ataques mais fracos (COA, KPA).",
                                    "Formalizar em termos probabilísticos: vantagem não-negligível."
                                  ],
                                  "verification": "Escrever a definição completa de CPA em 100 palavras e citar diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo 'Chosen-Plaintext Attack' (Wikipedia em PT)",
                                    "Slides de aula sobre modelos de segurança"
                                  ],
                                  "tips": "Use a sigla CPA e memorize: 'Chosen Plaintext Attack' = texto plano ESCOLHIDO.",
                                  "learningObjective": "Capacitar-se a definir CPA com precisão técnica.",
                                  "commonMistakes": "Omitir o papel ativo do atacante na escolha dos plaintexts."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações e Exemplos Iniciais de CPA",
                                  "subSteps": [
                                    "Discutir cifras seguras contra CPA (ex: AES-GCM).",
                                    "Analisar cifras fracas a CPA (ex: ECB mode).",
                                    "Simular dedução de chave com plaintexts escolhidos.",
                                    "Relacionar com segurança semântica.",
                                    "Refletir sobre por que CPA é poderoso."
                                  ],
                                  "verification": "Identificar 2 cifras vulneráveis a CPA e explicar como atacá-las.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador online de cifras (CrypTool)",
                                    "Notebook para simulações manuais"
                                  ],
                                  "tips": "Comece com cifras simples como César para intuitivamente entender CPA.",
                                  "learningObjective": "Aplicar a definição de CPA a cenários reais iniciais.",
                                  "commonMistakes": "Confundir CPA com ataques por texto cifrado escolhido (CCA)."
                                }
                              ],
                              "practicalExample": "Em uma cifra de César (shift desconhecido), o atacante consulta o oráculo com plaintext 'A' (recebe 'D' para shift=3), 'B' (recebe 'E'), deduzindo o shift após poucas consultas e recuperando a chave completa.",
                              "finalVerifications": [
                                "Definir CPA em palavras próprias sem consultar materiais.",
                                "Explicar o papel do oráculo em uma frase.",
                                "Diferenciar CPA de KPA e COA.",
                                "Dar um exemplo simples de plaintext escolhido.",
                                "Descrever o objetivo final: deduzir a chave secreta.",
                                "Identificar uma cifra vulnerável a CPA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de CPA (80% das componentes corretas).",
                                "Clareza na explicação do oráculo e consultas.",
                                "Correta diferenciação de ataques relacionados.",
                                "Uso de terminologia técnica apropriada (ex: 'plaintext arbitrário').",
                                "Capacidade de ilustrar com exemplo prático.",
                                "Compreensão probabilística básica (vantagem do atacante)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria da informação.",
                                "Programação: Implementação de oráculos em Python para simulações.",
                                "Segurança Cibernética: Modelos de adversário em protocolos.",
                                "Lógica e Raciocínio: Dedução a partir de consultas black-box."
                              ],
                              "realWorldApplication": "Em auditorias de segurança, CPA testa cifras em sistemas como VPNs antigas ou apps móveis, revelando vulnerabilidades em modos como ECB, prevenindo vazamentos de dados em comunicações reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Diferenciar CPA de Outros Ataques",
                            "description": "Comparar o CPA com ataques por texto plano conhecido (KPA) e texto cifrado conhecido (CCA), destacando o poder adicional do controle sobre os textos planos escolhidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Características do Ataque por Texto Plano Conhecido (KPA)",
                                  "subSteps": [
                                    "Ler a definição formal de KPA: atacante conhece pares (plaintext, ciphertext) sem controle sobre eles.",
                                    "Identificar cenários típicos onde KPA ocorre, como em mensagens interceptadas.",
                                    "Listar limitações do KPA: dependência de textos planos reais disponíveis.",
                                    "Exemplificar com cifra de César: dado 'HELLO' -> 'MJQQT', deduzir chave.",
                                    "Anotar vantagens e desvantagens em uma tabela comparativa inicial."
                                  ],
                                  "verification": "Criar uma tabela com pelo menos 3 exemplos de KPA e confirmar que não há controle sobre plaintexts.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre criptoanálise",
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de cifras clássicas"
                                  ],
                                  "tips": "Use analogias cotidianas, como decifrar mensagens sem escolher o conteúdo.",
                                  "learningObjective": "Compreender os fundamentos e limitações do KPA como base para comparações.",
                                  "commonMistakes": [
                                    "Confundir KPA com ataques onde o atacante gera os plaintexts",
                                    "Ignorar que o KPA requer textos reais conhecidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Ataque por Texto Cifrado Escolhido (CCA)",
                                  "subSteps": [
                                    "Definir CCA: atacante escolhe ciphertexts e obtém plaintexts decifrados (exceto possivelmente um alvo).",
                                    "Comparar com KPA: destaque o controle sobre ciphertexts escolhidos.",
                                    "Analisar cenários: oráculos de decifração em protocolos interativos.",
                                    "Exemplificar: em Padding Oracle Attack, escolher ciphertexts para revelar plaintexts.",
                                    "Registrar diferenças chave em relação ao KPA em uma tabela atualizada."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como o CCA difere do KPA, com 2 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de oráculos de cifração/decifração",
                                    "Simulador online de cifras (opcional)",
                                    "Tabela comparativa em andamento"
                                  ],
                                  "tips": "Visualize o oráculo como uma 'máquina' que responde às suas consultas escolhidas.",
                                  "learningObjective": "Diferenciar CCA de KPA, enfatizando o poder do controle sobre ciphertexts.",
                                  "commonMistakes": [
                                    "Misturar CCA com CPA, esquecendo que CCA não controla plaintexts diretamente",
                                    "Subestimar restrições do oráculo de decifração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Ataque por Texto Plano Escolhido (CPA)",
                                  "subSteps": [
                                    "Definir CPA: atacante escolhe plaintexts e obtém ciphertexts correspondentes via oráculo de cifração.",
                                    "Destacar o controle total: escolha livre de plaintexts para maximizar informação.",
                                    "Comparar com KPA e CCA: maior poder por adaptação de plaintexts.",
                                    "Exemplificar: testar cifras lineares escolhendo plaintexts que revelam a chave.",
                                    "Atualizar tabela comparativa com coluna CPA."
                                  ],
                                  "verification": "Montar tabela final com 3 colunas (KPA, CCA, CPA) e pelo menos 4 linhas de diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de tabela comparativa",
                                    "Exemplos matemáticos de cifras (AES modo ECB)",
                                    "Vídeo curto sobre oráculos CPA (opcional)"
                                  ],
                                  "tips": "Pense no CPA como 'testar hipóteses' escolhendo entradas específicas para o cifrador.",
                                  "learningObjective": "Dominar a definição de CPA e seu controle único sobre plaintexts.",
                                  "commonMistakes": [
                                    "Confundir oráculo de cifração (CPA) com decifração (CCA)",
                                    "Achar que CPA é mais fraco que CCA"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Diferenças e Poder Adicional do CPA",
                                  "subSteps": [
                                    "Comparar poderes: KPA (passivo), CCA (decifração escolhida), CPA (cifração escolhida com plaintexts adaptativos).",
                                    "Discutir por que CPA é mais poderoso em certos contextos: revela estrutura da cifra diretamente.",
                                    "Simular cenários híbridos e discutir segurança (ex: IND-CPA).",
                                    "Criar resumo: 'O que torna CPA único?' com 5 pontos chave.",
                                    "Testar compreensão respondendo perguntas de diferenciação."
                                  ],
                                  "verification": "Responder quiz com 5 perguntas comparativas sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa completa",
                                    "Quiz autoavaliativo impresso ou digital"
                                  ],
                                  "tips": "Use mnemônicos: K=Conhecido (sem escolha), C=Escolhido Plano/Cifrado.",
                                  "learningObjective": "Sintetizar diferenças e justificar o poder adicional do CPA.",
                                  "commonMistakes": [
                                    "Ignorar adaptação em CPA (escolher plaintexts baseados em respostas anteriores)",
                                    "Equiparar CPA a ataques mais fortes como CCA2"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine quebrar uma cifra ECB simples: no KPA, você usa mensagens reais interceptadas; no CPA, você envia 'AAAAA', 'BBBBB' etc. ao oráculo para detectar padrões de blocos repetidos, revelando que é ECB sem precisar de textos reais.",
                              "finalVerifications": [
                                "Explicar corretamente as diferenças entre KPA, CCA e CPA em uma conversa simulada.",
                                "Preencher tabela comparativa com 100% de precisão.",
                                "Identificar cenários onde CPA é aplicável vs. outros ataques.",
                                "Diferenciar oráculos: cifração (CPA) vs. decifração (CCA).",
                                "Justificar por que CPA tem poder adicional com exemplo concreto.",
                                "Resolver problema: 'Dado um oráculo, qual ataque é esse?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusões entre ataques).",
                                "Clareza na comparação de poderes e controles.",
                                "Uso de exemplos relevantes e corretos.",
                                "Compreensão do impacto na segurança criptográfica.",
                                "Capacidade de sintetizar diferenças em resumo conciso.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e análise estatística em distribuições de plaintexts.",
                                "História: Evolução de ataques desde Enigma (KPA-like) a modernos oráculos.",
                                "Física/Engenharia: Modelos de oráculos como black boxes em experimentos.",
                                "Lógica/Filosofia: Raciocínio dedutivo em hipóteses criptoanalíticas."
                              ],
                              "realWorldApplication": "Em auditorias de segurança, diferenciar CPA ajuda a avaliar se um protocolo resiste a IND-CPA (ex: TLS sem autenticação), prevenindo vazamentos em apps de mensagens ou pagamentos online onde atacantes podem submeter dados escolhidos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Identificar Condições para CPA",
                            "description": "Reconhecer cenários onde o CPA é aplicável, como acesso a um oráculo de criptografia em criptosistemas simétricos ou públicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Fundamental do CPA",
                                  "subSteps": [
                                    "Leia a definição de Ataque por Texto Plano Escolhido (CPA): um atacante pode escolher plaintexts arbitrários e obter os ciphertexts correspondentes via um oráculo de encriptação.",
                                    "Identifique os elementos chave: controle total sobre plaintexts de entrada e acesso ao ciphertext de saída.",
                                    "Anote exemplos iniciais de oráculos, como APIs de encriptação em sistemas web.",
                                    "Compare brevemente com COA (apenas ciphertext disponível).",
                                    "Registre dúvidas sobre diferenças com outros ataques."
                                  ],
                                  "verification": "Você pode explicar em suas próprias palavras o que é um oráculo de encriptação e por que ele é crucial para CPA.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento ou slide sobre tipos de ataques criptográficos",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias: imagine um 'caixa de encriptação' que você alimenta com mensagens escolhidas.",
                                  "learningObjective": "Compreender o conceito central do CPA e seu mecanismo básico.",
                                  "commonMistakes": "Confundir CPA com KPA (onde chaves parciais são conhecidas) ou ignorar o papel do oráculo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Condições Pré-Requisitos para CPA",
                                  "subSteps": [
                                    "Liste as condições essenciais: 1) Acesso ilimitado a um oráculo de encriptação; 2) Não conhecimento da chave privada; 3) Criptosistema determinístico ou probabilístico.",
                                    "Analise cenários onde o oráculo existe: implementações de encriptação em nuvem ou protocolos cliente-servidor.",
                                    "Discuta limitações: oráculo deve responder múltiplas queries sem detecção.",
                                    "Crie uma tabela comparativa: CPA vs. cenários sem oráculo.",
                                    "Valide com pseudocódigo de um oráculo simples."
                                  ],
                                  "verification": "Crie uma checklist de 5 condições para CPA e marque exemplos válidos/inválidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou ferramenta digital para tabelas (ex: Google Sheets)",
                                    "Referência teórica de criptografia (ex: livro de Katz-Lindell)"
                                  ],
                                  "tips": "Pense em termos de 'poder do atacante': quão 'poderoso' é o acesso ao oráculo?",
                                  "learningObjective": "Reconhecer as condições mínimas necessárias para viabilizar um CPA.",
                                  "commonMistakes": "Assumir que qualquer acesso a ciphertext qualifica como CPA, ignorando a escolha de plaintext."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Aplicabilidade em Criptosistemas Simétricos e Públicos",
                                  "subSteps": [
                                    "Estude CPA em simétricos (ex: AES): oráculo usa a mesma chave para múltiplas encriptações.",
                                    "Examine assimétricos (ex: RSA): oráculo público encripta com chave pública escolhida pelo atacante.",
                                    "Identifique cenários reais: padding oracle em TLS ou APIs de encriptação pública.",
                                    "Simule um cenário: desenhe um diagrama de fluxo atacante-oráculo.",
                                    "Liste 3 exemplos onde CPA falha (ex: sem oráculo)."
                                  ],
                                  "verification": "Descreva 2 cenários simétricos e 2 públicos onde CPA é aplicável, justificando as condições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama em branco ou ferramenta como Draw.io",
                                    "Exemplos de código Python para oráculos simulados"
                                  ],
                                  "tips": "Foque em 'acesso prático': em apps reais, APIs expostas criam oráculos acidentais.",
                                  "learningObjective": "Aplicar condições de CPA a diferentes tipos de criptosistemas.",
                                  "commonMistakes": "Confundir encriptação pública com quebra total da chave privada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar CPA de Outros Ataques e Sintetizar",
                                  "subSteps": [
                                    "Compare com COA, KPA e CCA: destaque o 'escolhido' no plaintext.",
                                    "Crie um fluxograma de decisão: 'Dado este cenário, é CPA?'",
                                    "Revise casos borderline: oráculo limitado vs. ilimitado.",
                                    "Teste com quiz autoavaliativo de 5 cenários.",
                                    "Resuma em uma mindmap as condições chave."
                                  ],
                                  "verification": "Resolva 80% de um quiz de 10 perguntas sobre identificação de CPA.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quiz online ou impresso sobre ataques criptográficos",
                                    "Ferramenta de mindmap (ex: MindMeister)"
                                  ],
                                  "tips": "Use mnemônicos: CPA = 'Chosen Plaintext Access'.",
                                  "learningObjective": "Diferenciar CPA de ataques semelhantes e sintetizar critérios de identificação.",
                                  "commonMistakes": "Sobrestimar aplicabilidade: CPA requer oráculo ativo, não passivo."
                                }
                              ],
                              "practicalExample": "Em um site de mensagens seguras usando AES-GCM via API, um atacante envia plaintexts escolhidos (ex: 'teste1', 'teste2') para a API de encriptação e recebe ciphertexts. Isso cria um oráculo perfeito para CPA, permitindo testar fraquezas no padding ou modo de operação.",
                              "finalVerifications": [
                                "Explique verbalmente 3 condições essenciais para CPA.",
                                "Identifique corretamente CPA em 4 de 5 cenários hipotéticos.",
                                "Diferencie CPA de COA e CCA em uma tabela.",
                                "Desenhe um diagrama de um oráculo em um criptosistema simétrico.",
                                "Liste limitações práticas de CPA em sistemas reais.",
                                "Responda a perguntas sobre aplicabilidade em RSA público."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de oráculos (90% acerto).",
                                "Compreensão de diferenças com outros ataques (clareza em explicações).",
                                "Capacidade de aplicar a cenários simétricos e assimétricos.",
                                "Uso correto de terminologia criptográfica.",
                                "Profundidade em exemplos práticos e diagramas.",
                                "Identificação de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade em ataques probabilísticos (ex: IND-CPA).",
                                "Segurança da Informação: Modelos de ameaça e oráculos em protocolos.",
                                "Programação: Implementação de oráculos em Python para simulação.",
                                "Ética: Implicações de ataques em sistemas reais e conformidade legal.",
                                "Redes: CPA em protocolos como TLS/SSL."
                              ],
                              "realWorldApplication": "Em auditorias de segurança, identificar condições para CPA ajuda a detectar vulnerabilidades em APIs de encriptação expostas, como em serviços de nuvem (AWS KMS mal configurado), prevenindo brechas em comunicações seguras de bancos ou apps de saúde."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Modelo Adversarial e Oráculo de Criptografia",
                        "description": "Exploração do modelo teórico do adversário no CPA, incluindo o funcionamento do oráculo e as queries permitidas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Descrever o Oráculo CPA",
                            "description": "Explicar o oráculo como uma 'caixa preta' que recebe texto plano escolhido pelo analista e retorna o texto cifrado com a chave desconhecida, sem acesso à descriptografia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de oráculo em criptografia",
                                  "subSteps": [
                                    "Pesquisar a definição geral de 'oráculo' em contextos computacionais e criptográficos.",
                                    "Identificar que um oráculo é uma abstração de uma função desconhecida acessível apenas por consultas.",
                                    "Diferenciar oráculos de funções conhecidas, enfatizando a natureza de 'caixa preta'.",
                                    "Estudar exemplos simples de oráculos em teoria da computação.",
                                    "Anotar analogias cotidianas, como uma máquina de vending que responde a inputs específicos."
                                  ],
                                  "verification": "Escrever uma definição em 3 frases e compará-la com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook ou computador",
                                    "Artigos introdutórios sobre criptografia (ex: Wikipedia - Oracle machine)"
                                  ],
                                  "tips": "Use analogias como uma 'máquina mágica' para facilitar a compreensão intuitiva.",
                                  "learningObjective": "Dominar a noção abstrata de oráculo como interface limitada a uma função secreta.",
                                  "commonMistakes": [
                                    "Confundir oráculo com uma função totalmente conhecida",
                                    "Ignorar o aspecto de 'caixa preta'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contextualizar o Oráculo no Ataque por Texto Plano Escolhido (CPA)",
                                  "subSteps": [
                                    "Revisar o que é um Ataque CPA: atacante escolhe textos planos e observa cifrados.",
                                    "Explicar o modelo adversarial onde o atacante não conhece a chave.",
                                    "Posicionar o oráculo CPA como simulador do cifrador inimigo.",
                                    "Comparar com ataques passivos (apenas observação) vs. ativos (consultas escolhidas).",
                                    "Diagrama mental: Atacante → Texto Plano Escolhido → Oráculo → Cifrado."
                                  ],
                                  "verification": "Criar um fluxograma simples do processo CPA com oráculo destacado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama (ex: Draw.io)",
                                    "Vídeos tutoriais sobre CPA (Khan Academy ou YouTube)"
                                  ],
                                  "tips": "Desenhe diagramas para visualizar o fluxo de interações.",
                                  "learningObjective": "Entender o papel específico do oráculo no cenário de criptoanálise CPA.",
                                  "commonMistakes": [
                                    "Misturar CPA com CCA (Chosen Ciphertext Attack)",
                                    "Achar que o oráculo revela a chave diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o funcionamento detalhado da 'caixa preta'",
                                  "subSteps": [
                                    "Detalhar entradas: qualquer texto plano escolhido pelo analista.",
                                    "Explicar saídas: texto cifrado correspondente com chave fixa e desconhecida.",
                                    "Enfatizar ausência de descriptografia ou acesso à chave.",
                                    "Simular múltiplas consultas: ex. input 'A', output cifrado1; input 'B', output cifrado2.",
                                    "Discutir que o oráculo usa sempre a mesma chave secreta por sessão."
                                  ],
                                  "verification": "Simular verbalmente 3 consultas ao oráculo e descrever respostas esperadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo ou Python simples para simular oráculo",
                                    "Documentação de cifradores como AES"
                                  ],
                                  "tips": "Pense no oráculo como um serviço web que só cifra, sem login ou chave.",
                                  "learningObjective": "Descrever precisamente as interfaces de entrada/saída e restrições do oráculo CPA.",
                                  "commonMistakes": [
                                    "Assumir que o oráculo permite descriptografia",
                                    "Ignorar que a chave é fixa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar limitações, importância e exemplos práticos",
                                  "subSteps": [
                                    "Listar limitações: sem acesso à chave, sem descriptografia, consultas limitadas em cenários reais.",
                                    "Explicar importância: testa segurança de cifradores contra ataques ativos.",
                                    "Criar um exemplo simples com cifrador toy (ex: cifra César simulada).",
                                    "Discutir como oráculos modelam protocolos reais como TLS handshakes.",
                                    "Refletir sobre implicações éticas em criptoanálise."
                                  ],
                                  "verification": "Redigir um parágrafo resumindo o oráculo CPA com limitações e um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Ferramentas online de criptografia (ex: CyberChef)"
                                  ],
                                  "tips": "Teste com ferramentas reais para ver o conceito em ação.",
                                  "learningObjective": "Integrar o conceito em contextos mais amplos de segurança criptográfica.",
                                  "commonMistakes": [
                                    "Superestimar poderes do oráculo",
                                    "Confundir simulação com ataque real"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um oráculo CPA com cifra de César (chave secreta=3): Input 'HELLO' → Output 'KHOOR'; Input 'ATTACK' → Output 'DWWDFN'. O analista escolhe plaintexts para inferir padrões, sem conhecer o shift=3.",
                              "finalVerifications": [
                                "Definir oráculo CPA em termos de entradas/saídas e caixa preta.",
                                "Explicar diferença entre oráculo CPA e observação passiva.",
                                "Simular 2 consultas e prever saídas consistentes com chave fixa.",
                                "Identificar que não há acesso à descriptografia.",
                                "Descrever papel no modelo adversarial.",
                                "Citar uma limitação real do oráculo em cenários práticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da caixa preta (entrada plaintext, saída ciphertext).",
                                "Clareza na explicação do contexto CPA e modelo adversarial.",
                                "Uso correto de terminologia criptográfica (chave desconhecida, sem descriptografia).",
                                "Capacidade de fornecer exemplos concretos e diagramas.",
                                "Compreensão de limitações e importância teórica/prática.",
                                "Originalidade em analogias e verificações pessoais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria das funções e abstrações black-box.",
                                "Física: Modelos experimentais com variáveis ocultas.",
                                "Segurança da Informação: Testes de penetração e auditorias.",
                                "Filosofia da Ciência: Limites do conhecimento empírico via oráculos."
                              ],
                              "realWorldApplication": "Em avaliações de segurança de protocolos como HTTPS/TLS, onde oráculos simulam cifradores de servidores para testar vulnerabilidades a ataques CPA, ajudando desenvolvedores a fortalecer sistemas contra criptoanálise ativa."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Simular Queries no Oráculo",
                            "description": "Demonstrar como o analista envia múltiplas mensagens plano-cifrado para coletar pares e analisar padrões que revelem a chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Simulação do Oráculo",
                                  "subSteps": [
                                    "Pesquise o conceito de oráculo de criptografia em ataques chosen-plaintext.",
                                    "Implemente uma função oráculo simples em Python que recebe um plaintext e retorna o ciphertext usando XOR com uma chave secreta fixa (ex: chave de 8 bytes).",
                                    "Teste o oráculo com um plaintext conhecido para verificar se o ciphertext é gerado corretamente.",
                                    "Defina o tamanho fixo das mensagens (ex: 8 bytes) para todas as queries.",
                                    "Crie uma lista vazia para armazenar os pares plaintext-ciphertext."
                                  ],
                                  "verification": "Execute o oráculo com 'hello123' e confirme que retorna um ciphertext consistente com a chave secreta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3 instalado",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Biblioteca padrão (sem dependências externas)"
                                  ],
                                  "tips": "Use bytes em vez de strings para manipulação binária precisa; pad com zeros se necessário.",
                                  "learningObjective": "Compreender e implementar um modelo básico de oráculo adversarial.",
                                  "commonMistakes": [
                                    "Confundir strings com bytes levando a erros de encoding",
                                    "Não fixar o tamanho das mensagens",
                                    "Revelar a chave acidentalmente no código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Enviar Múltiplas Queries ao Oráculo",
                                  "subSteps": [
                                    "Gere uma lista de 10 plaintexts estratégicos variados (ex: todos zeros, todos uns, padrões repetidos).",
                                    "Envie cada plaintext para o oráculo e capture o ciphertext correspondente.",
                                    "Registre cada par (plaintext, ciphertext) em uma estrutura de dados como lista de tuplas.",
                                    "Repita queries com os mesmos plaintexts para verificar consistência (devem retornar mesmo ciphertext).",
                                    "Salve os pares em um arquivo CSV para análise posterior."
                                  ],
                                  "verification": "Confirme que você tem pelo menos 5 pares únicos armazenados sem duplicatas ou erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Biblioteca csv do Python para exportação"
                                  ],
                                  "tips": "Escolha plaintexts que maximizem diferenças em bytes para facilitar detecção de padrões.",
                                  "learningObjective": "Dominar a simulação de interações adversariais com o oráculo.",
                                  "commonMistakes": [
                                    "Enviar plaintexts de tamanhos variáveis",
                                    "Não capturar erros de padding",
                                    "Ignorar a consistência das respostas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Padrões nos Pares Plano-Cifrado Coletados",
                                  "subSteps": [
                                    "Carregue os pares do arquivo ou lista e exiba em tabela para inspeção visual.",
                                    "Para cada posição de byte (0-7), compare plaintexts e ciphertexts correspondentes.",
                                    "Calcule XOR byte-a-byte entre plaintext e ciphertext para um par e observe repetições.",
                                    "Verifique se o XOR resulta na mesma sequência em múltiplos pares (isso revela a chave).",
                                    "Identifique qualquer variação que indique stream cipher ou padrões de chave."
                                  ],
                                  "verification": "Gere uma tabela mostrando XORs consistentes em pelo menos 80% dos pares.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pandas para tabelas (opcional)",
                                    "Funções de XOR personalizadas em Python"
                                  ],
                                  "tips": "Use loops for byte positions e print hex para visualização clara.",
                                  "learningObjective": "Aplicar análise diferencial para detectar padrões criptográficos.",
                                  "commonMistakes": [
                                    "Analisar em decimal em vez de hex/binário",
                                    "Confundir posições de bytes",
                                    "Não testar múltiplos pares para confirmação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair e Validar a Chave Revelada",
                                  "subSteps": [
                                    "Compile a chave candidata do XOR dominante de todos os pares.",
                                    "Teste a chave cifrando um novo plaintext conhecido e comparando com o oráculo.",
                                    "Calcule taxa de acerto (ex: porcentagem de bytes corretos).",
                                    "Ajuste se houver discrepâncias menores e reteste.",
                                    "Documente o processo de revelação em um relatório curto."
                                  ],
                                  "verification": "A chave extraída deve descriptografar corretamente 100% de um plaintext de teste novo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Função de teste de descriptografia"
                                  ],
                                  "tips": "Sempre valide com dados não vistos anteriormente para evitar overfitting.",
                                  "learningObjective": "Concluir a criptoanálise extraindo e validando a chave secreta.",
                                  "commonMistakes": [
                                    "Assumir chave sem validação cruzada",
                                    "Ignorar ruído ou padding",
                                    "Não documentar suposições"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um oráculo que usa XOR com chave secreta b'secretkey'. Envie plaintexts como b'\\x00'*8, b'\\xFF'*8, b'hello123'. Analise: XOR de b'\\x00'*8 com ciphertext dá a chave diretamente. Confirme descriptografando 'testdata' corretamente.",
                              "finalVerifications": [
                                "Oráculo simulado responde consistentemente a queries repetidas.",
                                "Pelo menos 10 pares coletados e armazenados corretamente.",
                                "Análise revela padrão XOR idêntico em múltiplos pares.",
                                "Chave extraída descriptografa novos plaintexts com 100% de precisão.",
                                "Relatório documenta queries, análise e validação.",
                                "Código é reproduzível e livre de erros comuns."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do oráculo (sem vazamentos de chave).",
                                "Estratégia de queries cobre casos edge (zeros, ones, padrões).",
                                "Análise identifica corretamente o padrão XOR da chave.",
                                "Validação usa dados independentes com taxa de acerto perfeita.",
                                "Estrutura de código limpa e comentada.",
                                "Tempo total dentro de 90 minutos com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de bytes e estruturas de dados em Python.",
                                "Matemática: Operações bitwise (XOR) e análise de padrões.",
                                "Estatística: Verificação de consistência em conjuntos de dados.",
                                "Segurança da Informação: Modelos de ameaça adversarial.",
                                "Pensamento Computacional: Decomposição de problemas em steps atômicos."
                              ],
                              "realWorldApplication": "Em testes de penetração ética (pentesting), analistas usam oráculos reais como APIs de criptografia para quebrar implementações fracas, identificando vulnerabilidades em sistemas como apps web ou protocolos IoT antes de exploits maliciosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Analisar Limitações do Modelo CPA",
                            "description": "Discutir restrições como número limitado de queries e ausência de adaptatividade em modelos básicos de CPA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição e Funcionamento Básico do Modelo CPA",
                                  "subSteps": [
                                    "Ler a definição formal do modelo de Ataque por Texto Plano Escolhido (CPA).",
                                    "Identificar os componentes principais: adversário, oráculo de encriptação e queries.",
                                    "Desenhar um diagrama simples do fluxo de interações no modelo básico.",
                                    "Explicar verbalmente ou por escrito o papel do oráculo não adaptativo.",
                                    "Listar as premissas iniciais do modelo (ex.: mensagens de tamanho fixo)."
                                  ],
                                  "verification": "Criar um diagrama anotado e explicá-lo em 2 minutos sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Referência teórica sobre CPA (artigo ou livro de criptografia)"
                                  ],
                                  "tips": "Use setas no diagrama para mostrar o fluxo de queries e respostas.",
                                  "learningObjective": "Compreender os fundamentos do modelo CPA para contextualizar suas limitações.",
                                  "commonMistakes": [
                                    "Confundir CPA com CCA (adaptativo)",
                                    "Ignorar que o oráculo só encripta, não decripta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as Principais Limitações do Modelo CPA Básico",
                                  "subSteps": [
                                    "Listar limitações quantitativas: número finito de queries (ex.: q ≤ 2^20).",
                                    "Descrever limitação qualitativa: ausência de adaptatividade (queries não-dependentes).",
                                    "Analisar restrições em mensagens: apenas textos planos escolhidos, sem controle total.",
                                    "Discutir limites computacionais implícitos no adversário.",
                                    "Categorizar limitações em tabela: tipo, impacto e exemplo."
                                  ],
                                  "verification": "Produzir uma tabela com pelo menos 4 limitações identificadas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Notas de aula sobre modelos de segurança"
                                  ],
                                  "tips": "Priorize limitações canônicas como q-polinomial e não-adaptatividade.",
                                  "learningObjective": "Reconhecer e catalogar restrições específicas do modelo CPA.",
                                  "commonMistakes": [
                                    "Superestimar o número de queries como ilimitado",
                                    "Confundir não-adaptatividade com aleatoriedade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Impacto das Limitações na Criptoanálise",
                                  "subSteps": [
                                    "Simular um cenário com queries limitadas e observar falhas em ataques.",
                                    "Explicar como a não-adaptatividade favorece cifradores IND-CPA seguros.",
                                    "Calcular probabilidade de sucesso de um ataque dado q queries.",
                                    "Comparar eficiência com modelos mais fracos (ex.: ataque passivo).",
                                    "Discutir cenários onde limitações protegem ou expõem o sistema."
                                  ],
                                  "verification": "Realizar um cálculo simples de probabilidade e interpretá-lo por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python para simulações probabilísticas",
                                    "Exemplos de cifradores IND-CPA como AES"
                                  ],
                                  "tips": "Use fórmulas como Pr[sucesso] ≤ q / 2^k para blocos de k bits.",
                                  "learningObjective": "Avaliar consequências práticas das restrições no desempenho de ataques.",
                                  "commonMistakes": [
                                    "Ignorar vantagens probabilísticas para o cifrador",
                                    "Aplicar adaptatividade indevidamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Extensões e Melhorias Além do Modelo Básico",
                                  "subSteps": [
                                    "Comparar CPA com CCA (adaptativo) e listar diferenças chave.",
                                    "Propor experimentos para testar limites reais de queries.",
                                    "Discutir híbridos ou modelos realistas (ex.: com ruído ou side-channels).",
                                    "Redigir um parágrafo resumindo quando o modelo CPA é insuficiente.",
                                    "Pesquisar um paper recente sobre limitações em CPA."
                                  ],
                                  "verification": "Escrever um resumo comparativo de 200 palavras com referências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso a papers (Google Scholar ou arXiv)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Busque termos como 'IND-CPA limitations' para fontes atualizadas.",
                                  "learningObjective": "Contextualizar o CPA em hierarquias de segurança mais amplas.",
                                  "commonMistakes": [
                                    "Equiparar CPA a modelos reais sem considerar implementações",
                                    "Subestimar evoluções como quantum threats"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um oráculo CPA com limite de 100 queries contra o cifrador de fluxo RC4 fraco: envie textos planos escolhidos para recuperar a chave parcial, mas observe como o limite impede recuperação completa, destacando a não-adaptatividade ao não poder ajustar queries baseadas em respostas anteriores.",
                              "finalVerifications": [
                                "Explicar corretamente pelo menos 3 limitações principais do CPA.",
                                "Calcular impacto probabilístico de queries limitadas em um exemplo numérico.",
                                "Comparar CPA com CCA em um diagrama ou tabela.",
                                "Identificar cenários reais onde CPA é inadequado.",
                                "Redigir um relatório de 1 página analisando limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na identificação de limitações (30%)",
                                "Profundidade na análise de impactos e probabilidades (25%)",
                                "Clareza em diagramas, tabelas e exemplos práticos (20%)",
                                "Conexão com contextos mais amplos de criptoanálise (15%)",
                                "Originalidade em simulações ou extensões propostas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Complexidade Computacional",
                                "Segurança da Informação: Modelos Adversariais em Cibersegurança",
                                "Física: Analogias com Limites Quânticos em Criptografia",
                                "Economia: Análise de Custo-Benefício em Ataques Cibernéticos"
                              ],
                              "realWorldApplication": "Em auditorias de segurança de protocolos como TLS/SSL, analistas usam modelos CPA para validar resistências iniciais, identificando se implementações reais extrapolam limitações teóricas, prevenindo brechas em sistemas bancários ou comunicações governamentais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Exemplos Práticos e Dedução de Chave",
                        "description": "Aplicação do CPA em algoritmos simples, com foco em criptosistemas simétricos e dedução da chave.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Aplicar CPA em Cifra de César",
                            "description": "Usar dois textos planos escolhidos (ex: 'A' e 'B') para obter cifrados e calcular a chave de deslocamento diretamente pela diferença.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar Textos Planos Escolhidos",
                                  "subSteps": [
                                    "Escolha o primeiro texto plano simples, como 'A' (posição 0 no alfabeto inglês).",
                                    "Escolha o segundo texto plano adjacente, como 'B' (posição 1 no alfabeto).",
                                    "Registre as posições numéricas correspondentes: A=0, B=1.",
                                    "Certifique-se de que os textos sejam curtos, conhecidos e com diferença de posição de 1 para facilitar o cálculo."
                                  ],
                                  "verification": "Textos planos selecionados e suas posições numéricas (0-25) documentadas corretamente em uma tabela.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela do alfabeto com posições numéricas (A=0, B=1, ..., Z=25)"
                                  ],
                                  "tips": [
                                    "Use sempre letras maiúsculas para consistência.",
                                    "Prefira diferenças pequenas (ex: 1) para evitar ambiguidades modulares."
                                  ],
                                  "learningObjective": "Compreender o conceito de textos planos escolhidos controlados pelo atacante em um cenário de CPA.",
                                  "commonMistakes": [
                                    "Escolher textos longos ou com caracteres especiais.",
                                    "Mapear incorretamente letras para números (ex: ignorar A=0)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter Textos Cifrados do Oráculo",
                                  "subSteps": [
                                    "Submeta o primeiro texto plano 'A' ao oráculo ou simulador de Cifra de César.",
                                    "Registre o texto cifrado recebido, por exemplo, 'M', e sua posição (12).",
                                    "Submeta o segundo texto plano 'B' ao mesmo oráculo.",
                                    "Registre o segundo texto cifrado, por exemplo, 'N', e sua posição (13).",
                                    "Mapeie todos os cifrados para posições numéricas usando a tabela alfabética."
                                  ],
                                  "verification": "Textos cifrados obtidos e suas posições numéricas registradas para ambos os plaintexts, com consistência no oráculo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Simulador ou implementador de Cifra de César (manual ou código simples)",
                                    "Papel e caneta",
                                    "Tabela alfabética"
                                  ],
                                  "tips": [
                                    "Simule o oráculo manualmente se não disponível, assumindo uma chave fixa.",
                                    "Garanta que a mesma chave de deslocamento seja usada para todos os envios."
                                  ],
                                  "learningObjective": "Simular o acesso a um oráculo de cifragem em um ataque prático de texto plano escolhido.",
                                  "commonMistakes": [
                                    "Usar chaves diferentes acidentalmente entre submissões.",
                                    "Erro de transcrição ao registrar cifrados ou posições."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Chave de Deslocamento pela Diferença",
                                  "subSteps": [
                                    "Calcule a chave candidata k1 = posição(C1) - posição(P1) mod 26 (ex: 12 - 0 = 12).",
                                    "Calcule a chave candidata k2 = posição(C2) - posição(P2) mod 26 (ex: 13 - 1 = 12).",
                                    "Verifique se k1 é igual a k2; se não, revise entradas ou aplique ajuste modular (+26 se negativo).",
                                    "Registre a chave k final como o valor consistente.",
                                    "Teste a fórmula em um terceiro par opcional para confirmação."
                                  ],
                                  "verification": "Chave k calculada de forma consistente (k1 == k2) e documentada com todos os cálculos modulares.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou papel para operações modulares",
                                    "Tabela alfabética",
                                    "Papel e caneta"
                                  ],
                                  "tips": [
                                    "Para subtração modular: (a - b) mod 26 = ((a - b) % 26 + 26) % 26 para evitar negativos.",
                                    "Use múltiplos pares para aumentar a confiança na chave."
                                  ],
                                  "learningObjective": "Dominar o cálculo direto da chave via aritmética modular em ataques CPA.",
                                  "commonMistakes": [
                                    "Esquecer o módulo 26, resultando em valores >25 ou negativos.",
                                    "Não verificar consistência entre k1 e k2."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar a Chave Recuperada",
                                  "subSteps": [
                                    "Use k para cifrar um novo plaintext conhecido (ex: 'C'=2 → deve dar posição 2+k mod 26).",
                                    "Compare com o cifrado obtido do oráculo para o mesmo plaintext.",
                                    "Descriptografe uma mensagem secreta exemplo usando deslocamento -k mod 26.",
                                    "Confirme que o resultado faz sentido linguisticamente.",
                                    "Documente o processo completo com capturas ou registros."
                                  ],
                                  "verification": "Descriptografia e verificação bem-sucedidas em pelo menos dois testes independentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Implementação manual ou código de descriptografia César",
                                    "Mensagem cifrada de teste",
                                    "Papel e caneta"
                                  ],
                                  "tips": [
                                    "Sempre teste com plaintexts adicionais além dos iniciais.",
                                    "Considere wrap-around: Z +1 = A."
                                  ],
                                  "learningObjective": "Validar a eficácia do CPA na recuperação e uso da chave para quebrar a cifra.",
                                  "commonMistakes": [
                                    "Confundir cifragem (+k) com descriptografia (-k).",
                                    "Ignorar testes de verificação adicionais."
                                  ]
                                }
                              ],
                              "practicalExample": "Escolha P1='A' (0) e P2='B' (1). Oráculo retorna C1='M' (12) e C2='N' (13). Calcule k=12-0=12 mod 26 e k=13-1=12 mod 26. Verifique: 'C' (2) cifrado com k=12 dá 'O' (14). Descriptografe 'WDFN' (22,3,5,13) com -12: 'KEEP' (10,4,15,1).",
                              "finalVerifications": [
                                "Chave k consistente entre todos os pares plaintext-ciphertext testados.",
                                "Descriptografia de mensagens conhecidas produz plaintexts corretos.",
                                "Cálculos modulares 26 aplicados sem erros em todos os passos.",
                                "Processo documentado com tabelas de posições e fórmulas.",
                                "Ataque simula fielmente um cenário CPA real contra Cifra de César."
                              ],
                              "assessmentCriteria": [
                                "Precisão absoluta no cálculo da chave (match 100% com oráculo).",
                                "Completude: todos substeps executados e documentados.",
                                "Correta manipulação de aritmética modular (mod 26).",
                                "Verificações independentes com múltiplos testes.",
                                "Explicação clara do raciocínio CPA em relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números (Z/26Z).",
                                "História: Uso da Cifra de César por Júlio César na Roma Antiga.",
                                "Segurança Cibernética: Análise de vulnerabilidades em cifras simétricas.",
                                "Programação: Implementação de cifradores/descriptografadores em Python ou JavaScript."
                              ],
                              "realWorldApplication": "Em cibersegurança, o CPA revela fraquezas em sistemas de cifragem fracos, como em apps legados ou IoT; entender isso impulsiona o design de cifras modernas resistentes (ex: AES), testes de penetração e proteção de comunicações sensíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1",
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Realizar CPA em Cifra de Substituição Monoalfabética",
                            "description": "Escolher textos planos com letras específicas para mapear a permutação da chave de substituição através de pares plano-cifrado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios do CPA em Cifras de Substituição Monoalfabética",
                                  "subSteps": [
                                    "Estude a definição de cifra de substituição monoalfabética: cada letra do plaintext é substituída por uma única letra diferente no ciphertext via uma permutação fixa.",
                                    "Revise o conceito de Chosen Plaintext Attack (CPA): o atacante escolhe plaintexts específicos e observa os ciphertexts correspondentes para deduzir a chave.",
                                    "Identifique que em monoalfabética, plaintexts com letras únicas ou raras revelam mapeamentos diretos (ex: letra que aparece uma vez no plaintext mapeia para sua única ocorrência no ciphertext).",
                                    "Analise limitações: assume acesso a um oráculo de encriptação que aceita plaintexts escolhidos.",
                                    "Documente a permutação como uma tabela de mapeamento alfabético (A->X, B->Y, etc.)."
                                  ],
                                  "verification": "Crie um diagrama ou tabela explicando como um plaintext com letras únicas revela mapeamentos diretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de cifra monoalfabética online ou livro-texto"
                                  ],
                                  "tips": "Visualize a permutação como uma 'troca de letras' fixa; foque em como CPA 'engana' o sistema revelando pares um-a-um.",
                                  "learningObjective": "Entender como o CPA explora a estrutura determinística da cifra monoalfabética para mapear a chave completa.",
                                  "commonMistakes": [
                                    "Confundir com cifra polialfabética (múltiplas substituições).",
                                    "Ignorar que mapeamentos são bijetores (um-para-um).",
                                    "Assumir frequência de letras sem considerar textos escolhidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Textos Planos Estratégicos",
                                  "subSteps": [
                                    "Escolha plaintexts curtos contendo letras únicas ou com baixa sobreposição para mapeamentos isolados (ex: 'A B C D' para primeiras letras).",
                                    "Priorize cobertura progressiva: primeiro plaintext para 4-5 letras únicas, segundo para próximas, até cobrir o alfabeto (26 letras em ~6-7 textos).",
                                    "Inclua letras comuns (E, T, A) e raras (Z, Q) para eficiência; use pangramas modificados como 'THE QUICK BROWN FX JMP'.",
                                    "Registre cada plaintext com suas letras destacadas e propósito (ex: mapear vogais primeiro).",
                                    "Garanta que nenhum plaintext repita letras já mapeadas para evitar ambiguidades."
                                  ],
                                  "verification": "Lista de 5-7 plaintexts documentados, cobrindo todas 26 letras sem sobreposições desnecessárias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou editor de texto",
                                    "Lista do alfabeto inglês"
                                  ],
                                  "tips": "Comece com singleton letters ('A'), depois pares ('AB'), escalando para frases; mire em plaintexts <10 chars iniciais.",
                                  "learningObjective": "Selecionar plaintexts otimizados que minimizem o número de consultas e maximizem revelações de mapeamento.",
                                  "commonMistakes": [
                                    "Escolher textos longos com repetições, causando ambiguidades.",
                                    "Ignorar letras raras, deixando lacunas na chave.",
                                    "Não planejar cobertura total do alfabeto."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e Registrar Pares Plano-Cifrado",
                                  "subSteps": [
                                    "Simule ou use um oráculo/oracle de encriptação: envie cada plaintext escolhido e receba o ciphertext correspondente.",
                                    "Registre pares exatos: plaintext 'ABC' -> ciphertext 'XYZ'; alinhe letras posição por posição.",
                                    "Verifique comprimentos iguais e ausência de padding ou modificações.",
                                    "Compile uma tabela de pares: coluna plaintext letters vs. ciphertext letters.",
                                    "Identifique mapeamentos iniciais óbvios de letras únicas."
                                  ],
                                  "verification": "Tabela completa de pares plano-cifrado para todos plaintexts selecionados, com alinhamento posicional.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de simulação de cifra (ex: Python script ou app online)",
                                    "Papel para tabelas"
                                  ],
                                  "tips": "Use um script simples para automatizar se possível; sempre copie ciphertexts exatamente como recebidos.",
                                  "learningObjective": "Coletar dados empíricos de encriptação para análise subsequente.",
                                  "commonMistakes": [
                                    "Misalign letras em pares.",
                                    "Perder registros de um plaintext.",
                                    "Assumir encriptação sem testar um par conhecido."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear a Permutação da Chave",
                                  "subSteps": [
                                    "Para cada letra única no plaintext, trace sua posição no ciphertext para deduzir mapeamento direto (ex: A em pos 1 -> X em pos 1).",
                                    "Resolva ambiguidades iterativamente: use mapeamentos conhecidos para desambiguar repetições.",
                                    "Construa tabela de substituição: plaintext letter -> ciphertext letter, preenchendo progressivamente.",
                                    "Verifique consistência: mesma plaintext letter sempre mapeia para mesma ciphertext em todos pares.",
                                    "Complete lacunas propagando mapeamentos de textos subsequentes."
                                  ],
                                  "verification": "Tabela de mapeamento 100% preenchida (26 pares), sem contradições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel quadriculado"
                                  ],
                                  "tips": "Use setas bidirecionais para tracking; teste mapeamentos parciais em mensagens curtas.",
                                  "learningObjective": "Deduzir a chave de substituição completa a partir de pares observados.",
                                  "commonMistakes": [
                                    "Ignorar inconsistências em mapeamentos.",
                                    "Confundir direções (plaintext->ciphertext vs. inverse).",
                                    "Parar antes de cobrir todas as letras."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a Chave e Aplicar Descriptografia",
                                  "subSteps": [
                                    "Aplique a chave deduzida para descriptografar uma mensagem ciphertext de teste conhecida.",
                                    "Confirme que todos mapeamentos são bijetores (nenhuma colisão ou falta).",
                                    "Teste com plaintexts adicionais não usados na dedução para validar.",
                                    "Gere a chave inversa (ciphertext -> plaintext) para descriptografia geral.",
                                    "Documente a chave final como string ou tabela (ex: 'A->X B->Y ...')."
                                  ],
                                  "verification": "Descriptografia bem-sucedida de 2-3 mensagens de teste independentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mensagens ciphertext de teste",
                                    "Ferramenta de descriptografia manual ou script"
                                  ],
                                  "tips": "Sempre teste com pangrama completo para cobertura total; ajuste se houver erro.",
                                  "learningObjective": "Validar a robustez da chave deduzida contra novos inputs.",
                                  "commonMistakes": [
                                    "Não testar inverse mapping.",
                                    "Aceitar mapeamentos parciais.",
                                    "Erros de transcrição na tabela final."
                                  ]
                                }
                              ],
                              "practicalExample": "Escolha plaintexts: 1. 'ETAO' -> ciphertext 'XIFV' (E->X, T->I, A->F, O->V). 2. 'INRS' -> 'HQWL' (preenche mais). Continue até chave completa: ex. chave 'ETAOIN SHRDLU...' mapeia para permutação deduzida. Descriptografe 'XIF VQEBJ CRPWL GJS' de volta para 'THE QUICK BROWN FOX'.",
                              "finalVerifications": [
                                "Chave deduzida é uma permutação completa (26 mapeamentos bijetores).",
                                "Descriptografia correta de mensagens de teste independentes.",
                                "Consistência em todos pares plano-cifrado usados.",
                                "Cobertura total do alfabeto sem lacunas ou colisões.",
                                "Validação com plaintext adicional não usado na dedução.",
                                "Documentação clara da tabela de mapeamento."
                              ],
                              "assessmentCriteria": [
                                "Eficiência na escolha de plaintexts (cobertura com ≤7 textos).",
                                "Precisão no registro de pares plano-cifrado (sem erros de alinhamento).",
                                "Correção e completude da tabela de mapeamento.",
                                "Detecção e resolução de ambiguidades iterativamente.",
                                "Validação robusta com testes independentes.",
                                "Clareza na documentação e explicação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Permutações e funções bijetoras.",
                                "Estatística: Análise de frequência de letras para otimização.",
                                "História: Cifras clássicas como a de Vigenère ou Atbash.",
                                "Linguística: Estrutura alfabética e pangramas.",
                                "Programação: Implementação de scripts para simulação de CPA."
                              ],
                              "realWorldApplication": "Em cibersegurança, CPA modela ataques a protocolos como padding oracle ou encriptações fracas em apps web, permitindo hackers deduzirem chaves; essencial para desenvolvedores testarem robustez de sistemas criptográficos em cenários como SSL inseguro ou jogos online."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Discutir CPA em Criptosistemas Públicos",
                            "description": "Explicar como o CPA pode ser usado em esquemas de chave pública, como RSA sem padding adequado, para recuperar a chave privada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de CPA e Criptosistemas Públicos",
                                  "subSteps": [
                                    "Defina CPA (Chosen Plaintext Attack) como um ataque onde o atacante pode escolher textos planos e obter os correspondentes cifras.",
                                    "Explique os componentes de um criptosistema público: chave pública para cifrar, chave privada para decifrar.",
                                    "Diferencie CPA de outros ataques como Known Plaintext Attack (KPA) e Ciphertext-Only Attack (COA).",
                                    "Liste pré-requisitos matemáticos: aritmética modular e funções exponenciais.",
                                    "Pesquise exemplos históricos de falhas em PKCs devido a ataques semelhantes."
                                  ],
                                  "verification": "Resuma em 3-5 frases os conceitos chave e compare CPA com KPA/COA em um diagrama simples.",
                                  "estimatedTime": "45 minutes",
                                  "materials": "Notebook, acesso à internet para Wikipedia/Docs de criptografia, papel e caneta para diagramas.",
                                  "tips": "Use analogias como 'escolher mensagens para enviar a uma caixa preta de cifragem' para visualizar CPA.",
                                  "learningObjective": "Dominar definições fundamentais de CPA e PKCs para contextualizar ataques.",
                                  "commonMistakes": "Confundir CPA com COA; ignorar que em PKCs a chave pública é conhecida por todos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o Funcionamento do RSA sem Padding Adequado",
                                  "subSteps": [
                                    "Descreva o algoritmo RSA: geração de chaves (p, q primos, n=pq, e coprimo com φ(n), d = e⁻¹ mod φ(n)).",
                                    "Explique cifragem sem padding: c = m^e mod n, onde m é o texto plano numérico.",
                                    "Implemente em Python uma função simples de cifragem RSA sem padding usando pow(m, e, n).",
                                    "Teste com mensagens pequenas (m < n) e observe saídas.",
                                    "Identifique vulnerabilidades: mensagens determinísticas levam a vazamento de informação."
                                  ],
                                  "verification": "Execute código Python cifrando 3 mensagens escolhidas e verifique se decifra corretamente com chave privada conhecida.",
                                  "estimatedTime": "60 minutes",
                                  "materials": "Editor de código (VS Code ou Jupyter), biblioteca Python (sem necessidade de extras além de built-ins).",
                                  "tips": "Comece com números primos pequenos (ex: p=61, q=53) para cálculos manuais iniciais.",
                                  "learningObjective": "Entender a mecânica exata do RSA textbook (sem padding) e suas fraquezas inerentes.",
                                  "commonMistakes": "Usar padding inadvertidamente; esquecer que m deve ser < n sem padding."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular um Ataque CPA em RSA sem Padding",
                                  "subSteps": [
                                    "Escolha textos planos específicos: envie '1' e '2' para obter c1 = 1^e mod n e c2 = 2^e mod n.",
                                    "Calcule diferenças: observe que (c2 - c1) revela informações sobre e e n.",
                                    "Para RSA sem padding, demonstre fatoração via múltiplos ciframentos escolhidos (ex: Wiener's attack ou extensões).",
                                    "Implemente script para enviar plaintexts escolhidos e tentar fatorar n usando gcd ou algoritmos como Fermat.",
                                    "Recupere d aproximando via continued fractions se e pequeno."
                                  ],
                                  "verification": "Sucesso no ataque: recupere fatores de n ou d privado a partir de apenas chaves públicas e cifras escolhidas.",
                                  "estimatedTime": "90 minutes",
                                  "materials": "Python com sympy para fatoração (pip install sympy), simulador de oráculo de cifragem.",
                                  "tips": "Simule o oráculo como uma função que recebe m e retorna c usando chaves fixas secretas.",
                                  "learningObjective": "Executar praticamente um CPA para ver como plaintexts escolhidos vazam a chave privada.",
                                  "commonMistakes": "Escolher plaintexts grandes (>n); não simular corretamente o oráculo público."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações e Soluções para CPA em PKCs",
                                  "subSteps": [
                                    "Discuta por que padding (ex: OAEP) mitiga CPA: randomização e estrutura.",
                                    "Compare RSA sem padding vs. com PKCS#1 v1.5/OAEP.",
                                    "Debata cenários reais: ataques em implementações antigas como SSLv2.",
                                    "Crie um relatório resumindo passos do ataque e defesas.",
                                    "Explore extensões: hybrid attacks com side-channels."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como padding previne o ataque demonstrado.",
                                  "estimatedTime": "45 minutes",
                                  "materials": "Documentação RFC 8017 (OAEP), exemplos de código GitHub para RSA padded.",
                                  "tips": "Use ferramentas como CyberChef para visualizar paddings em cifras.",
                                  "learningObjective": "Concluir discussão conectando teoria à prática segura em criptosistemas.",
                                  "commonMistakes": "Subestimar importância de padding; achar que chaves grandes bastam."
                                }
                              ],
                              "practicalExample": "Simule um oráculo RSA com n=3233 (57*61), e=17. Envie m=2, obtenha c=1024; m=3, c=2465. Use diferenças para fatorar n via gcd(2^17 - 1024, 3233)=57, revelando chaves.",
                              "finalVerifications": [
                                "Explica corretamente como CPA explora determinismo em RSA sem padding.",
                                "Implementa e executa simulação de ataque com sucesso.",
                                "Identifica pelo menos 3 vulnerabilidades específicas do RSA textbook.",
                                "Descreve mecanismos de padding como OAEP e sua relação com CPA-security.",
                                "Discute limitações do ataque em cenários modernos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e mecânicas corretas (30%)",
                                "Implementação prática: código funcional e ataque bem-sucedido (30%)",
                                "Análise crítica: identificação de fraquezas e soluções (20%)",
                                "Clareza na discussão: exemplos e explicações acionáveis (10%)",
                                "Conexões interdisciplinares: menção a matemática e segurança (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, fatoração de inteiros e frações continuadas.",
                                "Segurança da Informação: Modelos de segurança (IND-CPA) e protocolos como TLS.",
                                "Programação: Implementação criptográfica em Python e depuração.",
                                "História da Computação: Evolução de padrões criptográficos pós-ataques."
                              ],
                              "realWorldApplication": "Em implementações legadas como protocolos obsoletos (SSLv3), CPAs em RSA sem padding permitiram roubo de chaves em ataques como POODLE/FREAK; hoje, reforça uso obrigatório de padding em bibliotecas como OpenSSL para proteger comunicações seguras em banking e e-commerce."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1",
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.4",
                            "name": "Avaliar Contra-medidas ao CPA",
                            "description": "Identificar modos de operação seguros (ex: CBC com IV aleatório) e esquemas probabilísticos que resistem a CPA básico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Vulnerabilidades do CPA em Modos Determinísticos",
                                  "subSteps": [
                                    "Relembre o conceito de CPA: atacante envia textos planos escolhidos e observa cifras correspondentes para deduzir a chave.",
                                    "Analise o modo ECB: demonstre como padrões em plaintexts repetidos vazam na ciphertext.",
                                    "Compare com modos sem IV: explique por que determinismo permite mapping único plaintext-ciphertext.",
                                    "Identifique falhas: discuta como um oráculo de encriptação facilita ataques lineares ou diferenciais básicos.",
                                    "Pratique com exemplo simples: encripte 'AAA...BBB...' em ECB e observe padrões."
                                  ],
                                  "verification": "Crie um diagrama mostrando como ECB falha em CPA e explique em 2-3 frases.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de modos AES (NIST SP 800-38A)",
                                    "Ferramenta online como CyberChef para simular ECB"
                                  ],
                                  "tips": "Use imagens de pinguins em ECB para visualizar vazamento de padrões intuitivamente.",
                                  "learningObjective": "Compreender por que modos determinísticos são vulneráveis a CPA básico.",
                                  "commonMistakes": [
                                    "Confundir CPA com CCA (Chosen Ciphertext Attack)",
                                    "Ignorar que ECB é determinístico mesmo com chaves aleatórias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Modos de Operação Seguros como CBC com IV Aleatório",
                                  "subSteps": [
                                    "Estude o modo CBC: explique o papel do IV na primeira iteração e chaining.",
                                    "Implemente CBC com IV fixo vs aleatório: mostre como IV fixo ainda permite ataques.",
                                    "Gere IV aleatório por mensagem: verifique que ciphertexts idênticos em plaintexts iguais produzem outputs diferentes.",
                                    "Simule CPA: tente deduzir chave enviando plaintexts múltiplos e analise se padrões persistem.",
                                    "Analise segurança: discuta provada segurança sob IND-CPA para CBC com IV aleatório."
                                  ],
                                  "verification": "Encripte o mesmo plaintext duas vezes com IVs diferentes e confirme saídas únicas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca Python cryptography ou OpenSSL",
                                    "Exemplos de código CBC no GitHub"
                                  ],
                                  "tips": "Sempre use IV de 128 bits para AES e nunca reuse em produção.",
                                  "learningObjective": "Identificar CBC com IV aleatório como contra-medida efetiva ao CPA.",
                                  "commonMistakes": [
                                    "Reutilizar IV para múltiplas mensagens",
                                    "Confundir IV com nonce ou chave"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Esquemas Probabilísticos e Randomização",
                                  "subSteps": [
                                    "Defina esquemas probabilísticos: encriptação usa random bits por mensagem para IND-CPA.",
                                    "Compare determinístico vs probabilístico: probabilístico resiste a mapping único.",
                                    "Estude padding como PKCS#7: como adiciona aleatoriedade efetiva.",
                                    "Examine autenticação: discuta AEAD como GCM, que combina confidencialidade e integridade contra CPA.",
                                    "Pratique: implemente encriptação probabilística simples com random prefix."
                                  ],
                                  "verification": "Explique em pseudocódigo como randomização impede dedução de chave em CPA.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo 'Probabilistic Encryption' de Goldwasser-Micali",
                                    "Ferramentas como CrypTool"
                                  ],
                                  "tips": "Lembre: segurança probabilística requer fresh randomness por encriptação.",
                                  "learningObjective": "Reconhecer esquemas probabilísticos como base para resistência a CPA.",
                                  "commonMistakes": [
                                    "Achar que padding sozinho basta sem IV",
                                    "Ignorar side-channel leaks em random generation"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Comparar Contra-medidas em Cenários Práticos",
                                  "subSteps": [
                                    "Compile tabela comparativa: ECB, CBC-IVfixo, CBC-IValeatório, GCM.",
                                    "Simule ataques: aplique CPA em cada e meça sucesso na dedução de chave.",
                                    "Avalie trade-offs: overhead computacional, tamanho de ciphertext, usabilidade.",
                                    "Discuta melhores práticas: prefira modos aprovados como AES-GCM para novos designs.",
                                    "Crie checklist: critérios para validar uma contra-medida (ex: IND-CPA security)."
                                  ],
                                  "verification": "Produza relatório curto avaliando 3 contra-medidas com prós/contras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Google Sheets para tabela",
                                    "Referências IETF RFC 5116"
                                  ],
                                  "tips": "Priorize modos com provada segurança em modelos padrão como IND-CPA.",
                                  "learningObjective": "Avaliar criticamente contra-medidas para resistir a CPA básico.",
                                  "commonMistakes": [
                                    "Subestimar necessidade de IV único",
                                    "Confundir resistência a CPA com CCA"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de chat seguro, use AES-CBC com IV aleatório gerado por os.urandom() para cada mensagem. Simule CPA: atacante envia 'hello' múltiplas vezes; ciphertexts variam, impedindo dedução de chave. Contrastar com ECB onde 'hello' sempre gera mesma ciphertext.",
                              "finalVerifications": [
                                "Explicar por que ECB falha em CPA mas CBC com IV aleatório resiste.",
                                "Identificar IV aleatório como essencial em 3 modos de operação comuns.",
                                "Diferenciar esquemas determinísticos de probabilísticos com exemplos.",
                                "Simular CPA em código e confirmar falha em contra-medida insegura.",
                                "Listar 3 critérios para validar uma contra-medida ao CPA.",
                                "Discutir impacto de reutilização de IV em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de modos seguros (CBC-IV aleatório, GCM).",
                                "Profundidade na explicação de randomização probabilística.",
                                "Capacidade de simular e analisar ataques CPA em exemplos.",
                                "Uso correto de terminologia (IND-CPA, IV, nonce).",
                                "Análise de trade-offs (segurança vs performance).",
                                "Criatividade em exemplos práticos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e aleatoriedade em criptosistemas.",
                                "Segurança da Informação: Protocolos TLS/HTTPS usando contra-medidas CPA.",
                                "Programação: Implementação segura de criptografia em Python/Java.",
                                "Ética: Implicações de falhas criptográficas em privacidade de dados."
                              ],
                              "realWorldApplication": "Em comunicações seguras como WhatsApp ou HTTPS (TLS 1.3 usa AEAD-GCM), contra-medidas ao CPA previnem que atacantes em MITM deduzam chaves de sessões, protegendo bilhões de mensagens diárias contra espionagem básica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Criptoanálise de Cifras Polialfabéticas",
                    "description": "Técnicas para quebrar cifras como Vigenère, usando comprimento de chave e análise de frequência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Determinação do Comprimento da Chave",
                        "description": "Técnicas para estimar o tamanho da chave em cifras polialfabéticas, como o método de Kasiski e o índice de coincidência de Friedman.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Aplicar o teste de Kasiski",
                            "description": "Identificar repetições de sequências de 3 ou mais letras no criptotexto e calcular as distâncias entre elas para encontrar fatores comuns que indicam o comprimento da chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o criptotexto e identificar sequências repetidas",
                                  "subSteps": [
                                    "Obtenha ou gere um criptotexto cifrado com cifra polialfabética (ex: Vigenère).",
                                    "Converta o texto para maiúsculas e remova espaços, pontuação ou caracteres não alfabéticos.",
                                    "Procure manualmente por sequências repetidas de 3 ou mais letras consecutivas (trigramas, tetragramas etc.).",
                                    "Registre cada ocorrência com sua posição inicial no texto (contando a partir de 1).",
                                    "Liste pelo menos 5-10 repetições relevantes para análise estatística confiável."
                                  ],
                                  "verification": "Verifique se você tem uma tabela com pelo menos 5 sequências repetidas, cada uma com posições iniciais anotadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Criptotexto exemplo (papel ou editor de texto)",
                                    "Papel quadriculado ou planilha Excel/Google Sheets para anotações"
                                  ],
                                  "tips": "Comece procurando trigramas comuns como 'THE' em inglês, mas foque em repetições idênticas independentemente do significado.",
                                  "learningObjective": "Identificar padrões repetidos no criptotexto que sugiram alinhamentos de chave.",
                                  "commonMistakes": [
                                    "Ignorar sequências curtas (menos de 3 letras)",
                                    "Contar posições incorretamente (off-by-one error)",
                                    "Incluir não-letras no texto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular distâncias entre ocorrências repetidas",
                                  "subSteps": [
                                    "Para cada sequência repetida encontrada, liste todas as suas posições iniciais.",
                                    "Calcule a distância entre cada par de posições: distância = posição_final - posição_inicial.",
                                    "Registre todas as distâncias em uma lista ou coluna separada na sua tabela.",
                                    "Arredonde distâncias para números inteiros e ignore distâncias muito pequenas (<10) que podem ser coincidências.",
                                    "Some ou agrupe distâncias semelhantes para facilitar a análise posterior."
                                  ],
                                  "verification": "Confirme que todas as distâncias foram calculadas corretamente comparando com um parceiro ou recalculando uma amostra.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha com posições das sequências do Step 1",
                                    "Calculadora ou função SUBTRAIR no Excel"
                                  ],
                                  "tips": "Use uma fórmula no Excel como =B2-A2 para automatizar cálculos em colunas.",
                                  "learningObjective": "Quantificar a periodicidade sugerida pelas repetições no criptotexto.",
                                  "commonMistakes": [
                                    "Calcular distância entre posições finais em vez de iniciais",
                                    "Incluir distâncias de sequências diferentes",
                                    "Não filtrar distâncias irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar fatores comuns das distâncias",
                                  "subSteps": [
                                    "Para cada distância calculada, liste seus fatores primos ou divisores (ex: 14 → 1,2,7,14).",
                                    "Agrupe as distâncias e identifique divisores comuns que aparecem frequentemente (ex: 4,8,12 sugerem múltiplos de 4).",
                                    "Conte a frequência de cada possível divisor comum nas distâncias.",
                                    "Priorize divisores que dividem a maioria (>50%) das distâncias.",
                                    "Crie uma tabela de frequência de divisores potenciais para o comprimento da chave."
                                  ],
                                  "verification": "Valide fatores listando-os e verificando divisibilidade (ex: 14 % 7 == 0).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de distâncias do Step 2",
                                    "Tabela de fatoração ou app online de fatores primos"
                                  ],
                                  "tips": "Fatores pequenos (3-10) são mais prováveis para chaves curtas; ignore 1.",
                                  "learningObjective": "Aplicar análise de fatores para detectar o período da cifra polialfabética.",
                                  "commonMistakes": [
                                    "Confundir fatores com múltiplos",
                                    "Ignorar frequência de aparição",
                                    "Listar fatores incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar e validar o comprimento provável da chave",
                                  "subSteps": [
                                    "Selecione o divisor mais frequente como candidato principal ao comprimento da chave (ex: 5 se comum).",
                                    "Teste candidatos dividindo o criptotexto em sub-alfabetos (ex: posições 1,6,11... para chave=5).",
                                    "Analise frequência de letras em cada sub-alfabeto para ver se aproxima distribuição monoalfabética (ex: E alta).",
                                    "Compare múltiplos candidatos e escolha o que melhor quebra a cifra.",
                                    "Documente a conclusão com evidências numéricas (frequências, índice de coincidência)."
                                  ],
                                  "verification": "O comprimento proposto deve permitir decifração parcial coerente ou IC próximo a 0.066 (inglês).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Criptotexto completo",
                                    "Ferramenta de análise de frequência (ex: site online ou Python simples)"
                                  ],
                                  "tips": "Use o Índice de Coincidência (IC) para validar: IC ≈ 1/26 para aleatório, 0.066 para inglês.",
                                  "learningObjective": "Integrar análise de Kasiski com validação para confirmar comprimento da chave.",
                                  "commonMistakes": [
                                    "Escolher divisor menos frequente",
                                    "Não validar com análise de frequência",
                                    "Assumir sem testar sub-alfabetos"
                                  ]
                                }
                              ],
                              "practicalExample": "Criptotexto: 'FUXVJRYWRKAFJALLDEQHGXJRYW'. Repetições: 'JRY' em pos. 5 e 15 (dist=10), 'JX' em pos. 12 e 22 (dist=10), 'FJAL' em pos. 8 e 18 (dist=10). Fatores comuns: 2,5,10 → Comprimento chave provável=5. Divida em 5 sub-alfabetos e analise frequências.",
                              "finalVerifications": [
                                "Lista completa de ≥5 repetições com posições corretas.",
                                "Distâncias calculadas e fatores listados sem erros aritméticos.",
                                "Candidato a comprimento da chave justificado por frequência de divisores.",
                                "Validação via sub-alfabetos mostra frequências plausíveis (ex: E/Z comuns).",
                                "Índice de Coincidência (IC) dos sub-alfabetos próximo a 0.066.",
                                "Explicação escrita conectando Kasiski à quebra da cifra."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de repetições (≥80% corretas).",
                                "Correção matemática em distâncias e fatores (100% sem erros).",
                                "Seleção lógica do comprimento da chave baseada em evidências.",
                                "Validação eficaz com análise de frequência ou IC.",
                                "Documentação clara e organizada (tabelas, explicações).",
                                "Criatividade em lidar com ambiguidades ou poucos dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números, fatoração e divisibilidade.",
                                "Estatística: Análise de frequências e distribuições probabilísticas.",
                                "História: Contribuições de Kasiski na criptoanálise do séc. XIX.",
                                "Programação: Implementar Kasiski automatizado em Python.",
                                "Lógica e resolução de problemas: Padrões e inferência dedutiva."
                              ],
                              "realWorldApplication": "Usado na quebra de cifras Vigenère durante a Guerra Civil Americana e inspirou máquinas como Enigma na WWII; hoje aplicado em cibersegurança para analisar cifras fracas em comunicações antigas ou vulnerabilidades em protocolos criptográficos modernos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Calcular o Índice de Coincidência",
                            "description": "Computar o IC do criptotexto inteiro e de substrings deslocadas para identificar o comprimento da chave onde o IC se aproxima do valor esperado para o idioma (ex: 0.066 para português).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a fórmula e o conceito do Índice de Coincidência (IC)",
                                  "subSteps": [
                                    "Estude a fórmula do IC: IC = Σ (f_i * (f_i - 1)) / (N * (N - 1)), onde f_i é a frequência absoluta da letra i e N é o comprimento do texto.",
                                    "Aprenda que o IC esperado para o português é aproximadamente 0.066, indicando aleatoriedade baixa em textos naturais.",
                                    "Compare com IC aleatório (~0.038 para 26 letras), que é menor.",
                                    "Revise o propósito: detectar periodicidade em cifras polialfabéticas.",
                                    "Anote exemplos de frequências em textos plaintext em português."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e o valor esperado para português, com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de frequências de letras em português",
                                    "Calculadora"
                                  ],
                                  "tips": "Memorize a fórmula focando no numerador (combinações de letras iguais) e denominador (total possível).",
                                  "learningObjective": "Entender matematicamente o IC e seu significado criptoanalítico.",
                                  "commonMistakes": [
                                    "Confundir frequência absoluta com relativa",
                                    "Esquecer de subtrair 1 no numerador",
                                    "Ignorar maiúsculas/minúsculas no pré-processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e calcular o IC do criptotexto inteiro",
                                  "subSteps": [
                                    "Limpe o criptotexto: converta para maiúsculas, remova não-letras e espaços.",
                                    "Conte a frequência absoluta de cada letra (A-Z).",
                                    "Aplique a fórmula do IC passo a passo: calcule Σ f_i*(f_i-1), multiplique N*(N-1).",
                                    "Compare o IC calculado com o esperado (0.066) e aleatório (0.038).",
                                    "Registre o resultado em uma tabela."
                                  ],
                                  "verification": "Mostre o criptotexto limpo, tabela de frequências e IC calculado com todos os passos aritméticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Criptotexto exemplo",
                                    "Planilha Excel ou papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Use contadores manuais ou função COUNTIF no Excel para frequências rápidas.",
                                  "learningObjective": "Aplicar a fórmula IC em um texto completo de forma precisa.",
                                  "commonMistakes": [
                                    "Incluir não-letras no cálculo",
                                    "Erro aritmético no Σ f_i*(f_i-1)",
                                    "Usar N incorreto (comprimento errado)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar substrings deslocadas do criptotexto",
                                  "subSteps": [
                                    "Defina o período máximo de análise (ex: comprimento/4, até 20).",
                                    "Para cada deslocamento k=0 a período: extraia substring de posições i onde i ≡ k mod período.",
                                    "Garanta que cada substring tenha pelo menos 30-50 letras para confiabilidade.",
                                    "Liste as substrings em uma tabela: k=0, k=1, etc.",
                                    "Visualize com alinhamento para verificar extração."
                                  ],
                                  "verification": "Apresente tabela com pelo menos 5 substrings corretas extraídas de um criptotexto exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Criptotexto preparado",
                                    "Papel ou editor de texto para extração"
                                  ],
                                  "tips": "Comece com k pequeno e use cor para destacar posições em um exemplo curto.",
                                  "learningObjective": "Dominar a divisão do texto em grupos por deslocamento para análise de chave.",
                                  "commonMistakes": [
                                    "Deslocamento errado (confundir mod k)",
                                    "Substrings muito curtas",
                                    "Incluir posições incorretas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular IC das substrings e identificar comprimento da chave",
                                  "subSteps": [
                                    "Para cada substring, repita o cálculo de IC (frequências e fórmula).",
                                    "Plote ou tabule os ICs vs. deslocamento k.",
                                    "Identifique picos próximos a 0.066: o período da chave é o espaçamento entre picos.",
                                    "Teste hipóteses: verifique se múltiplos de um período candidato alinham picos.",
                                    "Conclua com o comprimento provável da chave."
                                  ],
                                  "verification": "Forneça tabela de ICs por k, gráfico simples e justificativa do comprimento da chave.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabelas das steps anteriores",
                                    "Gráfico de linhas (papel ou Excel)",
                                    "Calculadora"
                                  ],
                                  "tips": "Procure padrões repetitivos nos picos para confirmar.",
                                  "learningObjective": "Interpretar ICs deslocados para determinar comprimento da chave.",
                                  "commonMistakes": [
                                    "Interpretar ruído como pico",
                                    "Ignorar comprimento insuficiente das substrings",
                                    "Não testar múltiplos períodos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar a análise",
                                  "subSteps": [
                                    "Recalcule ICs com período candidato para confirmar agrupamento.",
                                    "Compare com outros métodos (Kasiski) se disponível.",
                                    "Documente suposições e limitações (ex: texto curto).",
                                    "Teste com um plaintext conhecido cifrado para validar.",
                                    "Registre lições aprendidas."
                                  ],
                                  "verification": "Relatório final com validação e possível quebra parcial da cifra.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados anteriores",
                                    "Ferramenta de cifra Vigenère para teste"
                                  ],
                                  "tips": "Automatize em Python se possível para verificação rápida.",
                                  "learningObjective": "Refinar análise e validar resultados criptoanalíticos.",
                                  "commonMistakes": [
                                    "Aceitar primeiro pico sem validação",
                                    "Não considerar ruído em textos curtos"
                                  ]
                                }
                              ],
                              "practicalExample": "Criptotexto: 'XMCKL VDRNF UDXNZ VDRNF UDXNZ' (chave de comprimento 6). Limpe: XMCKLVDRNFUDXNZVDRNFUDXNZ. Calcule IC inteiro ≈0.045 (aleatório). Substrings k=0: XDVX... IC≈0.067; k=5: LNFU... IC≈0.065. Picos em múltiplos de 6 confirmam chave=6.",
                              "finalVerifications": [
                                "IC inteiro calculado corretamente e comparado ao esperado.",
                                "Substrings deslocadas extraídas sem erros para período testado.",
                                "ICs das substrings plotados e picos identificados.",
                                "Comprimento da chave proposto com justificativa baseada em picos.",
                                "Validação com recálculo em grupos do período candidato.",
                                "Documentação completa de todos os cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da fórmula IC (erro <0.001).",
                                "Correta extração e comprimento mínimo das substrings.",
                                "Identificação correta de pelo menos 80% dos picos esperados.",
                                "Interpretação lógica do comprimento da chave.",
                                "Clareza na documentação e visualizações.",
                                "Tratamento de edge cases como textos curtos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Frequências e probabilidade condicional.",
                                "Matemática: Somas e produtos em fórmulas combinatórias.",
                                "Programação: Implementação em Python para automação de IC.",
                                "Língua Portuguesa: Análise de frequências linguísticas.",
                                "História: Criptografia em contextos militares/históricos."
                              ],
                              "realWorldApplication": "Usado em forensics digitais para quebrar cifras em comunicações interceptadas, análise de segurança em cibersegurança e ferramentas como Cryptool para detecção de chaves em ataques a Vigenère."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Combinar métodos para estimar comprimento",
                            "description": "Usar resultados de Kasiski e IC para confirmar o período da chave, resolvendo ambiguidades comuns em cifras Vigenère.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Listar Resultados do Método Kasiski",
                                  "subSteps": [
                                    "Identifique todas as repetições de sequências de 3 ou mais letras no texto cifrado.",
                                    "Meça a distância entre cada par de repetições idênticas.",
                                    "Calcule o maior divisor comum (GCD) das distâncias para obter candidatos iniciais ao comprimento da chave.",
                                    "Liste os 3-5 candidatos mais prováveis, priorizando GCDs menores e frequentes.",
                                    "Anotar frequência de cada fator para avaliar confiança."
                                  ],
                                  "verification": "Uma tabela com repetições, distâncias, GCDs e lista de candidatos Kasiski (ex: 4, 6, 8).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto cifrado impresso ou digital",
                                    "Calculadora ou spreadsheet para GCD",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Priorize repetições longas (>4 letras) para maior confiabilidade; use ferramenta online para GCD se manual for lento.",
                                  "learningObjective": "Extrair e priorizar candidatos de comprimento de chave a partir de análise Kasiski.",
                                  "commonMistakes": [
                                    "Incluir repetições curtas (<3 letras) que geram ruído",
                                    "Calcular GCD incorretamente, ignorando múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e Analisar Índice de Coincidências (IC)",
                                  "subSteps": [
                                    "Para cada candidato Kasiski (ex: 4,6,8), divida o texto cifrado em grupos alfabéticos correspondentes ao comprimento.",
                                    "Calcule a frequência de cada letra em cada grupo.",
                                    "Compute IC para cada comprimento: soma (freq_i * (freq_i -1)) / (N*(N-1)), onde N é comprimento do grupo.",
                                    "Compare ICs calculados com valores esperados: ~0.066 para inglês monoalfabético, mais baixo para polialfabético.",
                                    "Identifique comprimentos onde ICs dos grupos são próximos ao monoalfabético (~0.04-0.07)."
                                  ],
                                  "verification": "Tabela com IC por candidato, destacando os com ICs elevados e próximos ao esperado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Texto cifrado",
                                    "Spreadsheet (Excel/Google Sheets) para frequências e fórmulas IC",
                                    "Tabela de IC linguístico de referência"
                                  ],
                                  "tips": "Automatize cálculos em spreadsheet para precisão; teste comprimentos múltiplos dos candidatos Kasiski.",
                                  "learningObjective": "Aplicar IC para validar candidatos de comprimento de chave em cifras polialfabéticas.",
                                  "commonMistakes": [
                                    "Erro na divisão de grupos (off-by-one)",
                                    "Usar fórmula errada para IC, confundindo com chi-quadrado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Combinar Resultados Kasiski e IC",
                                  "subSteps": [
                                    "Alinhe listas de candidatos: destaque comprimentos comuns ou múltiplos entre Kasiski e IC alto.",
                                    "Pontue candidatos: +2 para comum, +1 para IC próximo ao esperado, +1 para GCD frequente.",
                                    "Elimine candidatos fracos (ex: sem suporte duplo ou IC muito baixo).",
                                    "Selecione top 2-3 candidatos finais baseados em pontuação.",
                                    "Documente razões para cada escolha em uma tabela comparativa."
                                  ],
                                  "verification": "Tabela de comparação com pontuações e top candidatos selecionados (ex: comprimento 4 como principal).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas de Kasiski e IC do passo anterior",
                                    "Papel ou quadro para pontuação"
                                  ],
                                  "tips": "Use múltiplos: se Kasiski dá 4, cheque IC em 4,8,12; priorize o menor com suporte forte.",
                                  "learningObjective": "Integrar evidências de múltiplos métodos para uma estimativa robusta do comprimento da chave.",
                                  "commonMistakes": [
                                    "Ignorar múltiplos harmônicos",
                                    "Superestimar um método isolado sem cross-validação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Ambiguidade e Confirmar Comprimento da Chave",
                                  "subSteps": [
                                    "Para candidatos ambíguos, aplique teste parcial: tente decifrar com chave parcial e cheque digramas ingleses.",
                                    "Use método Friedman em sub-texto ou teste de autocorrelação para refinar.",
                                    "Teste decifração completa com candidato top e avalie legibilidade/coerência.",
                                    "Se ambiguidade persistir, colete mais texto cifrado ou use chi-quadrado em decifra parcial.",
                                    "Confirme o comprimento final com >80% de suporte combinado."
                                  ],
                                  "verification": "Relatório de confirmação com teste parcial bem-sucedido e comprimento final justificado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de decifração Vigenère (online ou script Python)",
                                    "Tabelas de frequência inglês",
                                    "Texto cifrado"
                                  ],
                                  "tips": "Sempre teste decifração parcial primeiro – é o verificador definitivo; pare se texto faz sentido.",
                                  "learningObjective": "Resolver conflitos comuns e validar estimativa final do período da chave.",
                                  "commonMistakes": [
                                    "Não testar decifração, confiando só em números",
                                    "Aceitar ambiguidade sem teste prático"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto cifrado: 'KRMXYBUARZ...'. Kasiski encontra distâncias 8,12,16 → GCD=4 (candidatos 4,8). IC: 0.068 para 4 (alto), 0.045 para 8 (baixo). Combinação confirma 4. Decifração parcial revela 'THEQUICK...' – chave comprimento 4 confirmada.",
                              "finalVerifications": [
                                "Lista candidatos Kasiski e IC corretamente de um texto dado.",
                                "Pontua e seleciona comprimento top com justificativa escrita.",
                                "Resolve ambiguidade em exemplo com múltiplos candidatos usando decifração parcial.",
                                "Explica por que combinação é superior a método único.",
                                "Aplica processo completo em nova cifra Vigenère em <90 minutos.",
                                "Identifica erros comuns em análises de pares de alunos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista de candidatos Kasiski (GCD correto >90%).",
                                "Cálculo IC exato e interpretação alinhada a valores linguísticos.",
                                "Pontuação combinada lógica, priorizando evidências duplas.",
                                "Resolução efetiva de ambiguidade com teste prático.",
                                "Documentação clara com tabelas e justificativas.",
                                "Tempo total dentro de 110 minutos com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de GCD e estatística descritiva (IC).",
                                "Estatística: Análise de frequências e testes de hipóteses (IC vs. esperado).",
                                "História: Criptoanálise na Segunda Guerra Mundial (Enigma/Bletchley Park).",
                                "Programação: Implementar scripts para automação de IC/GCD.",
                                "Língua Portuguesa/Inglês: Análise de n-gramas e legibilidade textual."
                              ],
                              "realWorldApplication": "Em cibersegurança, analistas combinam Kasiski/IC para quebrar cifras Vigenère variantes em comunicações antigas ou malwares; essencial em forensics digital, CTFs e validação de sistemas criptográficos modernos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Análise de Frequência em Subalfabetos",
                        "description": "Dividir o criptotexto em cosets baseados no comprimento da chave e realizar análise de frequência em cada grupo monoalfabético.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Dividir o criptotexto em cosets",
                            "description": "Separar o texto cifrado em M grupos (onde M é o comprimento da chave), cada um correspondendo a uma posição da chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Criptotexto para Divisão",
                                  "subSteps": [
                                    "Remover todos os espaços, pontuações e caracteres não alfabéticos do criptotexto.",
                                    "Converter todas as letras para maiúsculas para uniformidade.",
                                    "Numerar as posições das letras de 0 até N-1, onde N é o comprimento final.",
                                    "Contar e registrar o comprimento total N do criptotexto limpo.",
                                    "Verificar visualmente se não há erros de transcrição."
                                  ],
                                  "verification": "Criptotexto limpo listado com posições numeradas e comprimento N confirmado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Criptotexto original impresso"
                                  ],
                                  "tips": "Trabalhe em uma linha reta para facilitar a numeração das posições.",
                                  "learningObjective": "Garantir que o criptotexto esteja padronizado e pronto para divisão precisa.",
                                  "commonMistakes": [
                                    "Manter espaços ou minúsculas",
                                    "Erros na numeração sequencial das posições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Confirmar M e Inicializar os Cosets",
                                  "subSteps": [
                                    "Confirmar o valor de M (comprimento da chave) a partir da análise anterior.",
                                    "Criar M listas ou colunas vazias, rotuladas como Coset 0, Coset 1, ..., Coset (M-1).",
                                    "Escrever cabeçalhos claros para cada coset acima das colunas.",
                                    "Preparar espaço suficiente para aproximadamente N/M letras por coset.",
                                    "Anotar o valor de M no topo para referência."
                                  ],
                                  "verification": "M colunas vazias criadas e rotuladas corretamente de 0 a M-1.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Use colunas verticais para facilitar a adição sequencial de letras.",
                                  "learningObjective": "Entender que cada coset corresponde a uma posição fixa na chave.",
                                  "commonMistakes": [
                                    "Confundir a ordem dos cosets (começar de 1 em vez de 0)",
                                    "Usar M incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Distribuir as Letras nos Cosets",
                                  "subSteps": [
                                    "Iniciar pelo i=0: calcular resíduo k = i % M e adicionar a letra i ao Coset k.",
                                    "Incrementar i em 1, repetir o cálculo k = i % M e adicionar à respectiva lista.",
                                    "Continuar o processo para todas as N posições, mantendo ordem sequencial em cada coset.",
                                    "Manter um contador de progresso para rastrear i atual.",
                                    "Pausar periodicamente para verificar se as adições estão corretas."
                                  ],
                                  "verification": "Todas as N letras foram distribuídas; cada coset contém letras de posições congruentes módulo M.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel com criptotexto numerado",
                                    "Calculadora para % se N grande"
                                  ],
                                  "tips": "Visualize o processo como 'pular' a cada M posições para o mesmo coset.",
                                  "learningObjective": "Dominar o uso da operação módulo para agrupar posições equivalentes.",
                                  "commonMistakes": [
                                    "Calcular módulo incorretamente (ex: usar divisão inteira)",
                                    "Adicionar letras fora de ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Finalizar os Cosets",
                                  "subSteps": [
                                    "Contar o número de letras em cada coset e registrar.",
                                    "Verificar se os tamanhos são floor(N/M) ou ceil(N/M) e soma total = N.",
                                    "Conferir aleatoriamente 3-5 posições: confirmar i % M leva à letra correta no coset.",
                                    "Rotular cada coset com seu índice e comprimento.",
                                    "Preparar os cosets para análise de frequência subsequente."
                                  ],
                                  "verification": "Contagens de letras corretas, soma = N, e verificações spot-check aprovadas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel com cosets preenchidos",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece verificando os cosets menores primeiro para confiança rápida.",
                                  "learningObjective": "Validar a integridade da divisão para análise confiável.",
                                  "commonMistakes": [
                                    "Ignorar desbalanceamento natural dos cosets",
                                    "Erros aritméticos em contagens"
                                  ]
                                }
                              ],
                              "practicalExample": "Criptotexto: 'ATTACKATDAWN' (N=12, M=3).\nCoset 0 (pos %3==0): A(0), A(3), A(6), A(9) → 'AAAA'\nCoset 1 (pos %3==1): T(1), C(4), T(7), W(10) → 'TCTW'\nCoset 2 (pos %3==2): T(2), K(5), D(8), N(11) → 'TKDN'",
                              "finalVerifications": [
                                "Soma dos comprimentos dos cosets equals N.",
                                "Cada coset contém apenas letras de posições i onde i % M == índice do coset.",
                                "Tamanhos dos cosets são consistentes: floor(N/M) ou ceil(N/M).",
                                "Nenhuma letra duplicada ou faltando.",
                                "Cosets rotulados corretamente e legíveis.",
                                "Preparados para análise de frequência individual."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na distribuição de todas as letras.",
                                "Correta aplicação da operação módulo em todas as posições.",
                                "Tamanhos de cosets validados matematicamente.",
                                "Processo executado de forma eficiente e organizada.",
                                "Compreensão demonstrada na verificação e explicação do método.",
                                "Preparação clara para passos subsequentes de criptoanálise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e congruências.",
                                "Estatística: Agrupamento de dados para análise de frequências.",
                                "História: Técnicas usadas na quebra de códigos Vigenère no século XIX.",
                                "Programação: Implementável com loops for e listas em Python ou JavaScript."
                              ],
                              "realWorldApplication": "Essa divisão em cosets é o passo crucial na criptoanálise de cifras polialfabéticas como Vigenère, permitindo análise de frequência separada por subalfabetos. Historicamente, usada por Charles Babbage para decifrar mensagens diplomáticas britânicas e em inteligência militar moderna para quebrar comunicações cifradas sem computador."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Realizar análise de frequência por coset",
                            "description": "Calcular frequências relativas em cada coset e compará-las com a distribuição esperada de letras no idioma plaintext (ex: E mais frequente em português).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ciphertext e identificar os cosets",
                                  "subSteps": [
                                    "Obtenha o ciphertext e determine o comprimento da chave (ex: via Kasiski ou coincidência de índices).",
                                    "Divida o ciphertext em cosets baseados no comprimento da chave (cada coset corresponde a uma posição na chave).",
                                    "Liste as letras de cada coset separadamente, ignorando espaços ou não-letras.",
                                    "Crie uma tabela para cada coset com colunas para letras observadas.",
                                    "Registre o tamanho total de cada coset para cálculos futuros."
                                  ],
                                  "verification": "Confirme que cada coset contém apenas letras da posição correspondente e que o total de letras soma corretamente com o ciphertext.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ciphertext impresso ou digital",
                                    "Papel quadriculado ou planilha Excel/Google Sheets",
                                    "Chave estimada ou comprimento"
                                  ],
                                  "tips": "Comece com um comprimento de chave pequeno (ex: 3-5) para prática; use cor para diferenciar cosets visualmente.",
                                  "learningObjective": "Entender como subalfabetos (cosets) são formados em cifras polialfabéticas.",
                                  "commonMistakes": [
                                    "Confundir posições dos cosets",
                                    "Incluir letras de outros cosets",
                                    "Esquecer de remover não-letras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular frequências absolutas em cada coset",
                                  "subSteps": [
                                    "Para cada coset, conte o número de ocorrências de cada letra do alfabeto (A-Z).",
                                    "Registre as contagens em uma tabela por coset.",
                                    "Some as contagens para verificar o tamanho do coset.",
                                    "Identifique letras ausentes (frequência 0).",
                                    "Ordene as letras por frequência decrescente para visualização."
                                  ],
                                  "verification": "As somas das frequências absolutas devem igualar o tamanho do coset; verifique contagens manuais com uma segunda pessoa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabelas de cosets do Step 1",
                                    "Calculadora ou contador digital",
                                    "Alfabeto impresso"
                                  ],
                                  "tips": "Use traços ou marcas para contar à mão; automatize com fórmula COUNTIF no Excel para cosets longos.",
                                  "learningObjective": "Dominar o cálculo de contagens absolutas em subconjuntos de texto.",
                                  "commonMistakes": [
                                    "Contar maiúsculas/minúsculas diferentemente",
                                    "Erros de soma nas contagens",
                                    "Ignorar letras raras"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular frequências relativas por coset",
                                  "subSteps": [
                                    "Para cada letra em um coset, divida a frequência absoluta pelo tamanho do coset e multiplique por 100 para porcentagem.",
                                    "Crie uma nova tabela com frequências relativas arredondadas a 2 casas decimais.",
                                    "Compare visualmente as top 5 letras mais frequentes em cada coset.",
                                    "Normalize se necessário para alfabeto de 26 letras.",
                                    "Grave as frequências em gráfico de barras para cada coset."
                                  ],
                                  "verification": "Soma das frequências relativas deve ser 100%; teste com coset pequeno conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas de frequências absolutas",
                                    "Calculadora científica",
                                    "Software de gráficos (Excel ou Python Matplotlib)"
                                  ],
                                  "tips": "Use fórmula =CONTAGEM/TOTAL*100 no Excel; foque em precisão para letras comuns.",
                                  "learningObjective": "Converter contagens absolutas em distribuições probabilísticas relativas.",
                                  "commonMistakes": [
                                    "Dividir pelo alfabeto total em vez do coset size",
                                    "Arredondamento excessivo perdendo precisão",
                                    "Esquecer de multiplicar por 100"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com distribuição esperada e interpretar",
                                  "subSteps": [
                                    "Obtenha tabela de frequências portuguesas (ex: A:12.7%, O:10.7%, E:10.2%, S:6.5%).",
                                    "Para cada coset, alinhe as frequências relativas com a tabela esperada e calcule desvios (diferença absoluta).",
                                    "Identifique o shift César que minimiza desvios (ex: letra mais freq no coset -> E).",
                                    "Some chi-quadrado ou use métrica de similaridade para ranking de shifts.",
                                    "Registre hipóteses de plaintext para cada coset."
                                  ],
                                  "verification": "O shift proposto deve alinhar top letras do coset com as mais comuns em PT; teste descriptografando um trecho.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de freq PT (impressa)",
                                    "Lista de shifts possíveis (0-25)",
                                    "Ferramenta de descriptografia Vigenère parcial"
                                  ],
                                  "tips": "Comece comparando apenas top 3 letras; use chi-quadrado para objetividade: Σ((obs-exp)^2/exp).",
                                  "learningObjective": "Aplicar análise estatística para quebrar subchaves em polialfabéticas.",
                                  "commonMistakes": [
                                    "Usar freq inglês em vez de PT",
                                    "Ignorar cosets pequenos (ruído alto)",
                                    "Não considerar ruído em textos curtos"
                                  ]
                                }
                              ],
                              "practicalExample": "Ciphertext Vigenère: 'CRIPTOANALISE' com chave len=3. Coset 1 (pos 1): C,R,I,T,A,N,L,S,E (9 letras). Freq abs: C1,R1,I1,T1,A1,N1,L1,S1,E1. Rel: ~11% cada. Comparar com PT: mais uniformes que esperado -> shift para alinhar 'E' max. Coset realignado sugere key 'ABC'.",
                              "finalVerifications": [
                                "Frequências relativas somam 100% por coset.",
                                "Top letras de cada coset mapeiam logicamente para PT comuns via shift.",
                                "Desvio total (chi-quadrado) < threshold (ex: <50 para cosets >50 letras).",
                                "Descriptografia parcial produz texto coerente em PT.",
                                "Todos cosets processados sem erros de contagem.",
                                "Gráficos mostram similaridade visual com freq PT."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas contagens absolutas e relativas (erro <1%).",
                                "Correta identificação e cálculo de shifts por coset.",
                                "Interpretação estatística válida (uso de desvios ou chi-quadrado).",
                                "Apresentação clara de tabelas e gráficos.",
                                "Aplicação correta ao contexto polialfabético.",
                                "Detecção de limitações (ex: cosets pequenos)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições de frequência e testes qui-quadrado.",
                                "Probabilidade: Modelos de linguagem e entropia.",
                                "Linguística: Análise de corpora textuais em PT.",
                                "Matemática: Aritmética modular em shifts César.",
                                "História: Criptoanálise na Segunda Guerra Mundial."
                              ],
                              "realWorldApplication": "Em inteligência de sinais (SIGINT), analistas usam isso para quebrar mensagens Vigenère em comunicações inimigas, como na Enigma ou códigos diplomáticos modernos, identificando padrões linguísticos para descriptografar sem chave."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Identificar deslocamentos monoalfabéticos",
                            "description": "Mapear a letra mais frequente de cada coset para a mais comum no plaintext para estimar o shift da cifra César equivalente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ciphertext e Identificar Cosets",
                                  "subSteps": [
                                    "Obtenha o ciphertext e determine o comprimento da chave presumido (ex: via Kasiski ou coincidência de índices).",
                                    "Divida o ciphertext em cosets correspondentes a cada posição da chave (coset 0: posições 0, len_key, 2*len_key; etc.).",
                                    "Escreva cada coset separadamente para análise isolada.",
                                    "Conte o número de letras em cada coset para garantir amostra suficiente (mínimo 20-50 letras).",
                                    "Registre o alfabeto usado (assuma maiúsculas A-Z, ignore não-letras)."
                                  ],
                                  "verification": "Confirme que cada coset está corretamente segmentado e sem sobreposições ou erros de indexação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ciphertext impresso ou digital, papel quadriculado, lápis, calculadora para contagens.",
                                  "tips": "Use cores diferentes para marcar cada coset visualmente.",
                                  "learningObjective": "Compreender a estrutura de cosets em cifras polialfabéticas como base para análise monoalfabética.",
                                  "commonMistakes": "Confundir posições de cosets (ex: começar coset 1 em posição 1 em vez de 0-based); ignorar letras não-alfabéticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Frequências de Letras em Cada Coset",
                                  "subSteps": [
                                    "Para cada coset, crie uma tabela de frequência contando ocorrências de cada letra (A-Z).",
                                    "Calcule a frequência relativa (ocorrências / total de letras no coset).",
                                    "Identifique as 3-5 letras mais frequentes em cada coset.",
                                    "Compare visualmente com tabela padrão de frequências inglesas (E:12.7%, T:9.1%, A:8.2%, etc.).",
                                    "Anote a letra dominante (mais frequente) em cada coset."
                                  ],
                                  "verification": "Tabela de frequências soma 100% do comprimento do coset; top letras fazem sentido comparadas a plaintext padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de frequências padrão do inglês impressa, planilha Excel ou papel para contagens.",
                                  "tips": "Agrupe letras em colunas para contagem rápida; use traços para marcar ocorrências.",
                                  "learningObjective": "Aplicar análise de frequência para isolar padrões monoalfabéticos em subalfabetos.",
                                  "commonMistakes": "Erros de contagem aritmética; não normalizar frequências para comparação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Letra Mais Frequente e Estimar Shift",
                                  "subSteps": [
                                    "Para cada coset, pegue a letra mais frequente no ciphertext (C_freq).",
                                    "Mapeie C_freq para 'E' (mais comum em plaintext inglês): shift = (posição_C_freq - posição_E) mod 26.",
                                    "Converta letras para números (A=0, B=1, ..., Z=25) para cálculo preciso.",
                                    "Calcule shifts para 2-3 letras top como verificação cruzada.",
                                    "Registre o shift estimado para cada coset (ex: coset 0: shift 3, coset 1: shift 10)."
                                  ],
                                  "verification": "Shifts calculados são inteiros entre 0-25; mapeamento reverso de 'E' + shift resulta em C_freq.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela alfabética numerada (A=0 a Z=25), calculadora modular.",
                                  "tips": "Lembre: shift = (C - P) mod 26, onde P='E'=4.",
                                  "learningObjective": "Estimar shifts César equivalentes via mapeamento de frequências pico.",
                                  "commonMistakes": "Esquecer módulo 26 (shifts negativos ou >25); usar minúsculas ou ignorar case."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Shifts e Reconstruir Chave Parcial",
                                  "subSteps": [
                                    "Aplique shifts a todo coset para obter plaintext parcial e cheque legibilidade.",
                                    "Verifique consistência com 2ª/3ª letras frequentes (ex: T->2ª mais freq no coset).",
                                    "Converta shifts em letras de chave: key_letter = (shift + 'A') mod 26? Não: para Vigenère, key = (P - C) mod 26, mas foque em shift.",
                                    "Identifique padrões ou palavras conhecidas no plaintext decifrado.",
                                    "Ajuste shifts se necessário baseado em validação."
                                  ],
                                  "verification": "Plaintext parcial contém >50% letras comuns inglês e fragmentos legíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Alfabeto de César para cada shift, ferramenta de decifração manual ou online simples.",
                                  "tips": "Teste shifts vizinhos (±1) se dúvida.",
                                  "learningObjective": "Validar estimativas de shift através de decifração e análise qualitativa.",
                                  "commonMistakes": "Não validar com múltiplas letras; assumir shift perfeito sem checagem."
                                }
                              ],
                              "practicalExample": "Ciphertext Vigenère (chave 'KEY', len=3): 'KDFHRUVDUW'... Coset 0 (K,D,H,R,U...): freq top 'U'(21). Shift=(21-4) mod26=17 -> aplica shift17: K->D, D->Q, etc. -> 'THERE...'. Coset1 top freq, etc. Resulta shifts estimados 10,3,24 -> chave parcial 'K','D','Y'.",
                              "finalVerifications": [
                                "Todos cosets têm letra top mapeada corretamente para 'E'.",
                                "Shifts produzidos são consistentes (0-25) e únicos por coset.",
                                "Decifração parcial revela texto inglês legível (>40% cobertura).",
                                "Frequências secundárias alinham com plaintext padrão.",
                                "Nenhum erro de segmentação ou contagem detectado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cosets (100% correto).",
                                "Cálculo exato de frequências e top letras (erro <5%).",
                                "Shifts corretos via fórmula modular (todos matches).",
                                "Validação eficaz com exemplos de plaintext.",
                                "Relatório claro com tabelas e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e estatística de frequências.",
                                "Estatística: Análise de distribuições e testes de hipótese simples.",
                                "História: Uso de análise de frequência na quebra de Enigma (WWII).",
                                "Linguística: Padrões de frequência em idiomas naturais."
                              ],
                              "realWorldApplication": "Em cibersegurança, quebra clássica de cifras Vigenère em mensagens históricas ou CTFs; base para ferramentas automatizadas como em forensics digitais ou análise de malware ofuscado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Reconstrução da Chave e Descriptografia",
                        "description": "Usar as análises anteriores para derivar a chave completa e descriptografar o texto.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Derivar letras da chave",
                            "description": "Para cada coset, subtrair o shift estimado da letra mais frequente para encontrar a letra correspondente da chave Vigenère.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar análise de frequência no coset selecionado",
                                  "subSteps": [
                                    "Liste todas as letras pertencentes ao coset específico (posições congruentes módulo do comprimento estimado da chave).",
                                    "Conte a ocorrência de cada letra única no coset, ignorando maiúsculas/minúsculas e considerando apenas letras do alfabeto.",
                                    "Identifique a letra com a maior frequência absoluta ou relativa.",
                                    "Registre a tabela de frequências para referência futura."
                                  ],
                                  "verification": "A tabela de frequências está completa, soma total igual ao tamanho do coset, e a letra mais frequente está destacada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Texto cifrado",
                                    "Papel e lápis ou planilha digital",
                                    "Tabela do alfabeto (A-Z)"
                                  ],
                                  "tips": [
                                    "Use uma tabela ou histograma para visualizar frequências; foque em cosets com pelo menos 20-30 letras para confiabilidade."
                                  ],
                                  "learningObjective": "Dominar o cálculo preciso de frequências em subconjuntos de texto cifrado.",
                                  "commonMistakes": [
                                    "Incluir letras de cosets errados",
                                    "Esquecer de normalizar case (maiúscula/minúscula)",
                                    "Contar não-letras como espaços ou pontuação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar o shift assumindo correspondência com a letra mais frequente do plaintext",
                                  "subSteps": [
                                    "Atribua valores numéricos às letras: A=0, B=1, ..., Z=25.",
                                    "Assuma que a letra mais frequente no plaintext é 'E' (valor 4 no alfabeto inglês).",
                                    "Calcule o shift: shift = (valor_numérico_da_letra_mais_frequente_no_coset - 4) mod 26."
                                  ],
                                  "verification": "O shift calculado está entre 0 e 25 e pode ser verificado manualmente com exemplo numérico simples.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de conversão alfabeto-número",
                                    "Calculadora para operações modulares"
                                  ],
                                  "tips": [
                                    "Lembre-se: em aritmética modular, subtrações negativas adicionam 26: (a - b) mod 26 = ((a - b + 26) % 26)."
                                  ],
                                  "learningObjective": "Aplicar aritmética modular básica para estimar deslocamentos em cifras polialfabéticas.",
                                  "commonMistakes": [
                                    "Esquecer o módulo 26, resultando em shifts negativos ou >25",
                                    "Usar frequência errada como base para cálculo",
                                    "Confundir ordem: plaintext mais frequente com ciphertext"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a letra correspondente da chave Vigenère",
                                  "subSteps": [
                                    "Use o shift calculado como o valor numérico da letra da chave (pois key = (cipher - plain) mod 26).",
                                    "Converta o valor numérico da chave de volta para a letra correspondente (0=A, 1=B, ..., 25=Z).",
                                    "Anote a letra da chave associada à posição do coset (ex: posição 1 da chave)."
                                  ],
                                  "verification": "A letra da chave derivada, quando aplicada ao coset, deve aproximar a letra 'E' na posição mais frequente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de conversão número-alfabeto",
                                    "Papel para anotações"
                                  ],
                                  "tips": [
                                    "Teste rapidamente: aplique a chave inversa (subtraia shift) na letra mais frequente e veja se obtém 'E'."
                                  ],
                                  "learningObjective": "Entender a relação inversa entre shift, ciphertext e chave em cifras Vigenère.",
                                  "commonMistakes": [
                                    "Inverter a fórmula: usar (4 - cipher) em vez de (cipher - 4)",
                                    "Não converter corretamente número para letra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Repetir o processo para todos os cosets e verificar a chave completa",
                                  "subSteps": [
                                    "Aplique os passos 1-3 para cada coset restante (um por posição da chave).",
                                    "Monte a chave completa concatenando as letras derivadas na ordem dos cosets.",
                                    "Descriptografe uma porção do texto usando a chave candidata e verifique legibilidade."
                                  ],
                                  "verification": "A chave completa produz texto plaintext com distribuição de frequências semelhante ao inglês (E mais comum, etc.).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Chave parcial anterior",
                                    "Texto cifrado completo",
                                    "Ferramenta de descriptografia Vigenère (opcional, como Python ou app online)"
                                  ],
                                  "tips": [
                                    "Se o texto não for legível, ajuste shifts em cosets pequenos trocando 'E' por 'T' ou 'A'."
                                  ],
                                  "learningObjective": "Integrar derivações parciais em uma chave funcional e validar empiricamente.",
                                  "commonMistakes": [
                                    "Desalinhar posições de cosets com letras da chave",
                                    "Não testar descriptografia imediata",
                                    "Assumir chave longa sem comprimento estimado correto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e documentar a chave derivada",
                                  "subSteps": [
                                    "Compare o plaintext descriptografado com padrões linguísticos conhecidos.",
                                    "Ajuste letras de chave em cosets com baixa contagem se necessário.",
                                    "Documente todos os shifts, frequências e decisões tomadas."
                                  ],
                                  "verification": "Documentação completa inclui tabelas, cálculos e plaintext parcial legível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Dicionário de frequências inglesas/portuguesas",
                                    "Ferramenta de análise de texto"
                                  ],
                                  "tips": [
                                    "Use IC (Index of Coincidence) para validar se >0.06 para inglês."
                                  ],
                                  "learningObjective": "Avaliar e iterar sobre resultados de criptoanálise para robustez.",
                                  "commonMistakes": [
                                    "Ignorar cosets pequenos",
                                    "Não documentar suposições como 'E' mais frequente"
                                  ]
                                }
                              ],
                              "practicalExample": "Coset 1 (posições 1,6,11,...): letras K(3x), P(2x), J(1x), L(1x). Mais frequente: K=10. Shift = (10 - 4) mod 26 = 6. Letra chave: 6=G. Descriptografando K com G: (10 - 6) mod 26 = 4=E, correto.",
                              "finalVerifications": [
                                "Letra mais frequente em cada coset identificada corretamente.",
                                "Shifts calculados modularmente sem erros aritméticos.",
                                "Letras da chave convertidas precisamente de números.",
                                "Chave completa descriptografa pelo menos 70% do texto como legível.",
                                "Distribuição de frequências no plaintext aproxima idioma alvo (ex: E/T/A comuns).",
                                "Documentação inclui tabelas de frequência e cálculos.",
                                "Teste com porção desconhecida do texto confirma chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de frequências (100% exata).",
                                "Cálculos modulares corretos em todos os steps (sem erros >1).",
                                "Chave derivada leva a plaintext com IC >0.04.",
                                "Explicação clara de suposições (ex: 'E' como mais frequente).",
                                "Uso eficiente de tempo, completando em <70 minutos.",
                                "Identificação e correção de pelo menos um erro comum.",
                                "Documentação completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e operações em Z/26Z.",
                                "Estatística: Análise de frequências e distribuições probabilísticas.",
                                "História: Criptoanálise na Segunda Guerra Mundial (máquina Enigma).",
                                "Linguística: Padrões de frequência em idiomas naturais.",
                                "Programação: Implementação em Python para automação de cosets."
                              ],
                              "realWorldApplication": "Em cibersegurança, essa técnica é usada para quebrar cifras Vigenère em comunicações antigas ou malware simples, auxiliando em forensics digital e análise de vazamentos de dados históricos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Descriptografar o criptotexto completo",
                            "description": "Aplicar a chave encontrada a todo o texto, verificando a inteligibilidade do plaintext resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Criptotexto e a Chave",
                                  "subSteps": [
                                    "Copie o criptotexto completo em uma folha ou editor de texto, removendo espaços, pontuações e convertendo para maiúsculas.",
                                    "Confirme a chave encontrada na etapa anterior, anotando seu comprimento exato.",
                                    "Repita a chave ciclicamente até que ela tenha o mesmo comprimento do criptotexto.",
                                    "Alinhe visualmente o criptotexto e a chave repetida lado a lado para verificação.",
                                    "Ignore ou remova caracteres não alfabéticos do criptotexto se presentes."
                                  ],
                                  "verification": "Verifique se o comprimento da chave repetida é idêntico ao do criptotexto e se o alinhamento está correto.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples (ex: Notepad), criptotexto original anotado.",
                                  "tips": "Trabalhe sempre em maiúsculas para evitar erros de case sensitivity; use uma régua para alinhar longos textos.",
                                  "learningObjective": "Preparar dados de entrada precisos para evitar erros propagados na descriptografia.",
                                  "commonMistakes": "Erro no comprimento da chave ou inclusão de caracteres não alfabéticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Descriptografia ao Criptotexto Completo",
                                  "subSteps": [
                                    "Para cada posição i: Calcule o shift da letra da chave K_i (A=0, B=1, ..., Z=25).",
                                    "Para cada letra C_i do criptotexto (converta para número 0-25), aplique a fórmula: P_i = (C_i - K_i) mod 26.",
                                    "Converta cada P_i de volta para letra (0=A, ..., 25=Z).",
                                    "Registre o plaintext resultante letra por letra, agrupando em palavras se possível.",
                                    "Use uma tabela Vigenère ou script simples para acelerar o processo em textos longos."
                                  ],
                                  "verification": "Gere o plaintext completo e confira as primeiras e últimas 5 letras manualmente com a fórmula.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Tabela de Vigenère impressa, calculadora ou planilha Excel com fórmula MOD, lápis para cálculos manuais.",
                                  "tips": "Divida o texto em blocos de 10 letras para gerenciar fadiga; sempre subtraia e aplique mod 26.",
                                  "learningObjective": "Executar a descriptografia polialfabética usando aritmética modular de forma precisa.",
                                  "commonMistakes": "Esquecer o módulo 26 (resultando em números negativos ou >25), ou somar em vez de subtrair."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Inteligibilidade do Plaintext",
                                  "subSteps": [
                                    "Leia o plaintext completo em voz alta ou silenciosamente, procurando palavras reconhecíveis.",
                                    "Analise a distribuição de frequências de letras (ex: E deve ser comum em inglês).",
                                    "Procure padrões linguísticos como bigramas comuns (TH, HE) ou palavras de frequência alta.",
                                    "Compare com o contexto esperado (ex: mensagem militar ou jornalística).",
                                    "Anote seções ambíguas e teste shifts alternativos em ±1 para confirmação."
                                  ],
                                  "verification": "O texto forma pelo menos 80% de palavras coerentes e faz sentido no contexto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Plaintext gerado, tabela de frequências de letras em português/inglês, dicionário online.",
                                  "tips": "Ignore ruído inicial; foque em frases completas; use ferramentas como letter frequency analyzer online para suporte.",
                                  "learningObjective": "Avaliar a qualidade da descriptografia com base em critérios linguísticos e estatísticos.",
                                  "commonMistakes": "Confundir ruído com plaintext inválido ou aceitar texto sem sentido como válido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar, Documentar e Finalizar",
                                  "subSteps": [
                                    "Se não inteligível, revise a chave ou aplicação da fórmula em pontos suspeitos.",
                                    "Ajuste shifts em erros isolados e re-verifique inteligibilidade.",
                                    "Documente o plaintext final, a chave usada e discrepâncias encontradas.",
                                    "Compare com plaintext conhecido se disponível, ou resuma o conteúdo.",
                                    "Salve o processo completo em um relatório para análise posterior."
                                  ],
                                  "verification": "Plaintext final é inteligível e documentado com evidências do processo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Relatório ou documento Word/Google Docs, plaintext final.",
                                  "tips": "Mantenha um log de ajustes para rastreabilidade; celebre quando o texto fizer sentido!",
                                  "learningObjective": "Iterar e refinar a descriptografia, enfatizando documentação para reprodutibilidade.",
                                  "commonMistakes": "Não documentar mudanças, levando a perda de rastreamento de erros."
                                }
                              ],
                              "practicalExample": "Criptotexto: 'WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ'. Chave: 'KEY' (repetida: KEYKEYKEYKEYKEYKE). Aplicando fórmula: W(22)-K(10)=12=M, H(7)-E(4)=3=D, etc. Plaintext: 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG'. Verificação: Frase pangramática clássica, 100% inteligível.",
                              "finalVerifications": [
                                "Plaintext é 90%+ legível com palavras reconhecíveis.",
                                "Fórmula aplicada corretamente em amostra aleatória de 20 letras.",
                                "Distribuição de frequências de letras matches idioma esperado.",
                                "Nenhuma discrepância não resolvida entre criptotexto e chave.",
                                "Processo documentado com plaintext final.",
                                "Teste de re-criptografia com a mesma chave recupera o original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da fórmula modular (sem erros aritméticos).",
                                "Qualidade da verificação de inteligibilidade (uso de múltiplos critérios).",
                                "Completude da preparação e alinhamento de chave/texto.",
                                "Efetividade dos ajustes e iterações.",
                                "Clareza e completude da documentação.",
                                "Tempo respeitado com eficiência nos subpassos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e operações em Z/26Z.",
                                "Língua Portuguesa/Inglês: Análise linguística e frequência de palavras.",
                                "História: Aplicações em cifras históricas como Vigenère na Renascença.",
                                "Programação: Implementação em Python para automação da descriptografia."
                              ],
                              "realWorldApplication": "Em cibersegurança, descriptografar mensagens interceptadas em comunicações antigas ou modernas para inteligência; validar descriptografias em forensics digitais ou quebra de códigos em CTFs (Capture The Flag)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Validar e refinar a chave",
                            "description": "Testar variações da chave candidata e usar n-grams ou IC para confirmar a descriptografia correta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar Variações da Chave Candidata",
                                  "subSteps": [
                                    "Analise a chave parcial identificada anteriormente e liste possíveis substituições para letras incertas baseadas em frequência comum em idiomas alvo (ex: E, T, A em inglês).",
                                    "Considere variações de comprimento da chave, adicionando ou removendo uma letra se o IC inicial sugerir erro.",
                                    "Crie pelo menos 5-10 variações sistemáticas, priorizando mudanças mínimas (ex: alterar uma letra por vez).",
                                    "Registre cada variação com uma breve justificativa (ex: 'KEY' -> 'KEA' por frequência de A).",
                                    "Ordene as variações por probabilidade estimada com base em análise prévia de frequência."
                                  ],
                                  "verification": "Lista documentada de pelo menos 5 variações com justificativas, salva em um arquivo ou planilha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Chave candidata inicial",
                                    "Tabela de frequências de letras do idioma alvo",
                                    "Planilha ou papel para listar variações"
                                  ],
                                  "tips": "Mantenha um log numerado para rastrear variações e evitar duplicatas.",
                                  "learningObjective": "Desenvolver capacidade de gerar hipóteses sistemáticas para refinamento de chaves em criptoanálise.",
                                  "commonMistakes": [
                                    "Gerar variações aleatórias sem base em frequências linguísticas",
                                    "Ignorar o impacto do comprimento da chave no IC",
                                    "Criar mais de 20 variações, desperdiçando tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descriptografar o Texto Cifrado com Cada Variação",
                                  "subSteps": [
                                    "Implemente a descriptografia Vigenère para cada variação da chave no texto cifrado completo.",
                                    "Repita o processo para pelo menos as top 5 variações mais promissoras.",
                                    "Salve o texto descriptografado resultante para cada variação em arquivos separados ou colunas de planilha.",
                                    "Visualize rapidamente cada saída para notar padrões iniciais de legibilidade (ex: presença de palavras reais).",
                                    "Automatize se possível com uma ferramenta simples como Python ou calculadora modular."
                                  ],
                                  "verification": "Arquivos ou registros com textos descriptografados para todas as variações testadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Texto cifrado completo",
                                    "Implementação de descriptografia Vigenère (manual ou script)",
                                    "Editor de texto ou planilha"
                                  ],
                                  "tips": "Teste primeiro em um segmento curto do texto para agilizar iterações.",
                                  "learningObjective": "Praticar a aplicação repetida de algoritmos de descriptografia para múltiplas hipóteses.",
                                  "commonMistakes": [
                                    "Erros de alinhamento na repetição da chave",
                                    "Usar criptografia em vez de descriptografia",
                                    "Não salvar saídas para comparação posterior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Qualidade Usando Índice de Coincidência (IC) e N-Grams",
                                  "subSteps": [
                                    "Calcule o IC para cada texto descriptografado: IC = Σ (f_i * (f_i - 1)) / (N * (N - 1)), onde f_i é frequência de letra i e N é comprimento.",
                                    "Compare o IC calculado com o valor esperado para o idioma (ex: 0.066 para inglês).",
                                    "Analise bigramas (n=2) e trigramas (n=3) comuns (ex: TH, HE, THE) e conte sua ocorrência em cada saída.",
                                    "Pontue cada variação: alto IC + n-grams frequentes = alta pontuação.",
                                    "Identifique a variação com melhor pontuação combinada."
                                  ],
                                  "verification": "Tabela com IC, contagens de n-grams top 5 e pontuações para cada variação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Fórmula de IC",
                                    "Tabelas de n-grams esperados para o idioma",
                                    "Calculadora ou script Python para IC"
                                  ],
                                  "tips": "Use scripts prontos para IC se disponível para precisão e velocidade.",
                                  "learningObjective": "Dominar métricas quantitativas como IC e análise de n-grams para validar descriptografias.",
                                  "commonMistakes": [
                                    "Calcular IC em texto cifrado em vez de descriptografado",
                                    "Ignorar n-grams além de unigramas",
                                    "Arredondar IC prematuramente, perdendo nuances"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar a Chave e Validar Final",
                                  "subSteps": [
                                    "Selecione a variação com melhor pontuação e teste em todo o texto para confirmar legibilidade.",
                                    "Refine iterativamente: ajuste letras baseadas em erros visuais no texto (ex: contexto semântico).",
                                    "Re-calcule IC e n-grams na versão refinada para confirmar melhoria.",
                                    "Compare com texto conhecido (se disponível) ou dicionário para validação semântica.",
                                    "Documente a chave final e o processo de refinamento."
                                  ],
                                  "verification": "Chave final documentada com texto descriptografado legível e métricas finais (IC > 0.06, n-grams coerentes).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Melhores candidatos do passo anterior",
                                    "Dicionário ou corpus linguístico",
                                    "Texto cifrado original"
                                  ],
                                  "tips": "Use contexto semântico (palavras reais) como tie-breaker quando ICs são próximos.",
                                  "learningObjective": "Integrar análise quantitativa e qualitativa para otimizar chaves em criptoanálise.",
                                  "commonMistakes": [
                                    "Parar na primeira variação legível sem métricas",
                                    "Overfitting: ajustar demais perdendo generalização",
                                    "Não re-testar métricas após refinamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto cifrado Vigenère: 'KRMYGYMPVKW'. Chave candidata inicial: 'KEY'. Variações: 'KEA' (IC=0.045), 'LEY' (IC=0.068), 'KEYS' (IC=0.062). Melhor: 'LEY' produz 'THEREDACTOR' (IC próximo a 0.066, bigramas TH, HE presentes). Refine para 'LEYS' se necessário para texto completo.",
                              "finalVerifications": [
                                "IC do texto final está dentro de 5% do valor esperado para o idioma (ex: 0.063-0.069 para inglês).",
                                "Pelo menos 80% das bigramas top 10 do idioma aparecem no texto descriptografado.",
                                "Texto é semânticamente coerente com pelo menos 3-5 palavras reais identificáveis.",
                                "Processo documentado mostra pelo menos 3 iterações de refinamento.",
                                "Descriptografia com chave final reproduz texto idêntico em testes repetidos.",
                                "N-grams trigramas comuns (ex: THE, AND) ocorrem com frequência esperada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de IC (erro < 0.01).",
                                "Número e qualidade das variações geradas (sistemáticas e justificadas).",
                                "Correta interpretação de n-grams para seleção da chave.",
                                "Eficiência no refinamento (melhoria mensurável em métricas).",
                                "Documentação completa do processo com evidências.",
                                "Legibilidade final do texto (nota subjetiva 8/10 ou superior)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo probabilístico do IC e análise de frequências.",
                                "Linguística: Estudo de n-grams e padrões linguísticos em textos.",
                                "Matemática: Aritmética modular na descriptografia Vigenère.",
                                "História: Aplicações em criptoanálise da WWII (máquina Enigma).",
                                "Programação: Automatização de cálculos com scripts Python."
                              ],
                              "realWorldApplication": "Em segurança cibernética, validar chaves fracas em sistemas legados ou comunicações interceptadas; agências como NSA usam técnicas semelhantes para quebrar cifras polialfabéticas em inteligência signals (SIGINT); análise forense digital de mensagens criptografadas em investigações criminais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Protocolos Criptográficos",
                "description": "Protocolos para autenticação, troca de chaves e assinatura digital, garantindo segurança em comunicações.",
                "totalSkills": 34,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Protocolos de Autenticação",
                    "description": "Mecanismos criptográficos para verificar a identidade de participantes em comunicações seguras.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1.1",
                        "name": "Autenticação com Chaves Simétricas",
                        "description": "Mecanismos que utilizam chaves compartilhadas secretas para verificar a identidade de um comunicante por meio de funções de autenticação de mensagens (MAC) ou cifragem de desafios.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1.1",
                            "name": "Definir e exemplificar MAC em autenticação",
                            "description": "Explicar o conceito de Message Authentication Code (MAC), seus componentes (chave secreta, mensagem, tag) e como é usado para autenticação unilateral em protocolos simétricos, com exemplos como HMAC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Message Authentication Code (MAC)",
                                  "subSteps": [
                                    "Ler a definição formal de MAC como um código de autenticação de mensagens usando chaves simétricas.",
                                    "Entender que MAC garante integridade e autenticidade unilateral da mensagem.",
                                    "Diferenciar MAC de funções hash puras, destacando o uso de chave secreta.",
                                    "Analisar o papel em protocolos simétricos para evitar modificações não autorizadas.",
                                    "Estudar exemplos iniciais de uso em autenticação."
                                  ],
                                  "verification": "Explicar em suas próprias palavras o que é MAC e sua diferença de um hash simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou vídeo sobre conceitos de criptografia básica",
                                    "Diagrama de autenticação unilateral"
                                  ],
                                  "tips": [
                                    "Visualize MAC como um 'selo de segurança' que só abre com a chave certa.",
                                    "Compare com envelope lacrado com cera e selo único."
                                  ],
                                  "learningObjective": "Definir MAC e identificar sua finalidade principal em autenticação.",
                                  "commonMistakes": [
                                    "Confundir MAC com criptografia de confidencialidade.",
                                    "Achar que MAC é assimétrico como assinaturas digitais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os Componentes Essenciais do MAC",
                                  "subSteps": [
                                    "Descrever a chave secreta compartilhada entre emissor e receptor.",
                                    "Explicar a mensagem original como entrada para o algoritmo MAC.",
                                    "Entender a tag MAC como saída (código gerado pela função MAC(chave, mensagem)).",
                                    "Discutir como a tag é anexada à mensagem para transmissão.",
                                    "Verificar o processo de validação no receptor."
                                  ],
                                  "verification": "Listar e diagramar os três componentes principais com setas indicando o fluxo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta de diagramação (ex: Draw.io)",
                                    "Pseudocódigo de função MAC"
                                  ],
                                  "tips": [
                                    "Lembre-se: sem chave secreta, tag é inútil para verificação.",
                                    "Use cores diferentes no diagrama para chave, mensagem e tag."
                                  ],
                                  "learningObjective": "Listar e explicar os componentes chave, mensagem e tag do MAC.",
                                  "commonMistakes": [
                                    "Omitir que a chave deve ser secreta e compartilhada.",
                                    "Confundir tag com a mensagem criptografada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o Processo de Geração e Verificação do MAC",
                                  "subSteps": [
                                    "Simular o emissor: calcular MAC(K, M) e anexar tag à mensagem.",
                                    "Simular transmissão da mensagem + tag para o receptor.",
                                    "No receptor: recalcular MAC(K, M') e comparar com tag recebida.",
                                    "Analisar casos de falha: modificação da mensagem invalida a tag.",
                                    "Discutir autenticação unilateral (receptor autentica emissor, não vice-versa)."
                                  ],
                                  "verification": "Executar um fluxograma passo a passo e identificar onde falha se mensagem alterada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação online de criptografia",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": [
                                    "Teste alterando uma letra da mensagem para ver invalidação.",
                                    "Pense em termos de 'matemática impossível de inverter sem chave'."
                                  ],
                                  "learningObjective": "Descrever o fluxo completo de autenticação com MAC em protocolos simétricos.",
                                  "commonMistakes": [
                                    "Achar que MAC fornece confidencialidade (não criptografa mensagem).",
                                    "Ignorar que ambos precisam da mesma chave."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar com HMAC (Hash-based MAC)",
                                  "subSteps": [
                                    "Explicar HMAC como construção padrão usando hash (ex: SHA-256) + chave.",
                                    "Estudar fórmula: HMAC(K, M) = H((K XOR opad) || H((K XOR ipad) || M)).",
                                    "Implementar pseudocódigo ou código simples em Python.",
                                    "Testar HMAC com mensagem e chave exemplo, verificando tag.",
                                    "Comparar HMAC com MAC genérico e discutir vantagens (segurança comprovada)."
                                  ],
                                  "verification": "Gerar e validar uma tag HMAC com ferramenta ou código, confirmando match.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca Python hmac ou site como hmac-generator.com",
                                    "Documentação RFC 2104 sobre HMAC"
                                  ],
                                  "tips": [
                                    "Comece com chaves e mensagens curtas para testes.",
                                    "Use hashlib em Python para prática rápida."
                                  ],
                                  "learningObjective": "Implementar e exemplificar HMAC como instância prática de MAC.",
                                  "commonMistakes": [
                                    "Usar hash sem chave (vira hash simples).",
                                    "Ignorar padding inner/outer no HMAC."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python: importe hmac e hashlib; defina chave='secret', mensagem='Olá, autenticação!'; calcule tag = hmac.new(chave.encode(), mensagem.encode(), hashlib.sha256).hexdigest(); envie mensagem+tag; receptor recalcula e compara. Teste alterando mensagem para ver falha.",
                              "finalVerifications": [
                                "Definir MAC corretamente incluindo integridade e autenticação unilateral.",
                                "Listar componentes: chave secreta, mensagem e tag.",
                                "Explicar fluxo de geração e verificação sem erros.",
                                "Implementar exemplo HMAC e validar tag.",
                                "Diferenciar MAC de hash e criptografia.",
                                "Identificar uso em protocolos simétricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e componentes (80% correto).",
                                "Clareza no fluxograma ou explicação do processo.",
                                "Correção na implementação de exemplo HMAC.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Conexão com autenticação unilateral.",
                                "Uso de terminologia técnica apropriada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e propriedades colisão-resistentes.",
                                "Redes de Computadores: Protocolos seguros como TLS/SSL.",
                                "Segurança da Informação: Ameaças de integridade e replay attacks.",
                                "Programação: Implementação de algoritmos criptográficos em Python.",
                                "Matemática Discreta: Operações XOR e concatenação."
                              ],
                              "realWorldApplication": "MACs como HMAC são usados em TLS para autenticação de handshakes, APIs seguras (ex: JWT com HMAC), protocolos IoT para mensagens leves e sistemas bancários para verificar transações sem expor chaves assimétricas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.2",
                            "name": "Descrever protocolo de autenticação por desafio-resposta simétrico",
                            "description": "Detalhar o fluxo de um protocolo challenge-response usando cifragem simétrica, incluindo passos como envio de nonce, resposta cifrada e verificação, destacando prevenção de replay attacks.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do Protocolo",
                                  "subSteps": [
                                    "Defina chave simétrica como uma chave secreta compartilhada entre cliente e servidor para cifrar e decifrar mensagens.",
                                    "Explique nonce (number used once) como um valor aleatório único gerado pelo servidor para cada sessão.",
                                    "Descreva o mecanismo challenge-response: o servidor 'desafia' o cliente com um nonce, que responde cifrando-o com a chave compartilhada.",
                                    "Identifique o objetivo principal: provar posse da chave sem transmiti-la, prevenindo eavesdropping.",
                                    "Diferencie autenticação unilateral (apenas cliente) de mútua (ambos)."
                                  ],
                                  "verification": "Liste e defina corretamente os 5 conceitos em um resumo escrito, sem erros conceituais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Diagrama básico de criptografia simétrica (impresso ou digital)"
                                  ],
                                  "tips": "Use analogias como uma fechadura compartilhada onde o desafio é uma forma específica de girar a chave.",
                                  "learningObjective": "Dominar os termos e papéis dos componentes essenciais do protocolo.",
                                  "commonMistakes": [
                                    "Confundir chave simétrica com pública/privada",
                                    "Achar que nonce é reutilizável",
                                    "Ignorar que a chave nunca é enviada em claro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear o Fluxo Básico de Autenticação Unilateral",
                                  "subSteps": [
                                    "Cliente envia mensagem de início de autenticação (ex: 'AUTH_REQUEST') ao servidor.",
                                    "Servidor gera nonce aleatório (ex: timestamp + random) e o envia em claro ao cliente.",
                                    "Cliente recebe nonce, cifra-o usando chave compartilhada K (ex: AES-K(nonce)) e envia de volta.",
                                    "Servidor decifra a resposta com K, compara com o nonce original; se igual, autentica o cliente.",
                                    "Servidor responde com confirmação ou falha."
                                  ],
                                  "verification": "Crie um diagrama de sequência UML com as 5 mensagens trocadas, rotulando cada uma corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io ou papel e caneta",
                                    "Exemplo de nonce: valor hexadecimal aleatório"
                                  ],
                                  "tips": "Sempre inclua setas bidirecionais no diagrama para mostrar cliente-servidor.",
                                  "learningObjective": "Descrever com precisão a sequência de mensagens no fluxo unilateral.",
                                  "commonMistakes": [
                                    "Omitir o envio inicial do cliente",
                                    "Cifrar o nonce com chave assimétrica",
                                    "Esquecer a comparação no servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Prevenção de Replay Attacks e Autenticação Mútua",
                                  "subSteps": [
                                    "Explique replay attack: atacante captura e reutiliza mensagem válida; nonce previne por ser único por sessão.",
                                    "Adicione timestamp ao nonce para expiração (ex: nonce + timestamp, verificado no servidor).",
                                    "Estenda para autenticação mútua: após cliente, servidor envia seu nonce; cliente verifica.",
                                    "Descreva verificação mútua: cliente cifra nonce_servidor e envia; servidor não precisa, pois já sabe K.",
                                    "Liste limitações: chave compartilhada requer canal seguro inicial para distribuição."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como o nonce + timestamp previne replays, com exemplo numérico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora para simular timestamp",
                                    "Artigo sobre ataques de replay (online)"
                                  ],
                                  "tips": "Teste mentalmente: se nonce reutilizado, servidor rejeita por já usado ou expirado.",
                                  "learningObjective": "Integrar mecanismos de segurança contra replays e estender para autenticação bidirecional.",
                                  "commonMistakes": [
                                    "Reutilizar nonce em sessões múltiplas",
                                    "Confundir mútua com unilateral sem troca dupla",
                                    "Ignorar distribuição segura da chave"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Diagramar o Protocolo Completo",
                                  "subSteps": [
                                    "Reúna todos os passos em uma descrição narrativa fluida do protocolo completo.",
                                    "Crie um diagrama final incluindo init, challenge, response, verify, mutual challenge se aplicável.",
                                    "Simule o fluxo com valores exemplo: K='secret', nonce_serv='0xABC123'.",
                                    "Identifique pontos de falha: nonce fraco, chave comprometida.",
                                    "Compare brevemente com autenticação por senha em claro (por que é pior)."
                                  ],
                                  "verification": "Apresente diagrama e narrativa para revisão; deve cobrir unilateral + mutual + anti-replay.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama avançada",
                                    "Pseudocódigo para cifragem simples"
                                  ],
                                  "tips": "Use cores no diagrama: azul para cliente, vermelho para servidor, verde para nonce.",
                                  "learningObjective": "Produzir uma descrição coesa e visual do protocolo pronto para ensino.",
                                  "commonMistakes": [
                                    "Diagrama incompleto sem mutual",
                                    "Exemplos irreais (nonce previsível)",
                                    "Não mencionar limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema IoT de casa inteligente: Dispositivo (cliente) pede acesso à central (servidor). Central envia nonce '0xFFAA'. Dispositivo cifra com K_shared='MyIoTKey' resultando 'encryptedNonce'. Central decifra, verifica match, concede acesso à luzes; mutual: central envia nonce2, dispositivo verifica.",
                              "finalVerifications": [
                                "Lista corretamente os componentes: chave simétrica, nonce, challenge-response.",
                                "Descreve o fluxo com pelo menos 4 mensagens principais sem erros de sequência.",
                                "Explica prevenção de replay via nonce único e timestamp.",
                                "Inclui extensão para autenticação mútua.",
                                "Produz diagrama de sequência legível e completo.",
                                "Identifica uma limitação real do protocolo."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de termos (30%)",
                                "Correção do fluxo: sequência exata de mensagens (25%)",
                                "Tratamento de segurança: replay e mutual bem explicados (20%)",
                                "Clareza visual: diagrama profissional e legível (15%)",
                                "Completude: cobre todos elementos sem omissões (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de cifragem simétrica (ex: AES como permutações blocais).",
                                "Redes de Computadores: Protocolos de troca de mensagens em camadas de transporte.",
                                "Segurança da Informação: Análise de ameaças como MITM e replays.",
                                "Física/Engenharia: Analogias com sinais analógicos seguros em comunicações.",
                                "Lógica/Algoritmos: Geração de nonces pseudo-aleatórios."
                              ],
                              "realWorldApplication": "Implementado em protocolos como o de autenticação em redes Bluetooth Low Energy (BLE) para pareamento de dispositivos, ou em sistemas SCADA industriais para autenticação segura de sensores sem chaves assimétricas pesadas, prevenindo acessos não autorizados em ambientes IoT."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.3",
                            "name": "Identificar vulnerabilidades em protocolos simétricos",
                            "description": "Analisar ataques comuns como man-in-the-middle e replay em autenticação simétrica, explicando como nonces e timestamps mitigam esses riscos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Autenticação com Chaves Simétricas",
                                  "subSteps": [
                                    "Defina autenticação simétrica como o uso de uma chave compartilhada secreta para verificar a identidade de uma parte.",
                                    "Descreva o fluxo básico: cliente envia mensagem encriptada com a chave compartilhada; servidor descriptografa e verifica.",
                                    "Identifique componentes chave: chave secreta (K), mensagem (M), criptografia simétrica (ex: AES).",
                                    "Crie um diagrama simples do fluxo de autenticação sem proteção adicional.",
                                    "Explique por que a confidencialidade é garantida, mas a autenticidade pode ser vulnerável."
                                  ],
                                  "verification": "Desenhe e explique um diagrama do fluxo de autenticação simétrica para um parceiro de estudo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Recursos online sobre AES e criptografia simétrica (ex: Crypto101.io)"
                                  ],
                                  "tips": "Use setas em diagramas para mostrar o fluxo de mensagens e destaque a chave compartilhada.",
                                  "learningObjective": "Entender o mecanismo básico de autenticação simétrica e suas premissas de segurança.",
                                  "commonMistakes": [
                                    "Confundir autenticação simétrica com assimétrica (chaves públicas)",
                                    "Ignorar que a chave deve ser secreta e compartilhada previamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Ataque Man-in-the-Middle (MITM) em Protocolos Simétricos",
                                  "subSteps": [
                                    "Descreva o cenário: atacante intercepta comunicações entre cliente e servidor sem que eles saibam.",
                                    "Explique como o atacante pode se passar pelo cliente enviando mensagens encriptadas com a mesma chave K.",
                                    "Simule o ataque: cliente envia auth, atacante captura e retransmite para servidor como se fosse legítimo.",
                                    "Discuta impactos: roubo de sessão, impersonação contínua.",
                                    "Identifique por que falha: protocolo não verifica frescor ou integridade da origem da mensagem."
                                  ],
                                  "verification": "Simule o ataque em um diagrama e identifique onde o servidor falha em detectar o impostor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação online (ex: draw.io)",
                                    "Vídeos tutoriais sobre MITM em Wireshark"
                                  ],
                                  "tips": "Pense no atacante como um 'homem no meio' fisicamente entre os dois; foque na falta de verificação de identidade.",
                                  "learningObjective": "Identificar como MITM explora a falta de verificação de origem em autenticação simétrica.",
                                  "commonMistakes": [
                                    "Achar que encriptação impede MITM (ela protege confidencialidade, não autenticidade)",
                                    "Confundir com eavesdropping passivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Ataque de Replay em Autenticação Simétrica",
                                  "subSteps": [
                                    "Defina replay attack: atacante captura uma mensagem válida e a retransmite mais tarde para reutilizá-la.",
                                    "Explique vulnerabilidade: mensagens reutilizáveis sem indicador de frescor (nonce ou timestamp).",
                                    "Simule: cliente autentica com msg encriptada; atacante armazena e replay após logout.",
                                    "Discuta consequências: acesso não autorizado repetido, negação de serviço por replays excessivos.",
                                    "Compare com MITM: replay é passivo na captura, mas ativo na retransmissão."
                                  ],
                                  "verification": "Crie uma sequência temporal de mensagens mostrando captura e replay bem-sucedido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador de rede simples (ex: Python com sockets)",
                                    "Documentação de ataques replay em RFCs"
                                  ],
                                  "tips": "Use um relógio no diagrama para mostrar o atraso entre captura e replay.",
                                  "learningObjective": "Reconhecer como a ausência de unicidade temporal permite replays em protocolos simétricos.",
                                  "commonMistakes": [
                                    "Pensar que encriptação impede replay (chave é a mesma)",
                                    "Ignorar que servidor aceita msg válida independentemente do tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Mitigações com Nonces e Timestamps",
                                  "subSteps": [
                                    "Defina nonce: número usado uma única vez (Number used ONCE) para garantir unicidade.",
                                    "Descreva uso: inclua nonce gerado pelo cliente na msg; servidor verifica se é novo.",
                                    "Explique timestamp: valor de tempo atual; servidor rejeita se fora de janela de tempo (ex: ±5 min).",
                                    "Compare: nonce previne replay puro; timestamp previne replay atrasado; juntos, mitigam ambos.",
                                    "Discuta implementação: armazenar nonces vistos ou usar sincronização de relógios seguros."
                                  ],
                                  "verification": "Modifique diagramas anteriores adicionando nonce/timestamp e mostre ataques falhando.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de código Python para nonce/timestamp em autenticação",
                                    "RFC 4086 sobre nonces"
                                  ],
                                  "tips": "Teste com código simples: gere nonce aleatório e verifique duplicatas em um set.",
                                  "learningObjective": "Compreender como nonces e timestamps restauram frescor e previnem MITM/replay.",
                                  "commonMistakes": [
                                    "Achar que nonce sozinho previne todos replays (precisa de armazenamento)",
                                    "Ignorar problemas de sincronização de relógios em timestamps"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de acesso IoT para portas inteligentes: Dispositivo (cliente) e servidor compartilham chave K. Cliente envia {ID, hash(tempo + ID, K)} para abrir porta. Atacante captura e faz replay após 10 min (servidor aceita). Com nonce: cliente inclui N aleatório; servidor rejeita N reutilizado. Com timestamp: rejeita se |tempo_recebido - tempo_servidor| > 5 min.",
                              "finalVerifications": [
                                "Explicar MITM em autenticação simétrica sem mitigações.",
                                "Desenhar fluxo de replay attack com diagrama temporal.",
                                "Identificar falhas em um protocolo simétrico dado.",
                                "Mostrar como nonce previne replay em um exemplo.",
                                "Descrever uso de timestamp e sua janela de aceitação.",
                                "Comparar eficácia de nonce vs timestamp."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de ataques MITM e replay (sem confusões conceituais).",
                                "Clareza em diagramas e fluxos de mensagens.",
                                "Correta explicação de mecanismos de mitigação (nonce/timestamp).",
                                "Identificação de limitações práticas (ex: armazenamento de nonces).",
                                "Uso de exemplos concretos e acionáveis.",
                                "Compreensão de por que simétrico é vulnerável sem frescor."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise de tráfego com Wireshark para detectar replays.",
                                "Matemáticas: Funções hash e geração de nonces pseudo-aleatórios.",
                                "Ética e Direito: Implicações legais de ataques de segurança cibernética.",
                                "Programação: Implementação em Python de protocolos com nonces."
                              ],
                              "realWorldApplication": "Em apps bancários móveis (ex: autenticação de transações com chaves simétricas em TLS 1.3), sistemas Kerberos para autenticação em redes corporativas, e dispositivos IoT como fechaduras inteligentes, onde nonces/timestamps previnem acessos não autorizados via MITM ou replay."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.1.2",
                        "name": "Autenticação com Chaves Públicas",
                        "description": "Protocolos que empregam criptografia de chave pública, como assinaturas digitais e certificados, para autenticação sem necessidade de chaves compartilhadas previamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.2.1",
                            "name": "Explicar o uso de assinaturas digitais para autenticação",
                            "description": "Descrever como pares de chaves pública/privada em esquemas como RSA ou ECDSA geram e verificam assinaturas, garantindo integridade e origem da mensagem em comunicações seguras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Criptografia Assimétrica",
                                  "subSteps": [
                                    "Definir chaves pública e privada e seu papel em sistemas assimétricos.",
                                    "Explicar a diferença entre criptografia simétrica (uma chave) e assimétrica (par de chaves).",
                                    "Descrever brevemente algoritmos como RSA (baseado em fatoração) e ECDSA (curvas elípticas).",
                                    "Entender os requisitos: chave privada secreta, chave pública compartilhada.",
                                    "Reconhecer os objetivos: confidencialidade, integridade, autenticação e não-repúdio."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito a diferença entre chaves pública e privada e citar um exemplo de algoritmo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo Khan Academy sobre criptografia assimétrica",
                                    "Artigo da Wikipedia sobre RSA e ECDSA"
                                  ],
                                  "tips": "Visualize a chave privada como uma 'assinatura única' que só você tem; a pública como um 'selo verificável' por todos.",
                                  "learningObjective": "Compreender os pilares da criptografia assimétrica necessários para assinaturas digitais.",
                                  "commonMistakes": [
                                    "Confundir o uso: assinar com pública em vez de privada.",
                                    "Achar que chaves assimétricas são mais lentas sem entender por quê (operações matemáticas complexas).",
                                    "Ignorar que chaves públicas precisam ser distribuídas de forma confiável."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o Processo de Geração de Assinatura Digital",
                                  "subSteps": [
                                    "Calcular o hash da mensagem original usando funções como SHA-256 para criar um resumo fixo.",
                                    "Assinar o hash com a chave privada do remetente usando o algoritmo (ex: RSA ou ECDSA).",
                                    "Concatenar a assinatura ao hash ou mensagem para envio.",
                                    "Garantir que a chave privada nunca saia do dispositivo seguro.",
                                    "Testar conceitualmente: se mensagem muda, hash muda, assinatura inválida."
                                  ],
                                  "verification": "Desenhar um diagrama simples mostrando mensagem -> hash -> assinatura com chave privada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como CryptoJS para simular hash e assinatura",
                                    "Diagrama ilustrativo de fluxo de assinatura digital"
                                  ],
                                  "tips": "Sempre assine o hash, não a mensagem inteira, para eficiência.",
                                  "learningObjective": "Dominar o mecanismo de geração de assinaturas para garantir origem e integridade.",
                                  "commonMistakes": [
                                    "Assinar a mensagem sem hash, levando a vulnerabilidades de padding.",
                                    "Expor a chave privada durante o processo.",
                                    "Usar chave pública para assinar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o Processo de Verificação de Assinatura Digital",
                                  "subSteps": [
                                    "Receber mensagem, assinatura e chave pública do suposto remetente.",
                                    "Calcular o hash da mensagem recebida.",
                                    "Verificar a assinatura usando a chave pública: descriptografar assinatura para obter hash original.",
                                    "Comparar hashes: iguais = válido (integridade e origem confirmadas).",
                                    "Entender falhas: mensagem alterada ou chave errada resulta em hashes diferentes."
                                  ],
                                  "verification": "Simular verificação com ferramenta online e confirmar se passa/falha em cenários alterados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de assinaturas digitais (ex: Crypto101 tools)",
                                    "Exemplo de código Python com biblioteca cryptography"
                                  ],
                                  "tips": "A verificação prova 'quem enviou' e 'não foi alterado', mas não confidencialidade.",
                                  "learningObjective": "Saber verificar assinaturas para validar comunicações seguras.",
                                  "commonMistakes": [
                                    "Verificar com chave privada.",
                                    "Comparar assinaturas diretamente sem hash.",
                                    "Ignorar ataques de colisão de hash."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Assinaturas Digitais em Autenticação e Protocolos",
                                  "subSteps": [
                                    "Explicar autenticação: assinatura prova identidade do remetente.",
                                    "Discutir não-repúdio: remetente não pode negar envio.",
                                    "Integrar em protocolos como TLS/SSL ou PGP para emails.",
                                    "Analisar cenários: software updates, transações blockchain.",
                                    "Explorar limitações: necessidade de CA para confiança em chaves públicas."
                                  ],
                                  "verification": "Descrever um cenário real onde assinatura falha e como detectar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de PGP para email",
                                    "Vídeo sobre como HTTPS usa assinaturas em certificados"
                                  ],
                                  "tips": "Assinaturas fornecem autenticação forte em comunicações não confiáveis como internet.",
                                  "learningObjective": "Conectar assinaturas a usos práticos em autenticação segura.",
                                  "commonMistakes": [
                                    "Confundir autenticação com confidencialidade (assinaturas não criptografam).",
                                    "Subestimar necessidade de distribuição segura de chaves públicas.",
                                    "Pensar que assinaturas protegem contra replay attacks sozinhas."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao enviar um contrato PDF por email, o remetente calcula o hash do arquivo, assina com sua chave privada ECDSA, anexa a assinatura. O destinatário usa a chave pública do remetente (de um certificado) para verificar: hash calculado do PDF recebido bate com o da assinatura? Sim → contrato autêntico e inalterado.",
                              "finalVerifications": [
                                "Explicar corretamente o fluxo completo: geração e verificação.",
                                "Identificar impacto de alteração na mensagem (hash muda, verificação falha).",
                                "Diferenciar assinatura digital de criptografia simétrica.",
                                "Descrever papel em autenticação vs. confidencialidade.",
                                "Simular verificação em ferramenta e interpretar resultado.",
                                "Explicar não-repúdio com exemplo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos passos de assinatura/verificação (sem inversão de chaves).",
                                "Compreensão conceitual de integridade, origem e não-repúdio.",
                                "Capacidade de aplicar a cenários reais (ex: email seguro).",
                                "Identificação correta de erros comuns e limitações.",
                                "Uso de terminologia adequada (hash, chave assimétrica, RSA/ECDSA).",
                                "Clareza em diagramas ou explicações visuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números, logaritmos discretos e curvas elípticas em RSA/ECDSA.",
                                "Redes de Computadores: Integração em protocolos como TLS para HTTPS.",
                                "Direito e Ética: Validade legal de assinaturas digitais (ex: leis eIDAS na UE).",
                                "Segurança da Informação: Análise de ameaças como ataques man-in-the-middle.",
                                "História da Computação: Evolução de Diffie-Hellman a criptografia moderna."
                              ],
                              "realWorldApplication": "Assinaturas digitais autenticam atualizações de software (ex: Microsoft usa para Windows), transações em blockchain (Bitcoin/Ethereum), certificados SSL para sites seguros, assinaturas eletrônicas em contratos (DocuSign), e autenticação em VPNs e emails corporativos, prevenindo fraudes e garantindo confiança em comunicações digitais globais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2.2",
                            "name": "Entender o papel de certificados digitais",
                            "description": "Explicar a estrutura de um certificado X.509, o processo de emissão por CA e como é usado em protocolos para validar chaves públicas e evitar ataques de falsificação de identidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de um certificado X.509",
                                  "subSteps": [
                                    "Estude os componentes principais: versão, número de série, assinatura do algoritmo, emissor (CA), período de validade, sujeito, chave pública e extensões.",
                                    "Identifique o formato ASN.1 DER/PEM usado para codificação.",
                                    "Analise um exemplo de certificado em formato legível (base64 decodificado).",
                                    "Desenhe um diagrama da hierarquia de campos em um certificado X.509 v3.",
                                    "Compare certificados raiz vs. intermediários."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama da estrutura X.509 com pelo menos 8 campos principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação RFC 5280, ferramenta online como SSL Labs ou openssl para decodificar certificados.",
                                  "tips": "Use ferramentas como 'openssl x509 -in cert.pem -text -noout' para visualizar estrutura real.",
                                  "learningObjective": "Identificar e explicar todos os campos essenciais de um certificado X.509.",
                                  "commonMistakes": "Confundir emissor com sujeito ou ignorar extensões como Key Usage."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o processo de emissão por uma Autoridade Certificadora (CA)",
                                  "subSteps": [
                                    "Entenda o fluxo: solicitação de certificado (CSR) pelo sujeito, verificação de identidade pela CA, assinatura digital pela CA privada.",
                                    "Diferencie CAs raiz, intermediárias e de registro.",
                                    "Simule a criação de uma CSR usando ferramentas como OpenSSL.",
                                    "Discuta revogação via CRL ou OCSP.",
                                    "Analise a cadeia de confiança (chain of trust)."
                                  ],
                                  "verification": "Gere uma CSR simulada e explique o processo de assinatura em um fluxograma.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "OpenSSL instalado, tutoriais da Let's Encrypt, RFC 2986 para CSR.",
                                  "tips": "Pratique em ambiente local com uma CA auto-assinada para evitar custos.",
                                  "learningObjective": "Descrever o fluxo completo de emissão e validar a cadeia de confiança.",
                                  "commonMistakes": "Achar que CA assina com chave pública ou ignorar verificação de identidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o uso de certificados em protocolos para validar chaves públicas",
                                  "subSteps": [
                                    "Estude integração em TLS/SSL: handshake onde servidor envia certificado para validação.",
                                    "Verifique passos: extrair chave pública, validar assinatura da CA, checar validade e revogação.",
                                    "Simule um handshake TLS com Wireshark capturando tráfego.",
                                    "Explique vinculação de identidade ao certificado via campos sujeito.",
                                    "Compare com autenticação mútua (client certs)."
                                  ],
                                  "verification": "Capture e anote um handshake TLS real, destacando validação do certificado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Wireshark, navegador com dev tools (F12 > Security tab), site HTTPS como google.com.",
                                  "tips": "Filtre Wireshark por 'tls.handshake.certificate' para focar no certificado.",
                                  "learningObjective": "Explicar como certificados validam chaves públicas em protocolos como TLS.",
                                  "commonMistakes": "Confundir validação de certificado com troca de chaves ou ignorar OCSP stapling."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender como certificados previnem ataques de falsificação de identidade",
                                  "subSteps": [
                                    "Identifique ataques mitigados: man-in-the-middle (MITM), spoofing de chaves públicas.",
                                    "Explique por que confiança na CA é crucial e riscos de CAs comprometidas (ex: DigiNotar).",
                                    "Discuta pinning de certificados e HSTS como defesas extras.",
                                    "Simule um cenário de MITM sem/ com certificado válido.",
                                    "Avalie cenários de falha: certificados expirados ou revogados."
                                  ],
                                  "verification": "Descreva em um parágrafo como um certificado bloqueia um MITM específico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Casos de estudo (DigiNotar breach), diagramas de ataques MITM.",
                                  "tips": "Use ferramentas como mitmproxy para demonstrar falha sem validação de cert.",
                                  "learningObjective": "Articular mecanismos de prevenção de falsificação via certificados.",
                                  "commonMistakes": "Superestimar segurança absoluta ou subestimar riscos de CAs falsas."
                                }
                              ],
                              "practicalExample": "Examine o certificado SSL do site https://www.google.com usando o inspetor do navegador (clique no ícone de cadeado > Certificate): identifique o emissor (GTS CA 1C3), validade, chave pública do Google e valide a cadeia até a raiz.",
                              "finalVerifications": [
                                "Explicar verbalmente a estrutura X.509 com 90% de precisão.",
                                "Gerar e assinar uma CSR com CA local sem erros.",
                                "Analisar um handshake TLS capturado e listar validações realizadas.",
                                "Identificar 3 ataques prevenidos por certificados em um cenário MITM.",
                                "Desenhar cadeia de confiança com 4 níveis corretamente.",
                                "Responder quiz de 10 perguntas sobre emissão e uso com 85% acertos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da estrutura X.509 (peso 25%).",
                                "Compreensão correta do processo de emissão CA (peso 25%).",
                                "Explicação clara de validação em protocolos (peso 20%).",
                                "Análise de prevenção de ataques (peso 15%).",
                                "Uso correto de exemplos práticos e ferramentas (peso 10%).",
                                "Clareza e completude em diagramas/fluxogramas (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Criptografia de chaves públicas (RSA/ECDSA para assinaturas).",
                                "Direito: Aspectos legais de confiança digital e regulamentações como eIDAS.",
                                "Redes de Computadores: Integração com protocolos TLS/IPsec.",
                                "Segurança da Informação: Gerenciamento de PKI e conformidade."
                              ],
                              "realWorldApplication": "Certificados digitais são essenciais em HTTPS para sites seguros, autenticação de emails (S/MIME), VPNs corporativas, assinaturas digitais em documentos PDF e blockchain para identidade verificável, prevenindo bilhões de ataques MITM anualmente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2.3",
                            "name": "Analisar protocolo de autenticação assimétrica básica",
                            "description": "Detalhar um protocolo simples como o envio de desafio cifrado com chave pública e assinatura com chave privada, identificando passos e benefícios sobre simetria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Criptografia Assimétrica",
                                  "subSteps": [
                                    "Estude pares de chaves pública e privada e suas propriedades matemáticas (ex: RSA baseado em fatoração).",
                                    "Diferencie cifra assimétrica de simétrica: assimétrica usa chaves diferentes para cifrar/decifrar.",
                                    "Entenda o conceito de 'desafio' (challenge) como nonce ou timestamp para prevenir replay attacks.",
                                    "Revise assinatura digital: hash da mensagem assinada com chave privada, verificada com pública.",
                                    "Identifique o objetivo da autenticação: provar posse de chave privada sem revelá-la."
                                  ],
                                  "verification": "Resuma em um diagrama simples os componentes (chave pública A, privada A, desafio, assinatura).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RSA básica",
                                    "Vídeo introdutório sobre chaves assimétricas (Khan Academy ou similar)"
                                  ],
                                  "tips": "Use analogia de caixa de correio: pública para receber, privada para abrir.",
                                  "learningObjective": "Compreender os fundamentos matemáticos e funcionais da assimetria.",
                                  "commonMistakes": [
                                    "Confundir chave pública com compartilhável como em simetria",
                                    "Ignorar o papel do hash em assinaturas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Fluxo do Protocolo Passo a Passo",
                                  "subSteps": [
                                    "Servidor envia desafio aleatório (nonce) para cliente.",
                                    "Cliente cifra o desafio com chave pública do servidor e assina com sua chave privada.",
                                    "Cliente envia o desafio cifrado + assinatura ao servidor.",
                                    "Servidor decifra com sua chave privada e verifica assinatura com chave pública do cliente.",
                                    "Se coincidir, autenticação aprovada."
                                  ],
                                  "verification": "Escreva o protocolo em pseudocódigo ou fluxograma com setas indicando fluxo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Ferramenta online como draw.io"
                                  ],
                                  "tips": "Numere cada mensagem trocada (Msg1: desafio, Msg2: resposta).",
                                  "learningObjective": "Mapear sequencialmente as trocas de mensagens no protocolo.",
                                  "commonMistakes": [
                                    "Omitir a assinatura digital",
                                    "Confundir quem cifra o desafio (cliente usa pública do servidor)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Mecanismos de Segurança e Vulnerabilidades",
                                  "subSteps": [
                                    "Explique como o nonce previne replay: cada desafio é único.",
                                    "Discuta forward secrecy: compromisso de chave privada não afeta sessões passadas.",
                                    "Identifique ataques potenciais: man-in-the-middle se chaves públicas não forem confiáveis.",
                                    "Verifique integridade via assinatura: detecção de alterações.",
                                    "Avalie confidencialidade: desafio cifrado protege conteúdo."
                                  ],
                                  "verification": "Liste 3 garantias de segurança e 1 vulnerabilidade com mitigação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de ataques comuns em cripto (OWASP)",
                                    "Exemplos de protocolos como TLS handshake"
                                  ],
                                  "tips": "Pense em termos de propriedades CIA (Confidencialidade, Integridade, Autenticidade).",
                                  "learningObjective": "Identificar como o protocolo atende a requisitos de autenticação segura.",
                                  "commonMistakes": [
                                    "Achar que assimetria é sempre mais segura sem contexto",
                                    "Esquecer verificação de assinatura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Autenticação Simétrica e Destacar Benefícios",
                                  "subSteps": [
                                    "Descreva protocolo simétrico: compartilhamento prévio de chave secreta.",
                                    "Compare: simetria requer canal seguro inicial; assimetria usa diretórios públicos.",
                                    "Benefícios assimétricos: escalabilidade (sem chaves compartilhadas por pares), não-repúdio via assinatura.",
                                    "Desvantagens: computacionalmente mais custoso.",
                                    "Conclua quando usar cada: simetria para performance, assimetria para autenticação inicial."
                                  ],
                                  "verification": "Crie tabela comparativa com 4 colunas: Aspecto, Simétrico, Assimétrico, Vencedor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela em Excel ou Markdown",
                                    "Artigo comparativo simetria vs assimetria"
                                  ],
                                  "tips": "Foque em 'key distribution problem' como killer feature da assimetria.",
                                  "learningObjective": "Avaliar trade-offs e justificar uso da assimetria.",
                                  "commonMistakes": [
                                    "Ignorar custo computacional da assimetria",
                                    "Achar simetria obsoleta"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um login SSH: servidor envia nonce, cliente assina com chave privada (id_rsa), servidor verifica com id_rsa.pub. Sem expor senha ou chave secreta compartilhada.",
                              "finalVerifications": [
                                "Diagramar corretamente o fluxo com 5 mensagens principais.",
                                "Explicar papel exato da assinatura digital.",
                                "Identificar 2 benefícios sobre simetria.",
                                "Simular protocolo com ferramentas como OpenSSL.",
                                "Listar 3 propriedades de segurança garantidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de passos do protocolo (100% correto).",
                                "Profundidade na análise de segurança (cobre confidencialidade, integridade, autenticidade).",
                                "Clareza no diagrama ou pseudocódigo.",
                                "Comparação equilibrada com simetria, com pelo menos 3 benefícios.",
                                "Uso correto de terminologia criptográfica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, módulo).",
                                "Redes de Computadores: Protocolos de handshake (TLS/SSL).",
                                "Segurança da Informação: Ameaças como MITM e replay.",
                                "Programação: Implementação em Python com cryptography library."
                              ],
                              "realWorldApplication": "Autenticação em protocolos como TLS (HTTPS), SSH logins, assinatura de emails PGP, blockchain wallets provando ownership sem expor chaves."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.1.3",
                        "name": "Autenticação Mútua em Protocolos",
                        "description": "Protocolos que estabelecem autenticação bidirecional entre duas partes, combinando elementos simétricos e assimétricos para sessões seguras como no TLS.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.3.1",
                            "name": "Descrever autenticação mútua unilateral vs bilateral",
                            "description": "Comparar autenticação unilateral (apenas servidor) com mútua (cliente e servidor), usando exemplos de protocolos como Kerberos ou handshake TLS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Autenticação Unilateral",
                                  "subSteps": [
                                    "Defina autenticação unilateral como o processo onde apenas o servidor verifica a identidade do cliente.",
                                    "Explique o fluxo típico: cliente envia credenciais (ex: username/password), servidor valida.",
                                    "Discuta vantagens: simplicidade e menor sobrecarga computacional.",
                                    "Identifique vulnerabilidades: suscetível a ataques de phishing ou replay sem proteção adicional.",
                                    "Desenhe um diagrama simples do fluxo unilateral."
                                  ],
                                  "verification": "Crie um diagrama ou descreva verbalmente o fluxo unilateral sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Artigo sobre autenticação básica (ex: Wikipedia 'Password authentication')"
                                  ],
                                  "tips": "Use setas no diagrama para mostrar o sentido do fluxo de mensagens.",
                                  "learningObjective": "Compreender o conceito e fluxo da autenticação unilateral.",
                                  "commonMistakes": "Confundir com autenticação sem senha ou ignorar o papel exclusivo do servidor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Autenticação Mútua (Bilateral)",
                                  "subSteps": [
                                    "Defina autenticação mútua como verificação recíproca: cliente autentica servidor e servidor autentica cliente.",
                                    "Descreva o fluxo: troca de certificados ou chaves criptográficas em ambas as direções.",
                                    "Explique benefícios: maior segurança contra impostores em ambas as pontas.",
                                    "Discuta desvantagens: maior complexidade e overhead.",
                                    "Desenhe um diagrama comparativo inicial com o unilateral."
                                  ],
                                  "verification": "Descreva o fluxo mútua e destaque pelo menos duas diferenças chave do unilateral.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo curto sobre TLS handshake (ex: YouTube 'TLS Handshake Explained')"
                                  ],
                                  "tips": "Pense em 'mão de quatro' vs 'aperto de mão' para visualizar a reciprocidade.",
                                  "learningObjective": "Dominar o conceito e fluxo da autenticação mútua.",
                                  "commonMistakes": "Achar que mútua é só 'duas senhas' em vez de criptografia recíproca."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Autenticação Unilateral vs Mútua",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para unilateral/mútua, linhas para segurança, complexidade, uso comum.",
                                    "Analise cenários: quando usar unilateral (apps simples) vs mútua (redes sensíveis).",
                                    "Discuta trade-offs: unilateral é mais rápido, mútua é mais segura.",
                                    "Identifique protocolos híbridos ou evoluções.",
                                    "Revise diagramas lado a lado."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 critérios sem inconsistências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Documentação comparativa de autenticação (ex: RFCs resumidos)"
                                  ],
                                  "tips": "Use ícones (cadeado simples vs duplo) para visualização rápida.",
                                  "learningObjective": "Capacitar comparação precisa entre os dois tipos.",
                                  "commonMistakes": "Ignorar overhead computacional na mútua ou subestimar riscos unilaterais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Exemplos com Protocolos Reais",
                                  "subSteps": [
                                    "Estude handshake TLS: cliente verifica certificado servidor (unilateral base), extensão para mútua com client cert.",
                                    "Analise Kerberos: tickets para autenticação mútua entre cliente, servidor e KDC.",
                                    "Simule fluxos: trace um handshake TLS unilateral vs mútua usando Wireshark demo.",
                                    "Compare: TLS unilateral comum em HTTPS, mútua em cenários empresariais.",
                                    "Registre lições aprendidas de cada protocolo."
                                  ],
                                  "verification": "Explique com exemplos de TLS/Kerberos a diferença em um parágrafo coerente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Wireshark demo capture de TLS",
                                    "Diagramas de Kerberos e TLS (ex: cloudflare.com/learning/ssl)"
                                  ],
                                  "tips": "Pause vídeos em steps chave para anotar fluxos.",
                                  "learningObjective": "Conectar conceitos teóricos a protocolos práticos.",
                                  "commonMistakes": "Confundir TLS unilateral (padrão) com mútua obrigatória."
                                }
                              ],
                              "practicalExample": "Simule um login web: Unilateral - digite senha no site (servidor verifica você). Mútua - use certificado client em VPN corporativa (servidor verifica você, você verifica servidor via CA). Trace com ferramentas como OpenSSL para TLS unilateral vs mútua.",
                              "finalVerifications": [
                                "Pode diagramar fluxos unilateral e mútua sem erros?",
                                "Explica diferenças em segurança e uso com exemplos TLS/Kerberos?",
                                "Identifica cenários ideais para cada tipo?",
                                "Preenche tabela comparativa corretamente?",
                                "Descreve vulnerabilidades específicas de cada?",
                                "Aplica conceitos a um exemplo real como HTTPS?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de unilateral vs mútua (30%)",
                                "Comparação profunda: trade-offs e tabela clara (25%)",
                                "Exemplos relevantes: TLS/Kerberos aplicados corretamente (20%)",
                                "Diagramas/visuais: fluxos precisos e legíveis (15%)",
                                "Compreensão aplicada: cenários e vulnerabilidades (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Integra com protocolos como TLS em camadas OSI.",
                                "Matemática: Chaves assimétricas e funções hash subjacentes.",
                                "Ética e Segurança: Implicações de privacidade em autenticação falha.",
                                "Desenvolvimento de Software: Implementação em APIs (OAuth unilateral vs mTLS)."
                              ],
                              "realWorldApplication": "Em bancos online (HTTPS unilateral para simplicidade), mas mútua em sistemas bancários internos ou IoT seguras para prevenir MITM; Kerberos em domínios Windows empresariais garante autenticação bilateral em redes internas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3.2",
                            "name": "Analisar o protocolo Needham-Schroeder",
                            "description": "Explicar o protocolo Needham-Schroeder para autenticação mútua com chave simétrica via third-party (KDC), incluindo vulnerabilidades conhecidas como replay e correções com timestamps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Componentes e Notação do Protocolo Needham-Schroeder",
                                  "subSteps": [
                                    "Identificar os agentes: A (iniciador), B (respondedor), S (KDC - Key Distribution Center).",
                                    "Aprender a notação padrão: E(K, X) para X encriptado com chave K; Ka é chave compartilhada A-S; Kb para B-S; Kab é chave de sessão A-B.",
                                    "Estudar suposições do protocolo: canais inseguros, chaves simétricas pré-compartilhadas e confiáveis, S confiável.",
                                    "Diagramar a arquitetura: agentes, chaves e fluxo inicial de confiança.",
                                    "Revisar conceitos básicos de criptografia simétrica (blocos, modos de operação)."
                                  ],
                                  "verification": "Criar e rotular um diagrama completo dos componentes, notação e relações de chaves.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo original de Needham-Schroeder (1978)",
                                    "Ferramenta de diagramação (Draw.io ou papel/caneta)",
                                    "Glossário de criptografia"
                                  ],
                                  "tips": "Use cores diferentes para chaves de longo prazo (Ka, Kb) vs. sessão (Kab).",
                                  "learningObjective": "Dominar a terminologia e setup para análise posterior.",
                                  "commonMistakes": [
                                    "Confundir chaves de sessão (Kab) com chaves de longo prazo (Ka/Kb)",
                                    "Ignorar a confiança implícita no KDC (S)",
                                    "Esquecer que canais são inseguros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Fluxo de Mensagens do Protocolo Original",
                                  "subSteps": [
                                    "Listar Mensagem 1: A → S: A, B (pedido de ticket).",
                                    "Detalhar Mensagem 2: S → A: E(Ka, [Kab, IDA, E(Kb, [Kab, IDA])]) (ticket para B).",
                                    "Explicar Mensagem 3: A → B: E(Kb, [Kab, IDA]) (apresentar ticket).",
                                    "Descrever Mensagem 4: B → A: E(Kab, NonceB) (desafio de B).",
                                    "Finalizar Mensagem 5: A → B: E(Kab, f(NonceB)) onde f é decremento ou resposta (resposta ao desafio)."
                                  ],
                                  "verification": "Escrever as 5 mensagens com notação exata e explicar o propósito de cada uma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pseudocódigo ou diagramas de sequência (UML)",
                                    "Editor de texto para notação",
                                    "Referência: paper Needham-Schroeder ou RFC Kerberos-like"
                                  ],
                                  "tips": "Use setas numeradas em um diagrama de sequência para visualizar o fluxo.",
                                  "learningObjective": "Memorizar e reproduzir precisamente o protocolo de 5 mensagens.",
                                  "commonMistakes": [
                                    "Omitir IDA na mensagem 2",
                                    "Confundir NonceB com timestamp",
                                    "Esquecer que Kab é gerada por S"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular uma Execução Bem-Sucedida do Protocolo",
                                  "subSteps": [
                                    "Atribuir valores concretos: chaves Ka='keyA', Kb='keyB', Kab='sess123', IDA='Alice', NonceB=123.",
                                    "Simular passo a passo as 5 mensagens, descriptografando e encriptando manualmente.",
                                    "Verificar autenticação mútua: A prova identidade para B via ticket; B prova para A via NonceB resposta.",
                                    "Registrar o que cada parte aprende (ex: B descobre Kab e IDA).",
                                    "Testar com ferramenta simples de cripto (Python com cryptography lib)."
                                  ],
                                  "verification": "Produzir um log de simulação com mensagens encriptadas/descriptografadas e confirmações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou JavaScript com libs crypto (cryptography.py ou CryptoJS)",
                                    "Planilha para simulação manual",
                                    "Calculadora para XOR se manual"
                                  ],
                                  "tips": "Comece com encriptação simples (XOR) para valores pequenos antes de AES.",
                                  "learningObjective": "Executar o protocolo para validar seu funcionamento correto.",
                                  "commonMistakes": [
                                    "Erro em descriptografia por chave errada",
                                    "Reutilizar NonceB incorretamente",
                                    "Não verificar frescor via desafio-resposta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Analisar a Vulnerabilidade de Replay Attack",
                                  "subSteps": [
                                    "Descrever cenário: Invasor I intercepta Msg3: E(Kb, [Kab_old, IDA]) de sessão velha.",
                                    "Simular replay: I reenvia Msg3 para B; B aceita como nova sessão com A, inicia Msg4 com Kab_old.",
                                    "Explicar por quê falha: B não detecta replay pois não há frescor (sem timestamp/nonce único por sessão).",
                                    "Demonstrar impacto: B criptografa dados sensíveis com Kab_old comprometido.",
                                    "Analisar formalmente: Falha em propriedade de 'frescor' ou 'anti-replay'."
                                  ],
                                  "verification": "Criar um diagrama de ataque replay com invasor I e mostrar Msg3 duplicada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de simulação de rede (Wireshark ou custom script)",
                                    "Diagramas de ataque (Attack Trees)",
                                    "Referências: Lowe's análise ou BAN logic basics"
                                  ],
                                  "tips": "Use timestamps relativos para ilustrar 'velha' vs. 'nova' sessão.",
                                  "learningObjective": "Reconhecer a falha específica de replay no NS original.",
                                  "commonMistakes": [
                                    "Confundir replay com man-in-the-middle",
                                    "Pensar que ticket protege contra replay",
                                    "Ignorar que B aceita qualquer ticket válido"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar a Correção com Timestamps",
                                  "subSteps": [
                                    "Modificar Msg2: S inclui Ts (timestamp) em E(Ka, [...]) e E(Kb, [Kab, IDA, Ts]).",
                                    "Atualizar Msg3: A → B inclui Ts no ticket.",
                                    "Explicar verificação: B checa Ts dentro de janela de tempo (deltaT); rejeita se velho.",
                                    "Simular execução corrigida e replay falhado (Ts velho rejeitado).",
                                    "Discutir trade-offs: Relógios sincronizados necessários, proteção contra replay perfeito."
                                  ],
                                  "verification": "Simular protocolo corrigido e demonstrar rejeição de replay com Ts expirado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python estendido com timestamps",
                                    "Relógio simulado para testes",
                                    "Paper sobre extensões NS"
                                  ],
                                  "tips": "Defina deltaT=5min; teste com Ts atrasado.",
                                  "learningObjective": "Entender como timestamps restauram propriedades de segurança.",
                                  "commonMistakes": [
                                    "Esquecer sincronização de relógios",
                                    "Colocar Ts só em Msg3 sem Msg2",
                                    "Ignorar ataques de atraso de rede"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule Alice (A) acessando servidor Bob (B) em uma rede corporativa: A pede ticket ao KDC (S), recebe E(Ka_Alice, [Kab='sess456', 'Alice', E(Kb_Bob, ['sess456', 'Alice'])]), envia ticket a B, B desafia com Nonce=789, A responde 788. Para replay: invasor reenvia ticket velho; B rejeita por falta de Ts na versão original.",
                              "finalVerifications": [
                                "Diagramar precisamente as 5 mensagens originais com notação E(K,X).",
                                "Simular replay attack bem-sucedido no original e falha na versão com Ts.",
                                "Explicar autenticação mútua: A prova para B via ticket; B para A via desafio-resposta.",
                                "Identificar todas as chaves e seu propósito em uma tabela.",
                                "Produzir código Python executável simulando o protocolo completo.",
                                "Descrever limitações: dependência em relógios sincronizados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação e mensagens (sem erros de sintaxe).",
                                "Correta identificação e simulação da vulnerabilidade de replay.",
                                "Explicação clara de como timestamps corrigem o problema.",
                                "Diagramas legíveis e completos.",
                                "Simulação prática funcional (código ou log manual).",
                                "Análise de trade-offs (ex: sincronização vs. segurança)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Criptografia simétrica e funções de hash para nonces.",
                                "Redes de Computadores: Protocolos de autenticação em camadas de transporte.",
                                "Lógica Formal: Análise com lógica BAN ou model checking (Tamarin/ProVerif).",
                                "Ética e Segurança: Implicações de falhas em sistemas reais (Kerberos).",
                                "Programação: Implementação de protocolos em Python/Java."
                              ],
                              "realWorldApplication": "O Needham-Schroeder simétrico inspirou o Kerberos (usado em Active Directory, Hadoop), protegendo autenticação em redes distribuídas como bancos e empresas contra eavesdropping e replays iniciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3.3",
                            "name": "Identificar elementos de protocolos modernos como TLS",
                            "description": "Mapear autenticação mútua no handshake TLS 1.3, focando em certificados cliente/servidor, nonces e derivação de chaves de sessão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral do Handshake TLS 1.3",
                                  "subSteps": [
                                    "Ler a seção de handshake no RFC 8446 (TLS 1.3).",
                                    "Identificar as mensagens principais: ClientHello, ServerHello, EncryptedExtensions, Certificate, CertificateVerify, Finished.",
                                    "Desenhar um diagrama sequencial das mensagens trocadas entre cliente e servidor.",
                                    "Mapear fases: negociação de parâmetros, autenticação e troca de chaves.",
                                    "Comparar brevemente com TLS 1.2 para destacar simplificações no 1.3."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama do handshake TLS 1.3 com pelo menos 6 mensagens principais corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 8446 (https://datatracker.ietf.org/doc/html/rfc8446#section-4)",
                                    "Diagramas visuais de TLS 1.3 (ex: Cloudflare TLS explainer)"
                                  ],
                                  "tips": "Use ferramentas como draw.io para diagramas; foque em fluxos de cima para baixo.",
                                  "learningObjective": "Compreender a sequência de mensagens no handshake TLS 1.3 como base para autenticação mútua.",
                                  "commonMistakes": "Confundir ordem das mensagens ou ignorar que TLS 1.3 usa (0-RTT, mas focar em full handshake)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear autenticação do servidor via certificados",
                                  "subSteps": [
                                    "Analisar mensagem Server Certificate: contém cadeia de certificados X.509 do servidor.",
                                    "Examinar CertificateVerify: assinatura do servidor sobre transcript hash usando chave privada.",
                                    "Verificar como cliente valida certificado (chain of trust para CA raiz).",
                                    "Identificar extensões relevantes como Server Name Indication (SNI).",
                                    "Simular validação com openssl s_client."
                                  ],
                                  "verification": "Explique em 3-5 frases como o servidor prova sua identidade e liste 2 extensões chave no Certificate.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OpenSSL para simular (openssl s_client -connect example.com:443)",
                                    "Wireshark com filtro tls.handshake.type == 11 (Certificate)"
                                  ],
                                  "tips": "Capture tráfego real com Wireshark para ver certificados ao vivo.",
                                  "learningObjective": "Identificar e validar elementos de autenticação unilateral do servidor no TLS 1.3.",
                                  "commonMistakes": "Esquecer que CertificateVerify usa transcript hash, não apenas nonce."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear autenticação mútua do cliente via certificados",
                                  "subSteps": [
                                    "Identificar Client CertificateRequest do servidor (opcional, mas para mútua).",
                                    "Analisar Client Certificate e Client CertificateVerify: cliente assina transcript.",
                                    "Comparar certificados cliente vs servidor (tipicamente client certs para autenticação forte).",
                                    "Verificar requisitos para mútua: PSK ou certificados bilaterais.",
                                    "Testar cenários com mutual TLS usando ferramentas como curl --cert."
                                  ],
                                  "verification": "Descreva diferenças entre autenticação servidor e cliente, citando mensagens específicas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RFC 8446 seção 4.4.3 (Client Authentication)",
                                    "Exemplo mutual TLS: curl com --cert e --key"
                                  ],
                                  "tips": "Mutual TLS é raro em web, mas comum em IoT/API; teste local com mkcert.",
                                  "learningObjective": "Diferenciar e mapear autenticação do cliente para mútua no handshake.",
                                  "commonMistakes": "Assumir autenticação cliente sempre presente; é opcional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar nonces e iniciais secrets no handshake",
                                  "subSteps": [
                                    "Identificar nonces: ClientHello.random e ServerHello.random (32 bytes cada).",
                                    "Mapear PSK (Pre-Shared Key) ou external secrets se aplicável.",
                                    "Explicar derivados iniciais: client/server handshake secret de HKDF sobre nonces e CH/ SH hashes.",
                                    "Rastrear transcript hash (todos handshake msgs até Finished).",
                                    "Visualizar árvore de chaves HKDF-Expand-Label."
                                  ],
                                  "verification": "Liste fontes de entropia (nonces) e derive um secret inicial conceitualmente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "RFC 8446 seção 7 (Key Schedule)",
                                    "Ferramenta online HKDF visualizer"
                                  ],
                                  "tips": "Lembre: nonces previnem replay; foque em entropia fresca.",
                                  "learningObjective": "Mapear nonces e secrets iniciais como base para derivação de chaves.",
                                  "commonMistakes": "Confundir randoms com nonces fixos ou ignorar salt no HKDF."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Compreender derivação de chaves de sessão finais",
                                  "subSteps": [
                                    "Derivar application traffic secrets de handshake secrets via Finished keys.",
                                    "Explicar HKDF-Extract/Expand para traffic keys (IV, key, etc.).",
                                    "Verificar proteção de mensagens pós-handshake com session keys.",
                                    "Analisar Finished MAC para integridade do transcript.",
                                    "Simular com Wireshark decodificação de TLS 1.3 (se master secret conhecido).",
                                    "Discutir rotação de chaves durante sessão."
                                  ],
                                  "verification": "Desenhe fluxo HKDF da árvore de chaves do início ao traffic secret.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Wireshark TLS 1.3 decryption guide",
                                    "RFC 8446 seção 7.1"
                                  ],
                                  "tips": "Use cores no diagrama para rastrear secrets; teste com servidor TLS 1.3.",
                                  "learningObjective": "Rastrear derivação completa de chaves de sessão a partir de nonces e certificados.",
                                  "commonMistakes": "Pular Finished verify ou confundir handshake vs application secrets."
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um handshake TLS 1.3 para google.com:443 com mutual TLS simulado. Identifique ClientHello (nonce client random), ServerHello (nonce server), Server Certificate/CertificateVerify, Client Certificate/CertificateVerify, e derive conceitualmente os secrets HKDF dos nonces para keys de sessão. Exporte o diagrama com labels.",
                              "finalVerifications": [
                                "Diagrama completo do handshake TLS 1.3 com autenticação mútua rotulado corretamente.",
                                "Explicação escrita de nonces (Client/Server random) e seu papel em HKDF.",
                                "Identificação precisa de mensagens Certificate e CertificateVerify para ambos lados.",
                                "Descrição da árvore de derivação de chaves com 4-5 secrets principais.",
                                "Análise de um capture Wireshark real destacando 3 elementos chave.",
                                "Comparação: como TLS 1.3 melhora segurança vs 1.2 em autenticação."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: 100% das mensagens e campos (certificados, nonces, HKDF) corretos (40%).",
                                "Completude: Todos elementos mapeados com substeps detalhados (30%).",
                                "Clareza visual: Diagramas legíveis com labels e setas (15%).",
                                "Profundidade: Explicações conectam autenticação a derivação de chaves (10%).",
                                "Aplicação prática: Análise de Wireshark ou simulação válida (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash (HKDF) e criptografia assimétrica (assinaturas ECDSA/RSA).",
                                "Redes: Protocolos de transporte (TCP/QUIC) e captura de pacotes (Wireshark).",
                                "Segurança da Informação: Ameaças como MITM e validação de certificados.",
                                "Programação: Implementação em Python com cryptography.io ou scapy para TLS parsing."
                              ],
                              "realWorldApplication": "Em navegadores web (HTTPS), APIs seguras (mutual TLS em bancos), VPNs (WireGuard usa TLS-like), e IoT (dispositivos autenticam mutuamente para prevenir acessos não autorizados), garantindo confidencialidade e integridade contra eavesdropping e impersonation."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Protocolos de Troca de Chaves",
                    "description": "Procedimentos para estabelecer chaves compartilhadas de forma segura entre partes remotas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Protocolo Diffie-Hellman",
                        "description": "Protocolo clássico probabilístico para estabelecer uma chave compartilhada simétrica entre duas partes remotas sem transmitir a chave diretamente, baseado no problema do logaritmo discreto.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar parâmetros públicos e privados no Diffie-Hellman",
                            "description": "Explicar os papéis de p (primo grande), g (gerador primitivo), chaves privadas a e b, e chaves públicas A = g^a mod p e B = g^b mod p, demonstrando como são gerados e trocados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os parâmetros públicos p e g",
                                  "subSteps": [
                                    "Estude o papel de p como um número primo grande que define o campo finito para os cálculos modulares.",
                                    "Aprenda que g é um gerador primitivo (ou base) no grupo multiplicativo módulo p, garantindo que potências de g cubram todos os elementos.",
                                    "Identifique que p e g são compartilhados abertamente entre as partes sem comprometer a segurança.",
                                    "Leia exemplos de valores típicos: p deve ser pelo menos 1024 bits em aplicações reais.",
                                    "Anote as propriedades matemáticas: ordem do grupo é p-1, e g tem ordem p-1."
                                  ],
                                  "verification": "Liste corretamente p e g como públicos e explique por que eles são seguros para compartilhar.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação sobre Diffie-Hellman",
                                    "Calculadora para primos",
                                    "Papel e caneta"
                                  ],
                                  "tips": [
                                    "Escolha p primo para evitar ataques; teste g com potências para verificar primitividade.",
                                    "Use ferramentas online para gerar p e g iniciais."
                                  ],
                                  "learningObjective": "Identificar e explicar os parâmetros públicos fundamentais do protocolo Diffie-Hellman.",
                                  "commonMistakes": [
                                    "Confundir p com não-primo, facilitando fatoração.",
                                    "Achar que g pode ser qualquer número; deve ser primitivo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e identificar chaves privadas a e b",
                                  "subSteps": [
                                    "Cada parte (Alice e Bob) escolhe uma chave privada aleatória: a para Alice (1 < a < p-1), b para Bob.",
                                    "Entenda que chaves privadas são números secretos mantidos apenas pelo dono.",
                                    "Aprenda critérios: aleatórias, grandes o suficiente para segurança, mas menores que p.",
                                    "Simule geração: use gerador de números aleatórios seguros.",
                                    "Registre que nunca são trocadas; só usadas localmente para calcular públicas."
                                  ],
                                  "verification": "Gere exemplos de a e b e confirme que são privados e nunca compartilhados.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Gerador de números aleatórios (Python random ou ferramenta criptográfica)",
                                    "Folha de exercícios"
                                  ],
                                  "tips": [
                                    "Mantenha a > 1 e < p-1 para evitar trivialidades.",
                                    "Em produção, use entropia alta para aleatoriedade."
                                  ],
                                  "learningObjective": "Distinguir chaves privadas como segredos locais e gerar exemplos válidos.",
                                  "commonMistakes": [
                                    "Escolher a=1 ou a=p-1, resultando em chaves fracas previsíveis.",
                                    "Confundir privadas com públicas durante geração."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e identificar chaves públicas A e B",
                                  "subSteps": [
                                    "Calcule A = g^a mod p para Alice e B = g^b mod p para Bob.",
                                    "Aprenda exponenciação modular eficiente (square-and-multiply).",
                                    "Identifique A e B como públicas: calculadas a partir de privadas, mas sem revelar a ou b.",
                                    "Pratique com exemplo pequeno: verifique que A e B parecem aleatórios.",
                                    "Confirme que A e B são trocadas abertamente."
                                  ],
                                  "verification": "Compute A e B corretamente para valores dados e classifique como públicas.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Calculadora modular ou Python (pow(g, a, p))",
                                    "Exemplos numéricos impressos"
                                  ],
                                  "tips": [
                                    "Use pow(base, exp, mod) em Python para eficiência.",
                                    "Verifique cálculos manuais com números pequenos primeiro."
                                  ],
                                  "learningObjective": "Executar cálculos de chaves públicas e entender sua natureza pública.",
                                  "commonMistakes": [
                                    "Erro em exponenciação modular, como esquecer mod p.",
                                    "Achar que A revela a diretamente (devido a log discreto difícil)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender o processo de troca e distinção final",
                                  "subSteps": [
                                    "Descreva fluxo: Compartilhar p,g → Cada gera privada → Calcula pública → Troca A e B.",
                                    "Classifique: Públicos (p,g,A,B); Privados (a,b).",
                                    "Explique por que troca é segura: problema do log discreto impede extrair a de A.",
                                    "Simule troca completa sem revelar privados.",
                                    "Discuta ataques potenciais se parâmetros fracos."
                                  ],
                                  "verification": "Diagrama o fluxo de troca rotulando públicos vs privados corretamente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Diagrama em branco",
                                    "Vídeo tutorial DH",
                                    "Ferramenta simuladora online"
                                  ],
                                  "tips": [
                                    "Desenhe setas para trocas e 'segredo' para privados.",
                                    "Compare com chaves simétricas para contraste."
                                  ],
                                  "learningObjective": "Mapear todo o protocolo identificando precisamente públicos e privados.",
                                  "commonMistakes": [
                                    "Listar A ou B como privados.",
                                    "Ignorar que p e g são pré-trocados ou fixos."
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: p=23 (primo), g=5 (primitivo). Alice escolhe a=6 (privada), calcula A=5^6 mod 23=8 (pública). Bob escolhe b=15 (privada), B=5^15 mod 23=19 (pública). Trocam A e B; Alice computa segredo compartilhado B^a mod p=19^6 mod 23=2; Bob A^b mod p=8^15 mod 23=2. Públicos: p=23,g=5,A=8,B=19; Privados: a=6,b=15.",
                              "finalVerifications": [
                                "Liste corretamente os 4 parâmetros públicos e 2 privados.",
                                "Explique fórmulas A=g^a mod p e B=g^b mod p.",
                                "Simule troca sem vazar privados.",
                                "Identifique por que p e g são públicos apesar de críticos.",
                                "Compute segredo compartilhado em exemplo dado.",
                                "Diferencie DH de RSA na distinção pública/privada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de cada parâmetro (público/privado).",
                                "Correção matemática nos cálculos modulares.",
                                "Clareza na explicação do fluxo de troca.",
                                "Uso correto de terminologia (primo, gerador, etc.).",
                                "Identificação de riscos se privados vazarem.",
                                "Capacidade de aplicar em exemplo numérico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, grupos cíclicos, log discreto).",
                                "Segurança da Informação: Criptografia Assimétrica e Autenticação.",
                                "Redes de Computadores: Protocolos de Troca de Chaves em TLS/SSL.",
                                "Programação: Implementação em Python/Java com bibliotecas criptográficas.",
                                "Física: Analogia quântica em QKD (Distribuição Quântica de Chaves)."
                              ],
                              "realWorldApplication": "O Diffie-Hellman é fundamental em protocolos como TLS/HTTPS para troca segura de chaves em navegadores web, VPNs (IPsec), SSH e WhatsApp, permitindo comunicação criptografada sem pré-compartilhamento de segredos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Calcular a chave compartilhada no Diffie-Hellman",
                            "description": "Realizar o cálculo da chave compartilhada K = A^b mod p = B^a mod p, verificando que ambas as partes chegam ao mesmo valor sem conhecerem as chaves privadas alheias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os parâmetros públicos e chaves privadas do protocolo Diffie-Hellman",
                                  "subSteps": [
                                    "Escolha um primo grande p (ex: p=23) e um gerador g (ex: g=5) como parâmetros públicos compartilhados.",
                                    "Alice escolhe chave privada secreta a (ex: a=6) e calcula A = g^a mod p.",
                                    "Bob escolhe chave privada secreta b (ex: b=15) e calcula B = g^b mod p.",
                                    "Alice e Bob trocam A e B publicamente.",
                                    "Registre todos os valores em uma tabela para referência."
                                  ],
                                  "verification": "Confirme que A e B foram calculados corretamente usando uma calculadora modular e que p e g são públicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora com suporte a exponenciação modular (ex: Python ou Wolfram Alpha)",
                                    "Tabela de exemplo impressa"
                                  ],
                                  "tips": "Use um primo pequeno para prática inicial; evite números grandes sem ferramentas computacionais.",
                                  "learningObjective": "Compreender a configuração inicial do protocolo e o papel de cada parâmetro.",
                                  "commonMistakes": [
                                    "Confundir chaves privadas com públicas",
                                    "Esquecer o módulo p no cálculo",
                                    "Usar g=1 que não funciona como gerador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a chave compartilhada K do ponto de vista de Alice",
                                  "subSteps": [
                                    "Alice recebe B de Bob.",
                                    "Alice computa K = B^a mod p.",
                                    "Registre o resultado passo a passo: primeiro B^a, depois mod p.",
                                    "Verifique o cálculo intermediário manualmente para p pequeno.",
                                    "Anote K_Alice."
                                  ],
                                  "verification": "K deve ser o mesmo que o esperado no exemplo (ex: K=2 para p=23, g=5, a=6, b=15).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora modular",
                                    "Papel para cálculos manuais",
                                    "Exemplo numérico prévio"
                                  ],
                                  "tips": "Compute potências por duplicação sucessiva para eficiência: B^2, B^4, etc.",
                                  "learningObjective": "Executar o cálculo da chave compartilhada usando a chave privada de Alice.",
                                  "commonMistakes": [
                                    "Usar A em vez de B",
                                    "Aplicar mod p antes da exponenciação completa",
                                    "Revelar a chave privada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a chave compartilhada K do ponto de vista de Bob",
                                  "subSteps": [
                                    "Bob recebe A de Alice.",
                                    "Bob computa K = A^b mod p.",
                                    "Registre o cálculo passo a passo similar ao de Alice.",
                                    "Compare o processo com o de Alice conceitualmente.",
                                    "Anote K_Bob."
                                  ],
                                  "verification": "K_Bob deve igualar K_Alice sem que Bob conheça a.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmos da Step 2"
                                  ],
                                  "tips": "Note a simetria: (g^b)^a = (g^a)^b mod p.",
                                  "learningObjective": "Executar o cálculo simétrico usando a chave privada de Bob.",
                                  "commonMistakes": [
                                    "Confundir expoente com base",
                                    "Ignorar propriedades logarítmicas discretas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a igualdade das chaves e discutir implicações de segurança",
                                  "subSteps": [
                                    "Compare K_Alice e K_Bob: devem ser iguais.",
                                    "Explique matematicamente por que K = g^(a*b) mod p para ambos.",
                                    "Discuta por que um atacante com A, B, p, g não pode computar K facilmente (problema do log discreto).",
                                    "Teste com valores diferentes para validar.",
                                    "Registre insights sobre confidencialidade das chaves privadas."
                                  ],
                                  "verification": "Ambas as chaves coincidem e explicação correta da igualdade é fornecida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Referência teórica rápida sobre log discreto"
                                  ],
                                  "tips": "Use exemplos com p maior para simular segurança real.",
                                  "learningObjective": "Validar o protocolo e compreender sua base matemática e segurança.",
                                  "commonMistakes": [
                                    "Achar que A ou B é a chave compartilhada",
                                    "Subestimar dificuldade computacional do log discreto"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: p=23, g=5. Alice: a=6, A=5^6 mod 23=8. Bob: b=15, B=5^15 mod 23=19. K_Alice=19^6 mod 23=2. K_Bob=8^15 mod 23=2. Chave compartilhada K=2.",
                              "finalVerifications": [
                                "Cálculo correto de K para ambos os lados no exemplo dado.",
                                "Explicação da igualdade K = g^(a*b) mod p.",
                                "Identificação de que chaves privadas permanecem secretas.",
                                "Reconhecimento do problema do log discreto como base de segurança.",
                                "Reprodução do cálculo com parâmetros ligeiramente alterados.",
                                "Descrição de um cenário de troca sem canal seguro para públicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos modulares (100% correto).",
                                "Compreensão conceitual da simetria do protocolo.",
                                "Identificação correta de componentes públicos vs. privados.",
                                "Explicação clara da segurança baseada em log discreto.",
                                "Capacidade de aplicar a novos parâmetros numéricos.",
                                "Uso eficiente de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números (logaritmo discreto).",
                                "História: Evolução da criptografia assimétrica (1976 por Diffie e Hellman).",
                                "Física: Vulnerabilidades quânticas (algoritmo de Shor quebra DH).",
                                "Ciência da Computação: Implementação em bibliotecas como OpenSSL.",
                                "Ética: Implicações de privacidade em comunicações seguras."
                              ],
                              "realWorldApplication": "Usado em protocolos como TLS/SSL para HTTPS, VPNs (IPsec), SSH e criptomoedas para troca segura de chaves de sessão sem pré-chaves compartilhadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Reconhecer vulnerabilidades básicas do Diffie-Hellman",
                            "description": "Descrever ataques como o homem-no-meio (Man-in-the-Middle) e a necessidade de autenticação para mitigar exposições, relacionando com criptoanálise básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Funcionamento Básico do Protocolo Diffie-Hellman",
                                  "subSteps": [
                                    "Estude a matemática subjacente: parâmetros públicos p (primo) e g (gerador), e chaves privadas a e b.",
                                    "Entenda o fluxo: Alice envia g^a mod p, Bob envia g^b mod p, ambos computam (g^b)^a mod p = (g^a)^b mod p.",
                                    "Identifique que a chave compartilhada é secreta apenas para Alice e Bob, sem troca direta.",
                                    "Pratique cálculos manuais com números pequenos para visualizar o processo.",
                                    "Registre as suposições de segurança: problema do logaritmo discreto."
                                  ],
                                  "verification": "Realize um cálculo manual de DH com p=23, g=5, a=6, b=15 e confirme que a chave compartilhada é 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou Python para potências modulares",
                                    "Diagrama do protocolo DH"
                                  ],
                                  "tips": "Use exponentiação modular passo a passo para evitar erros de cálculo.",
                                  "learningObjective": "Compreender os passos exatos do DH e sua dependência em logaritmo discreto.",
                                  "commonMistakes": [
                                    "Confundir chaves públicas com privadas",
                                    "Ignorar a modularidade nas potências",
                                    "Achar que o atacante vê a chave secreta diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Ausência de Autenticação no DH",
                                  "subSteps": [
                                    "Analise o protocolo: não há verificação de identidade de Alice ou Bob.",
                                    "Discuta o que acontece se um atacante interceptar: pode ver g^a e g^b, mas não a ou b facilmente.",
                                    "Explique que sem autenticação, o atacante pode se passar por uma das partes.",
                                    "Compare com protocolos autenticados como TLS.",
                                    "Liste premissas: canal público, mas confiança nas identidades ausente."
                                  ],
                                  "verification": "Descreva em uma frase por que DH sozinho não autentica identidades e dê um exemplo hipotético.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fluxograma do DH",
                                    "Artigos sobre vulnerabilidades DH",
                                    "Vídeo explicativo de 5 minutos sobre DH"
                                  ],
                                  "tips": "Pense em termos de 'quem sou eu conversando?' – DH não responde isso.",
                                  "learningObjective": "Reconhecer que DH fornece confidencialidade de chave, mas não autenticação.",
                                  "commonMistakes": [
                                    "Acreditar que logaritmo discreto protege identidades",
                                    "Confundir sigilo com autenticação",
                                    "Subestimar ataques passivos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Ataque Man-in-the-Middle (MitM) no DH",
                                  "subSteps": [
                                    "Descreva o cenário: Eve intercepta mensagens e se faz passar por Bob para Alice e vice-versa.",
                                    "Simule: Eve recebe g^a de Alice, envia g^c para Alice; Alice responde com chave K1 = (g^c)^a; Eve faz o mesmo com Bob.",
                                    "Mostre que Eve computa chaves separadas com cada um e pode descriptografar/criptografar tráfego.",
                                    "Calcule um exemplo numérico com Eve intervindo.",
                                    "Relacione com criptoanálise: exploração de falta de autenticação sem quebrar logaritmo discreto."
                                  ],
                                  "verification": "Desenhe um diagrama do ataque MitM mostrando trocas de Eve e confirme que ela obtém chaves separadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online simuladora DH (ex: Crypto101 tools)",
                                    "Papel para diagrama",
                                    "Exemplo numérico pré-pronto"
                                  ],
                                  "tips": "Visualize Eve como um 'espelho duplo' – reflete mensagens alteradas para cada lado.",
                                  "learningObjective": "Explicar mecanicamente como MitM explora DH sem autenticação.",
                                  "commonMistakes": [
                                    "Achar que Eve precisa quebrar logaritmo discreto",
                                    "Esquecer que Eve gera suas próprias chaves públicas",
                                    "Confundir MitM com eavesdropping passivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Mitigações e Relação com Criptoanálise Básica",
                                  "subSteps": [
                                    "Discuta autenticação: uso de assinaturas digitais ou chaves pré-compartilhadas.",
                                    "Estude Station-to-Station (STS) ou DH com autenticação via certificados.",
                                    "Relacione com criptoanálise: MitM é análise de protocolo, não matemática pura.",
                                    "Compare vulnerabilidades: Logjam (prefixos fracos em DH).",
                                    "Planeje como integrar autenticação em um protocolo híbrido."
                                  ],
                                  "verification": "Proponha uma modificação simples no DH para adicionar autenticação e justifique por quê funciona.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 2631 (DH com autenticação)",
                                    "Exemplos de TLS handshake",
                                    "Quiz online sobre ataques DH"
                                  ],
                                  "tips": "Lembre: autenticação resolve identidade, mas não substitui sigilo DH.",
                                  "learningObjective": "Entender mitigações essenciais e contextualizar em criptoanálise de protocolos.",
                                  "commonMistakes": [
                                    "Achar que chaves efêmeras resolvem MitM",
                                    "Ignorar necessidade de confiança em certificados",
                                    "Confundir autenticação com não-repúdio"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um chat seguro entre Alice e Bob usando DH em Python. Introduza Eve como proxy que intercepta e modifica mensagens, demonstrando como ela lê mensagens 'secretas' sem quebrar matemática, forçando Alice e Bob a usarem chaves diferentes com Eve.",
                              "finalVerifications": [
                                "Explicar o fluxo DH sem erros em 1 minuto.",
                                "Desenhar diagrama preciso de MitM no DH.",
                                "Identificar 3 consequências de MitM em DH.",
                                "Propor pelo menos 2 mitigações viáveis.",
                                "Diferenciar DH vulnerável de DH autenticado.",
                                "Relacionar ataque a criptoanálise básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do protocolo DH (matemática e fluxo).",
                                "Clareza na explicação do MitM, com exemplo numérico/diagrama.",
                                "Compreensão profunda da falta de autenticação como raiz da vulnerabilidade.",
                                "Identificação correta de mitigações e limitações.",
                                "Capacidade de relacionar a cenários reais de criptoanálise.",
                                "Criatividade em verificações e exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmo discreto e teoria dos números.",
                                "Segurança da Informação: Análise de protocolos e ameaças ativas.",
                                "Redes de Computadores: Interceptação em canais públicos.",
                                "Ética em Computação: Implicações de ataques em comunicações seguras."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/SSL (HTTPS), DH é usado com autenticação via certificados para evitar MitM; vulnerabilidades como Logjam (2015) exploraram DH fraco, levando a atualizações em browsers e servidores para mitigar ataques em VPNs, SSH e WhatsApp."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Troca de Chaves com Criptografia de Chave Pública",
                        "description": "Uso de criptosistemas assimétricos, como RSA, para encriptar e transmitir chaves simétricas de forma segura entre partes remotas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Gerar pares de chaves RSA para troca",
                            "description": "Explicar a geração de chaves pública (e, n) e privada (d, n) no RSA e como a parte receptora usa sua chave pública para que o emissor encripte a chave simétrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar dois números primos grandes p e q",
                                  "subSteps": [
                                    "Identifique critérios para primos: grandes (pelo menos 1024 bits no total), distintos e aleatórios.",
                                    "Use testes de primalidade como Miller-Rabin para verificar.",
                                    "Gere ou selecione p e q seguros (ex: p=61, q=53 para exemplo educativo).",
                                    "Registre os valores escolhidos.",
                                    "Verifique que p ≠ q e ambos são ímpares (exceto 2)."
                                  ],
                                  "verification": "Confirme que p e q são primos usando um teste de primalidade ou fatoração manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como Python com sympy.isprime()",
                                    "Tabela de primos pequenos para testes"
                                  ],
                                  "tips": "Para produção, use bibliotecas criptográficas como OpenSSL para gerar primos seguros.",
                                  "learningObjective": "Compreender a importância de primos grandes e distintos na segurança do RSA.",
                                  "commonMistakes": [
                                    "Escolher números compostos como primos",
                                    "Usar primos iguais",
                                    "Selecionar primos muito pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular n = p * q e φ(n) = (p-1) * (q-1)",
                                  "subSteps": [
                                    "Multiplique p por q para obter n (módulo público).",
                                    "Calcule φ(n) como (p-1) * (q-1), função totiente de Euler.",
                                    "Verifique o cálculo aritmético.",
                                    "Armazene n como parte de ambas as chaves.",
                                    "Confirme que φ(n) é correto comparando com fatoração conhecida."
                                  ],
                                  "verification": "n deve ser o produto exato de p e q; φ(n) deve ser (p-1)(q-1).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora de alta precisão ou Python para multiplicações grandes"
                                  ],
                                  "tips": "n deve ser difícil de fatorar; tamanho de n determina força da criptografia.",
                                  "learningObjective": "Dominar cálculos fundamentais do módulo e totiente no RSA.",
                                  "commonMistakes": [
                                    "Erro de multiplicação em números grandes",
                                    "Confundir φ(n) com n-1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolher expoente público e coprimo com φ(n)",
                                  "subSteps": [
                                    "Selecione e tal que 1 < e < φ(n) e gcd(e, φ(n)) = 1 (ex: 65537).",
                                    "Teste coprimaridade usando algoritmo de Euclides.",
                                    "Prefira e pequeno e comum para eficiência.",
                                    "Documente por que e foi escolhido.",
                                    "Verifique múltiplos candidatos se necessário."
                                  ],
                                  "verification": "gcd(e, φ(n)) = 1 confirmado pelo algoritmo estendido de Euclides.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Implementação do algoritmo de Euclides em Python ou Wolfram Alpha"
                                  ],
                                  "tips": "65537 é Fermat prime, ideal por ser 2^16 +1, eficiente em hardware.",
                                  "learningObjective": "Entender o papel de e como expoente de encriptação pública.",
                                  "commonMistakes": [
                                    "Escolher e não coprimo",
                                    "Usar e >= φ(n)",
                                    "Ignorar eficiência computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular expoente privado d = e^{-1} mod φ(n)",
                                  "subSteps": [
                                    "Aplique o algoritmo estendido de Euclides para encontrar d tal que (d * e) mod φ(n) = 1.",
                                    "Resolva a equação modular.",
                                    "Verifique: (d * e) % φ(n) == 1.",
                                    "Mantenha d secreto.",
                                    "Teste com encriptação/decryptação simples."
                                  ],
                                  "verification": "(d * e) mod φ(n) = 1 e decrypt(m^e mod n)^d mod n = m.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca sympy.mod_inverse() ou implementação manual do Extended Euclidean"
                                  ],
                                  "tips": "Nunca exponha d; use chaves seguras para armazená-lo.",
                                  "learningObjective": "Aprender inverso modular essencial para descriptografia.",
                                  "commonMistakes": [
                                    "Erro no Extended Euclidean",
                                    "Calcular d incorreto levando a falha na decrypt"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formar chaves e demonstrar uso na troca de chaves simétricas",
                                  "subSteps": [
                                    "Chave pública: (e, n); privada: (d, n).",
                                    "Receptor envia pública para emissor.",
                                    "Emissor gera chave simétrica K, encripta c = K^e mod n, envia c.",
                                    "Receptor descriptografa K = c^d mod n.",
                                    "Verifique troca com exemplo numérico."
                                  ],
                                  "verification": "Chave simétrica recuperada corretamente pelo receptor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com pow() para exponentiação modular",
                                    "Exemplo numérico pronto"
                                  ],
                                  "tips": "Na prática, use PKCS#1 para padding em encriptação de chaves.",
                                  "learningObjective": "Aplicar pares de chaves RSA em protocolos de troca híbrida.",
                                  "commonMistakes": [
                                    "Expor chave privada",
                                    "Não usar padding",
                                    "Confundir encriptador/descriptografador"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: p=61, q=53. n=3233, φ(n)=3120. e=17 (gcd(17,3120)=1). d=2753 (17*2753 mod 3120=1). Público: (17,3233). Encripte K=42: 42^17 mod 3233=1316. Descripte: 1316^2753 mod 3233=42.",
                              "finalVerifications": [
                                "Par (e,n) e (d,n) gerados com cálculos corretos.",
                                "(d * e) mod φ(n) = 1.",
                                "Encriptação de mensagem com pública e descriptografia com privada funciona.",
                                "Explicação clara do fluxo de troca de chave simétrica.",
                                "Identificação de p,q a partir de n é computacionalmente difícil.",
                                "Uso correto de termos: público para encriptar, privado para descriptografar."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos matemáticos (100% correto).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Eficiência na escolha de parâmetros (e.g., e=65537).",
                                "Segurança básica respeitada (primos grandes, segredo de d).",
                                "Aplicação prática na troca híbrida explicada.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primalidade, Euclides, módulos).",
                                "Segurança da Informação: Criptografia assimétrica vs. simétrica.",
                                "Computação: Algoritmos eficientes e bibliotecas (e.g., OpenSSL).",
                                "Física: Ameaças quânticas ao RSA (Shor's algorithm)."
                              ],
                              "realWorldApplication": "Geração de chaves RSA em protocolos como TLS/SSL para HTTPS, permitindo troca segura de chaves simétricas em navegação web, e-mails (PGP) e VPNs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Executar encriptação e decriptação de chaves simétricas",
                            "description": "Demonstrar o processo: gerar chave simétrica K, encriptar C = K^e mod n com a chave pública do receptor, transmitir C e decriptar K = C^d mod n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar chaves assimétricas do receptor (chave pública e privada RSA)",
                                  "subSteps": [
                                    "Escolha dois números primos pequenos p e q (ex: p=61, q=53)",
                                    "Calcule n = p * q (n=3233) e phi(n) = (p-1)*(q-1) = 3120",
                                    "Escolha e coprimo com phi(n), como e=17 (gcd(17,3120)=1)",
                                    "Calcule d como inverso modular de e mod phi(n): d=2753 (17*2753 ≡ 1 mod 3120)",
                                    "Verifique: (e * d) % phi(n) == 1"
                                  ],
                                  "verification": "Confirme que gcd(e, phi(n)) == 1 e (e * d) % phi(n) == 1 usando Python: pow(e, -1, phi_n)",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Python interpreter",
                                    "Biblioteca sympy para primos e inversos (opcional: sympy.gcd, sympy.mod_inverse)"
                                  ],
                                  "tips": "Use números primos pequenos para testes manuais; armazene n, e como chave pública e d como privada",
                                  "learningObjective": "Compreender a geração de pares de chaves RSA para troca segura de chaves simétricas",
                                  "commonMistakes": [
                                    "Escolher e não coprimo com phi(n)",
                                    "Erro no cálculo de phi(n) incluindo p ou q",
                                    "Confundir ordem de p e q no cálculo de n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar chave simétrica K no lado do remetente",
                                  "subSteps": [
                                    "Obtenha a chave pública do receptor (n=3233, e=17)",
                                    "Gere um número aleatório K como inteiro entre 1 e n-1 (ex: K=42 usando random.randint(1, n-1))",
                                    "Registre K como a chave simétrica secreta a ser compartilhada",
                                    "Garanta que K seja adequado para cifra simétrica (ex: 128-256 bits em produção)"
                                  ],
                                  "verification": "Verifique que 1 < K < n e registre o valor exato de K",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Python com import random"
                                  ],
                                  "tips": "Em produção, use criptografia segura como os.urandom; aqui use random para simplicidade educacional",
                                  "learningObjective": "Aprender a gerar chaves simétricas aleatórias e seguras para cifragem posterior",
                                  "commonMistakes": [
                                    "Gerar K >= n, causando overflow em exponenciação modular",
                                    "Usar random sem seed ou não aleatório o suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encriptar a chave simétrica K com a chave pública do receptor",
                                  "subSteps": [
                                    "Use a fórmula C = K^e mod n (ex: C = pow(42, 17, 3233) = 1455)",
                                    "Implemente em Python: C = pow(K, e, n)",
                                    "Registre o valor de C como o ciphertext a ser transmitido",
                                    "Simule a transmissão enviando C para o receptor"
                                  ],
                                  "verification": "Compute C e confirme que é um inteiro entre 0 e n-1",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Python interpreter"
                                  ],
                                  "tips": "A função pow(base, exp, mod) é eficiente para grandes números; evite loops manuais",
                                  "learningObjective": "Dominar a encriptação assimétrica de chaves simétricas usando exponenciação modular",
                                  "commonMistakes": [
                                    "Esquecer o módulo n, resultando em números gigantes",
                                    "Confundir expoente e base na fórmula"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decriptar o ciphertext C no lado do receptor para recuperar K",
                                  "subSteps": [
                                    "Receba C do remetente (ex: C=1455)",
                                    "Use a chave privada: K_recuperada = C^d mod n (ex: pow(1455, 2753, 3233) = 42)",
                                    "Implemente em Python: K_recuperada = pow(C, d, n)",
                                    "Compare K_recuperada com o K original enviado"
                                  ],
                                  "verification": "Confirme que K_recuperada == K original (ex: 42 == 42)",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Python interpreter"
                                  ],
                                  "tips": "A decriptação deve ser computacionalmente inviável sem d; teste com e sem d para demonstrar",
                                  "learningObjective": "Entender a decriptação assimétrica para troca segura de chaves simétricas",
                                  "commonMistakes": [
                                    "Usar e em vez de d na decriptação",
                                    "Erro de cálculo modular levando a K incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a integridade da chave trocada e discutir segurança",
                                  "subSteps": [
                                    "Compare K original e K_recuperada para igualdade",
                                    "Discuta por que isso é seguro (dificuldade de fatorar n)",
                                    "Teste com K diferente para validar o processo repetidamente",
                                    "Considere ataques: evite reutilizar K, use padding em produção (OAEP)"
                                  ],
                                  "verification": "K_recuperada matches K em múltiplos testes; documente resultados",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resultados dos steps anteriores"
                                  ],
                                  "tips": "Registre todos os valores em um log para auditoria",
                                  "learningObjective": "Avaliar a eficácia do protocolo de troca de chaves híbrido",
                                  "commonMistakes": [
                                    "Ignorar padding, vulnerável a ataques como Bleichenbacher",
                                    "Reutilizar chaves em testes múltiplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Receptor gera: p=61, q=53, n=3233, e=17, d=2753. Remetente gera K=42, C=pow(42,17,3233)=1455. Transmite C. Receptor: pow(1455,2753,3233)=42. Chave trocada com sucesso!",
                              "finalVerifications": [
                                "K_recuperada == K_original em pelo menos 3 testes com K diferentes",
                                "Todos os cálculos modulares estão corretos (0 <= resultado < n)",
                                "Chave pública (n,e) compartilhada corretamente sem vazar d",
                                "Tempo de execução é eficiente (pow() < 1s)",
                                "Nenhum erro de overflow ou divisão por zero",
                                "Log completo de valores intermediários documentado"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas C = K^e mod n e K = C^d mod n aplicadas corretamente (100%)",
                                "Implementação prática: Código Python funcional e reproduzível",
                                "Compreensão conceitual: Explicação clara de por que assimétrico protege a chave simétrica",
                                "Tratamento de erros: Identificação e correção de common mistakes",
                                "Eficiência: Uso de pow() em vez de implementações ineficientes",
                                "Segurança básica: Discussão de limitações (primos pequenos, sem padding)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, Teorema de Euler, Inversos modulares",
                                "Segurança da Informação: Protocolos híbridos como TLS/SSL",
                                "Programação: Manipulação de grandes inteiros em Python",
                                "Física/Engenharia: Analogia com sinais seguros em comunicações",
                                "Ética: Implicações de criptografia em privacidade digital"
                              ],
                              "realWorldApplication": "Esse processo é a base para troca de chaves em HTTPS/TLS (ex: RSA key exchange em navegadores), VPNs (IPsec), e apps de mensagens seguras como Signal, onde chaves simétricas (AES) são trocadas via assimétricas para cifragem eficiente de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Comparar com criptosistemas simétricos puros",
                            "description": "Analisar vantagens da troca híbrida (chave pública para chave simétrica) em eficiência e segurança em canais não confiáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Criptosistemas Simétricos Puros",
                                  "subSteps": [
                                    "Defina criptografia simétrica e exemplos como AES.",
                                    "Explique o processo de troca de chaves simétricas (ex: envio direto da chave).",
                                    "Identifique vulnerabilidades em canais não confiáveis, como interceptação por eavesdroppers.",
                                    "Calcule overhead computacional básico (chaves curtas, operações rápidas).",
                                    "Discuta escalabilidade para múltiplos usuários."
                                  ],
                                  "verification": "Resuma em um diagrama os problemas de troca de chaves simétricas em canais públicos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre AES, diagrama de fluxo de dados.",
                                  "tips": "Use analogias como 'trocar uma chave de casa pelo correio' para visualizar riscos.",
                                  "learningObjective": "Compreender limitações inerentes da criptografia simétrica pura em ambientes não seguros.",
                                  "commonMistakes": "Confundir criptografia simétrica com assimétrica; ignorar impacto de canais não confiáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Troca de Chaves Híbrida com Criptografia de Chave Pública",
                                  "subSteps": [
                                    "Descreva o modelo híbrido: usar RSA/EC para encriptar chave simétrica (ex: AES key).",
                                    "Detalhe o protocolo: Alice gera chave simétrica, encripta com chave pública de Bob, envia.",
                                    "Explique decodificação: Bob usa chave privada para recuperar chave simétrica.",
                                    "Compare tamanhos: chaves assimétricas maiores, mas usadas só uma vez.",
                                    "Simule fluxo em pseudocódigo."
                                  ],
                                  "verification": "Crie um fluxograma do protocolo híbrido e identifique o papel de cada chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Pseudocódigo de Diffie-Hellman/RSA híbrido, ferramenta como Draw.io para diagramas.",
                                  "tips": "Foquem na 'troca única' da chave assimétrica para minimizar exposição.",
                                  "learningObjective": "Dominar o mecanismo da troca híbrida e sua integração simétrica-assimétrica.",
                                  "commonMistakes": "Achar que híbrido usa só assimétrica; subestimar necessidade de chaves simétricas para bulk data."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Eficiência Computacional e de Recursos",
                                  "subSteps": [
                                    "Meça custo: simétrico (rápido, mas troca insegura); híbrido (assimétrica lenta, mas só inicial).",
                                    "Analise latência: tempo de setup vs. throughput de dados.",
                                    "Compare uso de banda: tamanho de mensagens de troca de chaves.",
                                    "Calcule para cenários: 1 usuário vs. N usuários (escalabilidade).",
                                    "Use métricas: operações por segundo (benchmarks AES vs. RSA)."
                                  ],
                                  "verification": "Tabela comparativa com métricas numéricas (ex: ms para troca de 1KB).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabelas de benchmarks (NIST), calculadora ou spreadsheet.",
                                  "tips": "Priorize 'custo inicial vs. custo contínuo' para híbrido vencer em sessões longas.",
                                  "learningObjective": "Quantificar vantagens de eficiência da abordagem híbrida.",
                                  "commonMistakes": "Ignorar overhead de assimétrica só no handshake; superestimar velocidade simétrica em escala."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens de Segurança em Canais Não Confiáveis",
                                  "subSteps": [
                                    "Simétrico: risco total se chave interceptada; sem Perfect Forward Secrecy (PFS).",
                                    "Híbrido: chave simétrica nunca exposta em claro; PFS possível com ephemeral keys.",
                                    "Discuta ataques: MITM em simétrico vs. resistência em híbrido (com certificados).",
                                    "Avalie forward/backward secrecy.",
                                    "Compare resistências: brute-force, quantum threats."
                                  ],
                                  "verification": "Lista de 5 ataques e como híbrido mitiga vs. simétrico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Casos de estudo (Heartbleed vs. TLS 1.3), lista de ataques comuns.",
                                  "tips": "Enfatize 'canal não confiável = público/internet'; híbrido resolve distribuição segura.",
                                  "learningObjective": "Identificar superioridade de segurança híbrida sem sacrificar eficiência.",
                                  "commonMistakes": "Confundir segurança com velocidade; achar simétrico 'bom o suficiente' para internet."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Vantagens Gerais e Conclusões",
                                  "subSteps": [
                                    "Compile prós/cons em matriz comparativa.",
                                    "Discuta trade-offs: híbrido ideal para web/email/VPN.",
                                    "Preveja cenários futuros (IoT, 5G).",
                                    "Crie argumento persuasivo para uso híbrido.",
                                    "Autoavalie compreensão."
                                  ],
                                  "verification": "Relatório de 1 página resumindo por que híbrido > simétrico puro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matriz template (Excel/Google Sheets).",
                                  "tips": "Use dados dos steps anteriores para evidências quantitativas.",
                                  "learningObjective": "Integrar conhecimentos para análise crítica e recomendação.",
                                  "commonMistakes": "Ser tendencioso sem dados; ignorar contextos onde simétrico ainda aplica (ex: LAN segura)."
                                }
                              ],
                              "practicalExample": "Em um chat seguro como Signal: Use curva elíptica (pública) para trocar chave simétrica AES; mensagens subsequentes usam AES rápido. Compare com envio direto de AES key por WhatsApp não criptografado – híbrido previne eavesdropping em WiFi público.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças em eficiência para um par de usuários.",
                                "Desenhar protocolo híbrido vs. simétrico sem erros.",
                                "Identificar 3 cenários onde híbrido falha (ex: chaves públicas comprometidas).",
                                "Calcular tempo relativo de setup para 100 conexões.",
                                "Defender uso híbrido em debate simulado.",
                                "Listar mitigações para fraquezas remanescentes do híbrido."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (80% correto em definições).",
                                "Profundidade quantitativa (uso de métricas/benchmarks).",
                                "Análise crítica de trade-offs (prós/cons balanceados).",
                                "Clareza em diagramas e explicações.",
                                "Aplicação a cenários reais (relevância).",
                                "Originalidade em exemplos/síntese."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, log discreto em RSA/EC).",
                                "Redes de Computadores: Protocolos TLS/SSH handshakes.",
                                "Segurança da Informação: Análise de ameaças MITM/eavesdropping.",
                                "Física/Engenharia: Otimização de recursos em dispositivos IoT limitados."
                              ],
                              "realWorldApplication": "Protocolos HTTPS/TLS usam híbrido para sessões web seguras (Google, bancos); VPNs como WireGuard trocam chaves assimétricas iniciais para túneis simétricos eficientes em internet não confiável, protegendo milhões de transações diárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Protocolos Híbridos e Considerações Práticas",
                        "description": "Combinação de protocolos simétricos e assimétricos para trocas seguras em cenários reais, incluindo extensões como ECDH e referências bibliográficas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Descrever protocolos híbridos como TLS handshake",
                            "description": "Explicar o uso de Diffie-Hellman ou RSA no handshake TLS para gerar chaves de sessão simétricas, integrando autenticação e confidencialidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Criptografia Híbrida",
                                  "subSteps": [
                                    "Diferencie criptografia simétrica (ex: AES) de assimétrica (ex: RSA, Diffie-Hellman).",
                                    "Explique por que sistemas híbridos combinam ambas para eficiência e segurança.",
                                    "Identifique os objetivos principais: confidencialidade, autenticação e integridade no TLS.",
                                    "Revise conceitos de chaves públicas/privadas e troca de chaves efêmera.",
                                    "Estude o papel da autenticação mútua ou unilateral no contexto TLS."
                                  ],
                                  "verification": "Resuma em 3-5 frases os prós e contras de criptografia híbrida, citando exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 8446 (TLS 1.3), Khan Academy: Criptografia Assimétrica",
                                    "Diagramas de chaves simétricas vs. assimétricas"
                                  ],
                                  "tips": "Use analogias como 'chave mestra (pública) para abrir cofre e chave secreta (simétrica) para dados'.",
                                  "learningObjective": "Compreender a necessidade e base teórica de protocolos híbridos como TLS.",
                                  "commonMistakes": "Confundir simétrica com assimétrica; ignorar overhead computacional da assimétrica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear o Fluxo Geral do TLS Handshake",
                                  "subSteps": [
                                    "Descreva as fases: ClientHello, ServerHello, troca de certificados e chaves.",
                                    "Identifique mensagens chave: ClientHello (suporte a cifras), Certificate, ServerKeyExchange.",
                                    "Explique o Record Protocol e como o handshake estabelece o estado de sessão.",
                                    "Diferencie TLS 1.2 (RSA comum) de TLS 1.3 (DH preferido).",
                                    "Desenhe um diagrama sequencial do handshake básico."
                                  ],
                                  "verification": "Crie um fluxograma simples do handshake TLS 1.2 com 6-8 mensagens principais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark para capturas de tráfego HTTPS",
                                    "Cloudflare TLS Explainer",
                                    "Vídeo: TLS Handshake em 5 minutos"
                                  ],
                                  "tips": "Pense no handshake como uma 'conversa segura inicial' antes da comunicação real.",
                                  "learningObjective": "Visualizar a sequência temporal do TLS handshake.",
                                  "commonMistakes": "Omitir ServerHello ou confundir ordem das mensagens; ignorar renegociação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar Uso de Diffie-Hellman ou RSA na Troca de Chaves",
                                  "subSteps": [
                                    "Explique RSA: Cliente criptografa pre-master secret com chave pública do servidor.",
                                    "Descreva Diffie-Hellman (DHE/ECDHE): Computação compartilhada de secret sem envio direto.",
                                    "Compare forward secrecy: DH oferece, RSA clássico não.",
                                    "Detalhe derivação da master secret e chaves de sessão simétricas (via PRF/HKDF).",
                                    "Analise autenticação via certificado X.509 e assinatura digital."
                                  ],
                                  "verification": "Escreva pseudocódigo para geração de chave via RSA ou DH no handshake.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "OpenSSL docs para comandos de handshake",
                                    "RFC 5246 (TLS 1.2), RFC 8446 (TLS 1.3)",
                                    "Ferramenta online: TLS Handshake Simulator"
                                  ],
                                  "tips": "Lembre: RSA é 'envio criptografado', DH é 'computação conjunta mágica'.",
                                  "learningObjective": "Dominar mecanismos exatos de geração de chaves simétricas.",
                                  "commonMistakes": "Confundir pre-master com master secret; ignorar ephemeral keys em DH."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Autenticação, Confidencialidade e Praticar Descrição",
                                  "subSteps": [
                                    "Descreva como assinatura do servidor autentica identidade.",
                                    "Explique criptografia simétrica pós-handshake para dados (confidencialidade).",
                                    "Discuta Finished messages para verificação mútua.",
                                    "Simule um handshake completo narrando cada passo verbalmente ou por escrito.",
                                    "Identifique vulnerabilidades como POODLE ou downgrade attacks."
                                  ],
                                  "verification": "Registre uma descrição completa do handshake em 300 palavras, incluindo DH/RSA.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Browser DevTools para inspecionar HTTPS",
                                    "Exercícios interativos em Crypto101.io"
                                  ],
                                  "tips": "Pratique explicando para um 'amigo imaginário' sem conhecimento técnico.",
                                  "learningObjective": "Articular integralmente como TLS garante segurança híbrida.",
                                  "commonMistakes": "Esquecer verificação de Finished; superestimar segurança sem PFS."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Refinar Conhecimento",
                                  "subSteps": [
                                    "Compare TLS com outros protocolos híbridos (SSH, IPsec).",
                                    "Teste com cenários: Ataque MITM sem autenticação.",
                                    "Otimize descrição para clareza, adicionando diagramas.",
                                    "Revise diferenças entre versões TLS.",
                                    "Autoavalie usando critérios de avaliação."
                                  ],
                                  "verification": "Passe no quiz interno: Descreva handshake sem consultar notas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quiz online TLS Handshake",
                                    "Comparação TLS vs SSL"
                                  ],
                                  "tips": "Grave sua explicação e compare com fontes autoritativas.",
                                  "learningObjective": "Consolidar e aplicar conhecimento de forma independente.",
                                  "commonMistakes": "Ignorar evoluções como TLS 1.3 (sem RSA estático)."
                                }
                              ],
                              "practicalExample": "Simule um navegador (cliente) acessando google.com (servidor): Cliente envia ClientHello com suporte a ECDHE-RSA-AES256; servidor responde com certificado, chave DH efêmera; ambos derivam chave simétrica AES para trafegar dados criptografados, autenticando servidor via CA.",
                              "finalVerifications": [
                                "Diagramar corretamente o fluxo de mensagens TLS handshake.",
                                "Explicar geração de chave simétrica via DH ou RSA sem erros.",
                                "Identificar papel da autenticação via certificado.",
                                "Diferenciar forward secrecy em DH vs RSA.",
                                "Descrever derivação de master secret e chaves de sessão.",
                                "Simular handshake em ferramenta como Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção em mecanismos de chave (90%+).",
                                "Completude: Cobertura de autenticação e confidencialidade.",
                                "Clareza: Explicação acessível com analogias/diagramas.",
                                "Profundidade: Inclusão de DH ephemeral e PRF/HKDF.",
                                "Aplicação: Ligação a cenários reais como HTTPS.",
                                "Originalidade: Evidência de compreensão além de memorização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (primos, log discreto em DH).",
                                "Redes: Protocolos TCP/UDP e camadas OSI (TLS em transporte).",
                                "Segurança: Análise de ameaças (MITM, replay attacks).",
                                "Programação: Implementação em Python com ssl library."
                              ],
                              "realWorldApplication": "Todo tráfego HTTPS (bancos, e-mails) usa TLS handshake para sessões seguras; sem ele, dados seriam expostos em Wi-Fi públicas, permitindo roubo de credenciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Aplicar conceitos de algoritmos probabilísticos",
                            "description": "Relacionar a natureza probabilística de protocolos como Diffie-Hellman com criptoanálise, citando fontes como Menezes e Schneier para validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos probabilísticos do protocolo Diffie-Hellman",
                                  "subSteps": [
                                    "Revisar a descrição matemática do protocolo Diffie-Hellman, focando em parâmetros públicos (p, g) e privados (a, b).",
                                    "Identificar elementos probabilísticos: escolha aleatória de expoentes privados e a dependência de propriedades do grupo multiplicativo.",
                                    "Analisar por que o protocolo é probabilístico, relacionando à dificuldade computacional do logaritmo discreto.",
                                    "Estudar exemplos numéricos simples para visualizar a geração de chaves compartilhadas.",
                                    "Mapear a aleatoriedade necessária para segurança contra ataques de força bruta."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando os aspectos probabilísticos do DH, com um exemplo numérico resolvido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Handbook of Applied Cryptography (Menezes et al., Capítulo 8)",
                                    "Applied Cryptography (Schneier, 2ª edição, Capítulo 22)",
                                    "Calculadora ou software como SageMath para logaritmo discreto"
                                  ],
                                  "tips": "Use exemplos pequenos (p=23, g=5) para entender sem sobrecarga computacional.",
                                  "learningObjective": "Identificar e descrever os componentes probabilísticos essenciais no protocolo Diffie-Hellman.",
                                  "commonMistakes": [
                                    "Confundir probabilidade com determinismo, ignorando a aleatoriedade dos expoentes.",
                                    "Não relacionar à segurança baseada em problemas difíceis como log discreto.",
                                    "Usar parâmetros fracos sem perceber impactos probabilísticos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar a natureza probabilística com técnicas de criptoanálise",
                                  "subSteps": [
                                    "Explorar ataques probabilísticos como man-in-the-middle e colisões em grupos pequenos.",
                                    "Analisar vulnerabilidades devido a má escolha de parâmetros (p pequeno, g não gerador).",
                                    "Estudar ataques baseados em probabilidade, como Pollard's rho para log discreto.",
                                    "Comparar sucesso de ataques determinísticos vs. probabilísticos em termos de complexidade.",
                                    "Simular um cenário de criptoanálise probabilística com parâmetros fracos."
                                  ],
                                  "verification": "Desenhar um diagrama de um ataque probabilístico ao DH e calcular sua probabilidade de sucesso.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas sobre ataques ao DH (RFC 2631)",
                                    "Software Python com biblioteca cryptography ou sympy",
                                    "Referências Schneier sobre análise de protocolos"
                                  ],
                                  "tips": "Comece com grupos pequenos para simular ataques viáveis em tempo real.",
                                  "learningObjective": "Explicar como falhas probabilísticas no DH facilitam criptoanálise.",
                                  "commonMistakes": [
                                    "Ignorar o papel da entropia na geração de chaves.",
                                    "Confundir ataques passivos com ativos no contexto probabilístico.",
                                    "Subestimar o impacto de reutilização de parâmetros."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar conceitos com fontes autorizadas (Menezes e Schneier)",
                                  "subSteps": [
                                    "Ler seções específicas: Menezes (8.7-8.8 sobre DH e segurança probabilística).",
                                    "Consultar Schneier (22.4 sobre falhas em protocolos de chave e análise probabilística).",
                                    "Extrair citações chave sobre natureza probabilística e recomendações para parâmetros seguros.",
                                    "Comparar visões de ambos autores sobre criptoanálise de DH.",
                                    "Compilar um glossário de termos probabilísticos citados nas fontes."
                                  ],
                                  "verification": "Criar uma tabela comparativa com citações de Menezes e Schneier sobre probabilidade no DH.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "PDFs ou livros: Handbook of Applied Cryptography e Applied Cryptography",
                                    "Ferramenta de anotações como Notion ou papel e caneta"
                                  ],
                                  "tips": "Busque termos como 'probabilistic polynomial time' e 'random oracle model'.",
                                  "learningObjective": "Citar e validar relacionamentos probabilísticos com literatura especializada.",
                                  "commonMistakes": [
                                    "Citar fora de contexto, distorcendo a análise probabilística.",
                                    "Ignorar atualizações em edições posteriores dos livros.",
                                    "Não diferenciar opiniões teóricas de práticas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos em uma análise integrada de criptoanálise",
                                  "subSteps": [
                                    "Integrar conhecimentos: simular DH seguro vs. inseguro probabilisticamente.",
                                    "Realizar uma mini-análise de criptoanálise, prevendo probabilidades de quebra.",
                                    "Propor melhorias baseadas em fontes (ex: usar curvas elípticas).",
                                    "Documentar o processo completo com citações.",
                                    "Avaliar trade-offs entre probabilidade e eficiência computacional."
                                  ],
                                  "verification": "Produzir um relatório curto (500 palavras) com simulação, análise e citações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python ou JavaScript para simulação DH",
                                    "Referências bibliográficas compiladas"
                                  ],
                                  "tips": "Use bibliotecas prontas como pycryptodome para foco na análise, não implementação.",
                                  "learningObjective": "Aplicar holisticamente conceitos probabilísticos em cenários de criptoanálise.",
                                  "commonMistakes": [
                                    "Focar só em teoria sem simulação prática.",
                                    "Não quantificar probabilidades numericamente.",
                                    "Omitir validação com fontes."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o protocolo Diffie-Hellman em Python com parâmetros fracos (p=101, g=2), simule 100 trocas de chaves e aplique um ataque de log discreto probabilístico (Pollard's rho). Meça taxa de sucesso (esperada ~30% em 100 tentativas), citando Schneier sobre por que parâmetros fortes evitam isso.",
                              "finalVerifications": [
                                "Explicar verbalmente a probabilidade inerente no DH e seu link com criptoanálise.",
                                "Simular com sucesso um ataque probabilístico em parâmetros fracos.",
                                "Citar corretamente pelo menos 3 trechos de Menezes e Schneier.",
                                "Identificar 2 melhorias para mitigar riscos probabilísticos.",
                                "Calcular complexidade probabilística de um ataque (ex: O(sqrt(p))).",
                                "Discutir limitações em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de elementos probabilísticos (30%)",
                                "Correta relação com criptoanálise e exemplos (25%)",
                                "Uso adequado de citações de fontes (20%)",
                                "Qualidade da simulação prática e verificações (15%)",
                                "Clareza e profundidade na aplicação integrada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Logaritmo Discreto",
                                "Probabilidade e Estatística: Modelos Probabilísticos e Complexidade",
                                "Física: Entropia e Mecânica Quântica em Criptografia Pós-QP",
                                "Ética: Implicações de Segurança em Protocolos Probabilísticos"
                              ],
                              "realWorldApplication": "No protocolo TLS 1.3 para HTTPS, o DH é usado em modo efêmero (DHE) para troca probabilística de chaves, resistindo a criptoanálise quântica parcial e garantindo privacidade em comunicações web seguras, como em bancos online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Protocolos de Assinatura Digital",
                    "description": "Protocolos que utilizam assinaturas para garantir autenticidade, integridade e não-repúdio de mensagens.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Princípios Fundamentais de Assinaturas Digitais",
                        "description": "Conceitos básicos que definem o que são assinaturas digitais e suas propriedades essenciais para garantir segurança em protocolos criptográficos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Definir assinatura digital",
                            "description": "Explicar o conceito de assinatura digital como um mecanismo criptográfico que usa chaves assimétricas para anexar uma 'assinatura' matemática a uma mensagem, permitindo verificação posterior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Criptografia Assimétrica",
                                  "subSteps": [
                                    "Pesquise e defina chave pública e chave privada em criptografia assimétrica.",
                                    "Compare com criptografia simétrica, destacando a diferença no uso de chaves.",
                                    "Identifique funções hash como base para assinaturas (ex: SHA-256).",
                                    "Estude o papel do hash na criação de uma representação única de dados.",
                                    "Visualize um diagrama simples de par de chaves assimétricas."
                                  ],
                                  "verification": "Crie um diagrama rotulado de chaves pública/privada e explique verbalmente para um parceiro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para artigos sobre RSA/AES",
                                    "Papel e caneta para diagrama",
                                    "Vídeo introdutório sobre criptografia assimétrica (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'casa com duas chaves: uma para trancar (privada), uma para qualquer um abrir (pública)'.",
                                  "learningObjective": "Compreender como chaves assimétricas diferem da simetria e preparam o terreno para assinaturas.",
                                  "commonMistakes": [
                                    "Confundir chave pública com privada",
                                    "Ignorar o papel do hash na integridade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Processo de Criação da Assinatura Digital",
                                  "subSteps": [
                                    "Selecione uma mensagem ou documento de exemplo.",
                                    "Aplique uma função hash à mensagem para gerar um digest.",
                                    "Criptografe o digest com a chave privada do assinante usando algoritmo como RSA.",
                                    "Anexe a assinatura criptografada à mensagem original.",
                                    "Salve ou envie o pacote mensagem + assinatura."
                                  ],
                                  "verification": "Simule o processo em pseudocódigo ou ferramenta online como CryptoJS e gere uma assinatura de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de criptografia (ex: CyberChef ou jsfiddle com CryptoJS)",
                                    "Mensagem de texto simples para teste"
                                  ],
                                  "tips": "Lembre-se: só a chave privada assina; pública só verifica.",
                                  "learningObjective": "Dominar os passos matemáticos para gerar uma 'assinatura' única e vinculada ao assinante.",
                                  "commonMistakes": [
                                    "Criptografar a mensagem inteira em vez do hash",
                                    "Usar chave pública para assinar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Processo de Verificação da Assinatura",
                                  "subSteps": [
                                    "Receba a mensagem + assinatura e obtenha a chave pública do assinante.",
                                    "Calcule o hash da mensagem recebida.",
                                    "Descriptografe a assinatura com a chave pública para obter o digest original.",
                                    "Compare os dois digests: se iguais, assinatura válida.",
                                    "Discuta falhas: alteração na mensagem invalida a verificação."
                                  ],
                                  "verification": "Use a mesma ferramenta do Step 2 para verificar a assinatura gerada anteriormente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma ferramenta online do Step 2",
                                    "Chave pública correspondente"
                                  ],
                                  "tips": "Analogia: selo de cera quebra se envelope aberto – hash muda se mensagem alterada.",
                                  "learningObjective": "Saber como qualquer um pode verificar autenticidade e integridade sem chave privada.",
                                  "commonMistakes": [
                                    "Assumir que verificação requer chave privada",
                                    "Não recalcular hash da mensagem recebida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Propriedades e Benefícios das Assinaturas Digitais",
                                  "subSteps": [
                                    "Liste propriedades: autenticidade, integridade, não-repúdio.",
                                    "Compare com assinaturas manuscritas: digital previne falsificação via matemática.",
                                    "Discuta ataques comuns: colisão de hash, roubo de chave privada.",
                                    "Explore padrões: PKCS#7, assinatura com timestamp.",
                                    "Resuma o fluxo completo em um fluxograma."
                                  ],
                                  "verification": "Crie um fluxograma do processo completo e explique as três propriedades principais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (ex: Draw.io ou papel)",
                                    "Artigo sobre propriedades de assinaturas digitais"
                                  ],
                                  "tips": "Não-repúdio significa: assinante não pode negar ter assinado.",
                                  "learningObjective": "Reconhecer por que assinaturas digitais são seguras e equivalentes legais a manuscritas.",
                                  "commonMistakes": [
                                    "Confundir integridade com confidencialidade",
                                    "Subestimar riscos de chaves fracas"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine assinar um contrato PDF: você gera hash do PDF, criptografa com sua chave privada (via Adobe Sign), anexa assinatura. Receptor usa sua chave pública para verificar se documento não foi alterado e veio de você.",
                              "finalVerifications": [
                                "Explique verbalmente o fluxo de assinatura e verificação sem erros.",
                                "Gere e verifique uma assinatura digital usando ferramenta online.",
                                "Desenhe diagrama preciso de chaves e processos.",
                                "Identifique e corrija um erro comum em um cenário dado.",
                                "Liste as três propriedades principais com exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de hash, chaves assimétricas (30%)",
                                "Clareza na explicação: uso de analogias e fluxos lógicos (25%)",
                                "Prática hands-on: sucesso em gerar/verificar assinatura (20%)",
                                "Compreensão de propriedades: autenticidade, integridade, não-repúdio (15%)",
                                "Identificação de erros: reconhecimento de pitfalls comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números primos e modularidade em RSA.",
                                "Direito: Validade legal de assinaturas digitais (ex: Lei de Assinaturas Eletrônicas).",
                                "História: Evolução da criptografia de Enigma a moderna PKI.",
                                "Física/Computação: Princípios de segurança em redes quânticas."
                              ],
                              "realWorldApplication": "Usado em certificados SSL/TLS para sites seguros, blockchain (transações Bitcoin), documentos governamentais (e-Gov), e software updates (verificação de integridade no Windows Update)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Identificar propriedades de segurança",
                            "description": "Listar e descrever as três propriedades principais: autenticidade (prova de autoria), integridade (detecção de alterações) e não-repúdio (impossibilidade de negação pelo signatário).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Geral de Propriedades de Segurança em Assinaturas Digitais",
                                  "subSteps": [
                                    "Pesquise o que são assinaturas digitais e seu papel na criptografia.",
                                    "Identifique que propriedades de segurança são características essenciais para confiança em comunicações digitais.",
                                    "Liste as três propriedades principais: autenticidade, integridade e não-repúdio.",
                                    "Leia definições básicas de cada uma em fontes confiáveis.",
                                    "Anote diferenças entre propriedades de confidencialidade e essas três."
                                  ],
                                  "verification": "Crie um mapa mental ou tabela resumindo as três propriedades e suas definições iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook ou papel para anotações",
                                    "Recursos: Khan Academy ou Wikipedia sobre criptografia"
                                  ],
                                  "tips": "Use analogias do mundo físico, como selos em cartas, para facilitar a compreensão.",
                                  "learningObjective": "Compreender o propósito e a lista das três propriedades principais de segurança.",
                                  "commonMistakes": "Confundir com criptografia simétrica ou ignorar o contexto de assinaturas digitais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Propriedade de Autenticidade",
                                  "subSteps": [
                                    "Defina autenticidade como prova de autoria do remetente.",
                                    "Estude como chaves públicas e privadas verificam a identidade.",
                                    "Exemplo: Verificar se uma mensagem assinada corresponde à chave pública do alegado autor.",
                                    "Pesquise algoritmos como RSA para autenticação.",
                                    "Compare com autenticação em senhas comuns."
                                  ],
                                  "verification": "Escreva uma descrição de 100 palavras sobre autenticidade e dê um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RSA ou ECC",
                                    "Simulador online de assinaturas digitais (ex: Crypto101.io)"
                                  ],
                                  "tips": "Lembre-se: é sobre 'quem enviou', não sobre esconder o conteúdo.",
                                  "learningObjective": "Descrever com precisão como a autenticidade é alcançada e verificada.",
                                  "commonMistakes": "Confundir autenticidade com confidencialidade (ocultação de conteúdo)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Integridade e Sua Detecção de Alterações",
                                  "subSteps": [
                                    "Defina integridade como garantia de que a mensagem não foi alterada.",
                                    "Aprenda sobre funções hash (ex: SHA-256) que detectam mudanças mínimas.",
                                    "Simule: Assine uma mensagem, altere uma letra e verifique falha na validação.",
                                    "Discuta ataques como colisões de hash e defesas.",
                                    "Compare integridade com checksums em downloads de software."
                                  ],
                                  "verification": "Realize uma simulação prática e documente o resultado antes/depois da alteração.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef ou OpenSSL para hash",
                                    "Exemplos de mensagens de teste"
                                  ],
                                  "tips": "Pense em integridade como um selo lacrado: qualquer toque quebra.",
                                  "learningObjective": "Explicar mecanismos de detecção de integridade em assinaturas.",
                                  "commonMistakes": "Achar que integridade protege contra roubo, não contra modificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar Não-Repúdio e Sintetizar as Propriedades",
                                  "subSteps": [
                                    "Defina não-repúdio como impossibilidade de o signatário negar a autoria.",
                                    "Estude como a chave privada exclusiva garante isso.",
                                    "Exemplo: Em disputas legais, a assinatura prova responsabilidade.",
                                    "Sintetize as três propriedades em um fluxograma de verificação.",
                                    "Crie cenários onde uma propriedade falha afeta as outras."
                                  ],
                                  "verification": "Redija um parágrafo integrando as três propriedades com um exemplo unificado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Vídeos sobre não-repúdio (ex: YouTube - Computerphile)"
                                  ],
                                  "tips": "Não-repúdio é o 'juramento irrevogável' digital.",
                                  "learningObjective": "Integrar conhecimento das três propriedades e suas interdependências.",
                                  "commonMistakes": "Confundir não-repúdio com auditoria ou logs de acesso."
                                }
                              ],
                              "practicalExample": "Ao assinar digitalmente um contrato PDF com Adobe Sign: Autenticidade confirma que você é o autor via sua chave privada; Integridade detecta se o texto foi alterado pós-assinatura; Não-repúdio impede você de negar a assinatura em corte.",
                              "finalVerifications": [
                                "Liste corretamente as três propriedades sem erros de nome.",
                                "Descreva cada propriedade em uma frase precisa.",
                                "Forneça um exemplo prático para cada uma.",
                                "Explique como falha em uma afeta as outras.",
                                "Crie um fluxograma simples de verificação de assinatura.",
                                "Simule uma verificação em ferramenta online."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusões entre propriedades).",
                                "Uso de exemplos concretos e relevantes.",
                                "Profundidade: menção a mecanismos como hash e chaves assimétricas.",
                                "Capacidade de síntese e interconexões.",
                                "Clareza na escrita ou explicação verbal.",
                                "Aplicação em cenários reais demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e teoria dos números em criptografia assimétrica.",
                                "Direito: Validade legal de assinaturas digitais (ex: Lei de Assinaturas Eletrônicas).",
                                "Ética e Cidadania: Responsabilidade em comunicações digitais e prevenção de fraudes.",
                                "História da Computação: Evolução de assinaturas de Diffie-Hellman a blockchain."
                              ],
                              "realWorldApplication": "Em transações bancárias online (ex: aprovar transferências via app), documentos fiscais assinados eletronicamente (NF-e no Brasil), atualizações de software (verificar integridade contra malware) e certificados SSL em sites para autenticar servidores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Explicar o papel das funções hash",
                            "description": "Descrever como funções hash (ex: SHA-256) são usadas para comprimir mensagens antes da assinatura, garantindo eficiência e resistência a colisões em protocolos de assinatura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de funções hash",
                                  "subSteps": [
                                    "Definir função hash como uma função que transforma uma entrada de tamanho arbitrário em uma saída de tamanho fixo (ex: 256 bits para SHA-256).",
                                    "Listar propriedades principais: determinística, unidirecional, efeito avalanche e resistência a colisões.",
                                    "Explicar a diferença entre hash criptográfico e não criptográfico (ex: MD5 vs SHA-256).",
                                    "Pesquisar exemplos comuns como SHA-256 e sua saída em hexadecimal.",
                                    "Calcular manualmente o hash de uma string simples usando uma ferramenta online."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as 4 propriedades principais de uma função hash.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Ferramenta online como hash.online-convert.com",
                                    "Artigo da Wikipedia sobre SHA-256"
                                  ],
                                  "tips": "Use exemplos visuais: compare o hash de 'abc' e 'abcd' para ver o efeito avalanche.",
                                  "learningObjective": "Dominar a definição e propriedades fundamentais de funções hash criptográficas.",
                                  "commonMistakes": "Confundir função hash com criptografia reversível ou simétrica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar problemas em assinaturas digitais sem funções hash",
                                  "subSteps": [
                                    "Analisar o processo de assinatura digital direta: chave privada aplicada à mensagem inteira.",
                                    "Calcular o tamanho: mensagem longa (ex: 1MB) resulta em assinatura proporcionalmente grande.",
                                    "Discutir ineficiência computacional: tempo e recursos para assinar/verificar mensagens grandes.",
                                    "Exemplificar com um documento real: tempo de assinatura sem hash vs com hash.",
                                    "Relacionar com limitações de protocolos: lentidão em redes ou dispositivos limitados."
                                  ],
                                  "verification": "Desenhar um diagrama comparando assinatura direta vs com hash, destacando tamanhos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para simular mensagens longas"
                                  ],
                                  "tips": "Pense em termos de custo: assinatura de 1GB seria impraticável sem compressão.",
                                  "learningObjective": "Reconhecer as limitações de eficiência em assinaturas sem hash.",
                                  "commonMistakes": "Ignorar o impacto no tempo de verificação em larga escala."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o processo de assinatura usando funções hash",
                                  "subSteps": [
                                    "Explicar o fluxo: 1) Aplicar hash à mensagem; 2) Assinar o hash com chave privada; 3) Enviar assinatura + hash + mensagem.",
                                    "Detalhar verificação: Receptor recalcula hash da mensagem e verifica com chave pública.",
                                    "Simular com pseudocódigo: hash = SHA256(mensagem); assinatura = sign(hash, priv_key).",
                                    "Comparar tamanhos: mensagem N bytes → hash 32 bytes → assinatura ~256-512 bytes.",
                                    "Testar com ferramenta: Gerar hash e simular assinatura usando bibliotecas como OpenSSL."
                                  ],
                                  "verification": "Executar uma simulação passo a passo e documentar os resultados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OpenSSL instalado ou ferramenta online como CyberChef",
                                    "Documentação de OpenSSL"
                                  ],
                                  "tips": "Sempre inclua o hash na transmissão para permitir verificação independente.",
                                  "learningObjective": "Mapear o fluxo completo de assinatura digital com hash.",
                                  "commonMistakes": "Esquecer que a assinatura é do hash, não da mensagem original."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar benefícios e propriedades de segurança das funções hash",
                                  "subSteps": [
                                    "Explicar eficiência: Reduz tamanho processado pela assinatura.",
                                    "Discutir resistência a colisões: Impossibilidade prática de encontrar duas mensagens com mesmo hash.",
                                    "Abordar outras resistências: pré-imagem e segunda pré-imagem.",
                                    "Relacionar com protocolos: Por que SHA-256 é padrão em assinaturas (ex: ECDSA).",
                                    "Pesquisar ataques conhecidos (ex: colisões em MD5) e por que evitar."
                                  ],
                                  "verification": "Responder a perguntas sobre por que colisões quebrariam assinaturas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo explicativo sobre ataques a hashes (YouTube)",
                                    "Artigo NIST sobre padrões hash"
                                  ],
                                  "tips": "Lembre: colisão permite forjar assinatura sem chave privada.",
                                  "learningObjective": "Entender como propriedades de hash garantem segurança e eficiência.",
                                  "commonMistakes": "Subestimar o risco de colisões em hashes fracos como MD5."
                                }
                              ],
                              "practicalExample": "Ao assinar um contrato PDF de 500KB via email: 1) Compute SHA-256 do PDF (32 bytes); 2) Assine os 32 bytes com sua chave privada ECDSA (produz ~70 bytes); 3) Envie PDF + hash + assinatura. Receptor verifica recalculando hash e validando assinatura, eficiente mesmo em mobile.",
                              "finalVerifications": [
                                "Explicar corretamente o fluxo de assinatura com hash em 5 passos.",
                                "Identificar 3 propriedades de hash e seu impacto na segurança.",
                                "Comparar tamanhos de assinatura com e sem hash para mensagem de 1MB.",
                                "Simular verificação de uma assinatura hasheada usando ferramenta.",
                                "Discutir por que colisão de hash invalidaria o protocolo.",
                                "Nomear 2 hashes obsoletos e razões para usarem SHA-256."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definições corretas de hash e propriedades (30%).",
                                "Compreensão do processo: Fluxo de assinatura descrito sem erros (25%).",
                                "Análise de eficiência: Comparação quantitativa de tamanhos/tempos (20%).",
                                "Conhecimento de segurança: Explicação de colisões e resistências (15%).",
                                "Exemplo prático: Aplicação real demonstrada (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de funções e complexidade computacional (resistência a colisões).",
                                "Segurança da Informação: Integração com autenticação e integridade de dados.",
                                "Redes de Computadores: Otimização de protocolos em transmissão de dados.",
                                "Programação: Implementação de hashes em linguagens como Python (hashlib)."
                              ],
                              "realWorldApplication": "Em blockchains como Bitcoin, transações são hasheadas com SHA-256 antes de assinatura ECDSA para eficiência; em certificados SSL/TLS, hashes garantem integridade de sites sem sobrecarregar servidores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Protocolo de Assinatura RSA",
                        "description": "Detalhes do protocolo RSA aplicado a assinaturas digitais, incluindo geração, assinatura e verificação de mensagens.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Gerar chaves para assinatura RSA",
                            "description": "Descrever o processo de geração de par de chaves (pública e privada) usando números primos grandes, com ênfase na escolha da chave privada para assinatura e pública para verificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar dois números primos grandes p e q",
                                  "subSteps": [
                                    "Escolha números primos p e q de tamanho similar (ex: 1024 bits cada para produção)",
                                    "Garanta que p e q sejam primos usando testes de primalidade (Miller-Rabin)",
                                    "Prefira primos seguros contra ataques conhecidos (ex: safeprimes)",
                                    "Registre os valores escolhidos para rastreabilidade",
                                    "Evite primos muito próximos para prevenir Fermat factorization"
                                  ],
                                  "verification": "Confirme primalidade de p e q usando função is_prime() em sympy ou similar",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python com sympy",
                                    "Gerador de primos criptográficos (ex: sympy.nextprime)"
                                  ],
                                  "tips": "Comece com primos pequenos para testes (ex: p=61, q=53), escale para grandes em produção",
                                  "learningObjective": "Entender a importância de primos grandes e seguros na base da RSA",
                                  "commonMistakes": [
                                    "Escolher números compostos",
                                    "p e q muito próximos",
                                    "Ignorar tamanho de bits"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o módulo n e a função totiente φ(n)",
                                  "subSteps": [
                                    "Calcule n = p * q (use multiplicação de big integers)",
                                    "Calcule φ(n) = (p-1) * (q-1)",
                                    "Verifique que n tenha o tamanho esperado (ex: 2048 bits)",
                                    "Armazene n e φ(n) de forma segura (φ(n) nunca é exposto)",
                                    "Teste overflow em linguagens com inteiros limitados"
                                  ],
                                  "verification": "Verifique n == p * q e φ(n) == (p-1)*(q-1)",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Python (suporte nativo a bigints)",
                                    "Calculadora de precisão arbitrária se necessário"
                                  ],
                                  "tips": "Use bibliotecas como gmpy2 para aceleração em números grandes",
                                  "learningObjective": "Dominar cálculos fundamentais da RSA: produto e totiente de Euler",
                                  "commonMistakes": [
                                    "Erro de cálculo em φ(n)",
                                    "Expor φ(n) acidentalmente",
                                    "Overflow em n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolher o expoente público e e calcular o expoente privado d",
                                  "subSteps": [
                                    "Selecione e como 65537 (padrão F4, coprimo com φ(n))",
                                    "Verifique gcd(e, φ(n)) == 1",
                                    "Calcule d como inverso modular: d = e^{-1} mod φ(n) usando Extended Euclidean Algorithm",
                                    "Confirme que (e * d) % φ(n) == 1",
                                    "Escolha e pequeno e ímpar para eficiência"
                                  ],
                                  "verification": "Assert (e * d) % phi_n == 1 e gcd(e, phi_n) == 1",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "sympy.mod_inverse(e, phi_n)",
                                    "Biblioteca cryptography para validação"
                                  ],
                                  "tips": "65537 é ótimo por ser primo Fermat e ter hamming weight baixo",
                                  "learningObjective": "Aprender inverso modular e propriedades coprimas na RSA",
                                  "commonMistakes": [
                                    "e não coprimo com φ(n)",
                                    "Cálculo errado de inverso",
                                    "e par"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e formatar as chaves pública e privada",
                                  "subSteps": [
                                    "Chave pública: tupla (n, e)",
                                    "Chave privada: tupla (n, d) ou estrutura completa (p, q, d, e, n)",
                                    "Codifique em formato PEM ou DER usando bibliotecas padrão",
                                    "Salve chaves separadamente com proteções (senha para privada)",
                                    "Gere chaves em formato compatível com OpenSSL"
                                  ],
                                  "verification": "Carregue chaves com biblioteca (ex: cryptography) e confira valores",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "cryptography.hazmat.primitives.asymmetric.rsa",
                                    "OpenSSL para validação"
                                  ],
                                  "tips": "Nunca hardcode chaves em código; use variáveis seguras",
                                  "learningObjective": "Formatar chaves RSA para uso prático em aplicações",
                                  "commonMistakes": [
                                    "Misturar pública/privada",
                                    "Formato inválido",
                                    "Expor privada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a validade das chaves geradas",
                                  "subSteps": [
                                    "Teste assinatura simples: assine mensagem com d, verifique com e",
                                    "Confirme propriedades RSA: m^{e*d} ≡ m mod n para m < n",
                                    "Use ferramenta externa (openssl rsa -check)",
                                    "Avalie entropia e tamanho das chaves",
                                    "Documente chaves com metadados (tamanho, data)"
                                  ],
                                  "verification": "Assinatura de teste round-trip bem-sucedida",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Script de teste Python",
                                    "OpenSSL CLI"
                                  ],
                                  "tips": "Implemente testes unitários para automação",
                                  "learningObjective": "Validar chaves para garantir usabilidade e segurança",
                                  "commonMistakes": [
                                    "Pular verificação",
                                    "Teste com mensagem >= n",
                                    "Ignorar padding"
                                  ]
                                }
                              ],
                              "practicalExample": "Para p=61 (primo), q=53 (primo): n=3233, φ(n)=60*52=3120, e=17 (gcd(17,3120)=1), d=mod_inverse(17,3120)=2753. Chave pública (3233,17), privada (3233,2753). Teste: assine 65 com privada: 65^2753 mod 3233 = 2790, verifique 2790^17 mod 3233 = 65.",
                              "finalVerifications": [
                                "p e q são primos confirmados",
                                "n = p * q exato",
                                "gcd(e, φ(n)) = 1",
                                "(e * d) mod φ(n) = 1",
                                "Chaves públicas/privadas formatadas corretamente",
                                "Teste de assinatura/verificação round-trip passa",
                                "Tamanho de chaves atende padrões (≥2048 bits)"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática em todos os cálculos",
                                "Escolha adequada de primos (tamanho, segurança)",
                                "Eficiência na escolha de e (padrão 65537)",
                                "Segurança no manuseio de chaves privadas",
                                "Validação completa com testes",
                                "Documentação clara dos passos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, totiente de Euler)",
                                "Matemática: Aritmética Modular e Inversos",
                                "Programação: Manipulação de Big Integers",
                                "Segurança da Informação: Princípios Criptográficos",
                                "Física: Entropia e Geradores de Números Aleatórios"
                              ],
                              "realWorldApplication": "Geração de pares de chaves para assinaturas digitais em certificados SSL/TLS (HTTPS), emails criptografados (S/MIME), autenticação de software (código signing) e blockchain (transações assinadas), garantindo integridade e não-repúdio em comunicações seguras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Executar assinatura e verificação RSA",
                            "description": "Explicar os passos: computar hash da mensagem, assinar com chave privada (S = H(m)^d mod n) e verificar com chave pública (H(m) == S^e mod n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar par de chaves RSA",
                                  "subSteps": [
                                    "Escolha dois números primos distintos p e q (exemplo: p=61, q=53).",
                                    "Calcule n = p * q (resultado: 3233).",
                                    "Calcule φ(n) = (p-1) * (q-1) (resultado: 3120).",
                                    "Escolha e tal que 1 < e < φ(n) e gcd(e, φ(n)) = 1 (exemplo: e=17).",
                                    "Calcule d como o inverso modular de e módulo φ(n), ou seja, d * e ≡ 1 mod φ(n) (resultado: d=2753)."
                                  ],
                                  "verification": "Verifique se pow(e, d, φ(n)) == 1 para confirmar que d é o inverso correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python interpreter",
                                    "Calculadora ou função pow() para testes"
                                  ],
                                  "tips": "Use números primos pequenos para testes iniciais; em produção, use bibliotecas como cryptography para primos grandes.",
                                  "learningObjective": "Compreender e executar a geração de chaves pública (e, n) e privada (d, n) no esquema RSA.",
                                  "commonMistakes": [
                                    "Escolher p ou q que não sejam primos",
                                    "Erro no cálculo de φ(n)",
                                    "Não verificar se gcd(e, φ(n)) == 1",
                                    "Cálculo incorreto do inverso modular d"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o hash da mensagem",
                                  "subSteps": [
                                    "Defina a mensagem m como string (exemplo: m = 'Hello').",
                                    "Importe a biblioteca hashlib e compute o hash SHA-256: hash_obj = hashlib.sha256(m.encode()).",
                                    "Converta o digest para inteiro: h = int.from_bytes(hash_obj.digest(), 'big').",
                                    "Reduza o hash módulo n para garantir h < n: h = h % n.",
                                    "Salve h para uso na assinatura."
                                  ],
                                  "verification": "Re-compute o hash da mesma mensagem e confirme que h é idêntico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3 com hashlib (built-in)"
                                  ],
                                  "tips": "Sempre use funções de hash criptográficas como SHA-256 para prevenir colisões e ataques de extensão de comprimento.",
                                  "learningObjective": "Preparar a mensagem para assinatura RSA através de hashing seguro, entendendo por que assinamos o hash em vez da mensagem bruta.",
                                  "commonMistakes": [
                                    "Não codificar a string para bytes antes do hash",
                                    "Usar ordem de bytes incorreta (use 'big')",
                                    "Esquecer de reduzir h % n",
                                    "Usar hash não criptográfico como MD5"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a assinatura digital com a chave privada",
                                  "subSteps": [
                                    "Use a fórmula da assinatura: S = h^d mod n.",
                                    "Em Python, compute: S = pow(h, d, n).",
                                    "Verifique que 0 ≤ S < n.",
                                    "Armazene S como a assinatura digital da mensagem."
                                  ],
                                  "verification": "Confirme que S está no intervalo [0, n-1] e é um inteiro.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Chaves (d, n) e h do passo anterior",
                                    "Função pow() do Python"
                                  ],
                                  "tips": "A função pow(base, exp, mod) é otimizada para exponentiação modular e evita overflow com números grandes.",
                                  "learningObjective": "Implementar a operação de assinatura RSA usando exponentiação modular com a chave privada.",
                                  "commonMistakes": [
                                    "Usar e em vez de d na assinatura",
                                    "Esquecer o módulo n, causando números enormes",
                                    "Não tratar h como inteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a assinatura com a chave pública",
                                  "subSteps": [
                                    "Re-compute h' = hash da mensagem recebida m' usando os mesmos passos do Step 2.",
                                    "Use a fórmula de verificação: h_computed = S^e mod n.",
                                    "Em Python: h_computed = pow(S, e, n).",
                                    "Verifique se h_computed == h': se sim, a assinatura é válida; caso contrário, rejeite.",
                                    "Teste com mensagem alterada para ver falha."
                                  ],
                                  "verification": "pow(S, e, n) == h para mensagem original; != h' para mensagem alterada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Chave pública (e, n)",
                                    "Assinatura S",
                                    "Mensagem m"
                                  ],
                                  "tips": "A verificação é muito mais rápida que a assinatura, pois e é pequeno; isso é intencional no design RSA.",
                                  "learningObjective": "Implementar a verificação RSA, confirmando autenticidade e integridade da mensagem.",
                                  "commonMistakes": [
                                    "Usar d em vez de e na verificação",
                                    "Não re-hashar a mensagem recebida",
                                    "Ignorar falhas na verificação (aceitar sempre)"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo completo com números pequenos: p=61, q=53 → n=3233, φ=3120, e=17, d=2753. Mensagem m='A' → bytes(65), hash SHA-256 truncado/mod n → h=2790 (simplificado para demo). Assinatura S = pow(2790, 2753, 3233) = 1242. Verificação: pow(1242, 17, 3233) = 2790 == h → Válido! Altere m para 'B' → h' diferente → pow(S,17,3233) != h' → Inválido.",
                              "finalVerifications": [
                                "Gera chaves RSA corretas e verifica inverso modular.",
                                "Computa hash consistente e reduzido módulo n.",
                                "Assina corretamente e obtém S válido.",
                                "Verifica assinatura válida para m original e rejeita para m alterada.",
                                "Implementa todo o processo em um script Python funcional.",
                                "Explica matematicamente por que a verificação funciona (Teorema de Euler)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em todos os cálculos (chaves, hash, modexp).",
                                "Uso correto de hashing criptográfico e redução módulo n.",
                                "Eficiência e correção na implementação de pow() para operações modulares.",
                                "Tratamento adequado de erros (ex: chaves inválidas, mensagem alterada).",
                                "Clareza na explicação dos passos e fórmulas RSA.",
                                "Testes abrangentes incluindo casos de falha."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, Teorema Chinês do Resto, Teorema de Euler/Fermat.",
                                "Segurança da Informação: Conceitos de autenticidade, não-repúdio e integridade de dados.",
                                "Programação: Algoritmos numéricos, bibliotecas Python (hashlib, pow), depuração de código.",
                                "História da Computação: RSA (1977) por Rivest, Shamir e Adleman como base da criptografia assimétrica.",
                                "Física/Engenharia: Aplicações em comunicações seguras (ex: satélites, IoT)."
                              ],
                              "realWorldApplication": "Assinaturas RSA são fundamentais em protocolos como TLS/SSL para certificados digitais em sites HTTPS, assinatura de atualizações de software (ex: pacotes APT, Windows Update), transações blockchain (Bitcoin/Ethereum), emails criptografados (PGP/S/MIME) e autenticação em VPNs, garantindo que mensagens não foram alteradas e vêm da fonte correta."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Analisar ataques comuns ao RSA de assinatura",
                            "description": "Identificar vulnerabilidades como ataques de texto plano e padding inadequado (ex: necessidade de PKCS#1 ou PSS para segurança probabilística).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Protocolo RSA de Assinatura Básico",
                                  "subSteps": [
                                    "Revise a geração de chaves RSA (p, q, n = p*q, e, d).",
                                    "Entenda o processo de assinatura: hash(m) ^ d mod n.",
                                    "Aprenda verificação: hash(m) == s ^ e mod n.",
                                    "Identifique suposições de segurança: hash colisão-resistente.",
                                    "Estude representação da mensagem como inteiro menor que n."
                                  ],
                                  "verification": "Resuma o fluxo de assinatura e verificação em um diagrama simples e explique para um colega.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação RSA (RFC 8017)",
                                    "Vídeo introdutório sobre RSA (Khan Academy ou similar)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use exemplos numéricos pequenos (n=15) para ilustrar cálculos manuais.",
                                  "learningObjective": "Explicar o mecanismo básico de assinatura RSA e suas premissas de segurança.",
                                  "commonMistakes": [
                                    "Confundir assinatura com criptografia (ex: usar e para assinar)",
                                    "Ignorar o papel do hash na assinatura",
                                    "Assumir que mensagens longas podem ser assinadas diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Ataques de Texto Plano (Plaintext Attacks)",
                                  "subSteps": [
                                    "Defina ataque de texto plano: assinatura direta de mensagem sem hash/padding.",
                                    "Simule matematicamente: se m < n, s = m^d mod n revela m diretamente.",
                                    "Discuta ataques existenciais: forjar s = m'^e mod n para m' escolhido.",
                                    "Explore cenários onde hash é omitido ou previsível.",
                                    "Implemente uma assinatura vulnerável em Python para testar."
                                  ],
                                  "verification": "Execute um script Python que demonstre recuperação de mensagem de uma assinatura de texto plano.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca pycryptodome ou cryptography em Python",
                                    "Notebook Jupyter",
                                    "Exemplos de código de ataques RSA no GitHub"
                                  ],
                                  "tips": "Sempre use mensagens curtas (< n) para demonstrações iniciais de vulnerabilidade.",
                                  "learningObjective": "Identificar e demonstrar como assinaturas de texto plano permitem recuperação trivial da mensagem.",
                                  "commonMistakes": [
                                    "Não reduzir mensagem mod n",
                                    "Confundir texto plano com padding determinístico",
                                    "Ignorar que ataques funcionam mesmo com hash fraco"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Vulnerabilidades de Padding Inadequado",
                                  "subSteps": [
                                    "Explique padding PKCS#1 v1.5 determinístico e suas fraquezas (Bleichenbacher).",
                                    "Descreva o oracle attack: usar respostas de verificação para decifrar.",
                                    "Analise como padding previsível permite forjar assinaturas.",
                                    "Compare com raw RSA sem padding.",
                                    "Revise exemplos históricos de falhas em implementações."
                                  ],
                                  "verification": "Descreva os passos de um ataque Bleichenbacher em pseudocódigo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo original de Bleichenbacher (1998)",
                                    "RFC 8017 seção sobre padding",
                                    "Ferramenta online para simular oracles (se disponível)"
                                  ],
                                  "tips": "Foquem em probabilidades: ataques exploram 1/256 chance de padding válido.",
                                  "learningObjective": "Explicar como padding determinístico em RSA permite ataques adaptativos escolhidos.",
                                  "commonMistakes": [
                                    "Confundir PKCS#1 v1.5 com PSS",
                                    "Subestimar impacto de oracles em protocolos reais",
                                    "Ignorar necessidade de nonces aleatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Esquemas de Padding Probabilísticos Seguros",
                                  "subSteps": [
                                    "Estude PKCS#1 PSS: uso de MGF, hash, nonce aleatório.",
                                    "Compare segurança: probabilístico vs determinístico.",
                                    "Implemente assinatura PSS e teste contra ataques anteriores.",
                                    "Discuta transições em protocolos (ex: TLS 1.3 usa PSS).",
                                    "Analise critérios EUF-CMA (existential unforgeability under chosen message attack)."
                                  ],
                                  "verification": "Gere uma assinatura PSS e verifique que ataques de texto plano/padding falham.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "pycryptodome para PSS",
                                    "RFC 8017 PSS specification",
                                    "Comparação de tabelas PKCS#1 vs PSS"
                                  ],
                                  "tips": "Use seeds aleatórias longas para demonstrar variabilidade em assinaturas.",
                                  "learningObjective": "Diferenciar e justificar o uso de padding probabilístico para mitigar ataques conhecidos.",
                                  "commonMistakes": [
                                    "Usar PSS sem MGF corretamente",
                                    "Assumir que todo padding probabilístico é PSS",
                                    "Não testar contra malleability"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de votação eletrônica, uma assinatura RSA sem padding adequado permite que um atacante forje votos alterando a mensagem diretamente (s = m'^d mod n), demonstrado via script Python que recupera e modifica uma 'assinatura' de voto plano.",
                              "finalVerifications": [
                                "Explicar matematicamente um ataque de texto plano com exemplo numérico.",
                                "Descrever os passos principais do ataque Bleichenbacher.",
                                "Implementar e testar uma assinatura RSA vulnerável vs segura (PSS).",
                                "Identificar quando usar PSS em vez de PKCS#1 v1.5.",
                                "Listar 3 protocolos reais afetados por falhas de padding RSA.",
                                "Verificar uma assinatura real de um certificado SSL."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ataques (texto plano, padding determinístico).",
                                "Capacidade de simular ataques em código funcional.",
                                "Compreensão de mitigações probabilísticas (PSS).",
                                "Uso correto de terminologia criptográfica (EUF-CMA, oracle).",
                                "Análise de implicações em cenários reais.",
                                "Clareza em diagramas e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Modular Aritmética.",
                                "Redes de Computadores: Protocolos TLS/SSL e Certificados Digitais.",
                                "Ética e Direito: Implicações Legais de Fraudes Criptográficas.",
                                "Programação: Implementação Segura em Python/Java.",
                                "Segurança da Informação: Análise de Ameaças em Sistemas."
                              ],
                              "realWorldApplication": "Na validação de assinaturas em certificados X.509 (browsers), PDFs assinados digitalmente, transações blockchain (ex: Ethereum), e protocolos como SSH, onde falhas de padding RSA histórico permitiram ataques como o de 2014 no iOS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Protocolos Alternativos e Aplicações",
                        "description": "Outros protocolos de assinatura como DSA e ECDSA, além de considerações práticas em protocolos criptográficos reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Comparar RSA, DSA e ECDSA",
                            "description": "Comparar características: RSA baseado em fatoração, DSA em log discreto, ECDSA em curvas elípticas para maior eficiência em chaves menores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do RSA",
                                  "subSteps": [
                                    "Estude a história e o propósito do RSA como algoritmo de chave pública para criptografia e assinaturas digitais.",
                                    "Aprenda a base matemática: dificuldade computacional da fatoração de números primos grandes.",
                                    "Entenda o processo de geração de chaves: escolha de dois primos grandes p e q, n = p*q, φ(n) = (p-1)(q-1), escolha e e d.",
                                    "Descreva como funciona a assinatura digital com RSA: hash da mensagem, exponenciação modular com chave privada.",
                                    "Identifique vantagens iniciais: simplicidade e versatilidade."
                                  ],
                                  "verification": "Crie um diagrama simples do fluxo de assinatura RSA e explique verbalmente para um par.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação RSA original (Rivest-Shamir-Adleman)",
                                    "Vídeos Khan Academy sobre criptografia de chave pública",
                                    "Calculadora modular online"
                                  ],
                                  "tips": "Use exemplos numéricos pequenos (p=3, q=11) para entender a fatoração.",
                                  "learningObjective": "Compreender a base matemática e o mecanismo de assinatura do RSA.",
                                  "commonMistakes": [
                                    "Confundir fatoração com log discreto",
                                    "Ignorar a necessidade de padding como OAEP para segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Fundamentos do DSA",
                                  "subSteps": [
                                    "Estude o DSA como padrão americano (DSS) para assinaturas digitais.",
                                    "Aprenda a base matemática: problema do logaritmo discreto em campos finitos.",
                                    "Entenda geração de chaves: parâmetros globais (p, q, g), chave privada x, pública y = g^x mod p.",
                                    "Descreva assinatura: calcular r = (g^k mod p) mod q, s = k^{-1}(H(m) + x*r) mod q.",
                                    "Note que DSA é apenas para assinaturas, não criptografia."
                                  ],
                                  "verification": "Implemente um exemplo de assinatura DSA com números pequenos em Python ou JavaScript.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NIST FIPS 186-4 (DSA spec)",
                                    "Biblioteca cryptography em Python",
                                    "Simulador de log discreto online"
                                  ],
                                  "tips": "Lembre-se: DSA requer parâmetros compartilhados, o que pode ser uma desvantagem em mobilidade.",
                                  "learningObjective": "Dominar a matemática do log discreto e o processo de assinatura DSA.",
                                  "commonMistakes": [
                                    "Confundir DSA com Diffie-Hellman",
                                    "Esquecer que r e s são componentes da assinatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os Fundamentos do ECDSA",
                                  "subSteps": [
                                    "Estude ECDSA como variante elíptica do DSA para eficiência.",
                                    "Aprenda a base matemática: problema do log discreto em curvas elípticas sobre campos finitos.",
                                    "Entenda geração de chaves: escolha de curva (ex: secp256k1), ponto base G, chave privada d, pública Q = d*G.",
                                    "Descreva assinatura: ponto k*G = (x1,y1), r = x1 mod n, s = k^{-1}(H(m) + d*r) mod n.",
                                    "Compare curvas elípticas: operações mais rápidas com chaves menores."
                                  ],
                                  "verification": "Desenhe a curva elíptica y² = x³ + ax + b e plote um ponto de exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NIST SP 800-186 (curvas recomendadas)",
                                    "Biblioteca elliptic em JavaScript",
                                    "Visualizador de curvas elípticas online"
                                  ],
                                  "tips": "ECDSA usa metade do tamanho de chave para segurança equivalente (256-bit vs 3072-bit RSA).",
                                  "learningObjective": "Entender como curvas elípticas melhoram eficiência sobre DSA.",
                                  "commonMistakes": [
                                    "Confundir multiplicação escalar com exponenciação modular",
                                    "Ignorar vulnerabilidades como curvas fracas (Dual_EC_DRBG)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar RSA, DSA e ECDSA",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: bases matemáticas (fatoração, log discreto, ECC).",
                                    "Compare tamanhos de chave e performance: RSA lento com chaves grandes, ECDSA rápido com chaves pequenas.",
                                    "Analise segurança: resistências a ataques quânticos (Shor quebra todos), curvas vs campos finitos.",
                                    "Discuta padrões e usos: RSA versátil, DSA legado, ECDSA moderno (Bitcoin, TLS).",
                                    "Avalie trade-offs: eficiência, patentes (RSA), mobilidade."
                                  ],
                                  "verification": "Apresente a tabela comparativa e responda perguntas sobre escolhas em cenários reais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela comparativa em Excel/Google Sheets",
                                    "Artigos StackExchange Criptografia",
                                    "Benchmark de bibliotecas OpenSSL"
                                  ],
                                  "tips": "Use métricas: tempo de assinatura/verificação, tamanho da assinatura.",
                                  "learningObjective": "Sintetizar diferenças e decidir quando usar cada um.",
                                  "commonMistakes": [
                                    "Superestimar segurança DSA moderna",
                                    "Ignorar que RSA é mais lento mas amplamente suportado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a Comparação em um Caso Prático",
                                  "subSteps": [
                                    "Escolha um cenário: assinar transações blockchain.",
                                    "Avalie cada algoritmo: RSA (seguro mas lento), DSA (não elíptico), ECDSA (eficiente para mobile).",
                                    "Gere assinaturas de teste com cada um usando bibliotecas.",
                                    "Meça performance e discuta migração para ECDSA.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Compartilhe código e resultados de benchmark com grupo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "OpenSSL ou Python cryptography",
                                    "Ambiente Jupyter Notebook",
                                    "Dados de benchmark de sites como eBACS"
                                  ],
                                  "tips": "Teste com chaves de 2048-bit RSA, 256-bit ECDSA para comparação justa.",
                                  "learningObjective": "Aplicar comparação para tomada de decisão prática.",
                                  "commonMistakes": [
                                    "Comparar chaves de tamanhos desiguais",
                                    "Esquecer impacto de hardware em performance"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao desenvolver uma aplicação de blockchain como uma wallet móvel, compare RSA (chaves grandes, lento em dispositivos low-power), DSA (sem criptografia, legado) e ECDSA (secp256k1 usado no Bitcoin, assinatura de 70 bytes rápida), escolhendo ECDSA para eficiência em transações.",
                              "finalVerifications": [
                                "Explique corretamente as três bases matemáticas sem confusão.",
                                "Liste pelo menos 3 vantagens de ECDSA sobre RSA e DSA.",
                                "Crie uma tabela comparativa precisa com tamanhos de chave equivalentes.",
                                "Identifique cenários onde RSA ainda é preferido (compatibilidade legacy).",
                                "Discuta impactos quânticos em cada algoritmo.",
                                "Meça e compare tempos de assinatura em código real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das bases matemáticas (fatoração, log discreto, ECC).",
                                "Profundidade na comparação de performance e tamanhos de chave.",
                                "Correção em exemplos práticos e verificações.",
                                "Clareza na tabela ou visualização comparativa.",
                                "Identificação de trade-offs de segurança e usabilidade.",
                                "Capacidade de aplicar em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (fatoração, log discreto, geometria algébrica).",
                                "Segurança da Informação: Análise de ameaças quânticas e side-channel.",
                                "Desenvolvimento de Software: Integração de bibliotecas criptográficas (OpenSSL, BouncyCastle).",
                                "Engenharia de Computação: Otimização de performance em hardware restrito.",
                                "Economia Digital: Aplicações em criptomoedas e blockchains."
                              ],
                              "realWorldApplication": "RSA é usado em certificados SSL/TLS para autenticação web; DSA em alguns protocolos SSH legados; ECDSA em Bitcoin para assinar transações, TLS 1.3 moderno e apps IoT, permitindo segurança forte com menor bateria e largura de banda."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Descrever aplicações em protocolos reais",
                            "description": "Exemplificar uso em TLS/SSL, PDF assinados e blockchain, destacando como garantem não-repúdio em comunicações seguras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Assinatura Digital e Não-Repúdio",
                                  "subSteps": [
                                    "Defina não-repúdio como a garantia de que uma parte não pode negar ter realizado uma ação, como enviar uma mensagem ou assinar um documento.",
                                    "Explique o papel das assinaturas digitais usando chaves assimétricas (chave privada para assinar, pública para verificar).",
                                    "Discuta os componentes essenciais: hash da mensagem, assinatura com chave privada e verificação com chave pública.",
                                    "Identifique como isso previne negação em comunicações seguras.",
                                    "Crie um diagrama simples de fluxo de assinatura digital."
                                  ],
                                  "verification": "Escreva uma definição precisa de não-repúdio e desenhe um diagrama correto sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Artigos introdutórios sobre criptografia assimétrica"
                                  ],
                                  "tips": "Use analogias como uma assinatura manuscrita em um contrato para visualizar o conceito.",
                                  "learningObjective": "Compreender os princípios básicos que habilitam o não-repúdio em protocolos reais.",
                                  "commonMistakes": "Confundir não-repúdio com confidencialidade ou autenticação; assumir que hash sozinho garante não-repúdio."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aplicação em TLS/SSL",
                                  "subSteps": [
                                    "Descreva o handshake TLS/SSL: troca de certificados e assinaturas para autenticação mútua.",
                                    "Explique como o servidor assina o handshake com sua chave privada, verificável pelo cliente via CA.",
                                    "Detalhe o uso de assinaturas em mensagens de troca de chaves para provar identidade e integridade.",
                                    "Exemplifique em um cenário HTTPS: navegador verifica assinatura do site para evitar MITM.",
                                    "Registre como isso garante não-repúdio de ações do servidor durante a sessão."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo TLS com foco em assinaturas, citando pelo menos 3 passos chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação oficial do TLS 1.3 (RFC 8446)",
                                    "Ferramenta Wireshark para capturar tráfego HTTPS"
                                  ],
                                  "tips": "Assista a uma animação do handshake TLS para visualizar o processo dinâmico.",
                                  "learningObjective": "Descrever precisamente como TLS/SSL usa assinaturas para não-repúdio em comunicações web seguras.",
                                  "commonMistakes": "Ignorar o papel das Autoridades Certificadoras (CAs); confundir assinatura com criptografia simétrica da sessão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Assinaturas em PDFs Digitais",
                                  "subSteps": [
                                    "Instale um visualizador PDF com suporte a assinaturas como Adobe Reader.",
                                    "Crie um PDF simples e aplique uma assinatura digital usando um certificado autoassinado.",
                                    "Analise as propriedades: hash do PDF assinado, timestamp e cadeia de confiança.",
                                    "Descreva verificação: leitor usa chave pública para validar integridade e autoria.",
                                    "Discuta não-repúdio em contextos legais, como contratos eletrônicos."
                                  ],
                                  "verification": "Gere um PDF assinado e valide-o, documentando o processo com screenshots.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Adobe Acrobat Reader ou PDF signer gratuito",
                                    "Certificado digital de teste (via browser ou ferramenta online)"
                                  ],
                                  "tips": "Use PDFs reais de faturas ou contratos para praticar cenários autênticos.",
                                  "learningObjective": "Demonstrar como assinaturas em PDFs garantem não-repúdio em documentos digitais.",
                                  "commonMistakes": "Não verificar a cadeia de certificados; achar que assinatura PDF é só uma imagem escaneada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Aplicações em Blockchain",
                                  "subSteps": [
                                    "Explique transações em blockchain (ex: Bitcoin): cada uma é assinada com chave privada do remetente.",
                                    "Descreva verificação distribuída: nós usam chave pública para validar assinatura e saldo.",
                                    "Discuta não-repúdio inerente: transação no ledger é imutável e ligada à chave privada.",
                                    "Compare com smart contracts no Ethereum, onde assinaturas autorizam execuções.",
                                    "Crie um exemplo simples de transação assinada usando uma wallet de teste."
                                  ],
                                  "verification": "Simule uma transação em testnet (ex: Bitcoin testnet) e explique a assinatura no explorer.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Explorador de blockchain como Blockchain.com",
                                    "Wallet de teste como Electrum testnet"
                                  ],
                                  "tips": "Comece com tutoriais visuais de blockchain para não se perder em detalhes técnicos.",
                                  "learningObjective": "Articular como blockchain usa assinaturas para não-repúdio em transações descentralizadas.",
                                  "commonMistakes": "Confundir proof-of-work com assinaturas; ignorar que perda de chave privada perde controle."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Comparar Aplicações",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: TLS/SSL, PDF, Blockchain (colunas: mecanismo de assinatura, contexto, garantia de não-repúdio).",
                                    "Escreva um parágrafo descritivo para cada, destacando não-repúdio em comunicações seguras.",
                                    "Identifique semelhanças (chaves assimétricas) e diferenças (centralizado vs descentralizado).",
                                    "Pratique explicando para um 'parceiro de estudo' ou gravando um vídeo curto.",
                                    "Refine descrições com feedback ou autoavaliação."
                                  ],
                                  "verification": "Produza uma tabela e descrições coerentes, sem inconsistências factuais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Gravação de áudio/vídeo para prática"
                                  ],
                                  "tips": "Use bullet points iniciais para organizar ideias antes de escrever parágrafos completos.",
                                  "learningObjective": "Integrar conhecimentos para descrever aplicações reais de forma coesa e precisa.",
                                  "commonMistakes": "Fazer generalizações vagas; não ligar explicitamente ao não-repúdio em cada caso."
                                }
                              ],
                              "practicalExample": "Em um e-commerce HTTPS (TLS/SSL), o servidor assina o certificado durante o handshake, permitindo que o cliente verifique a identidade real do site, garantindo não-repúdio de comunicações sensíveis como confirmações de pagamento. Para um PDF de contrato assinado digitalmente, a assinatura vincula o signatário ao documento, comprovável em corte. No blockchain, uma transação de transferência de criptomoeda assinada prova que o dono da chave privada autorizou-a, imutável no ledger público.",
                              "finalVerifications": [
                                "Pode listar e explicar os 3 protocolos com exemplos de não-repúdio sem hesitação.",
                                "Desenha fluxogramas corretos para cada aplicação.",
                                "Identifica diferenças chave entre centralizado (TLS/PDF) e descentralizado (blockchain).",
                                "Responde perguntas sobre falhas potenciais, como revogação de certificados.",
                                "Escreve um resumo de 200 palavras descrevendo aplicações reais.",
                                "Simula explicação oral em menos de 5 minutos com clareza."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção de conceitos de assinatura e não-repúdio (30%).",
                                "Profundidade de exemplos: Detalhes específicos para TLS, PDF e blockchain (25%).",
                                "Clareza na descrição: Linguagem acessível e estruturada (20%).",
                                "Conexão com não-repúdio: Ênfase explícita em comunicações seguras (15%).",
                                "Originalidade: Exemplos práticos e não copiados verbatim (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Direito Digital: Validade legal de assinaturas eletrônicas (e.g., leis como eIDAS na UE).",
                                "História da Tecnologia: Evolução de protocolos desde PGP até blockchain moderno.",
                                "Matemática: Fundamentos de funções hash e criptografia de curva elíptica.",
                                "Ética e Segurança: Implicações de privacidade vs. accountability em sistemas distribuídos."
                              ],
                              "realWorldApplication": "Essa habilidade permite auditar comunicações seguras em TI, validar documentos legais em empresas, analisar transações financeiras em fintechs e educar sobre cibersegurança, essencial para profissionais de compliance, desenvolvedores de software seguro e analistas de blockchain."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Propriedades de Segurança em Protocolos",
                    "description": "Garantias como confidencialidade, integridade e autenticação em protocolos criptográficos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Confidencialidade",
                        "description": "Garantia de que as mensagens em protocolos criptográficos são legíveis apenas pelas partes autorizadas, protegendo contra eavesdropping e divulgação não autorizada.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Definir confidencialidade em protocolos",
                            "description": "Explicar o conceito de confidencialidade como a propriedade que impede a leitura de mensagens por terceiros não autorizados, com exemplos de ataques como interceptação passiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de confidencialidade",
                                  "subSteps": [
                                    "Leia a definição padrão: Confidencialidade é a propriedade que garante que apenas destinatários autorizados possam ler as mensagens.",
                                    "Compare com analogia cotidiana: Como um envelope selado impede que estranhos leiam a carta.",
                                    "Anote os elementos chave: 'impedir leitura por terceiros não autorizados'.",
                                    "Pesquise definições em fontes confiáveis como RFCs ou livros de criptografia.",
                                    "Resuma em suas próprias palavras."
                                  ],
                                  "verification": "Escreva uma definição de confidencialidade em uma frase e compare com a definição oficial (deve coincidir em 90%).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro ou site sobre criptografia (ex: Cryptography Engineering), caderno para anotações"
                                  ],
                                  "tips": "Use analogias simples para fixar o conceito antes de avançar para aspectos técnicos.",
                                  "learningObjective": "Compreender e definir confidencialidade como propriedade de segurança fundamental.",
                                  "commonMistakes": [
                                    "Confundir com integridade (que protege contra alterações) ou autenticidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contextualizar confidencialidade em protocolos criptográficos",
                                  "subSteps": [
                                    "Estude o que são protocolos criptográficos: conjuntos de regras para comunicação segura.",
                                    "Identifique onde a confidencialidade se aplica: na transmissão de dados sensíveis.",
                                    "Desenhe um diagrama simples: remetente -> canal inseguro -> destinatário autorizado.",
                                    "Explique como algoritmos como AES fornecem confidencialidade via criptografia simétrica.",
                                    "Discuta protocolos como TLS que incorporam confidencialidade."
                                  ],
                                  "verification": "Crie um diagrama de protocolo mostrando fluxo com e sem confidencialidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama, vídeo introdutório sobre TLS (ex: YouTube Khan Academy)"
                                  ],
                                  "tips": "Foque no 'por quê' da confidencialidade em protocolos antes do 'como'.",
                                  "learningObjective": "Relacionar confidencialidade ao contexto de protocolos de comunicação segura.",
                                  "commonMistakes": [
                                    "Achar que confidencialidade é só criptografia; é uma propriedade garantida por ela."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar ataques que violam confidencialidade",
                                  "subSteps": [
                                    "Defina interceptação passiva: atacante escuta o tráfego sem alterar.",
                                    "Simule um cenário: tráfego HTTP não criptografado em Wi-Fi público.",
                                    "Liste outros ataques: eavesdropping em redes sem fio, man-in-the-middle sem detecção.",
                                    "Compare com canais seguros: HTTPS vs HTTP.",
                                    "Registre como confidencialidade previne esses ataques."
                                  ],
                                  "verification": "Descreva um ataque de interceptação passiva e explique por que falha com confidencialidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para demo (versão demo), exemplos de capturas de pacotes HTTP"
                                  ],
                                  "tips": "Use ferramentas reais como Wireshark em ambiente controlado para visualizar tráfego.",
                                  "learningObjective": "Identificar e exemplificar ameaças à confidencialidade como interceptação passiva.",
                                  "commonMistakes": [
                                    "Confundir passiva com ativa (ativa altera dados, violando integridade)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar confidencialidade de outras propriedades de segurança",
                                  "subSteps": [
                                    "Liste propriedades: confidencialidade, integridade, autenticidade, não-repúdio.",
                                    "Crie tabela comparativa: o que cada uma protege e exemplos de violações.",
                                    "Aplique a protocolos: TLS garante todas via camadas.",
                                    "Teste com quiz mental: 'Interceptação passiva viola qual propriedade?'",
                                    "Reforce com exemplo completo de protocolo seguro."
                                  ],
                                  "verification": "Preencha tabela comparativa corretamente sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela, resumo de propriedades de segurança"
                                  ],
                                  "tips": "Use mnemônicos: CIA triad (Confidentiality, Integrity, Availability).",
                                  "learningObjective": "Distinguir confidencialidade de integridade, autenticidade e outras propriedades.",
                                  "commonMistakes": [
                                    "Misturar confidencialidade com disponibilidade (que é sobre negação de serviço)."
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine enviar uma mensagem de login (usuário/senha) via HTTP em Wi-Fi público: sem confidencialidade, um atacante próximo usa Wireshark para capturar e ler os dados. Com HTTPS (TLS), a mensagem é criptografada, impedindo leitura não autorizada.",
                              "finalVerifications": [
                                "Defina confidencialidade corretamente em uma frase.",
                                "Explique interceptação passiva com um exemplo real.",
                                "Diferencie confidencialidade de integridade.",
                                "Descreva como TLS provê confidencialidade.",
                                "Identifique um cenário onde confidencialidade é essencial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% alinhada com conceito padrão).",
                                "Uso correto de exemplos de ataques (pelo menos 2 mencionados).",
                                "Diferenciação clara de outras propriedades de segurança.",
                                "Capacidade de diagramar fluxo de protocolo seguro.",
                                "Explicação contextualizada em protocolos criptográficos."
                              ],
                              "crossCurricularConnections": [
                                "Ética e Privacidade: Discussão sobre leis como LGPD/GDPR que exigem confidencialidade.",
                                "Matemática: Fundamentos de criptografia simétrica (funções bijetoras).",
                                "Redes de Computadores: Camada de transporte e segurança em TCP/IP.",
                                "Direito Digital: Responsabilidades em proteção de dados pessoais."
                              ],
                              "realWorldApplication": "Em apps como WhatsApp ou bancos online, confidencialidade via end-to-end encryption (Signal Protocol) impede que provedores ou interceptadores leiam mensagens privadas, protegendo transações financeiras e comunicações sensíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Identificar mecanismos de confidencialidade",
                            "description": "Descrever o uso de criptografia simétrica (ex: AES) e assimétrica (ex: RSA) para cifrar mensagens em protocolos, destacando chaves secretas compartilhadas versus chaves públicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Criptografia Simétrica com AES",
                                  "subSteps": [
                                    "Defina criptografia simétrica e explique que usa a mesma chave para cifrar e decifrar.",
                                    "Estude o AES como padrão moderno, com tamanhos de chave de 128, 192 ou 256 bits.",
                                    "Aprenda o processo básico: modo de operação ECB ou CBC para blocos de dados.",
                                    "Simule manualmente a cifragem de uma mensagem curta usando uma chave compartilhada.",
                                    "Discuta a necessidade de distribuição segura da chave secreta."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o processo de cifragem AES com um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre AES (Khan Academy ou YouTube)",
                                    "Ferramenta online como CyberChef para simular AES"
                                  ],
                                  "tips": "Use mensagens curtas para visualização; foque em como a chave deve ser secreta.",
                                  "learningObjective": "Compreender os princípios e operação da criptografia simétrica usando AES.",
                                  "commonMistakes": "Confundir simétrica com assimétrica; ignorar vulnerabilidades de distribuição de chaves."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Criptografia Assimétrica com RSA",
                                  "subSteps": [
                                    "Defina criptografia assimétrica: par de chaves pública (cifra) e privada (decifra).",
                                    "Aprenda os fundamentos matemáticos do RSA: números primos grandes e exponenciação modular.",
                                    "Estude o processo: gerar chaves, cifrar com pública, decifrar com privada.",
                                    "Simule cifragem de uma mensagem usando chaves públicas disponíveis online.",
                                    "Explique por que a chave pública pode ser compartilhada abertamente."
                                  ],
                                  "verification": "Gere um par de chaves RSA simples e decifre uma mensagem cifrada com a privada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora RSA online (como rsa-calculator.com)",
                                    "Tutorial interativo sobre RSA (Crypto101)"
                                  ],
                                  "tips": "Visualize com números pequenos para entender a matemática antes de escalar.",
                                  "learningObjective": "Dominar os conceitos e operação da criptografia assimétrica usando RSA.",
                                  "commonMistakes": "Confundir qual chave cifra/decifra; subestimar o custo computacional do RSA."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Chaves e Uso em Protocolos",
                                  "subSteps": [
                                    "Compare chaves: secretas compartilhadas (simétrica, risco de interceptação) vs. públicas (assimétrica, segura para envio).",
                                    "Discuta híbridos: AES para dados + RSA para chaves em protocolos como TLS.",
                                    "Identifique confidencialidade em protocolos: como HTTPS usa ambos para cifrar mensagens.",
                                    "Analise vantagens/desvantagens: velocidade (AES) vs. segurança de troca de chaves (RSA).",
                                    "Crie uma tabela comparativa de cenários de uso."
                                  ],
                                  "verification": "Preencha uma tabela comparativa correta entre simétrica e assimétrica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama TLS handshake (Cloudflare Learning)",
                                    "Planilha Google Sheets para tabela"
                                  ],
                                  "tips": "Pense em 'quem precisa saber a chave?'; use analogias como cofre com cadeado público.",
                                  "learningObjective": "Diferenciar e contrastar o uso de chaves em criptografias simétrica e assimétrica.",
                                  "commonMistakes": "Achar que assimétrica é sempre mais rápida; ignorar ataques man-in-the-middle sem autenticação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Mecanismos em Exemplos Práticos",
                                  "subSteps": [
                                    "Analise um protocolo real: trace o Wireshark de uma conexão HTTPS para ver AES/RSA.",
                                    "Identifique confidencialidade em apps: WhatsApp (Signal com AES), email PGP (RSA).",
                                    "Crie fluxograma de um protocolo genérico usando ambos os tipos.",
                                    "Debata cenários: quando usar só simétrica vs. híbrido.",
                                    "Teste com ferramenta: capture tráfego e verifique cifragem."
                                  ],
                                  "verification": "Descreva corretamente os mecanismos em 2 protocolos reais com evidências.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Wireshark gratuito",
                                    "Exemplos de tráfego criptografado (packetlife.net)"
                                  ],
                                  "tips": "Filtre pacotes TLS no Wireshark; foque no handshake para chaves.",
                                  "learningObjective": "Aplicar conhecimento para identificar confidencialidade em protocolos reais.",
                                  "commonMistakes": "Não distinguir cifras de autenticação; assumir todos os protocolos usam só um tipo."
                                }
                              ],
                              "practicalExample": "Simule um chat seguro: Alice gera chave AES compartilhada com Bob via RSA (envia AES cifrada com pública de Bob), então usa AES para mensagens. Use CyberChef para demonstrar.",
                              "finalVerifications": [
                                "Explicar corretamente AES vs. RSA com exemplos de chaves.",
                                "Identificar confidencialidade em um handshake TLS.",
                                "Comparar riscos de chaves secretas vs. públicas.",
                                "Simular cifragem híbrida em ferramenta online.",
                                "Listar 3 protocolos que usam esses mecanismos.",
                                "Desenhar fluxograma de troca segura de mensagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de simétrica (chave única) e assimétrica (par de chaves).",
                                "Correta identificação de exemplos (AES, RSA) e modos de uso.",
                                "Compreensão de distribuição de chaves e riscos associados.",
                                "Capacidade de aplicar em protocolos reais como TLS/HTTPS.",
                                "Uso de terminologia técnica precisa (cifrar, decifrar, chave pública/privada).",
                                "Demonstração prática via simulação ou análise de tráfego."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e modularidade no RSA.",
                                "História: Evolução da criptografia de Enigma a moderna.",
                                "Física/Engenharia: Entropia em geração de chaves aleatórias.",
                                "Ética: Privacidade vs. segurança nacional em protocolos."
                              ],
                              "realWorldApplication": "Em HTTPS para navegação segura (bancos online), apps de mensagens como Signal/WhatsApp para chats privados, e VPNs para túneis cifrados, garantindo que dados confidenciais não sejam lidos por interceptadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Analisar violações de confidencialidade",
                            "description": "Reconhecer ataques como chosen-plaintext attack em contextos probabilísticos e diferenciar criptosistemas determinísticos de probabilísticos para preservar confidencialidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Diferenciar Criptosistemas Determinísticos e Probabilísticos",
                                  "subSteps": [
                                    "Estude a definição de criptosistema determinístico: mesma plaintext sempre produz mesma ciphertext com a mesma chave.",
                                    "Estude a definição de criptosistema probabilístico: usa aleatoriedade, mesma plaintext pode produzir ciphertexts diferentes.",
                                    "Compare exemplos: AES-ECB (determinístico) vs AES-GCM (probabilístico).",
                                    "Analise impacto na confidencialidade: determinísticos vazam padrões, probabilísticos os mascaram.",
                                    "Crie um diagrama comparativo."
                                  ],
                                  "verification": "Crie uma tabela comparando os dois tipos com exemplos e explique verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de criptografia (ex: Katz & Lindell), notas de aula, papel e caneta para diagrama.",
                                  "tips": "Use analogias: determinístico como uma fechadura fixa, probabilístico como uma com ruído aleatório.",
                                  "learningObjective": "Distinguir características e implicações de confidencialidade entre criptosistemas determinísticos e probabilísticos.",
                                  "commonMistakes": "Confundir com simétrico/assimétrico; ignorar o papel da aleatoriedade na probabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Chosen-Plaintext Attack (CPA)",
                                  "subSteps": [
                                    "Defina CPA: atacante escolhe plaintexts e obtém ciphertexts correspondentes.",
                                    "Descreva o modelo de segurança: oráculo de encriptação acessível.",
                                    "Estude a vantagem do atacante: distinguir entre duas mensagens possíveis.",
                                    "Analise formalmente: experimento de b distinguibilidade.",
                                    "Simule um CPA simples com ferramenta online."
                                  ],
                                  "verification": "Descreva o passo a passo de um CPA em um parágrafo e simule com código ou ferramenta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta Cryptool ou Python com pycryptodome, vídeo tutorial sobre CPA.",
                                  "tips": "Pense no atacante como um 'oráculo consultor' que testa hipóteses.",
                                  "learningObjective": "Explicar o mecanismo e objetivos de um chosen-plaintext attack.",
                                  "commonMistakes": "Confundir CPA com known-plaintext; subestimar acesso ao oráculo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Violações de Confidencialidade via CPA em Sistemas Determinísticos",
                                  "subSteps": [
                                    "Encripte duas plaintexts idênticas em modo determinístico e observe ciphertexts iguais.",
                                    "Simule CPA: atacante envia 'mensagem A' e 'mensagem B', compara respostas.",
                                    "Identifique vazamento: padrões revelam informações sem quebrar chaves.",
                                    "Discuta exemplos reais: ECB penguin (imagem com padrões visíveis).",
                                    "Registre como CPA quebra IND-CPA em determinísticos."
                                  ],
                                  "verification": "Demonstre um ataque CPA em ECB com imagem ou texto, mostrando violação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python script para ECB, imagem de teste (Tux penguin), debugger.",
                                  "tips": "Visualize com imagens coloridas para padrões em ECB.",
                                  "learningObjective": "Reconhecer como CPA explora determinismo para violar confidencialidade.",
                                  "commonMistakes": "Achar que CPA requer descriptografia; ignorar contextos probabilísticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Preservação de Confidencialidade em Sistemas Probabilísticos contra CPA",
                                  "subSteps": [
                                    "Encripte a mesma plaintext múltiplas vezes em modo probabilístico e observe variações.",
                                    "Simule CPA em CBC ou GCM: atacante não distingue devido a IV/nonce.",
                                    "Analise prova de segurança IND-CPA: vantagem negligenciável.",
                                    "Compare falhas determinísticas vs sucessos probabilísticos.",
                                    "Proponha quando usar cada um para confidencialidade."
                                  ],
                                  "verification": "Execute simulação mostrando ciphertexts diferentes para mesma plaintext e explique por quê.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com pycryptodome para CBC/GCM, planilha para comparações.",
                                  "tips": "Gere múltiplas encriptações (10+) para estatísticas.",
                                  "learningObjective": "Diferenciar e justificar uso de probabilísticos para resistir a CPA.",
                                  "commonMistakes": "Reutilizar IV/nonce (torna probabilístico determinístico); confundir com perfeição."
                                }
                              ],
                              "practicalExample": "Em um sistema de mensagens usando AES-ECB (determinístico), um atacante com acesso ao oráculo CPA envia imagens de dois gatos diferentes. O ciphertext revela padrões de pixels idênticos, permitindo distinguir qual gato foi enviado, violando confidencialidade. Em AES-CBC (probabilístico), ciphertexts variam, mascarando a distinção.",
                              "finalVerifications": [
                                "Explicar diferença entre determinístico e probabilístico com exemplos.",
                                "Descrever passo a passo de um CPA bem-sucedido em ECB.",
                                "Simular falha de CPA em modo probabilístico com evidências.",
                                "Identificar violações em um cenário dado.",
                                "Propor correção para um sistema vulnerável.",
                                "Discutir IND-CPA formalmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de tipos de criptosistemas (90%+ correto).",
                                "Capacidade de simular e explicar CPA (com demo funcional).",
                                "Análise correta de violações em contextos específicos.",
                                "Uso apropriado de terminologia criptográfica.",
                                "Profundidade em provas conceituais de segurança.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e teoria da informação para modelar vantagens de ataques.",
                                "Ética: Implicações de privacidade e violações de dados em protocolos reais.",
                                "Física: Analogias com ruído quântico em criptografia pós-quântica.",
                                "Direito: Regulamentações como GDPR sobre confidencialidade de dados."
                              ],
                              "realWorldApplication": "Em protocolos como TLS/HTTPS, modos probabilísticos como AES-GCM previnem CPA, protegendo comunicações bancárias e e-mails contra atacantes que interceptam tráfego e testam plaintexts escolhidos, garantindo confidencialidade em transações online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Integridade",
                        "description": "Garantia de que as mensagens em protocolos não foram alteradas durante a transmissão, detectando modificações ou substituições não autorizadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Definir integridade em protocolos",
                            "description": "Explicar integridade como a propriedade que assegura que a mensagem recebida é idêntica à enviada, protegendo contra ataques de modificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de integridade",
                                  "subSteps": [
                                    "Leia a definição: Integridade assegura que a mensagem recebida é idêntica à enviada.",
                                    "Anote os componentes chave: 'idêntica' significa sem alterações, adições ou deleções.",
                                    "Pesquise sinônimos e antônimos para reforçar o conceito (ex: integridade vs. adulteração).",
                                    "Escreva a definição com suas próprias palavras.",
                                    "Compare com exemplos cotidianos, como um envelope lacrado."
                                  ],
                                  "verification": "Você pode recitar a definição sem olhar para as notas e explicar um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook e papel, acesso a um dicionário online de termos de segurança da informação.",
                                  "tips": "Use analogias físicas como uma carta selada para visualizar melhor.",
                                  "learningObjective": "Memorizar e internalizar a definição precisa de integridade em protocolos.",
                                  "commonMistakes": "Confundir integridade com confidencialidade (que é sobre sigilo, não alteração)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar ameaças à integridade",
                                  "subSteps": [
                                    "Liste ataques comuns: modificação, inserção, replay e deleção de mensagens.",
                                    "Estude cenários: um atacante altera o valor de uma transação bancária em trânsito.",
                                    "Desenhe um diagrama simples: remetente -> canal inseguro -> receptor com alteração.",
                                    "Pesquise exemplos reais, como o ataque Man-in-the-Middle (MITM).",
                                    "Classifique como integridade é violada em cada caso."
                                  ],
                                  "verification": "Crie uma lista de 3 ataques e explique como cada um afeta a integridade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta para diagramas, vídeos curtos sobre ataques MITM no YouTube.",
                                  "tips": "Pense em 'o que acontece se alguém mexer na mensagem no meio do caminho?'.",
                                  "learningObjective": "Reconhecer como ataques de modificação comprometem a integridade.",
                                  "commonMistakes": "Ignorar ataques sutis como replay, focando só em alterações óbvias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar integridade de outras propriedades de segurança",
                                  "subSteps": [
                                    "Compare com confidencialidade: sigilo vs. não-alteração.",
                                    "Compare com autenticidade: origem vs. conteúdo intacto.",
                                    "Compare com disponibilidade: acesso vs. veracidade dos dados.",
                                    "Crie uma tabela comparativa com exemplos para cada propriedade.",
                                    "Explique por que integridade é essencial mesmo com as outras propriedades."
                                  ],
                                  "verification": "Preencha uma tabela comparativa corretamente sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou papel para tabela, infográfico sobre CIA Triad (Confidencialidade, Integridade, Disponibilidade).",
                                  "tips": "Use a tríade CIA como mnemônico para lembrar as propriedades principais.",
                                  "learningObjective": "Distinguir integridade de confidencialidade, autenticidade e disponibilidade.",
                                  "commonMistakes": "Achar que integridade inclui verificar a identidade do remetente (isso é autenticidade)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito em um protocolo simples",
                                  "subSteps": [
                                    "Escolha um protocolo exemplo: HTTPS ou email com assinatura digital.",
                                    "Descreva como integridade é verificada (ex: hash ou MAC).",
                                    "Simule um fluxo: envie uma mensagem, altere-a e veja a falha de verificação.",
                                    "Use uma ferramenta online para demonstrar hash de mensagens.",
                                    "Escreva um parágrafo explicando integridade nesse contexto."
                                  ],
                                  "verification": "Explique o papel da integridade em um protocolo real com um diagrama.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta online como hash generator (ex: md5hashgenerator.com), diagrama software como Draw.io.",
                                  "tips": "Teste alterando uma string e recalculando o hash para ver a diferença.",
                                  "learningObjective": "Aplicar a definição de integridade a protocolos criptográficos reais.",
                                  "commonMistakes": "Confundir mecanismos de verificação (hash) com a propriedade em si."
                                }
                              ],
                              "practicalExample": "Em um aplicativo de mensagens como WhatsApp com criptografia ponta a ponta, ao enviar 'Transfira R$1000 para João', o receptor verifica se o hash da mensagem bate, garantindo que não foi alterado para 'R$10000' por um atacante intermediário.",
                              "finalVerifications": [
                                "Defina integridade em uma frase precisa.",
                                "Liste 3 ataques que violam integridade.",
                                "Diferencie integridade de confidencialidade e autenticidade.",
                                "Explique como um hash assegura integridade em um protocolo.",
                                "Crie um diagrama de um ataque de modificação.",
                                "Responda a perguntas hipotéticas sobre cenários de violação."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e completa de integridade (sem omissões).",
                                "Identificação correta de pelo menos 3 ameaças específicas.",
                                "Diferenciação clara de outras propriedades de segurança.",
                                "Exemplo prático relevante com mecanismo de proteção.",
                                "Uso de analogias ou diagramas para clareza.",
                                "Ausência de confusões conceituais comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e propriedades algébricas de integridade.",
                                "Ética: Importância da integridade em comunicações confiáveis e responsabilidade digital.",
                                "Física: Analogia com conservação de energia (sem perda ou ganho indevido).",
                                "História: Evolução de protocolos seguros pós-ataques famosos como o Heartbleed."
                              ],
                              "realWorldApplication": "Em sistemas bancários online, integridade garante que instruções de transferência não sejam modificadas por cibercriminosos, prevenindo fraudes financeiras e mantendo a confiança no ecossistema digital global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Descrever primitivas para integridade",
                            "description": "Detalhar o uso de funções hash (ex: SHA-256) e Message Authentication Codes (MAC) em conjunto com chaves simétricas para verificar integridade em protocolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Funções Hash para Integridade Básica",
                                  "subSteps": [
                                    "Estude a definição de função hash: uma função unidirecional que mapeia dados de tamanho variável para um hash fixo (ex: 256 bits para SHA-256).",
                                    "Aprenda propriedades chave: determinística, resistênte a colisões, efeito avalanche e preimagem.",
                                    "Explore como hashes detectam alterações: mesmo uma mudança mínima nos dados altera o hash drasticamente.",
                                    "Pratique calculando hash de strings simples usando ferramentas online.",
                                    "Analise limitações: hashes sozinhos não previnem adulteração intencional sem autenticação."
                                  ],
                                  "verification": "Calcule o hash SHA-256 de uma mensagem antes e depois de alterá-la; confirme que o hash muda completamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial SHA-256 (NIST), ferramenta online como CyberChef ou Python hashlib library.",
                                  "tips": "Use exemplos reais como hashing de senhas para visualizar o efeito avalanche.",
                                  "learningObjective": "Explicar como funções hash garantem detecção de integridade sem chaves.",
                                  "commonMistakes": "Confundir hash com criptografia reversível; ignorar que hashes são públicos e não secretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Message Authentication Codes (MAC)",
                                  "subSteps": [
                                    "Defina MAC: combinação de hash com chave simétrica para autenticação e integridade.",
                                    "Estude algoritmos comuns: HMAC-SHA256 (hash + chave via função de mistura).",
                                    "Aprenda o processo: MAC = HMAC(chave, mensagem); receptor recalcula e compara.",
                                    "Diferencie de hashes puros: MAC requer chave compartilhada, previne forjarias.",
                                    "Implemente um MAC simples em pseudocódigo ou Python."
                                  ],
                                  "verification": "Gere um MAC para uma mensagem com uma chave; altere a mensagem ou use chave errada e veja falha na verificação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Biblioteca Python hmac/hashlib, exemplos de código HMAC no GitHub.",
                                  "tips": "Sempre use chaves fortes e aleatórias; teste com chaves fracas para ver vulnerabilidades.",
                                  "learningObjective": "Descrever como MAC adiciona autenticação à integridade via chaves simétricas.",
                                  "commonMistakes": "Usar a mesma chave para múltiplos propósitos; esquecer de validar o MAC no receptor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Primitivas em Protocolos Criptográficos",
                                  "subSteps": [
                                    "Analise fluxo em protocolos: remetente calcula hash/MAC da mensagem, anexa ao pacote.",
                                    "Estude receptor: recalcula hash/MAC e compara; rejeita se não coincidir.",
                                    "Explore exemplos: TLS (usa HMAC para integridade), IPsec AH (autenticação header).",
                                    "Discuta ataques mitigados: replay (com nonces/timestamps), man-in-the-middle.",
                                    "Desenhe diagrama de um protocolo simples usando hash + MAC."
                                  ],
                                  "verification": "Crie um diagrama de protocolo que incorpore hash e MAC; simule envio e verificação com código.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Diagramas de TLS/IPsec (RFCs), ferramenta de desenho como Draw.io, Python para simulação.",
                                  "tips": "Inclua nonces em MACs para prevenir replays; visualize fluxos com Wireshark.",
                                  "learningObjective": "Explicar integração de hash e MAC em protocolos para verificação de integridade.",
                                  "commonMistakes": "Ignorar padding ou encoding na mensagem antes do hash; assumir MAC protege confidencialidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Aplicar Primitivas em Cenários Práticos",
                                  "subSteps": [
                                    "Compare hash vs MAC: hash para integridade não-autenticada, MAC para autenticada.",
                                    "Teste cenários: arquivo transferido, API request com MAC no header.",
                                    "Estude falhas históricas: length extension em MD5, lições para SHA-256.",
                                    "Implemente verificador de integridade em script Python.",
                                    "Reflita sobre escolhas: quando usar hash puro vs MAC."
                                  ],
                                  "verification": "Implemente e execute um script que verifica integridade de uma mensagem usando MAC; documente resultados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com hmac/hashlib, exemplos de código de protocolos seguros.",
                                  "tips": "Use bibliotecas padrão em vez de reinventar; valide contra vetores de teste conhecidos.",
                                  "learningObjective": "Aplicar primitivas para verificar integridade em contextos protocolares reais.",
                                  "commonMistakes": "Revelar chaves em logs; não considerar side-channel attacks em implementações."
                                }
                              ],
                              "practicalExample": "Em um protocolo de chat seguro: Alice envia mensagem 'Olá' com MAC(HMAC-SHA256(chave_compartilhada, 'Olá')). Bob recalcula MAC e compara; se igual, aceita como íntegro e autêntico. Alteração para 'Olá!' falha na verificação.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito as propriedades de uma função hash como SHA-256.",
                                "Demonstrar cálculo e comparação de MAC com código funcional.",
                                "Desenhar fluxo de protocolo com hash/MAC e identificar pontos de falha.",
                                "Identificar quando usar hash vs MAC em um cenário dado.",
                                "Simular ataque de adulteração e mostrar como primitivas detectam.",
                                "Listar limitações de cada primitiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de funções hash (incluindo propriedades): 0-5 pontos.",
                                "Compreensão correta de MAC e integração com chaves simétricas: 0-5 pontos.",
                                "Capacidade de diagramar e explicar uso em protocolos: 0-5 pontos.",
                                "Identificação de ataques mitigados e limitações: 0-5 pontos.",
                                "Implementação prática sem erros: 0-5 pontos.",
                                "Conexões com aplicações reais: 0-5 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de funções unidirecionais e probabilidade de colisões.",
                                "Redes de Computadores: Headers de protocolo como IPsec AH/ESP.",
                                "Segurança da Informação: Autenticação e detecção de intrusões.",
                                "Programação: Implementação com bibliotecas criptográficas em Python/Java."
                              ],
                              "realWorldApplication": "Em HTTPS/TLS, HMAC garante integridade de handshakes e dados; em blockchain, hashes SHA-256 verificam blocos imutáveis; em apps de mensagens como Signal, MACs protegem contra adulterações em trânsito."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Avaliar ataques à integridade",
                            "description": "Identificar ataques como collision attacks em hashes e explicar criptoanálise básica para comprometer integridade em protocolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Integridade em Protocolos Criptográficos",
                                  "subSteps": [
                                    "Defina integridade como a garantia de que os dados não foram alterados indevidamente.",
                                    "Identifique propriedades relacionadas: autenticidade, não-repúdio e disponibilidade.",
                                    "Classifique ataques à integridade: modificação, inserção, replay e deleção.",
                                    "Estude mecanismos de proteção: hashes, MACs e assinaturas digitais.",
                                    "Analise exemplos iniciais de falhas de integridade em protocolos como TLS."
                                  ],
                                  "verification": "Resuma em um parágrafo os tipos de ataques à integridade e mecanismos de defesa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 2119 sobre termos de segurança",
                                    "Vídeo introdutório sobre propriedades CIA (Confidencialidade, Integridade, Disponibilidade)"
                                  ],
                                  "tips": "Use diagramas para visualizar como um ataque à integridade afeta o fluxo de um protocolo.",
                                  "learningObjective": "Ao final deste passo, o aluno será capaz de diferenciar integridade de outras propriedades de segurança e listar ataques comuns.",
                                  "commonMistakes": [
                                    "Confundir integridade com confidencialidade",
                                    "Ignorar ataques passivos como replay",
                                    "Subestimar o papel de hashes em protocolos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Collision Attacks em Funções Hash",
                                  "subSteps": [
                                    "Explique o que é uma função hash: entrada arbitrária para saída fixa e determinística.",
                                    "Defina collision attack: encontrar duas entradas diferentes com o mesmo hash.",
                                    "Compare hashes resistentes (SHA-256) vs. vulneráveis (MD5).",
                                    "Simule um collision simples usando ferramentas online.",
                                    "Discuta birthday attack e sua complexidade computacional (O(2^{n/2})).",
                                    "Analise impactos em protocolos: falsificação de certificados ou assinaturas."
                                  ],
                                  "verification": "Gere um collision artificial em MD5 usando uma ferramenta e documente o processo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online HashClash ou Python com hashlib",
                                    "Artigo 'Collisions in MD5' de Wang et al."
                                  ],
                                  "tips": "Teste hashes reais de arquivos para ver saídas idênticas em collisions simulados.",
                                  "learningObjective": "Identificar e demonstrar collision attacks, calculando complexidades básicas.",
                                  "commonMistakes": [
                                    "Achar que todos os hashes são igualmente seguros",
                                    "Confundir preimage attack com collision",
                                    "Ignorar contexto probabilístico do birthday attack"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Criptoanálise Básica para Comprometer Integridade",
                                  "subSteps": [
                                    "Introduza criptoanálise: estudo de fraquezas em algoritmos criptográficos.",
                                    "Estude ataques diferenciais: análise de diferenças em pares de plaintexts.",
                                    "Explore ataques lineares e chosen-plaintext attacks em contextos de integridade.",
                                    "Aplique a hashes e MACs: como encontrar fraquezas em HMAC.",
                                    "Revise casos reais: ataques em SHA-1 (SHAttered).",
                                    "Pratique identificando vulnerabilidades em pseudocódigo de protocolos."
                                  ],
                                  "verification": "Descreva um ataque diferencial aplicado a um hash simples e seus passos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Livro 'Cryptography and Network Security' de Stallings (cap. criptoanálise)",
                                    "Ferramenta Cryptohack para desafios interativos"
                                  ],
                                  "tips": "Use tabelas para mapear diferenças em ataques diferenciais.",
                                  "learningObjective": "Explicar técnicas de criptoanálise básica e seu impacto na integridade de protocolos.",
                                  "commonMistakes": [
                                    "Confundir análise estatística com brute-force",
                                    "Subestimar requisitos de chosen-textos",
                                    "Não relacionar à integridade específica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Ataques à Integridade em Protocolos Completos",
                                  "subSteps": [
                                    "Analise um protocolo como HTTPS: onde hashes garantem integridade.",
                                    "Identifique pontos de falha: MITM com collisions em certificados.",
                                    "Simule avaliação: diagrame um ataque replay ou modification attack.",
                                    "Compare mitigações: uso de nonce, timestamps e chaves frescas.",
                                    "Crie um relatório de risco para um protocolo dado.",
                                    "Teste com Wireshark: capture tráfego e identifique potenciais violações."
                                  ],
                                  "verification": "Produza um diagrama de ataque à integridade em um protocolo simples como um handshake.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes",
                                    "Diagrama de protocolo TLS 1.2/1.3"
                                  ],
                                  "tips": "Sempre considere o protocolo inteiro, não só o algoritmo isolado.",
                                  "learningObjective": "Avaliar holisticamente ataques à integridade em protocolos reais.",
                                  "commonMistakes": [
                                    "Focar só em teoria sem simulação prática",
                                    "Ignorar camadas de rede",
                                    "Não quantificar severidade do ataque"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de votação eletrônica, um atacante usa um collision attack em MD5 para substituir um voto 'Não' por 'Sim' sem alterar o hash verificador, comprometendo a integridade do resultado final.",
                              "finalVerifications": [
                                "Lista corretamente 5 ataques à integridade com exemplos.",
                                "Explica collision attack e birthday paradox em termos simples.",
                                "Identifica criptoanálise diferencial em um cenário dado.",
                                "Avalia riscos em um protocolo como TLS com diagrama.",
                                "Propõe mitigações específicas para cada ataque estudado.",
                                "Simula um collision attack com ferramenta prática."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e classificação de ataques (30%)",
                                "Profundidade na explicação de collisions e criptoanálise (25%)",
                                "Qualidade de simulações e diagramas práticos (20%)",
                                "Relevância de exemplos e aplicações em protocolos (15%)",
                                "Clareza na identificação de mitigações e erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e complexidade computacional (birthday paradox)",
                                "Segurança Cibernética: Análise de ameaças e vulnerabilidades",
                                "Redes de Computadores: Protocolos como TLS e análise de tráfego",
                                "Ética: Implicações de ataques em sistemas críticos como eleições"
                              ],
                              "realWorldApplication": "Na blockchain do Bitcoin, avaliar collision attacks em SHA-256 previne falsificação de transações, garantindo integridade em milhões de dólares diários; em apps bancários, detecta MITM que alteram saldos via replay attacks."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Autenticação",
                        "description": "Garantia de que as partes em um protocolo são quem afirmam ser, verificando identidades e prevenindo impersonificação.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Definir autenticação em protocolos",
                            "description": "Explicar autenticação como a propriedade que confirma a identidade das entidades comunicantes, distinguindo autenticação de entidade e de mensagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de autenticação em protocolos",
                                  "subSteps": [
                                    "Leia definições padrão de autenticação em criptografia de fontes confiáveis.",
                                    "Identifique o papel principal: confirmar a identidade das entidades comunicantes.",
                                    "Registre o contexto em protocolos: por que é essencial para segurança.",
                                    "Crie um diagrama simples de comunicação sem e com autenticação.",
                                    "Resuma em uma frase própria o conceito."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é autenticação em protocolos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de criptografia",
                                    "Acesso à internet para artigos introdutórios",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias cotidianas, como verificar identidade com documento antes de uma transação.",
                                  "learningObjective": "Dominar a definição básica de autenticação como confirmação de identidade das partes comunicantes.",
                                  "commonMistakes": "Confundir autenticação apenas com senhas, ignorando contextos protocolares mais amplos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar autenticação de entidade",
                                  "subSteps": [
                                    "Defina autenticação de entidade: confirmação da identidade de uma entidade em um momento específico.",
                                    "Estude mecanismos comuns: challenge-response, certificados digitais.",
                                    "Analise um exemplo: handshake inicial em TLS para verificar o servidor.",
                                    "Simule um fluxo simples de autenticação de entidade em pseudocódigo.",
                                    "Liste vantagens e limitações em protocolos."
                                  ],
                                  "verification": "Descreva um mecanismo de autenticação de entidade com um exemplo prático.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de protocolos como TLS/SSL",
                                    "Ferramenta de desenho online como Draw.io",
                                    "Vídeos tutoriais curtos sobre handshakes"
                                  ],
                                  "tips": "Pense em termos de 'quem está batendo na porta?' – foque no momento da interação.",
                                  "learningObjective": "Diferenciar e exemplificar autenticação de entidade em comunicações seguras.",
                                  "commonMistakes": "Misturar com autenticação de longo prazo, como contas de usuário, em vez de sessões efêmeras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar autenticação de mensagem",
                                  "subSteps": [
                                    "Defina autenticação de mensagem: garante origem e integridade da mensagem.",
                                    "Estude primitivas: MAC (Message Authentication Code), assinaturas digitais.",
                                    "Analise exemplo: HMAC em mensagens de um protocolo para prevenir tampering.",
                                    "Compare com hash simples: por que autenticação requer chaves compartilhadas ou assimétricas.",
                                    "Crie um exemplo de cálculo manual simplificado de MAC."
                                  ],
                                  "verification": "Explique como uma MAC autentica uma mensagem e detecta alterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca de criptografia online (ex: Crypto101)",
                                    "Calculadora para hashes simples",
                                    "Notas de aula anteriores sobre hashes"
                                  ],
                                  "tips": "Visualize como um selo inviolável na mensagem – qualquer mudança quebra o selo.",
                                  "learningObjective": "Compreender autenticação de mensagem como proteção contra falsificação e modificação.",
                                  "commonMistakes": "Confundir com confidencialidade, achando que autenticação criptografa o conteúdo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Distinguir autenticação de entidade e de mensagem em protocolos",
                                  "subSteps": [
                                    "Compare definições lado a lado em uma tabela.",
                                    "Identifique cenários onde ambos são usados: ex. protocolo completo como SSH.",
                                    "Discuta interdependências: entidade autentica o canal, mensagem autentica o payload.",
                                    "Avalie falhas: replay attacks em entidade vs. forgery em mensagem.",
                                    "Sintetize em um fluxograma de um protocolo genérico."
                                  ],
                                  "verification": "Crie uma tabela comparativa precisa entre os dois tipos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de tabela como Google Sheets",
                                    "Diagramas de protocolos de referência",
                                    "Fórum ou parceiro para discussão"
                                  ],
                                  "tips": "Entidade é 'quem envia', mensagem é 'o que envia é autêntico' – separe os conceitos.",
                                  "learningObjective": "Distinguir claramente autenticação de entidade de mensagem e sua aplicação em protocolos.",
                                  "commonMistakes": "Tratar como sinônimos, ignorando que entidade é peer-to-peer e mensagem é por datagrama."
                                }
                              ],
                              "practicalExample": "No protocolo HTTPS (TLS), autenticação de entidade ocorre no handshake inicial via certificado do servidor para confirmar sua identidade; autenticação de mensagem usa HMAC em cada registro de aplicação para garantir que dados como senhas não foram alterados em trânsito.",
                              "finalVerifications": [
                                "Defina autenticação em protocolos criptográficos em uma frase.",
                                "Explique autenticação de entidade com um mecanismo exemplo.",
                                "Descreva autenticação de mensagem e sua diferença da anterior.",
                                "Identifique um protocolo real que usa ambos os tipos.",
                                "Diferencie de propriedades como confidencialidade e integridade.",
                                "Dê um exemplo de falha sem autenticação de entidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de autenticação como confirmação de identidade.",
                                "Distinção clara e correta entre autenticação de entidade e de mensagem.",
                                "Uso de exemplos relevantes de protocolos criptográficos.",
                                "Compreensão de mecanismos subjacentes (ex: MAC, certificados).",
                                "Capacidade de ilustrar diferenças via diagramas ou tabelas.",
                                "Identificação de contextos de aplicação em segurança de rede."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Primitivas criptográficas como funções hash e MACs.",
                                "Redes de Computadores: Integração em protocolos como TCP/IP seguro.",
                                "Ética e Sociedade: Implicações de falhas de autenticação em privacidade e cibersegurança.",
                                "Física: Analogias com sinais quânticos para autenticação incondicional."
                              ],
                              "realWorldApplication": "Em aplicativos bancários móveis, autenticação de entidade verifica o usuário via biometria ou token durante login, enquanto autenticação de mensagem protege transações com assinaturas digitais, prevenindo fraudes como man-in-the-middle ou alterações em transferências financeiras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Explicar esquemas de autenticação",
                            "description": "Descrever autenticação mútua com chaves simétricas (ex: protocolos baseados em chaves compartilhadas) e assimétricas (ex: assinaturas digitais com RSA).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Autenticação Mútua",
                                  "subSteps": [
                                    "Defina autenticação mútua como o processo onde duas partes verificam a identidade uma da outra.",
                                    "Explique a diferença entre autenticação unilateral e mútua.",
                                    "Discuta a importância da confidencialidade e integridade nos esquemas de autenticação.",
                                    "Identifique desafios como ataques de replay e man-in-the-middle.",
                                    "Revise terminologia chave: chaves simétricas vs. assimétricas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo autenticação mútua e liste 3 desafios comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de autenticação básica",
                                    "Notas sobre criptografia introdutória"
                                  ],
                                  "tips": "Use analogias como 'duas pessoas trocando senhas secretas' para visualizar.",
                                  "learningObjective": "Compreender os fundamentos e terminologia de autenticação mútua.",
                                  "commonMistakes": [
                                    "Confundir autenticação com autorização",
                                    "Ignorar ataques de replay"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Autenticação Mútua com Chaves Simétricas",
                                  "subSteps": [
                                    "Descreva chaves simétricas como chaves compartilhadas usadas para cifrar e decifrar.",
                                    "Explique um protocolo simples: A envia nonce cifrado com K; B responde com nonce cifrado.",
                                    "Detalhe o protocolo de necessidade de acordo (Needham-Schroeder com chaves simétricas).",
                                    "Simule o fluxo: geração de nonce, cifragem, verificação de frescura.",
                                    "Analise vulnerabilidades como reutilização de chaves."
                                  ],
                                  "verification": "Desenhe o diagrama de fluxo do protocolo e anote cada mensagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online como Cryptool para simulação"
                                  ],
                                  "tips": "Lembre-se: nonce garante frescura; sempre inclua-o nas mensagens.",
                                  "learningObjective": "Descrever e simular autenticação usando chaves compartilhadas.",
                                  "commonMistakes": [
                                    "Esquecer nonces para prevenir replays",
                                    "Assumir chaves públicas em simétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Autenticação Mútua com Chaves Assimétricas",
                                  "subSteps": [
                                    "Introduza pares de chaves: pública para verificação, privada para assinatura.",
                                    "Explique assinaturas digitais: hash da mensagem assinada com chave privada.",
                                    "Descreva protocolo com RSA: A assina desafio de B com sua privada; B verifica com pública de A.",
                                    "Detalhe fluxo mútua: troca de desafios assinados reciprocamente.",
                                    "Compare eficiência com simétrico em termos de computação."
                                  ],
                                  "verification": "Implemente um exemplo simples de assinatura RSA em pseudocódigo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca Python como cryptography para teste opcional",
                                    "Documentação RSA"
                                  ],
                                  "tips": "Pense em assinaturas como 'selos digitais' impossíveis de forjar sem chave privada.",
                                  "learningObjective": "Explicar autenticação usando assinaturas digitais e chaves assimétricas.",
                                  "commonMistakes": [
                                    "Confundir assinatura com cifragem",
                                    "Ignorar necessidade de hash para integridade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Esquemas e Aplicar Conhecimento",
                                  "subSteps": [
                                    "Compare simétrico (rápido, mas distribuição de chave difícil) vs. assimétrico (seguro, computacionalmente caro).",
                                    "Discuta híbridos: simétrico para dados, assimétrico para chaves.",
                                    "Analise exemplos reais: Kerberos (simétrico), TLS (híbrido com assimétrico).",
                                    "Crie uma tabela de prós/contras.",
                                    "Resolva um cenário: escolha esquema para IoT vs. banco online."
                                  ],
                                  "verification": "Preencha tabela comparativa e justifique escolha para 2 cenários.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela modelo em Excel ou papel",
                                    "Referências a protocolos reais"
                                  ],
                                  "tips": "Foco em trade-offs: use simétrico onde performance importa.",
                                  "learningObjective": "Comparar esquemas e selecionar baseado em contexto.",
                                  "commonMistakes": [
                                    "Superestimar segurança sem gerenciamento de chaves",
                                    "Ignorar custos computacionais"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule autenticação mútua em um chat seguro: Alice gera nonce1, cifra com chave simétrica compartilhada e envia a Bob; Bob responde com nonce1+1 cifrado e seu nonce2; Alice confirma. Para assimétrico, Alice assina nonce de Bob com RSA privada; Bob verifica com pública de Alice.",
                              "finalVerifications": [
                                "Descreve corretamente fluxo de autenticação simétrica com nonces.",
                                "Explica assinatura digital RSA passo a passo.",
                                "Identifica pelo menos 2 vulnerabilidades em cada esquema.",
                                "Compara prós/contras de simétrico vs. assimétrico.",
                                "Aplica esquemas a cenários reais como TLS.",
                                "Desenha diagramas precisos de protocolos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (20%)",
                                "Clareza na descrição de fluxos (25%)",
                                "Uso correto de terminologia criptográfica (15%)",
                                "Análise de vulnerabilidades (20%)",
                                "Comparação equilibrada (10%)",
                                "Exemplos práticos relevantes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e algoritmos RSA.",
                                "Segurança da Informação: Análise de ameaças em protocolos.",
                                "Redes de Computadores: Integração em TLS/SSL.",
                                "Programação: Implementação de criptografia em código."
                              ],
                              "realWorldApplication": "Usado em protocolos como TLS para HTTPS (autenticação de servidores com certificados RSA), Kerberos em redes corporativas (chaves simétricas), e SSH para login remoto seguro, prevenindo acessos não autorizados em comunicações cotidianas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Analisar falhas de autenticação",
                            "description": "Reconhecer ataques como man-in-the-middle e replay attacks, e como protocolos criptográficos os mitigam usando nonces ou timestamps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Autenticação",
                                  "subSteps": [
                                    "Defina autenticação como o processo de verificar a identidade de uma entidade.",
                                    "Identifique componentes chave: credenciais (senhas, tokens), desafios e respostas.",
                                    "Explique propriedades essenciais: confidencialidade, integridade e frescura.",
                                    "Diferencie autenticação de autorização.",
                                    "Revise exemplos simples de protocolos como login básico com senha."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos básicos e liste 2 exemplos de falhas sem criptografia.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fluxo de autenticação básica",
                                    "Artigo introdutório sobre autenticação"
                                  ],
                                  "tips": "Use analogias como 'chave de casa' para credenciais para fixar conceitos.",
                                  "learningObjective": "Compreender os fundamentos da autenticação para contextualizar falhas.",
                                  "commonMistakes": [
                                    "Confundir autenticação com autorização",
                                    "Ignorar a importância da frescura das mensagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Ataques Man-in-the-Middle (MITM)",
                                  "subSteps": [
                                    "Descreva MITM: atacante intercepta comunicação entre cliente e servidor.",
                                    "Simule cenário: atacante captura credenciais em trânsito não criptografado.",
                                    "Identifique impactos: roubo de sessões, impersonação.",
                                    "Discuta detecção: análise de certificados inválidos ou latência anormal.",
                                    "Compare com eavesdropping passivo."
                                  ],
                                  "verification": "Desenhe um diagrama de MITM e explique como ele compromete a autenticação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para captura de pacotes simulada",
                                    "Vídeo demonstrativo de MITM"
                                  ],
                                  "tips": "Teste em ambiente controlado como localhost para visualizar interceptação.",
                                  "learningObjective": "Reconhecer mecanismos e consequências do MITM em protocolos de autenticação.",
                                  "commonMistakes": [
                                    "Achar que HTTPS sempre previne MITM sem verificação de certificado",
                                    "Subestimar ataques ARP spoofing"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Replay Attacks",
                                  "subSteps": [
                                    "Defina replay attack: atacante captura e retransmite mensagens válidas.",
                                    "Explique vulnerabilidade em protocolos sem controle de tempo ou unicidade.",
                                    "Simule: captura de token de login e replay para acesso não autorizado.",
                                    "Discuta detecção: logs de duplicatas ou timestamps inválidos.",
                                    "Diferencie de MITM: foco em repetição vs. interceptação ativa."
                                  ],
                                  "verification": "Crie um exemplo de mensagem replay e identifique por que falha sem proteção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script Python simples para simular replay",
                                    "Documentação de ataques replay em OWASP"
                                  ],
                                  "tips": "Use ferramentas como Burp Suite para capturar e repetir requests.",
                                  "learningObjective": "Identificar como replays exploram falta de frescura em autenticações.",
                                  "commonMistakes": [
                                    "Confundir replay com brute force",
                                    "Ignorar que replays funcionam em mensagens criptografadas mas não 'frescas'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Mitigações com Nonces e Timestamps",
                                  "subSteps": [
                                    "Defina nonce: número usado uma vez para garantir unicidade.",
                                    "Explique timestamp: marca temporal para validar frescura.",
                                    "Descreva uso em protocolos: cliente gera nonce/timestamp, servidor verifica.",
                                    "Compare: nonces previnem replays por unicidade, timestamps por validade temporal.",
                                    "Analise protocolos como Kerberos ou TLS que os incorporam."
                                  ],
                                  "verification": "Modifique um diagrama de autenticação adicionando nonce/timestamp e explique a proteção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código em Python com nonce",
                                    "RFCs de protocolos como OAuth 2.0"
                                  ],
                                  "tips": "Gere nonces aleatórios com uuid para testes práticos.",
                                  "learningObjective": "Compreender como nonces e timestamps mitigam MITM e replays.",
                                  "commonMistakes": [
                                    "Reutilizar nonces (torna vulnerável)",
                                    "Usar timestamps sem sincronização de relógios"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um login web vulnerável: use um script Python para servidor/cliente sem nonce. Capture um login válido com Wireshark, replay a mensagem para ganhar acesso indevido. Adicione nonce gerado por cliente e verifique falha no replay.",
                              "finalVerifications": [
                                "Explique MITM e replay em suas próprias palavras com diagramas.",
                                "Identifique 3 protocolos que usam nonces/timestamps.",
                                "Simule uma falha de autenticação e sua mitigação.",
                                "Diferencie impactos de MITM vs. replay.",
                                "Liste limitações de nonces (ex: clock skew em timestamps)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de ataques (90% correto).",
                                "Uso correto de terminologia (nonce, frescura, etc.).",
                                "Capacidade de diagramar fluxos com mitigações.",
                                "Exemplos práticos viáveis e testados.",
                                "Análise de limitações e cenários edge-case.",
                                "Conexão clara entre falhas e soluções criptográficas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e geração de números pseudo-aleatórios para nonces.",
                                "Redes de Computadores: Protocolos de camada de transporte como TLS.",
                                "Ética e Direito: Implicações legais de ataques cibernéticos.",
                                "Desenvolvimento de Software: Implementação segura de autenticação em apps."
                              ],
                              "realWorldApplication": "Em aplicativos bancários como apps de mobile banking, nonces e timestamps previnem replays em transações, enquanto certificados TLS mitigam MITM, garantindo segurança em logins remotos e evitando fraudes financeiras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 229
          }
        ],
        "totalSkills": 229
      }
    ]
  }
}