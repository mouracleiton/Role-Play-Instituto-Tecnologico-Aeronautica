{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T10:35:15.838Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - AT-92",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 296
    },
    "areas": [
      {
        "id": "10",
        "name": "Matemática",
        "description": "Área de Matemática, abrangendo tópicos avançados em análise numérica e métodos computacionais.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Análise Numérica II",
            "description": "Métodos de diferenças finitas. Convergência, consistência, estabilidade. Equações parabólicas: convergência, estabilidade, métodos ADI. Equações elípticas: Condições de Dirichlet e de Neumann. Equações hiperbólicas: métodos explícitos e implícitos. Noções de Dispersão e Dissipação.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Métodos de Diferenças Finitas",
                "description": "Introdução aos métodos de diferenças finitas para resolver equações diferenciais parciais.",
                "totalSkills": 54,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Introdução aos Métodos de Diferenças Finitas",
                    "description": "Fundamentos e formulação básica dos métodos de diferenças finitas para equações diferenciais parciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Formulação Básica dos Métodos de Diferenças Finitas",
                        "description": "Apresentação dos princípios fundamentais para discretizar equações diferenciais parciais (EDPs) em grades retangulares, utilizando aproximações por diferenças finitas para derivadas parciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar diferenças finitas forward, backward e central",
                            "description": "Diferenciar e calcular as diferenças finitas forward (progressiva), backward (retroativa) e central para aproximar a primeira e segunda derivadas em uma dimensão, incluindo o erro de truncagem associado a cada esquema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender diferenças finitas forward e backward para a primeira derivada",
                                  "subSteps": [
                                    "Defina a diferença finita forward como Δf(x) = [f(x+h) - f(x)] / h, onde h é o passo espacial.",
                                    "Defina a diferença finita backward como ∇f(x) = [f(x) - f(x-h)] / h.",
                                    "Derive as fórmulas a partir da expansão de Taylor e identifique o erro de truncagem O(h) para ambos.",
                                    "Calcule um exemplo simples com f(x) = x² em x=1, h=0.1.",
                                    "Compare os resultados forward e backward com a derivada exata f'(x)=2x=2."
                                  ],
                                  "verification": "Reproduzir as fórmulas e calcular corretamente o exemplo, com erro menor que 0.1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Tabela de valores de funções teste"
                                  ],
                                  "tips": "Visualize forward como 'olhando para frente' e backward como 'olhando para trás' na grade de pontos.",
                                  "learningObjective": "Dominar as definições e fórmulas básicas das diferenças forward e backward para primeira derivada.",
                                  "commonMistakes": [
                                    "Confundir os sinais nas fórmulas",
                                    "Esquecer de dividir por h",
                                    "Usar h negativo inadvertidamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar diferenças finitas central para a primeira derivada",
                                  "subSteps": [
                                    "Defina a diferença finita central como δf(x) = [f(x+h) - f(x-h)] / (2h).",
                                    "Derive a fórmula via expansão de Taylor, notando o erro de truncagem O(h²), mais preciso.",
                                    "Calcule para f(x) = sin(x) em x=0, h=0.1, comparando com derivada exata cos(0)=1.",
                                    "Discuta vantagens da central (simetria e precisão maior).",
                                    "Pratique com outro função, como f(x)=e^x em x=1."
                                  ],
                                  "verification": "Calcular o valor central com erro <0.01 e explicar por que é mais preciso que forward/backward.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de exercícios com funções",
                                    "Gráficos de funções"
                                  ],
                                  "tips": "A central usa pontos simétricos, reduzindo o erro de ordem par.",
                                  "learningObjective": "Entender a superioridade da diferença central em precisão para primeira derivada.",
                                  "commonMistakes": [
                                    "Dividir por h em vez de 2h",
                                    "Confundir com segunda derivada",
                                    "Ignorar simetria nos pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formulação das diferenças finitas para segunda derivada",
                                  "subSteps": [
                                    "Derive a segunda derivada forward: [f(x+2h) - 2f(x+h) + f(x)] / h², erro O(h).",
                                    "Derive a backward: [f(x) - 2f(x-h) + f(x-2h)] / h².",
                                    "Derive a central: [f(x+h) - 2f(x) + f(x-h)] / h², erro O(h²).",
                                    "Calcule para f(x)=x³ em x=1, h=0.1; derivada exata f''(x)=6x=6.",
                                    "Compare precisões entre os esquemas."
                                  ],
                                  "verification": "Reproduzir todas as três fórmulas e calcular com erro relativo <5%.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de cálculo simbólico opcional (ex: Python/SymPy)",
                                    "Tabelas de valores"
                                  ],
                                  "tips": "Lembre-se que segundas derivadas envolvem combinações lineares de três pontos.",
                                  "learningObjective": "Dominar fórmulas para aproximação de segundas derivadas com os três esquemas.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes (-2 no termo central)",
                                    "Confundir escalas de h (2h vs h)",
                                    "Não normalizar por h²"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise de erros de truncagem e comparação dos métodos",
                                  "subSteps": [
                                    "Expanda cada fórmula via Taylor e isole os termos de erro: O(h) para forward/backward, O(h²) para central.",
                                    "Crie uma tabela comparativa de erros para f(x)=sin(x) em x=π/4, variando h=0.1, 0.01.",
                                    "Discuta trade-offs: precisão vs custo computacional (pontos necessários).",
                                    "Implemente um cálculo tabular para visualização.",
                                    "Conclua quando usar cada método (ex: central para precisão interna)."
                                  ],
                                  "verification": "Montar tabela de erros mostrando convergência e ordenar métodos por precisão.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para tabulação",
                                    "Gráficos de erro vs h (log-log)"
                                  ],
                                  "tips": "Plote erro vs h em escala log para ver a ordem de convergência.",
                                  "learningObjective": "Analisar e comparar erros, escolhendo método apropriado por contexto.",
                                  "commonMistakes": [
                                    "Ignorar termos de ordem superior no Taylor",
                                    "Confundir erro local com global",
                                    "Não variar h para testar convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado uma tabela de temperaturas em uma barra: T(0)=0, T(0.1)=0.995, T(0.2)=0.980. Aproxime a taxa de mudança térmica (primeira derivada) em x=0.1 usando forward, backward e central, e a curvatura (segunda derivada). Compare com solução analítica de equação de calor.",
                              "finalVerifications": [
                                "Deriva corretamente todas as fórmulas forward, backward e central para 1ª e 2ª derivadas.",
                                "Calcula aproximações numéricas com erros consistentes com análise de truncagem.",
                                "Constrói tabela comparativa de erros para h variados.",
                                "Explica verbalmente diferenças em precisão e aplicação.",
                                "Aplica a um exemplo prático não visto, obtendo resultado coerente.",
                                "Identifica esquema ótimo para cenários de fronteira vs interior."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas derivadas (100% correto).",
                                "Cálculos numéricos sem erros aritméticos (<1% erro relativo).",
                                "Análise de erro de truncagem com ordens corretas identificadas.",
                                "Tabela comparativa clara e conclusiva.",
                                "Explicação qualitativa das diferenças entre métodos.",
                                "Aplicação criativa em exemplo real."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aproximação de velocidades (1ª derivada) e acelerações (2ª derivada) em mecânica.",
                                "Computação: Base para métodos numéricos em programação (ex: bibliotecas NumPy/SciPy).",
                                "Engenharia: Simulações em CFD e estruturas finitas.",
                                "Economia: Derivadas numéricas em modelagem financeira e opções.",
                                "Processamento de Imagens: Detecção de bordas via diferenças finitas."
                              ],
                              "realWorldApplication": "Esses métodos são essenciais em simulações computacionais como dinâmica de fluidos (CFD), onde aproximam derivadas em malhas discretas para resolver PDEs; em finanças para sensibilidade de preços (Greeks); e em machine learning para gradientes em dados discretos, permitindo previsões precisas sem analítico exato."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Aplicar diferenças finitas a derivadas parciais em EDPs",
                            "description": "Construir esquemas de diferenças finitas para aproximar derivadas parciais em duas dimensões, como ∂u/∂x e ∂²u/∂y², em uma grade uniforme.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar diferenças finitas para derivadas em uma dimensão",
                                  "subSteps": [
                                    "Relembre a aproximação forward para ∂u/∂x: (u_{i+1} - u_i)/h",
                                    "Relembre a aproximação central: (u_{i+1} - u_{i-1})/(2h)",
                                    "Relembre a aproximação para segunda derivada ∂²u/∂x²: (u_{i+1} - 2u_i + u_{i-1})/h²",
                                    "Pratique derivando essas fórmulas a partir da definição de derivada",
                                    "Identifique o erro de truncamento O(h²) para esquemas centrados"
                                  ],
                                  "verification": "Derive corretamente as três fórmulas principais e calcule o erro de truncamento para uma função teste como u(x) = sin(x)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Notebook com fórmulas de diferenças finitas"
                                  ],
                                  "tips": "Use expansões de Taylor para derivar as aproximações e visualizar o erro.",
                                  "learningObjective": "Compreender as bases das diferenças finitas em 1D para extensão a derivadas parciais.",
                                  "commonMistakes": [
                                    "Confundir forward com backward",
                                    "Esquecer o fator h no denominador",
                                    "Ignorar o ordem do erro de truncamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar uma grade uniforme em duas dimensões",
                                  "subSteps": [
                                    "Defina a grade 2D: pontos (x_i, y_j) onde x_i = i*h_x, y_j = j*h_y, com h_x = h_y = h para uniformidade",
                                    "Indexe os pontos como u_{i,j} ≈ u(x_i, y_j)",
                                    "Desenhe uma grade 5x5 e rotule os vizinhos de um ponto central (i,j): (i-1,j), (i+1,j), (i,j-1), (i,j+1)",
                                    "Calcule distâncias e identifique stencil de 5 pontos para derivadas mistas",
                                    "Verifique consistência dimensional assumindo h_x = h_y"
                                  ],
                                  "verification": "Desenhe corretamente o stencil para um ponto interno e liste os índices dos vizinhos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis",
                                    "Software de desenho como GeoGebra ou papel"
                                  ],
                                  "tips": "Comece com uma grade pequena para visualizar; assuma h uniforme para simplificar.",
                                  "learningObjective": "Dominar a indexação e representação de grades 2D uniformes.",
                                  "commonMistakes": [
                                    "Indexação errada (confundir i com j)",
                                    "Esquecer condições de contorno",
                                    "Assumir h_x ≠ h_y prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximar derivadas parciais de primeira ordem: ∂u/∂x e ∂u/∂y",
                                  "subSteps": [
                                    "Aplique forward em x: ∂u/∂x |_{i,j} ≈ (u_{i+1,j} - u_{i,j})/h",
                                    "Aplique central em x: ∂u/∂x |_{i,j} ≈ (u_{i+1,j} - u_{i-1,j})/(2h)",
                                    "Da mesma forma para ∂u/∂y |_{i,j} ≈ (u_{i,j+1} - u_{i,j-1})/(2h)",
                                    "Teste com função conhecida u(x,y) = x*y em grade 4x4",
                                    "Calcule erro usando valor exato da derivada"
                                  ],
                                  "verification": "Implemente em uma tabela ou código simples e compare com derivada analítica para pelo menos 3 pontos",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy)",
                                    "Função teste impressa"
                                  ],
                                  "tips": "Use esquema central para precisão O(h²); teste em pontos internos apenas.",
                                  "learningObjective": "Construir aproximações precisas para derivadas parciais de primeira ordem em 2D.",
                                  "commonMistakes": [
                                    "Misturar direções x e y nos índices",
                                    "Dividir por 2h em forward",
                                    "Aplicar em bordas sem ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aproximar derivadas parciais de segunda ordem: ∂²u/∂y²",
                                  "subSteps": [
                                    "Aplique stencil padrão: ∂²u/∂y² |_{i,j} ≈ (u_{i,j+1} - 2u_{i,j} + u_{i,j-1})/h²",
                                    "Derive via Taylor em y, mantendo x fixo",
                                    "Combine com ∂u/∂x para EDPs como a equação de advecção",
                                    "Teste com u(x,y) = sin(πx) * sin(πy) e verifique erro O(h²)",
                                    "Discuta estabilidade básica (não amplificar erros)"
                                  ],
                                  "verification": "Calcule a aproximação para 5 pontos internos e confirme erro < 1% com h=0.1",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou MATLAB para cálculo numérico",
                                    "Gráficos de erro"
                                  ],
                                  "tips": "Sempre normalize pelo h² em segundas derivadas; plote erros vs h.",
                                  "learningObjective": "Desenvolver esquemas para segundas derivadas parciais em EDPs 2D.",
                                  "commonMistakes": [
                                    "Usar h em vez de h²",
                                    "Confundir ∂²u/∂x∂y com separadas",
                                    "Ignorar truncamento em y"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir e validar esquema completo para uma EDP simples",
                                  "subSteps": [
                                    "Escolha EDP: ∂u/∂t = ∂²u/∂x² + ∂²u/∂y² (calor 2D)",
                                    "Monte o sistema discreto: u^{n+1}_{i,j} = u^n_{i,j} + Δt/h² (u^n_{i+1,j} + u^n_{i-1,j} + u^n_{i,j+1} + u^n_{i,j-1} - 4u^n_{i,j})",
                                    "Aplique condições de Dirichlet em bordas",
                                    "Implemente 10 iterações e plote evolução",
                                    "Valide contra solução analítica estacionária"
                                  ],
                                  "verification": "O esquema converge para solução conhecida com ||erro|| < 0.01",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Código template de grade 2D"
                                  ],
                                  "tips": "Escolha Δt/h² < 1/4 para estabilidade explícita.",
                                  "learningObjective": "Integrar todas as aproximações em um esquema funcional para EDPs.",
                                  "commonMistakes": [
                                    "Fator -4 errado no laplaciano",
                                    "Passo de tempo instável",
                                    "Bordas não tratadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace ∇²u = 0 em um quadrado unitário com u=0 nas bordas x=0,1 e u=sin(πy) nas laterais y=0,1. Use diferenças finitas centrais: (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² = 0. Resolva o sistema linear resultante em uma grade 10x10 e compare com solução exata u(x,y)=sin(πx)sin(πy).",
                              "finalVerifications": [
                                "Deriva corretamente aproximações para ∂u/∂x, ∂u/∂y e ∂²u/∂y² em 2D",
                                "Constrói stencil preciso para laplaciano 2D sem erros de indexação",
                                "Implementa esquema em código e obtém convergência com erro O(h²)",
                                "Identifica e corrige instabilidades básicas como Δt excessivo",
                                "Valida contra solução analítica em pelo menos um exemplo",
                                "Explica truncamento e consistência do esquema"
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas de diferenças finitas (90% correto)",
                                "Correta indexação e stencil em grade 2D",
                                "Implementação funcional com condições de contorno",
                                "Análise de erro e ordem de convergência demonstrada",
                                "Clareza na derivação via Taylor",
                                "Aplicação coerente a EDP exemplo"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para grades e solvers lineares",
                                "Física: Modelagem de difusão de calor ou potencial eletrostático",
                                "Engenharia: Simulações CFD para escoamentos incompressíveis",
                                "Computação Científica: Introdução a métodos numéricos paralelizáveis",
                                "Matemática Aplicada: Análise de estabilidade via von Neumann"
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), diferenças finitas aproximam derivadas parciais nas equações de Navier-Stokes para prever fluxos em aviões ou turbinas; em geofísica, modelam propagação de ondas sísmicas em reservatórios de petróleo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Discretizar uma EDP elíptica simples",
                            "description": "Formular o esquema de diferenças finitas de cinco pontos para a equação de Laplace (∇²u = 0) em uma grade 2D com condições de contorno de Dirichlet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema e Configurar a Grade 2D",
                                  "subSteps": [
                                    "Escreva a equação de Laplace em 2D: ∇²u = ∂²u/∂x² + ∂²u/∂y² = 0 no domínio Ω (ex: retângulo [0,a] × [0,b]).",
                                    "Especifique condições de contorno de Dirichlet: u(x,y) = g(x,y) nas bordas ∂Ω.",
                                    "Escolha o passo de grade uniforme h = a/(N+1) = b/(M+1), onde N e M são o número de intervalos internos em x e y.",
                                    "Desenhe a grade 2D com pontos internos (i,j) para i=1 a N, j=1 a M, identificando pontos de contorno.",
                                    "Rotule os valores conhecidos nas bordas como u_{0,j}, u_{N+1,j}, u_{i,0}, u_{i,M+1}."
                                  ],
                                  "verification": "Verifique se a grade está corretamente indexada, com h consistente e todos os pontos de contorno identificados em um diagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (ex: GeoGebra, papel e lápis)",
                                    "Calculadora para h"
                                  ],
                                  "tips": "Use uma grade pequena inicial (ex: 3x3 pontos internos) para facilitar a visualização.",
                                  "learningObjective": "Compreender o setup geométrico e as condições de contorno para EDPs elípticas.",
                                  "commonMistakes": [
                                    "Confundir índices internos (1 a N) com totais (0 a N+1)",
                                    "Escolher h inconsistente entre x e y"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Aproximações de Diferenças Finitas para Derivadas Segundas",
                                  "subSteps": [
                                    "Aproxime ∂²u/∂x² no ponto (x_i, y_j) por (u_{i+1,j} - 2u_{i,j} + u_{i-1,j}) / h² (diferença finita central, ordem O(h²)).",
                                    "Aproxime ∂²u/∂y² por (u_{i,j+1} - 2u_{i,j} + u_{i,j-1}) / h².",
                                    "Some as aproximações para obter o laplaciano discreto: ∇²u_{i,j} ≈ [u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}] / h².",
                                    "Defina a equação discreta: ∇²u_{i,j} = 0 ⇒ u_{i,j} = (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}) / 4.",
                                    "Desenhe o stencil de 5 pontos (centro e 4 vizinhos) para visualizar a relação."
                                  ],
                                  "verification": "Confirme que o coeficiente central é -4/h² e vizinhos +1/h² na forma ∇²u ≈ 0, ou média dos vizinhos na forma rearranjada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel para derivar Taylor e stencil",
                                    "Livro de referência em diferenças finitas (opcional)"
                                  ],
                                  "tips": "Lembre-se da expansão de Taylor para justificar a truncagem O(h²).",
                                  "learningObjective": "Dominar a derivação de diferenças finitas centradas para o laplaciano 2D.",
                                  "commonMistakes": [
                                    "Usar diferenças forward/backward em vez de central (baixa precisão)",
                                    "Esquecer o fator 1/h² inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Condições de Contorno de Dirichlet",
                                  "subSteps": [
                                    "Para pontos internos (i=1..N, j=1..M), a equação é u_{i,j} = (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}) / 4.",
                                    "Substitua valores conhecidos nas bordas: ex, para i=1, u_{0,j} = g(0,y_j) é fixo.",
                                    "Escreva equações para pontos próximos às bordas, incorporando g diretamente.",
                                    "Liste todas as NM equações para os pontos internos.",
                                    "Verifique simetria do stencil perto das bordas."
                                  ],
                                  "verification": "Todas as equações internas usam valores de borda conhecidos sem variáveis extras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela para listar equações por (i,j)",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Comece pelos cantos para praticar: ex, canto inferior esquerdo usa u_{0,0}, u_{1,0}, u_{0,1}.",
                                  "learningObjective": "Integrar condições de contorno no esquema discreto.",
                                  "commonMistakes": [
                                    "Tratar bordas como desconhecidas",
                                    "Interpolação desnecessária para Dirichlet (use valores diretos)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o Sistema Linear e Verificar Consistência",
                                  "subSteps": [
                                    "Reescreva as equações na forma Au = b, onde A é matriz esparsa NM×NM com 4 na diagonal e -1 nos off-diagonais.",
                                    "Monte vetor b incorporando contribuições das bordas: b_k = soma de g nos vizinhos de contorno.",
                                    "Para uma grade pequena (ex: 2x2), escreva explicitamente A e b.",
                                    "Confirme propriedades: A simétrica, definida positiva para Laplace.",
                                    "Discuta ordem de precisão global O(h²) e consistência."
                                  ],
                                  "verification": "Sistema balanceado: soma de linhas internas =0, exceto contribuições de b.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz esparsa em papel ou MATLAB/Python para exemplo",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Use ordenação natural (i + (j-1)*N) para indexar variáveis.",
                                  "learningObjective": "Formular o problema discreto como sistema linear solucionável.",
                                  "commonMistakes": [
                                    "Índices errados na matriz A",
                                    "Esquecer contribuições assimétricas de bordas em b"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma placa quadrada [0,1]×[0,1] com u=0 nas bordas x=0, x=1, y=0 e u=sin(πx) em y=1. Com h=0.25 (N=M=3), derive as 9 equações, monte A (9×9) e b, resultando em u_{1,1} ≈ 0.15, u_{2,2} ≈ 0.31 (aprox. solução exata sin(πx)sinh(πy)/sinh(π)).",
                              "finalVerifications": [
                                "Stencil de 5 pontos correto: u_{i,j} = média dos 4 vizinhos.",
                                "Todas NM equações escritas com BCs Dirichlet incorporadas.",
                                "Matriz A esparsa com -4 diagonal, +1 adjacentes; b com valores de g.",
                                "Soma de cada linha de A + contribuições b = 0 (propriedade de Laplace).",
                                "Ordem de precisão O(h²) justificada por diferenças centradas.",
                                "Exemplo numérico pequeno resolvido manualmente para verificação."
                              ],
                              "assessmentCriteria": [
                                "Correção da derivação das diferenças finitas (erro <5% em coeficientes).",
                                "Integração precisa de BCs Dirichlet sem variáveis extras (100% dos valores de borda usados).",
                                "Montagem correta de Au=b para grade pequena (verificação por substituição).",
                                "Identificação de propriedades da matriz A (simetria, esparsidade).",
                                "Explicação clara da consistência e estabilidade do esquema.",
                                "Visualização adequada do stencil e grade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos eletrostáticos (equação de Poisson ∇²φ = -ρ/ε).",
                                "Engenharia Mecânica: Análise de fluxo de calor estacionário em placas.",
                                "Computação: Implementação de solvers iterativos (Gauss-Seidel, multigrid) em Python/NumPy.",
                                "Matemática Aplicada: Teoria de EDPs elípticas e análise de erros.",
                                "Engenharia Civil: Simulação de tensões em estruturas planas."
                              ],
                              "realWorldApplication": "Simulação da distribuição de temperatura em uma chapa metálica fina com bordas mantidas a temperaturas fixas (ex: forno industrial), permitindo otimização de processos de aquecimento uniforme sem hotspots."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Consistência dos Métodos de Diferenças Finitas",
                        "description": "Conceito de consistência como a propriedade pela qual o erro de truncagem do esquema tende a zero quando o tamanho da malha h → 0 e o passo de tempo τ → 0.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Calcular o erro de truncagem local",
                            "description": "Derivar a expansão de Taylor para determinar o erro de truncagem O(h²) ou O(τ) em esquemas de diferenças finitas para EDPs parabólicas e elípticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a expansão de Taylor multivariada e o esquema de diferenças finitas",
                                  "subSteps": [
                                    "Estude a expansão de Taylor para funções de duas variáveis u(x,y) até ordem 4.",
                                    "Identifique o esquema de diferenças finitas para uma EDP parabólica, como a equação de calor: u_t = u_xx.",
                                    "Anote o esquema explícito forward Euler em tempo e central em espaço: (u^{n+1}_i - u^n_i)/τ = (u^n_{i+1} - 2u^n_i + u^n_{i-1})/h².",
                                    "Repita para uma EDP elíptica como Laplace: u_xx + u_yy = 0, com stencil de 5 pontos."
                                  ],
                                  "verification": "Escreva as expansões de Taylor e esquemas corretamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de análise numérica, caderno, calculadora simbólica (ex: SymPy).",
                                  "tips": "Comece com 1D para simplificar antes de ir para 2D.",
                                  "learningObjective": "Compreender os fundamentos teóricos necessários para análise de erro.",
                                  "commonMistakes": "Confundir ordens de derivadas ou notação de stencil."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar expansão de Taylor à solução exata no ponto de grade",
                                  "subSteps": [
                                    "Expanda u(x_i + h, y_j, t_n) e u(x_i - h, y_j, t_n) em torno de (x_i, y_j, t_n) até termos O(h^4) e O(τ).",
                                    "Para tempo, expanda u(x_i, y_j, t_n + τ) em derivadas temporais.",
                                    "Substitua no esquema de diferenças finitas, alinhando com a EDP original.",
                                    "Colete termos de ordem baixa que cancelam com a EDP."
                                  ],
                                  "verification": "Verifique se os termos de ordem 0,1,2 casam com a EDP discretizada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, lápis, software de álgebra computacional.",
                                  "tips": "Use notação compacta com somatórios para Taylor multivariada.",
                                  "learningObjective": "Dominar a expansão de Taylor aplicada a grids discretos.",
                                  "commonMistakes": "Esquecer termos mistos como ∂⁴u/∂x²∂y² em 2D."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Isolar e identificar o erro de truncagem local",
                                  "subSteps": [
                                    "Subtraia a EDP exata do esquema expandido para isolar resíduos.",
                                    "Agrupe termos residuais: identifique O(h²) para diferenças centrais espaciais e O(τ) para tempo forward.",
                                    "Para elípticas, confirme simetria leva a O(h²) uniforme.",
                                    "Escreva o erro local como |τ L[u] - (esquema)| ≤ C h² + D τ."
                                  ],
                                  "verification": "O resíduo deve ser exatamente O(h²) + O(τ) sem termos menores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folhas de cálculo, referências de livros como LeVeque 'Finite Difference Methods'.",
                                  "tips": "Fatore h² ou τ para visualizar ordens claramente.",
                                  "learningObjective": "Calcular precisamente o resíduo de truncagem.",
                                  "commonMistakes": "Ignorar coeficientes exatos nos termos de erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar para EDPs parabólicas e elípticas",
                                  "subSteps": [
                                    "Teste numéricamente com função conhecida (ex: u(x,t)=sin(x) e^{-t}).",
                                    "Generalize para operadores elípticos como ∇²u = f.",
                                    "Discuta impacto de condições de contorno na truncagem local.",
                                    "Registre a ordem final: O(h² + τ) para parabólica explícita."
                                  ],
                                  "verification": "Simulação numérica confirma taxa de convergência de 2 em h.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/MATLAB para teste numérico, código de diferenças finitas.",
                                  "tips": "Use grids finos para validar assintoticamente.",
                                  "learningObjective": "Generalizar a análise de consistência.",
                                  "commonMistakes": "Confundir truncagem local com global."
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx, esquema: u^{n+1}_i = u^n_i + τ/h² (u^n_{i+1} - 2u^n_i + u^n_{i-1}). Expandindo Taylor: LHS = u + τ u_t + (τ²/2) u_{tt} + O(τ³); RHS = u + τ u_xx + (h²/12) u_{xxxx} + O(h^4). Erro: τ (u_t - u_xx) + (τ²/2) u_{tt} + (h²/12) u_{xxxx} + ..., mas como u_t = u_xx, truncagem local O(τ + h²).",
                              "finalVerifications": [
                                "Derivação de Taylor reproduz EDP exata nos termos principais.",
                                "Resíduo é corretamente O(h²) para espaço central e O(τ) para tempo.",
                                "Cálculo numérico com solução exata confirma ordem de erro.",
                                "Generalização para elíptica (Laplace) yields O(h²).",
                                "Identifica coeficientes exatos como h²/12 para u_{xxxx}.",
                                "Sem erros em notação ou índices de grade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (termos até ordem necessária).",
                                "Correta identificação e ordem do erro de truncagem.",
                                "Manipulação algébrica sem erros aritméticos.",
                                "Generalização coerente para parabólicas/elípticas.",
                                "Uso apropriado de notação O(h^k).",
                                "Validação prática via exemplo numérico."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão em equações de calor/condução.",
                                "Computação: Implementação e análise de estabilidade em solvers numéricos.",
                                "Engenharia: Simulações CFD para fluxos parabólicos.",
                                "Estatística: Análise de erro em métodos Monte Carlo para EDPs."
                              ],
                              "realWorldApplication": "Em simulações climáticas, calcular truncagem garante precisão em previsões de temperatura (EDPs parabólicas); em design estrutural, erros controlados em solvers elípticos evitam falhas em análises de tensão."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Verificar consistência de um esquema numérico",
                            "description": "Analisar se um esquema de diferenças finitas é consistente com a EDP original, comparando os operadores discretos com os diferenciais via expansão em série de Taylor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a EDP original e o esquema numérico proposto",
                                  "subSteps": [
                                    "Leia e anote a equação diferencial parcial (EDP) original, incluindo termos diferenciais e condições iniciais/limites.",
                                    "Escreva o esquema numérico de diferenças finitas explicitamente, identificando os operadores discretos (ex.: diferenças forward, backward ou central).",
                                    "Defina os parâmetros de discretização, como passo h em x e k em t.",
                                    "Verifique se o esquema está corretamente indexado (i para espaço, n para tempo).",
                                    "Desenhe um stencil gráfico do esquema para visualização espacial."
                                  ],
                                  "verification": "Confirme que a EDP e o esquema estão anotados corretamente e o stencil desenhado sem erros tipográficos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de diagramação (ex.: Draw.io)",
                                    "Referência do problema da EDP"
                                  ],
                                  "tips": "Sempre use notação consistente para índices (ex.: u_i^n para u(x_i, t_n)).",
                                  "learningObjective": "Compreender a estrutura da EDP e sua discretização numérica.",
                                  "commonMistakes": [
                                    "Confundir operadores forward/backward",
                                    "Esquecer termos de tempo em EDPs parabolicas",
                                    "Ignorar condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar expansão em série de Taylor dos operadores discretos",
                                  "subSteps": [
                                    "Expanda cada termo discretizado (ex.: u_{i+1}^n) em série de Taylor em torno de (x_i, t_n).",
                                    "Inclua termos até ordem suficiente (geralmente até O(h^4) ou superior para precisão).",
                                    "Substitua as expansões no esquema numérico completo.",
                                    "Agrupe termos por derivadas parciais (u_x, u_xx, u_t, etc.).",
                                    "Identifique os coeficientes de cada derivada resultante."
                                  ],
                                  "verification": "As expansões de Taylor coincidem com fórmulas padrão (ex.: u_{i+1} = u + h u_x + (h^2/2) u_xx + ...).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex.: Mathematica ou papel)",
                                    "Tabelas de expansões de Taylor pré-computadas"
                                  ],
                                  "tips": "Use a fórmula geral de Taylor multidimensional para EDPs em espaço-tempo.",
                                  "learningObjective": "Dominar a expansão de Taylor para aproximações discretas.",
                                  "commonMistakes": [
                                    "Parar a expansão prematuramente (ex.: só até 1º ordem)",
                                    "Erros de sinal em termos pares/impares",
                                    "Confundir derivadas espaciais e temporais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar o esquema expandido com a EDP original",
                                  "subSteps": [
                                    "Subtraia o lado esquerdo expandido do esquema pelo lado direito da EDP.",
                                    "Colete termos de ordem zero (que devem cancelar exatamente).",
                                    "Identifique o erro de truncamento (termos residuais de ordem alta).",
                                    "Verifique se os coeficientes das derivadas principais coincidem com a EDP.",
                                    "Calcule a ordem de consistência (menor expoente no erro O(h^p + k^q))."
                                  ],
                                  "verification": "O erro de truncamento é O(h^p) com p ≥ 1 para consistência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculo ou software (ex.: SymPy para simplificação algébrica)"
                                  ],
                                  "tips": "Normalize o esquema dividindo pelo fator de discretização (ex.: /h^2 para 2ª derivada).",
                                  "learningObjective": "Analisar correspondência entre operadores discretos e diferenciais.",
                                  "commonMistakes": [
                                    "Ignorar termos temporais em esquemas implícitos",
                                    "Confundir ordem de h e k",
                                    "Não dividir por passos de malha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir sobre a consistência e documentar resultados",
                                  "subSteps": [
                                    "Afirme se o esquema é consistente (lim h,k→0 do erro → 0).",
                                    "Especifique a ordem de consistência (ex.: 2ª ordem em espaço).",
                                    "Discuta impactos em estabilidade/convergência (teorema Lax).",
                                    "Teste numericamente com uma solução exata simples se possível.",
                                    "Registre limitações ou melhorias sugeridas."
                                  ],
                                  "verification": "Declaração clara de consistência com ordem e justificativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código simples em Python/MATLAB para teste numérico opcional"
                                  ],
                                  "tips": "Lembre: Consistência é necessária mas não suficiente para convergência.",
                                  "learningObjective": "Interpretar resultados de análise de consistência.",
                                  "commonMistakes": [
                                    "Concluir consistência sem verificar lim h→0",
                                    "Ignorar assimetrias em operadores",
                                    "Confundir com estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDP de calor u_t = u_xx, considere o esquema explícito: u_i^{n+1} - u_i^n = (k/h^2)(u_{i+1}^n - 2u_i^n + u_{i-1}^n). Expansão de Taylor mostra que é consistente de ordem 1 em tempo e 2 em espaço, com erro O(k + h^2).",
                              "finalVerifications": [
                                "Coeficientes das derivadas principais coincidem exatamente com a EDP.",
                                "Erro de truncamento tende a zero quando h, k → 0.",
                                "Ordem de consistência é pelo menos 1 em cada direção.",
                                "Nenhum termo espúrio de ordem baixa aparece.",
                                "Stencil e expansões estão corretos via substituição numérica teste.",
                                "Documentação inclui ordem explícita e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expansões de Taylor (sem erros algébricos).",
                                "Correta identificação de termos de erro e ordem.",
                                "Justificativa clara da consistência ou inconsistência.",
                                "Uso adequado de notação e visualizações (stencil).",
                                "Análise de pelo menos um exemplo concreto.",
                                "Conexão com teorema de Lax para contexto mais amplo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão de calor ou ondas via EDPs.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD em aerodinâmica.",
                                "Estatística: Análise de erros de aproximação em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como previsão de clima (modelos Navier-Stokes discretizados), onde verificar consistência garante que soluções numéricas aproximem fielmente a física real, evitando erros em previsões de furacões ou fluxos turbulentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Determinar a ordem de consistência",
                            "description": "Identificar e calcular a ordem de precisão (ex.: segundo ordem em h) de esquemas comuns como Lax-Friedrichs ou Leapfrog para EDPs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Consistência",
                                  "subSteps": [
                                    "Defina consistência: um esquema é consistente se o operador de diferença local L_h tende para o operador diferencial L quando h, k → 0.",
                                    "Explique ordem de consistência: a maior p tal que ||L_h u - L u|| = O(h^p + k^q) para u suave.",
                                    "Identifique notação padrão: h = Δx (espaço), k = Δt (tempo).",
                                    "Discuta importância para convergência via Lax Equivalence Theorem.",
                                    "Liste esquemas comuns: Lax-Friedrichs (1ª ordem), Leapfrog (2ª ordem)."
                                  ],
                                  "verification": "Escreva definições em suas palavras e cite um teorema relacionado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), caderno, lápis.",
                                  "tips": "Use analogias com aproximações finitas em ODEs para fixar ideias.",
                                  "learningObjective": "Compreender conceitualmente consistência e sua ordem.",
                                  "commonMistakes": "Confundir consistência com estabilidade; consistência é sobre aproximação local."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Expansão de Taylor para Operadores de Diferença",
                                  "subSteps": [
                                    "Expanda u(x + h) = u + h u_x + (h^2/2) u_xx + (h^3/6) u_xxx + O(h^4).",
                                    "Derive operadores de diferença centrados e deslocados: δ_x u = (u_{i+1} - u_{i-1})/(2h) = u_x + O(h^2).",
                                    "Para tempo: similar com k, ex: (u^{n+1} - u^{n-1})/(2k) = u_t + O(k^2).",
                                    "Combine para esquemas espaciais-temporais: identifique termos de truncamento.",
                                    "Pratique em 1D: advection u_t + a u_x = 0."
                                  ],
                                  "verification": "Calcule expansão de Taylor para δ_x^2 u até O(h^4) e verifique = u_xx + (h^2/12) u_xxxx.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora simbólica (ex: Mathematica ou papel), exemplos de PDEs simples.",
                                  "tips": "Sempre normalize por h ou k para isolar ordens.",
                                  "learningObjective": "Aplicar séries de Taylor a operadores finitos.",
                                  "commonMistakes": "Esquecer termos pares/impares ou sinal errado em expansões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Ordem para Lax-Friedrichs",
                                  "subSteps": [
                                    "Esquema: u_i^{n+1} = (u_{i+1}^n + u_{i-1}^n)/2 - (a k /(2h)) (u_{i+1}^n - u_{i-1}^n).",
                                    "Expanda cada termo: u_{i+1}^n = u + h u_x + (h^2/2) u_xx + ... + k u_t + ...",
                                    "Substitua e colete termos: encontre L_h u = u_t + a u_x + (h/(2)) u_xx + O(k^2 + h^2).",
                                    "Identifique ordem: O(h) em espaço (devido a Lax-Friedrichs dissipativo), O(k) em tempo.",
                                    "Conclua: ordem 1 em h e k."
                                  ],
                                  "verification": "Mostre que truncamento é O(h + k); teste com u(x,t) = sin(x - a t).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel quadriculado, referências de esquemas (notas de aula).",
                                  "tips": "Agrupe termos por potências de h e k sistematicamente.",
                                  "learningObjective": "Executar análise completa para esquema 1ª ordem.",
                                  "commonMistakes": "Ignorar termo (h/2) u_xx como leading error."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Ordem para Leapfrog e Generalizar",
                                  "subSteps": [
                                    "Esquema Leapfrog para onda u_tt = c^2 u_xx: u_i^{n+1} = 2 u_i^n - u_i^{n-1} + λ^2 (u_{i+1}^n - 2 u_i^n + u_{i-1}^n), λ = c k / h.",
                                    "Expanda em Taylor multi-dimensional (espaço e tempo até 2k).",
                                    "Colete: truncamento O(k^2 + h^2), ordem 2 em ambos.",
                                    "Compare com Lax-Friedrichs: Leapfrog não dissipativo.",
                                    "Generalize: verifique ordem via definição formal para esquemas arbitrários."
                                  ],
                                  "verification": "Derive explicitamente O(h^2 + k^2) para Leapfrog.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software simbólico opcional (SymPy), exemplos numéricos.",
                                  "tips": "Use notação compacta: δ_t^2 u / k^2 = u_tt + O(k^2).",
                                  "learningObjective": "Analisar esquemas 2ª ordem e sintetizar padrões.",
                                  "commonMistakes": "Confundir Leapfrog (2nd order) com upwind (1st order)."
                                }
                              ],
                              "practicalExample": "Para equação de advecção u_t + u_x = 0, aplique Lax-Friedrichs com a=1, h=0.1, k=0.05. Expansão mostra erro O(h) = 0.1, simulando numericamente confirme dispersão artificial.",
                              "finalVerifications": [
                                "Calcule corretamente ordem 1 para Lax-Friedrichs mostrando termo (h/2) u_xx.",
                                "Derive ordem 2 para Leapfrog em u_tt = u_xx.",
                                "Explique Lax Equivalence: consistência + estabilidade ⇒ convergência.",
                                "Identifique ordem para FTCS scheme (1 em tempo, 2 em espaço).",
                                "Teste com solução exata: erro numérico ~ h^p.",
                                "Generalize para esquema arbitrário via Taylor."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (termos até ordem correta).",
                                "Identificação correta da ordem de consistência (p,q).",
                                "Explicação conceitual clara da definição formal.",
                                "Tratamento de erros comuns (ex: termos paridade).",
                                "Aplicação consistente a múltiplos esquemas.",
                                "Conexão com convergência e estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de esquemas em equações de onda/fluido.",
                                "Computação: Implementação em código para verificação numérica.",
                                "Engenharia: Simulações CFD onde ordem afeta precisão.",
                                "Estatística: Análise de erro de truncamento como viés."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), esquemas de 2ª ordem como Leapfrog minimizam erros em simulações de longo prazo de ondas atmosféricas, economizando poder computacional vs ordens mais altas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Estabilidade dos Métodos de Diferenças Finitas",
                        "description": "Propriedade que garante o controle do crescimento de erros numéricos, analisada via método von Neumann ou matriz de amplificação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Entender a condição CFL para estabilidade",
                            "description": "Explicar e aplicar a condição Courant-Friedrichs-Lewy (CFL) para esquemas explícitos em EDPs hiperbólicas e parabólicas, como τ ≤ h/c.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de estabilidade em métodos explícitos",
                                  "subSteps": [
                                    "Revise o conceito de estabilidade von Neumann para esquemas de diferenças finitas.",
                                    "Identifique as diferenças entre esquemas explícitos e implícitos em EDPs.",
                                    "Analise exemplos simples de instabilidade numérica em simulações hiperbólicas.",
                                    "Estude a amplificação de erros em iterações temporais.",
                                    "Discuta o papel do passo de tempo τ e espacial h na estabilidade."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios de estabilidade e dê um exemplo de instabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque 'Finite Difference Methods')",
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com equações de transporte linear para visualização intuitiva.",
                                  "learningObjective": "Entender por que a estabilidade é crucial em métodos explícitos para EDPs.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com precisão",
                                    "Ignorar o papel da análise de Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a condição CFL para EDPs hiperbólicas",
                                  "subSteps": [
                                    "Considere a equação de advecção u_t + c u_x = 0 com esquema explícito forward-time central-space.",
                                    "Aplique a análise von Neumann: assuma solução u_j^n = ξ^n e^{i k j h}.",
                                    "Calcule o fator de amplificação |ξ| ≤ 1, levando a τ ≤ h / |c|.",
                                    "Interprete fisicamente: informação não pode viajar mais que uma célula por passo de tempo.",
                                    "Teste com valores de Courant number σ = c τ / h > 1 para observar instabilidade."
                                  ],
                                  "verification": "Derive a condição τ ≤ h/c em um papel e verifique |ξ| ≤ 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para plotar fatores de amplificação",
                                    "Folhas de cálculo"
                                  ],
                                  "tips": "Use o diagrama de Courant para visualizar a propagação de informação.",
                                  "learningObjective": "Derivar e interpretar a condição CFL para esquemas hiperbólicos.",
                                  "commonMistakes": [
                                    "Erro no sinal da derivada espacial",
                                    "Esquecer o módulo no fator de amplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a condição CFL em EDPs parabólicas",
                                  "subSteps": [
                                    "Estude a equação do calor u_t = α u_xx com esquema FTCS (forward-time central-space).",
                                    "Derive a condição de estabilidade τ ≤ (h^2)/(2α) via análise von Neumann.",
                                    "Compare com hiperbólicas: note a dependência quadrática em h.",
                                    "Implemente uma simulação numérica simples e varie τ para testar.",
                                    "Analise o número de Courant difusivo r = α τ / h^2 ≤ 1/2."
                                  ],
                                  "verification": "Execute uma simulação e confirme estabilidade para r ≤ 0.5.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Código exemplo de heat equation"
                                  ],
                                  "tips": "Comece com condições iniciais gaussianas para observar difusão.",
                                  "learningObjective": "Estender a CFL para esquemas parabólicos e identificar diferenças.",
                                  "commonMistakes": [
                                    "Usar central em tempo para parabólicas (instável)",
                                    "Confundir coeficientes de difusão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e verificar a aplicação da condição CFL",
                                  "subSteps": [
                                    "Resolva um problema misto hiperbólico-parabólico (ex: Burgers' equation linearizada).",
                                    "Escolha τ e h para satisfazer CFL em ambas componentes.",
                                    "Compare soluções numéricas com analíticas para diferentes σ.",
                                    "Documente casos de violação e correção adaptativa de passos.",
                                    "Discuta limitações da CFL em geometrias complexas ou não-lineares."
                                  ],
                                  "verification": "Gere gráficos mostrando estabilidade vs. instabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Referências online sobre CFL (ex: CFD Wiki)"
                                  ],
                                  "tips": "Use adaptive time-stepping para eficiência prática.",
                                  "learningObjective": "Aplicar CFL de forma integrada e diagnosticar problemas.",
                                  "commonMistakes": [
                                    "Não considerar velocidade máxima em fluxos variáveis",
                                    "Ignorar condições de contorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 em [0,2] com u(0,x)=sen(πx), h=0.1. Use τ=0.05 (σ=0.5, estável) vs. τ=0.2 (σ=2, instável). Plote u em t=1 e observe oscilações na violação.",
                              "finalVerifications": [
                                "Derive corretamente CFL para advecção e heat equation.",
                                "Implemente simulação estável e instável com gráficos.",
                                "Explique fisicamente o limite τ ≤ h/c.",
                                "Identifique CFL em um esquema dado.",
                                "Ajuste parâmetros para estabilidade em problema misto.",
                                "Discuta exceções (ex: esquemas upwind)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (fator amplificação correto).",
                                "Interpretação física intuitiva da condição.",
                                "Implementação numérica sem erros de código.",
                                "Análise qualitativa/quantitativa de resultados.",
                                "Capacidade de generalizar para outros esquemas.",
                                "Clareza na documentação de verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e difusão em mecânica de fluidos.",
                                "Computação: Otimização numérica e paralelismo em simulações PDE.",
                                "Engenharia: CFD para aerodinâmica e previsão meteorológica.",
                                "Matemática Aplicada: Análise de Fourier e estabilidade linear."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), a condição CFL garante simulações estáveis de choques em aviões ou previsão de furacões, evitando crashes computacionais em supercomputadores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Realizar análise de estabilidade von Neumann",
                            "description": "Aplicar o método von Neumann para calcular o fator de amplificação em esquemas de diferenças finitas, verificando |g| ≤ 1 para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o esquema de diferenças finitas e formular o problema",
                                  "subSteps": [
                                    "Identificar a equação diferencial parcial (EDP) alvo, como a equação de advecção ou de onda.",
                                    "Escrever o esquema de diferenças finitas explícito, incluindo os coeficientes e operadores de diferença (forward, backward, central).",
                                    "Definir os parâmetros: passo de tempo Δt, passo de espaço Δx, número de Courant λ = a Δt / Δx.",
                                    "Desenhar o stencil do esquema para visualizar as contribuições vizinhas.",
                                    "Verificar a consistência do esquema com a EDP original."
                                  ],
                                  "verification": "O aluno consegue escrever corretamente o stencil e os parâmetros do esquema em uma folha de papel.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro-texto de análise numérica (ex: LeVeque)",
                                    "Software como MATLAB ou Python para stencil visual"
                                  ],
                                  "tips": "Comece sempre pela EDP original para evitar confusões no esquema aproximado.",
                                  "learningObjective": "Entender a estrutura do esquema de diferenças finitas e sua relação com a EDP.",
                                  "commonMistakes": [
                                    "Confundir operadores forward/backward",
                                    "Esquecer termos de difusão implícitos",
                                    "Ignorar o número de Courant"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir solução de Fourier e substituir no esquema",
                                  "subSteps": [
                                    "Assumir solução mono-cromática: u_j^n = g^n e^{i k j Δx}, onde k é o número de onda.",
                                    "Substituir na equação do esquema: u_j^{n+1} ≈ g u_j^n para cada termo.",
                                    "Calcular as diferenças finitas: Δu forward = (u_{j+1} - u_j)/Δx → (e^{i k Δx} - 1)/Δx.",
                                    "Simplificar expressões trigonométricas: usar seno e cosseno para fatores de amplificação.",
                                    "Isolar g^{n+1}/g^n = g, obtendo a equação algébrica para g."
                                  ],
                                  "verification": "Derivação correta da forma de Fourier substituída, com fatores e^{i θ} onde θ = k Δx.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folhas de derivadas trigonométricas padrão"
                                  ],
                                  "tips": "Lembre-se: a solução de Fourier é periódica e captura modos de alta frequência (Nyquist).",
                                  "learningObjective": "Aplicar o ansatz de von Neumann para linearizar o esquema.",
                                  "commonMistakes": [
                                    "Esquecer o expoente n em g^n",
                                    "Erro no sinal das diferenças finitas",
                                    "Não usar i para imaginário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o fator de amplificação g(k)",
                                  "subSteps": [
                                    "Resolver a equação algébrica para g: g = 1 + λ (e^{iθ} - 1) para FTCS, por exemplo.",
                                    "Simplificar g usando identidades: g = 1 - i λ sinθ + ... para casos reais.",
                                    "Calcular |g|^2 = g * conj(g) para obter módulo.",
                                    "Expressar |g| em função de θ = k Δx, com θ ∈ [0, π].",
                                    "Plotar |g(θ)| graficamente para visualizar comportamento."
                                  ],
                                  "verification": "Expressão fechada de |g(θ)| correta e plotada corretamente.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotar |g(θ)|",
                                    "Tabela de identidades trigonométricas"
                                  ],
                                  "tips": "Use expansão em série de Taylor para θ pequeno (modo de baixa frequência).",
                                  "learningObjective": "Calcular analiticamente o símbolo de amplificação von Neumann.",
                                  "commonMistakes": [
                                    "Erro no cálculo de |g|^2 (não conjugar corretamente)",
                                    "Limitar θ a [0, 2π] em vez de [0,π]",
                                    "Ignorar modos de alta frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar condição de estabilidade e analisar domínio",
                                  "subSteps": [
                                    "Impor |g(θ)| ≤ 1 para todo θ ∈ [0, π].",
                                    "Analisar numericamente: encontrar max_θ |g(θ)| e condição em λ.",
                                    "Identificar região de estabilidade no plano complexo (para esquemas multi-estágio).",
                                    "Testar esquemas conhecidos: FTCS instável, Lax-Wendroff condicionalmente estável.",
                                    "Concluir se o esquema é estável, instável ou condicional."
                                  ],
                                  "verification": "Conclusão correta sobre estabilidade com limite em λ (ex: λ ≤ 1 para upwind).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos de |g(θ)| gerados",
                                    "Tabela de esquemas padrão e suas condições"
                                  ],
                                  "tips": "Verifique sempre θ=π (modo Nyquist, mais instável).",
                                  "learningObjective": "Determinar estabilidade via critério von Neumann.",
                                  "commonMistakes": [
                                    "Achar estável se |g|≤1 só para θ=0",
                                    "Confundir estabilidade com consistência",
                                    "Não testar extremos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação de advecção u_t + u_x = 0: u_j^{n+1} = u_j^n - (λ/2)(u_{j+1}^n - u_{j-1}^n). Substitua Fourier: g = 1 - i λ sinθ. Então |g|^2 = 1 + λ² sin²θ >1 para λ>0, provando instabilidade incondicional.",
                              "finalVerifications": [
                                "Derivação correta de g(θ) para esquema dado.",
                                "Cálculo preciso de |g(θ)| e máximo.",
                                "Identificação correta da condição de estabilidade em λ.",
                                "Análise qualitativa de modos de alta/baixa frequência.",
                                "Plot de |g(θ)| mostrando comportamento.",
                                "Comparação com esquemas conhecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g (100% correto).",
                                "Cobertura completa de θ ∈ [0,π].",
                                "Interpretação física da instabilidade (amplificação de erros).",
                                "Uso correto de ferramentas computacionais para plots.",
                                "Clareza na conclusão de estabilidade.",
                                "Identificação de limitações do método von Neumann (linearidade)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise espectral de ondas e dispersão.",
                                "Computação: Análise de estabilidade em simulações numéricas PDE.",
                                "Engenharia: CFD (dinâmica de fluidos computacional).",
                                "Matemática: Análise complexa e funções trigonométricas."
                              ],
                              "realWorldApplication": "Essencial em simulações numéricas de previsão meteorológica, dinâmica de fluidos (ex: NASA CFD), propagação de ondas sísmicas e modelagem climática, garantindo que erros numéricos não explodam em longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Comparar esquemas explícitos e implícitos",
                            "description": "Discutir a estabilidade incondicional de esquemas implícitos (ex.: Crank-Nicolson) versus condicional de explícitos para a equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os esquemas explícito e implícito para a equação do calor",
                                  "subSteps": [
                                    "Estudar a equação do calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Derivar o esquema explícito usando diferenças finitas forward em tempo e central em espaço.",
                                    "Derivar o esquema implícito (backward Euler) usando diferenças finitas backward em tempo.",
                                    "Introduzir o esquema Crank-Nicolson como média entre explícito e implícito.",
                                    "Implementar as fórmulas em pseudocódigo para clareza."
                                  ],
                                  "verification": "Escrever as fórmulas matemáticas dos três esquemas em um caderno ou documento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex.: Burden & Faires), caderno, calculadora.",
                                  "tips": "Use notação consistente para Δt, Δx e r = α Δt / (Δx)².",
                                  "learningObjective": "Compreender as diferenças fundamentais na discretização temporal entre esquemas explícitos e implícitos.",
                                  "commonMistakes": "Confundir forward e backward em tempo; ignorar o parâmetro r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estabilidade do esquema explícito",
                                  "subSteps": [
                                    "Aplicar o método de von Neumann: assumir solução u_j^n = ξ^n e^{i k j Δx} e encontrar |ξ| ≤ 1.",
                                    "Derivar a condição de estabilidade: r ≤ 1/2 para o explícito.",
                                    "Simular numericamente com r > 1/2 para observar instabilidade (oscilações).",
                                    "Discutir o raio espectral da matriz de amplificação.",
                                    "Comparar com estabilidade absoluta."
                                  ],
                                  "verification": "Gerar gráfico de solução instável com r=1 em software como Python.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB, equação do calor script base.",
                                  "tips": "Comece com k=π/Δx para modo mais instável.",
                                  "learningObjective": "Identificar a restrição condicional de estabilidade no esquema explícito.",
                                  "commonMistakes": "Esquecer o fator |ξ|; usar r>1/2 sem simulação visual."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a estabilidade do esquema implícito (Crank-Nicolson)",
                                  "subSteps": [
                                    "Aplicar von Neumann ao Crank-Nicolson: derivar ξ = [1 - 2r sin²(θ/2)] / [1 + 2r sin²(θ/2)], θ=kΔx.",
                                    "Verificar |ξ| ≤ 1 para todo r > 0 e θ.",
                                    "Resolver o sistema tridiagonal implícito via Thomas algorithm.",
                                    "Simular com r grande (ex.: r=10) para confirmar estabilidade.",
                                    "Comparar precisão (ordem 2 em tempo vs. ordem 1 do implícito simples)."
                                  ],
                                  "verification": "Executar simulação estável com r=10 e comparar com solução exata.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/MATLAB com solver tridiagonal, dados de condição inicial (ex.: barra quente).",
                                  "tips": "Implemente o algoritmo Thomas para eficiência O(n).",
                                  "learningObjective": "Demonstrar estabilidade incondicional dos esquemas implícitos.",
                                  "commonMistakes": "Negligenciar a matriz transposta no Crank-Nicolson; erro na fórmula de ξ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e discutir as implicações práticas",
                                  "subSteps": [
                                    "Tabular condições: Explícito (r≤0.5, Δt~Δx²), Implícito (incondicional, Δt livre).",
                                    "Discutir trade-offs: explícito simples mas restrito; implícito estável mas iterativo.",
                                    "Analisar custo computacional: explícito O(n), implícito O(n) por step.",
                                    "Explorar exemplos reais de falha explícito em problemas stiff.",
                                    "Redigir um relatório comparativo."
                                  ],
                                  "verification": "Criar tabela comparativa e relatório de 1 página.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha (Excel/Google Sheets), relatório template.",
                                  "tips": "Inclua gráficos de ambos esquemas lado a lado.",
                                  "learningObjective": "Sintetizar vantagens/desvantagens para escolha de método.",
                                  "commonMistakes": "Ignorar custo em 3D; superestimar simplicidade implícito."
                                }
                              ],
                              "practicalExample": "Simule a equação do calor em uma barra de 1m com extremidades a 0°C, inicial u(x,0)=sin(πx), α=1. Use Δx=0.1, teste explícito com Δt=0.001 (r=0.5, estável) vs. Δt=0.01 (r=5, instável com oscilações). Para Crank-Nicolson com Δt=0.1 (r=10), solução permanece suave e precisa.",
                              "finalVerifications": [
                                "Explicar verbalmente a condição r≤1/2 para explícito.",
                                "Mostrar gráfico de |ξ| vs. θ para ambos esquemas.",
                                "Implementar e rodar código para Crank-Nicolson com r=10 estável.",
                                "Identificar instabilidade em simulação explícita com r>0.5.",
                                "Redigir parágrafo comparando estabilidade incondicional vs. condicional.",
                                "Comparar erro numérico com solução exata u(x,t)=sin(πx) e^{-π² α t}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das condições de estabilidade (von Neumann correto).",
                                "Qualidade dos gráficos e simulações numéricas (ausência de artefatos).",
                                "Profundidade da comparação (trade-offs custo/estabilidade/precisão).",
                                "Correta implementação do solver implícito (Thomas algorithm).",
                                "Clareza no relatório e exemplos práticos.",
                                "Identificação de erros comuns em esquemas explícitos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e parabólicas PDEs.",
                                "Computação: Algoritmos numéricos, solvers lineares e programação científica.",
                                "Engenharia: Simulações em transferência de calor (ex.: design de reatores).",
                                "Matemática Aplicada: Análise de erros e estabilidade em EDOs/PDEs."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, esquemas implícitos como Crank-Nicolson são usados em simulações CFD para prever fluxos térmicos em foguetes, permitindo passos de tempo maiores sem instabilidade, otimizando simulações de longa duração em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.4",
                        "name": "Convergência dos Métodos de Diferenças Finitas",
                        "description": "Teorema de Lax-Richtmyer: um esquema consistente e estável converge para a solução exata da EDP quando h, τ → 0.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.4.1",
                            "name": "Enunciar o teorema de convergência de Lax",
                            "description": "Explicar o teorema de Lax-Richtmyer relacionando consistência e estabilidade à convergência em norma adequada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais: Consistência, Estabilidade e Convergência",
                                  "subSteps": [
                                    "Defina consistência: um esquema é consistente se o erro de truncamento local tende a zero quando h e Δt vão a zero.",
                                    "Explique estabilidade: a solução numérica permanece limitada independentemente do número de passos temporais.",
                                    "Descreva convergência: a solução numérica aproxima a solução exata da EDP quando h e Δt → 0.",
                                    "Compare as normas usadas: norma L² ou máxima para convergência.",
                                    "Estude exemplos simples de esquemas consistentes mas instáveis."
                                  ],
                                  "verification": "Escreva definições precisas em um caderno e compare com referências padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula, calculadora.",
                                  "tips": "Use analogias: consistência é 'aproximar bem a equação', estabilidade é 'não explodir'.",
                                  "learningObjective": "Compreender os três pilares do teorema e suas inter-relações.",
                                  "commonMistakes": "Confundir estabilidade com consistência; ignorar dependência em normas específicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Enunciado Preciso do Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Leia o enunciado: Para esquemas lineares consistentes e estáveis em norma adequada, segue convergência na mesma norma.",
                                    "Identifique premissas: lineares, solução exata suave, domínio periódico ou condições adequadas.",
                                    "Analise a equivalência Lax: estabilidade + consistência ⇔ convergência.",
                                    "Memorize a forma matemática: ||e^n|| ≤ C (τ(h) + h^p), onde τ é erro local.",
                                    "Anote variações: teorema de Lax original vs. Richtmyer."
                                  ],
                                  "verification": "Recite o teorema verbalmente e escreva-o sem consultar materiais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo original de Lax (1960) ou resumo em livro-texto, quadro branco.",
                                  "tips": "Divida em partes: premissas → teorema → corolário.",
                                  "learningObjective": "Enunciar o teorema com precisão matemática.",
                                  "commonMistakes": "Omitir 'linearidade' ou especificar norma errada (ex: usar L∞ para L²)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Prova e Condições Necessárias",
                                  "subSteps": [
                                    "Revise esboço da prova: decomposição em erro de truncamento e propagação de erros iniciais.",
                                    "Entenda papel da consistência: controla ||T(u) - L_h u||.",
                                    "Discuta estabilidade via desigualdade de Gårding ou Fourier.",
                                    "Examine contraexemplos: esquema consistente mas instável (ex: upwind invertido).",
                                    "Relacione com norma adequada: mesma norma para todos os termos."
                                  ],
                                  "verification": "Desenhe diagrama da prova e explique cada seta para um colega.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB para simulações simples, referências como Gustafsson et al.",
                                  "tips": "Visualize com análise de Fourier: símbolos de amplificação.",
                                  "learningObjective": "Explicar por que consistência + estabilidade implicam convergência.",
                                  "commonMistakes": "Achar que consistência sozinha basta; ignorar condições de contorno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Enunciação e Aplicação Inicial",
                                  "subSteps": [
                                    "Enuncie o teorema em voz alta três vezes, variando contextos (EDO vs EDP).",
                                    "Aplique a um esquema conhecido: FTCS para equação de advecção.",
                                    "Verifique se é consistente e estável, predizendo convergência.",
                                    "Escreva um parágrafo relacionando os conceitos.",
                                    "Resolva exercício: prove convergência para método explícito de Euler."
                                  ],
                                  "verification": "Grave áudio da enunciação e avalie clareza e precisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exercícios de livro-texto, gravador de voz.",
                                  "tips": "Use mnemônicos: 'CLS' para Consistência, Lax, Stability → Convergence.",
                                  "learningObjective": "Enunciar fluentemente e relacionar à prática.",
                                  "commonMistakes": "Enunciar sem contexto numérico; generalizar demais para não-lineares."
                                }
                              ],
                              "practicalExample": "Considere o esquema FTCS para a equação de calor u_t = u_xx. Verifique consistência (ordem O(h² + Δt)), estabilidade (Δt ≤ h²/2 via von Neumann), logo convergência em norma L² pelo teorema de Lax.",
                              "finalVerifications": [
                                "Enuncie o teorema completo sem erros em menos de 1 minuto.",
                                "Explique relação entre consistência e erro de truncamento.",
                                "Identifique norma adequada para um esquema dado.",
                                "Cite um contraexemplo de falha de convergência.",
                                "Aplique o teorema a um esquema simples verbalmente.",
                                "Descreva implicações para design de esquemas numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado (100% das premissas corretas).",
                                "Compreensão conceitual (explica interdependências).",
                                "Uso correto de terminologia matemática (normas, lineares).",
                                "Capacidade de aplicação a exemplos concretos.",
                                "Identificação de limitações (ex: não-lineares).",
                                "Clareza na comunicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de EDPs em dinâmica de fluidos.",
                                "Ciência da Computação: análise de complexidade e estabilidade algorítmica.",
                                "Engenharia: modelagem numérica em estruturas e controle.",
                                "Estatística: convergência de métodos Monte Carlo para EDPs."
                              ],
                              "realWorldApplication": "Em simulações CFD para previsão de tempo ou aerodinâmica, o teorema guia o design de esquemas numéricos estáveis e consistentes, evitando divergências em previsões críticas como furacões ou fluxos supersônicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.4.2",
                            "name": "Verificar convergência prática de um esquema",
                            "description": "Analisar numericamente a taxa de convergência computando erros em malhas refinadas para uma EDP modelo como a equação de onda 1D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema Modelo e Solução Exata",
                                  "subSteps": [
                                    "Escolha a equação de onda 1D: ∂²u/∂t² = c² ∂²u/∂x² em [0,L] × [0,T].",
                                    "Defina condições de contorno (ex: Dirichlet u(0,t)=u(L,t)=0) e condições iniciais u(x,0)=f(x), ∂u/∂t(x,0)=g(x).",
                                    "Selecione uma solução exata conhecida, como u(x,t) = sin(πx/L) cos(π c t / L) para f(x)=sin(πx/L), g(x)=0.",
                                    "Defina parâmetros: L=1, c=1, T=1.",
                                    "Documente todas as funções e parâmetros em um script ou notebook."
                                  ],
                                  "verification": "Confirme que a solução exata satisfaz a EDP, condições iniciais e de contorno.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notebook Jupyter ou MATLAB/Python script",
                                    "Documentação da equação de onda 1D"
                                  ],
                                  "tips": "Use soluções analíticas simples para evitar complicações numéricas iniciais.",
                                  "learningObjective": "Entender a configuração exata do problema para benchmark numérico.",
                                  "commonMistakes": [
                                    "Escolher solução exata que não satisfaça as condições",
                                    "Ignorar estabilidade CFL no planejamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Esquema de Diferenças Finitas",
                                  "subSteps": [
                                    "Escolha um esquema explícito: u^{n+1}_j = 2(1-r²)u^n_j - u^{n-1}_j + r² (u^n_{j+1} - 2u^n_j + u^n_{j-1}), onde r = c Δt / Δx.",
                                    "Defina malha inicial: N_x pontos em x (Δx = L/N_x), N_t em t (Δt = T/N_t), com r ≤ 1 para estabilidade.",
                                    "Implemente condições iniciais: u^0_j = f(x_j), u^1_j ≈ u^0_j + Δt g(x_j) - (Δt²/2) c² f''(x_j).",
                                    "Codifique em loop temporal, aplicando BCs em cada passo.",
                                    "Teste com uma malha grosseira (N_x=20) para verificar implementação."
                                  ],
                                  "verification": "Compare u numérica em t=T com solução exata em alguns pontos; erro deve ser pequeno.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Referência: livro de diferenças finitas"
                                  ],
                                  "tips": "Use vetores para eficiência; plot u em t=T para visual inspeção.",
                                  "learningObjective": "Implementar corretamente um esquema de segundo ordem para EDP hiperbólica.",
                                  "commonMistakes": [
                                    "Erro na aproximação de u^1",
                                    "Não aplicar BCs corretamente",
                                    "r >1 causando instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Malhas Refinadas e Computar Soluções Aproximadas",
                                  "subSteps": [
                                    "Defina sequência de refinamentos: N_x = 20, 40, 80, 160, 320 (h_k = 1/N_x,k).",
                                    "Ajuste Δt_k = r * h_k com r fixo ≤1 (ex: r=0.9).",
                                    "Para cada h_k, compute solução numérica u_h até t=T.",
                                    "Armazene soluções em arrays ou arquivos para análise.",
                                    "Monitore tempo de computação para notar O(h^{-2}) custo."
                                  ],
                                  "verification": "Todas simulações rodam sem NaNs ou instabilidades.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 2 estendido",
                                    "Espaço de armazenamento para grids"
                                  ],
                                  "tips": "Use loop sobre h_k e salve apenas u_h em t=T para economizar memória.",
                                  "learningObjective": "Executar estudos de convergência com refinamento h-refinement.",
                                  "commonMistakes": [
                                    "Não manter r constante",
                                    "Refinamento insuficiente (poucos níveis)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Erros Numéricos",
                                  "subSteps": [
                                    "Para cada h_k, compute erro em norma L∞: max |u_h(x_j,T) - u(x_j,T)|.",
                                    "Ou norma L2 discreta: sqrt( Δx ∑ (u_h,j(T) - u(x_j,T))^2 ).",
                                    "Gere solução exata na malha h_k: u_exata_j(T).",
                                    "Armazene e_k = erro para cada k.",
                                    "Plote log(e_k) vs log(h_k) para visualização preliminar."
                                  ],
                                  "verification": "Erros diminuem monotonicamente com h_k refinado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy para normas",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Use interp1d se necessário para u exata, mas evite com malha alinhada.",
                                  "learningObjective": "Quantificar precisão numérica via normas de erro.",
                                  "commonMistakes": [
                                    "Erro na computação da norma L2 (esquecer sqrt ou Δx)",
                                    "Comparar em malhas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Estimar e Verificar Taxa de Convergência",
                                  "subSteps": [
                                    "Compute taxas observadas: p_k = log(e_k / e_{k+1}) / log(h_k / h_{k+1}).",
                                    "Verifique se p_k ≈ 2 (ordem teórica do esquema).",
                                    "Plote p_k vs nível de refinamento; deve estabilizar em 2.",
                                    "Analise resíduos ou razões de erro para confirmação.",
                                    "Conclua sobre convergência prática se p_k → ordem teórica."
                                  ],
                                  "verification": "Taxas convergem para valor esperado (≈2); gráfico linear em log-log.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de plotting avançado",
                                    "Referência teórica do esquema"
                                  ],
                                  "tips": "Use pelo menos 4-5 refinamentos para boa estimativa; ignore primeiros se polluição de BC.",
                                  "learningObjective": "Interpretar numericamente a ordem de convergência prática.",
                                  "commonMistakes": [
                                    "Cálculo errado de p_k (inverter h_k)",
                                    "Concluir prematuramente com poucos pontos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u_tt = u_xx em [0,1]×[0,1], u(0,t)=u(1,t)=0, u(x,0)=sin(πx), u_t(x,0)=0. Solução exata: u(x,t)=sin(πx)cos(πt). Use esquema explícito com r=0.9. Refine Δx=1/20,1/40,...,1/320. Compute ||e_h||_∞ em t=1; espere p≈2.",
                              "finalVerifications": [
                                "Erros diminuem com refinamento h.",
                                "Taxas de convergência observadas aproximam-se de 2.",
                                "Plots log-log mostram inclinação ≈2.",
                                "Solução numérica converge visualmente para exata.",
                                "Sem instabilidades em malhas finas.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do esquema (erro <1e-3 em h grosseiro).",
                                "Correta computação de erros e normas.",
                                "Estimativa de p_k com desvio <0.2 do teórico.",
                                "Análise qualitativa e conclusões corretas.",
                                "Eficiência computacional e código limpo.",
                                "Gráficos claros e interpretáveis."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica (NumPy, loops eficientes).",
                                "Física (modelagem de ondas, propagação).",
                                "Estatística (análise de regressão log-log para p).",
                                "Engenharia Computacional (simulações CFD semelhantes)."
                              ],
                              "realWorldApplication": "Verificação de códigos de simulação em engenharia acústica, sísmica ou aeroacústica, garantindo precisão em predições de propagação de ondas antes de aplicações industriais caras."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.4.3",
                            "name": "Relacionar os três pilares: consistência, estabilidade e convergência",
                            "description": "Integrar os conceitos demonstrando como a falta de estabilidade impede convergência mesmo com alta consistência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Definições dos Três Pilares",
                                  "subSteps": [
                                    "Relembrar a definição de consistência: o esquema numérico aproxima a solução exata quando o passo de malha h → 0.",
                                    "Definir estabilidade: o erro de arredondamento e truncamento não amplifica com o número de iterações.",
                                    "Explicar convergência: a solução numérica U_h converge para a solução exata u quando h → 0.",
                                    "Estudar o teorema Lax: convergência ⇔ consistência + estabilidade para problemas lineares bem-postos.",
                                    "Identificar símbolos chave: ||e|| para norma do erro, τ para erro de truncamento."
                                  ],
                                  "verification": "Escrever definições precisas e o teorema Lax em um resumo de 1 página.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre Métodos de Diferenças Finitas",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": "Use analogias: consistência é 'aproximação boa', estabilidade é 'não explode', convergência é 'chega no alvo'.",
                                  "learningObjective": "Compreender precisamente cada pilar e sua interdependência teórica.",
                                  "commonMistakes": [
                                    "Confundir consistência com precisão de máquina",
                                    "Ignorar que estabilidade é condição necessária mas não suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Relação entre Consistência e Convergência",
                                  "subSteps": [
                                    "Implementar um esquema consistente para a equação de calor 1D: u_t = u_xx.",
                                    "Usar esquema explícito com r = α Δt / (Δx)^2 ≤ 0.5 para garantir estabilidade implícita.",
                                    "Simular com h pequeno e observar convergência via norma L2 do erro.",
                                    "Comparar ordem de convergência esperada (O(Δt + Δx^2)) com resultados numéricos.",
                                    "Plotar gráficos de erro vs. h para visualizar taxa de convergência."
                                  ],
                                  "verification": "Gerar plot mostrando erro decrescendo com h, confirmando convergência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB com NumPy/Matplotlib",
                                    "Código base para esquema explícito",
                                    "Solução exata analítica da equação de calor"
                                  ],
                                  "tips": "Comece com condições iniciais simples como Gaussiana para solução conhecida.",
                                  "learningObjective": "Demonstrar que consistência sozinha permite convergência quando estabilidade é satisfeita.",
                                  "commonMistakes": [
                                    "Escolher r > 0.5 inadvertidamente",
                                    "Usar malha não-uniforme sem ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar o Impacto da Falta de Estabilidade",
                                  "subSteps": [
                                    "Modificar o esquema explícito aumentando r > 0.5 (ex: r=1.0) mantendo consistência.",
                                    "Executar simulação longa e observar amplificação oscilatória do erro.",
                                    "Calcular norma do erro em passos iniciais vs. finais para quantificar instabilidade.",
                                    "Comparar com caso estável (r=0.4) no mesmo gráfico de evolução temporal.",
                                    "Explicar amplificação via análise de von Neumann: fator de amplificação |g| >1."
                                  ],
                                  "verification": "Mostrar plot onde solução instável diverge apesar de consistência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mesmo ambiente de programação do Step 2",
                                    "Ferramenta para análise de Fourier discreto (opcional)"
                                  ],
                                  "tips": "Anote valores exatos de r testados e tempo de simulação para reprodutibilidade.",
                                  "learningObjective": "Ilustrar que ausência de estabilidade bloqueia convergência mesmo com alta consistência.",
                                  "commonMistakes": [
                                    "Atribuir falha à consistência em vez de estabilidade",
                                    "Simulações curtas que mascaram instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar os Três Pilares em uma Síntese Conceitual",
                                  "subSteps": [
                                    "Criar diagrama de Venn ou fluxograma mostrando dependências: consistência → convergência só se estável.",
                                    "Escrever parágrafo explicando teorema Lax com contraexemplo do Step 3.",
                                    "Discutir esquemas implícitos (sempre estáveis) como alternativa.",
                                    "Resolver exercício: provar que forward Euler para u' = λu com |λ|Δt >2 é instável.",
                                    "Formular regra geral: verifique consistência (expansão de Taylor), estabilidade (von Neumann), então espere convergência."
                                  ],
                                  "verification": "Produzir diagrama e parágrafo coeso submetido para revisão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou papel)",
                                    "Exercícios de livro-texto"
                                  ],
                                  "tips": "Use setas causais no diagrama: sem estabilidade → NÃO convergência.",
                                  "learningObjective": "Relacionar os pilares holisticamente, priorizando estabilidade como gargalo prático.",
                                  "commonMistakes": [
                                    "Subestimar estabilidade como 'detalhe secundário'",
                                    "Generalizar teorema Lax para não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "No esquema explícito para a equação de calor u_t = u_xx com u(0,x)=sen(πx), u_t=0 nas bordas: com Δx=0.1, Δt=0.005 (r=0.5, estável), erro L2 ~10^-3 após 100 passos; com Δt=0.01 (r=1.0, instável), solução oscila e diverge para valores >10^5, apesar da mesma consistência O(Δt + Δx^2).",
                              "finalVerifications": [
                                "Explicar verbalmente por que estabilidade é necessária para convergência.",
                                "Identificar instabilidade em um esquema dado (ex: forward difference para onda).",
                                "Calcular fator de amplificação para um modo de Fourier dado.",
                                "Plotar exemplo numérico mostrando falha de convergência por instabilidade.",
                                "Citar teorema Lax corretamente com condições.",
                                "Propor correção (ex: esquema implícito) para caso instável."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas e inter-relações claras (30%)",
                                "Evidência numérica: plots e cálculos demonstrando o ponto chave (30%)",
                                "Síntese: diagrama ou explicação integrando pilares (20%)",
                                "Profundidade: menção a ferramentas como von Neumann/Lax (10%)",
                                "Clareza e organização: comunicação acionável (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Estabilidade em simulações de PDEs para fluidos/difusão.",
                                "Ciência da Computação: Análise de algoritmos numéricos e complexidade.",
                                "Engenharia: Validação de modelos CFD (Computational Fluid Dynamics).",
                                "Estatística: Controle de erro em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em previsão numérica do tempo (modelos como WRF), falta de estabilidade em esquemas de advecção causa 'explosões' numéricas, levando a previsões inválidas; engenheiros usam critérios de Courant-Friedrichs-Lewy (CFL) para equilibrar consistência e estabilidade em simulações de ondas sísmicas ou aerodinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Convergência, Consistência e Estabilidade",
                    "description": "Propriedades essenciais: definição, teorema de Lax e análise para métodos de diferenças finitas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Consistência",
                        "description": "Definição de consistência para métodos de diferenças finitas, incluindo a noção de truncagem local e ordem de consistência, essencial para aproximar adequadamente as equações diferenciais parciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir consistência em métodos de diferenças finitas",
                            "description": "Explicar a definição formal de consistência, demonstrando que o erro de truncagem local tende a zero à medida que o passo de malha h e o passo de tempo k vão a zero.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos dos métodos de diferenças finitas",
                                  "subSteps": [
                                    "Explicar o conceito de discretização espacial e temporal em problemas de EDP.",
                                    "Definir os passos de malha h (espacial) e k (temporal).",
                                    "Apresentar um esquema de diferenças finitas genérico para uma EDP parabólica ou hiperbólica.",
                                    "Discutir a aproximação de derivadas parciais por diferenças finitas (ex: centrada, avançada).",
                                    "Identificar os operadores de diferença no esquema."
                                  ],
                                  "verification": "Desenhar e explicar um esquema simples para a equação de calor u_t = u_xx.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para diagramas",
                                    "Notas de aula sobre EDP"
                                  ],
                                  "tips": "Comece com exemplos 1D para simplicidade; visualize a grade espaço-tempo.",
                                  "learningObjective": "Compreender a estrutura básica de um método de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir h (espacial) com k (temporal)",
                                    "Ignorar a ordem de precisão das aproximações de derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o erro de truncagem local (LTE)",
                                  "subSteps": [
                                    "Derivar o erro de truncagem para aproximações de derivadas (ex: Taylor para diferença centrada).",
                                    "Explicar LTE como a diferença entre a EDP contínua e o esquema discreto plugado na solução exata.",
                                    "Calcular LTE para derivadas temporais e espaciais comuns.",
                                    "Mostrar como LTE depende de h e k (ex: O(h^2 + k)).",
                                    "Discutir condições para LTE pequeno."
                                  ],
                                  "verification": "Calcular o LTE para a derivada segunda espacial com diferença centrada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: SymPy)",
                                    "Folhas de exercícios de Taylor",
                                    "Referência: LeVeque 'Finite Difference Methods'"
                                  ],
                                  "tips": "Use expansões de Taylor sistematicamente; anote os termos residuais.",
                                  "learningObjective": "Calcular e interpretar o erro de truncagem local em esquemas FD.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior na expansão de Taylor",
                                    "Não considerar a solução suave necessária"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente a consistência",
                                  "subSteps": [
                                    "Estabelecer a definição: Um esquema é consistente se lim_{h,k→0} LTE = 0 para soluções suaves.",
                                    "Explicar 'tende a zero' independentemente ou com relação h = O(k^m).",
                                    "Discutir a ordem de consistência (ex: consistência de ordem p se LTE = O(h^p + k^q)).",
                                    "Relacionar com a solução exata u exata no esquema.",
                                    "Apresentar notação matemática formal: τ(u; h,k) → 0.",
                                    "Verificar exemplos triviais (método exato é consistente)."
                                  ],
                                  "verification": "Escrever a definição formal e provar para um esquema consistente trivial.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Quadro branco ou software LaTeX",
                                    "Artigos ou slides sobre convergência Lax",
                                    "Exercícios de análise numérica"
                                  ],
                                  "tips": "Memorize: Consistência = LTE → 0; foque na uniformidade em h,k.",
                                  "learningObjective": "Enunciar e justificar a definição formal de consistência.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade",
                                    "Ignorar a necessidade de soluções suaves (C^4)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar consistência em um exemplo prático",
                                  "subSteps": [
                                    "Escolher o método explícito para u_t = α u_xx: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), r=αk/h^2.",
                                    "Calcular LTE usando Taylor na solução exata.",
                                    "Mostrar LTE = [k/2 u_tt - (h^2/12) α u_xxxx + O(k^2 + h^4)] → 0 como h,k→0.",
                                    "Verificar numericamente com valores pequenos de h,k.",
                                    "Discutir implicações para convergência (teorema Lax)."
                                  ],
                                  "verification": "Derivar LTE para o exemplo e concluir consistência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/MATLAB para verificação numérica",
                                    "Papel para derivações",
                                    "Exemplo resolvido de livro-texto"
                                  ],
                                  "tips": "Use solução exata conhecida (ex: gaussiana) para plug-in.",
                                  "learningObjective": "Aplicar a definição para provar consistência em um esquema real.",
                                  "commonMistakes": [
                                    "Erro no cálculo de Taylor para tempo e espaço",
                                    "Não normalizar pelo passo h ou k"
                                  ]
                                }
                              ],
                              "practicalExample": "No método explícito para a equação de calor u_t = u_xx, o esquema é u_j^{n+1} = u_j^n + (k/h^2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n). Expandindo u exata via Taylor, LTE = (k/2) u_tt(j,x_n) - (h^2/12) u_xxxx(j,x_n) + O(k^2 + h^4). Como u_tt = u_xx = u_xxxx (da EDP), LTE = O(k + h^2) → 0 quando h,k → 0, provando consistência.",
                              "finalVerifications": [
                                "Escrever corretamente a definição formal de consistência.",
                                "Calcular LTE para pelo menos um esquema simples.",
                                "Demonstrar lim_{h,k→0} LTE = 0 em um exemplo.",
                                "Explicar o papel da suavidade da solução.",
                                "Diferenciar consistência de estabilidade e convergência.",
                                "Identificar um esquema inconsistente (ex: LTE constante)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição e derivação de LTE (90% correto).",
                                "Clareza na demonstração do limite h,k→0.",
                                "Uso correto de expansões de Taylor sem erros aritméticos.",
                                "Inclusão de ordem de consistência quando aplicável.",
                                "Explicação verbal fluida e exemplos relevantes.",
                                "Identificação de condições necessárias (ex: r fixo)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão e ondas via PDEs.",
                                "Computação: Implementação e análise de erros em códigos numéricos.",
                                "Engenharia: Validação de simulações CFD e finitas diferenças.",
                                "Matemática Aplicada: Teorema Lax-Richtmyer de convergência.",
                                "Estatística: Análise de erros numéricos e truncagem."
                              ],
                              "realWorldApplication": "Garante a confiabilidade de simulações numéricas em previsão do tempo, dinâmica de fluidos computacional (CFD), modelagem financeira (equações parabólicas) e bioengenharia (difusão de fármacos), onde erros de truncagem devem vanishing para precisão preditiva."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Calcular a ordem de consistência",
                            "description": "Derivar e calcular a ordem de consistência de um esquema de diferenças finitas, utilizando expansões de Taylor para estimar o erro de truncagem em equações parabólicas, elípticas ou hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Equação Diferencial Parcial e o Esquema de Diferenças Finitas",
                                  "subSteps": [
                                    "Identifique a PDE alvo (ex: parabólica como u_t = α u_xx, elíptica como ∇²u = f, ou hiperbólica como u_tt = c² u_xx).",
                                    "Especifique os parâmetros da malha: passos espaciais h e temporais k.",
                                    "Descreva o stencil do esquema de diferenças finitas (ex: central para segunda derivada: (u_{j+1} - 2u_j + u_{j-1})/h²).",
                                    "Anote a forma local do esquema: L_h u = 0, onde L_h é o operador discretizado.",
                                    "Verifique se o esquema é explícito ou implícito."
                                  ],
                                  "verification": "Confirme que a PDE e o esquema estão corretamente transcritos e que o stencil corresponde à aproximação pretendida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX",
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Exemplo de PDE padrão"
                                  ],
                                  "tips": "Comece sempre com uma PDE simples como a equação do calor para praticar.",
                                  "learningObjective": "Entender o setup exato do problema para análise de consistência.",
                                  "commonMistakes": "Confundir notação de índices (j para espaço, n para tempo) ou esquecer fatores de normalização como α."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Expansões de Taylor para os Operadores de Diferença",
                                  "subSteps": [
                                    "Expanda u(x + h) = u + h u' + (h²/2) u'' + (h³/6) u''' + O(h⁴).",
                                    "Faça o mesmo para u(x - h), u(t + k), etc., conforme o stencil.",
                                    "Derive operadores diferenciais aproximados: ex: δ²u / h² = u'' + (h²/12) u'''' + O(h⁴).",
                                    "Registre todas as expansões até a ordem desejada (geralmente até O(h³) ou O(h⁴)).",
                                    "Inclua termos mistos para esquemas espaço-tempo (ex: forward difference em tempo)."
                                  ],
                                  "verification": "As expansões de Taylor coincidem com as fórmulas padrão e os coeficientes estão corretos (ex: 1/2 para h²).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy ou Mathematica)",
                                    "Tabela de expansões de Taylor pré-computadas"
                                  ],
                                  "tips": "Use a fórmula geral de Taylor: sum (Δx)^m / m! * D^m u, onde D é derivada.",
                                  "learningObjective": "Dominar a expansão de Taylor multivariable para aproximações finitas.",
                                  "commonMistakes": "Esquecer termos pares/impares ou sinal errado em expansões simétricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir Expansões no Esquema Discretizado",
                                  "subSteps": [
                                    "Substitua as expansões de Taylor no operador L_h u.",
                                    "Expanda completamente L_h u em série: L_h u = sum c_m D^m u + O(h^p).",
                                    "Colete termos por ordem de h e k (ex: termos O(1), O(h), O(h²)).",
                                    "Simplifique expressões algébricas para isolar operadores diferenciais.",
                                    "Verifique consistência de ordens espaço e tempo."
                                  ],
                                  "verification": "O resultado é uma série assintótica em potências de h e k sem erros de cálculo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de cálculo ou software simbólico",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Agrupe termos por derivadas para facilitar comparação com a PDE.",
                                  "learningObjective": "Aplicar expansões para obter a forma assintótica do esquema.",
                                  "commonMistakes": "Erros aritméticos em coeficientes ou perda de termos de alta ordem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com a PDE Original e Identificar o Erro de Truncagem",
                                  "subSteps": [
                                    "Escreva a PDE como L u = 0, onde L é o operador diferencial exato.",
                                    "Subtraia: τ = L_h u - L u, onde τ é o erro de truncagem local.",
                                    "Identifique os termos líderes em τ (ex: τ = O(h² + k)).",
                                    "Expresse τ em termos das derivadas de u (ex: (k/2) u_tt - (h²/12) u_xxxx).",
                                    "Confirme que τ → 0 quando h,k → 0."
                                  ],
                                  "verification": "τ possui apenas termos de ordem positiva em h e k.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas dos passos anteriores",
                                    "Definção formal de consistência"
                                  ],
                                  "tips": "Lembre-se: consistência requer τ = o(1), ordem p se τ = O(h^p).",
                                  "learningObjective": "Calcular explicitamente o erro de truncagem τ.",
                                  "commonMistakes": "Confundir L_h u com L u ou inverter o sinal de τ."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Determinar e Verificar a Ordem de Consistência",
                                  "subSteps": [
                                    "Identifique o menor expoente p tal que τ = O(h^p + k^q), com p,q ≥1.",
                                    "Para esquemas uniformes, defina ordem global como min(p,q) ajustado por r = k/h².",
                                    "Teste com PDEs específicas: parabólica (heat), elíptica (Poisson), hiperbólica (wave).",
                                    "Documente a ordem: ex: ordem 2 em espaço, 1 em tempo.",
                                    "Verifique numericamente com uma solução exata suave."
                                  ],
                                  "verification": "A ordem calculada corresponde a literatura padrão para o esquema.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para verificação numérica",
                                    "Tabelas de ordens conhecidas"
                                  ],
                                  "tips": "Para esquemas padrão como FTCS, espere ordem 2 em h, 1 em k.",
                                  "learningObjective": "Extrair a ordem p da expressão de τ.",
                                  "commonMistakes": "Ignorar relação k ~ h² em análises parabólicas."
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = u_xx com esquema FTCS: (u_j^{n+1} - u_j^n)/k - (u_{j+1}^n - 2u_j^n + u_{j-1}^n)/h² = 0. Expansões dão τ = (k/2) u_tt - (h²/12) u_xxxx + O(k² + h⁴ + k h²), ordem 1 em tempo e 2 em espaço.",
                              "finalVerifications": [
                                "Expansões de Taylor estão corretas até ordem suficiente.",
                                "Erro de truncagem τ é identificado e expresso em derivadas.",
                                "Ordem de consistência é explicitamente declarada (ex: O(h² + k)).",
                                "Verificação numérica confirma que ||τ|| diminui com h,k.",
                                "Análise funciona para pelo menos duas classes de PDEs (parabólica e elíptica).",
                                "Documentação inclui stencil, τ e ordem p."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expansões de Taylor (coeficientes exatos).",
                                "Correta derivação de τ sem erros algébricos.",
                                "Identificação precisa da ordem de truncagem líder.",
                                "Explicação clara da relação com tipos de PDE.",
                                "Uso apropriado de notação matemática consistente.",
                                "Inclusão de verificação numérica ou analítica.",
                                "Profundidade: análise para múltiplos esquemas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão e ondas em simulações numéricas.",
                                "Computação: Implementação de solvers em Python (NumPy/SciPy).",
                                "Engenharia: Análise de erros em CFD e simulações estruturais.",
                                "Estatística: Estimação de erros em métodos Monte Carlo.",
                                "Economia: Modelos de precificação de opções com diferenças finitas."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de fluidos (CFD), calcular a ordem de consistência garante precisão em previsões meteorológicas ou design aerodinâmico, otimizando malhas computacionais para reduzir tempo de simulação sem perda de acurácia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Verificar consistência para esquemas simples",
                            "description": "Analisar a consistência de métodos explícitos e implícitos para equações de difusão (parabólicas) e onda (hiperbólicas), identificando condições sobre h e k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de consistência em métodos de diferenças finitas",
                                  "subSteps": [
                                    "Estude a definição de consistência de Lax: um esquema é consistente se o operador de truncamento τ(h,k) → 0 quando h → 0 e k → 0.",
                                    "Revise expansões de Taylor para aproximações de diferenças finitas em derivadas parciais (tempo e espaço).",
                                    "Identifique os termos de erro local de truncamento para esquemas forward, backward e central.",
                                    "Pratique derivando τ para uma equação modelo simples como u_t = u_xx.",
                                    "Discuta a relação entre consistência, convergência e estabilidade."
                                  ],
                                  "verification": "Derive corretamente o operador de truncamento τ para o esquema forward Euler em uma PDE parabólica simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque ou Quarteroni)",
                                    "Folha de papel ou software como Mathematica para expansões Taylor",
                                    "Notas de aula sobre diferenças finitas"
                                  ],
                                  "tips": "Sempre normalize pelo operador L; foque nos termos de ordem mais baixa no erro.",
                                  "learningObjective": "Dominar a definição matemática de consistência e como computar erros de truncamento locais.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade",
                                    "Esquecer de dividir pelo operador diferencial L no τ",
                                    "Ignorar condições de h e k indo a zero independentemente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar consistência para esquemas explícito e implícito na equação de difusão (parabólica)",
                                  "subSteps": [
                                    "Escreva o esquema explícito: u_i^{n+1} = u_i^n + (k/h^2)(u_{i-1}^n - 2u_i^n + u_{i+1}^n) para u_t = u_xx.",
                                    "Aplique expansões Taylor em torno de (x_i, t_n) para derivar o erro de truncamento τ = O(k + h^2).",
                                    "Repita para o esquema implícito: resolva o sistema tridiagonal e derive τ = O(k + h^2).",
                                    "Analise condições: consistência requer h → 0, k → 0 com k/h^2 → r finito (não restritivo para consistência).",
                                    "Compare os erros: ambos consistentes de ordem 1 em tempo e 2 em espaço."
                                  ],
                                  "verification": "Mostre que τ → 0 à medida que h,k → 0 para ambos esquemas, citando as ordens de erro.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Caderno para cálculos",
                                    "Software como Python/MATLAB para verificar numericamente Taylor",
                                    "Exemplos de código de diferenças finitas"
                                  ],
                                  "tips": "Use a notação δ_t u = (u^{n+1} - u^n)/k e δ_xx u = (u_{i-1} - 2u_i + u_{i+1})/h^2.",
                                  "learningObjective": "Aplicar a definição para verificar consistência em esquemas parabólicos simples.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior nas expansões",
                                    "Confundir r = k/h^2 com condição de estabilidade (CFL)",
                                    "Não considerar o esquema implícito como consistente apesar de não-local"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar consistência para esquemas na equação de onda (hiperbólica)",
                                  "subSteps": [
                                    "Escreva o esquema central explícito: u_i^{n+1} = 2u_i^n - u_i^{n-1} + (c k / h)^2 (u_{i-1}^n - 2u_i^n + u_{i+1}^n) para u_tt = c^2 u_xx.",
                                    "Derive expansões Taylor para o operador em tempo segunda derivada e espaço.",
                                    "Mostre τ = O(k^2 + h^2), confirmando consistência quando h,k → 0.",
                                    "Discuta variantes implícitas e condições gerais: λ = c k / h finito não afeta consistência.",
                                    "Verifique numericamente com uma solução exata conhecida (ex: d'Alembert)."
                                  ],
                                  "verification": "Derive explicitamente τ para o esquema de onda e prove que tende a zero.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou similar)",
                                    "Gráficos de soluções exatas vs numéricas",
                                    "Referências sobre PDEs hiperbólicas"
                                  ],
                                  "tips": "A segunda derivada em tempo requer Taylor em t^{n+1} e t^{n-1} simetricamente.",
                                  "learningObjective": "Analisar consistência em esquemas para equações hiperbólicas.",
                                  "commonMistakes": [
                                    "Usar aproximação first-order em tempo para onda",
                                    "Confundir λ com estabilidade (CFL ≤1)",
                                    "Ignorar paridade em tempo para derivadas pares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar condições gerais sobre h e k para consistência e sintetizar resultados",
                                  "subSteps": [
                                    "Resuma condições: para todos esquemas simples, consistência holds se h → 0, k → 0 independentemente (ordem positiva no erro).",
                                    "Compare parabólicos vs hiperbólicos: ambos O(k + h^2) ou melhor.",
                                    "Discuta impacto de r = k/h^2 ou λ = c k/h: irrelevante para consistência, mas crítico para estabilidade.",
                                    "Crie uma tabela comparativa de τ para explícito/implícito em ambos tipos.",
                                    "Teste com h=k=10^{-m} para m=1,2,3 e observe ||τ|| → 0."
                                  ],
                                  "verification": "Produza uma tabela ou gráfico mostrando τ → 0 para diferentes h,k.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para tabelas",
                                    "Código de verificação numérica"
                                  ],
                                  "tips": "Sempre especifique a norma usada para τ → 0 (ex: máximo local).",
                                  "learningObjective": "Sintetizar condições sobre malha para garantir consistência.",
                                  "commonMistakes": [
                                    "Impor condições de estabilidade como necessárias para consistência",
                                    "Não distinguir truncamento local vs global"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de difusão u_t = u_xx em [0,1]x[0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx), use esquema explícito com h=0.1, k=0.001 (r=0.1). Solução exata u(x,t)=sin(πx)exp(-π^2 t). Compute τ em um ponto interno e verifique |τ| < 10^{-3}, confirmando consistência ao refinar malha.",
                              "finalVerifications": [
                                "Derivação correta de τ para esquemas explícito e implícito em difusão.",
                                "Cálculo de τ para esquema de onda central.",
                                "Identificação precisa de ordens de erro (O(k + h^2)).",
                                "Condições corretas: h,k → 0 sem restrições em r ou λ para consistência.",
                                "Tabela ou gráfico numérico mostrando τ → 0.",
                                "Diferenciação clara entre consistência e estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de expansões Taylor (sem erros algébricos).",
                                "Correta identificação de termos dominantes no erro de truncamento.",
                                "Análise qualitativa/quantitativa das condições sobre h e k.",
                                "Uso apropriado de notação matemática (δ_t, δ_xx, etc.).",
                                "Capacidade de generalizar para esquemas similares.",
                                "Clareza na explicação de exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de propagação de calor (difusão) e ondas acústicas/seismicas.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações em CFD para escoamentos viscosos ou elásticos.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, verificar consistência garante que modelos numéricos de difusão de umidade ou propagação de ondas sonoras aproximem fielmente a física contínua ao refinar grades espaciais/temporais, essencial para previsões precisas em supercomputadores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Estabilidade",
                        "description": "Conceito de estabilidade em métodos de diferenças finitas, incluindo análise de Von Neumann, condições CFL e noções de dissipação e dispersão para esquemas em equações diferenciais parciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Definir estabilidade e demonstrar sua importância",
                            "description": "Explicar a definição de estabilidade (GKS ou L2), diferenciando estabilidade numérica de consistência e ilustrando com exemplos de instabilidade em métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estabilidade numérica formalmente (GKS e L2)",
                                  "subSteps": [
                                    "Estude a definição de estabilidade de GKS: uma família de operadores de aproximação é estável se existe uma constante K independente de h tal que ||S(h,t)|| <= K para todo t.",
                                    "Aprenda a definição de estabilidade em norma L2: sup_{t} ||e(t)||_2 <= K sup_{s<=t} ||f(s)||_2 para a solução do problema inicial.",
                                    "Compare as duas definições, notando que GKS é mais geral para normas fortes, enquanto L2 é comum em análise de Fourier para diferenças finitas.",
                                    "Derive a condição de estabilidade usando análise de von Neumann para esquemas lineares constantes.",
                                    "Resolva exercícios simples de verificação de estabilidade para operadores diferenciais aproximados."
                                  ],
                                  "verification": "Escreva as definições exatas de GKS e L2 estabilidade e aplique a análise de von Neumann a um esquema simples, confirmando se é estável.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Livro de análise numérica (e.g., LeVeque ou Strikwerda)",
                                    "Notas de aula sobre diferenças finitas",
                                    "Software MATLAB/Python para análise simbólica"
                                  ],
                                  "tips": "Use símbolos LaTeX para anotações precisas; foque na independência de h e t nas constantes.",
                                  "learningObjective": "Compreender as definições formais de estabilidade e suas implicações para esquemas numéricos.",
                                  "commonMistakes": "Confundir estabilidade com acurácia; esquecer que K deve ser independente do tamanho da malha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar estabilidade numérica de consistência",
                                  "subSteps": [
                                    "Revise a definição de consistência: lim_{h->0} ||L_h u - L u|| = 0, onde L_h é o operador discreto.",
                                    "Explique que consistência garante que o esquema aproxima a PDE, mas sem estabilidade, soluções explodem.",
                                    "Estude o Teorema de Lax: para problemas bem-postos lineares, convergência <=> consistência + estabilidade.",
                                    "Crie uma tabela comparativa: estabilidade (controle de erros de arredondamento/propagação), consistência (aproximação local).",
                                    "Discuta exemplos onde consistência existe mas falta estabilidade."
                                  ],
                                  "verification": "Redija um parágrafo explicando a diferença e prove o Teorema de Lax para um caso linear simples.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Teorema de Lax em notas ou livro-texto",
                                    "Papel e caneta para derivações",
                                    "Vídeos online sobre teorema de equivalência GKS"
                                  ],
                                  "tips": "Lembre-se: consistência é 'local', estabilidade é 'global' no tempo.",
                                  "learningObjective": "Distinguir claramente estabilidade de consistência e entender sua interdependência para convergência.",
                                  "commonMistakes": "Achar que consistência implica estabilidade; ignorar o papel dos dados iniciais no teorema de Lax."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ilustrar instabilidade em métodos explícitos",
                                  "subSteps": [
                                    "Implemente o esquema FTCS explícito para a equação de calor u_t = u_xx e rode simulações com Δt > (Δx)^2 / 2.",
                                    "Observe oscilações e blow-up numérico, calculando o fator de amplificação via análise de von Neumann: |g| = |1 + i k Δt - (k Δx)^2 Δt / 2| >1 para modos altos.",
                                    "Compare com o esquema implícito backward Euler, que é incondicionalmente estável.",
                                    "Teste upwind explícito para equação de advecção u_t + u_x =0, mostrando instabilidade para CFL >1.",
                                    "Gere gráficos de soluções instáveis vs estáveis para diferentes parâmetros."
                                  ],
                                  "verification": "Produza plots mostrando blow-up em método explícito e explique o fator de amplificação >1.",
                                  "estimatedTime": "3-4 hours",
                                  "materials": [
                                    "Python/MATLAB com NumPy/Matplotlib",
                                    "Código template para esquemas de diferenças finitas",
                                    "Artigos sobre condições CFL"
                                  ],
                                  "tips": "Comece com malhas grosseiras para ver instabilidade rapidamente; use log-scale para erros.",
                                  "learningObjective": "Identificar e reproduzir numericamente exemplos de instabilidade em métodos explícitos comuns.",
                                  "commonMistakes": "Usar passos de tempo muito pequenos que mascaram instabilidade; confundir erro de truncamento com instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a importância da estabilidade",
                                  "subSteps": [
                                    "Analise como falta de estabilidade amplifica erros de arredondamento em simulações longas.",
                                    "Discuta impacto em problemas reais: simulações climáticas falham sem estabilidade.",
                                    "Conecte à convergência: prove que sem estabilidade, mesmo esquema consistente diverge.",
                                    "Explore estratégias de estabilização: upwinding, implicitos, filtros.",
                                    "Resuma com um fluxograma: consistência + estabilidade -> convergência."
                                  ],
                                  "verification": "Escreva um relatório curto (1 página) ilustrando por que estabilidade é crucial, com referências aos exemplos anteriores.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Exemplos computacionais do step 3",
                                    "Referências bibliográficas (GKS original)",
                                    "Ferramenta de escrita LaTeX"
                                  ],
                                  "tips": "Use analogia: consistência é 'direção certa', estabilidade é 'não capotar'.",
                                  "learningObjective": "Demonstrar por que estabilidade é essencial para confiabilidade numérica.",
                                  "commonMistakes": "Subestimar erros de máquina; focar só em teoria sem ligação prática."
                                }
                              ],
                              "practicalExample": "Implemente o esquema FTCS explícito para u_t = u_xx em [0,1]x[0,10] com u(0,x)=sin(πx), Δx=0.1. Com Δt=0.01 (estável), solução converge; com Δt=0.06 (instável), oscilações crescem exponencialmente, demonstrando blow-up.",
                              "finalVerifications": [
                                "Defina corretamente GKS e L2 estabilidade com notação precisa.",
                                "Explique a diferença entre estabilidade e consistência com o Teorema de Lax.",
                                "Gere plots numéricos mostrando instabilidade em método explícito.",
                                "Identifique fator de amplificação >1 em análise de von Neumann.",
                                "Descreva 3 consequências práticas da falta de estabilidade.",
                                "Prove convergência para um esquema estável e consistente."
                              ],
                              "assessmentCriteria": [
                                "Precisão das definições formais (GKS/L2): 25%.",
                                "Clareza na diferenciação estabilidade vs consistência: 20%.",
                                "Qualidade dos exemplos numéricos e plots: 25%.",
                                "Análise correta de fatores de amplificação: 15%.",
                                "Demonstração da importância com argumentos lógicos: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de difusão/ondas (equações de calor/onda).",
                                "Computação: Análise de complexidade e estabilidade em algoritmos numéricos.",
                                "Engenharia: Aplicações em CFD e controle de sistemas dinâmicos.",
                                "Estatística: Controle de variância em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM), esquemas instáveis causam previsões erráticas devido a amplificação de perturbações; estabilidade garante simulações confiáveis por décadas de tempo simulado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Aplicar análise de Von Neumann para estabilidade",
                            "description": "Realizar análise de amplificação de Fourier (Von Neumann) para esquemas em equações parabólicas e hiperbólicas, determinando regiões de estabilidade absoluta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise de Von Neumann",
                                  "subSteps": [
                                    "Estude o método de Von Neumann: assume solução sob a forma de onda de Fourier e analisa o fator de amplificação.",
                                    "Revise a equação parabólica (ex: equação de calor) e hiperbólica (ex: equação de onda ou advecção).",
                                    "Entenda o conceito de estabilidade absoluta: |g(k)| ≤ 1 para todos os números de onda k.",
                                    "Pratique derivando a forma discreta geral de um esquema de diferenças finitas.",
                                    "Identifique o símbolo de Fourier e o operador de diferença central/avanço."
                                  ],
                                  "verification": "Derive corretamente o fator de amplificação g(θ) para um esquema simples como FTCS na equação de calor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Comece com esquemas 1D simples para construir intuição antes de generalizar.",
                                  "learningObjective": "Compreender os princípios teóricos da análise de Von Neumann e sua aplicação em esquemas lineares.",
                                  "commonMistakes": "Confundir fator de amplificação com erro de truncamento; ignorar a dependência em kΔx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Análise a Esquemas Parabólicos",
                                  "subSteps": [
                                    "Escolha um esquema explícito para a equação de calor: u_t = α u_xx.",
                                    "Substitua a solução Fourier u_j^n = g^n e^{i k j Δx} na discretização.",
                                    "Calcule o fator de amplificação g(θ) onde θ = k Δx.",
                                    "Determine a condição |g(θ)| ≤ 1 para todos θ, obtendo r ≤ 1/2 para FTCS.",
                                    "Plote |g(θ)| vs θ para visualizar a região de estabilidade."
                                  ],
                                  "verification": "Obtenha a região de estabilidade r ≤ 1/2 e confirme com gráfico sem amplificação >1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB para plotar |g(θ)|, papel para derivações manuais.",
                                  "tips": "Use expansão em série de Taylor para verificar consistência antes da estabilidade.",
                                  "learningObjective": "Executar análise completa para esquemas parabólicos e identificar condições de estabilidade.",
                                  "commonMistakes": "Esquecer o termo imaginário em esquemas implícitos; não normalizar θ de 0 a π."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Análise a Esquemas Hiperbólicos",
                                  "subSteps": [
                                    "Selecione equação de advecção u_t + c u_x = 0 com esquema upwind.",
                                    "Insira a forma de Fourier e isole g(θ) = 1 - λ (1 - e^{-iθ}) para upwind.",
                                    "Calcule |g(θ)|^2 e encontre a condição de estabilidade λ ≤ 1.",
                                    "Compare com esquemas Lax-Friedrichs ou Lax-Wendroff.",
                                    "Analise neutralidade numérica e dissipação numérica via Re(g) e Im(g)."
                                  ],
                                  "verification": "Derive corretamente λ ≤ 1 para upwind e plote o círculo unitário no plano complexo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de plotagem complexa (MATLAB complex plot), referências como Strikwerda.",
                                  "tips": "Represente g no plano complexo: estabilidade requer g dentro do círculo unitário.",
                                  "learningObjective": "Dominar análise para equações hiperbólicas, destacando diferenças com parabólicas.",
                                  "commonMistakes": "Assumir c=1 sem generalizar; confundir advecção com onda bidirecional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Comparar Regiões de Estabilidade",
                                  "subSteps": [
                                    "Compile regiões de estabilidade para múltiplos esquemas (explícito, implícito, Crank-Nicolson).",
                                    "Use o método de polígono para esquemas multi-estágio.",
                                    "Compare estabilidade absoluta vs condicional.",
                                    "Teste numericamente um esquema instável vs estável em código simples.",
                                    "Documente limitações da análise de Von Neumann (linearidade, periodicidade)."
                                  ],
                                  "verification": "Crie tabela comparativa de regiões de estabilidade e rode simulação estável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python (NumPy/SciPy para simulações 1D), tabela em LaTeX ou Excel.",
                                  "tips": "Sempre verifique com CFL condition para hiperbólicas.",
                                  "learningObjective": "Interpretar resultados da análise e conectá-los a escolhas práticas de esquemas.",
                                  "commonMistakes": "Ignorar von Neumann para esquemas não-lineares; superestimar estabilidade absoluta."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação Final e Extensões",
                                  "subSteps": [
                                    "Aplique a uma equação combinada (parab+hiperb como Burgers linearizada).",
                                    "Analise esquemas em 2D reduzindo via Fourier separável.",
                                    "Implemente função genérica para análise em código.",
                                    "Discuta alternativas como análise de energia para não-lineares.",
                                    "Resolva exercícios de livros-textos para prática."
                                  ],
                                  "verification": "Implemente código que plota auto-região de estabilidade para esquema dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Jupyter Notebook, problemas de livros (ex: Gustafsson).",
                                  "tips": "Automatize derivações com sympy para eficiência.",
                                  "learningObjective": "Generalizar a análise e preparar para aplicações avançadas.",
                                  "commonMistakes": "Não testar numericamente as previsões teóricas."
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx com esquema FTCS: g(θ) = 1 - 4r sin²(θ/2). Estabilidade requer |g|≤1 ⇒ r≤1/2. Simule com r=0.4 (estável, oscilações mínimas) vs r=0.6 (instável, blow-up).",
                              "finalVerifications": [
                                "Deriva fator g(θ) corretamente para FTCS parabólico e upwind hiperbólico.",
                                "Identifica regiões de estabilidade absoluta (ex: r≤1/2, λ≤1).",
                                "Plota |g(θ)| e confirma ausência de amplificação >1.",
                                "Compara esquemas via plano complexo.",
                                "Implementa simulação numérica validando teoria.",
                                "Explica limitações (linearidade requerida)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação simbólica de g(θ) (90% correto).",
                                "Correta identificação de condições de estabilidade.",
                                "Qualidade de gráficos e interpretação visual.",
                                "Implementação numérica sem erros de programação.",
                                "Análise comparativa de pelo menos 3 esquemas.",
                                "Clareza na documentação de passos e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão (calor) e ondas (acústica).",
                                "Computação: Programação numérica em Python/MATLAB para PDEs.",
                                "Engenharia: Simulações CFD em aerodinâmica.",
                                "Estatística: Análise de erro e convergência em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos hiperbólicos para advecção de umidade) e térmicas (parabólicas para transferência de calor em reatores nucleares), garantindo simulações estáveis sem blow-up numérico."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Analisar dissipação e dispersão",
                            "description": "Identificar e quantificar erros de dissipação (amortecimento artificial) e dispersão (fases erradas) em esquemas de diferenças finitas para equações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de dissipação e dispersão",
                                  "subSteps": [
                                    "Defina dissipação como o amortecimento artificial de componentes de alta frequência na solução numérica.",
                                    "Defina dispersão como o erro de fase que faz ondas de diferentes frequências propagarem em velocidades diferentes.",
                                    "Revise a equação hiperbólica modelo, como a equação de advecção u_t + a u_x = 0.",
                                    "Explique o papel da análise de von Neumann na detecção desses erros.",
                                    "Compare com comportamento exato: |G| = 1 (sem dissipação) e arg(G) = -a k Δt (sem dispersão)."
                                  ],
                                  "verification": "Resuma as definições em um parágrafo e liste 3 diferenças entre dissipação e dispersão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula sobre von Neumann.",
                                  "tips": "Use diagramas de ondas para visualizar: dissipação apaga picos, dispersão espalha o pacote de onda.",
                                  "learningObjective": "Distinguir conceitualmente dissipação e dispersão em esquemas hiperbólicos.",
                                  "commonMistakes": "Confundir dissipação com difusão física real ou dispersão com não-linearidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise de von Neumann para esquemas de diferenças finitas",
                                  "subSteps": [
                                    "Assuma solução plano u_j^n = g^n e^{i k j Δx} e derive o símbolo de amplificação G(k Δx).",
                                    "Calcule G para esquemas upwind e Lax-Friedrichs.",
                                    "Plote |G(θ)| onde θ = k Δx para θ ∈ [0, π].",
                                    "Analise arg(G(θ)) e compare com a fase exata -a Δt sin(θ)/Δx.",
                                    "Identifique regiões onde |G| < 1 (dissipação) ou arg(G) ≠ fase exata (dispersão)."
                                  ],
                                  "verification": "Gere plots de |G| e arg(G) - fase exata para um esquema e anote anomalias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com NumPy/Matplotlib, papel e lápis para derivações.",
                                  "tips": "Normalize Δx=1, varie CFL = a Δt / Δx para ver dependência.",
                                  "learningObjective": "Derivar e interpretar o símbolo de amplificação G(θ).",
                                  "commonMistakes": "Esquecer o fator e^{i k (j+1) Δx} na stencil ou normalizar incorretamente θ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Quantificar erros de dissipação e dispersão",
                                  "subSteps": [
                                    "Calcule taxa de dissipação: 1 - |G(θ)| por timestep.",
                                    "Meça erro de dispersão: |arg(G(θ)) + a Δt sin(θ)/Δx|.",
                                    "Integre erros sobre espectro de frequências para norma L2.",
                                    "Compare esquemas: upwind (dissipativo), Lax-Wendroff (dispersivo).",
                                    "Ajuste parâmetros (CFL) para minimizar erros em faixas específicas."
                                  ],
                                  "verification": "Tabela com erros numéricos para 3 esquemas e 2 valores de CFL.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de plotagem, calculadora simbólica (SymPy).",
                                  "tips": "Foque em θ próximo a π para modos oscilatórios problemáticos.",
                                  "learningObjective": "Quantificar numericamente dissipação e dispersão via métricas.",
                                  "commonMistakes": "Usar |G| médio em vez de ponderado por energia do sinal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar análise a um esquema específico e interpretar resultados",
                                  "subSteps": [
                                    "Escolha esquema Lax-Wendroff para equação de onda 1D.",
                                    "Derive G(θ) explicitamente: G = A - (CFL^2/2)(1 - cosθ)(1 + i CFL sinθ).",
                                    "Plote curvas de dissipação/dispersão vs. θ e CFL.",
                                    "Interprete: regiões de super-dissipação ou dispersão leading/trailing.",
                                    "Proponha melhorias como filtros ou esquemas higher-order."
                                  ],
                                  "verification": "Relatório de 1 página com plots, cálculos e conclusões.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código Jupyter notebook pronto para análise von Neumann.",
                                  "tips": "Valide G com limite θ→0: deve recuperar exato.",
                                  "learningObjective": "Aplicar e interpretar análise completa em esquema real.",
                                  "commonMistakes": "Erro de sinal na fase ou ignorar dependência CFL."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com simulações numéricas",
                                  "subSteps": [
                                    "Implemente esquema em código e rode para pulso gaussiano.",
                                    "Compare solução numérica com exata: meça atenuação e espalhamento.",
                                    "Correlacione com análise von Neumann: alta freq. dissipadas?",
                                    "Ajuste grid/CFL e reavalie.",
                                    "Documente concordância qualitativa/quantitativa."
                                  ],
                                  "verification": "Plots lado-a-lado numérico vs. analítico de erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python para solver hiperbólico 1D.",
                                  "tips": "Use sinal com múltiplas frequências para ver dispersão.",
                                  "learningObjective": "Conectar teoria von Neumann com prática computacional.",
                                  "commonMistakes": "Boundary conditions ruins mascarando erros internos."
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Wendroff na equação de advecção u_t + u_x = 0 com CFL=0.9: derive G(θ) = 1 - (0.9^2/2)(1-cosθ)(1 + i 0.9 sinθ / sin(θ/2) approx), plote |G|<1 para θ>π/2 (dissipação) e arg(G) atrasado (dispersão leading).",
                              "finalVerifications": [
                                "Plots corretos de |G(θ)| ≤1 com dissipação em altas frequências.",
                                "Curva de fase arg(G) coincidente com exata em baixas k, desviando em altas.",
                                "Tabela quantitativa de erros de dissipação/dispersão por esquema.",
                                "Interpretação verbal precisa dos erros identificados.",
                                "Validação via simulação numérica mostrando atenuação/espalhamento previsto.",
                                "Sugestões de mitigação baseadas na análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do símbolo G(θ) (fórmula exata).",
                                "Qualidade dos plots e identificação visual de anomalias.",
                                "Correção quantitativa de métricas de erro.",
                                "Profundidade da interpretação física/matemática.",
                                "Conexão coerente entre teoria e simulação prática.",
                                "Clareza e completude do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação sísmica.",
                                "Engenharia: Simulações CFD para fluxos compressíveis.",
                                "Computação: Otimização de algoritmos numéricos paralelos.",
                                "Matemática Aplicada: Análise de Fourier em PDEs."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, análise de dissipação/dispersão garante precisão na propagação de ondas P/S sem artefatos numéricos que levem a falsos reservatórios; em CFD aeroespacial, minimiza erros em choques para design seguro de aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.4",
                            "name": "Verificar estabilidade em métodos ADI e condições de contorno",
                            "description": "Examinar estabilidade do método ADI para equações parabólicas bidimensionais e condições de Dirichlet/Neumann em problemas elípticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos do método ADI e condições de contorno",
                                  "subSteps": [
                                    "Estudar a formulação do método ADI para a equação do calor 2D: u_t = α (u_xx + u_yy).",
                                    "Derivar as etapas alternadas: sweep em x e depois em y.",
                                    "Explicar condições de contorno Dirichlet (valor fixo) e Neumann (derivada fixa) para problemas elípticos como Poisson.",
                                    "Implementar um stencil simples de diferenças finitas para visualização.",
                                    "Comparar com métodos explícitos como FTCS para destacar vantagens implícitas."
                                  ],
                                  "verification": "Resumir em um diagrama o ciclo ADI e listar diferenças entre Dirichlet e Neumann.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), notebook Jupyter com Python/NumPy.",
                                  "tips": "Desenhe grades 2D para visualizar sweeps alternados.",
                                  "learningObjective": "Compreender a estrutura algébrica do ADI e impacto das condições de contorno.",
                                  "commonMistakes": "Confundir sweeps ADI com Crank-Nicolson unidirecional; ignorar periodicidade nas condições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise de estabilidade para ADI em equações parabólicas",
                                  "subSteps": [
                                    "Aplicar análise von Neumann: assumir solução plano-onda e calcular fator de amplificação G.",
                                    "Derivar condição de estabilidade incondicional do ADI para r = α Δt / Δx² > 0.",
                                    "Analisar eigenvalues da matriz tridiagonal nas sweeps x e y.",
                                    "Testar numericamente com diferentes r, observando crescimento de erros.",
                                    "Comparar com métodos explícitos (CFL r ≤ 1/4)."
                                  ],
                                  "verification": "Plotar |G| vs. wavenumbers e confirmar |G| ≤ 1 para todos os modos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB ou Python (SciPy para eigenvalues), exemplos de código de estabilidade.",
                                  "tips": "Use Fourier transform discreta para validar von Neumann numericamente.",
                                  "learningObjective": "Derivar e verificar critério de estabilidade incondicional do ADI.",
                                  "commonMistakes": "Esquecer termos cross-derivadas na linearização; assumir estabilidade sem checar altos frequências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar impacto de condições de contorno Dirichlet/Neumann em elípticos",
                                  "subSteps": [
                                    "Formular problema elíptico: ∇²u = f com Dirichlet (u= g na borda) ou Neumann (∂u/∂n = h).",
                                    "Construir matriz de diferenças finitas e analisar condicionamento/estabilidade.",
                                    "Usar ADI para elípticos (Peaceman-Rachford) e derivar condições de convergência.",
                                    "Simular com grids não-uniformes para testar robustez das condições.",
                                    "Calcular norma da solução e residual para diferentes tipos de bordas."
                                  ],
                                  "verification": "Resolver sistema e checar se ||Au - b|| < 1e-6 e monotonicidade da solução.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código Python com solvers iterativos (SOR ou GMRES), grids de teste.",
                                  "tips": "Para Neumann, adicione equação de compatibilidade ∫h ds = ∫f dV.",
                                  "learningObjective": "Avaliar como Dirichlet/Neumann afetam estabilidade e precisão em elípticos.",
                                  "commonMistakes": "Violar compatibilidade em Neumann levando a singularidade; usar stencil central na borda."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e verificar estabilidade integrada",
                                  "subSteps": [
                                    "Codificar ADI completo para calor 2D com mistas Dirichlet/Neumann.",
                                    "Executar testes de estabilidade: variar Δt, Δx e plotar erros L2 vs. tempo.",
                                    "Analisar sensibilidade a condições de contorno alterando-as.",
                                    "Otimizar parâmetros e documentar thresholds de instabilidade.",
                                    "Relatar resultados em relatório com gráficos."
                                  ],
                                  "verification": "Solução converge para solução exata conhecida (ex: Gaussiana) sem oscilações.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python/MATLAB com Matplotlib, solução analítica de referência.",
                                  "tips": "Monitore eigenvalues da matriz de iteração para predizer instabilidade.",
                                  "learningObjective": "Aplicar verificação de estabilidade em código real.",
                                  "commonMistakes": "Índices errados na borda; não normalizar erros por grid size."
                                }
                              ],
                              "practicalExample": "Implemente ADI para equação do calor 2D em [0,1]x[0,1] com u(x,y,0)=sin(πx)sin(πy), Dirichlet u=0 nas bordas. Varie r de 1 a 100 e plote norma L2 do erro; confirme estabilidade incondicional vs. blow-up em explícito.",
                              "finalVerifications": [
                                "Derivação correta do fator de amplificação |G| ≤ 1 para ADI parabólico.",
                                "Matriz elíptica bem-condicionada (cond < 1e6) com Dirichlet/Neumann.",
                                "Simulação numérica converge monotonicamente sem oscilações.",
                                "Relatório documenta thresholds e plots de erro.",
                                "Teste com grid 64x64 roda em <1min sem crash.",
                                "Compatibilidade Neumann verificada via integral."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de estabilidade (100% match com literatura).",
                                "Código executável e reproduzível com erros <1%.",
                                "Análise qualitativa de condições de contorno (Dirichlet mais estável).",
                                "Gráficos claros de |G| e erros L2.",
                                "Identificação de 3+ erros comuns evitados.",
                                "Relatório estruturado com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão em fluidos/materiais.",
                                "Computação: Algoritmos iterativos e análise de eigenvalues.",
                                "Engenharia: Simulações CFD com PDEs elípticas.",
                                "Estatística: Análise de erro e condicionamento matricial."
                              ],
                              "realWorldApplication": "Verificação de estabilidade em simulações numéricas de fluxo de calor em painéis solares (ADI parabólico) ou escoamento incompressível (elípticos com Neumann em paredes), evitando crashes em softwares como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Convergência e Teorema de Lax",
                        "description": "Relação entre convergência, consistência e estabilidade, com ênfase no Teorema de Lax-Richtmyer para métodos de diferenças finitas em equações diferenciais parciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Definir convergência de um método numérico",
                            "description": "Descrever convergência como a tendência da solução numérica à solução exata quando h e k → 0, medindo erro global em normas adequadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender soluções exatas e numéricas em métodos de diferenças finitas",
                                  "subSteps": [
                                    "Explicar o que é uma solução exata de uma equação diferencial parcial (EDP).",
                                    "Descrever como os métodos de diferenças finitas substituem derivadas por diferenças finitas para obter uma aproximação numérica.",
                                    "Identificar as fontes principais de erro: erro de truncamento local e erro de arredondamento.",
                                    "Discutir o objetivo geral dos métodos numéricos: aproximar a solução exata com precisão arbitrária."
                                  ],
                                  "verification": "O aluno explica verbalmente ou por escrito a diferença entre solução exata e numérica, citando pelo menos duas fontes de erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica II",
                                    "Caderno e lápis",
                                    "Exemplos de EDPs simples (como equação de Laplace)"
                                  ],
                                  "tips": "Comece com um exemplo unidimensional simples para visualizar a grade de pontos.",
                                  "learningObjective": "Diferenciar solução exata de numérica e reconhecer componentes de erro em métodos de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir erro de truncamento com erro de arredondamento",
                                    "Achar que soluções numéricas são sempre exatas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito geral de convergência numérica",
                                  "subSteps": [
                                    "Definir convergência em termos intuitivos: tendência da aproximação à verdade à medida que o processo é refinado.",
                                    "Explicar que convergência é uma propriedade assintótica quando parâmetros de discretização diminuem.",
                                    "Discutir a importância da convergência para validar métodos numéricos.",
                                    "Relacionar com exemplos não numéricos, como sequências convergentes em cálculo."
                                  ],
                                  "verification": "O aluno reformula a definição intuitiva de convergência e dá um exemplo não numérico análogo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com definições básicas de limites",
                                    "Software de plotagem como Python/Matplotlib (opcional)"
                                  ],
                                  "tips": "Use gráficos de sequências convergentes para ilustrar o conceito visualmente.",
                                  "learningObjective": "Compreender convergência como propriedade assintótica de aproximações.",
                                  "commonMistakes": [
                                    "Confundir convergência com consistência",
                                    "Ignorar o aspecto assintótico (h→0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar os parâmetros de discretização h e k",
                                  "subSteps": [
                                    "Definir h como o passo espacial na malha (Δx = h).",
                                    "Definir k como o passo temporal na malha (Δt = k), se aplicável a EDPs evolutivas.",
                                    "Descrever o processo de refinamento: h → 0 e k → 0 para aumentar a resolução.",
                                    "Discutir implicações computacionais: trade-off entre precisão e custo."
                                  ],
                                  "verification": "O aluno desenha uma malha 2D simples e indica h e k corretamente, explicando o refinamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (GeoGebra)",
                                    "Exemplos de malhas em problemas de Poisson ou onda"
                                  ],
                                  "tips": "Desenhe malhas grosseiras vs. finas para comparar visualmente.",
                                  "learningObjective": "Identificar e explicar o papel de h e k no refinamento da malha numérica.",
                                  "commonMistakes": [
                                    "Confundir h (espacial) com k (temporal)",
                                    "Achar que h→0 sem k afeta apenas problemas estacionários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir formalmente a convergência e normas de erro",
                                  "subSteps": [
                                    "Estabelecer a definição formal: um método converge se ||u_h,k - u|| → 0 quando h,k → 0, onde u é a solução exata.",
                                    "Explicar erro global: máximo ou norma L2 sobre o domínio.",
                                    "Introduzir normas adequadas: ||.||_∞, ||.||_2 para EDPs.",
                                    "Mencionar o Teorema de Lax como contexto (convergência ≡ consistência + estabilidade)."
                                  ],
                                  "verification": "O aluno escreve a definição formal completa, incluindo normas, e explica cada símbolo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com fórmulas de normas",
                                    "Livro com Teorema de Lax",
                                    "Calculadora para normas simples"
                                  ],
                                  "tips": "Memorize a definição como: lim_{h,k→0} e(h,k) = 0, onde e é o erro global.",
                                  "learningObjective": "Formular a definição precisa de convergência para métodos de diferenças finitas.",
                                  "commonMistakes": [
                                    "Omitir 'global' no erro",
                                    "Confundir norma local com global",
                                    "Esquecer h,k →0 simultaneamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a definição em um exemplo simples",
                                  "subSteps": [
                                    "Escolher um problema modelo: equação de Laplace em 1D.",
                                    "Implementar diferenças finitas e calcular erro para diferentes h.",
                                    "Plotar erro vs. h em escala log-log para observar ordem de convergência.",
                                    "Verificar numericamente se erro →0 ao refinar h."
                                  ],
                                  "verification": "O aluno computa e plota erros para 3 valores de h e conclui sobre convergência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou MATLAB para implementação",
                                    "Dados de solução exata conhecida"
                                  ],
                                  "tips": "Use solução exata analítica para comparar diretamente.",
                                  "learningObjective": "Aplicar a definição de convergência em prática computacional.",
                                  "commonMistakes": [
                                    "Erro na implementação da diferença finita",
                                    "Má escolha de norma incompatível com o problema"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação -u''(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0, a solução exata é u(x)=sin(πx). Use diferenças finitas centradas: (u_{i+1} - 2u_i + u_{i-1})/h² = -π² sin(π x_i). Resolva o sistema tridiagonal para h=0.1, 0.05, 0.025. Calcule erro máximo ||U_h - u||_∞ e observe que diminui como O(h²) à medida que h→0, confirmando convergência.",
                              "finalVerifications": [
                                "O aluno define corretamente convergência como lim_{h,k→0} ||u_{h,k} - u|| = 0.",
                                "Explica o papel de h e k como passos de malha espacial e temporal.",
                                "Identifica normas adequadas (ex: L^∞, L^2) para medir erro global.",
                                "Distingue erro global de local.",
                                "Relaciona com Teorema de Lax (consistência + estabilidade implica convergência).",
                                "Aplica em exemplo simples mostrando redução de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição formal (0-4 pontos: completa com normas?).",
                                "Compreensão de h,k e refinamento (0-3 pontos).",
                                "Correta distinção de erros local/global (0-3 pontos).",
                                "Aplicação prática em exemplo (0-4 pontos: cálculo e interpretação).",
                                "Integração com contexto de Lax (0-3 pontos).",
                                "Clareza na explicação verbal/escrita (0-3 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de convergência em simulações de EDPs para mecânica de fluidos.",
                                "Ciência da Computação: Implementação e teste de algoritmos numéricos em programação.",
                                "Engenharia: Validação de modelos finitos em estruturas e aerodinâmica.",
                                "Estatística: Análise de erro e normas em dados numéricos."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas, métodos de diferenças finitas para EDPs atmosféricas convergem à solução física real ao refinar a malha (h,k menores), permitindo simulações precisas de furacões e mudanças climáticas com grids globais de alta resolução."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Enunciar e provar o Teorema de Lax",
                            "description": "Enunciar o Teorema de Lax-Richtmyer (consistência + estabilidade ⇒ convergência) e esboçar sua prova para problemas lineares bem-postos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais Pré-Requisitos",
                                  "subSteps": [
                                    "Defina problema linear bem-posto no contexto de equações diferenciais parciais (EDPs).",
                                    "Explique consistência de um esquema de diferenças finitas: limite da solução numérica para o passo h→0 deve recuperar a solução exata.",
                                    "Descreva estabilidade: norma da solução numérica não explode com o número de passos.",
                                    "Defina convergência: erro entre solução numérica e exata tende a zero conforme h, τ →0.",
                                    "Relacione os três conceitos hierarquicamente."
                                  ],
                                  "verification": "Escreva definições precisas e verifique se elas se alinham com referências padrão (ex: livro de Gustafsson).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula de Análise Numérica II, livro 'Finite Difference Schemes and Partial Differential Equations' de Strikwerda, calculadora simbólica (ex: Mathematica ou papel e lápis).",
                                  "tips": "Use analogias físicas: consistência é 'aproximação local', estabilidade é 'controle de amplificação de erros'.",
                                  "learningObjective": "Dominar definições exatas de consistência, estabilidade e convergência para problemas lineares bem-postos.",
                                  "commonMistakes": "Confundir estabilidade com consistência; esquecer que problemas devem ser bem-postos (solução única e estável depende continuamente dos dados iniciais)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar Precisamente o Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Escreva o enunciado formal: Para problemas lineares bem-postos, um esquema consistente e estável é convergente.",
                                    "Especifique condições: operadores lineares em espaços de Banach, semi-discretização ou totalmente discreta.",
                                    "Inclua notação: Seja u solução exata, u_h solução numérica; ||u - u_h|| →0 quando mesh refina.",
                                    "Discuta equivalência para problemas lineares: teorema de Lax original.",
                                    "Memorize prova de direção 'apenas se' em casos simples."
                                  ],
                                  "verification": "Recite o teorema de memória e compare com enunciado padrão em literatura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo original de Lax-Richtmyer (1960) ou resumo em LeVeque 'Finite Difference Methods for ODEs and PDEs', quadro branco.",
                                  "tips": "Enuncie em voz alta várias vezes, associando a uma imagem mental de 'triângulo: consistência + estabilidade = convergência'.",
                                  "learningObjective": "Enunciar o teorema com precisão matemática, incluindo hipóteses.",
                                  "commonMistakes": "Omitir 'problemas lineares bem-postos'; confundir com teorema de Lax-Wendroff (alta ordem)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Esboçar a Prova para Problemas Lineares Bem-Postos",
                                  "subSteps": [
                                    "Mostre consistência: |L_h u - P_h L u| ≤ C h^p, onde L_h esquema, P_h projeção.",
                                    "Use estabilidade: ||u_h^n|| ≤ K ||u_h^0|| para todos n, h, τ.",
                                    "Aplique triangulação de erros: erro total = truncamento + propagado.",
                                    "Conclua convergência via teorema de densidade ou boundedness em normas adequadas.",
                                    "Desenhe diagrama da prova: setas de consistência e estabilidade convergindo para erro →0."
                                  ],
                                  "verification": "Escreva esboço da prova em 1 página e identifique passos chave sem lacunas lógicas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Papel milimetrado, livro de análise funcional básica (ex: Rudin), software LaTeX para notação.",
                                  "tips": "Comece pela prova de direção 'se convergente então consistente e estável' que é mais intuitiva.",
                                  "learningObjective": "Compreender e reproduzir esboço lógico da prova, focando em operadores lineares.",
                                  "commonMistakes": "Ignorar normas equivalentes em espaços finitos; assumir CFL sem contexto de estabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar o Teorema em um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha EDP linear: equação de advecção u_t + a u_x =0.",
                                    "Analise esquema upwind: verifique consistência (ordem 1), estabilidade (CFL ≤1).",
                                    "Mostre convergência numérica via simulação com h decrescendo.",
                                    "Contraponha com esquema instável (ex: downwind).",
                                    "Discuta extensão para sistemas lineares."
                                  ],
                                  "verification": "Implemente código simples e plote erros de convergência (deve ser O(h)).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com NumPy/Matplotlib, código template de diferenças finitas.",
                                  "tips": "Use grids grosseiros primeiro para depuração rápida; log-log plot para ordem de convergência.",
                                  "learningObjective": "Aplicar teorema para validar esquemas numéricos concretos.",
                                  "commonMistakes": "Esquecer normalização de erros; confundir erro local vs global."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x =0 com u(0,x)=δ(x), aplique esquema Lax-Friedrichs: verifique consistência O(h^2 + τ^2), estabilidade via von Neumann (CFL≤1), e observe convergência em simulações com h=1/100 vs h=1/200.",
                              "finalVerifications": [
                                "Enuncie o teorema sem consultar notas.",
                                "Esboce prova em menos de 5 minutos.",
                                "Identifique falhas em um esquema dado (ex: FTCS instável).",
                                "Explique por que consistência sozinha falha.",
                                "Aplique teorema a um sistema linear simples (ex: equações de onda).",
                                "Discuta contraexemplo não linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado (100% correto).",
                                "Completude do esboço de prova (todos passos lógicos presentes).",
                                "Correta identificação de consistência/estabilidade em exemplos.",
                                "Uso apropriado de normas e espaços funcionais.",
                                "Capacidade de generalizar para esquemas multi-D.",
                                "Ausência de erros conceituais comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Validação de simulações CFD.",
                                "Ciência da Computação: Análise de algoritmos numéricos paralelos.",
                                "Engenharia: Estabilidade em métodos de elementos finitos.",
                                "Análise Funcional: Espaços de Banach em provas."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou aerodinâmicas (CFD), garante que métodos numéricos convergem para soluções físicas reais, evitando 'blow-up' em previsões de tempo ou design de aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Aplicar o teorema em análises práticas",
                            "description": "Verificar convergência para métodos explícitos/implícitos em equações elípticas (condições Dirichlet/Neumann) e hiperbólicas, usando consistência e estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema de Lax e conceitos fundamentais",
                                  "subSteps": [
                                    "Estude a declaração precisa do Teorema de Lax: para esquemas lineares bem-posicionados, consistência + estabilidade implica convergência.",
                                    "Revise definições de consistência (ordem de truncamento → 0 com h, τ → 0) e estabilidade (norma da solução numérica bounded).",
                                    "Identifique diferenças entre métodos explícitos (ex: forward Euler) e implícitos (ex: backward Euler).",
                                    "Liste condições de contorno: Dirichlet (valor fixo) vs. Neumann (derivada fixa).",
                                    "Exercite com esquemas para PDEs elípticas (Poisson) e hiperbólicas (onda)."
                                  ],
                                  "verification": "Resuma o teorema em suas próprias palavras e dê um exemplo de falha sem estabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula, calculadora simbólica (Mathematica/MATLAB).",
                                  "tips": "Use diagramas de von Neumann para visualizar amplificação de erros.",
                                  "learningObjective": "Compreender os pilares do teorema para aplicação posterior.",
                                  "commonMistakes": "Confundir consistência (aproximação local) com estabilidade (comportamento global)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar consistência em equações elípticas com condições Dirichlet/Neumann",
                                  "subSteps": [
                                    "Escolha o problema modelo: ∇²u = f em domínio Ω, u=g em ∂Ω (Dirichlet) ou ∂u/∂n = h (Neumann).",
                                    "Discretize com diferenças finitas centradas: derive o esquema implícito (ex: 5-point stencil).",
                                    "Calcule o erro de truncamento local: expanda em Taylor e verifique ordem O(h²).",
                                    "Compare métodos explícito vs. implícito: note que explícito pode não ser adequado para elípticas.",
                                    "Teste numericamente: resolva para malha fina e compare com solução exata."
                                  ],
                                  "verification": "Mostre que ||τ|| → 0 quando h → 0, com cálculo explícito do termo de truncamento.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Python (NumPy/SciPy), grade de malha 2D gerada por meshgrid.",
                                  "tips": "Para Neumann, use stencil assimétrico na fronteira.",
                                  "learningObjective": "Dominar verificação de consistência para elípticas.",
                                  "commonMistakes": "Ignorar termos de fronteira no erro de truncamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar estabilidade para métodos explícitos/implícitos em elípticas e hiperbólicas",
                                  "subSteps": [
                                    "Para elípticas implícitas: prove estabilidade via norma L² (matriz simétrica positiva definida).",
                                    "Para hiperbólicas (ex: u_t + u_x = 0): analise CFL para explícito (τ/h ≤ 1).",
                                    "Use análise de von Neumann: calcule fator de amplificação |g(θ)| ≤ 1 para todos modos θ.",
                                    "Compare: implícito incondicionalmente estável para difusão, explícito condicional para onda.",
                                    "Simule instabilidade: rode código com τ/h >1 e observe blow-up."
                                  ],
                                  "verification": "Derive condição de estabilidade e plote |g(θ)| vs. θ.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Código Python para análise de Fourier, solver de autovalores.",
                                  "tips": "Linearize não-lineares se necessário.",
                                  "learningObjective": "Aplicar ferramentas de estabilidade corretamente.",
                                  "commonMistakes": "Esquecer modos de alta frequência (θ=π)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Teorema de Lax para concluir convergência e validar numericamente",
                                  "subSteps": [
                                    "Combine resultados: se consistente e estável, então convergente pela Lax.",
                                    "Para elíptica Dirichlet implícita: mostre ||u_h - u|| ≤ C h².",
                                    "Para hiperbólica explícita: verifique CFL e ordem 1 em tempo/espaço.",
                                    "Implemente solver completo e compute erro em norma L∞ para h=1/10, 1/20, 1/40.",
                                    "Analise taxa de convergência: log(error)/log(h) ≈ ordem."
                                  ],
                                  "verification": "Gere gráfico de erro vs. h confirmando convergência.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Jupyter notebook com solvers FD, solução exata conhecida (ex: u=sin(x)cos(t)).",
                                  "tips": "Use grids não-uniformes para testar robustez.",
                                  "learningObjective": "Concluir convergência via teorema e evidência numérica.",
                                  "commonMistakes": "Atribuir convergência sem checar ambas condições."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar casos de falha e extensões",
                                  "subSteps": [
                                    "Teste esquema inconsistente: altere stencil para ordem 0 e observe não-convergência.",
                                    "Caso sem estabilidade: hiperbólica com CFL>1, mostre divergência apesar de consistente.",
                                    "Extenda a condições mistas Dirichlet-Neumann.",
                                    "Discuta não-lineares: onde Lax não aplica diretamente.",
                                    "Resolva problema prático: convergência em simulação de calor (elíptica estacionária)."
                                  ],
                                  "verification": "Documente 2 casos onde teorema falha e explique por quê.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Códigos modificados dos steps anteriores.",
                                  "tips": "Compare com métodos espectrais para benchmark.",
                                  "learningObjective": "Reconhecer limitações do teorema.",
                                  "commonMistakes": "Aplicar Lax a esquemas não-lineares sem adaptação."
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de Poisson ∇²u = -π² sin(πx) sin(πy) em [0,1]² com u=0 na fronteira (Dirichlet). Use esquema implícito 5-point, verifique consistência O(h²), estabilidade (matriz SPD), e convergência plotando erro L² vs. h=1/10 a 1/80 em Python.",
                              "finalVerifications": [
                                "Deriva corretamente o erro de truncamento para stencil centrado.",
                                "Obtém fator de amplificação |g(θ)| ≤1 para todos os casos.",
                                "Conclui convergência via Lax com justificativa escrita.",
                                "Implementa código que converge com taxa esperada.",
                                "Identifica e corrige instabilidade em simulação hiperbólica.",
                                "Aplica a condições Neumann sem erros de fronteira."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de consistência (90% correto).",
                                "Correta análise de estabilidade via von Neumann (gráfico incluído).",
                                "Taxa de convergência numérica matches teorema (±10%).",
                                "Código limpo, reproduzível e comentado.",
                                "Explicação clara de falhas potenciais.",
                                "Integração correta de condições de contorno."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão de calor (elípticas) e ondas (hiperbólicas).",
                                "Computação: Implementação eficiente em SciPy/Sparse matrices.",
                                "Engenharia: Simulações CFD para escoamentos incompressíveis.",
                                "Estatística: Análise de erro numérico e convergência probabilística."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, verificar convergência de solvers FD para simular fluxo supersônico (hiperbólicas) garantindo precisão em projetos de aviões; em geofísica, modelar reservatórios de óleo com Poisson (elípticas) para otimização de extração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Métodos para Equações Parabólicas",
                    "description": "Convergência e estabilidade, incluindo o método ADI (Alternating Direction Implicit).",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Convergência de Métodos de Diferenças Finitas para Equações Parabólicas",
                        "description": "Conceitos fundamentais de convergência, incluindo consistência e ordem de precisão, aplicados a esquemas numéricos para equações parabólicas como a equação do calor.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Definir e verificar consistência de esquemas de diferenças finitas",
                            "description": "Explicar a definição de consistência de um esquema numérico e calcular o erro de truncamento local para esquemas explícito e implícito em equações parabólicas unidimensionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de Consistência em Esquemas Numéricos",
                                  "subSteps": [
                                    "Revise a definição formal de consistência: um esquema é consistente se o erro de truncamento local (LTE) tende a zero quando o tamanho da malha h e o passo de tempo k tendem a zero.",
                                    "Estude os princípios de Lax-Richtmyer para estabilidade, consistência e convergência.",
                                    "Diferencie consistência de estabilidade e convergência.",
                                    "Analise exemplos simples de esquemas consistentes e inconsistentes.",
                                    "Memorize a notação padrão: solução exata u, aproximação numérica u_h^k."
                                  ],
                                  "verification": "Escreva a definição de consistência em suas próprias palavras e forneça um exemplo de esquema inconsistente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), notas de aula, papel e caneta",
                                  "tips": "Use analogias como 'zooming in' na solução exata para visualizar o LTE.",
                                  "learningObjective": "Definir precisamente consistência e sua relação com o teorema de Lax.",
                                  "commonMistakes": "Confundir consistência com estabilidade; ignorar limites h→0 e k→0 simultaneamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e Calcular o Erro de Truncamento Local (LTE)",
                                  "subSteps": [
                                    "Derive o LTE expandindo a solução exata em série de Taylor ao redor de um ponto grid.",
                                    "Identifique termos de ordem O(h^p + k^q) no LTE.",
                                    "Aplique a expansão de Taylor para derivadas parciais em equações parabólicas u_t = α u_xx.",
                                    "Calcule o operador de diferença finita e subtraia da PDE exata.",
                                    "Verifique que LTE → 0 implica consistência para esquemas lineares."
                                  ],
                                  "verification": "Derive o LTE genérico para uma PDE parabólica e mostre que é O(h^2 + k).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (Mathematica ou SymPy), quadro branco",
                                  "tips": "Comece com expansões univariadas antes de bivariadas para derivadas mistas.",
                                  "learningObjective": "Calcular LTE usando séries de Taylor para esquemas de diferenças finitas.",
                                  "commonMistakes": "Esquecer termos de ordem superior ou sinais errados em expansões de Taylor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Consistência no Esquema Explícito (FTCS)",
                                  "subSteps": [
                                    "Escreva o esquema FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α k / h^2.",
                                    "Expanda u exata em Taylor no ponto (x_j, t_n) para derivar LTE.",
                                    "Mostre LTE = O(k + h^2) para FTCS.",
                                    "Conclua consistência pois LTE → 0 quando h,k → 0.",
                                    "Teste numericamente com h=k=0.1 vs h=k=0.01."
                                  ],
                                  "verification": "Calcule explicitamente LTE para FTCS e plote erro vs h.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB para simulação simples, papel quadriculado",
                                  "tips": "Use stencil visual para lembrar coeficientes do Laplace discreto.",
                                  "learningObjective": "Verificar consistência do esquema explícito via LTE.",
                                  "commonMistakes": "Confundir LTE local com erro global; errar fator r na expansão temporal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Consistência no Esquema Implícito (BTCS)",
                                  "subSteps": [
                                    "Escreva o esquema BTCS: -r/2 u_{j-1}^{n+1} + (1+r) u_j^{n+1} = r/2 u_{j+1}^{n+1} + u_j^n.",
                                    "Expanda Taylor em (x_j, t_{n+1}) para o lado implícito.",
                                    "Derive LTE = O(k + h^2), similar ao explícito.",
                                    "Compare estabilidade (implícito incondicionalmente estável) sem afetar consistência.",
                                    "Implemente um código simples para validar."
                                  ],
                                  "verification": "Derive LTE para BTCS e confirme consistência igual ao FTCS.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python pronto para esquemas parabólicos",
                                  "tips": "Linearize o sistema implícito mentalmente como I - k A, onde A é Laplace.",
                                  "learningObjective": "Verificar consistência do esquema implícito e contrastar com explícito.",
                                  "commonMistakes": "Expandir Taylor no tempo errado (use t_{n+1} para implícito)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Sintetizar Consistência Geral",
                                  "subSteps": [
                                    "Resuma condições para consistência em esquemas parabólicos 1D.",
                                    "Discuta esquemas de ordem superior (ex: Crank-Nicolson, LTE O(h^2 + k^2)).",
                                    "Resolva exercícios: prove consistência para variantes.",
                                    "Crie um fluxograma: PDE → Esquema → LTE → Consistente?",
                                    "Avalie impacto em convergência via Lax Equivalence."
                                  ],
                                  "verification": "Resolva 2 problemas de prova de consistência e discuta exceções.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios de livro-texto, software de plotagem",
                                  "tips": "Sempre normalize LTE por h e k para ordem de precisão.",
                                  "learningObjective": "Sintetizar verificação de consistência para esquemas explícito/implícito.",
                                  "commonMistakes": "Ignorar não-linearidades que quebram teorema de Lax."
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx em [0,1]x[0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx), aplique FTCS com r=0.5, h=0.1, k=0.02. Calcule LTE ≈ (k/2 - h^2/12) u_{tt} + ... e verifique |LTE| < 10^{-3}, confirmando consistência ao refinar malha.",
                              "finalVerifications": [
                                "Definição de consistência explicada corretamente sem erros.",
                                "LTE derivado precisamente para FTCS e BTCS com ordens corretas.",
                                "Cálculos numéricos mostram LTE → 0 com refinamento de malha.",
                                "Diferenças entre explícito e implícito destacadas corretamente.",
                                "Exemplo prático implementado e validado.",
                                "Fluxograma ou resumo de verificação criado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de séries de Taylor (90%+ correto).",
                                "Correta identificação de ordens de LTE (O(h^2 + k)).",
                                "Explicação clara da relação consistência-convergência.",
                                "Uso apropriado de notação matemática padrão.",
                                "Exemplo numérico com erro < 1% da norma exata.",
                                "Análise de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e ondas.",
                                "Computação: Implementação em Python/NumPy para PDEs.",
                                "Engenharia: Simulações CFD em aerodinâmica.",
                                "Estatística: Análise de erros numéricos em Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de transferência de calor em painéis solares ou previsão meteorológica, verificar consistência garante que refinamentos de malha capturem física real sem artefatos numéricos, otimizando designs industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Aplicar o teorema de Lax para convergência",
                            "description": "Demonstrar o teorema de Lax-Richtmyer, relacionando consistência e estabilidade à convergência, e analisar a ordem de convergência para métodos FTCS e BTCS em problemas parabólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Estude o enunciado formal do teorema: para esquemas de diferenças finitas lineares, consistência + estabilidade implica convergência.",
                                    "Revise definições chave: truncamento local (LTE), consistência (LTE → 0 quando Δt, Δx → 0), estabilidade (norma da solução numérica bounded).",
                                    "Analise a relação com o princípio de Huygens para esquemas hiperbólicos, mas foque em parabólicos.",
                                    "Derive intuitivamente por que estabilidade é necessária usando contraexemplos.",
                                    "Memorize condições para esquemas lineares e implicações para não-lineares."
                                  ],
                                  "verification": "Enuncie o teorema e explique cada termo em suas próprias palavras; resolva um exercício simples de identificação.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica' de Burden & Faires (Cap. Diferenças Finitas)",
                                    "Notas de aula sobre Análise Numérica II",
                                    "Artigo original de Lax-Richtmyer (PDF online)"
                                  ],
                                  "tips": "Use analogias: consistência é 'aproximação boa', estabilidade é 'não explode', convergência é 'vai para a solução exata'.",
                                  "learningObjective": "Compreender e enunciar precisamente o teorema de Lax-Richtmyer, diferenciando consistência, estabilidade e convergência.",
                                  "commonMistakes": [
                                    "Confundir consistência (aproximação da PDE) com precisão numérica; ignorar que o teorema é para esquemas lineares uniformemente estáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Consistência para Métodos FTCS e BTCS",
                                  "subSteps": [
                                    "Escreva a equação parabólica modelo: u_t = α u_xx.",
                                    "Derive o esquema FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Calcule o erro de truncamento local (LTE) para FTCS via expansão de Taylor: LTE = O(Δt) + O(Δx²).",
                                    "Repita para BTCS (implícito): resolva o sistema tridiagonal e encontre LTE = O(Δt) + O(Δx²).",
                                    "Conclua consistência: lim Δt,Δx→0 LTE = 0 para ambos."
                                  ],
                                  "verification": "Compute LTE para ambos esquemas e mostre que →0; compare ordens.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB para expansões simbólicas (SymPy)",
                                    "Folha de papel para Taylor manual",
                                    "Exercícios de Análise Numérica II"
                                  ],
                                  "tips": "Sempre normalize com Δt e Δx; foque em termos líderes do erro.",
                                  "learningObjective": "Calcular erros de truncamento e provar consistência para FTCS e BTCS em equações parabólicas.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior na Taylor; confundir FTCS (explícito) com BTCS (implícito) na derivação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade dos Esquemas FTCS e BTCS",
                                  "subSteps": [
                                    "Use análise von Neumann: assuma solução u_j^n = ξ^n e^{i k j Δx}, encontre amplificação ξ.",
                                    "Para FTCS: |ξ|² = 1 - 4r sin²(θ/2), instável para r > 1/2.",
                                    "Para BTCS: resolva |ξ|² = 1 / |1 + 4r sin²(θ/2)|² ≤1, sempre estável.",
                                    "Discuta estabilidade condicional (FTCS) vs incondicional (BTCS).",
                                    "Verifique uniformidade em k para aplicação do teorema de Lax."
                                  ],
                                  "verification": "Plote |ξ| vs r e θ para ambos; identifique regiões estáveis.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB/Python para plotar fatores de amplificação",
                                    "Tabela de Fourier para von Neumann"
                                  ],
                                  "tips": "Comece com θ=π (modo mais oscilante); use cos(2θ) para simplificar.",
                                  "learningObjective": "Realizar análise de estabilidade von Neumann e determinar condições para FTCS/BTCS.",
                                  "commonMistakes": [
                                    "Erro no cálculo de ξ para implícito; esquecer normalização |ξ|≤1+ O(Δt)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema e Analisar Ordem de Convergência",
                                  "subSteps": [
                                    "Combine resultados: ambos consistentes; FTCS converge se r≤1/2, BTCS sempre.",
                                    "Estime ordem: para FTCS estável, erro global O(Δt + Δx²); similar para BTCS.",
                                    "Use teorema de Lax para justificar convergência uniforme em malhas finas.",
                                    "Numéricamente: implemente e compare erros L2 vs solução exata.",
                                    "Discuta limitações: não-linearidades ou geometrias complexas."
                                  ],
                                  "verification": "Escreva prova completa de convergência e compute ordem numericamente.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código Python para simulação 1D heat equation",
                                    "Solução analítica via separação de variáveis"
                                  ],
                                  "tips": "Refine malha logarítmicamente para estimar ordem via log-log plot.",
                                  "learningObjective": "Aplicar teorema de Lax para provar convergência e determinar ordem para esquemas parabólicos.",
                                  "commonMistakes": [
                                    "Ignorar dependência em r para ordem; superestimar convergência sem estabilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx em [0,1]x[0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx): implemente FTCS com r=0.4 (estável), compare solução numérica em t=0.5 com exata u(x,0.5)=sin(πx)e^{-π² 0.5}, verificando erro O(10^{-3}) para Δx=0.05.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema de Lax-Richtmyer.",
                                "Deriva LTE para FTCS e BTCS mostrando consistência.",
                                "Realiza análise von Neumann correta para estabilidade.",
                                "Prova convergência condicional/incondicional usando o teorema.",
                                "Estima ordem de convergência numericamente com erro <1%.",
                                "Identifica limitações do teorema em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de LTE e ordem de consistência (80%).",
                                "Correção na análise de estabilidade von Neumann (90%).",
                                "Aplicação lógica do teorema para convergência (100%).",
                                "Qualidade de simulação numérica e plots de erro (85%).",
                                "Clareza na explicação de conexões entre conceitos (90%).",
                                "Identificação de erros comuns e limitações (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de estabilidade em simulações CFD.",
                                "Computação: Implementação eficiente de solvers implícitos (BTCS) em Python/NumPy.",
                                "Engenharia: Convergência em simulações de fluxo de calor em materiais.",
                                "Estatística: Análise de erros numéricos e estimação de ordem via regressão."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes (estabilidade garante previsões confiáveis), ou em finanças para modelar difusão de preços de opções (Black-Scholes parabólico), onde convergência rápida permite decisões em tempo real sem explosão numérica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Analisar erros de truncamento e arredondamento",
                            "description": "Calcular e comparar erros de truncamento espacial e temporal, além de erros de arredondamento, determinando o h e k ótimos para convergência em equações parabólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Erros de Truncamento e Arredondamento",
                                  "subSteps": [
                                    "Defina erro de truncamento espacial (relacionado a h) e temporal (relacionado a k).",
                                    "Explique o erro de arredondamento devido à precisão de ponto flutuante.",
                                    "Revise a expansão em série de Taylor para derivadas em métodos de diferenças finitas.",
                                    "Identifique a ordem de precisão do esquema para equações parabólicas (ex: O(h² + k)).",
                                    "Discuta a condição de estabilidade CFL para esquemas explícitos."
                                  ],
                                  "verification": "Resuma em um parágrafo os três tipos de erros e suas dependências em h e k.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Análise Numérica, notas de aula, calculadora.",
                                  "tips": "Use diagramas de grade espacial-temporal para visualizar h e k.",
                                  "learningObjective": "Diferenciar e explicar fontes de erro em métodos de diferenças finitas.",
                                  "commonMistakes": "Confundir truncamento espacial com temporal; ignorar termos de ordem superior."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Erros de Truncamento Espacial e Temporal",
                                  "subSteps": [
                                    "Escolha uma equação parabólica modelo: u_t = α u_xx.",
                                    "Aplique esquema de diferenças finitas explícito e derive o erro local de truncamento.",
                                    "Expanda em Taylor as diferenças finitas para obter O(h² + k/h²) ou similar.",
                                    "Calcule numericamente para h=0.1, k=0.01 em uma grade 10x10.",
                                    "Compare erros para diferentes valores de h e k."
                                  ],
                                  "verification": "Plote erro de truncamento vs. h e vs. k em gráfico log-log.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/MATLAB com NumPy/Matlab, papel quadriculado.",
                                  "tips": "Mantenha α=1 para simplicidade inicial.",
                                  "learningObjective": "Derivar e quantificar erros de truncamento em esquemas parabólicos.",
                                  "commonMistakes": "Esquecer fatores de 1/2 nas expansões de Taylor; usar h em vez de Δt."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Erros de Arredondamento",
                                  "subSteps": [
                                    "Explique propagação de erros de arredondamento em iterações temporais.",
                                    "Estime erro de arredondamento como ε_machine * (T/k), onde T é tempo final.",
                                    "Simule em código com precisão reduzida (ex: float32 vs float64).",
                                    "Calcule para máquina típica (ε ≈ 10^{-16}).",
                                    "Compare magnitude com erros de truncamento."
                                  ],
                                  "verification": "Mostre que erro de arredondamento domina para h,k muito pequenos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (Python com numpy.float32), documentação IEEE 754.",
                                  "tips": "Use np.spacing(1) para estimar ε_machine.",
                                  "learningObjective": "Quantificar impacto do arredondamento na precisão global.",
                                  "commonMistakes": "Subestimar crescimento exponencial em esquemas instáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar h e k Ótimos para Convergência",
                                  "subSteps": [
                                    "Estabeleça trade-off: truncamento diminui com h,k pequenos; arredondamento aumenta.",
                                    "Minimize erro total E ≈ C1 h² + C2 k + C3 / sqrt(k).",
                                    "Derive h_opt ~ ε^{1/4}, k_opt ~ ε^{1/2} para ordens típicas.",
                                    "Otimize numericamente para uma solução exata conhecida (ex: Gaussiana).",
                                    "Verifique convergência plotando erro vs. malha."
                                  ],
                                  "verification": "Encontre h,k que minimizam erro em simulação; confirme com gráfico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Script de otimização (scipy.optimize), solução analítica de teste.",
                                  "tips": "Comece com ε=10^{-8} para testes rápidos.",
                                  "learningObjective": "Balancear erros para máxima precisão e convergência.",
                                  "commonMistakes": "Ignorar condição de estabilidade ao escolher k > h²."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Avaliar Convergência Geral",
                                  "subSteps": [
                                    "Compare erros para malhas grosseiras vs. finas.",
                                    "Calcule razão de convergência (log(error_n / error_{n+1}) / log(r_h)).",
                                    "Analise impacto em solução final para problema de fronteira.",
                                    "Documente tabela de erros totais.",
                                    "Conclua sobre escolha ótima de parâmetros."
                                  ],
                                  "verification": "Tabela mostra ordem de convergência próxima à teórica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Jupyter notebook para tabelas/gráficos.",
                                  "tips": "Use problema teste: u_t = u_xx, u(0,t)=u(1,t)=0, u(x,0)=sin(πx).",
                                  "learningObjective": "Integrar análises para validar método de diferenças finitas.",
                                  "commonMistakes": "Não normalizar erros pelo tamanho da malha."
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx em [0,1]x[0,1] com u(x,0)=sin(πx), u(0,t)=u(1,t)=0, use esquema explícito FTCS. Calcule erro de truncamento local O(k + h²/12), erro de arredondamento ~10^{-15} * 100/k iterações. Para h=0.05, k=0.00125 (CFL=0.5), erro total ~10^{-5}; otimize h≈0.03, k≈0.0005 para mínimo.",
                              "finalVerifications": [
                                "Derivação correta do erro de truncamento via Taylor.",
                                "Gráfico mostrando trade-off h/k vs. erro total.",
                                "Simulação numérica com convergência observada.",
                                "Identificação de h,k ótimos com erro mínimo.",
                                "Comparação quantitativa entre erros de truncamento e arredondamento.",
                                "Verificação de estabilidade CFL satisfeita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica de erros (90% correto).",
                                "Correção numérica em simulações (erro <10^{-4}).",
                                "Identificação correta de h,k ótimos (±10% do ideal).",
                                "Análise qualitativa clara de trade-offs.",
                                "Uso apropriado de ferramentas computacionais.",
                                "Documentação completa com gráficos e tabelas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e propagação de ondas.",
                                "Computação: Implementação eficiente em HPC e análise de precisão flutuante.",
                                "Engenharia: Simulações CFD para aerodinâmica.",
                                "Estatística: Análise de erros em métodos Monte Carlo.",
                                "Finanças: Modelos de Black-Scholes via diferenças finitas."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos de oceanos com equações de difusão), otimizar h/k minimiza tempo computacional enquanto mantém precisão para previsões de longo prazo; em finanças, acelera precificação de opções exóticas evitando erros de arredondamento em grids finos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Estabilidade de Métodos de Diferenças Finitas para Equações Parabólicas",
                        "description": "Análise de estabilidade usando métodos como von Neumann e matrizes de amplificação, com foco em esquemas explícitos, implícitos e Crank-Nicolson.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Realizar análise de estabilidade von Neumann",
                            "description": "Aplicar a análise von Neumann para determinar a condição de estabilidade em esquemas explícitos para a equação do calor, identificando o número de Courant limite.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema numérico explícito para a equação do calor",
                                  "subSteps": [
                                    "Escreva a equação do calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Apresente o esquema explícito forward-time central-space (FTCS): u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Defina os parâmetros: Δt (passo de tempo), Δx (passo de espaço), r (número de Fourier).",
                                    "Verifique a consistência do esquema aproximando os operadores diferenciais.",
                                    "Discuta limitações iniciais conhecidas do método explícito."
                                  ],
                                  "verification": "Escreva corretamente o esquema FTCS e defina r em termos de α, Δt e Δx.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de análise numérica (ex: LeVeque ou Quarteroni)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use notação consistente para índices j (espaço) e n (tempo).",
                                  "learningObjective": "Compreender a formulação exata do esquema explícito FTCS para a equação do calor.",
                                  "commonMistakes": [
                                    "Confundir r com o número de Courant (r é o número de Fourier aqui)",
                                    "Esquecer o fator α na definição de r",
                                    "Usar diferenças forward ou backward incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise de estabilidade von Neumann e assumir solução de Fourier",
                                  "subSteps": [
                                    "Explique o princípio: analisar modos de alta frequência (ondas de Fourier) para detectar instabilidade.",
                                    "Assuma solução u_j^n = ξ^n exp(i κ j Δx), onde κ é o número de onda e i é a unidade imaginária.",
                                    "Substitua na equação de discretização para isolar ξ (fator de amplificação).",
                                    "Normalize κ Δx = θ, com θ ∈ [0, π] para cobrir todos os modos.",
                                    "Verifique que a solução é uma superposição linear de modos independentes."
                                  ],
                                  "verification": "Escreva a forma assumida u_j^n e explique por que ela é uma solução exata da discretização linear.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de matemática simbólica (ex: Mathematica ou SymPy)",
                                    "Notas de aula sobre análise von Neumann"
                                  ],
                                  "tips": "Lembre-se: a análise é local e ignora condições de contorno para modos curtos.",
                                  "learningObjective": "Dominar a formulação da solução de Fourier para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Esquecer o expoente n em ξ",
                                    "Confundir κ (número de onda) com k (onda espacial)",
                                    "Não normalizar θ = κ Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o fator de amplificação ξ",
                                  "subSteps": [
                                    "Substitua u_j^n = ξ^n e^{i θ j} no esquema FTCS.",
                                    "Calcule os termos vizinhos: u_{j+1}^n = ξ^n e^{i θ (j+1)} = ξ^n e^{i θ j} e^{i θ}, similar para u_{j-1}^n.",
                                    "Divida ambos os lados por ξ^n e^{i θ j} para isolar ξ^{n+1}/ξ^n = ξ.",
                                    "Simplifique: ξ = 1 + r (e^{i θ} - 2 + e^{-i θ}) = 1 + r (2 cos θ - 2) = 1 - 4 r sin²(θ/2).",
                                    "Verifique algebricamente usando identidade trigonométrica."
                                  ],
                                  "verification": "Derive explicitamente ξ = 1 - 4 r sin²(θ/2) a partir do esquema.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica para plotar",
                                    "SymPy ou MATLAB para verificação simbólica"
                                  ],
                                  "tips": "Use a identidade e^{iθ} + e^{-iθ} = 2 cos θ para simplificar.",
                                  "learningObjective": "Calcular o símbolo de amplificação ξ(θ, r) corretamente.",
                                  "commonMistakes": [
                                    "Erro no cálculo de e^{iθ} - 2 + e^{-iθ} (deve ser -4 sin²(θ/2))",
                                    "Dividir incorretamente por ξ^n",
                                    "Confundir ξ com |ξ| prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a condição de estabilidade |ξ| ≤ 1",
                                  "subSteps": [
                                    "Reescreva ξ = 1 - 4 r sin²(φ), onde φ = θ/2 ∈ [0, π/2].",
                                    "Note que ξ é real e diminui com sin²(φ); mínimo em φ=π/2: ξ = 1 - 4 r.",
                                    "Exija |ξ| ≤ 1 para todos φ: como ξ ≤ 1 sempre (para r>0), foque em ξ ≥ -1.",
                                    "Assim, 1 - 4 r ≥ -1 ⇒ 4 r ≤ 2 ⇒ r ≤ 1/2.",
                                    "Confirme que para r > 1/2, |ξ| >1 para θ=π (modo mais oscilatório)."
                                  ],
                                  "verification": "Mostre que a condição |ξ| ≤1 para todo θ leva a r ≤ 1/2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos de |ξ(θ)| para diferentes r"
                                  ],
                                  "tips": "Plote |ξ(θ)| vs θ para r=0.4 (estável) e r=0.6 (instável).",
                                  "learningObjective": "Derivar a condição necessária e suficiente de estabilidade.",
                                  "commonMistakes": [
                                    "Ignorar o caso ξ < -1",
                                    "Esquecer que sin² max=1",
                                    "Concluir r ≤1 em vez de 1/2"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar o número de Courant e aplicações",
                                  "subSteps": [
                                    "Identifique r = α Δt / Δx² como o número de Courant-Friedrichs-Lewy (CFL) para difusão.",
                                    "Discuta implicações: Δt ≤ (Δx²)/(2α) para estabilidade.",
                                    "Compare com esquemas implícitos (incondicionalmente estáveis).",
                                    "Aplique a um exemplo numérico: resolva com r=0.4 e observe estabilidade.",
                                    "Resuma limitações da análise von Neumann (linear, condições periódicas)."
                                  ],
                                  "verification": "Calcule o limite de Δt para α=1, Δx=0.1 e explique o trade-off precisão/estabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para simulação 1D",
                                    "Papel para cálculos"
                                  ],
                                  "tips": "O número de Courant mede 'informação por célula por tempo'.",
                                  "learningObjective": "Relacionar a análise teórica com restrições práticas em simulações.",
                                  "commonMistakes": [
                                    "Chamar r de 'Courant' sem especificar CFL para difusão",
                                    "Ignorar dependência quadrática em Δx"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação do calor com α=1 em [0,1]x[0,1], Δx=0.1 (J=10), use esquema FTCS com r=0.4: Δt=0.004. Simule 100 passos e compare com solução exata; observe estabilidade. Aumente para r=0.6 e veja oscilações crescerem.",
                              "finalVerifications": [
                                "Deriva corretamente ξ = 1 - 4r sin²(θ/2).",
                                "Identifica r ≤ 1/2 como condição de estabilidade.",
                                "Explica o papel dos modos de alta frequência (θ≈π).",
                                "Aplica a análise a um esquema numérico dado.",
                                "Discute limitações da análise von Neumann.",
                                "Calcula Δt máximo para parâmetros específicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ξ (100% correto).",
                                "Correta identificação do limite r ≤ 1/2 com justificativa.",
                                "Uso apropriado de trigonometria e análise complexa.",
                                "Interpretação física do número CFL.",
                                "Capacidade de plotar e analisar |ξ(θ)|.",
                                "Aplicação em simulação simples sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e parabólicas PDEs.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD para transferência de calor.",
                                "Matemática Aplicada: Análise de Fourier e estabilidade linear.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em engenharia térmica, garante simulações estáveis de propagação de calor em materiais (ex: previsão de falhas em reatores nucleares ou design de isolantes); em meteorologia, modela difusão de poluentes ou umidade no solo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Comparar estabilidade de esquemas explícito, implícito e Crank-Nicolson",
                            "description": "Derivar as condições de estabilidade para FTCS (explícito), BTCS (implícito) e Crank-Nicolson, destacando incondicionalidade e dissipação numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão da Equação Parabólica e Aproximações Básicas de Diferenças Finitas",
                                  "subSteps": [
                                    "Escreva a equação de calor unidimensional: ∂u/∂t = α ∂²u/∂x², com condições de contorno e inicial.",
                                    "Defina a malha espacial Δx e temporal Δt, introduzindo índices j para espaço e n para tempo.",
                                    "Apresente as diferenças finitas: forward em tempo (FT), central em espaço (CS) para derivadas.",
                                    "Introduza o parâmetro de Courant r = α Δt / Δx² e discuta seu papel na estabilidade.",
                                    "Esboce os stencils gráficos para FTCS, BTCS e Crank-Nicolson."
                                  ],
                                  "verification": "Pode reproduzir os stencils e o parâmetro r para cada esquema sem consulta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Use notação consistente (u_j^n) e desenhe stencils para visualização clara.",
                                  "learningObjective": "Compreender as discretizações básicas e o parâmetro r comum aos esquemas.",
                                  "commonMistakes": [
                                    "Confundir diferenças forward/backward em tempo",
                                    "Esquecer fator α na definição de r"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivação da Condição de Estabilidade para o Esquema Explícito FTCS",
                                  "subSteps": [
                                    "Escreva o esquema FTCS: u_j^{n+1} = u_j^n + r (u_{j-1}^n - 2 u_j^n + u_{j+1}^n).",
                                    "Aplique análise de von Neumann: assuma u_j^n = g^n e^{i κ j Δx}, derive o símbolo de amplificação g(κ Δx).",
                                    "Calcule |g|² = [1 - 4 r sin²(κ Δx / 2)]² e encontre a condição para |g| ≤ 1 ∀ κ.",
                                    "Conclua que r ≤ 1/2 é necessário e suficiente para estabilidade.",
                                    "Discuta implicações: restrição CFL-like."
                                  ],
                                  "verification": "Derive |g| ≤ 1 e identifique r ≤ 1/2 corretamente em uma prova escrita.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folhas de cálculo",
                                    "Referência: notas de aula sobre von Neumann"
                                  ],
                                  "tips": "Normalize o ângulo θ = κ Δx / 2 para simplificar sin²(θ).",
                                  "learningObjective": "Derivar e interpretar a estabilidade condicional do esquema explícito.",
                                  "commonMistakes": [
                                    "Erro no sinal do laplaciano",
                                    "Esquecer o módulo |g| ≤ 1 para todos os modos de Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise de Estabilidade para Esquemas Implícito BTCS e Crank-Nicolson",
                                  "subSteps": [
                                    "Escreva BTCS: -r u_{j-1}^{n+1} + (1 + 2r) u_j^{n+1} - r u_{j+1}^{n+1} = u_j^n.",
                                    "Aplique von Neumann: g^{-1} = 1 + 2 r (1 - cos(κ Δx)), mostre |g| ≤ 1 para todo r > 0.",
                                    "Para Crank-Nicolson: média temporal, g = [1 - 2 r sin²(θ)] / [1 + 2 r sin²(θ)], prove |g| < 1 ∀ r.",
                                    "Verifique incondicionalidade: sem restrição em r para ambos.",
                                    "Compare numericamente |g| para diferentes r e θ."
                                  ],
                                  "verification": "Mostre algebraicamente |g| ≤ 1 para BTCS e CN, plotando |g(θ)| se possível.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para plotar |g|",
                                    "Papel para álgebra"
                                  ],
                                  "tips": "Para CN, note que é |num/den| com den > |num| sempre.",
                                  "learningObjective": "Demonstrar estabilidade incondicional e diferenças algébricas entre implícito e semi-implícito.",
                                  "commonMistakes": [
                                    "Inverter o tempo em BTCS",
                                    "Confundir g com 1/g na análise"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparação Geral, Dissipação Numérica e Verificação",
                                  "subSteps": [
                                    "Tabule condições: FTCS (r≤1/2, oscilatório), BTCS (incondicional, dissipativo), CN (incondicional, menos dissipativo).",
                                    "Analise dissipação: taxa de amortecimento Re(g) e dispersão Im(g).",
                                    "Discuta trade-offs: custo computacional (explícito direto vs. implícitos matriciais).",
                                    "Implemente teste numérico simples para validar estabilidade.",
                                    "Resuma vantagens: CN para precisão em ondas de baixa frequência."
                                  ],
                                  "verification": "Crie tabela comparativa e explique dissipação em um parágrafo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/Jupyter para simulação rápida",
                                    "Tabela em LaTeX ou Excel"
                                  ],
                                  "tips": "Use r=1 para testar instabilidade em FTCS visualmente.",
                                  "learningObjective": "Comparar esquemas holisticamente, incluindo aspectos práticos.",
                                  "commonMistakes": [
                                    "Ignorar dissipação em CN como 'perfeita'",
                                    "Subestimar custo de solve em implícitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente os três esquemas em Python para resolver ∂u/∂t = ∂²u/∂x² em [0,1] com u(x,0)=sin(πx), u(0,t)=u(1,t)=0. Teste r=0.4 (estável FTCS), r=1 (instável FTCS, estável outros) e plote soluções em t=0.5, observando oscilações em FTCS e suavização em BTCS vs. oscilações preservadas em CN.",
                              "finalVerifications": [
                                "Deriva corretamente r ≤ 1/2 para FTCS com prova von Neumann completa.",
                                "Mostra |g| ≤ 1 para BTCS e CN para qualquer r > 0.",
                                "Explica diferença de dissipação: BTCS forte, CN fraca (próxima a 1 para baixos modos).",
                                "Identifica incondicionalidade e trade-offs computacionais.",
                                "Valida via simulação numérica com plots de estabilidade.",
                                "Compara em tabela: estabilidade, precisão, custo."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de g(θ) (exato vs. aproximado).",
                                "Compreensão conceitual de von Neumann e modos de Fourier.",
                                "Correta identificação de condições (condicional vs. incondicional).",
                                "Análise qualitativa de dissipação e dispersão.",
                                "Uso de exemplos numéricos para validação.",
                                "Clareza na tabela comparativa e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação à equação de difusão térmica e propagação de calor.",
                                "Computação: Implementação de solvers lineares (Thomas algorithm para tridiagonal).",
                                "Engenharia: Simulações em CFD e modelagem de materiais.",
                                "Matemática Pura: Análise de autovalores e estabilidade linear."
                              ],
                              "realWorldApplication": "Em engenharia térmica para simular distribuição de temperatura em placas (explícito para malhas finas rápidas, CN para precisão em simulações longas); em finanças para opções de precificação (equações de Black-Scholes parabólicas); em biofísica para difusão de espécies químicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Avaliar dissipação e dispersão em esquemas parabólicos",
                            "description": "Explicar conceitos de dissipação numérica e dispersão, calculando taxas para diferentes esquemas e sua relação com estabilidade em problemas parabólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de dissipação e dispersão numérica",
                                  "subSteps": [
                                    "Definir dissipação numérica como o amortecimento artificial de componentes de alta frequência na solução numérica.",
                                    "Definir dispersação numérica como o erro de propagação de fase que causa oscilações ou deslocamentos de onda.",
                                    "Explicar a distinção entre dissipação/dispersão numéricas e seus análogos físicos em equações parabólicas.",
                                    "Discutir o impacto em problemas parabólicos, como a equação de difusão de calor."
                                  ],
                                  "verification": "Resumir em um parágrafo as definições e diferenças, sem consultar materiais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque 'Finite Difference Methods'), notas de aula sobre estabilidade.",
                                    "Acesso a software como MATLAB ou Python (NumPy/SciPy)."
                                  ],
                                  "tips": "Use analogias com filtros de sinal para visualizar dissipação como atenuação e dispersão como distorção de fase.",
                                  "learningObjective": "Diferenciar e explicar dissipação e dispersão no contexto de métodos numéricos para PDEs parabólicas.",
                                  "commonMistakes": [
                                    "Confundir dissipação numérica com viscosidade física.",
                                    "Ignorar que dispersão afeta ondas de alta frequência mais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e calcular a taxa de dissipação para esquemas parabólicos",
                                  "subSteps": [
                                    "Analisar o símbolo de amplificação ξ(kΔx, Δt/Δx²) para esquemas como FTCS, BTCS e Crank-Nicolson.",
                                    "Extrair a parte real de log|ξ| para obter a taxa de dissipação numérica d(k) = Re(log ξ)/Δt.",
                                    "Calcular d(k) explicitamente para diferentes esquemas e valores de r = Δt/Δx².",
                                    "Comparar taxas de dissipação entre esquemas explícitos e implícitos."
                                  ],
                                  "verification": "Computar d(kπ) para FTCS com r=0.5 e verificar se é negativo (dissipativo).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para derivações von Neumann.",
                                    "Código Python/MATLAB para plotar d(k) vs. kΔx."
                                  ],
                                  "tips": "Comece com a análise von Neumann: assuma solução u_j^n = ξ^n e^{i k j Δx}.",
                                  "learningObjective": "Calcular quantitativamente a dissipação numérica e interpretá-la como erro.",
                                  "commonMistakes": [
                                    "Esquecer o fator Δt na taxa de dissipação.",
                                    "Usar aproximação de alta frequência sem validar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e calcular a taxa de dispersão para esquemas parabólicos",
                                  "subSteps": [
                                    "Extrair a parte imaginária de log ξ para obter a taxa de dispersão numérica p(k) = Im(log ξ)/Δt.",
                                    "Comparar p(k) com a dispersão física exata p_exata(k) = -k² para equação u_t = u_xx.",
                                    "Calcular o erro de dispersão e plotar para diferentes esquemas.",
                                    "Identificar esquemas com baixa dispersão, como Crank-Nicolson."
                                  ],
                                  "verification": "Plotar p(k) vs. p_exata(k) e discutir regimes de precisão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de plotagem (Matplotlib ou similar).",
                                    "Referências: Artigos sobre análise de Fourier para diferenças finitas."
                                  ],
                                  "tips": "Normalize por k² para visualizar o erro relativo de fase.",
                                  "learningObjective": "Quantificar erros de fase numérica e sua dependência no número de onda k.",
                                  "commonMistakes": [
                                    "Confundir dispersão com advecção em problemas parabólicos puros.",
                                    "Ignorar o sinal na parte imaginária."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a relação entre dissipação, dispersão e estabilidade",
                                  "subSteps": [
                                    "Verificar condição de estabilidade |ξ| ≤ 1 e ligar a dissipação excessiva com instabilidade.",
                                    "Analisar trade-offs: esquemas dissipativos são estáveis mas pouco precisos; baixa dissipação pode causar instabilidade.",
                                    "Comparar esquemas em uma tabela: dissipação, dispersão, estabilidade para r variando.",
                                    "Avaliar numericamente em uma simulação simples da equação de calor."
                                  ],
                                  "verification": "Executar simulação com r acima da estabilidade e observar dissipação/dispersão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código fonte para simulação 1D de calor (Python com diferenças finitas)."
                                  ],
                                  "tips": "Use perfis iniciais com alta frequência (ex: seno de alta k) para testar.",
                                  "learningObjective": "Integrar análises para avaliar esquemas em termos de estabilidade e precisão.",
                                  "commonMistakes": [
                                    "Atribuir instabilidade só a dispersão, ignorando dissipação negativa."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de calor 1D u_t = u_xx em [0,1] com u(0,t)=u(1,t)=0 e u(x,0)=sen(4πx). Implemente FTCS com Δx=0.01, r=0.4. Calcule dissipação/dispersão via análise von Neumann e compare com solução numérica: observe amortecimento excessivo de modos altos e leve deslocamento de fase.",
                              "finalVerifications": [
                                "Explicar verbalmente dissipação vs. dispersão com exemplo gráfico.",
                                "Calcular manualmente d(k) e p(k) para Crank-Nicolson em kΔx=π/2.",
                                "Interpretar plot de |ξ(k)| e arg(ξ(k)) para um esquema dado.",
                                "Simular e identificar artefatos numéricos devidos a dissipação/dispersão.",
                                "Comparar dois esquemas em termos de erro L2 após 100 passos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de d(k) e p(k) (erro <5%).",
                                "Correta interpretação qualitativa dos resultados.",
                                "Qualidade dos gráficos e comparações (legendas, escalas adequadas).",
                                "Identificação precisa de trade-offs estabilidade-precisão.",
                                "Capacidade de ligar análise teórica à simulação prática."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Modelagem de difusão térmica e amortecimento.",
                                "Engenharia Mecânica: Simulações CFD para escoamentos viscosos.",
                                "Ciência da Computação: Análise de estabilidade em solvers numéricos PDE.",
                                "Processamento de Sinais: Analogia com filtros digitais (dissipação como filtro passa-baixa)."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, baixa dissipação preserva frentes frias sem oscilações espúrias; em modelagem financeira (equações de Black-Scholes parabólicas), minimiza erros de fase em precificação de opções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Método ADI (Alternating Direction Implicit)",
                        "description": "Método iterativo implícito alternado para equações parabólicas bidimensionais, com análise de convergência e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Descrever o algoritmo do método ADI",
                            "description": "Implementar o método ADI para a equação do calor 2D, detalhando as duas meias-passadas (x e y) e condições de contorno de Dirichlet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação do calor 2D e sua discretização por diferenças finitas",
                                  "subSteps": [
                                    "Escrever a equação do calor 2D: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²).",
                                    "Discretizar o domínio em uma grade uniforme com passos Δx, Δy e Δt.",
                                    "Aplicar a diferença finita explícita para entender limitações (condição CFL).",
                                    "Introduzir a necessidade de métodos implícitos para estabilidade incondicional.",
                                    "Derivar o esquema implícito completo em 2D e notar o sistema tridiagonal acoplado."
                                  ],
                                  "verification": "Capacidade de escrever a equação discretizada e explicar por que o esquema implícito completo é computacionalmente caro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, software de edição de equações (LaTeX ou MathType), livro de análise numérica (ex: Burden & Faires).",
                                  "tips": "Desenhe a grade 2D para visualizar os pontos vizinhos.",
                                  "learningObjective": "Compreender a base matemática da equação do calor e suas discretizações iniciais.",
                                  "commonMistakes": "Confundir derivadas espaciais com temporais; ignorar a soma das segundas derivadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o conceito do método ADI (Alternating Direction Implicit)",
                                  "subSteps": [
                                    "Explicar o princípio: decompor o operador Laplaciano em direções x e y alternadas.",
                                    "Descrever as duas meias-passadas por ciclo temporal completo.",
                                    "Mostrar que cada meia-passada resolve um sistema tridiagonal 1D (eficiente).",
                                    "Discutir a estabilidade incondicional para equações parabólicas.",
                                    "Comparar com métodos explícito e implícito completo em termos de custo computacional."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como o ADI alterna direções para reduzir complexidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Quadro branco ou software de desenho (ex: Draw.io), artigos sobre ADI (Peaceman & Rachford).",
                                  "tips": "Pense no ADI como 'meio implícito em x, meio implícito em y' por passo de tempo.",
                                  "learningObjective": "Dominar o conceito fundamental de alternância de direções no método ADI.",
                                  "commonMistakes": "Achar que ADI é totalmente explícito; confundir com método de direção alternada explícito (ADE)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar a meia-passada na direção x (primeira meia-passada)",
                                  "subSteps": [
                                    "Escrever a equação para a meia-passada x: resolver implicitamente em x e explicitamente em y.",
                                    "Derivar o sistema tridiagonal para pontos internos na direção x: a_i u_{i-1}^{n+1/2} + b_i u_i^{n+1/2} + c_i u_{i+1}^{n+1/2} = d_i.",
                                    "Definir coeficientes a_i, b_i, c_i e termo fonte d_i envolvendo u^n e termos y.",
                                    "Explicar resolução via Thomas algorithm (decomposição LU para tridiagonal).",
                                    "Aplicar condições de contorno de Dirichlet nas bordas x=0 e x=Lx."
                                  ],
                                  "verification": "Escrever corretamente os coeficientes do sistema tridiagonal para meia-passada x.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Python/MATLAB para testar coeficientes, grade de exemplo 5x5.",
                                  "tips": "Use notação superscrita para tempos: n para atual, n+1/2 para intermediário.",
                                  "learningObjective": "Formular e resolver o sistema da meia-passada x com precisão.",
                                  "commonMistakes": "Erros nos coeficientes de r = α Δt / (2 Δx²); esquecer termos explícitos de y."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar a meia-passada na direção y (segunda meia-passada)",
                                  "subSteps": [
                                    "Escrever a equação para meia-passada y usando solução intermediária de x.",
                                    "Derivar sistema tridiagonal similar, agora em y: implícito y, explícito x do passo anterior.",
                                    "Definir coeficientes análogos para direção y com passos Δy.",
                                    "Resolver novamente com algoritmo Thomas.",
                                    "Aplicar condições de Dirichlet nas bordas y=0 e y=Ly."
                                  ],
                                  "verification": "Comparar sistemas x e y, confirmando simetria e completude do ciclo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Mesmo do passo 3, adicionar pseudocódigo para ciclo completo.",
                                  "tips": "Note que Δx e Δy podem diferir, ajustando r_x e r_y.",
                                  "learningObjective": "Formular a meia-passada y e entender sua dependência da anterior.",
                                  "commonMistakes": "Usar u^n em vez de u^{n+1/2} no termo fonte; inverter ordem das passadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Descrever o algoritmo completo do ADI com condições de contorno",
                                  "subSteps": [
                                    "Esquematizar o loop temporal: inicializar u^0, repetir meias-passadas x e y até t_final.",
                                    "Incorporar condições de Dirichlet: fixar u nas bordas em cada iteração.",
                                    "Escrever pseudocódigo completo com resolução tridiagonal.",
                                    "Discutir precisão (ordem 2 em espaço/tempo) e convergência.",
                                    "Testar com exemplo numérico simples (placa aquecida)."
                                  ],
                                  "verification": "Implementar pseudocódigo e rodar para 2-3 iterações manualmente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python ou MATLAB para simulação, grade 10x10 exemplo.",
                                  "tips": "Sempre atualize bordas ANTES das passadas internas.",
                                  "learningObjective": "Sintetizar o algoritmo ADI completo e implementável.",
                                  "commonMistakes": "Esquecer atualizar solução intermediária; não tratar cantos das bordas corretamente."
                                }
                              ],
                              "practicalExample": "Considere uma placa quadrada 1x1 com u=0 nas bordas, inicial u(x,y,0)=sin(πx)sin(πy), α=1. Aplique ADI com Δx=Δy=0.1, Δt=0.01 por 10 passos: resolva meia x (tridiagonal 10x10), depois meia y, visualize evolução da temperatura.",
                              "finalVerifications": [
                                "Escrever pseudocódigo completo do ADI para equação do calor 2D.",
                                "Calcular manualmente uma iteração para grade 3x3.",
                                "Explicar estabilidade incondicional vs. métodos explícitos.",
                                "Identificar coeficientes tridiagonais corretos para ambas direções.",
                                "Aplicar Dirichlet corretamente em bordas e cantos.",
                                "Comparar ADI com esquema implícito completo em custo (O(N) vs O(N²))."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação dos sistemas tridiagonais (90% correto).",
                                "Clareza no pseudocódigo e fluxograma do algoritmo.",
                                "Correta incorporação de condições de Dirichlet.",
                                "Demonstração de estabilidade e ordem de precisão.",
                                "Exemplo numérico executado sem erros.",
                                "Explicação conceitual fluida (alternância de direções)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e parabólicas.",
                                "Computação: Algoritmos numéricos e resolução de sistemas lineares (Thomas).",
                                "Engenharia: Simulações em CFD e transferência de calor.",
                                "Matemática Aplicada: Análise de estabilidade von Neumann."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em painéis solares, previsão meteorológica (difusão de umidade), design de circuitos integrados (dissipação de calor em chips), e modelagem de reservatórios petrolíferos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Analisar convergência e estabilidade do ADI",
                            "description": "Provar a convergência do método ADI de Peaceman-Rachford usando análise espectral e verificar estabilidade incondicional para malhas retangulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulação do método ADI de Peaceman-Rachford",
                                  "subSteps": [
                                    "Estudar a equação parabólica modelo: ∂u/∂t = Δu em domínio retangular Ω = [0,a]×[0,b].",
                                    "Derivar o esquema ADI em duas direções: passo implícito em x, explícito em y, e vice-versa.",
                                    "Escrever as equações iterativas para o esquema de Peaceman-Rachford: (I - (Δt/2)δ_xx)u^{n+1/2} = (I + (Δt/2)δ_yy)u^n e (I - (Δt/2)δ_yy)u^{n+1} = (I + (Δt/2)δ_xx)u^{n+1/2}.",
                                    "Identificar os operadores de diferenças finitas δ_xx e δ_yy em malha retangular uniforme.",
                                    "Verificar consistência do esquema com a equação diferencial usando expansão de Taylor."
                                  ],
                                  "verification": "Capacidade de escrever corretamente as equações ADI e derivar a consistência de ordem O(Δt^2 + h^2 + k^2).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro 'Análise Numérica' de Burden/Faires, notas de aula sobre diferenças finitas, papel e lápis para derivações.",
                                  "tips": "Comece com o caso 1D para intuitar antes de 2D; desenhe a malha para visualizar passos alternados.",
                                  "learningObjective": "Compreender a estrutura algébrica do ADI e sua decomposição direcional.",
                                  "commonMistakes": "Confundir passos semi-implícitos; ignorar fatores de malha h_x ≠ h_y."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise espectral para convergência",
                                  "subSteps": [
                                    "Introduzir autovalores e autovetores dos operadores δ_xx e δ_yy: λ_p = -4/h_x^2 sin^2(π p h_x / (2a)), μ_q = -4/h_y^2 sin^2(π q h_y / (2b)).",
                                    "Calcular o fator de amplificação por iteração ADI: g(λ_p, μ_q) = [1 - (Δt/2)λ_p]/[1 + (Δt/2)λ_p] * [1 - (Δt/2)μ_q]/[1 + (Δt/2)μ_q].",
                                    "Provar |g(λ_p, μ_q)| ≤ 1 para todos modos espectrais, mostrando convergência.",
                                    "Analisar taxa de convergência: demonstrar que ||e^{n+1}|| ≤ ρ ||e^n|| com ρ < 1.",
                                    "Verificar convergência incondicional derivando que max |g| < 1 independentemente de Δt."
                                  ],
                                  "verification": "Derivação completa do fator g e prova de |g| < 1 com limite assintótico para Δt grande.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software MATLAB ou Python (NumPy/SciPy) para plotar |g| vs frequências, quadro branco para eigenanálise.",
                                  "tips": "Use identidade trigonométrica para maximizar |g|; plote superfícies 3D de |g| para visualização.",
                                  "learningObjective": "Dominar análise espectral de esquemas multi-etapa via produto de amplificadores 1D.",
                                  "commonMistakes": "Erro no sinal dos autovalores (devem ser negativos); esquecer normalização dos denominadores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar estabilidade incondicional para malhas retangulares",
                                  "subSteps": [
                                    "Definir norma espectral e provar ||A||_2 = max |autovalores de A|.",
                                    "Mostrar que para ADI, os autovalores do operador de amplificação satisfazem |ζ| ≤ 1.",
                                    "Derivar condição suficiente: para λ,μ < 0, |g|² = [(1 - rλ/2)/(1 + rλ/2)]² * [(1 - sμ/2)/(1 + sμ/2)]² ≤ 1 onde r=Δt, s=Δt.",
                                    "Analisar casos extremos: h→0 (alta frequência) e Δt→∞, confirmando |g|→1 mas <1.",
                                    "Comparar com Crank-Nicolson: destacar vantagem ADI em eficiência sem restrição CFL."
                                  ],
                                  "verification": "Prova analítica de estabilidade incondicional e gráfico de |g|_{max} <1 para vários r,s.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Artigo original Peaceman-Rachford (1955), MATLAB para eigenvalues numéricos em matrizes discretas.",
                                  "tips": "Use desigualdade | (1 - a)/(1 + a) | ≤ 1 para a>0; teste numericamente com matriz tridiagonal.",
                                  "learningObjective": "Provar estabilidade via análise von Neumann generalizada para métodos ADI.",
                                  "commonMistakes": "Confundir estabilidade com convergência; assumir malha quadrada quando retangular."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar prova completa e testar numericamente",
                                  "subSteps": [
                                    "Combinar análises: escrever teorema de convergência e estabilidade.",
                                    "Implementar ADI em código para equação do calor 2D e medir erro vs tempo.",
                                    "Comparar com método explícito: observar restrição CFL vs incondicional ADI.",
                                    "Analisar dependência em razão de malhas r = h_x / h_y.",
                                    "Documentar limitações: precisão ótima e custo por iteração."
                                  ],
                                  "verification": "Código funcional com erro L2 < 10^{-4} e relatório de análise.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python/MATLAB com solvers lineares (Thomas algorithm), dados de solução exata (série de Fourier).",
                                  "tips": "Use fatorização LU para passos implícitos; monitore resíduos espectrais.",
                                  "learningObjective": "Integrar teoria espectral com validação computacional.",
                                  "commonMistakes": "Erro de indexação na malha 2D; não normalizar solução inicial."
                                }
                              ],
                              "practicalExample": "Aplique ADI para resolver ∂u/∂t = Δu em [0,1]×[0,1] com u(x,y,0)=sin(πx)sin(πy), u=0 na borda. Use h_x=h_y=1/20, Δt=0.1; prove convergência medindo ||u_num - u_exata||_2 →0 e confirme estabilidade com Δt=10.",
                              "finalVerifications": [
                                "Derivação correta do fator de amplificação g(λ,μ).",
                                "Prova analítica de |g| < 1 para todos autovalores discretos.",
                                "Gráfico de |g|_{max} vs Δt mostrando independência de malha.",
                                "Implementação numérica com erro decaindo monotonicamente.",
                                "Explicação verbal da decomposição ADI sem erros conceituais.",
                                "Identificação correta de condições para malhas retangulares não-uniformes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação espectral (90% dos passos corretos).",
                                "Completude da prova de convergência (inclui limite Δt→∞).",
                                "Validação numérica com pelo menos duas malhas (erro O(h^2)).",
                                "Análise qualitativa de estabilidade vs outros métodos.",
                                "Clareza na documentação e gráficos de |g|.",
                                "Tratamento de casos degenerados (h_x ≠ h_y)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e fluxo de calor.",
                                "Computação: Algoritmos iterativos e solvers lineares tridiagonais.",
                                "Engenharia: Simulações CFD em geometrias retangulares.",
                                "Estatística: Análise de erros numéricos e convergência assintótica."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes em bacias retangulares urbanas, ou em engenharia aeroespacial para análise térmica de painéis retangulares sob carga variável, onde passos grandes Δt aceleram computações em malhas finas sem perda de estabilidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Comparar ADI com métodos uni-dimensionais",
                            "description": "Comparar eficiência computacional do ADI versus métodos explícitos e implícitos diretos em 2D, incluindo custo por passo de tempo e precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos dos Métodos",
                                  "subSteps": [
                                    "Estude a formulação do método ADI para equações parabólicas 2D, incluindo as duas direções alternadas.",
                                    "Revise métodos explícitos uni-dimensionais (ex: FTCS) e sua extensão direta para 2D.",
                                    "Analise métodos implícitos uni-dimensionais (ex: BTCS) e sua aplicação em malhas 2D via separação de variáveis ou iterações.",
                                    "Identifique as diferenças chave em termos de estrutura matricial e solução.",
                                    "Anote as condições de estabilidade para cada método."
                                  ],
                                  "verification": "Crie um diagrama comparativo resumindo as formulações e estabilidades de cada método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula de Análise Numérica II, livro de diferenças finitas (ex: LeVeque), papel e caneta.",
                                  "tips": "Use tabelas para organizar as formulações e condições CFL.",
                                  "learningObjective": "Compreender as bases matemáticas dos métodos para comparação posterior.",
                                  "commonMistakes": "Confundir ADI com métodos explícitos; ignorar a alternância de direções no ADI."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Custo Computacional por Passo de Tempo",
                                  "subSteps": [
                                    "Para métodos explícitos 2D: conte operações (multiplicações/somas) por célula, total O(N^2) onde N é pontos por dimensão.",
                                    "Para métodos implícitos diretos 2D: calcule inversão de matriz esparsa O(N^3) ou fatoração.",
                                    "Para ADI: decomponha em duas soluções 1D tridiagonais por passo, O(N^2) total.",
                                    "Compare flops por passo: explícito ~4N^2, implícito ~O(N^3), ADI ~8N^2.",
                                    "Considere overhead de armazenamento e iterações."
                                  ],
                                  "verification": "Elabore uma tabela com flops estimados para uma grade 100x100.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora ou Python para contagem simbólica, referências sobre complexidade de Thomas algorithm.",
                                  "tips": "Use o algoritmo de Thomas (O(N)) para soluções tridiagonais no ADI.",
                                  "learningObjective": "Quantificar o custo operacional de cada método em 2D.",
                                  "commonMistakes": "Subestimar custo de boundary conditions ou ignorar cache efficiency em grandes N."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Precisão e Estabilidade",
                                  "subSteps": [
                                    "Determine ordens de precisão: tipicamente O(Δt^2 + Δx^2) para ADI e implícitos, O(Δt + Δx^2) para explícitos.",
                                    "Compare raios de estabilidade: explícito limitado (CFL < 1/2 em 2D), ADI incondicionalmente estável.",
                                    "Calcule passos de tempo admissíveis: Δt_max explícito ~ O(Δx^2), ADI irrestrito.",
                                    "Avalie custo total até tempo T: número de passos × custo por passo.",
                                    "Discuta trade-offs precisão vs. custo para diferentes tamanhos de malha."
                                  ],
                                  "verification": "Plote curvas de estabilidade e estime tempo total de simulação para T=1.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de plotagem (Matplotlib/Python), tabelas de estabilidade de livros-texto.",
                                  "tips": "Normalize custos por unidade de tempo físico para comparação justa.",
                                  "learningObjective": "Avaliar trade-offs entre precisão, estabilidade e eficiência.",
                                  "commonMistakes": "Esquecer que custo total inclui número de passos até T fixo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Comparação Numérica Prática",
                                  "subSteps": [
                                    "Implemente códigos simples para ADI, explícito e implícito em Python para equação de calor 2D.",
                                    "Execute simulações em malha 50x50 até T=1, meça tempo de CPU e erro L2.",
                                    "Varie tamanhos de malha (25x25, 100x100) e registre eficiência (erro/tempo).",
                                    "Gere gráficos comparando curvas de erro vs. tempo computacional.",
                                    "Conclua vantagens do ADI para problemas grandes e estáveis."
                                  ],
                                  "verification": "Produza relatório com tabelas/gráficos mostrando ADI superior em eficiência para N>50.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/SciPy, Jupyter Notebook, solução analítica para validação.",
                                  "tips": "Use solução exata u(x,y,t)=exp(-π²t)sin(πx)sin(πy) para benchmark.",
                                  "learningObjective": "Validar comparações teóricas com evidências empíricas.",
                                  "commonMistakes": "Implementações ineficientes (vetorize com NumPy); grids muito pequenas mascaram diferenças."
                                }
                              ],
                              "practicalExample": "Para a equação de calor 2D ut = Δu em malha 100x100 com condições de Dirichlet, o método explícito requer ~10^5 passos (lento), implícito direto ~10^4 operações por passo (custoso), enquanto ADI usa 100 passos com ~10^4 ops cada, alcançando erro L2<10^-4 em 5s de CPU vs. 2min explícito.",
                              "finalVerifications": [
                                "Pode listar flops por passo corretamente para N=100.",
                                "Explica por que ADI é O(N^2) vs. O(N^3) implícito.",
                                "Identifica cenários onde explícito é preferível (malhas pequenas).",
                                "Calcula custo total até T=1 com precisão.",
                                "Compara estabilidades qualitativamente.",
                                "Interpreta resultados numéricos de simulações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações (erro <10%).",
                                "Correta identificação de ordens de complexidade.",
                                "Análise equilibrada de trade-offs precisão/estabilidade/custo.",
                                "Uso de evidências numéricas para suportar conclusões.",
                                "Clareza em tabelas/gráficos comparativos.",
                                "Conclusões alinhadas com literatura (ADI eficiente para 2D grandes)."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Análise de complexidade algorítmica e otimização de código.",
                                "Física: Modelagem de difusão em materiais 2D (ex: placas aquecidas).",
                                "Engenharia: Simulações CFD para escoamentos incompressíveis.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas 2D (previsão de temperatura), ADI permite grids finos sem restrições CFL, reduzindo tempo de computação de horas para minutos em supercomputadores, essencial para previsões em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Métodos para Equações Elípticas",
                    "description": "Aplicações com condições de Dirichlet e de Neumann.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Métodos de Diferenças Finitas para Condições de Dirichlet em Equações Elípticas",
                        "description": "Aborda a discretização de equações elípticas modelo, como a equação de Laplace ou Poisson, utilizando condições de Dirichlet, incluindo a formulação do esquema de diferenças finitas, análise de consistência e aplicação das condições de contorno prescritas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Derivar o esquema de diferenças finitas de 5 pontos para a equação de Laplace",
                            "description": "Derivar a aproximação de segunda ordem para o operador Laplaciano em uma malha uniforme retangular, resultando no stencil padrão de 5 pontos, e demonstrar sua consistência de ordem O(h²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação de Laplace e Configurar a Malha Uniforme",
                                  "subSteps": [
                                    "Escreva a equação de Laplace em 2D: ∇²u = ∂²u/∂x² + ∂²u/∂y² = 0.",
                                    "Defina uma malha retangular uniforme com espaçamento h em x e y.",
                                    "Indexe os pontos da malha como u_{i,j} ≈ u(x_i, y_j), onde x_i = i h, y_j = j h.",
                                    "Identifique um ponto interior genérico (i,j) e seus vizinhos.",
                                    "Esboce a malha no papel, destacando o stencil central."
                                  ],
                                  "verification": "Desenhe a malha com pelo menos 5x5 pontos e label o ponto (i,j) com seus 4 vizinhos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis",
                                    "Calculadora",
                                    "Referência: Livro de Análise Numérica (ex: LeVeque)"
                                  ],
                                  "tips": "Use coordenadas cartesianas para simplicidade; visualize como uma grade de pixels.",
                                  "learningObjective": "Compreender o problema contínuo e sua discretização inicial em malha uniforme.",
                                  "commonMistakes": [
                                    "Confundir equação de Laplace com Poisson (que tem termo fonte)",
                                    "Assumir malha não-uniforme prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Aproximação de Diferenças Finitas Centradas para ∂²u/∂x²",
                                  "subSteps": [
                                    "Expanda u(x+h,y) e u(x-h,y) em série de Taylor ao redor de (x,y).",
                                    "Some as expansões: u(x+h,y) + u(x-h,y) = 2u + (h²/3!) ∂⁴u/∂x⁴ + O(h⁴) + 2u.",
                                    "Divida por h²: [u(x+h,y) + u(x-h,y) - 2u]/h² = ∂²u/∂x² + O(h²).",
                                    "Substitua pelos índices da malha: [u_{i+1,j} + u_{i-1,j} - 2 u_{i,j}]/h² ≈ ∂²u/∂x²|_{i,j}.",
                                    "Confirme que a aproximação é de segunda ordem (erro O(h²))."
                                  ],
                                  "verification": "Escreva a equação exata da diferença finita para ∂²u/∂x² com termo de erro explícito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel para expansões de Taylor",
                                    "Tabela de derivadas de Taylor",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Mantenha os termos pares na soma para cancelar os ímpares.",
                                  "learningObjective": "Dominar a derivação da diferença finita centrada de segunda ordem para derivadas segundas.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 nas expansões pares",
                                    "Erro no sinal do termo de erro O(h²)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Aproximação para ∂²u/∂y² de Forma Analógica",
                                  "subSteps": [
                                    "Repita o processo de Taylor para u(x,y+h) e u(x,y-h).",
                                    "Obtenha [u_{i,j+1} + u_{i,j-1} - 2 u_{i,j}]/h² ≈ ∂²u/∂y²|_{i,j} + O(h²).",
                                    "Verifique a simetria entre as direções x e y devido à malha uniforme.",
                                    "Discuta por que diferenças forward/backward dariam apenas O(h), não O(h²).",
                                    "Escreva ambas as aproximações lado a lado para comparação."
                                  ],
                                  "verification": "Derive independentemente e confirme igualdade com a de x, exceto nos índices.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel com stencil anterior",
                                    "Calculadora para verificação numérica simples"
                                  ],
                                  "tips": "Copie a estrutura da derivação anterior para eficiência, mas entenda cada termo.",
                                  "learningObjective": "Aplicar o mesmo método de Taylor à direção y, reforçando consistência.",
                                  "commonMistakes": [
                                    "Misturar índices x e y",
                                    "Usar h diferente para x e y"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Aproximações para Formar o Stencil de 5 Pontos",
                                  "subSteps": [
                                    "Some as aproximações: ∂²u/∂x² + ∂²u/∂y² ≈ [u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4 u_{i,j}]/h².",
                                    "Defina o esquema: u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4 u_{i,j} = 0 (para ∇²u=0).",
                                    "Desenhe o stencil: 1/h² nos vizinhos, -4/h² no centro.",
                                    "Aplique condições de Dirichlet: u nas bordas é conhecido.",
                                    "Verifique dimensionalidade: esquema é consistente e simétrico."
                                  ],
                                  "verification": "Escreva o stencil matricial para um ponto interior e confirme soma dos coeficientes zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel para stencil",
                                    "Matriz 3x3 representando coeficientes"
                                  ],
                                  "tips": "Pense no stencil como um filtro convolução em processamento de imagens.",
                                  "learningObjective": "Construir o operador Laplaciano discreto completo de 5 pontos.",
                                  "commonMistakes": [
                                    "Esquecer o -4 no centro",
                                    "Não dividir por h² corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Demonstrar Consistência de Ordem O(h²)",
                                  "subSteps": [
                                    "Some os erros de truncamento: O(h²) de x + O(h²) de y = O(h²) total.",
                                    "Expanda completamente ∇²u usando Taylor para confirmar limite h→0 recupera equação exata.",
                                    "Discuta truncamento local: erro em cada equação é O(h²), levando a solução global O(h²).",
                                    "Teste numericamente: compare com solução exata em malha grosseira/fina.",
                                    "Conclua que o esquema é consistente de segunda ordem."
                                  ],
                                  "verification": "Calcule o erro de truncamento explícito e mostre que é proporcional a h².",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software como MATLAB/Python para teste numérico",
                                    "Solução analítica conhecida (ex: u=sin(πx)sin(πy))"
                                  ],
                                  "tips": "Use expansão bivariada de Taylor para rigor.",
                                  "learningObjective": "Provar a precisão e consistência do esquema derivado.",
                                  "commonMistakes": [
                                    "Ignorar termos de ordem superior mistos x-y",
                                    "Confundir consistência com convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere ∇²u=0 em um quadrado unitário [0,1]×[0,1] com u=sin(πx)sin(πy) nas bordas. Aplique o stencil de 5 pontos em um ponto interior (i=2,j=2) com h=1/4: verifique que u_{3,2}+u_{1,2}+u_{2,3}+u_{2,1}-4u_{2,2}=0 dentro de O(h²).",
                              "finalVerifications": [
                                "Escrever corretamente o stencil: u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0.",
                                "Derivar diferenças finitas para ∂²/∂x² e ∂²/∂y² com erro O(h²).",
                                "Desenhar e explicar o stencil de 5 pontos em uma malha 5x5.",
                                "Demonstrar soma das aproximações resulta em Laplaciano discreto.",
                                "Confirmar consistência: limite h→0 recupera ∇²u=0.",
                                "Aplicar stencil a um exemplo numérico simples sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de Taylor (sem erros em coeficientes).",
                                "Correção do stencil final e coeficientes (-4 centro, 1 vizinhos).",
                                "Explicação clara do erro de truncamento O(h²).",
                                "Uso apropriado de notação de índices e h uniforme.",
                                "Capacidade de aplicar a um exemplo concreto.",
                                "Raciocínio lógico sequencial nos passos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aproximação de potenciais eletrostáticos e campos gravitacionais.",
                                "Computação: Implementação de solvers iterativos como Gauss-Seidel em Python/MATLAB.",
                                "Engenharia: Simulação de tensões em placas elásticas ou fluxo de calor estacionário.",
                                "Processamento de Imagens: Filtros Laplacianos para detecção de bordas."
                              ],
                              "realWorldApplication": "Usado em simulações CFD para fluxo incompressível (vorticidade), modelagem de campos eletromagnéticos em capacitores, e análise de estruturas em engenharia civil para distribuições de tensão uniformes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Aplicar condições de Dirichlet em malhas 2D",
                            "description": "Implementar condições de Dirichlet incorporando valores prescritos nas fronteiras da malha, modificando o sistema linear resultante e resolvendo-o via métodos iterativos ou diretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a malha 2D e definir o problema elíptico",
                                  "subSteps": [
                                    "Defina o domínio geométrico (ex: quadrado [0,1]×[0,1]) e os parâmetros da malha (h_x, h_y, número de pontos).",
                                    "Especifique a equação elíptica (ex: -Δu = f) e as condições de Dirichlet nas fronteiras (u = g_i em cada borda).",
                                    "Gere os índices dos pontos internos e fronteira usando loops ou meshgrid.",
                                    "Implemente uma função para interpolar ou avaliar g_i nos pontos da fronteira.",
                                    "Visualize a malha inicial com Matplotlib para inspeção."
                                  ],
                                  "verification": "Verifique se o número de pontos internos e fronteira está correto e se os valores de g_i são aplicados sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Editor de código (Jupyter Notebook recomendado)"
                                  ],
                                  "tips": "Use np.meshgrid para gerar a malha de forma eficiente e evite malhas assimétricas inicialmente.",
                                  "learningObjective": "Compreender a estrutura da malha e como definir condições de contorno prescritas.",
                                  "commonMistakes": "Confundir índices de fronteira com internos; não normalizar o domínio para [0,1]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar a equação elíptica nos pontos internos",
                                  "subSteps": [
                                    "Aplique o esquema de diferenças finitas de segunda ordem para a equação (ex: stencil de 5 pontos para Laplace: u_{i,j} = (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1})/4 ).",
                                    "Inclua o termo fonte f se houver, multiplicando por h².",
                                    "Crie uma matriz de índices para mapear pontos internos a um vetor solução 1D.",
                                    "Teste a discretização em um ponto interno simples.",
                                    "Gere o vetor b inicial sem condições de fronteira."
                                  ],
                                  "verification": "Calcule manualmente o stencil para um ponto e compare com o código.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy para arrays",
                                    "Papel e lápis para stencil manual"
                                  ],
                                  "tips": "Numere os pontos internos em ordem lexicográfica (linha por linha) para facilitar a matriz esparsa.",
                                  "learningObjective": "Dominar a aproximação por diferenças finitas para operadores elípticos.",
                                  "commonMistakes": "Esquecer o fator h² no termo fonte; stencil incorreto em cantos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar condições de Dirichlet nas fronteiras",
                                  "subSteps": [
                                    "Identifique vizinhos de pontos internos que estão na fronteira.",
                                    "Modifique as linhas correspondentes na matriz A: defina diagonal como 1 e vetor b com g_i para pontos fronteira.",
                                    "Para pontos internos adjacentes à fronteira, substitua os valores desconhecidos por g_i no stencil.",
                                    "Atualize o vetor b somando contribuições das fronteiras (ex: (g_{direita})/4 no termo).",
                                    "Verifique simetria e propriedades da matriz resultante."
                                  ],
                                  "verification": "Extraia linhas da matriz A para pontos adjacentes à fronteira e confira manualmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy.sparse para matrizes esparsas (opcional)",
                                    "NumPy"
                                  ],
                                  "tips": "Use máscaras booleanas para identificar fronteiras e evite loops desnecessários com vetorização.",
                                  "learningObjective": "Implementar corretamente a modificação do sistema linear por condições prescritas.",
                                  "commonMistakes": "Não zerar coeficientes de fronteira em A; erros de indexação em malhas não uniformes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e resolver o sistema linear Ax = b",
                                  "subSteps": [
                                    "Construa a matriz A esparsa (csr_matrix do SciPy) ou densa para malhas pequenas.",
                                    "Implemente um solver direto (np.linalg.solve) ou iterativo (Gauss-Seidel ou scipy.sparse.linalg.cg).",
                                    "Execute a resolução e reshape o vetor solução para a malha 2D.",
                                    "Plote a solução com contourf ou pcolor no Matplotlib.",
                                    "Compare tempo de execução entre métodos direto e iterativo."
                                  ],
                                  "verification": "Resolva um problema analítico conhecido (ex: u=x y) e compare erro L2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "SciPy para solvers",
                                    "Matplotlib para visualização"
                                  ],
                                  "tips": "Para malhas grandes, prefira métodos iterativos; defina tolerância de 1e-6.",
                                  "learningObjective": "Resolver sistemas lineares oriundos de discretizações elípticas.",
                                  "commonMistakes": "Matriz A não simétrica positiva definida; solver inadequado para esparsidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar a solução",
                                  "subSteps": [
                                    "Calcule resíduos e norma do erro se solução exata disponível.",
                                    "Analise convergência iterativa (plots de erro por iteração).",
                                    "Estude refinamento de malha (h/2) e ordem de convergência.",
                                    "Compare com soluções referências ou software (ex: FEniCS).",
                                    "Documente observações em um relatório curto."
                                  ],
                                  "verification": "Erro diminui quadraticamente com h para esquema de 2ª ordem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy para normas",
                                    "Matplotlib para gráficos de convergência"
                                  ],
                                  "tips": "Use loglog plot para ordem de convergência: log(err) vs log(h).",
                                  "learningObjective": "Avaliar precisão e robustez da implementação.",
                                  "commonMistakes": "Ignorar efeitos de fronteira em erros; malhas muito grosseiras."
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 0 em [0,1]×[0,1] com u(0,y)=0, u(x,0)=0, u(x,1)=0, u(1,y)=sin(π y), usando malha uniforme 20×20. Solução aproximada deve coincidir com a exata u(x,y) = x sin(π y).",
                              "finalVerifications": [
                                "A malha 2D é gerada corretamente com pontos internos e fronteira identificados.",
                                "O sistema Ax=b incorpora todas as condições de Dirichlet sem vazamentos.",
                                "A solução numérica converge para a exata com refinamento de malha.",
                                "Visualizações mostram solução suave e compatível com fronteiras.",
                                "Tempo de resolução é eficiente (iterativo < direto para N>1000).",
                                "Erro L∞ nas fronteiras é <1e-10."
                              ],
                              "assessmentCriteria": [
                                "Correção na discretização (stencil exato, 20%)",
                                "Implementação precisa de Dirichlet (modificação A/b, 25%)",
                                "Eficiência do solver e convergência (20%)",
                                "Validação quantitativa (erros, ordem, 20%)",
                                "Código limpo, comentado e reproduzível (10%)",
                                "Análise de resultados com plots (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Potencial eletrostático em capacitores 2D.",
                                "Engenharia: Simulação de fluxo de calor em placas com temperaturas prescritas.",
                                "Programação: Uso de álgebra linear esparsa (SciPy).",
                                "Computação Científica: Introdução a PDEs numéricas.",
                                "Matemática Aplicada: Análise de erros e estabilidade."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em uma chapa metálica com bordas mantidas a temperaturas fixas (controle térmico em manufatura); modelagem de campos elétricos em dispositivos eletrônicos com eletrodos prescritos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Analisar consistência e convergência para Dirichlet",
                            "description": "Verificar a consistência do esquema via expansão de Taylor e discutir teoremas de convergência sob condições de Dirichlet, incluindo o erro de truncamento e normas adequadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Consistência via Expansão de Taylor",
                                  "subSteps": [
                                    "Relembre a definição de consistência em métodos numéricos para EDPs.",
                                    "Estude a expansão de Taylor para operadores diferenciais de segunda ordem.",
                                    "Derive a expansão para o operador Laplaciano discretizado em grade uniforme.",
                                    "Identifique os termos de ordem h² e h⁴ na expansão.",
                                    "Calcule o erro de truncamento local τ_h(u)."
                                  ],
                                  "verification": "Derive corretamente a expansão de Taylor para o Laplaciano 2D até ordem h⁴ e identifique o termo principal de erro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), caderno, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Use notação consistente para h (passo da grade) e indexação i,j.",
                                  "learningObjective": "Compreender como a expansão de Taylor quantifica a consistência do esquema de diferenças finitas.",
                                  "commonMistakes": "Esquecer termos mistos parciais ou confundir derivadas de primeira e segunda ordem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Expansão de Taylor à Discretização com Condições de Dirichlet",
                                  "subSteps": [
                                    "Configure o problema modelo: -Δu = f em Ω, u=g em ∂Ω (Dirichlet homogêneo).",
                                    "Escreva o esquema de diferenças finitas de 5 pontos para o interior da grade.",
                                    "Aplique condições de Dirichlet nas fronteiras interpolando g.",
                                    "Substitua a solução exata u na discretização e expanda via Taylor em pontos da grade.",
                                    "Some os erros locais para obter o erro de consistência global."
                                  ],
                                  "verification": "Mostre que o esquema é consistente de ordem 2 para condições de Dirichlet suaves.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Papel quadriculado, software Python/MATLAB para plotar grade, referências sobre EDPs elípticas.",
                                  "tips": "Assuma u ∈ C⁴(Ω) para validade da expansão até ordem necessária.",
                                  "learningObjective": "Aplicar análise de consistência específica para problemas elípticos com fronteiras Dirichlet.",
                                  "commonMistakes": "Ignorar o impacto das condições de fronteira na expansão perto da borda."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Erro de Truncamento e Estabilidade",
                                  "subSteps": [
                                    "Defina erro de truncamento local e global para o esquema.",
                                    "Estime ||τ_h||_∞ ≤ C h² para consistência.",
                                    "Discuta estabilidade via máximo princípio para operadores elípticos monotônicos.",
                                    "Verifique propriedades do operador discreto A_h (simétrico positivo definido).",
                                    "Relacione erro de truncamento com normas em espaços de Sobolev."
                                  ],
                                  "verification": "Prove que ||τ_h(u)|| ≤ K h² ||D⁴u|| para u suave.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Notas de aula sobre normas L² e H¹, calculadora.",
                                  "tips": "Use desigualdade triangular para somar erros locais.",
                                  "learningObjective": "Quantificar precisamente o erro de truncamento em esquemas finitos para Dirichlet.",
                                  "commonMistakes": "Confundir erro local com global ou superestimar ordem sem condições de suavidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Teoremas de Convergência e Normas Adequadas",
                                  "subSteps": [
                                    "Enuncie o teorema de Lax-Richtmyer adaptado para elípticos estacionários.",
                                    "Mostre convergência em norma L∞ ou H¹ sob consistência e estabilidade.",
                                    "Analise taxa de convergência O(h²) para soluções u ∈ H^{2+ε}(Ω).",
                                    "Escolha normas adequadas: ||e_h||_∞ ≤ C h² para máximo norma.",
                                    "Discuta condições de Dirichlet: regularidade da fronteira e dados f,g."
                                  ],
                                  "verification": "Escreva e prove um teorema de convergência completo para o método.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Artigo ou capítulo sobre teorema de convergência (ex: Gustafsson et al.), quadro branco.",
                                  "tips": "Lembre que para elípticos, estabilidade vem do máximo princípio, não CFL.",
                                  "learningObjective": "Dominar teoremas que garantem convergência sob condições de Dirichlet.",
                                  "commonMistakes": "Aplicar teoremas parabólicos a problemas elípticos sem adaptação."
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace Δu=0 em quadrado unitário [0,1]² com u(x,0)=u(x,1)=0, u(0,y)=sin(π y), u(1,y)=0. Discretize com h=1/10, compute expansão de Taylor no centro de uma célula, estime erro de truncamento, e verifique convergência comparando solução numérica com exata u(x,y)= (sin(π y) (1-x))/1.",
                              "finalVerifications": [
                                "Derivação correta da expansão de Taylor mostrando ordem h² de consistência.",
                                "Cálculo explícito do erro de truncamento local τ_h para Laplaciano.",
                                "Enunciação precisa do teorema de convergência para Dirichlet.",
                                "Seleção adequada de normas (L∞, H¹) com justificativa.",
                                "Análise de condições necessárias (suavidade de u, regularidade de ∂Ω).",
                                "Verificação numérica simples confirmando taxa O(h²)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de expansões de Taylor (90% dos termos corretos).",
                                "Compreensão conceitual de consistência vs. convergência (explicação clara).",
                                "Aplicação correta de teoremas (Lax-Richtmyer ou equivalente).",
                                "Uso apropriado de normas e estimativas de erro.",
                                "Identificação de erros comuns e condições de validade.",
                                "Capacidade de generalizar para outros problemas elípticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potenciais eletrostáticos com condições Dirichlet.",
                                "Computação: Implementação em Python (NumPy/SciPy) de solvers iterativos.",
                                "Engenharia: Análise de tensão em placas com bordas fixas.",
                                "Estatística: Métodos numéricos para EDPs estocásticas em finanças."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar fluxo incompressível ao redor de asas (equações elípticas com Dirichlet em superfícies), garantindo precisão numérica para otimizar designs e reduzir custos de testes físicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Métodos de Diferenças Finitas para Condições de Neumann em Equações Elípticas",
                        "description": "Explora a discretização de equações elípticas com condições de Neumann, utilizando pontos fictícios ou fórmulas de diferenças centradas assimétricas nas fronteiras, com ênfase em compatibilidade e tratamento de singularidades.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Discretizar condições de Neumann com pontos fictícios",
                            "description": "Introduzir pontos fictícios fora da malha para aproximar derivadas normais de primeira ordem nas fronteiras, derivando o stencil modificado e garantindo consistência O(h²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema elíptico com condições de Neumann",
                                  "subSteps": [
                                    "Revise a equação elíptica modelo, como -Δu = f em domínio Ω com ∂u/∂n = g em ∂Ω_N.",
                                    "Defina uma malha uniforme cartesiana com h como espaçamento.",
                                    "Identifique as fronteiras com condições de Neumann e posicione os pontos internos adjacentes.",
                                    "Desenhe a malha destacando a fronteira e o local para pontos fictícios fora da malha.",
                                    "Escreva o stencil padrão de diferenças finitas de segunda ordem para o operador Laplaciano."
                                  ],
                                  "verification": "Você pode esboçar a malha com pontos fictícios corretamente identificados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Referência de diferenças finitas"
                                  ],
                                  "tips": "Comece com um domínio retangular simples para visualização clara.",
                                  "learningObjective": "Compreender o setup do problema e a necessidade de pontos fictícios nas fronteiras Neumann.",
                                  "commonMistakes": [
                                    "Confundir condições Dirichlet com Neumann.",
                                    "Posicionar pontos fictícios dentro da malha.",
                                    "Ignorar a direção normal na fronteira."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir pontos fictícios e aproximar a derivada normal",
                                  "subSteps": [
                                    "Introduza pontos fictícios imediatamente fora da fronteira, ex: para y=0, ponto (i,0) fictício.",
                                    "Aproxime ∂u/∂n ≈ (u_{i,j+1} - u_{i,j-1}) / (2h) = g_i na fronteira.",
                                    "Escreva a equação explícita para o ponto fictício: u_{i,j-1} = u_{i,j+1} - 2h g_i.",
                                    "Verifique que essa aproximação é de segunda ordem O(h²) via análise de Taylor.",
                                    "Repita para outras fronteiras (esquerda, direita, superior)."
                                  ],
                                  "verification": "Derive corretamente a relação entre ponto fictício e pontos reais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use expansão de Taylor para confirmar a precisão: u(x-h) = u(x) - h u' + (h²/2) u'' - ...",
                                  "learningObjective": "Aproximar derivadas de primeira ordem com precisão O(h²) usando diferenças centradas.",
                                  "commonMistakes": [
                                    "Usar diferença forward/backward em vez de centrada, perdendo O(h²).",
                                    "Esquecer o fator 2h na relação do ponto fictício.",
                                    "Não considerar a normal inclinada em fronteiras não alinhadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o stencil modificado na fronteira",
                                  "subSteps": [
                                    "Escreva o stencil completo para um ponto na fronteira, incluindo o fictício.",
                                    "Substitua o ponto fictício pela relação derivada no passo anterior.",
                                    "Simplifique o stencil: ex: para Laplace, u_E + u_W + 2 u_N - 2 u_P = 2 h g (ajustado).",
                                    "Confirme que o coeficiente central permanece -4/h² ou similar para consistência.",
                                    "Geralize para equações elípticas não homogêneas."
                                  ],
                                  "verification": "O stencil modificado reproduz o original no interior e incorpora g corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "MATLAB/Python para stencil simbólico (opcional)"
                                  ],
                                  "tips": "Substitua sistematicamente e colete termos para evitar erros algébricos.",
                                  "learningObjective": "Eliminar variáveis fictícias e obter stencil fronteira acionável.",
                                  "commonMistakes": [
                                    "Erro na substituição levando a coeficientes errados.",
                                    "Manter o ponto fictício no sistema final.",
                                    "Não dividir corretamente pelo h² no Laplaciano."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar consistência e testar numericamente",
                                  "subSteps": [
                                    "Realize análise de erro de truncamento no stencil modificado via Taylor.",
                                    "Confirme ordem O(h²) para toda a discretização, incluindo fronteira.",
                                    "Implemente um exemplo 1D simples: -u''=0, u'(0)=1, u(1)=0, compare com solução exata.",
                                    "Estenda para 2D retangular com Neumann em uma face.",
                                    "Analise convergência reduzindo h."
                                  ],
                                  "verification": "Erro numérico diminui como O(h²) em simulações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Solução analítica de referência"
                                  ],
                                  "tips": "Use grids finos para validar; plote erro vs h em log-log.",
                                  "learningObjective": "Garantir precisão teórica e prática da discretização.",
                                  "commonMistakes": [
                                    "Ignorar termos de ordem superior na análise de Taylor.",
                                    "Condições de contorno inconsistentes no teste numérico.",
                                    "Má condicionalidade do sistema sem pré-condicionador."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere -Δu = 0 em [0,1]x[0,1], ∂u/∂y|_{y=0} = 0 (isolamento), u=0 nas outras bordas. Introduza pontos fictícios em j=0: u_{i,0} = u_{i,2} (pois g=0). Stencil em j=1: u_{i+1,1} + u_{i-1,1} + 2 u_{i,2} - 4 u_{i,1} + u_{i,1} wait, ajustado para (u_E + u_W + u_{i,2} + u_{i,0} -4u_P)/h²=0 → u_E + u_W + 2 u_{i,2} - 6 u_P =0 após sub.",
                              "finalVerifications": [
                                "Deriva corretamente a relação do ponto fictício para g arbitrário.",
                                "Stencil fronteira coincide com interior quando g=0.",
                                "Análise de Taylor mostra erro local O(h²).",
                                "Implementação numérica converge com ordem 2.",
                                "Sistema resultante é simétrico para Laplace.",
                                "Testa com g não-zero e valida solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da aproximação da derivada normal (O(h²)).",
                                "Correção algébrica na eliminação do ponto fictício.",
                                "Consistência do stencil modificado com o operador diferencial.",
                                "Validação numérica com exemplo concreto e análise de erro.",
                                "Generalização para múltiplas fronteiras Neumann.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de fluxos térmicos com isolamento (equação de calor estacionária).",
                                "Programação: Implementação em Python/NumPy para solvers de PDEs.",
                                "Engenharia: Simulações CFD com condições de fluxo nulo nas paredes.",
                                "Matemática Aplicada: Análise de erros em métodos numéricos.",
                                "Computação Científica: Pré-condicionadores para sistemas lineares elípticos."
                              ],
                              "realWorldApplication": "Em simulações de propagação de calor em paredes isoladas (Neumann g=0), ou fluxo de fluidos com velocidade tangencial zero nas fronteiras, essencial em engenharia térmica, acústica e geofísica para modelar domínios irregulares com precisão de segunda ordem."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Formular o sistema linear com condições de Neumann",
                            "description": "Montar o sistema de equações lineares para o problema elíptico com Neumann, considerando a condição de compatibilidade para solubilidade e resolvendo via relaxação ou métodos conjugados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema elíptico com condições de Neumann",
                                  "subSteps": [
                                    "Estude a equação elíptica padrão: -Δu = f em domínio Ω com ∂u/∂n = g na fronteira ∂Ω.",
                                    "Entenda que condições de Neumann especificam o fluxo normal, não o valor da função.",
                                    "Identifique a necessidade da condição de compatibilidade: ∫_Ω f dΩ = ∫_∂Ω g ds para solubilidade.",
                                    "Revise propriedades de soluções: única até constante aditiva.",
                                    "Discuta malha uniforme retangular para discretização."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre Dirichlet e Neumann, incluindo compatibilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula, calculadora"
                                  ],
                                  "tips": "Desenhe o domínio e fronteiras para visualizar fluxos.",
                                  "learningObjective": "Compreender o problema físico-matemático e suas restrições de solubilidade.",
                                  "commonMistakes": [
                                    "Confundir Neumann com Dirichlet; ignorar a constante aditiva na unicidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar pontos interiores com diferenças finitas",
                                  "subSteps": [
                                    "Aplique stencil de 5 pontos para -Δu ≈ (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² = f_{i,j}.",
                                    "Escreva a equação para um ponto interior genérico (i,j).",
                                    "Multiplique por h² para obter equação em termos de u's vizinhas.",
                                    "Identifique o coeficiente diagonal -4 e off-diagonal 1.",
                                    "Teste com f constante para verificar."
                                  ],
                                  "verification": "Derive a equação para um ponto específico e confira com stencil padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel quadriculado, Python/MATLAB para stencil visual",
                                    "Referência: Burden & Faires"
                                  ],
                                  "tips": "Use índices i,j para sistematizar; comece com h=1 para simplificar.",
                                  "learningObjective": "Dominar a discretização central de segunda ordem para Laplace/Poisson.",
                                  "commonMistakes": [
                                    "Erro no sinal do Laplaciano; esquecer multiplicar por h²."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar condições de Neumann nas fronteiras",
                                  "subSteps": [
                                    "Para borda direita (j=N), aproxime ∂u/∂x ≈ (u_{i+1,N} - u_{i,N})/h = g_{i,N}, introduzindo u fictício.",
                                    "Substitua u_{i+1,N} = u_{i,N} + h g_{i,N} na equação interior do ponto i,N.",
                                    "Faça o mesmo para outras bordas: esquerda, superior, inferior.",
                                    "Ajuste coeficientes: diagonal torna-se -3, off-diagonal vizinho ganha +1 + h g / h².",
                                    "Verifique simetria da matriz resultante."
                                  ],
                                  "verification": "Escreva equações para 2 pontos de borda e confira que incorporam g corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software para plotar malha (Matplotlib), exemplos resolvidos"
                                  ],
                                  "tips": "Use pontos fantasmas externamente para Neumann; teste com g=0 (Neumann homogêneo).",
                                  "learningObjective": "Aplicar aproximação de diferenças finitas para derivadas normais na fronteira.",
                                  "commonMistakes": [
                                    "Usar forward/backward inconsistente; não ajustar coeficientes corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o sistema linear Ax=b e verificar compatibilidade",
                                  "subSteps": [
                                    "Numere os pontos da malha em vetor x (ex: ordem linha por linha).",
                                    "Construa matriz A esparsa (tridiagonal-like) e vetor b incluindo f e termos de g.",
                                    "Implemente soma das linhas de A deve ser zero para Neumann puro (propriedade).",
                                    "Verifique compatibilidade discretizada: soma b ≈ soma integral f e g.",
                                    "Discuta solvers: Gauss-Seidel relaxação ou gradiente conjugado para A simétrica definida semi positiva."
                                  ],
                                  "verification": "Monte A e b para malha 3x3, resolva e cheque resíduos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com SciPy para sparse matrices, Jupyter notebook"
                                  ],
                                  "tips": "Use spy(A) para visualizar esparsidade; fixe u em um ponto para remover singularidade.",
                                  "learningObjective": "Formular e validar o sistema linear completo para Neumann.",
                                  "commonMistakes": [
                                    "Numeração errada levando a A assimétrica; esquecer fixar grau de liberdade."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Resolver e validar a solução numérica",
                                  "subSteps": [
                                    "Implemente relaxação de Jacobi/SOR: x^{k+1} = D^{-1}(b - (L+U)x^k).",
                                    "Ou use gradiente conjugado: iterativo para sistemas simétricos.",
                                    "Monitore convergência com norma do resíduo ||Ax - b|| < tol.",
                                    "Compare com solução exata se disponível (ex: u linear).",
                                    "Analise erro de ordem O(h²)."
                                  ],
                                  "verification": "Obtenha solução convergida e plote u; verifique ∂u/∂n ≈ g na borda.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB pronto para solvers iterativos"
                                  ],
                                  "tips": "ω=1.8 para SOR ótimo em 1D; pré-condicione com diagonal para CG.",
                                  "learningObjective": "Aplicar e avaliar métodos iterativos para sistemas de Neumann.",
                                  "commonMistakes": [
                                    "Não monitorar convergência; ignorar singularidade sem fixação."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere -Δu = 2π² sin(πx) sin(πy) em [0,1]x[0,1] com ∂u/∂n = 0 (Neumann homogêneo). Solução exata u=sin(πx)sin(πy). Monte malha 5x5, formule Ax=b, resolva com CG e compare erros.",
                              "finalVerifications": [
                                "Matriz A é simétrica e soma de linhas ≈0.",
                                "Condição de compatibilidade discretizada satisfeita: soma b =0 para homogêneo.",
                                "Solução converge em <100 iterações com tol=1e-6.",
                                "Derivadas normais na borda aproximam g dentro de O(h).",
                                "Erro L2 da solução < O(h²) vs exata.",
                                "Plot de u mostra suavidade esperada."
                              ],
                              "assessmentCriteria": [
                                "Correção na discretização interior e fronteira (20%).",
                                "Formulação precisa de A e b, incluindo g (25%).",
                                "Verificação de compatibilidade e propriedades de A (20%).",
                                "Implementação e convergência do solver (20%).",
                                "Análise de erros e validação (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos eletrostáticos/potencial com fluxos isolados.",
                                "Engenharia: Simulação de fluxo de calor com isolamento térmico (Neumann=0).",
                                "Computação: Algoritmos iterativos e álgebra linear esparsa (SciPy/PETSc).",
                                "Estatística: Problemas de Bayes com priors não-informativos (análogos).",
                                "Otimização: Sistemas KKT com multiplicadores de Lagrange."
                              ],
                              "realWorldApplication": "Em engenharia térmica, simular distribuição de temperatura em uma placa isolada nas bordas (Neumann=0) com fontes internas de calor; usado em design de dissipadores de calor para eletrônicos ou painéis solares."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Avaliar estabilidade e convergência para Neumann",
                            "description": "Discutir propriedades espectrais do operador discretizado, analisar a estabilidade do método de relaxação de Jacobi/Gauss-Seidel e estimar taxas de convergência sob condições de Neumann homogêneas ou não.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar discretização das equações elípticas com condições de Neumann",
                                  "subSteps": [
                                    "Estudar a formulação da equação de Poisson/Laplace em domínio com condições de Neumann homogêneas e não-homogêneas.",
                                    "Derivar o esquema de diferenças finitas centradas para a fronteira Neumann, incorporando a aproximação de segunda ordem.",
                                    "Montar a matriz do operador discretizado A, identificando sua estrutura simétrica e definida positiva.",
                                    "Verificar compatibilidade para Neumann não-homogêneo via condição de solvibilidade.",
                                    "Implementar numericamente um exemplo simples em grade 1D para validar."
                                  ],
                                  "verification": "Construir corretamente a matriz A para um problema teste e resolver via solver direto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "MATLAB/Python com NumPy/SciPy",
                                    "Notas de aula sobre diferenças finitas"
                                  ],
                                  "tips": [
                                    "Use simetria da matriz para reduzir computação.",
                                    "Sempre normalize o vetor de condições de contorno."
                                  ],
                                  "learningObjective": "Compreender como as condições de Neumann afetam a discretização e a estrutura matricial.",
                                  "commonMistakes": [
                                    "Ignorar a condição de compatibilidade.",
                                    "Usar diferenças forward/backward sem correção de ordem."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar propriedades espectrais do operador discretizado",
                                  "subSteps": [
                                    "Calcular autovalores e autovetores da matriz A para grades uniformes.",
                                    "Demonstrar que A é simétrica positiva definida (SPD) para Neumann homogêneo.",
                                    "Estimar o raio espectral ρ(A) e o número de condição cond(A).",
                                    "Analisar dependência em malha h: autovalor mínimo ~ h², máximo ~ 1/h².",
                                    "Usar teorema de Gershgorin para bornas espectrais aproximadas."
                                  ],
                                  "verification": "Plotar espectro de autovalores para grades crescentes e confirmar bornas teóricas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software eig (MATLAB/Python)",
                                    "Exemplos computacionais de operadores Laplace discretos"
                                  ],
                                  "tips": [
                                    "Diagonalize em bases de Fourier para domínios regulares.",
                                    "Foquem em autovalor menor para convergência."
                                  ],
                                  "learningObjective": "Dominar o espectro de A como base para análises de estabilidade e convergência.",
                                  "commonMistakes": [
                                    "Confundir raio espectral com norma.",
                                    "Negligir singularidade em Neumann puro."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar estabilidade do método de relaxação de Jacobi",
                                  "subSteps": [
                                    "Escrever o iterativo Jacobi: x^{k+1} = D^{-1}(b - (L+U)x^k).",
                                    "Derivar a matriz de iteração G_J = -D^{-1}(L+U) e sua norma espectral ρ(G_J) < 1.",
                                    "Provar ρ(G_J) ≈ 1 - O(h²) usando propriedades espectrais de A.",
                                    "Simular iterações em exemplo Neumann e medir taxa de amortecimento.",
                                    "Discutir impacto de Neumann não-homogêneo na estabilidade."
                                  ],
                                  "verification": "Executar 100 iterações e verificar ||e^k|| diminui monotonicamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Jacobi pronto",
                                    "Gráficos de erro vs iterações"
                                  ],
                                  "tips": [
                                    "Pré-condicione com diagonal para aceleração.",
                                    "Monitore resíduos r^k = b - Ax^k."
                                  ],
                                  "learningObjective": "Analisar condições de estabilidade via ρ(G) < 1 para Jacobi em Neumann.",
                                  "commonMistakes": [
                                    "Esquecer normalização em Neumann não-homogêneo.",
                                    "Usar norma errada para ρ."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência de Gauss-Seidel e estimar taxas",
                                  "subSteps": [
                                    "Formular Gauss-Seidel: x^{k+1/2} = D^{-1}(b - L x^{k+1/2} - U x^k).",
                                    "Comparar ρ(G_GS) ≤ [ρ(G_J)]² < ρ(G_J), provando aceleração.",
                                    "Estimar número de iterações N ≈ log(ε)/log(ρ) para erro ε.",
                                    "Avaliar para Neumann homogêneo (puro relaxação) vs não-homogêneo (com correção).",
                                    "Testar numericamente e plotar curvas de convergência."
                                  ],
                                  "verification": "Comparar N_Jacobi vs N_GS em mesmo problema, confirmando aceleração.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Implementações Jacobi/GS",
                                    "Ferramentas de plotting (Matplotlib)"
                                  ],
                                  "tips": [
                                    "GS é ótimo para SPD.",
                                    "Use multigrid para h pequena."
                                  ],
                                  "learningObjective": "Estimar taxas de convergência e comparar métodos sob Neumann.",
                                  "commonMistakes": [
                                    "Assumir independência de fronteiras.",
                                    "Subestimar custo por iteração em GS."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação -Δu = f em quadrado unitário com ∂u/∂n = g na fronteira (Neumann não-homogêneo). Discretize com h=1/32, aplique Jacobi/GS e compare 50 iterações: GS converge em ~20 iterações vs 40 para Jacobi, com erro final <10^{-6}.",
                              "finalVerifications": [
                                "Explicar por que ρ(G_J) →1 quando h→0.",
                                "Calcular bornas espectrais para A em 1D.",
                                "Simular e plotar log(erros) linear para taxa de convergência.",
                                "Discutir singularidade em Neumann homogêneo puro.",
                                "Comparar estabilidade Jacobi vs GS em exemplo numérico.",
                                "Verificar compatibilidade ∫f = ∫g."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação de G_J e G_GS.",
                                "Estimativa precisa de ρ baseada em espectro de A.",
                                "Análise qualitativa/quantitativa de taxas de convergência.",
                                "Tratamento adequado de Neumann homogêneo/não-homogêneo.",
                                "Validação numérica com gráficos de erro.",
                                "Identificação de limitações (h pequena)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos escalares com isolamento (calor, potencial).",
                                "Computação: Algoritmos iterativos e análise de complexidade O(N log(1/ε)).",
                                "Engenharia: Simulações CFD com condições de fluxo nulo.",
                                "Estatística: Métodos de suavização em imagens com bordas livres."
                              ],
                              "realWorldApplication": "Em simulações de fluxo térmico em paredes isoladas (Neumann=0), avaliar se Jacobi/GS convergem rápido o suficiente para malhas industriais, otimizando tempo de computação em softwares como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Métodos para Equações Hiperbólicas",
                    "description": "Métodos explícitos e implícitos para resolução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Métodos Explícitos para Equações Hiperbólicas",
                        "description": "Métodos numéricos explícitos baseados em diferenças finitas para resolver equações hiperbólicas, como a equação de advecção ou de onda, focando em esquemas como FTCS (Forward-Time Central-Space) e análise de estabilidade via condição CFL.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Derivação do esquema FTCS para equação de advecção",
                            "description": "Derivar o esquema de diferenças finitas explícito FTCS para a equação de advecção unidimensional ∂u/∂t + a ∂u/∂x = 0, identificando os operadores de diferença forward em tempo e central em espaço, e calcular a ordem de truncamento local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a equação de advecção e estabelecer a malha numérica",
                                  "subSteps": [
                                    "Escreva a equação diferencial parcial (EDP) unidimensional: ∂u/∂t + a ∂u/∂x = 0, onde a é a velocidade de advecção constante.",
                                    "Defina a malha espacial uniforme com passos Δx e pontos x_i = i Δx para i=0,1,...,N.",
                                    "Defina a malha temporal com passos Δt e tempos t_n = n Δt para n=0,1,...",
                                    "Aproxime a solução u(x_i, t_n) por u_i^n."
                                  ],
                                  "verification": "Verifique se a notação da EDP e da malha está correta e consistente em um rascunho.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de anotações como Jupyter Notebook",
                                    "Livro-texto de análise numérica (ex: LeVeque 'Finite Difference Methods')"
                                  ],
                                  "tips": "Mantenha a notação padrão: subscrito i para espaço, sobrescrito n para tempo.",
                                  "learningObjective": "Compreender a discretização do domínio contínuo em uma grade numérica finita.",
                                  "commonMistakes": [
                                    "Confundir notação espacial (i) com temporal (n)",
                                    "Esquecer que a é constante positiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a aproximação de diferenças finitas forward para a derivada temporal ∂u/∂t",
                                  "subSteps": [
                                    "Expanda u(x_i, t_n + Δt) em série de Taylor ao redor de t_n: u_i^{n+1} = u_i^n + Δt (∂u/∂t)_i^n + (Δt)^2/2 (∂²u/∂t²)_i^n + O(Δt^3).",
                                    "Reorganize para isolar a derivada temporal: (∂u/∂t)_i^n ≈ (u_i^{n+1} - u_i^n)/Δt.",
                                    "Identifique o erro de truncamento local: O(Δt), devido ao termo (Δt)/2 (∂²u/∂t²)."
                                  ],
                                  "verification": "Confirme a expansão de Taylor e a forma da aproximação forward com erro O(Δt) anotados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Folha de derivadas de Taylor pré-prontas"
                                  ],
                                  "tips": "Visualize o stencil: envolve u_i^{n+1} e u_i^n no tempo.",
                                  "learningObjective": "Dominar a derivação da diferença forward e seu erro de ordem.",
                                  "commonMistakes": [
                                    "Usar diferença backward em vez de forward",
                                    "Esquecer o fator 1/2 no termo de erro de segunda ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a aproximação de diferenças finitas central para a derivada espacial ∂u/∂x",
                                  "subSteps": [
                                    "Expanda u(x_i + Δx/2, t_n) e u(x_i - Δx/2, t_n) em séries de Taylor ao redor de x_i.",
                                    "Some as expansões e isole ∂u/∂x: (∂u/∂x)_i^n ≈ [u_{i+1}^n - u_{i-1}^n] / (2 Δx).",
                                    "Identifique o erro de truncamento local: O(Δx²), pois os termos de primeira ordem se cancelam."
                                  ],
                                  "verification": "Verifique as expansões simétricas e a fórmula central com erro O(Δx²).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para expansões",
                                    "Referência de operadores de diferenças finitas"
                                  ],
                                  "tips": "Note a simetria: stencil [-1/2, 0, 1/2] em espaço.",
                                  "learningObjective": "Entender a precisão de segunda ordem da diferença central.",
                                  "commonMistakes": [
                                    "Confundir com forward/backward em espaço",
                                    "Calcular mal os termos pares/impares nas expansões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar as aproximações para formar o esquema FTCS e calcular a ordem de truncamento total",
                                  "subSteps": [
                                    "Substitua as aproximações na EDP discretizada: u_i^{n+1} - u_i^n + a Δt (∂u/∂x)_i^n ≈ 0.",
                                    "Insira a diferença central: u_i^{n+1} = u_i^n - [a Δt / (2 Δx)] (u_{i+1}^n - u_{i-1}^n).",
                                    "Some os erros de truncamento: ordem local total O(Δt + Δx²), identificando FTCS como forward-tempo central-espaço."
                                  ],
                                  "verification": "Escreva o esquema final e confirme a ordem de truncamento O(Δt + Δx²).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo numérico simples para testar",
                                    "Software para verificação simbólica"
                                  ],
                                  "tips": "Lembre-se: CFL condition virá depois, foque na derivação.",
                                  "learningObjective": "Sintetizar o esquema explícito FTCS e analisar sua precisão.",
                                  "commonMistakes": [
                                    "Erro no sinal da advecção (deve ser -a)",
                                    "Ignorar o fator 1/2 na diferença central"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e documentar o esquema completo FTCS",
                                  "subSteps": [
                                    "Reescreva o esquema identificando explicitamente os operadores: forward em t, central em x.",
                                    "Confirme consistência aproximando a EDP original quando Δt, Δx → 0.",
                                    "Anote limitações iniciais, como instabilidade para a Δt/Δx > 1 (sem prova)."
                                  ],
                                  "verification": "Produza um resumo escrito com esquema, operadores e ordem de truncamento.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Template de relatório de derivação"
                                  ],
                                  "tips": "Use LaTeX ou Markdown para notação clara se digital.",
                                  "learningObjective": "Consolidar o conhecimento em uma forma reutilizável.",
                                  "commonMistakes": [
                                    "Omitir identificação explícita de FTCS",
                                    "Confundir ordem local com global"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação ∂u/∂t + ∂u/∂x = 0 (a=1) com u(x,0)=sen(2πx). Na malha Δx=0.1, Δt=0.01, para i=5, n=2: u_5^3 = u_5^2 - 0.05 (u_6^2 - u_4^2). Calcule numericamente assumindo valores iniciais.",
                              "finalVerifications": [
                                "Escreve corretamente o esquema FTCS: u_i^{n+1} = u_i^n - (a Δt)/(2 Δx) (u_{i+1}^n - u_{i-1}^n)",
                                "Identifica precisamente o operador forward em tempo e central em espaço",
                                "Calcula a ordem de truncamento local como O(Δt + Δx²)",
                                "Explica as expansões de Taylor usadas em cada derivada",
                                "Demonstra consistência da aproximação com a EDP original",
                                "Descreve o stencil temporal-espacial corretamente",
                                "Menciona potenciais issues como estabilidade (von Neumann após)"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática completa nas expansões de Taylor (100%)",
                                "Precisão na identificação de operadores e erros de truncamento",
                                "Clareza na derivação passo a passo com notação consistente",
                                "Capacidade de combinar aproximações sem erros algébricos",
                                "Profundidade na análise de ordens: O(Δt) temporal e O(Δx²) espacial",
                                "Exemplo prático resolvido corretamente",
                                "Documentação organizada e legível"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação hiperbólica",
                                "Engenharia Computacional: Base para solvers CFD em OpenFOAM ou MATLAB",
                                "Programação: Implementação em Python com NumPy para simulações",
                                "Matemática Aplicada: Análise de estabilidade via amplificação von Neumann",
                                "Ciência de Dados: Aproximações numéricas em ML para PDEs"
                              ],
                              "realWorldApplication": "O esquema FTCS é fundamental em simulações de transporte de poluentes em rios (advecção dominante), previsão de tráfego rodoviário, modelagem de frentes meteorológicas em previsões do tempo e animações de fluidos em jogos/vfx, onde se propaga informação sem difusão artificial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Análise de estabilidade do método explícito",
                            "description": "Aplicar a análise de von Neumann para determinar a condição de estabilidade CFL (Courant-Friedrichs-Lewy) no esquema FTCS, identificando o número de Courant σ ≤ 1 como critério para estabilidade e explicando o fenômeno de instabilidade osmótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o esquema FTCS para equações hiperbólicas",
                                  "subSteps": [
                                    "Revise a equação de advecção linear u_t + c u_x = 0.",
                                    "Descreva o esquema FTCS: u_j^{n+1} = u_j^n - (σ/2) (u_{j+1}^n - u_{j-1}^n), onde σ = c Δt / Δx.",
                                    "Implemente o esquema em pseudocódigo ou código simples.",
                                    "Execute uma simulação numérica inicial com σ < 1 para observar comportamento.",
                                    "Compare com a solução exata para validar a discretização."
                                  ],
                                  "verification": "Capacidade de escrever e executar o esquema FTCS corretamente, produzindo uma solução estável para σ ≤ 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Python ou MATLAB com NumPy",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com condições iniciais simples como uma gaussiana para visualizar propagação.",
                                  "learningObjective": "Entender a formulação discreta do método explícito FTCS e seu papel em aproximar equações hiperbólicas.",
                                  "commonMistakes": [
                                    "Confundir FTCS com upwind (que usa diferenças direcionais)",
                                    "Esquecer de normalizar σ corretamente",
                                    "Usar Δt muito grande sem verificar estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise de estabilidade de von Neumann",
                                  "subSteps": [
                                    "Explique os princípios: assumir solução modal e^{i (k j Δx - ω n Δt)} e derivar o fator de amplificação g.",
                                    "Defina a condição de estabilidade: |g(k Δx)| ≤ 1 + O(Δt) para todos os modos k.",
                                    "Discuta o espectro de frequências: θ = k Δx de 0 a 2π.",
                                    "Revise transformada de Fourier discreta e sua relação com erros numéricos.",
                                    "Pratique com um exemplo parabólico simples para analogia."
                                  ],
                                  "verification": "Desenhe o diagrama de von Neumann e explique verbalmente os passos para um colega.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Slides ou vídeo sobre von Neumann",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Visualize modos de alta frequência (θ ≈ π) que são mais propensos a instabilidade.",
                                  "learningObjective": "Dominar os fundamentos teóricos da análise de von Neumann para esquemas de diferenças finitas.",
                                  "commonMistakes": [
                                    "Ignorar a dependência em θ",
                                    "Confundir g com o símbolo de Fourier",
                                    "Não considerar todos os modos espaciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o fator de amplificação para o esquema FTCS",
                                  "subSteps": [
                                    "Substitua a forma modal u_j^n = g^n e^{i θ j} no esquema FTCS.",
                                    "Derive a equação para g: g = 1 - i σ sin(θ).",
                                    "Calcule |g|^2 = 1 + σ² sin²(θ).",
                                    "Analise |g| ≤ 1 para todos θ, concluindo que requer σ ≤ 0 (instável exceto σ=0), mas contextualize para variantes com σ ≤1.",
                                    "Note: Para FTCS puro em hiperbólica, instável; discuta correção para upwind/Lax onde σ ≤1 vale."
                                  ],
                                  "verification": "Derive algebricamente |g(θ)| e plote vs θ para diferentes σ usando software.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "SymPy ou Mathematica para simplificação simbólica",
                                    "Matplotlib para plotar |g(θ)|",
                                    "Artigo sobre estabilidade FTCS"
                                  ],
                                  "tips": "Use expansão em série de Taylor para aproximar g perto de θ=0.",
                                  "learningObjective": "Executar o cálculo explícito do fator de amplificação e interpretá-lo.",
                                  "commonMistakes": [
                                    "Erro no sinal da derivada central: sin(θ) vs i sin(θ)",
                                    "Esquecer o módulo |g|^2",
                                    "Não plotar para validar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a condição CFL e explicar instabilidade osmótica",
                                  "subSteps": [
                                    "Interprete |g| >1 para σ >0 em FTCS puro, levando a amplificação exponencial.",
                                    "Explique CFL geral: σ ≤1 garante que informação não ultrapasse domínio de dependência.",
                                    "Descreva instabilidade osmótica: oscilações de alta frequência crescendo como 'osmose' numérica, dissipando energia errada.",
                                    "Simule numericamente σ=0.5 (estável aproximado) vs σ=1.5 (instável com oscilações).",
                                    "Discuta remédios: usar upwind ou Lax-Friedrichs para σ ≤1 estável."
                                  ],
                                  "verification": "Simulação numérica mostrando instabilidade para σ>1 e explicação escrita.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python para simulação 1D",
                                    "Gráficos de evolução temporal",
                                    "Referência: livros de PDE numéricas"
                                  ],
                                  "tips": "Use condições periódicas para isolar estabilidade von Neumann.",
                                  "learningObjective": "Aplicar resultados para prever estabilidade e diagnosticar instabilidades numéricas.",
                                  "commonMistakes": [
                                    "Confundir instabilidade osmótica com dispersão",
                                    "Ignorar que FTCS hiperbólica requer modificações",
                                    "Não simular para validar teoria"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação u_t + u_x = 0 com u(x,0) = sen(2π x), Δx=0.01, Δt=0.005 (σ=0.5). Implemente FTCS, rode 1000 passos, compare com exata; aumente para σ=1.5 e observe oscilações crescendo.",
                              "finalVerifications": [
                                "Deriva corretamente g(θ) = 1 - i σ sin(θ) para FTCS.",
                                "Identifica σ ≤1 como CFL para variantes estáveis.",
                                "Explica por que |g| >1 leva a instabilidade.",
                                "Simula e diagnostica instabilidade osmótica.",
                                "Compara von Neumann com análise energia.",
                                "Aplica a outro esquema explícito similar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica do fator g (sem erros aritméticos).",
                                "Correta interpretação da condição |g| ≤1 para todos θ.",
                                "Qualidade da simulação numérica (gráficos claros, parâmetros apropriados).",
                                "Explicação clara da instabilidade osmótica com evidências visuais.",
                                "Conexão com CFL geral e domínio de dependência.",
                                "Capacidade de generalizar para outros métodos explícitos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e CFL em simulações hidrodinâmicas.",
                                "Computação: Implementação eficiente em Python/NumPy para PDEs.",
                                "Engenharia: Estabilidade em modelagem de fluxos (tráfego, fluidos).",
                                "Matemática Aplicada: Análise de Fourier e estabilidade linear."
                              ],
                              "realWorldApplication": "Em simulações CFD para previsão de tempo, aviação (choques supersônicos) ou finanças (modelos de Black-Scholes discretos), a condição CFL garante simulações estáveis sem blow-up numérico, evitando erros catastróficos em previsões reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Implementação numérica de método explícito",
                            "description": "Implementar em pseudocódigo ou código simples (ex: Python/MATLAB) o esquema FTCS para resolver a equação de advecção com condições iniciais e de contorno periódicas, verificando a condição CFL e plotando soluções numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a equação de advecção, condições iniciais/de contorno e parâmetros de discretização",
                                  "subSteps": [
                                    "Escreva a equação de advecção ∂u/∂t + c ∂u/∂x = 0, especificando o valor de c (ex: c=1).",
                                    "Defina as condições iniciais, como u(x,0) = sin(2πx/L) para x ∈ [0, L], com L=1.",
                                    "Estabeleça condições de contorno periódicas: u(0,t) = u(L,t).",
                                    "Escolha parâmetros: número de pontos espaciais Nx=100 (Δx = L/Nx), passos temporais Nt=1000 e Δt inicial.",
                                    "Calcule o número de CFL preliminar: σ = c Δt / Δx."
                                  ],
                                  "verification": "Lista de parâmetros documentada em comentários no código e σ calculado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter Notebook), Python com NumPy.",
                                  "tips": "Comece com valores pequenos de Nx para testes rápidos antes de refinar.",
                                  "learningObjective": "Compreender o setup matemático e numérico do problema.",
                                  "commonMistakes": "Esquecer de definir L ou usar Δx incorreto, levando a grids não periódicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o esquema FTCS em código Python",
                                  "subSteps": [
                                    "Crie o grid espacial x = np.linspace(0, L, Nx, endpoint=False) e inicialize u0 = np.sin(2*np.pi*x/L).",
                                    "Defina o esquema: u_new[j] = u[j] - (σ/2) * (u[j+1] - u[j-1]), com índices modulares para periodicidade (np.roll).",
                                    "Implemente o loop temporal: para n em range(Nt), atualize u com u_new e armazene soluções em intervalos (ex: a cada 250 passos).",
                                    "Use arrays NumPy para eficiência e evite loops Python lentos.",
                                    "Adicione tratamento de bordas periódicas explicitamente."
                                  ],
                                  "verification": "Código executa sem erros de sintaxe ou indexação, produzindo array u final sem NaNs.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python 3+, bibliotecas NumPy e Matplotlib instaladas (pip install numpy matplotlib).",
                                  "tips": "Teste o esquema em um passo temporal manual para validar a fórmula.",
                                  "learningObjective": "Dominar a tradução do esquema matemático para código vetorizado.",
                                  "commonMistakes": "Índices fora de bounds sem periodicidade, causando erros ou instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição CFL e executar a simulação completa",
                                  "subSteps": [
                                    "Ajuste Δt para que σ = c Δt / Δx ≤ 1 (ex: σ=0.5), recalculando Δt = σ * Δx / c.",
                                    "Adicione uma asserção no código: assert abs(σ) <= 1, 'CFL violada!'.",
                                    "Execute a simulação completa, armazenando snapshots de u em t=0, t=0.25, t=0.5.",
                                    "Monitore a norma L2 da solução para detectar instabilidade (ex: np.linalg.norm(u)).",
                                    "Salve os resultados em variáveis para plotting."
                                  ],
                                  "verification": "Simulação roda até o final sem crashes, σ < 1 confirmado e norma L2 estável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmos do passo anterior, mais terminal para testes.",
                                  "tips": "Use σ=0.9 para testar limite de estabilidade, mas comece com 0.5.",
                                  "learningObjective": "Aplicar e verificar critérios de estabilidade numérica.",
                                  "commonMistakes": "Calcular σ incorretamente (esquecer fator 1/2 no FTCS) ou usar Δt fixo sem ajuste."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar soluções numéricas e realizar validação básica",
                                  "subSteps": [
                                    "Use Matplotlib para plotar u vs x em múltiplos tempos (t=0, 0.25, 0.5) em uma figura com subplots.",
                                    "Plote a solução exata u_exact(x,t) = sin(2π(x - c t)/L) para comparação.",
                                    "Calcule erro L2: np.sqrt(np.mean((u - u_exact)**2)) e exiba no plot.",
                                    "Adicione legendas, títulos e grid para clareza.",
                                    "Salve a figura como 'solucoes_ftcs.png'."
                                  ],
                                  "verification": "Plots gerados mostram propagação à velocidade c sem dispersão excessiva; erro L2 < 0.1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib (import matplotlib.pyplot as plt).",
                                  "tips": "Use plt.contourf para visualização 2D se expandir para space-time diagram.",
                                  "learningObjective": "Visualizar e validar soluções numéricas contra analíticas.",
                                  "commonMistakes": "Escala errada nos eixos ou esquecimento da solução exata, mascarando erros."
                                }
                              ],
                              "practicalExample": "Implemente o esquema FTCS para ∂u/∂t + ∂u/∂x = 0 em [0,1] com u(x,0)=sin(2πx), condições periódicas, c=1, Nx=100, Nt=1000, σ=0.5. Plote u(x,t) em t=0, 0.25 e 0.5, comparando com u(x,t)=sin(2π(x-t)). A solução deve propagar sem distorção significativa.",
                              "finalVerifications": [
                                "Código implementa corretamente o esquema FTCS com periodicidade.",
                                "Condição CFL é verificada e satisfeita (σ ≤ 1).",
                                "Simulação executa sem erros numéricos ou crashes.",
                                "Plots mostram propagação estável da onda à velocidade c.",
                                "Erro L2 em relação à solução exata é baixo (<0.05).",
                                "Comentários no código explicam escolhas de parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática do esquema FTCS (30%).",
                                "Implementação eficiente em Python com NumPy (25%).",
                                "Verificação explícita da condição CFL (15%).",
                                "Qualidade e legibilidade dos plots com comparação exata (20%).",
                                "Análise de resultados e documentação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Vetorização com NumPy e visualização com Matplotlib.",
                                "Física: Modelagem de ondas e transporte em mecânica de fluidos.",
                                "Computação Científica: Análise de estabilidade e erros numéricos.",
                                "Matemática Aplicada: Soluções exatas de EDOs e análise de Fourier."
                              ],
                              "realWorldApplication": "Simulação de propagação de ondas acústicas, transporte de contaminantes em rios ou tráfego veicular em rodovias, onde métodos explícitos são usados em solvers CFD como OpenFOAM."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Métodos Implícitos para Equações Hiperbólicas",
                        "description": "Métodos numéricos implícitos para equações hiperbólicas, como o esquema BTCS (Backward-Time Central-Space), destacando estabilidade incondicional e resolução de sistemas lineares em cada passo de tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Derivação do esquema BTCS para equação hiperbólica",
                            "description": "Derivar o esquema implícito BTCS para a equação de advecção ∂u/∂t + a ∂u/∂x = 0, utilizando diferença backward em tempo e central em espaço, e analisar consistência e ordem de precisão O(Δt + Δx²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração da grade espacial-temporal e notação básica",
                                  "subSteps": [
                                    "Defina a equação de advecção: ∂u/∂t + a ∂u/∂x = 0, onde a > 0 é a velocidade de advecção.",
                                    "Estabeleça a grade uniforme: x_i = i Δx para i=0,1,...,N_x; t_n = n Δt para n=0,1,...,N_t.",
                                    "Introduza a notação u_i^n ≈ u(x_i, t_n).",
                                    "Especifique condições iniciais u_i^0 = u_0(x_i) e condições de contorno apropriadas (ex: periódicas ou Dirichlet).",
                                    "Defina os parâmetros de discretização: Δt (passo de tempo) e Δx (passo de espaço)."
                                  ],
                                  "verification": "Verifique se a notação está corretamente definida e a equação é escrita sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use índices claros (i para espaço, n para tempo) para evitar confusão posterior.",
                                  "learningObjective": "Compreender a discretização da malha e notação padrão em métodos de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir Δt com Δx",
                                    "Esquecer condições de contorno",
                                    "Notação inconsistente para u_i^n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e derivação das diferenças finitas para as derivadas",
                                  "subSteps": [
                                    "Para ∂u/∂t, use diferença backward implícita: (u_i^{n+1} - u_i^n)/Δt.",
                                    "Para ∂u/∂x, use diferença central simétrica: (u_{i+1}^{n+1} - u_{i-1}^{n+1})/(2 Δx).",
                                    "Justifique a escolha: backward em tempo torna o esquema implícito e incondicionalmente estável; central em espaço garante precisão de segunda ordem.",
                                    "Escreva as aproximações separadamente e discuta suas propriedades de precisão local.",
                                    "Verifique a dimensionalidade: ambas as diferenças devem ter unidades de derivada (1/tempo e 1/espaço)."
                                  ],
                                  "verification": "Confirme que as diferenças finitas escolhidas correspondem a BTCS (Backward Time, Centered Space).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de diferenças finitas padrão",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Lembre-se: implícito significa que u^{n+1} aparece em ambos os lados, exigindo solução de sistema linear.",
                                  "learningObjective": "Dominar as aproximações diferenciais finitas para derivadas parciais em esquemas implícitos.",
                                  "commonMistakes": [
                                    "Usar forward em vez de backward para tempo",
                                    "Confundir central com forward/backward em espaço",
                                    "Ignorar o nível temporal n+1 para espaço"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formulação do esquema BTCS completo",
                                  "subSteps": [
                                    "Substitua as diferenças na equação discretizada: (u_i^{n+1} - u_i^n)/Δt + a (u_{i+1}^{n+1} - u_{i-1}^{n+1})/(2 Δx) = 0.",
                                    "Multiplique por Δt para limpar denominadores: u_i^{n+1} - u_i^n + (a Δt /(2 Δx)) (u_{i+1}^{n+1} - u_{i-1}^{n+1}) = 0.",
                                    "Reorganize em forma matricial ou stencil: -λ/2 u_{i-1}^{n+1} + (1) u_i^{n+1} + λ/2 u_{i+1}^{n+1} = u_i^n, onde λ = a Δt / Δx (número de Courant).",
                                    "Identifique o sistema tridiagonal implícito para resolver u^{n+1} dado u^n.",
                                    "Escreva o esquema em notação compacta e verifique para i interno."
                                  ],
                                  "verification": "O stencil BTCS deve ser simétrico em espaço e centrado em (i, n+1).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para stencil",
                                    "Exemplo numérico simples com 3 pontos",
                                    "MATLAB/Python para testar stencil (opcional)"
                                  ],
                                  "tips": "Desenhe o stencil gráfico para visualizar os coeficientes vizinhos.",
                                  "learningObjective": "Construir o esquema numérico implícito a partir das aproximações diferenciais.",
                                  "commonMistakes": [
                                    "Erro no sinal de a (assumir a>0)",
                                    "Fator λ incorreto (deve ser a Δt / Δx)",
                                    "Não multiplicar por Δt corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise de consistência e ordem de precisão",
                                  "subSteps": [
                                    "Expanda u em série de Taylor ao redor de (x_i, t_{n+1}): u_i^{n+1} = u + Δt ∂u/∂t + (Δt)^2/2 ∂²u/∂t² + O(Δt³); similares para u_{i±1}^{n+1}.",
                                    "Substitua na diferença temporal: (u_i^{n+1} - u_i^n)/Δt = ∂u/∂t |_{t_{n+1/2}} + O(Δt).",
                                    "Para espacial: (u_{i+1}^{n+1} - u_{i-1}^{n+1})/(2Δx) = ∂u/∂x |_{n+1} + O(Δx²).",
                                    "Some os erros de truncagem: esquema = PDE + O(Δt) + O(Δx²), provando consistência (erro local ->0 quando Δt,Δx->0).",
                                    "Conclua ordem de precisão global O(Δt + Δx²) assumindo estabilidade."
                                  ],
                                  "verification": "Termos de erro de truncagem devem ser explicitamente O(Δt + Δx²).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha para expansões de Taylor",
                                    "Referência: notas de Análise Numérica II",
                                    "SymPy para automação de Taylor (avançado)"
                                  ],
                                  "tips": "Expanda tudo em t_{n+1} para consistência com o esquema implícito; ignore termos superiores.",
                                  "learningObjective": "Realizar análise de erro de truncagem para validar propriedades do esquema.",
                                  "commonMistakes": [
                                    "Taylor em ponto errado (ex: t_n em vez de t_{n+1})",
                                    "Ordem errada para central (O(Δx) em vez de O(Δx²))",
                                    "Não somar erros de ambas derivadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação ∂u/∂t + ∂u/∂x = 0 (a=1), com Δx=0.1, Δt=0.05 (λ=0.5), derive o stencil BTCS: -0.25 u_{i-1}^{n+1} + u_i^{n+1} + 0.25 u_{i+1}^{n+1} = u_i^n. Resolva para uma grade com 5 pontos e u^0 = sin(2πx), comparando com solução exata u(x,t)=sin(2π(x-t)).",
                              "finalVerifications": [
                                "Esquema BTCS escrito corretamente com stencil tridiagonal.",
                                "Diferença backward em tempo e central em espaço identificadas.",
                                "Expansão de Taylor mostra erro O(Δt + Δx²).",
                                "Consistência provada (esquema converge para PDE).",
                                "Número de Courant λ = a Δt / Δx corretamente definido.",
                                "Sistema implícito reconhecido como tridiagonal solucionável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das diferenças finitas (100% dos coeficientes corretos).",
                                "Correta expansão de Taylor com identificação de ordens de erro.",
                                "Clareza na reorganização algébrica para stencil.",
                                "Justificativa adequada para escolhas de diferenças (implícito vs explícito).",
                                "Ausência de erros dimensionais ou de sinal.",
                                "Compreensão de implicações (estabilidade incondicional)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas hiperbólicas e advecção em fluidos.",
                                "Computação: Implementação de solvers tridiagonais (Thomas algorithm) em Python/MATLAB.",
                                "Engenharia: Simulações numéricas em aerodinâmica e propagação de sinais.",
                                "Matemática Aplicada: Análise de estabilidade von Neumann complementar."
                              ],
                              "realWorldApplication": "O esquema BTCS é usado em simulações de propagação de ondas acústicas, modelagem de tráfego veicular (onde 'a' é velocidade média), previsão numérica do tempo para advecção de contaminantes, e finanças para modelar difusão de preços de ativos com termos hiperbólicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Análise de estabilidade incondicional",
                            "description": "Realizar análise de von Neumann no esquema BTCS, demonstrando estabilidade incondicional para qualquer σ > 0 e comparando com métodos explícitos em termos de restrições em Δt.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão do esquema BTCS e conceitos básicos de análise de von Neumann",
                                  "subSteps": [
                                    "Estude a equação hiperbólica modelo: u_t = c u_x ou u_tt = c² u_xx, focando em 1D.",
                                    "Derive o esquema BTCS: para u_t = u_xx, (u^{n+1}_j - u^n_j)/Δt = (u^{n+1}_{j-1} - 2u^{n+1}_j + u^{n+1}_{j+1})/(Δx²).",
                                    "Relembre análise de von Neumann: assumir u^n_j = g^n e^{i ξ j Δx}, onde ξ é número de onda.",
                                    "Defina σ = (c Δt)/Δx ou σ = Δt/Δx² para difusão/hiperbólica.",
                                    "Prepare notação: fator de amplificação G = g, com |G| ≤ 1 + O(Δt) para estabilidade."
                                  ],
                                  "verification": "Escreva o stencil BTCS matricialmente e a forma assumida de von Neumann sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e lápis, calculadora.",
                                  "tips": "Use diagrama de stencil para visualizar diferenças centradas no tempo reverso.",
                                  "learningObjective": "Compreender a estrutura implícita do BTCS e setup padrão de von Neumann.",
                                  "commonMistakes": "Confundir BTCS com CTCS; esquecer que BTCS é implícito e requer solução de sistema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação da solução de von Neumann para o esquema BTCS",
                                  "subSteps": [
                                    "Substitua u^n_j = g^n e^{i k j} em notação discreta (k = ξ Δx).",
                                    "Escreva a equação discretizada: g^{n+1} e^{i k j} - g^n e^{i k j} = σ (g^{n+1} e^{i k (j-1)} - 2 g^{n+1} e^{i k j} + g^{n+1} e^{i k (j+1)}).",
                                    "Simplifique dividindo por g^n e^{i k j}: 1 - g^{-1} = σ g^{-1} (e^{-i k} - 2 + e^{i k}).",
                                    "Reconheça que e^{i k} - 2 + e^{-i k} = -4 sin²(k/2).",
                                    "Defina o termo de difusão δ = -4 σ sin²(k/2)."
                                  ],
                                  "verification": "Obtenha a equação algébrica para g: g - 1 = δ g, resolvida como g = 1 / (1 - δ).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel quadriculado, software simbólico como SymPy ou Mathematica para simplificação.",
                                  "tips": "Sempre normalize dividindo pela amplitude comum e isole g.",
                                  "learningObjective": "Aplicar corretamente a ansatz de von Neumann ao esquema implícito.",
                                  "commonMistakes": "Erro no sinal de δ (deve ser negativo para difusão); confundir k com ξ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação explícita do fator de amplificação G(ξ)",
                                  "subSteps": [
                                    "Da equação: g = 1 / (1 + 4 σ sin²(ξ Δx / 2)), para u_t = u_xx.",
                                    "Para equação da onda u_tt = c² u_xx, adapte para esquema BTCS em duas dimensões temporais.",
                                    "Geralize: |G(ξ)| = |1 / (1 - i β sin θ + γ sin² θ)| onde θ = ξ Δx / 2, para hiperbólica.",
                                    "Para BTCS em onda 1D: resolva o sistema tridiagonal implicitamente na forma de von Neumann.",
                                    "Plote |G(ξ)| vs ξ para σ fixo usando Python/MATLAB."
                                  ],
                                  "verification": "Derive G(ξ) = 1 / (1 + 4 σ sin²(θ)) e verifique para σ→0, G→1.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy/Matplotlib, notebook Jupyter.",
                                  "tips": "Use identidade trigonométrica sin²(θ) = (1 - cos(2θ))/2 para simplificação.",
                                  "learningObjective": "Obter fórmula fechada de G para BTCS.",
                                  "commonMistakes": "Esquecer fatorização complexa em esquemas hiperbólicos; Δt² em vez de Δt."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prova de estabilidade incondicional: análise de |G| ≤ 1 ∀ σ > 0",
                                  "subSteps": [
                                    "Mostre que denominador |1 + 4 σ sin²(θ)| ≥ 1 para σ > 0, θ ∈ [0,π].",
                                    "Calcule |G| = 1 / |1 + 4 σ sin²(θ)| ≤ 1, pois real e positivo.",
                                    "Verifique para σ grande: sin²≤1, 4σ sin² ≥0, denominador ≥1.",
                                    "Compare limite ξ=0: G=1 (preservação de constantes).",
                                    "Analise dissipação: Re(G) <1 para modos não-zero."
                                  ],
                                  "verification": "Prove matematicamente |G| ≤1 e plote |G|_{max}=1 para vários σ.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel para prova, software para plotar |G(ξ)| de 0 a π/Δx.",
                                  "tips": "Considere função f(s) = 1 + 4σ s com s=sin²≥0, claramente |f|≥1.",
                                  "learningObjective": "Demonstrar estabilidade incondicional independentemente de σ.",
                                  "commonMistakes": "Achar |G|>1 para σ pequeno; ignorar que é implícito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparação com métodos explícitos e discussão de restrições em Δt",
                                  "subSteps": [
                                    "Revise FTCS explícito: G = 1 + σ (e^{ik}-2+e^{-ik}) = 1 - 4σ sin²(θ), instável se σ>1/2.",
                                    "Para Lax-Friedrichs: |G|≤1 só se σ≤1.",
                                    "Tabela: BTCS (σ qualquer), Explícito (σ≤1/2), custo (implícito O(N) por passo).",
                                    "Discuta trade-off: BTCS permite Δt grande mas requer solver linear.",
                                    "Implemente numéricamente erro vs σ para ambos."
                                  ],
                                  "verification": "Crie tabela comparativa e mostre plot de regiões de estabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python para simulação simples, tabela LaTeX ou Markdown.",
                                  "tips": "Use gráfico de von Neumann no plano σ-ξ para visualização.",
                                  "learningObjective": "Comparar vantagens do implícito sobre explícito.",
                                  "commonMistakes": "Confundir condição CFL para hiperbólica (σ≤1) com parabólica."
                                }
                              ],
                              "practicalExample": "Para a equação da onda u_tt = u_xx no domínio [0,1] com condições periódicas, aplique BTCS com σ=10 (Δt grande). Derive G(ξ)= [1 + 2i σ sin(θ)] / [1 + 4 σ² sin⁴(θ/2) + ...] (forma completa), plote |G|≈1 mostrando propagação sem amplificação, contrastando com FTCS que explode para σ>1.",
                              "finalVerifications": [
                                "Fórmula de G(ξ) derivada corretamente para BTCS.",
                                "Prova analítica de |G(ξ)| ≤ 1 para todo σ > 0 e ξ.",
                                "Plots de |G| vs ξ para σ=0.1, 1, 10 mostrando estabilidade.",
                                "Tabela comparativa de restrições CFL: BTCS (nenhuma) vs FTCS (σ≤0.5).",
                                "Exemplo numérico com erro L2 estável para Δt grande.",
                                "Discussão de custo computacional implícito vs explícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de G (sem erros algébricos).",
                                "Compreensão conceitual de estabilidade incondicional vs condicional.",
                                "Qualidade dos plots e tabelas comparativos.",
                                "Profundidade na prova de |G|≤1 e análise de dissipação.",
                                "Capacidade de relacionar teoria a implementação prática.",
                                "Clareza na comparação de restrições em Δt/Δx."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em modelagem de ondas acústicas/sísmicas.",
                                "Computação Científica: Solução de sistemas lineares tridiagonais (Thomas algorithm).",
                                "Engenharia: Simulações CFD hiperbólicas em aerodinâmica.",
                                "Matemática Aplicada: Análise espectral e autovalores de operadores discretos."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos ou propagação de ondas em reservatórios de óleo, onde Δt grandes são essenciais para eficiência em grids 3D massivos, permitindo BTCS superar limitações CFL de métodos explícitos em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Resolução de sistemas em métodos implícitos",
                            "description": "Explicar a estrutura tridiagonal do sistema linear gerado pelo BTCS em malha uniforme e descrever métodos de resolução eficientes como Thomas algorithm para passos de tempo implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivação da estrutura tridiagonal do sistema BTCS em malha uniforme",
                                  "subSteps": [
                                    "Revise a equação da onda hiperbólica u_tt = c² u_xx.",
                                    "Descreva a discretização BTCS (Backward Time Centered Space): u^{n+1}_j - 2u^{n+1}_{j-1} + u^{n+1}_{j+1} relacionado a termos em tempo n.",
                                    "Mostre que o esquema resulta em um sistema linear Au^{n+1} = b, onde A é tridiagonal.",
                                    "Identifique os coeficientes: subdiagonal a_i, diagonal b_i, superdiagonal c_i para malha uniforme Δx = h, Δt = k.",
                                    "Escreva explicitamente a matriz A para um exemplo com 5 pontos internos."
                                  ],
                                  "verification": "Derive a matriz A manualmente para N=3 e confirme que é tridiagonal com elementos constantes em malha uniforme.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de métodos numéricos (ex: Análise Numérica II)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use r = (c k / h)^2 para simplificar os coeficientes; memorize a forma padrão.",
                                  "learningObjective": "Compreender como o BTCS gera sistemas tridiagonais simétricos e dominantes diagonalmente.",
                                  "commonMistakes": [
                                    "Confundir BTCS com CTCS explícito",
                                    "Esquecer condições de contorno na matriz",
                                    "Erro nos coeficientes de diferença finita central"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introdução e princípios do Algoritmo de Thomas (TDMA)",
                                  "subSteps": [
                                    "Explique o TDMA como Gauss eliminação otimizada para matrizes tridiagonais, O(N) em vez de O(N³).",
                                    "Defina as fases: forward elimination (substituição progressiva) e backward substitution (substituição regressiva).",
                                    "Apresente as variáveis auxiliares: c'_i (super), d'_i (lado direito modificado).",
                                    "Escreva as recursões forward: c'_i = c_i / (b_i - a_i c'_{i-1}), d'_i = (d_i - a_i d'_{i-1}) / (b_i - a_i c'_{i-1}).",
                                    "Discuta estabilidade para matrizes diagonalmente dominantes."
                                  ],
                                  "verification": "Escreva pseudocódigo completo do TDMA e teste com matriz identidade 3x3.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pseudocódigo em papel",
                                    "Software como Python ou MATLAB para validação"
                                  ],
                                  "tips": "Sempre verifique dominância diagonal: |b_i| >= |a_i| + |c_i| para convergência.",
                                  "learningObjective": "Dominar os princípios teóricos do TDMA e suas vantagens em eficiência.",
                                  "commonMistakes": [
                                    "Inverter ordem de forward/backward",
                                    "Dividir por zero em casos instáveis",
                                    "Confundir índices i e i+1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação da eliminação forward no Algoritmo de Thomas",
                                  "subSteps": [
                                    "Inicialize c'_1 = c_1 / b_1, d'_1 = d_1 / b_1.",
                                    "Para i=2 a N-1: aplique recursão forward para c'_i e d'_i.",
                                    "Inclua tratamento de condições de contorno (ex: Dirichlet u_0 = u_{N+1} = 0).",
                                    "Codifique em Python ou MATLAB com vetores para a, b, c, d.",
                                    "Teste com sistema conhecido: solução exata u = [1,2,3]^T."
                                  ],
                                  "verification": "Execute código e compare c' e d' com cálculos manuais para N=4.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook",
                                    "Exemplos de matrizes tridiagonais"
                                  ],
                                  "tips": "Use loops for i in range(1, N) para evitar erros de índice.",
                                  "learningObjective": "Implementar corretamente a fase forward, preparando para back-sub.",
                                  "commonMistakes": [
                                    "Índices off-by-one em arrays",
                                    "Não inicializar corretamente c'_0",
                                    "Ignorar precisão numérica em floats"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação da substituição backward e verificação completa",
                                  "subSteps": [
                                    "Inicie backward: u_{N-1} = d'_{N-1} / c'_{N-1} (para N pontos internos).",
                                    "Para i=N-2 downto 1: u_i = (d'_i - c'_i u_{i+1}) / b_i (ajustar fórmula padrão).",
                                    "Ajuste fórmula exata: u_N = d'_N, u_i = (d'_i - a_i u_{i-1} - c_i u_{i+1}) não, use padrão TDMA.",
                                    "Verifique solução multiplicando Au =? b.",
                                    "Analise erro e tempo de execução vs. solvers densos."
                                  ],
                                  "verification": "Resolva sistema BTCS de exemplo e confirme ||Au - b|| < 1e-10.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python/MATLAB do step anterior",
                                    "Solver built-in como numpy.linalg.solve para comparação"
                                  ],
                                  "tips": "Imprima passos intermediários para debug; use np.allclose para verificação.",
                                  "learningObjective": "Completar TDMA e validar em contexto BTCS para passos implícitos.",
                                  "commonMistakes": [
                                    "Erro na ordem backward (de N para 1)",
                                    "Confundir u_i com d'_i final",
                                    "Não normalizar resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação da onda u_tt = u_xx em [0,1]x[0,1], malha uniforme h=0.2, k=0.1, r=0.25, condições u=0 nas bordas, u^0=sen(pi x), u_t^0=0. No primeiro passo implícito BTCS, o sistema é tridiagonal com a_i=-r/2, b_i=1+r, c_i=-r/2, d_i derivado de u^n. Use TDMA para encontrar u^1 em 5 pontos internos.",
                              "finalVerifications": [
                                "Derivação correta da matriz tridiagonal BTCS para malha uniforme.",
                                "Pseudocódigo completo e correto do Algoritmo de Thomas.",
                                "Implementação funcional em código que resolve sistema sem erros numéricos.",
                                "Verificação de resíduos ||Au - b|| < 1e-12.",
                                "Explicação da eficiência O(N) vs. O(N³) de Gauss padrão.",
                                "Aplicação bem-sucedida a um passo BTCS de equação hiperbólica."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação tridiagonal (25%)",
                                "Correção das recursões forward/backward (30%)",
                                "Funcionalidade e robustez do código (20%)",
                                "Análise de estabilidade e eficiência (15%)",
                                "Verificação numérica e resíduos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de ondas em mecânica.",
                                "Programação: implementação de algoritmos numéricos em Python/MATLAB.",
                                "Engenharia: modelagem em acústica e propagação de sinais.",
                                "Álgebra Linear: propriedades de matrizes esparsas."
                              ],
                              "realWorldApplication": "Resolução eficiente de sistemas implícitos em simulações numéricas de ondas sísmicas, acústicas em engenharia civil e aeroespacial, propagação de sinais em telecomunicações, permitindo passos de tempo maiores e simulações em malhas finas sem alto custo computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Noções de Dispersão e Dissipação Numérica",
                        "description": "Conceitos de erro numérico em métodos de diferenças finitas para equações hiperbólicas, incluindo dispersão (fase errada) e dissipação (amortecimento artificial de amplitudes).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Definição e análise de dissipação numérica",
                            "description": "Definir dissipação numérica como o fator de amplificação |g(k)| < 1 para modos de Fourier, calcular para esquemas FTCS e BTCS, e interpretar seu impacto na suavização de soluções de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a análise de von Neumann e definir dissipação numérica",
                                  "subSteps": [
                                    "Revise a análise de estabilidade de von Neumann para esquemas de diferenças finitas.",
                                    "Explique os modos de Fourier como soluções e^{i k x_j} no tempo.",
                                    "Defina o fator de amplificação g(k) como o multiplicador temporal para cada modo k.",
                                    "Estabeleça dissipação numérica quando |g(k)| < 1 para certos k, indicando amortecimento.",
                                    "Discuta o papel na suavização artificial de componentes de alta frequência."
                                  ],
                                  "verification": "Escreva uma definição precisa de dissipação numérica e identifique |g(k)| < 1 em um diagrama de fase.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: LeVeque), papel e lápis, software de plotagem (Matplotlib ou similar).",
                                  "tips": "Comece com a equação da onda u_t + a u_x = 0 para contextualizar.",
                                  "learningObjective": "Dominar a definição conceitual de dissipação via fator de amplificação |g(k)|.",
                                  "commonMistakes": "Confundir dissipação com dispersão; lembrar que dissipação afeta amplitude, não fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o fator de amplificação g(k) para o esquema FTCS",
                                  "subSteps": [
                                    "Escreva o esquema FTCS para a equação da onda: u_j^{n+1} = u_j^n - (σ/2)(u_{j+1}^n - u_{j-1}^n), onde σ = a Δt / Δx.",
                                    "Substitua o modo de Fourier u_j^n = g^n e^{i k j Δx}.",
                                    "Simplifique para obter g(k) = 1 - i σ sin(k Δx).",
                                    "Calcule |g(k)|^2 = 1 + σ^2 sin^2(k Δx) e mostre que |g(k)| > 1 para σ > 0.",
                                    "Interprete: FTCS é amplificador, não dissipativo."
                                  ],
                                  "verification": "Derive e plote |g(k)| para σ=0.5, confirmando |g(k)| ≥ 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), caderno de derivadas.",
                                  "tips": "Use a identidade trigonométrica para sin(k Δx) em termos de θ = k Δx.",
                                  "learningObjective": "Calcular explicitamente g(k) e |g(k)| para FTCS.",
                                  "commonMistakes": "Erro no sinal do esquema FTCS; verifique a forma explícita forward-time centered-space."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o fator de amplificação g(k) para o esquema BTCS",
                                  "subSteps": [
                                    "Escreva o esquema BTCS: -σ/2 u_{j+1}^{n+1} + u_j^{n+1} + σ/2 u_{j-1}^{n+1} = u_j^n.",
                                    "Substitua o modo de Fourier e resolva para g(k).",
                                    "Obtenha g(k) = 1 / (1 + σ^2 sin^2(k Δx)/4) * (1 - i (σ/2) sin(k Δx) * algo, wait: na verdade g(k) = [1 - i σ sin(θ)] / [1 + (σ sin(θ)/2)^2 wait, derive precisely.",
                                    "Calcule |g(k)| = 1 / sqrt(1 + (σ sin(k Δx)/2)^2 ) < 1 para σ > 0.",
                                    "Confirme dissipação: |g(k)| diminui com sin(k Δx) maior (altas frequências)."
                                  ],
                                  "verification": "Derive g(k), compute |g(k)| analiticamente e numéricamente para kΔx = π/2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de álgebra computacional, exemplos numéricos em Python.",
                                  "tips": "Resolva o sistema tridiagonal para g(k) assumindo forma e^{i k j Δx} em ambos lados.",
                                  "learningObjective": "Dominar derivação de g(k) para esquemas implícitos como BTCS.",
                                  "commonMistakes": "Esquecer de normalizar corretamente |g(k)|; teste com σ pequeno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o impacto da dissipação na suavização de soluções",
                                  "subSteps": [
                                    "Compare |g(k)| para FTCS (instável) vs BTCS (dissipativo).",
                                    "Analise para altas frequências (k Δx ≈ π): |g(k)| <<1 em BTCS, suavizando oscilações.",
                                    "Simule numericamente uma onda inicial com alta frequência e compare soluções.",
                                    "Discuta trade-off: dissipação remove ruído mas pode atenuar solução física.",
                                    "Plote |g(k)| vs k para visualização."
                                  ],
                                  "verification": "Gere gráfico de |g(k)| para ambos esquemas e descreva suavização qualitativa.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/MATLAB com NumPy/SciPy para simulação e plotagem.",
                                  "tips": "Use Δx pequeno para resolver altas k; foque em θ = k Δx de 0 a π.",
                                  "learningObjective": "Interpretar numericamente e conceitualmente o efeito dissipativo.",
                                  "commonMistakes": "Ignorar dependência em σ; sempre normalize pelo número de passos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise e discutir implicações",
                                  "subSteps": [
                                    "Resuma condições para dissipação: |g(k)| <1 preferencialmente para altas k.",
                                    "Compare com esquemas não-dissipativos como Lax-Wendroff.",
                                    "Discuta critérios de escolha em simulações hiperbólicas.",
                                    "Crie tabela comparativa de |g(k)| para diferentes esquemas.",
                                    "Reflita sobre estabilidade vs precisão."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo análise e crie tabela comparativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela em LaTeX ou Excel, referências bibliográficas.",
                                  "tips": "Use g(k) exato para evitar erros numéricos em síntese.",
                                  "learningObjective": "Integrar conceitos em análise crítica de esquemas numéricos.",
                                  "commonMistakes": "Generalizar demais; especifique para equações hiperbólicas lineares."
                                }
                              ],
                              "practicalExample": "Simule a equação da onda u_t + u_x = 0 com condição inicial u(x,0) = sin(10 π x) + 0.1 sin(50 π x) (alta frequência). Aplique BTCS com σ=1: observe que após 100 passos, a componente de alta frequência é dissipada, suavizando a solução, enquanto FTCS diverge.",
                              "finalVerifications": [
                                "Definição correta de dissipação como |g(k)| < 1.",
                                "Derivação precisa de g(k) para FTCS e BTCS.",
                                "Gráficos de |g(k)| mostrando dissipação em BTCS para altas k.",
                                "Interpretação correta do suavização de altas frequências.",
                                "Simulação numérica confirmando comportamento dissipativo.",
                                "Comparação tabular entre esquemas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g(k) (80%).",
                                "Correta interpretação de |g(k)| <1 e impacto em soluções (15%).",
                                "Qualidade de visualizações e simulações (5%).",
                                "Clareza na discussão de implicações práticas.",
                                "Identificação de erros comuns e limitações.",
                                "Integração conceitual com estabilidade geral."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas dissipativas em mecânica e acústica.",
                                "Computação: Implementação eficiente de solvers implícitos em CFD.",
                                "Engenharia: Análise de estabilidade em simulações de propagação de sinais.",
                                "Matemática Aplicada: Análise espectral de operadores diferenciais.",
                                "Estatística: Controle de ruído numérico em dados simulados."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD) para previsão de turbulência, esquemas dissipativos como BTCS são usados para suprimir oscilações numéricas de alta frequência sem comprometer a precisão em escalas físicas, essencial em design aeroespacial e previsão meteorológica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Definição e análise de dispersão numérica",
                            "description": "Definir dispersão numérica como ω_num(k) ≠ ω_exata(k), onde ω é a frequência angular, analisar o erro de fase em esquemas upwind e central, e discutir esquemas de baixa dispersão como Lax-Wendroff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de dispersão numérica",
                                  "subSteps": [
                                    "Revise a solução exata de uma equação hiperbólica linear, como a equação de onda ou de advecção: u_t + c u_x = 0.",
                                    "Introduza a análise de von Neumann: assuma solução u_j^n = g^n e^{i k j Δx}, derive a relação de amplificação g(k).",
                                    "Defina a frequência angular exata ω_exata(k) = c k e a frequência numérica ω_num(k) a partir de arg(g(k)).",
                                    "Explique dispersão como a discrepância ω_num(k) ≠ ω_exata(k), levando a erro de fase.",
                                    "Discuta o impacto: ondas de diferentes comprimentos de onda propagam em velocidades diferentes."
                                  ],
                                  "verification": "Escreva a definição formal de dispersão e dê um exemplo gráfico de dispersão em uma onda.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e lápis, calculadora simbólica como Mathematica ou SymPy.",
                                  "tips": "Comece com k pequeno (baixa frequência) onde dispersão é mínima, e aumente k para ver o efeito.",
                                  "learningObjective": "Definir precisamente dispersão numérica e relacioná-la à análise de estabilidade de von Neumann.",
                                  "commonMistakes": "Confundir dispersão com dissipação (amplitude vs fase); ignorar a dependência em k Δx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar dispersão no esquema upwind",
                                  "subSteps": [
                                    "Escreva o esquema upwind explícito para u_t + c u_x = 0: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), com λ = c Δt / Δx.",
                                    "Derive a relação de amplificação g(k) = 1 - λ (1 - e^{-i k Δx}).",
                                    "Calcule ω_num(k) = -Im(log(g(k))) / Δt e compare com ω_exata(k) = c k.",
                                    "Plote a curva de dispersão: ω_num / ω_exata vs k Δx para λ fixo (ex: 0.5).",
                                    "Observe que upwind é dispersivo para altas frequências (fase atrasada)."
                                  ],
                                  "verification": "Derive e plote a curva de dispersão upwind, identificando o erro de fase.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (MATLAB, Python com Matplotlib/NumPy), notas de aula.",
                                  "tips": "Use expansão em série de Taylor para aproximação assintótica em k Δx pequeno.",
                                  "learningObjective": "Derivar e interpretar a dispersão no esquema upwind, destacando seu caráter mono-dispersivo.",
                                  "commonMistakes": "Erro no sinal da derivada de amplificação; assumir λ=1 sem verificar estabilidade (CFL)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dispersão no esquema central",
                                  "subSteps": [
                                    "Formule o esquema central: u_j^{n+1} = u_j^n - (λ/2) (u_{j+1}^n - u_{j-1}^n).",
                                    "Obtenha g(k) = 1 - i λ sin(k Δx).",
                                    "Determine ω_num(k) = (λ sin(k Δx)) / Δx e compare com ω_exata.",
                                    "Plote ω_num / ω_exata vs k Δx: note oscilações e dispersão simétrica.",
                                    "Discuta instabilidade para λ >1, mas foque em dispersão para λ estável."
                                  ],
                                  "verification": "Compare graficamente dispersão upwind vs central para mesmo λ.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python ou MATLAB para derivação simbólica e plots.",
                                  "tips": "Normalice por ω_exata para visualizar erro relativo claramente.",
                                  "learningObjective": "Contrastar dispersão central (não mono-dispersiva) com upwind.",
                                  "commonMistakes": "Confundir esquema central com Lax-Friedrichs; erro em sin(k Δx) vs k Δx."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar esquemas de baixa dispersão como Lax-Wendroff",
                                  "subSteps": [
                                    "Apresente Lax-Wendroff: u_j^{n+1} = u_j^n - (λ/2)(u_{j+1}^n - u_{j-1}^n) + (λ²/2)(u_{j+1}^n - 2 u_j^n + u_{j-1}^n).",
                                    "Derive g(k) ≈ 1 - i c k Δt - (1/6) (c k Δt)^3 + O(Δt^5), mostrando ordem 2 em dispersão.",
                                    "Compare curvas de dispersão: Lax-Wendroff tem menor erro de fase que upwind/central.",
                                    "Discuta trade-offs: baixa dispersão mas possível dissipação em ordens pares.",
                                    "Sugira extensões: DRP schemes para ainda menor dispersão."
                                  ],
                                  "verification": "Implemente e plote dispersão Lax-Wendroff vs esquemas anteriores.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Código Python/MATLAB pronto para esquemas, referências como Gustafsson et al.",
                                  "tips": "Foquem em resolução espectral: número de pontos por onda >5 para precisão.",
                                  "learningObjective": "Entender como esquemas de alta ordem reduzem dispersão via cancelamento de termos de erro.",
                                  "commonMistakes": "Esquecer termo de segunda derivada; confundir com Beam-Warming."
                                }
                              ],
                              "practicalExample": "Simule a propagação de um pulso gaussiano u(x,0) = exp(-x²/0.1) com c=1 usando upwind, central e Lax-Wendroff em um grid de 1000 pontos, Δx=0.01, Δt=0.005. Observe após 100 passos: upwind mostra fase atrasada em altas frequências, central oscilações, Lax-Wendroff preserva forma melhor.",
                              "finalVerifications": [
                                "Define corretamente dispersão como ω_num(k) ≠ ω_exata(k).",
                                "Deriva g(k) para upwind, central e Lax-Wendroff sem erros.",
                                "Interpreta plots de dispersão qualitativamente.",
                                "Identifica que Lax-Wendroff tem dispersão de ordem 3.",
                                "Explica impacto em simulações de ondas.",
                                "Compara trade-offs entre esquemas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de relações de amplificação (90% correto).",
                                "Qualidade e legibilidade de plots de dispersão.",
                                "Profundidade na análise qualitativa de erros de fase.",
                                "Correta identificação de ordens de precisão em dispersão.",
                                "Capacidade de relacionar teoria a exemplo numérico.",
                                "Clareza na discussão de esquemas de baixa dispersão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e eletromagnéticas.",
                                "Computação: Implementação eficiente em CFD (Computational Fluid Dynamics).",
                                "Engenharia: Simulações em aerodinâmica e propagação de sinais.",
                                "Estatística: Análise de erros numéricos em dados simulados."
                              ],
                              "realWorldApplication": "Em simulações de CFD para aviação, baixa dispersão numérica (ex: Lax-Wendroff otimizado) garante precisão na propagação de choques e ondas sem distorções artificiais, essencial para design de asas e previsão de turbulência."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Comparação qualitativa de erros numéricos",
                            "description": "Comparar dispersão e dissipação em métodos explícitos vs. implícitos através de gráficos de fator de amplificação no plano (σ, kΔx), relacionando com comportamento físico de ondas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de dispersão e dissipação numérica",
                                  "subSteps": [
                                    "Defina dispersão numérica como a dependência da velocidade de fase numérica em relação ao número de onda.",
                                    "Defina dissipação numérica como a atenuação artificial de amplitudes de onda devido ao esquema numérico.",
                                    "Compare com dispersão e dissipação física em equações de onda hiperbólicas.",
                                    "Identifique como esses erros afetam a precisão de simulações de propagação de ondas.",
                                    "Estude a equação modelo: equação de advecção ou onda 1D: ∂u/∂t + c ∂u/∂x = 0."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre dispersão/dissipação física e numérica, com exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica II, notas de aula sobre métodos de diferenças finitas.",
                                  "tips": "Use analogias com ondas sonoras para visualizar os conceitos.",
                                  "learningObjective": "Compreender as origens qualitativas de erros numéricos em esquemas hiperbólicos.",
                                  "commonMistakes": "Confundir dispersão (fase errada) com dissipação (amplitude errada)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e derivar o fator de amplificação para métodos explícitos",
                                  "subSteps": [
                                    "Assuma solução mono-cromática u_j^n = G^n e^{i k j Δx}.",
                                    "Derive G(σ, ξ) para esquemas explícitos como FTCS e Lax-Friedrichs, onde σ = c Δt / Δx, ξ = k Δx.",
                                    "Calcule |G| (dissipação) e arg(G)/Δt (velocidade de fase numérica).",
                                    "Analise numericamente para ξ de 0 a π e σ típico (0.5-1.0).",
                                    "Identifique regiões onde |G| < 1 (dissipação) ou velocidade de fase ≠ c (dispersão)."
                                  ],
                                  "verification": "Esboce manualmente curvas qualitativas de |G| vs ξ para FTCS.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno, calculadora simbólica (SymPy ou Mathematica), slides de aula.",
                                  "tips": "Comece com σ fixo para simplificar plots iniciais.",
                                  "learningObjective": "Derivar e interpretar o fator de amplificação em métodos explícitos.",
                                  "commonMistakes": "Esquecer o fator i na exponencial de Fourier ou normalizar incorretamente σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e analisar fator de amplificação para métodos implícitos",
                                  "subSteps": [
                                    "Derive G(σ, ξ) para esquemas implícitos como BTCS ou Crank-Nicolson adaptado para hiperbólicas.",
                                    "Resolva a equação implícita |1 - i σ sin(ξ)/2| ou similar para obter G.",
                                    "Compare |G| e arg(G) com os explícitos no plano (σ, ξ).",
                                    "Note estabilidade incondicional para implícitos (|G| ≤ 1 sempre).",
                                    "Gere expressões analíticas para ambos os tipos."
                                  ],
                                  "verification": "Liste 3 diferenças qualitativas entre G explícito e implícito.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de álgebra computacional, papel para derivações.",
                                  "tips": "Use aproximação para pequenos ξ para validar resultados físicos.",
                                  "learningObjective": "Contrastar estabilidade e erros de fase/amplitude em implícitos vs explícitos.",
                                  "commonMistakes": "Ignorar a resolução matricial para esquemas implícitos multi-nível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar e interpretar gráficos no plano (σ, kΔx)",
                                  "subSteps": [
                                    "Implemente scripts para plotar |G(σ, ξ)| e φ_num = arg(G)/Δt vs ξ para σ variando.",
                                    "Crie contour plots ou superfícies 3D no plano (σ, ξ ∈ [0,π]).",
                                    "Identifique regiões de alta dissipação (vermelho em |G|<0.9) e dispersão (φ_num ≠ c).",
                                    "Compare curvas para explícito vs implícito lado a lado.",
                                    "Anote qualitative: explícitos oscilatórios em alta frequência, implícitos mais dissipativos."
                                  ],
                                  "verification": "Produza 4 gráficos rotulados corretamente e descreva padrões.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com Matplotlib/Plotly, dados de G pré-calculados.",
                                  "tips": "Use ξ = k Δx de 0 a π para capturar o espectro Nyquist.",
                                  "learningObjective": "Visualizar qualitativamente erros numéricos via gráficos de amplificação.",
                                  "commonMistakes": "Escala errada em ξ (deve parar em π, não 2π)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar comparação qualitativa e relacionar com comportamento físico",
                                  "subSteps": [
                                    "Compare dispersão: explícitos dispersam ondas curtas mais que longas; implícitos menos.",
                                    "Compare dissipação: explícitos podem amplificar (instável), implícitos sempre atenuam.",
                                    "Relacione com física: ondas físicas têm dispersão nula em meios lineares; numérica distorce pacotes.",
                                    "Discuta trade-offs: explícitos eficientes mas instáveis; implícitos estáveis mas caros.",
                                    "Conclua com escolha de esquema baseada em CFL e resolução espacial."
                                  ],
                                  "verification": "Escreva relatório de 1 página com conclusões qualitativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos gerados, referências físicas (Livro de ondas).",
                                  "tips": "Pense em pacotes de onda: dispersão espalha, dissipação amortece.",
                                  "learningObjective": "Sintetizar comparação e ligar erros numéricos a fenômenos físicos.",
                                  "commonMistakes": "Generalizar sem considerar faixa de σ/ξ relevante."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com pulso gaussiano inicial usando esquema explícito Lax-Friedrichs (σ=0.8) e implícito BTCS. Após 100 passos, plote soluções numéricas vs exata: observe dispersão (oscilações atrás do pulso no explícito) e dissipação suave no implícito, confirmando gráficos de |G|.",
                              "finalVerifications": [
                                "Pode esboçar qualitativamente |G| vs ξ para explícito e implícito.",
                                "Identifica regiões de dispersão dominante em métodos explícitos.",
                                "Explica por que implícitos são menos dispersivos mas mais dissipativos.",
                                "Relaciona erros numéricos a distorções em perfis de onda física.",
                                "Seleciona esquema adequado baseado em gráfico de amplificação.",
                                "Valida resultados com simulação numérica simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações de G (fórmulas corretas: 30%)",
                                "Qualidade e legibilidade dos gráficos no plano (σ, ξ): 25%",
                                "Análise qualitativa profunda e comparações: 20%",
                                "Relação explícita com comportamento físico de ondas: 15%",
                                "Relatório claro com verificações e trade-offs: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas acústicas/elásticas e análise de Fourier.",
                                "Computação: Programação numérica para análise de estabilidade (Python/MATLAB).",
                                "Engenharia: Simulações CFD para previsão de ondas de choque.",
                                "Estatística: Análise de erros e variância em dados simulados."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, gráficos de fator de amplificação guiam escolha de esquemas para minimizar dispersão em ondas P/S, evitando artefatos falsos em imagens geológicas e melhorando precisão em detecção de reservatórios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Dispersão e Dissipação Numérica",
                    "description": "Noções de erros numéricos associados a dispersão e dissipação nos métodos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Dispersão Numérica",
                        "description": "A dispersão numérica é um erro associado aos métodos de diferenças finitas que provoca uma propagação incorreta das ondas em equações diferenciais parciais hiperbólicas, resultando em velocidades de fase dependentes do número de onda e levando a oscilações espúrias ou distorções de fase na solução numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Definir dispersão numérica e sua relação com esquemas de diferenças finitas",
                            "description": "Explicar o conceito de dispersão numérica, diferenciando-o de outros erros como truncamento e arredondamento, e ilustrar sua ocorrência em esquemas centrados versus upwind para a equação de advecção, usando análise de Von Neumann para fator de amplificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender erros numéricos básicos em métodos de diferenças finitas",
                                  "subSteps": [
                                    "Revise a decomposição de erro em métodos numéricos: erro total = erro de truncamento + erro de arredondamento + erro de dispersão/dissipação.",
                                    "Estude exemplos simples de erro de truncamento em aproximações de derivadas (ex: diferença forward vs central).",
                                    "Analise impacto do erro de arredondamento devido à precisão de ponto flutuante.",
                                    "Identifique que dispersão é um erro de fase relacionado à representação de ondas altas.",
                                    "Compare qualitativamente os três tipos de erros em contexto de equações diferenciais parabólicas e hiperbólicas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre truncamento, arredondamento e dispersão, com um exemplo de cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notebook Jupyter com Python/NumPy.",
                                  "tips": "Use diagramas de Taylor para visualizar truncamento; foque em ordens de precisão.",
                                  "learningObjective": "Diferenciar erros numéricos fundamentais e contextualizar dispersão.",
                                  "commonMistakes": "Confundir dispersão com dissipação (dispersão preserva energia mas distorce fase)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir dispersão numérica e suas características",
                                  "subSteps": [
                                    "Defina dispersão numérica como o erro na velocidade de fase das ondas devido à discretização espacial/temporal.",
                                    "Explique que leva a oscilações espúrias (ondas de alta frequência) atrás de descontinuidades.",
                                    "Discuta relação com esquemas de diferenças finitas: ordem de precisão afeta dispersão.",
                                    "Ilustre com gráfico qualitativo: solução exata vs numérica com dispersão.",
                                    "Relacione com equação de advecção: u_t + a u_x = 0."
                                  ],
                                  "verification": "Escreva a definição formal de dispersão e desenhe um gráfico ilustrativo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Slides ou vídeo sobre dispersão (ex: MIT OCW análise numérica), papel e lápis.",
                                  "tips": "Pense em dispersão como 'dispersão de cor' em imagens: ondas se separam por frequência.",
                                  "learningObjective": "Dominar definição precisa e intuição visual de dispersão numérica.",
                                  "commonMistakes": "Achar que dispersão só ocorre em esquemas não-consistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir análise de Von Neumann para fator de amplificação",
                                  "subSteps": [
                                    "Revise análise de Von Neumann: assumir solução u_j^n = g^n e^{i k j Δx}, onde g é fator de amplificação.",
                                    "Derive |g(k Δx)| ≤ 1 para estabilidade (dissipação/amplificação).",
                                    "Introduza fase: arg(g) ≈ -a k Δt para precisão (sem dispersão).",
                                    "Mostre que dispersão ocorre quando arg(g) ≠ velocidade de fase exata.",
                                    "Calcule g para esquema Lax-Friedrichs ou upwind como exemplo simples."
                                  ],
                                  "verification": "Compute g(k Δx) para esquema upwind e plote |g| e arg(g) vs k Δx.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB para plotar fatores de amplificação, fórmula de Von Neumann anotada.",
                                  "tips": "Normalice k Δx de 0 a π; foque em ondas de alta frequência (k Δx → π).",
                                  "learningObjective": "Aplicar Von Neumann para quantificar dispersão via desvio de fase.",
                                  "commonMistakes": "Esquecer o modo complexo exponencial ou confundir |g| com arg(g)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar esquemas centrados vs upwind na equação de advecção",
                                  "subSteps": [
                                    "Implemente esquema central: u_j^{n+1} = u_j^n - (a Δt / 2 Δx)(u_{j+1}^n - u_{j-1}^n).",
                                    "Implemente esquema upwind: u_j^{n+1} = u_j^n - (a Δt / Δx)(u_j^n - u_{j-1}^n) para a>0.",
                                    "Simule advecção de pulso ou degrau; observe oscilações no central (alta dispersão).",
                                    "Analise Von Neumann: central tem dispersão O(Δx^2), upwind tem dissipação mas baixa dispersão.",
                                    "Plote fatores de amplificação para ambos esquemas."
                                  ],
                                  "verification": "Gere plots de soluções numéricas e fatores g; identifique dispersão qualitativa/quantitativa.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código Python pronto (NumPy/Matplotlib), condição inicial degrau.",
                                  "tips": "Use Δt/Δx = 1 (CFL=1) para estabilidade; refine malha para ver convergência.",
                                  "learningObjective": "Ilustrar dispersão prática em esquemas comuns via simulação e análise.",
                                  "commonMistakes": "Não usar CFL adequado ou confundir dispersão com instabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar relação dispersão-esquemas e conclusões",
                                  "subSteps": [
                                    "Resuma: esquemas centrados de alta ordem têm mais dispersão em ondas curtas.",
                                    "Discuta trade-off: upwind reduz dispersão mas adiciona dissipação.",
                                    "Explore esquemas de alta resolução (ex: TVD) que minimizam ambos.",
                                    "Crie tabela comparativa: esquema, ordem dispersão, ordem dissipação.",
                                    "Reflita sobre implicações em problemas reais (choques)."
                                  ],
                                  "verification": "Elabore tabela comparativa e explique por que upwind é preferido para advecção com descontinuidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela em Excel ou Markdown, plots anteriores.",
                                  "tips": "Lembre: dispersão é erro de fase, dissipação é atenuação de amplitude.",
                                  "learningObjective": "Integrar conceitos em visão coesa sobre dispersão em diferenças finitas.",
                                  "commonMistakes": "Ignorar dependência em número de onda k."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com condição inicial um degrau em [0,1] usando esquema central de segunda ordem (Δx=0.01, CFL=0.9). Observe oscilações atrás da frente de onda (dispersão); contraste com upwind, que suaviza mas sem oscilações. Plote soluções em t=0.5 e fatores de amplificação Von Neumann.",
                              "finalVerifications": [
                                "Defina corretamente dispersão numérica e diferencie de truncamento/arredondamento.",
                                "Derive fator de amplificação para esquema upwind e interprete dispersão.",
                                "Explique por que esquemas centrados exibem mais dispersão que upwind.",
                                "Gere plot de solução numérica mostrando oscilações espúrias.",
                                "Compare ordens de erro de dispersão entre esquemas.",
                                "Identifique quando dispersão é crítica em simulações hiperbólicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenciação de tipos de erro (30%).",
                                "Correção matemática na análise de Von Neumann (25%).",
                                "Qualidade de simulações e plots ilustrativos (20%).",
                                "Profundidade na comparação de esquemas (15%).",
                                "Clareza em explicações e síntese (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e análise de Fourier em mecânica ondulatória.",
                                "Computação: Implementação eficiente de solvers numéricos em Python/Fortran.",
                                "Engenharia: Simulações CFD onde dispersão afeta precisão em aerodinâmica.",
                                "Matemática Aplicada: Análise espectral e estabilidade de PDEs discretas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), dispersão numérica em esquemas para equações de Navier-Stokes causa oscilações artificiais em frentes de choque, levando a erros em projetos de aviões ou previsão de tempo; esquemas upwind ou limitadores TVD minimizam isso para resultados confiáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Calcular a velocidade de fase dispersiva em um esquema numérico",
                            "description": "Derivar e calcular a velocidade de fase numérica ξ(kΔx) para um esquema de diferenças finitas, como o de Lax-Friedrichs ou Lax-Wendroff, e compará-la com a velocidade de fase exata c, identificando regimes onde |ξ - c| é significativo para números de onda k altos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de dispersão numérica e velocidade de fase",
                                  "subSteps": [
                                    "Estude a equação de advecção linear u_t + c u_x = 0 e sua solução exata na forma de onda plana e^{i(kx - ωt)}.",
                                    "Defina a velocidade de fase exata c = ω / k.",
                                    "Explique o conceito de dispersão numérica: variação da velocidade de fase com o número de onda k.",
                                    "Identifique a velocidade de fase numérica ξ(kΔx) como ξ = [arg(g(kΔx)) / Δt] / k, onde g é o símbolo de amplificação.",
                                    "Revise os esquemas Lax-Friedrichs e Lax-Wendroff, anotando suas formas discretas."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um diagrama comparando fase exata e numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Papel e caneta",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Comece pela solução exata para fixar ideias.",
                                    "Use notação consistente: θ = kΔx.",
                                    "Assuma c > 0 sem perda de generalidade."
                                  ],
                                  "learningObjective": "Compreender a origem da dispersão numérica e sua relação com a velocidade de fase.",
                                  "commonMistakes": [
                                    "Confundir velocidade de fase com velocidade de grupo.",
                                    "Esquecer a dependência em θ = kΔx.",
                                    "Ignorar a normalização por Δt."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o símbolo de amplificação g(θ) para um esquema específico",
                                  "subSteps": [
                                    "Escolha o esquema Lax-Friedrichs: u_j^{n+1} = (u_{j-1}^n + u_{j+1}^n)/2 - r/2 (u_{j+1}^n - u_{j-1}^n), onde r = cΔt/Δx.",
                                    "Assuma solução numérica u_j^n = g^n e^{i k j Δx} e substitua na equação discreta.",
                                    "Simplifique para obter g(θ) = |g| e^{i φ(θ)}, com θ = kΔx.",
                                    "Calcule explicitamente: g(θ) = cos(θ) - i r sin(θ) para Lax-Friedrichs.",
                                    "Repita para Lax-Wendroff se desejar: g(θ) = 1 - (r θ sin(θ)/2)^2 + i (r sin(θ) - r^3 θ^2 sin(θ)/6)."
                                  ],
                                  "verification": "Verifique |g(θ)| ≤ 1 para estabilidade (r ≤ 1) e compute g(0) = 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou papel)",
                                    "Referência ao esquema (notas de aula)"
                                  ],
                                  "tips": [
                                    "Expanda senos e cossenos em termos de θ.",
                                    "Mantenha r fixo, ex: r=1 para simplicidade.",
                                    "Anote módulo e argumento separadamente."
                                  ],
                                  "learningObjective": "Derivar corretamente o símbolo de amplificação para esquemas de diferenças finitas.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo convectivo.",
                                    "Confundir índices j-1 e j+1.",
                                    "Esquecer o fator i na exponencial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a velocidade de fase numérica ξ(θ)",
                                  "subSteps": [
                                    "Extraia o argumento φ(θ) = arg(g(θ)) = atan2(Im(g), Re(g)).",
                                    "Compute ξ(θ) = - φ(θ) / (θ / c), normalizando pela velocidade exata (ajuste para ξ = c * [φ(θ)/θ]).",
                                    "Para Lax-Friedrichs: ξ(θ) = c * [atan(r sin(θ)/cos(θ)) / θ].",
                                    "Calcule numericamente ξ(θ) para θ = π/4, π/2, 3π/4.",
                                    "Compare valores: ξ(0) = c, mas ξ(π) ≠ c."
                                  ],
                                  "verification": "Tabela com θ, φ(θ), ξ(θ)/c; confirme ξ(0) = c.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software Python/MATLAB para atan2",
                                    "Planilha Excel"
                                  ],
                                  "tips": [
                                    "Use r=1 para cálculos manuais.",
                                    "Cuidado com descontinuidades em arg (use unwrap).",
                                    "Plote φ(θ)/θ vs θ."
                                  ],
                                  "learningObjective": "Extrair e calcular ξ(kΔx) a partir de g(θ).",
                                  "commonMistakes": [
                                    "Fórmula errada: ξ = φ / (k Δt), esquece normalização.",
                                    "Sinais negativos em arg.",
                                    "θ em radianos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ξ com c e analisar regimes de dispersão significativa",
                                  "subSteps": [
                                    "Plote ξ(θ)/c vs θ ∈ [0, π] para Lax-Friedrichs e Lax-Wendroff.",
                                    "Identifique onde |ξ - c| / |c| > 10%: tipicamente θ > π/2 (kΔx altos).",
                                    "Discuta implicações: ondas curtas (alta frequência) propagam mais devagar.",
                                    "Compare esquemas: Lax-Wendroff tem menos dispersão.",
                                    "Conclua regimes onde o esquema é preciso (baixa dispersão)."
                                  ],
                                  "verification": "Gráfico com curvas ξ/c e linha c/c=1; anote θ onde erro >5%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python (matplotlib, numpy)",
                                    "Referências comparativas"
                                  ],
                                  "tips": [
                                    "Use θ de 0 a π em 100 pontos.",
                                    "Sobreponha exata (linha reta 1).",
                                    "Log do erro relativo."
                                  ],
                                  "learningObjective": "Analisar numericamente diferenças e regimes críticos de dispersão.",
                                  "commonMistakes": [
                                    "Plote sem normalizar por c.",
                                    "Ignorar aliasing para θ>π.",
                                    "Confundir dispersão com dissipação."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Friedrichs com c=1, r=1, derive g(θ) = cos(θ) - i sin(θ), φ(θ) = -atan(tan(θ)), ξ(θ) = sin(θ)/θ. Plote ξ(θ)/c vs θ: observe ξ < c para θ>0, com erro significativo em θ≈π (ondas de 2 pontos por comprimento de onda).",
                              "finalVerifications": [
                                "Derivação correta de g(θ) para Lax-Friedrichs ou Lax-Wendroff.",
                                "Cálculo preciso de ξ(θ) para pelo menos 3 valores de θ.",
                                "Gráfico comparativo ξ vs c com identificação de regimes.",
                                "Explicação qualitativa da dispersão para k altos.",
                                "Verificação numérica: |ξ(0) - c| = 0 e |g(θ)| ≤1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação simbólica (sem erros algébricos).",
                                "Correção na fórmula de ξ(θ) e normalização.",
                                "Qualidade do gráfico: eixos rotulados, escalas adequadas.",
                                "Análise quantitativa: quantificação de |ξ - c|.",
                                "Profundidade da discussão de regimes e implicações.",
                                "Clareza na documentação (fórmulas, plots)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas em meios dispersivos (acústica, óptica).",
                                "Computação Científica: Implementação e análise de PDEs numéricas.",
                                "Engenharia: Simulações CFD onde dispersão afeta precisão.",
                                "Matemática Aplicada: Análise de estabilidade von Neumann."
                              ],
                              "realWorldApplication": "Em simulações numéricas de ondas sísmicas, acústica computacional ou modelagem de tráfego, onde dispersão numérica distorce fases de ondas curtas, levando a erros em previsões; otimizar malha (Δx pequeno) ou esquemas de alta ordem minimiza isso."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Identificar e mitigar dispersão em métodos para equações hiperbólicas",
                            "description": "Analisar esquemas explícitos e implícitos para a equação da onda ou advecção, determinando condições de dispersão mínima via relação de dispersão σ(kΔx) = ω(kΔx)/k - c, e discutir técnicas como filtros ou esquemas de alta ordem para redução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de dispersão numérica em equações hiperbólicas",
                                  "subSteps": [
                                    "Revise a equação da onda (u_t + c u_x = 0 ou u_tt = c^2 u_xx) e sua solução exata.",
                                    "Defina dispersão numérica como o erro de fase onde ondas de diferentes frequências propagam a velocidades diferentes.",
                                    "Compare com dissipação (amortecimento artificial de altas frequências).",
                                    "Estude a relação de dispersão σ(kΔx) = ω(kΔx)/k - c, onde ω é a frequência numérica.",
                                    "Analise exemplos qualitativos de dispersão em esquemas upwind vs. Lax-Wendroff."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre dispersão e dissipação, e esboce σ(kΔx) para um esquema dispersivo.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque 'Finite Difference Methods'), notebook Jupyter"
                                  ],
                                  "tips": "Visualize com animações de ondas numéricas vs. exatas para intuitar o efeito.",
                                  "learningObjective": "Dominar a definição e causas da dispersão em métodos hiperbólicos.",
                                  "commonMistakes": [
                                    "Confundir dispersão com dissipação",
                                    "Ignorar dependência em kΔx"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e analisar relações de dispersão para esquemas explícitos e implícitos",
                                  "subSteps": [
                                    "Derive a amplificação numérica g(kΔx) via substituição de Fourier na equação de advecção.",
                                    "Calcule ω(kΔx) = -Im(log g)/Δt para esquemas explícitos (ex: FTCS, Lax-Friedrichs).",
                                    "Repita para implícitos (ex: Backward Euler) e compare estabilidade vs. dispersão.",
                                    "Plote σ(kΔx) para diferentes CFL (ν = cΔt/Δx).",
                                    "Identifique regimes onde |σ| é mínimo (ex: ν=1 para upwind)."
                                  ],
                                  "verification": "Derive e plote σ(kΔx) para Lax-Wendroff e confirme dispersão de 3ª ordem.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software simbólico (SymPy/Python), MATLAB/Octave para plots"
                                  ],
                                  "tips": "Use expansão de Taylor para aproximar σ ≈ (Δx)^2 * erro de ordem.",
                                  "learningObjective": "Calcular quantitativamente a dispersão via análise von Neumann.",
                                  "commonMistakes": [
                                    "Erro no sinal de ω",
                                    "Esquecer fator i na Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar condições de dispersão mínima",
                                  "subSteps": [
                                    "Encontre ν onde max|σ(kΔx)| é mínimo para esquemas lineares.",
                                    "Analise esquemas não oscilatórios (TVD) e sua relação com dispersão.",
                                    "Compare ordens: 1ª ordem (alta dispersão), 3ª ordem (baixa para baixas k).",
                                    "Discuta trade-offs: estabilidade vs. precisão de fase.",
                                    "Teste numericamente com pacotes como Clawpack."
                                  ],
                                  "verification": "Identifique o CFL ótimo para mínimo erro de fase em equação de advecção.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Clawpack ou código Python customizado",
                                    "Artigos sobre análise de dispersão"
                                  ],
                                  "tips": "Integre σ ao longo de k para métrica global de dispersão.",
                                  "learningObjective": "Otimizar parâmetros numéricos para minimizar dispersão.",
                                  "commonMistakes": [
                                    "Focar só em estabilidade, ignorando fase",
                                    "Usar kΔx=π como único teste"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar técnicas de mitigação da dispersão",
                                  "subSteps": [
                                    "Implemente filtros de baixa passagem (ex: filtro de Shuman) pós-esquema.",
                                    "Estude esquemas de alta ordem (WENO, compactos) e sua σ reduzida.",
                                    "Aplique downwinding ou adaptação de malha h-adaptive.",
                                    "Compare antes/depois em simulações de onda com pacotes.",
                                    "Discuta custos computacionais vs. ganhos."
                                  ],
                                  "verification": "Aplique filtro e demonstre redução de σ em plot numérico.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código Python (NumPy/SciPy), exemplos de Dedalus ou PyClaw"
                                  ],
                                  "tips": "Comece com 1D advecção para simplicidade antes de 2D ondas.",
                                  "learningObjective": "Aplicar e avaliar métodos para reduzir dispersão.",
                                  "commonMistakes": [
                                    "Filtros excessivos causam dissipação",
                                    "Alta ordem sem limiter causa oscilações"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar análise em simulação prática",
                                  "subSteps": [
                                    "Simule equação da onda com esquema dispersivo e meça erro de fase.",
                                    "Mitigue com técnica escolhida e quantifique melhoria.",
                                    "Analise espectro de Fourier para validar σ.",
                                    "Documente relatório com plots de σ e soluções.",
                                    "Teste sensibilidade a ν e resolução."
                                  ],
                                  "verification": "Produza relatório mostrando redução de dispersão >50%.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Jupyter notebook completo",
                                    "Referências: Gustafsson et al. 'Time Dependent Problems'"
                                  ],
                                  "tips": "Use condições periódicas para análise Fourier limpa.",
                                  "learningObjective": "Sintetizar identificação e mitigação em projeto numérico.",
                                  "commonMistakes": [
                                    "Pouca resolução em k",
                                    "Ignorar erros de fronteira"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com pulso gaussiano usando esquema Lax-Wendroff (ν=0.9). Observe dispersão de trailing oscillations após t=10. Calcule σ(kΔx), aplique filtro de Shuman e reduza oscilações em 70%.",
                              "finalVerifications": [
                                "Deriva corretamente σ para FTCS e Lax-Wendroff.",
                                "Identifica CFL ótimo para mínima dispersão.",
                                "Implementa filtro e demonstra redução em simulação.",
                                "Compara trade-offs de esquemas explícito/implícito.",
                                "Analisa espectro Fourier de solução numérica.",
                                "Documenta relatório com plots quantitativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ω(kΔx) (80% correto).",
                                "Plots de σ mostram mínimo claro e dependência ν.",
                                "Simulação prática com mitigação efetiva (>50% redução).",
                                "Explicação clara de técnicas (filtros/alta ordem).",
                                "Identificação correta de erros comuns.",
                                "Relatório estruturado com verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas em acústica e eletromagnetismo.",
                                "Computação: Análise de estabilidade em PDE solvers (FFT, espectral).",
                                "Engenharia: Simulações CFD onde dispersão afeta precisão de choques.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, mitigar dispersão assegura precisão na propagação de ondas P/S, evitando artefatos em imagens geológicas e melhorando detecção de reservatórios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Dissipação Numérica",
                        "description": "A dissipação numérica refere-se ao amortecimento artificial das componentes de alta frequência nas soluções numéricas obtidas por métodos de diferenças finitas, especialmente em esquemas upwind ou com viscosidade numérica, afetando a precisão em equações parabólicas e hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Definir dissipação numérica e seu impacto na estabilidade",
                            "description": "Descrever a dissipação numérica como o módulo do fator de amplificação |g(k)| < 1 para números de onda k > 0, contrastando com esquemas não dissipativos, e relacionar com estabilidade de Von Neumann em métodos para equações de calor ou advecção-difusão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de dissipação numérica",
                                  "subSteps": [
                                    "Revise a definição de dissipação numérica como a propriedade de um esquema numérico onde componentes de alta frequência (números de onda k > 0) são atenuados.",
                                    "Estude a representação matemática: módulo do fator de amplificação |g(k)| < 1 para k ≠ 0.",
                                    "Identifique que isso simula a dissipação física em equações parabólicas como a de calor.",
                                    "Compare com a solução exata, onde modos de alta frequência decaem.",
                                    "Anote exemplos de esquemas dissipativos vs. não dissipativos."
                                  ],
                                  "verification": "Escreva uma definição precisa em suas próprias palavras e verifique se menciona |g(k)| < 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula sobre diferenças finitas.",
                                  "tips": "Use analogias físicas como amortecimento de vibrações para visualizar.",
                                  "learningObjective": "Definir dissipação numérica e sua representação matemática básica.",
                                  "commonMistakes": "Confundir dissipação com dispersão; dissipação atenua amplitudes, não altera fases."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a análise de Von Neumann e o fator de amplificação",
                                  "subSteps": [
                                    "Recapitule a análise de Von Neumann: assuma solução modal e^{i k x} e derive g(k).",
                                    "Calcule g(k) para esquemas simples, como Lax-Friedrichs para advecção.",
                                    "Plote |g(k)| vs. k para visualizar atenuação em altas frequências.",
                                    "Verifique |g(0)| = 1 para preservar a componente de baixa frequência.",
                                    "Implemente um script simples em Python/MATLAB para computar g(k)."
                                  ],
                                  "verification": "Gere um gráfico de |g(k)| mostrando |g(k)| < 1 para k > 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Python com NumPy/Matplotlib, MATLAB), exemplos de esquemas numéricos.",
                                  "tips": "Comece com k discretos (0 a π) para simplificar cálculos.",
                                  "learningObjective": "Calcular e interpretar o fator de amplificação g(k) na análise de Von Neumann.",
                                  "commonMistakes": "Esquecer a normalização |g(0)| = 1; isso garante consistência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o impacto da dissipação na estabilidade numérica",
                                  "subSteps": [
                                    "Relacione dissipação à estabilidade: |g(k)| ≤ 1 + O(Δt) garante estabilidade para todos k.",
                                    "Estude equações de calor: esquema explícito é dissipativo e condicionalmente estável.",
                                    "Simule numericamente uma instabilidade sem dissipação (ex: upwind sem viscosidade).",
                                    "Discuta como dissipação artificial controla modos espúrios.",
                                    "Resolva um problema de teste com e sem dissipação."
                                  ],
                                  "verification": "Execute uma simulação estável e compare com instável, documentando diferenças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código fonte para equação de calor (Python/MATLAB), computador.",
                                  "tips": "Use r = α Δt / Δx² < 1/2 para estabilidade explícita.",
                                  "learningObjective": "Explicar como dissipação numérica promove estabilidade via |g(k)| < 1.",
                                  "commonMistakes": "Ignorar o papel em equações hiperbólicas; dissipação excessiva pode suavizar soluções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar esquemas dissipativos e não dissipativos",
                                  "subSteps": [
                                    "Defina esquemas não dissipativos: |g(k)| = 1 para todos k (ex: Leapfrog).",
                                    "Compare com dissipativos em termos de estabilidade e precisão.",
                                    "Aplique a equações de advecção-difusão: adicione termo difusivo.",
                                    "Avalie trade-offs: dissipação melhora estabilidade mas introduz erro.",
                                    "Crie uma tabela comparativa de exemplos clássicos."
                                  ],
                                  "verification": "Preencha uma tabela comparando 3 esquemas, justificando impactos na estabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela em papel ou Excel, referências de métodos numéricos.",
                                  "tips": "Foco em exemplos padrão como FTCS (instável) vs. BTCS (dissipativo).",
                                  "learningObjective": "Diferenciar e relacionar dissipação com estabilidade em contextos específicos.",
                                  "commonMistakes": "Confundir não dissipativo com instável; Leapfrog é não dissipativo e estável."
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Friedrichs na equação de advecção u_t + a u_x = 0, o fator g(k) = cos(k Δx) - i (a Δt / Δx) sin(k Δx), com |g(k)| < 1 para k > 0, demonstrando dissipação que estabiliza simulações de ondas.",
                              "finalVerifications": [
                                "Defina dissipação numérica usando |g(k)| < 1 corretamente.",
                                "Plote |g(k)| para um esquema dissipativo mostrando atenuação.",
                                "Explique estabilidade de Von Neumann para equação de calor.",
                                "Compare Lax-Friedrichs (dissipativo) com Leapfrog (não dissipativo).",
                                "Simule um caso onde falta de dissipação causa instabilidade.",
                                "Relacione a equações de advecção-difusão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de dissipação (|g(k)| < 1).",
                                "Correta interpretação do fator de amplificação via Von Neumann.",
                                "Análise clara do impacto na estabilidade.",
                                "Comparação adequada entre esquemas dissipativos e não dissipativos.",
                                "Uso de exemplos concretos de equações de calor/advecção-difusão.",
                                "Demonstração prática via simulação ou gráfico."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com amortecimento em equações de difusão térmica.",
                                "Computação: Implementação eficiente em simulações CFD.",
                                "Engenharia: Estabilidade em modelagem numérica de fluidos.",
                                "Matemática Aplicada: Análise de estabilidade em EDOs/PDEs."
                              ],
                              "realWorldApplication": "Em simulações climáticas, dissipação numérica em modelos de diferenças finitas previne instabilidades em previsões de longo prazo para equações de advecção-difusão, garantindo precisão em padrões de temperatura oceânica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Avaliar o fator de dissipação em esquemas de diferenças finitas",
                            "description": "Computar o fator de amplificação |g(θ)| onde θ = kΔx, para esquemas como upwind (dissipativo) versus Leapfrog (não dissipativo), plotando o diagrama de dissipação e identificando o regime de resolução onde a dissipação é excessiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar esquemas de diferenças finitas: Upwind e Leapfrog",
                                  "subSteps": [
                                    "Estude a equação de advecção linear: ∂u/∂t + c ∂u/∂x = 0.",
                                    "Descreva o esquema upwind: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), onde λ = c Δt / Δx.",
                                    "Descreva o esquema Leapfrog: u_j^{n+1} = u_j^{n-1} - λ (u_{j+1}^n - u_{j-1}^n).",
                                    "Identifique propriedades: upwind é dissipativo, Leapfrog é não dissipativo.",
                                    "Compare estabilidades e precisões teóricas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre os esquemas e liste suas formas explícitas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre métodos de diferenças finitas",
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas de stencil para visualizar os pontos usados em cada esquema.",
                                  "learningObjective": "Compreender as diferenças estruturais e propriedades iniciais de dissipação nos esquemas upwind e Leapfrog.",
                                  "commonMistakes": [
                                    "Confundir upwind com Lax-Friedrichs",
                                    "Esquecer que Leapfrog é de dois níveis temporais",
                                    "Ignorar a dependência de λ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o fator de amplificação g(θ) para cada esquema",
                                  "subSteps": [
                                    "Assuma solução modal: u_j^n = g^n e^{i k j Δx}, onde θ = k Δx.",
                                    "Para upwind: substitua na equação e resolva para g(θ) = 1 - λ (1 - e^{-iθ}).",
                                    "Para Leapfrog: derive g(θ) = 1 - i λ sin(θ), considerando o modo físico.",
                                    "Compute |g(θ)| explicitamente: |g_upwind| = |1 - λ (1 - cosθ + i sinθ)|, |g_leapfrog| = |cosθ|.",
                                    "Verifique para θ=0: |g|≈1, e para θ=π: dissipação alta no upwind."
                                  ],
                                  "verification": "Escreva as expressões exatas de g(θ) e |g(θ)| para ambos esquemas e teste para θ=π/2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folha de derivadas von Neumann",
                                    "Referência: notas sobre análise de von Neumann"
                                  ],
                                  "tips": "Use a identidade e^{iθ} = cosθ + i sinθ para simplificar.",
                                  "learningObjective": "Derivar analiticamente os fatores de amplificação e entender sua dependência em θ.",
                                  "commonMistakes": [
                                    "Erro na expansão exponencial",
                                    "Confundir |g| com Re(g)",
                                    "Esquecer normalização |g| ≤1 para estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar o diagrama de dissipação |g(θ)| vs θ",
                                  "subSteps": [
                                    "Escolha λ fixo (ex: λ=0.5 para upwind estável).",
                                    "Gere θ de 0 a π com 100 pontos.",
                                    "Implemente funções para |g_upwind(θ)| e |g_leapfrog(θ)| em Python/MATLAB.",
                                    "Plote |g| vs θ para ambos esquemas no mesmo gráfico, com legenda e eixos rotulados.",
                                    "Adicione linha |g|=1 e destaque regiões θ pequeno (alta resolução)."
                                  ],
                                  "verification": "Gere o plot e confirme que upwind decai monotonicamente, Leapfrog oscila em torno de 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Jupyter Notebook",
                                    "Código template para análise von Neumann"
                                  ],
                                  "tips": "Use np.linspace(0, np.pi, 100) para θ suave.",
                                  "learningObjective": "Visualizar numericamente a dissipação através de plots precisos.",
                                  "commonMistakes": [
                                    "Plotar para θ>π (periódico)",
                                    "Escala errada no eixo y (0-1.1)",
                                    "Esquecer λ na upwind"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e identificar regimes de dissipação excessiva",
                                  "subSteps": [
                                    "Examine o plot: onde |g(θ)| < 0.9 para upwind vs Leapfrog.",
                                    "Defina 'excessiva': ex: |g(θ)| < 0.5 para θ < π/4 (ondas resolvidas).",
                                    "Calcule θ_crítico onde dissipação >10% para upwind.",
                                    "Compare: Leapfrog preserva amplitude para θ<π/2, upwind dissipa sempre.",
                                    "Discuta impacto: upwind smoothes altas frequências, bom para estabilidade."
                                  ],
                                  "verification": "Escreva relatório curto: 'Regime excessivo para upwind: θ < X, onde |g|<Y'.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Plot gerado do step 3",
                                    "Ferramenta de zoom/plot interativo",
                                    "Papel para anotações analíticas"
                                  ],
                                  "tips": "Foque em θ baixo: alta resolução (Δx << λ_onda).",
                                  "learningObjective": "Interpretar diagramas para identificar trade-offs dissipação vs resolução.",
                                  "commonMistakes": [
                                    "Chamar Leapfrog dissipativo (é neutro)",
                                    "Ignorar que dissipação é desejável para num. viscosidade",
                                    "Confundir com dispersão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de onda acústica em tubo (c=1), use upwind com Δx=0.1 (θ_max=π/10 para k_max). Plot |g(θ)| mostra dissipação de 5% em modos resolvidos (θ<0.3), excessiva para precisão longa-tempo; Leapfrog mantém amplitude mas oscila.",
                              "finalVerifications": [
                                "Derivação correta de |g(θ)| para upwind e Leapfrog.",
                                "Plot preciso com |g_upwind| decaindo e |g_leapfrog| ≈1 até θ=π/2.",
                                "Identificação quantitativa de θ onde |g|<0.9.",
                                "Explicação verbal das implicações para escolha de esquema.",
                                "Comparação com literatura (ex: |g_upwind| = |1-λ+λ cosθ - i λ sinθ|).",
                                "Código reproduzível para plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (100% correto).",
                                "Qualidade do plot: legível, rotulado, comparativo.",
                                "Análise quantitativa: thresholds numéricos para regimes.",
                                "Profundidade de interpretação: trade-offs dissipação/estabilidade.",
                                "Clareza na comunicação: relatório conciso.",
                                "Originalidade no exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e estabilidade em equações de advecção.",
                                "Programação: Implementação numérica e visualização com Python/MATLAB.",
                                "Engenharia: Aplicações em CFD para controle de viscosidade numérica.",
                                "Matemática Aplicada: Análise de Fourier e estabilidade von Neumann.",
                                "Computação Científica: Otimização de esquemas em simulações."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), upwind dissipa energia em escalas pequenas para evitar instabilidades; Leapfrog usado em acoustics para preservar ondas sem amortecimento artificial, ajustando resolução Δx para evitar dissipação excessiva em mesoescalas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Comparar dissipação em métodos explícitos e implícitos",
                            "description": "Analisar a dissipação em métodos explícitos (e.g., FTCS instável) versus implícitos (e.g., Crank-Nicolson com baixa dissipação) para equações parabólicas, calculando taxas de dissipação e discutindo trade-offs com dispersão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Dissipação Numérica",
                                  "subSteps": [
                                    "Defina dissipação numérica como o amortecimento artificial de componentes de alta frequência em esquemas de diferenças finitas.",
                                    "Explique o papel da dissipação na estabilidade e precisão de soluções para equações parabólicas, como a equação de calor.",
                                    "Revise a análise de von Neumann para decompor erros em componentes de Fourier e identificar taxas de dissipação.",
                                    "Discuta como a dissipação é quantificada pelo módulo da função de amplificação |G(θ)|, onde θ é o número de onda.",
                                    "Identifique diferenças qualitativas entre métodos explícitos e implícitos em termos de comportamento dissipativo."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de |G(θ)| >1 levando a instabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (e.g., LeVeque), notas de aula sobre von Neumann",
                                    "Software MATLAB ou Python (NumPy/SciPy)"
                                  ],
                                  "tips": "Comece com equações parabólicas 1D para simplicidade; visualize |G(θ)| plotando para diferentes esquemas.",
                                  "learningObjective": "Compreender a dissipação numérica e sua medição via análise de von Neumann.",
                                  "commonMistakes": [
                                    "Confundir dissipação com dispersão",
                                    "Ignorar dependência em θ",
                                    "Não normalizar pelo passo de tempo Δt"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Dissipação no Método Explícito FTCS",
                                  "subSteps": [
                                    "Implemente o esquema FTCS para a equação de calor u_t = u_xx: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = Δt/Δx².",
                                    "Derive a função de amplificação G(θ) = 1 - 4r sin²(θ/2) via análise de von Neumann.",
                                    "Calcule a taxa de dissipação: |G(θ)| ≈ 1 - 2r θ² para θ pequeno (baixa dissipação em baixas frequências).",
                                    "Identifique instabilidade para r > 0.5, onde |G(θ)| >1 para alguns θ.",
                                    "Simule numericamente uma solução com ruído inicial e observe amplificação de altas frequências."
                                  ],
                                  "verification": "Plote |G(θ)| para r=0.4 e mostre que |G| <1 para todos θ, mas próxima de 1 para θ=π.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para FTCS",
                                    "Gráficos de |G(θ)|",
                                    "Solução analítica da equação de calor"
                                  ],
                                  "tips": "Use θ de 0 a π; compare com solução exata para validar implementação.",
                                  "learningObjective": "Derivar e interpretar a dissipação no FTCS, destacando alta dissipação em altas frequências.",
                                  "commonMistakes": [
                                    "Erro na derivação de G(θ): esquecer o fator sin²",
                                    "Escolher r>0.5 sem notar instabilidade",
                                    "Não plotar para múltiplos θ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Dissipação no Método Implícito Crank-Nicolson",
                                  "subSteps": [
                                    "Implemente Crank-Nicolson: média de FTCS explícito e implícito, resolvendo sistema linear em cada passo.",
                                    "Derive G(θ) = [1 - 2r sin²(θ/2)] / [1 + 2r sin²(θ/2)].",
                                    "Calcule taxa de dissipação: |G(θ)| ≈ 1 - (r θ²)/2, mostrando baixa dissipação mesmo para r grande.",
                                    "Note incondicionalmente estável: |G(θ)| ≤1 para todo r>0.",
                                    "Simule com mesmos dados iniciais do FTCS e compare decaimento de modos de alta frequência."
                                  ],
                                  "verification": "Plote |G(θ)| para r=1 e r=10, confirmando |G| sempre <1 e próxima de 1 para baixas frequências.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Solver linear em Python (SciPy sparse)",
                                    "Código para Crank-Nicolson",
                                    "Mesma malha do passo anterior"
                                  ],
                                  "tips": "Use solvers eficientes para sistemas tridiagonais; compare tempos de computação.",
                                  "learningObjective": "Demonstrar baixa dissipação e estabilidade incondicional do Crank-Nicolson.",
                                  "commonMistakes": [
                                    "Erro na fórmula de G(θ): inverter numerador/denominador",
                                    "Ignorar custo computacional implícito",
                                    "Não testar estabilidade numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Dissipação, Calcular Taxas e Discutir Trade-offs",
                                  "subSteps": [
                                    "Compare |G(θ)| plots lado a lado para FTCS e Crank-Nicolson em mesma escala r.",
                                    "Calcule taxas de dissipação: d|G|/dθ² em θ→0 para ambos.",
                                    "Quantifique trade-offs: FTCS dissipativo mas simples/rápido; CN preciso mas caro.",
                                    "Discuta impacto na dispersão: CN tem menos dissipação mas mais dispersão de fase.",
                                    "Realize simulação comparativa com pulso inicial e analise erros em L2 e altas frequências."
                                  ],
                                  "verification": "Tabela comparativa de taxas de dissipação e relatório de 300 palavras sobre trade-offs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Códigos dos passos anteriores",
                                    "Ferramentas de plotagem (Matplotlib)",
                                    "Referências sobre dispersão (e.g., fórmula de fase)"
                                  ],
                                  "tips": "Normalize por Δt para taxas justas; inclua gráfico de erro vs tempo.",
                                  "learningObjective": "Sintetizar comparação quantitativa e qualitativa, incluindo trade-offs com dispersão.",
                                  "commonMistakes": [
                                    "Comparar em r diferentes",
                                    "Focar só em estabilidade ignorando precisão",
                                    "Não mencionar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de calor 1D em uma barra de 1m com pulso gaussiano inicial u(x,0)=exp(-(x-0.5)^2/0.01), condições de Dirichlet u(0,t)=u(1,t)=0. Use Δx=0.01, Δt=0.0001 para FTCS (r=0.1) e Crank-Nicolson (r=1). Compare perfis u(x,t=0.1) e espectros de Fourier para observar dissipação excessiva no FTCS em altas frequências vs preservação no CN.",
                              "finalVerifications": [
                                "Deriva corretamente G(θ) para FTCS e Crank-Nicolson.",
                                "Plota e interpreta |G(θ)| mostrando maior dissipação no FTCS.",
                                "Calcula taxas de dissipação assintóticas corretamente.",
                                "Identifica trade-offs: estabilidade vs custo e dispersão.",
                                "Simulação numérica reproduz comportamento esperado.",
                                "Relatório discute aplicações reais como modelagem térmica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de funções de amplificação (80% correto).",
                                "Qualidade dos plots comparativos e análises quantitativas.",
                                "Profundidade na discussão de trade-offs com dispersão.",
                                "Correção e eficiência das implementações numéricas.",
                                "Clareza e completude do relatório final.",
                                "Capacidade de conectar a conceitos mais amplos de análise numérica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e amortecimento em ondas.",
                                "Engenharia Computacional: Otimização de esquemas numéricos em CFD.",
                                "Matemática Aplicada: Análise de estabilidade via von Neumann em PDEs.",
                                "Programação Científica: Uso de solvers lineares e análise espectral."
                              ],
                              "realWorldApplication": "Em simulações de transferência de calor em engenharia aeroespacial, métodos explícitos como FTCS são usados para protótipos rápidos apesar da dissipação (smearing de frentes térmicas), enquanto Crank-Nicolson é preferido em simulações precisas de reatores nucleares para preservar gradientes sem oscilações artificiais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Análise Comparativa de Dispersão e Dissipação",
                        "description": "Análise integrada dos erros de dispersão e dissipação nos métodos de diferenças finitas, incluindo sua interação em esquemas para PDEs e estratégias de balanceamento para minimizar ambos em problemas de onda e transporte.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Realizar análise de Von Neumann para erros combinados",
                            "description": "Aplicar análise de Von Neumann para decompor o fator de amplificação em componentes dispersiva (parte imaginária) e dissipativa (parte real), para esquemas como Lax-Wendroff, e interpretar o plano complexo g(θ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais da Análise de Von Neumann",
                                  "subSteps": [
                                    "Estudar a equação modelo (ex: equação de advecção linear ∂u/∂t + c ∂u/∂x = 0).",
                                    "Entender a solução em Fourier: u_j^n = ∑ g(θ)^n e^{i θ j} ξ(x,t).",
                                    "Definir o fator de amplificação g(θ) = |g(θ)| e^{i φ(θ)}.",
                                    "Explicar componentes: parte real (dissipação) e imaginária (dispersão).",
                                    "Derivar a condição de estabilidade |g(θ)| ≤ 1 para todo θ."
                                  ],
                                  "verification": "Resumir em um parágrafo os componentes de g(θ) e sua interpretação física.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula, calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Visualize g(θ) no plano complexo para intuitar dispersão (desvio de fase) vs dissipação (amortecimento).",
                                  "learningObjective": "Compreender a base teórica da análise de Von Neumann para esquemas de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir dispersão com dissipação",
                                    "Ignorar dependência em θ",
                                    "Esquecer normalização da solução Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Fator de Amplificação para o Esquema Lax-Wendroff",
                                  "subSteps": [
                                    "Escrever o esquema Lax-Wendroff para advecção: u_j^{n+1} = u_j^n - (σ/2)(u_{j+1}^n - u_{j-1}^n) + (σ²/2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde σ = c Δt / Δx.",
                                    "Substituir solução Fourier: u_j^n = g(θ)^n e^{i θ j}.",
                                    "Derivar g(θ) = 1 - 2 i σ sin(θ) - 2 σ² (1 - cos(θ)).",
                                    "Simplificar: g(θ) = 1 - 2 σ² (1 - cos(θ)) - i 2 σ sin(θ).",
                                    "Verificar estabilidade para |σ| ≤ 1."
                                  ],
                                  "verification": "Implementar cálculo em código Python/MATLAB e plotar |g(θ)| e arg(g(θ)) para σ=0.9.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB, template de código para análise Von Neumann"
                                  ],
                                  "tips": "Use identidades trigonométricas: 1 - cos(θ) = 2 sin²(θ/2), sin(θ) = 2 sin(θ/2)cos(θ/2).",
                                  "learningObjective": "Dominar o cálculo explícito de g(θ) para esquemas parabólicos como Lax-Wendroff.",
                                  "commonMistakes": [
                                    "Erro no stencil do esquema",
                                    "Confundir σ com λ",
                                    "Não expandir corretamente os termos exponenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decompor g(θ) em Componentes Dispersiva e Dissipativa",
                                  "subSteps": [
                                    "Identificar parte real: Re[g(θ)] = 1 - 2 σ² (1 - cos(θ)) (dissipativa, controla amplitude).",
                                    "Identificar parte imaginária: Im[g(θ)] = -2 σ sin(θ) (dispersiva, controla fase).",
                                    "Calcular módulo |g(θ)| = sqrt( Re² + Im² ) e fase φ(θ) = atan2(Im, Re).",
                                    "Analisar erros: dissipação numérica quando |g| < 1, dispersão quando φ(θ) ≠ -σ θ.",
                                    "Expandir em série de Taylor para θ pequeno: comparar com solução exata."
                                  ],
                                  "verification": "Plotar Re[g], Im[g], |g(θ)| e φ(θ) + σ θ no plano complexo e identificar desvios.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de plotagem (Matplotlib, GNUPlot), papel e lápis para derivações"
                                  ],
                                  "tips": "Para erros combinados, note que Lax-Wendroff tem dissipação de ordem 3 e dispersão de ordem 3 em θ.",
                                  "learningObjective": "Decompor e quantificar erros numéricos em termos de dispersão e dissipação.",
                                  "commonMistakes": [
                                    "Trocar real/imaginário",
                                    "Não normalizar fase corretamente",
                                    "Ignorar termos de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Plano Complexo g(θ) e Analisar Erros Combinados",
                                  "subSteps": [
                                    "Plotar g(θ) no plano complexo para θ de 0 a π.",
                                    "Interpretar: círculo unitário ideal; desvios radiais = dissipação; angulares = dispersão.",
                                    "Comparar com esquemas upwind ou Beam-Warming para erros combinados.",
                                    "Calcular métricas: dissipation error = 1 - |g(θ)|, dispersion error = φ(θ) + σ θ.",
                                    "Discutir implicações: oscilações (dispersão dominante) vs amortecimento excessivo."
                                  ],
                                  "verification": "Produzir relatório com plots e tabela de erros para σ=0.5, 0.9 em Lax-Wendroff vs exato.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código de análise Von Neumann pronto, LaTeX para relatório"
                                  ],
                                  "tips": "Use log-scale para erros pequenos; foque em θ ~ π (modos de alta frequência).",
                                  "learningObjective": "Interpretar graficamente erros combinados e propor melhorias em esquemas.",
                                  "commonMistakes": [
                                    "Plot errôneo do plano complexo",
                                    "Confundir erros de fase com amplitude",
                                    "Não considerar CFL"
                                  ]
                                }
                              ],
                              "practicalExample": "Aplique a análise a um problema de advecção com pulso gaussiano usando Lax-Wendroff (σ=0.9). Simule numericamente, compare com exato, e use Von Neumann para explicar dispersão leading a oscilações atrás da frente de onda e dissipação suavizando o pulso.",
                              "finalVerifications": [
                                "g(θ) calculado corretamente para Lax-Wendroff com todas as componentes.",
                                "Plots do plano complexo mostram dissipação (dentro do círculo unitário) e dispersão (desvio angular).",
                                "Erros de dispersão e dissipação quantificados via Taylor para θ baixo.",
                                "Interpretação física coerente: alta frequência dissipada, ondas de fase distorcidas.",
                                "Comparação com upwind destaca trade-off dissipação-dispersão.",
                                "Código reproduzível gera plots idênticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo de g(θ) (sem erros algébricos).",
                                "Qualidade dos plots e interpretações no plano complexo.",
                                "Correta decomposição em real/imaginário e análise de erros combinados.",
                                "Uso apropriado de expansões assintóticas para interpretação.",
                                "Clareza na ligação entre análise teórica e comportamento numérico.",
                                "Originalidade na extensão a outro esquema ou parâmetro."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com amortecimento e refração de ondas em meios dispersivos.",
                                "Computação: Implementação eficiente de FFT para análise de erros em simulações.",
                                "Engenharia: Otimização de esquemas em CFD para minimizar erros numéricos.",
                                "Estatística: Análise de erros espectrais em dados simulados."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM), análise Von Neumann otimiza esquemas de advecção para reduzir dispersão em frentes de tempestade e dissipação em vórtices, melhorando previsões de longo prazo sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Avaliar trade-offs entre dispersão e dissipação",
                            "description": "Discutir e quantificar o dilema de Godunov-Tvd: esquemas dissipativos reduzem oscilações mas borram choques, enquanto dispersivos preservam picos mas oscilam; exemplificar com simulações numéricas simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Dispersão e Dissipação Numérica",
                                  "subSteps": [
                                    "Defina dispersão numérica como a distorção de fase em soluções numéricas de equações de onda.",
                                    "Defina dissipação numérica como a atenuação artificial de amplitude em esquemas de diferenças finitas.",
                                    "Estude a relação com a equação de convecção linear: ∂u/∂t + a ∂u/∂x = 0.",
                                    "Analise o espectro de Fourier para identificar componentes dispersivas e dissipativas.",
                                    "Compare com comportamento analítico exato."
                                  ],
                                  "verification": "Resuma definições em um parágrafo e identifique diferenças em um diagrama simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notebook Jupyter com NumPy/Matplotlib.",
                                  "tips": "Use animações de ondas para visualizar intuitivamente.",
                                  "learningObjective": "Distinguir dispersão de dissipação e sua origem em esquemas numéricos.",
                                  "commonMistakes": "Confundir dispersão com difusão física real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Esquemas Dissipativos e Dispersivos Clássicos",
                                  "subSteps": [
                                    "Implemente o esquema upwind (dissipativo) para a equação de Burgers.",
                                    "Implemente o esquema Lax-Wendroff (dispersivo) e compare amplificação numérica.",
                                    "Calcule os símbolos de dissipação e dispersão via análise de von Neumann.",
                                    "Plote curvas de dispersão/dissipação no plano (ω, kΔx).",
                                    "Discuta estabilidade e precisão de cada esquema."
                                  ],
                                  "verification": "Gere plots comparativos mostrando atenuação vs. oscilações.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com SciPy, código-fonte de esquemas de diferenças finitas.",
                                  "tips": "Normalize frequências para facilitar comparação.",
                                  "learningObjective": "Quantificar dissipação e dispersão em esquemas específicos.",
                                  "commonMistakes": "Ignorar condições CFL na estabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Dilema de Godunov-TVD",
                                  "subSteps": [
                                    "Descreva o dilema: dissipativos borram choques, dispersivos oscilam pós-choque.",
                                    "Estude limitadores TVD (ex: minmod, superbee) para balancear.",
                                    "Compare Godunov clássico com TVD em solução de Riemann.",
                                    "Quantifique trade-offs: métrica de borramento (entropy fix) vs. overshoots.",
                                    "Discuta hierarquia: 1ª ordem dissipativa → 2ª ordem dispersiva → TVD híbrido."
                                  ],
                                  "verification": "Escreva um relatório de 1 página explicando o dilema com equações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Artigos de Godunov e van Leer, simulador online de CFD.",
                                  "tips": "Foque em soluções de Riemann simples como teste.",
                                  "learningObjective": "Explicar o trade-off qualitativa e quantitativamente.",
                                  "commonMistakes": "Subestimar necessidade de limitadores em TVD."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Comparar Simulações Numéricas Simples",
                                  "subSteps": [
                                    "Simule propagação de pulso gaussiano com upwind, Lax-Wendroff e MUSCL-TVD.",
                                    "Meça métricas: L1 error para dissipação, max overshoot para dispersão.",
                                    "Varre parâmetros (CFL, grid size) e plote trade-off curves.",
                                    "Otimize limitador para minimizar ambos os erros.",
                                    "Valide contra solução exata ou referência high-res."
                                  ],
                                  "verification": "Produza gráficos de trade-off (dissipação vs. dispersão) com dados tabulados.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Jupyter notebook, bibliotecas NumPy, Matplotlib, código TVD pronto.",
                                  "tips": "Use grids uniformes e CFL=0.5 para reprodutibilidade.",
                                  "learningObjective": "Demonstrar trade-offs via simulações hands-on.",
                                  "commonMistakes": "Não normalizar erros entre simulações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Quantificar Trade-offs",
                                  "subSteps": [
                                    "Defina índices quantitativos: dissipation index = ∫|u_num - u_smooth|, oscillation index = max|u_num - u_monotone|.",
                                    "Compare performance em testes padrão (sod shock tube).",
                                    "Discuta escolhas de esquema baseadas em problema (choque vs. onda suave).",
                                    "Proponha critérios de seleção: threshold de overshoot <5%, borramento <10%.",
                                    "Reflita sobre limitações e avanços (WENO, etc.)."
                                  ],
                                  "verification": "Crie tabela de trade-offs e recomendação para cenários específicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Planilhas Excel ou Pandas para métricas.",
                                  "tips": "Priorize métricas problema-específicas.",
                                  "learningObjective": "Quantificar e decidir trade-offs racionalmente.",
                                  "commonMistakes": "Generalizar resultados de um teste único."
                                }
                              ],
                              "practicalExample": "Simule a equação de Burgers 1D com choque inicial u(x,0)=1 se x<0.5 senão -1. Aplique upwind (borra choque após t=0.5), Lax-Wendroff (oscila pós-choque) e TVD-MUSCL (preserva choque nítido sem oscilações excessivas). Meça largura do choque (dissipação) e overshoot máximo (dispersão).",
                              "finalVerifications": [
                                "Explicar dilema de Godunov-TVD em 3 frases sem consultar notas.",
                                "Plots de simulação mostram diferenças claras entre esquemas.",
                                "Calcular símbolos de dissipação/dispersão para Lax-Wendroff corretamente.",
                                "Tabela de métricas quantitativas para 3 esquemas.",
                                "Recomendar esquema para problema com choque forte.",
                                "Identificar overshoots em simulação dispersiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e dilema corretos (30%).",
                                "Qualidade de simulações: código funcional, plots claros (25%).",
                                "Análise quantitativa: métricas válidas e comparadas (20%).",
                                "Profundidade de trade-offs: discussão balanceada (15%).",
                                "Clareza de comunicação: relatórios e visualizações profissionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de fluidos, ondas acústicas e choques.",
                                "Computação: Programação científica, análise de estabilidade numérica.",
                                "Engenharia: CFD em aerodinâmica e simulações de propulsão.",
                                "Matemática: Análise de Fourier, estabilidade de von Neumann."
                              ],
                              "realWorldApplication": "Em simulações de fluxo supersônico em aviões (NASA CFD codes), TVD schemes balanceiam dissipação para capturar choques nítidos sem oscilações que invalidam aerofólios; ou previsão numérica do tempo, onde dispersão excessiva distorce frentes frias."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Convergência, Consistência e Estabilidade",
                "description": "Análise das propriedades de convergência, consistência e estabilidade nos métodos numéricos.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Consistência em Métodos de Diferenças Finitas",
                    "description": "Definição de consistência e truncagem de erro local em esquemas numéricos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Definição de Consistência",
                        "description": "Conceito fundamental que verifica se o esquema numérico de diferenças finitas aproxima corretamente a equação diferencial à medida que o passo de malha tende a zero.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Enunciar a definição formal de consistência",
                            "description": "Explicar que um esquema numérico é consistente se o operador de diferenças finitas L_h aplicado à solução exata u tende a zero em norma quando h → 0, ou seja, ||L_h u - L u|| → 0, onde L é o operador diferencial exato.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os operadores diferencial exato e de diferenças finitas",
                                  "subSteps": [
                                    "Revise o operador diferencial exato L, que representa a equação diferencial, como L u = f em problemas de valores de contorno.",
                                    "Defina o operador de diferenças finitas L_h como a aproximação discreta de L em uma malha com passo h.",
                                    "Identifique u como a solução exata contínua do problema diferencial.",
                                    "Explique o parâmetro h como o tamanho da malha espacial, que tende a zero para refinar a aproximação.",
                                    "Discuta normas matemáticas, como a norma supremo ou L2, usadas para medir erros: ||v|| = sup |v(x)| ou ∫|v|^2 dx."
                                  ],
                                  "verification": "Escreva definições claras de L, L_h e u para o problema -u'' = π² sin(πx) em [0,1] com u(0)=u(1)=0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre diferenças finitas",
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre associe L_h a uma malha uniforme para simplicidade inicial; visualize a malha com pontos x_i = i h.",
                                  "learningObjective": "Distinguir precisamente entre o operador contínuo L e sua discretização L_h, incluindo o papel de u exata e h.",
                                  "commonMistakes": [
                                    "Confundir L_h u (aplicado à solução exata) com a solução discreta do esquema.",
                                    "Ignorar que normas podem variar (L^∞, L^2), afetando a interpretação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o erro de consistência: L_h u - L u",
                                  "subSteps": [
                                    "Calcule L_h u aplicando o operador de diferenças finitas diretamente à solução exata u.",
                                    "Compute L u, que é conhecido exatamente para soluções testes.",
                                    "Forme a diferença local τ_h(x) = L_h u(x) - L u(x), chamada de termo de truncagem local.",
                                    "Estime a ordem de truncagem, como O(h^p) para p≥1 em esquemas centrados.",
                                    "Verifique numericamente para uma u conhecida, plotando ||τ_h|| vs h em log-log."
                                  ],
                                  "verification": "Para u(x)=sin(πx), compute τ_h no ponto central e confirme que |τ_h| ≈ C h^2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para cálculos numéricos",
                                    "Exemplos de soluções exatas (u=sin(πx))",
                                    "Gráficos de erro de truncagem"
                                  ],
                                  "tips": "Use expansões de Taylor para derivar τ_h analiticamente: u(x+h) = u + h u' + (h^2/2) u'' + O(h^3).",
                                  "learningObjective": "Calcular e interpretar o erro de truncagem local τ_h como ponte para a consistência global.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior na expansão de Taylor.",
                                    "Aplicar L_h à solução aproximada em vez da exata."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a definição formal de consistência",
                                  "subSteps": [
                                    "Enuncie: Um esquema numérico é consistente se lim_{h→0} ||L_h u - L u|| = 0, para toda u suave suficiente.",
                                    "Especifique a norma: geralmente ||.||_∞ ou ||.||_h discreta.",
                                    "Note que consistência requer truncagem local de ordem pelo menos 1: ||τ_h|| = O(h).",
                                    "Discuta independência de condições de contorno para consistência pura.",
                                    "Escreva em notação matemática precisa: ∀ u ∈ C^k, ||L_h u - L u|| → 0 as h → 0."
                                  ],
                                  "verification": "Escreva a definição completa em um papel, incluindo limite, norma e condições em u.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de referência com definições padrão",
                                    "Artigo ou livro sobre Lax Equivalence Theorem"
                                  ],
                                  "tips": "Memorize a frase chave: 'L_h aplicado à exata tende ao operador exato'. Pratique verbalizando.",
                                  "learningObjective": "Enunciar verbatim a definição formal, compreendendo cada símbolo e hipótese.",
                                  "commonMistakes": [
                                    "Omitir 'para soluções u suficientemente regulares'.",
                                    "Confundir com estabilidade (que envolve soluções aproximadas)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e praticar a enunciação da definição",
                                  "subSteps": [
                                    "Teste com exemplo: Para Laplace -Δu=0, L_h central é consistente pois O(h^2).",
                                    "Compare com esquemas inconsistentes, como forward difference para primeira derivada (O(h)).",
                                    "Explique verbalmente para um colega ou grave áudio.",
                                    "Resolva exercício: Prove consistência para u'' via Taylor.",
                                    "Autoavalie escrevendo 3 variações da definição."
                                  ],
                                  "verification": "Grave ou escreva a enunciação e compare com a definição padrão (100% match).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos numéricos em Python (script para L_h u)",
                                    "Gravação de voz ou parceiro de estudo"
                                  ],
                                  "tips": "Use mnemônicos: 'Consistência: Diferenças Finita na Exata → Diferencial Exato'.",
                                  "learningObjective": "Aplicar e validar a definição em contextos específicos, solidificando a memorização.",
                                  "commonMistakes": [
                                    "Usar norma errada ou limite em soluções aproximadas.",
                                    "Confundir ordem de consistência com convergência."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO -u''(x) = f(x) em [0,1] com u(0)=u(1)=0. Solução exata u(x)= (1-cos(πx))/π² para f=π² sin(πx)/2. O esquema central: L_h u_i = (u_{i-1} - 2u_i + u_{i+1})/h². Expansão Taylor mostra L_h u - (-u'') = O(h²), logo ||L_h u + u''||_∞ ≤ C h² → 0 como h→0, provando consistência.",
                              "finalVerifications": [
                                "Enuncie corretamente: '||L_h u - L u|| → 0 como h → 0'.",
                                "Explique todos os símbolos: L_h, u exata, L, norma, limite.",
                                "Identifique truncagem local τ_h e sua relação com consistência.",
                                "Dê exemplo de esquema consistente (central differences).",
                                "Distinga de estabilidade e convergência.",
                                "Prove consistência via Taylor para derivada segunda."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% símbolos corretos).",
                                "Compreensão do limite h→0 e independência de u suave.",
                                "Capacidade de derivar erro de truncagem O(h^p) com p≥1.",
                                "Aplicação correta em exemplos numéricos simples.",
                                "Distinção clara de conceitos relacionados (estabilidade).",
                                "Fluência na enunciação verbal/escrita sem hesitação."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar L_h em Python/NumPy para testar consistência empiricamente.",
                                "Física Computacional: Modelos de difusão/PDE onde consistência garante simulações precisas.",
                                "Engenharia: Análise de erros em CFD (Computational Fluid Dynamics).",
                                "Estatística: Análise de convergência em métodos Monte Carlo discretos.",
                                "Ciências da Computação: Teoria de aproximação em ML numérico."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como previsão de fluxo de fluidos (CFD) ou modelagem climática, a consistência garante que refinando a malha (h→0), o modelo discreto reproduz fielmente as leis físicas contínuas, evitando erros sistemáticos em previsões críticas como aerodinâmica de aviões ou simulações sísmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Identificar esquemas consistentes",
                            "description": "Analisar um esquema dado, como o esquema forward Euler para EDOs, e determinar se ele é consistente com a equação diferencial subjacente, verificando o limite do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição de Consistência em Métodos Numéricos",
                                  "subSteps": [
                                    "Recordar que um esquema numérico para EDOs é consistente se aproxima a solução exata localmente.",
                                    "Entender que a condição formal é lim_{h→0} [τ(t_n, y_n; h)/h] = 0, onde τ é o erro local de truncamento (LTE).",
                                    "Diferenciar consistência de ordem p: lim_{h→0} τ/h = 0 e os termos de ordem h^p.",
                                    "Exemplificar com a EDO y' = f(t,y), y(t_0)=y_0.",
                                    "Anotar a importância para convergência (Teorema de Lax)."
                                  ],
                                  "verification": "Escrever a definição formal e a condição limite corretamente em um papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre EDOs numéricas",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Sempre normalize o erro por h para capturar a taxa de convergência local.",
                                  "learningObjective": "Compreender o conceito teórico de consistência e sua relação com o erro local.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade",
                                    "Esquecer a divisão por h no limite",
                                    "Ignorar o papel da derivada f na aproximação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar e Analisar o Esquema Forward Euler",
                                  "subSteps": [
                                    "Escrever a EDO modelo: y' = f(t,y), com solução exata y(t).",
                                    "Formular o esquema forward Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Identificar t_n = t_0 + n h e como o esquema aproxima y(t_{n+1}).",
                                    "Expressar o operador numérico L_h[y_n] = y_n + h f(t_n, y_n).",
                                    "Comparar qualitativamente com a solução exata via expansão intuitiva."
                                  ],
                                  "verification": "Reescrever o esquema e identificar corretamente os termos de aproximação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de papel quadriculado",
                                    "Software como MATLAB ou Python (opcional para plot)"
                                  ],
                                  "tips": "Visualize o método como uma reta tangente aproximando a curva solução.",
                                  "learningObjective": "Representar o esquema numérico em forma padrão e relacioná-lo à EDO.",
                                  "commonMistakes": [
                                    "Escrever incorretamente o forward Euler (confundir com backward)",
                                    "Não especificar t_n e y_n",
                                    "Ignorar dependência em h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Erro Local de Truncamento (LTE)",
                                  "subSteps": [
                                    "Expandir y(t_{n+1}) via Taylor ao redor de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2) y''(ξ).",
                                    "Substituir y' = f(t,y) e assumir y suave para y'' = f_t + f_y f.",
                                    "Calcular LTE = y(t_{n+1}) - L_h[y(t_n)] = (h^2/2) y''(ξ) + O(h^3).",
                                    "Simplificar para mostrar LTE = O(h^2).",
                                    "Verificar numericamente com h pequeno em um exemplo simples como y' = -y."
                                  ],
                                  "verification": "Derivar a expressão exata de LTE e confirmar O(h^2).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para derivadas",
                                    "Calculadora para Taylor",
                                    "Exemplo numérico em Excel ou Python"
                                  ],
                                  "tips": "Use o teorema do valor médio para ξ em (t_n, t_{n+1}).",
                                  "learningObjective": "Dominar o cálculo de LTE usando expansões de Taylor.",
                                  "commonMistakes": [
                                    "Parar na primeira ordem (O(h))",
                                    "Erro no coeficiente h^2/2",
                                    "Não considerar y'' em termos de f"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Condição de Consistência",
                                  "subSteps": [
                                    "Calcular o erro normalizado: τ(h)/h = (h/2) y''(ξ) + O(h^2).",
                                    "Avaliar o limite lim_{h→0} τ(h)/h = 0.",
                                    "Concluir que forward Euler é consistente de ordem 1.",
                                    "Testar com outro esquema (ex: backward Euler) para contrastar.",
                                    "Generalizar: esquemas com LTE = O(h^{p+1}) são consistentes ordem p."
                                  ],
                                  "verification": "Mostrar analiticamente que o limite é zero e classificar a ordem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas anteriores",
                                    "Gráfico de erro vs h (log-log)"
                                  ],
                                  "tips": "Plote log(|τ|/h) vs log(h) para confirmar inclinação 1.",
                                  "learningObjective": "Aplicar a definição para determinar consistência e ordem.",
                                  "commonMistakes": [
                                    "Limitar τ(h) diretamente (deve ser τ/h)",
                                    "Concluir inconsistente por O(h^2) sem normalizar",
                                    "Confundir ordem de consistência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 (solução y=e^{-t}), forward Euler: y_{n+1} = y_n - h y_n. Taylor: y(h) = 1 - h + (h^2/2) + O(h^3), esquema: 1 - h, LTE = h^2/2 + O(h^3), τ/h → 0. Consistente!",
                              "finalVerifications": [
                                "Definição de consistência enunciada corretamente com limite τ/h → 0.",
                                "LTE do forward Euler derivado como O(h^2).",
                                "Limite do erro normalizado calculado e igual a zero.",
                                "Ordem de consistência identificada como 1.",
                                "Exemplo prático resolvido sem erros aritméticos.",
                                "Generalização para esquemas consistentes explicada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (90% correto).",
                                "Correta normalização e limite (limite explícito = 0).",
                                "Identificação clara de ordem de consistência.",
                                "Uso apropriado de notação matemática (h, t_n, y_n).",
                                "Ausência de erros comuns como confusão com estabilidade.",
                                "Exemplo prático completo e verificável."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em sistemas dinâmicos simulados.",
                                "Computação: Implementação de solvers numéricos em Python (scipy.integrate).",
                                "Engenharia: Modelagem de circuitos RC com EDOs aproximadas.",
                                "Estatística: Avaliação de erros numéricos em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de epidemias (modelo SIR), métodos consistentes como forward Euler garantem que soluções numéricas aproximem fielmente a dinâmica real para h pequeno, essencial em previsões de saúde pública e controle de doenças."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Relacionar consistência com convergência",
                            "description": "Discutir o teorema de Lax, que afirma que para esquemas lineares em espaços de Banach, consistência + estabilidade implicam convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Consistência e Estabilidade",
                                  "subSteps": [
                                    "Ler e anotar a definição formal de consistência para esquemas de diferenças finitas, focando no erro de truncagem local.",
                                    "Estudar a definição de estabilidade em normas de espaços de Banach, incluindo a condição de GKS para esquemas lineares.",
                                    "Comparar consistência (aproximação da equação diferencial) com estabilidade (controle de erros de arredondamento e iniciais).",
                                    "Resolver exercícios simples para calcular o erro de truncagem em um esquema explícito, como o de forward Euler.",
                                    "Discutir limitações: consistência sozinha não garante convergência sem estabilidade."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras comparando as definições e verificar se cobre os conceitos chave sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque 'Finite Difference Methods'), notas de aula sobre diferenças finitas, calculadora.",
                                  "tips": "Use diagramas de stencil para visualizar esquemas e destacar termos de truncagem.",
                                  "learningObjective": "Compreender precisamente os pré-requisitos conceituais para o teorema de Lax.",
                                  "commonMistakes": "Confundir consistência (ordem de precisão) com convergência global; ignorar o papel dos espaços de Banach."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar e Analisar o Teorema de Lax",
                                  "subSteps": [
                                    "Enunciar o teorema: Para operadores lineares em espaços de Banach, consistência + estabilidade implica convergência.",
                                    "Identificar condições necessárias: lineares, problema de Cauchy bem posto, norma adequada.",
                                    "Explicar a direção da implicação e por que a recíproca não vale (contraexemplos).",
                                    "Derivar intuitivamente: estabilidade controla ||e^n||, consistência faz ||τ|| → 0.",
                                    "Pesquisar variações do teorema para problemas não lineares ou semi-discretos."
                                  ],
                                  "verification": "Escrever o enunciado completo do teorema de memória e justificá-lo em 3 frases.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referência principal: Artigo original de Lax ou capítulo em 'Numerical Analysis' de Burden/Faires, quadro branco.",
                                  "tips": "Memorize a frase chave: 'Consistência + Estabilidade = Convergência' como mnemônico.",
                                  "learningObjective": "Dominar o enunciado preciso e as condições do teorema.",
                                  "commonMistakes": "Omitir 'lineares' ou 'Banach'; achar que vale para não lineares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Prova e Intuição do Teorema",
                                  "subSteps": [
                                    "Seguir a prova: Decompor erro total e = ξ + τ, onde ξ é erro de suavização (estabilidade), τ de truncagem.",
                                    "Analisar uso da desigualdade triangular e limite h→0, Δt→0.",
                                    "Construir contraexemplo: Esquema consistente mas instável (ex: Euler backward sem CFL).",
                                    "Discutir prova via densidade de funções suaves e extensão por continuidade.",
                                    "Implementar numericamente um esquema para observar falha sem estabilidade."
                                  ],
                                  "verification": "Resumir a prova em bullet points e simular um contraexemplo em código simples (Python/MATLAB).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico (Python com NumPy/SciPy), prova detalhada de um textbook (ex: Gustafsson et al.).",
                                  "tips": "Desenhe setas para fluxo de erro: inicial → amplificação (estabilidade) → truncagem.",
                                  "learningObjective": "Internalizar o raciocínio lógico da implicação.",
                                  "commonMistakes": "Pular detalhes da norma Banach; confundir estabilidade von Neumann com Lax."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema a Exemplos Práticos",
                                  "subSteps": [
                                    "Analisar esquema Lax-Friedrichs para equação de transporte: verificar consistência O(Δx² + Δt), estabilidade CFL.",
                                    "Prever convergência e testar numericamente com malhas refinadas.",
                                    "Discutir implicações para upwind vs. central differences.",
                                    "Explorar falhas: esquema instável como FTCS para advecção.",
                                    "Relacionar com ordem de convergência observada em simulações."
                                  ],
                                  "verification": "Gerar gráfico de erro vs. h para um exemplo, confirmando taxa de convergência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código MATLAB/Python pronto para diferenças finitas, dados de simulação.",
                                  "tips": "Use log-log plot para visualizar ordem de convergência.",
                                  "learningObjective": "Aplicar o teorema para diagnosticar esquemas numéricos.",
                                  "commonMistakes": "Ignorar condição CFL na estabilidade; superestimar consistência sem cálculo."
                                }
                              ],
                              "practicalExample": "Considere o esquema Lax-Friedrichs para a equação de advecção u_t + a u_x = 0: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (a Δt / (2 Δx)) (u_{j+1}^n - u_{j-1}^n). Verifique consistência (expansão de Taylor mostra O(Δt + Δx²)), estabilidade (|λ| ≤ 1 com CFL ≤1), logo convergência pelo teorema de Lax ao refinar malha.",
                              "finalVerifications": [
                                "Enunciar corretamente o teorema de Lax, incluindo condições.",
                                "Explicar por que estabilidade é essencial com um contraexemplo.",
                                "Calcular erro de truncagem para um esquema simples.",
                                "Interpretar gráfico de convergência numérica.",
                                "Discutir limitações para problemas não lineares.",
                                "Relacionar com outro teorema (ex: Godunov-Leveque)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado e condições do teorema (20%).",
                                "Profundidade na explicação da prova e intuição (25%).",
                                "Qualidade de contraexemplos e aplicações (20%).",
                                "Análise numérica correta com gráficos (20%).",
                                "Conexões claras com consistência global (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Análise de estabilidade em simulações de ondas/PDES.",
                                "Engenharia: Validação de códigos CFD (ex: OpenFOAM).",
                                "Ciência da Computação: Complexidade e análise de algoritmos numéricos.",
                                "Matemática Aplicada: Espaços funcionais e análise funcional."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), o teorema de Lax garante que métodos consistentes e estáveis para equações de Navier-Stokes convirjam para soluções físicas reais ao refinar malhas, essencial para design de aviões, previsão climática e simulações médicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Erro de Truncagem Local",
                        "description": "Medida do erro introduzido pela aproximação discreta da equação diferencial em um único ponto, essencial para determinar a ordem de consistência.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Definir o erro de truncagem local",
                            "description": "Descrever o erro de truncagem local τ_h como τ_h(x,t) = (L_h u)(x,t) - L u(x,t), onde u é a solução exata suave, e explicar que consistência requer τ_h → 0 quando h → 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os operadores diferencial contínuo (L) e de diferenças finitas (L_h)",
                                  "subSteps": [
                                    "Revise a definição do operador diferencial contínuo L para uma EDP, como ∂u/∂t - Δu = f.",
                                    "Estude exemplos de aproximações por diferenças finitas, como a derivada forward: (u_{i+1} - u_i)/h ≈ ∂u/∂x.",
                                    "Compare L u (exato, contínuo) com L_h u (discreto, em malha h).",
                                    "Identifique como L_h aproxima L em pontos da malha.",
                                    "Anote diferenças fundamentais entre contínuo e discreto."
                                  ],
                                  "verification": "Escreva definições de L e L_h para a equação de calor e verifique se distinguem corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires), caderno, lápis"
                                  ],
                                  "tips": "Use diagramas de malha para visualizar L_h atuando em u.",
                                  "learningObjective": "Distinguir operadores contínuo e discreto em métodos de diferenças finitas.",
                                  "commonMistakes": "Confundir L_h com a solução numérica em vez de operador aplicado à exata u."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente o erro de truncagem local τ_h(x,t)",
                                  "subSteps": [
                                    "Defina τ_h(x,t) = (L_h u)(x,t) - L u(x,t), onde u é solução exata suave.",
                                    "Escreva a notação matemática exata: τ_h(x,t) = L_h u(x,t) - L u(x,t).",
                                    "Explique que τ_h mede o erro de aproximação local do operador discreto sobre a solução exata.",
                                    "Discuta suposições: u ∈ C^k com k suficiente para expansões de Taylor.",
                                    "Pratique escrevendo τ_h para uma derivada simples: forward difference."
                                  ],
                                  "verification": "Escreva a fórmula de τ_h para a equação de onda 1D e confira com referência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com fórmulas de diferenças finitas, calculadora simbólica (ex: Wolfram Alpha)"
                                  ],
                                  "tips": "Sempre especifique que u é a solução exata suave, não aproximada.",
                                  "learningObjective": "Formular precisamente a definição matemática de τ_h.",
                                  "commonMistakes": "Escrever τ_h como erro global ou confundir com erro de solução numérica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o comportamento de τ_h no limite h → 0",
                                  "subSteps": [
                                    "Explique que consistência requer ||τ_h|| → 0 quando h → 0, para toda solução suave u.",
                                    "Use expansão de Taylor para mostrar τ_h = O(h^p) para ordem p.",
                                    "Discuta normas adequadas: máximo, L^∞ ou L^2.",
                                    "Verifique para esquemas conhecidos: Lax-Friedrichs (O(h)), Crank-Nicolson (O(h^2)).",
                                    "Prova qualitativa: por que suavidade de u garante o limite."
                                  ],
                                  "verification": "Calcule ordem de τ_h para derivada central e mostre que →0 com h→0.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel milimetrado para Taylor, software como MATLAB para plotar τ_h vs h"
                                  ],
                                  "tips": "Comece com 1D para simplicidade antes de generalizar.",
                                  "learningObjective": "Compreender a condição limite para consistência via τ_h.",
                                  "commonMistakes": "Ignorar suavidade de u ou confundir com estabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar erro de truncagem local com consistência de métodos numéricos",
                                  "subSteps": [
                                    "Recapitule teorema: método consistente se τ_h →0 independentemente de solução exata.",
                                    "Discuta implicações: necessário mas não suficiente para convergência (Lax eq.).",
                                    "Exemplo: esquema inconsistente (ex: upwind errado) onde τ_h não →0.",
                                    "Pratique identificando consistência em novos esquemas.",
                                    "Conclua com importância em análise de EDPs."
                                  ],
                                  "verification": "Classifique dois esquemas como consistentes/inconsistentes justificando com τ_h.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre teorema Lax, exemplos de esquemas"
                                  ],
                                  "tips": "Ligue sempre a convergência: consistência + estabilidade.",
                                  "learningObjective": "Integrar τ_h no contexto de consistência geral.",
                                  "commonMistakes": "Pensar que τ_h →0 garante convergência sem estabilidade."
                                }
                              ],
                              "practicalExample": "Para a EDP ∂u/∂t = ∂²u/∂x² (equação de calor), use diferenças centrais: L_h u_i = (u_{i+1} - 2u_i + u_{i-1})/h² - u_i/Δt. Então τ_h(x,t) = O(h² + Δt), que →0 se h,Δt→0, provando consistência de ordem 2 em espaço.",
                              "finalVerifications": [
                                "Escreve corretamente τ_h(x,t) = (L_h u)(x,t) - L u(x,t).",
                                "Explica que consistência requer τ_h → 0 quando h → 0 para u suave.",
                                "Calcula τ_h via Taylor para derivada forward.",
                                "Identifica ordem de truncagem em esquema dado.",
                                "Distingue truncagem local de erro global.",
                                "Liga a Lax-Richtmyer."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de τ_h (100% correto).",
                                "Compreensão do limite h→0 com justificativa (ex: Taylor).",
                                "Aplicação correta em exemplo simples (ordem exata).",
                                "Distinção clara de conceitos relacionados (consistência vs estabilidade).",
                                "Uso apropriado de notação matemática.",
                                "Explicação verbal clara e concisa."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Análise de esquemas em simulações de difusão.",
                                "Programação: Implementação de L_h em Python/MATLAB para verificar τ_h.",
                                "Estatística: Análise de erros em métodos numéricos probabilísticos.",
                                "Engenharia: Modelagem numérica em CFD (dinâmica de fluidos computacional)."
                              ],
                              "realWorldApplication": "Em simulações numéricas de clima ou finanças, definir e analisar τ_h garante que aproximações discretas capturem corretamente a física subjacente, evitando erros em previsões de longo prazo como em modelos de previsão do tempo ou precificação de opções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Calcular erro de truncagem para esquemas de diferenças finitas",
                            "description": "Derivar o erro de truncagem local para o esquema central de segunda ordem para a derivada segunda: δ²u/δx² = u_{i+1} - 2u_i + u_{i-1}/h², mostrando que é O(h²) assumindo u suave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar as expansões de Taylor para u_{i+1} e u_{i-1}",
                                  "subSteps": [
                                    "Escreva a expansão de Taylor de u(x_i + h) até ordem 4: u_{i+1} = u_i + h u'_i + (h²/2) u''_i + (h³/6) u'''_i + (h⁴/24) u^{(4)}_i + O(h⁵)",
                                    "Escreva a expansão de Taylor de u(x_i - h) até ordem 4: u_{i-1} = u_i - h u'_i + (h²/2) u''_i - (h³/6) u'''_i + (h⁴/24) u^{(4)}_i + O(h⁵)",
                                    "Identifique os termos pares e ímpares nas expansões",
                                    "Verifique que os termos de primeira e terceira ordens são ímpares e se cancelarão",
                                    "Anote os coeficientes exatos para cada termo"
                                  ],
                                  "verification": "Confirme que as expansões estão corretas comparando com a fórmula padrão de Taylor",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e lápis, calculadora para coeficientes, referência de série de Taylor",
                                  "tips": "Expanda até pelo menos ordem 4 para capturar o erro de truncagem de O(h²)",
                                  "learningObjective": "Dominar a aplicação de expansões de Taylor em pontos simétricos",
                                  "commonMistakes": "Esquecer o sinal alternado nos termos ímpares ou parar na ordem errada"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a aproximação de diferenças finitas",
                                  "subSteps": [
                                    "Escreva o esquema central: δ²u/δx² |_i = [u_{i+1} - 2u_i + u_{i-1}] / h²",
                                    "Substitua as expansões de Taylor de u_{i+1} e u_{i-1} na expressão",
                                    "Expanda: u_{i+1} + u_{i-1} = 2u_i + h² u''_i + (h⁴/12) u^{(4)}_i + O(h⁶)",
                                    "Divida por h²: [u_{i+1} - 2u_i + u_{i-1}] / h² = u''_i + (h²/12) u^{(4)}_i + O(h⁴)",
                                    "Simplifique os termos cancelados explicitamente"
                                  ],
                                  "verification": "Verifique que os termos de ordem h⁰ e h² correspondem exatamente a u''_i",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, livro de análise numérica (ex: Burden & Faires)",
                                  "tips": "Agrupe termos por potências de h para visualização clara",
                                  "learningObjective": "Construir a aproximação de diferenças finitas a partir de Taylor",
                                  "commonMistakes": "Erro nos sinais ao somar u_{i+1} + u_{i-1}, como confundir +h e -h"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o erro de truncagem local",
                                  "subSteps": [
                                    "Compare a aproximação com a derivada exata: δ²u/δx² - u''_i = (h²/12) u^{(4)}(ξ) + O(h⁴)",
                                    "Defina o erro de truncagem local τ_i(h) = [δ²u/δx² - u''_i]/h⁰ (pois é para segunda derivada)",
                                    "Mostre que |τ_i(h)| ≤ C h² para u suave (u^{(4)} limitada)",
                                    "Use o teorema do resto de Taylor para precisão: resto em ξ ∈ (x_i - h, x_i + h)",
                                    "Escreva explicitamente τ(h) = O(h²)"
                                  ],
                                  "verification": "Confirme que o erro principal é proporcional a h² u^{(4)}",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora simbólica (ex: Mathematica ou papel)",
                                  "tips": "Lembre que para consistência, erro local → 0 quando h → 0",
                                  "learningObjective": "Extrair e analisar o termo de erro de truncagem",
                                  "commonMistakes": "Confundir ordem do erro (pensar O(h) em vez de O(h²)) ou ignorar o resto"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a ordem de precisão do esquema",
                                  "subSteps": [
                                    "Defina precisão p tal que |erro| ≤ C h^p",
                                    "Aqui p=2, pois termo dominante h²/12",
                                    "Teste com função suave u(x) = sin(x) em x_i=0, h pequeno",
                                    "Calcule numericamente δ²u/δx² e compare com u''(0)=-sin(0)=0",
                                    "Plote log(erro) vs log(h) para confirmar inclinação 2"
                                  ],
                                  "verification": "O erro diminui quadraticamente com h",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como Python/MATLAB para verificação numérica, ou Excel",
                                  "tips": "Use h=0.1, 0.05, 0.025 para observar O(h²)",
                                  "learningObjective": "Demonstrar analítica e numericamente a ordem de truncagem",
                                  "commonMistakes": "Escolha função não suave ou h muito pequeno (erro de arredondamento)"
                                }
                              ],
                              "practicalExample": "Para u(x) = x^4 em x_i=1, h=0.1: u_{i+1}=1.1^4=1.4641, u_i=1, u_{i-1}=0.9^4=0.6561. Aprox: (1.4641 - 2 + 0.6561)/0.01 = 12.02. Exata u''(1)=12. Erro ≈0.02, consistente com (h²/12)*24=0.02.",
                              "finalVerifications": [
                                "Expansões de Taylor corretas até ordem 4",
                                "Cancelamento correto de termos de baixa ordem",
                                "Identificação precisa do termo (h²/12) u^{(4)}(ξ)",
                                "Demonstração de O(h²) com limite h→0",
                                "Verificação numérica com exemplo confirma ordem 2",
                                "Assunção de suavidade u ∈ C^4 explicitada"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (sem erros de sinal/coeficiente)",
                                "Clareza na identificação e isolamento do erro de truncagem",
                                "Correta análise da ordem de precisão (O(h²))",
                                "Uso apropriado do teorema do resto de Taylor",
                                "Inclusão de verificação numérica ou gráfica",
                                "Explicação completa das assunções (u suave)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações de equações diferenciais (ex: onda, calor)",
                                "Computação: Implementação de solvers numéricos em Python (NumPy/SciPy)",
                                "Engenharia: Modelagem em CFD onde precisão O(h²) afeta eficiência",
                                "Estatística: Análise de erros em métodos de aproximação numérica"
                              ],
                              "realWorldApplication": "Em simulações de engenharia como dinâmica de fluidos (CFD), esse esquema é usado em discretizações de Laplace/Poisson; entender O(h²) permite otimizar malhas (refinamento h) para precisão vs custo computacional em software como ANSYS ou OpenFOAM."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Determinar a ordem de consistência via truncagem",
                            "description": "Verificar se um esquema é consistente de ordem p se ||τ_h|| = O(h^p) com p ≥ 1, e aplicar a esquemas para equações parabólicas como a equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Consistência e Erro de Truncagem Local",
                                  "subSteps": [
                                    "Relembre a definição de consistência: um esquema numérico é consistente se o erro de truncagem local τ_h tende a zero quando h → 0.",
                                    "Entenda τ_h como a diferença entre a equação diferencial e a equação discreta dividida por h^k para esquemas de ordem k.",
                                    "Estude a condição de ordem p: ||τ_h|| = O(h^p) com p ≥ 1 para consistência de ordem p.",
                                    "Discuta esquemas para equações parabólicas, focando na equação do calor u_t = α u_xx.",
                                    "Identifique exemplos de esquemas consistentes vs. inconsistentes."
                                  ],
                                  "verification": "Resuma as definições em um parágrafo e dê um exemplo simples de τ_h não tendendo a zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre diferenças finitas.",
                                  "tips": "Use notação consistente: h para espaço, k para tempo; priorize equações parabólicas.",
                                  "learningObjective": "Compreender os fundamentos teóricos de consistência via truncagem.",
                                  "commonMistakes": "Confundir truncagem local (τ_h) com erro global de discretização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Erro de Truncagem Local para um Esquema Genérico",
                                  "subSteps": [
                                    "Escreva um esquema de diferenças finitas genérico para u_t = f(u_xx), ex: (u^{n+1}_j - u^n_j)/k = δ^2 u^n_j / h^2.",
                                    "Substitua a solução exata u(x_j, t_n) na equação discreta para obter τ_h.",
                                    "Expanda operadores de diferenças usando série de Taylor: δ^2 u / h^2 = u_xx + (h^2/12) u_xxxx + O(h^4).",
                                    "Some contribuições de tempo e espaço para formar τ_h completo.",
                                    "Simplifique τ_h para identificar termos dominantes em h."
                                  ],
                                  "verification": "Derive τ_h para um esquema forward-time central-space e verifique se τ_h = O(h^2 + k).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, calculadora simbólica (ex: SymPy ou Mathematica), tabela de expansões de Taylor.",
                                  "tips": "Sempre normalize pela potência de h^k do esquema para isolar O(h^p).",
                                  "learningObjective": "Calcular τ_h analiticamente para esquemas dados.",
                                  "commonMistakes": "Esquecer termos de ordem superior na expansão de Taylor ou normalização incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a Ordem p Analisando a Expansão de τ_h",
                                  "subSteps": [
                                    "Identifique o termo de menor ordem em ||τ_h|| após expansão.",
                                    "Se o termo líder for c h^p com p ≥ 1, conclua ordem p; caso contrário, inconsistente.",
                                    "Compare com esquemas conhecidos: FTCS tem p=2 se k/h^2 fixo.",
                                    "Teste variação: compute lim_{h→0} ||τ_h|| / h^p = c ≠ 0, finito.",
                                    "Documente a ordem para diferentes combinações de diferenças (forward, backward, central)."
                                  ],
                                  "verification": "Para um esquema dado, declare 'Ordem p=2' com evidência da expansão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de álgebra computacional para expansões automáticas.",
                                  "tips": "Assuma solução suave (u C^4) para justificação das expansões.",
                                  "learningObjective": "Extrair ordem de consistência de ||τ_h|| = O(h^p).",
                                  "commonMistakes": "Ignorar dependência em k; assumir p=1 sem verificar termos h^2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Esquemas para Equação do Calor",
                                  "subSteps": [
                                    "Considere equação do calor u_t = u_xx; escreva esquema explícito FTCS.",
                                    "Derive τ_h explícito: τ_h = (k/2) u_t t - (h^2/12) u_xxxx + O(k^2 + h^4 + k h^2).",
                                    "Determine p sob condição CFL (k = O(h^2)); verifique p=2.",
                                    "Compare com esquema implícito: mostre consistência similar.",
                                    "Teste numérico: implemente código simples para plotar ||τ_h|| vs h em log-log."
                                  ],
                                  "verification": "Produza tabela com p para 3 esquemas da equação do calor.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB com NumPy para simulação numérica, código template para FTCS.",
                                  "tips": "Use r = k/h^2 fixo para análise parabólica realista.",
                                  "learningObjective": "Aplicar conceito a problemas parabólicos práticos.",
                                  "commonMistakes": "Não considerar relação k-h, levando a p=1 incorreto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Sintetizar Ordem de Consistência",
                                  "subSteps": [
                                    "Revise derivações para todos esquemas testados.",
                                    "Confirme p ≥ 1 graficamente (log-log plot de ||τ_h|| vs h).",
                                    "Discuta implicações: p alto implica precisão melhor.",
                                    "Resolva exercício: dado esquema, encontre p.",
                                    "Registre conclusões em relatório curto."
                                  ],
                                  "verification": "Gráfico mostra inclinação -p em log-log, com p declarado corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha Excel ou Python para plots log-log.",
                                  "tips": "Slope de log||τ_h|| vs log h dá -p diretamente.",
                                  "learningObjective": "Sintetizar e validar ordem p experimentalmente.",
                                  "commonMistakes": "Escala errada no plot (use log10 para clareza)."
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação do calor u_t = u_xx: (u_j^{n+1} - u_j^n)/k = (u_{j+1}^n - 2u_j^n + u_{j-1}^n)/h^2. Expansão dá τ_h = [ (k/2) u_{tt} - (h^2/12) u_{xxxx} ] + O(h^4 + k^2). Com k=O(h^2), ||τ_h||=O(h^2), logo p=2.",
                              "finalVerifications": [
                                "Derivação de τ_h correta para pelo menos 2 esquemas.",
                                "Identificação precisa de p com evidência O(h^p).",
                                "Gráfico log-log confirma slope ≈ -p.",
                                "Aplicação correta à equação do calor com p≥1.",
                                "Relatório resume ordens para esquemas testados.",
                                "Nenhum erro em expansões de Taylor."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de τ_h (90% correto).",
                                "Correta determinação de p com justificativa analítica.",
                                "Qualidade da análise numérica (plots claros, convergência observada).",
                                "Compreensão conceitual em explicações escritas.",
                                "Aplicação contextual a equações parabólicas.",
                                "Ausência de erros comuns como confusão tempo-espaço."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e parabólicas.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Estatística: Análise de convergência via regressão log-log.",
                                "Engenharia: Simulações CFD para fluxo de calor."
                              ],
                              "realWorldApplication": "Em simulações de engenharia térmica, como previsão de distribuição de calor em painéis solares ou metais fundidos, determinar p garante precisão na malha fina sem custo computacional excessivo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Convergência de Métodos Numéricos",
                    "description": "Teorema de Lax-Richtmyer: convergência como consistência mais estabilidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Consistência de Métodos Numéricos",
                        "description": "Conceito fundamental que mede quão bem a discretização aproxima a equação diferencial original, medido pelo erro de truncamento local que tende a zero com o refinamento da malha.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Definir consistência em métodos de diferenças finitas",
                            "description": "Explicar a definição formal de consistência para esquemas de diferenças finitas aplicados a equações diferenciais parciais (EDPs), incluindo a condição de que o erro de truncamento local τ(h,k) → 0 quando h→0 e k→0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto de métodos de diferenças finitas para EDPs",
                                  "subSteps": [
                                    "Revisar a definição de Equações Diferenciais Parciais (EDPs) e sua representação geral como Lu = f, onde L é um operador diferencial.",
                                    "Estudar a discretização espacial usando diferenças finitas, introduzindo malha com passos h (x) e k (t).",
                                    "Explicar como o esquema numérico aproxima a EDP por uma equação algébrica L_h u_h = f_h.",
                                    "Identificar os erros envolvidos: erro de truncamento e erro de arredondamento.",
                                    "Diferenciar consistência de convergência e estabilidade."
                                  ],
                                  "verification": "Escrever um resumo de 3 frases explicando o papel das diferenças finitas em EDPs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica II",
                                    "Livro 'Análise Numérica de EDPs' (ex: LeVeque)",
                                    "Artigo introdutório sobre malhas numéricas"
                                  ],
                                  "tips": [
                                    "Comece com EDPs elípticas simples como Laplace para visualização.",
                                    "Desenhe uma malha 2D à mão para fixar conceitos.",
                                    "Anote diferenças entre métodos explícitos e implícitos."
                                  ],
                                  "learningObjective": "Entender a base conceitual das aproximações numéricas para EDPs.",
                                  "commonMistakes": [
                                    "Confundir h e k com parâmetros de tempo/espaço invertidos.",
                                    "Ignorar a importância da ordem de precisão do esquema.",
                                    "Misturar consistência com estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o esquema de diferenças finitas e o operador numérico",
                                  "subSteps": [
                                    "Formalizar o operador diferencial contínuo L u = f.",
                                    "Construir o operador discreto L_h u_h = f_h + τ(h,k), onde τ é o erro de truncamento local.",
                                    "Exemplificar com a derivada parcial: (u(x+h,y) - u(x-h,y))/(2h) ≈ ∂u/∂x.",
                                    "Discutir ordens de precisão: O(h²) para diferenças centrais.",
                                    "Verificar consistência de ordem via expansão de Taylor."
                                  ],
                                  "verification": "Construir um esquema simples para ∂u/∂t = ∂²u/∂x² e identificar τ(h,k).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado para desenhar malhas",
                                    "Software simbólico como SymPy ou Mathematica para expansões de Taylor",
                                    "Slides da aula sobre operadores discretos"
                                  ],
                                  "tips": [
                                    "Use expansões de Taylor até ordem 4 para calcular τ precisamente.",
                                    "Compare esquemas forward, backward e central.",
                                    "Registre a notação padrão: índices i,j para malha."
                                  ],
                                  "learningObjective": "Dominar a construção formal do esquema numérico e introdução ao erro de truncamento.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior na expansão de Taylor.",
                                    "Usar notação inconsistente para h e k.",
                                    "Confundir operador L_h com solução exata."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o erro de truncamento local τ(h,k)",
                                  "subSteps": [
                                    "Definir τ(h,k) = L_h φ - L φ, onde φ é uma função suave teste.",
                                    "Derivar τ via expansão de Taylor multivariable para esquemas 2D.",
                                    "Mostrar que para esquemas de ordem p,q: |τ(h,k)| ≤ C (h^p + k^q).",
                                    "Analisar exemplos: esquema FTCS para equação de calor tem τ = O(h² + k).",
                                    "Verificar numericamente τ reduzindo h e k."
                                  ],
                                  "verification": "Calcular τ(h,k) para um esquema dado e plotar vs. h log-log.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para simulação",
                                    "Tabela de expansões de Taylor pré-computadas",
                                    "Exercícios resolvidos da disciplina"
                                  ],
                                  "tips": [
                                    "Escolha funções teste suaves como senos ou polinômios.",
                                    "Use log-log para confirmar ordem de convergência de τ.",
                                    "Teste com h=k para simplificar."
                                  ],
                                  "learningObjective": "Calcular e interpretar o erro de truncamento local em esquemas específicos.",
                                  "commonMistakes": [
                                    "Não considerar derivadas mistas em EDPs 2D.",
                                    "Ignorar constantes C na estimativa assintótica.",
                                    "Confundir τ local com erro global."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer a definição formal de consistência",
                                  "subSteps": [
                                    "Enunciar: Um esquema é consistente se τ(h,k) → 0 quando h→0 e k→0, para toda solução suave u.",
                                    "Provar que esquemas de ordem finita >0 são consistentes.",
                                    "Discutir independência de normas: ||τ|| →0 em qualquer norma.",
                                    "Relacionar com teorema Lax: consistência + estabilidade ⇒ convergência.",
                                    "Testar não-consistência: esquema com coeficientes errados."
                                  ],
                                  "verification": "Escrever a definição completa e provar para um esquema O(h²).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Teorema de Lax-Richtmyer em PDF",
                                    "Caneta e papel para provas",
                                    "Quiz online sobre consistência"
                                  ],
                                  "tips": [
                                    "Memorize: consistência é sobre aproximação local do operador.",
                                    "Ligue a exemplos falhos como upwind errado.",
                                    "Pratique enunciados verbais."
                                  ],
                                  "learningObjective": "Enunciar e justificar a definição de consistência rigorosamente.",
                                  "commonMistakes": [
                                    "Omitir 'para soluções suaves'.",
                                    "Confundir limite com ordem zero.",
                                    "Ignorar multi-dimensionalidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor ∂u/∂t = ∂²u/∂x², o esquema FTCS é u_i^{n+1} = u_i^n + (k/h²)(u_{i+1}^n - 2u_i^n + u_{i-1}^n). Expandindo em Taylor, τ(h,k) = [(k/h² - 1/2) ∂⁴u/∂x⁴ h²/12 + O(k², h⁴, k h²)] → 0 se h,k→0, provando consistência de ordem 2 em h e 1 em k.",
                              "finalVerifications": [
                                "Enunciar corretamente a definição formal de consistência.",
                                "Calcular τ(h,k) para um esquema simples como diferenças centrais.",
                                "Explicar o papel das expansões de Taylor na derivação de τ.",
                                "Diferenciar consistência de estabilidade com exemplo.",
                                "Verificar numericamente τ→0 reduzindo h e k em código.",
                                "Relacionar com teorema de Lax."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (incluindo τ(h,k)→0).",
                                "Correta derivação de τ via Taylor para exemplos.",
                                "Clareza na distinção entre erros local e global.",
                                "Uso apropriado de notação matemática (h,k, L_h).",
                                "Capacidade de identificar esquemas não-consistentes.",
                                "Integração com conceitos de convergência."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de difusão em materiais.",
                                "Ciência da Computação: Implementação de solvers numéricos em Python/Fortran.",
                                "Engenharia: Modelagem de fluxo de calor em CFD.",
                                "Matemática Aplicada: Análise de erros em métodos espectrais."
                              ],
                              "realWorldApplication": "Em simulações numéricas de previsão climática (modelos de EDPs para atmosfera), engenharia aeroespacial (fluxos turbulentos) e finanças (equações de Black-Scholes), onde consistência garante que soluções numéricas aproximem fielmente as físicas ao refinar malhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Calcular o erro de truncamento local",
                            "description": "Derivar e calcular o erro de truncamento local para esquemas explícitos e implícitos em EDPs parabólicas, como o esquema de Euler forward para a equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a EDP parabólica e o esquema de Euler forward",
                                  "subSteps": [
                                    "Escreva a equação do calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Defina a malha numérica: pontos x_j = j Δx, tempos t_n = n Δt.",
                                    "Apresente o esquema explícito de Euler forward: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2 u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Identifique as aproximações: diferença forward para ∂u/∂t e central para ∂²u/∂x².",
                                    "Discuta a ordem de precisão esperada: O(Δt) temporal e O(Δx²) espacial."
                                  ],
                                  "verification": "Confirme que o esquema está corretamente escrito e r definido; teste com valores numéricos simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e lápis, calculadora.",
                                  "tips": "Sempre normalize unidades para α=1 inicialmente para simplificar.",
                                  "learningObjective": "Compreender a discretização básica do problema parabólico.",
                                  "commonMistakes": "Confundir forward com backward; esquecer a definição de r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar expansão de Taylor para o avanço temporal",
                                  "subSteps": [
                                    "Expanda u_j^{n+1} em torno de t_n: u_j^{n+1} = u_j^n + Δt ∂u/∂t + (Δt²/2) ∂²u/∂t² + O(Δt³).",
                                    "Substitua na equação discretizada: u_j^{n+1} - u_j^n ≈ Δt ∂u/∂t |_j^n.",
                                    "Identifique o erro local temporal: (Δt/2) ∂²u/∂t² + O(Δt²).",
                                    "Expresse ∂²u/∂t² usando a EDP original: ∂²u/∂t² = α ∂³u/∂t ∂x².",
                                    "Registre o termo de truncamento temporal como O(Δt)."
                                  ],
                                  "verification": "Verifique se a expansão recupera a derivada de primeira ordem corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software simbólico como SymPy (opcional).",
                                  "tips": "Use notação ∂_t para abreviar derivadas parciais.",
                                  "learningObjective": "Dominar a análise de Taylor para diferenças finitas temporais.",
                                  "commonMistakes": "Parar na primeira ordem sem identificar o termo de erro quadrático."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar expansão de Taylor para a derivada espacial",
                                  "subSteps": [
                                    "Expanda u_{j+1}^n e u_{j-1}^n: u_{j±1}^n = u_j^n ± Δx ∂u/∂x + (Δx²/2) ∂²u/∂x² ± (Δx³/6) ∂³u/∂x³ + (Δx⁴/24) ∂⁴u/∂x⁴ + O(Δx⁵).",
                                    "Calcule a diferença central: (u_{j+1}^n - 2 u_j^n + u_{j-1}^n)/Δx² = ∂²u/∂x² + (Δx²/12) ∂⁴u/∂x⁴ + O(Δx⁴).",
                                    "Identifique o erro local espacial: (Δx²/12) ∂⁴u/∂x⁴ + O(Δx⁴).",
                                    "Multiplique pelo fator r: erro espacial contribuinte r (Δx²/12) ∂⁴u/∂x⁴.",
                                    "Combine com o temporal para obter truncamento total O(Δt + Δx²)."
                                  ],
                                  "verification": "Substitua em uma função teste conhecida (ex: u=sin(x) cos(t)) e compare.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora gráfica ou Python/MATLAB para expansões simbólicas.",
                                  "tips": "Agrupe termos pares/ímpares para simplificar.",
                                  "learningObjective": "Aplicar Taylor multivariável em diferenças finitas espaciais.",
                                  "commonMistakes": "Esquecer o fator 1/Δx² na diferença segunda; confundir ordens de Δx."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender ao esquema implícito e calcular numericamente",
                                  "subSteps": [
                                    "Apresente o esquema implícito de Euler backward: u_j^{n+1} - r (u_{j+1}^{n+1} - 2 u_j^{n+1} + u_{j-1}^{n+1}) = u_j^n.",
                                    "Aplique expansões de Taylor em torno de t_{n+1} para mostrar simetria e mesmo ordem O(Δt + Δx²).",
                                    "Escolha uma solução exata: u(x,t) = exp(-π² α t) sin(π x), com condições de contorno.",
                                    "Calcule numericamente o erro local para Δt=0.01, Δx=0.1 em um ponto interno.",
                                    "Compare explícito vs implícito e discuta diferenças na prática."
                                  ],
                                  "verification": "O erro calculado deve coincidir com a ordem teórica (teste de convergência).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com NumPy/SciPy, ou planilha Excel para cálculos manuais.",
                                  "tips": "Use malha uniforme e solução analítica suave para evitar erros de contorno.",
                                  "learningObjective": "Comparar truncamento em esquemas explícito e implícito.",
                                  "commonMistakes": "Aplicar Taylor no ponto errado para implícito; ignorar suavidade da solução."
                                }
                              ],
                              "practicalExample": "Para a equação do calor com u(x,0)=sin(πx), α=1, em [0,1]: usando Δt=0.001, Δx=0.05, calcule erro local em (x=0.5,t=0.001) como | [u(0.5,0.001) - u(0.5,0)] / Δt - ∂u/∂t | ≈ 10^{-5}, confirmando O(Δt).",
                              "finalVerifications": [
                                "Derivação do erro temporal O(Δt) via Taylor forward.",
                                "Erro espacial O(Δx²) com coeficiente 1/12 para segunda derivada central.",
                                "Truncamento total O(Δt + Δx²) para ambos esquemas.",
                                "Cálculo numérico coincide com teoria em exemplo simples.",
                                "Extensão correta ao implícito sem mudança de ordem.",
                                "Identificação de termos líderes de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (pontos parciais por termo correto).",
                                "Identificação correta de ordens de truncamento (essencial).",
                                "Cálculo numérico exato com solução analítica (até 5% erro tolerado).",
                                "Explicação clara de diferenças explícito/implícito.",
                                "Uso apropriado de notação e simplificações matemáticas.",
                                "Ausência de erros algébricos comuns (ex: sinais em Taylor)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e condução de calor.",
                                "Programação: Implementação em Python/MATLAB para validação numérica.",
                                "Engenharia: Simulações em CFD (Computational Fluid Dynamics).",
                                "Estatística: Análise de erros em métodos Monte Carlo para EDPs."
                              ],
                              "realWorldApplication": "Em simulações de propagação de calor em engenharia (ex: design de processadores ou isolamento térmico), onde o erro de truncamento local determina a precisão de previsões de temperatura, evitando superaquecimento em eletrônicos ou falhas estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Determinar a ordem de consistência",
                            "description": "Identificar e calcular a ordem de consistência de um esquema numérico, verificando expansões de Taylor para termos espaciais e temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Consistência",
                                  "subSteps": [
                                    "Ler a definição formal de consistência: um esquema numérico é consistente se o erro de truncamento local (LTE) tende a zero quando Δt → 0 e Δx → 0.",
                                    "Estudar a ordem de consistência: identificar p e q tais que LTE = O(Δt^p + Δx^q).",
                                    "Revisar a relação entre consistência, convergência e estabilidade (Teorema de Lax).",
                                    "Analisar exemplos simples de esquemas consistentes e inconsistentes.",
                                    "Anotar as diferenças entre termos temporais e espaciais na expansão."
                                  ],
                                  "verification": "Escrever uma definição em palavras próprias e citar um exemplo de esquema inconsistente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica II",
                                    "Livro-texto de métodos numéricos (cap. Convergência)"
                                  ],
                                  "tips": "Use diagramas para visualizar a evolução temporal e espacial.",
                                  "learningObjective": "Definir consistência e identificar sua ordem em termos de LTE.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade",
                                    "Ignorar a dependência em Δt e Δx separadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Expansões de Taylor em Esquemas Numéricos",
                                  "subSteps": [
                                    "Recordar a expansão de Taylor multivariável para funções u(t,x).",
                                    "Aplicar Taylor ao lado contínuo da EDO/PDE: u(t+Δt, x) = u + Δt u_t + (Δt)^2/2 u_tt + ...",
                                    "Expandir operadores espaciais diferenciais finitos, ex: (u_{j+1} - u_{j-1})/(2Δx) = u_x + O(Δx^2).",
                                    "Combinar expansões temporais e espaciais para formar o LTE.",
                                    "Praticar com operadores forward, backward e central."
                                  ],
                                  "verification": "Derivar a expansão de Taylor para um operador de primeira derivada central.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou papel)",
                                    "Tabela de expansões de Taylor comuns"
                                  ],
                                  "tips": "Mantenha os termos até ordem 3 ou 4 para visualizar o erro.",
                                  "learningObjective": "Executar expansões de Taylor precisas para termos temporais e espaciais.",
                                  "commonMistakes": [
                                    "Esquecer termos mistos como ∂²u/∂t∂x",
                                    "Erros nos coeficientes binomiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Expansão Completa do Esquema Numérico",
                                  "subSteps": [
                                    "Selecionar um esquema numérico específico (ex: Lax-Friedrichs para u_t + u_x = 0).",
                                    "Expandir o lado discreto do esquema usando Taylor em todos os pontos da malha.",
                                    "Substituir a PDE no lado contínuo para comparar.",
                                    "Coletar termos de mesma ordem em Δt e Δx.",
                                    "Isolar os termos de menor ordem no LTE."
                                  ],
                                  "verification": "Escrever a expansão LTE para o esquema escolhido, mostrando cancelamentos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado para malha",
                                    "Software como MATLAB para verificação numérica opcional"
                                  ],
                                  "tips": "Trabalhe simbolicamente primeiro, depois numéricamente para validar.",
                                  "learningObjective": "Construir a expansão LTE completa de um esquema.",
                                  "commonMistakes": [
                                    "Não expandir todos os shifts na malha",
                                    "Confundir índices j e n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar e Verificar a Ordem de Consistência",
                                  "subSteps": [
                                    "Identificar o menor expoente no LTE: min(p para Δt^p, q para Δx^q).",
                                    "Verificar se p ≥ 1 e q ≥ 1 para consistência básica.",
                                    "Analisar casos anisotrópicos (Δt ~ Δx^r) e ordens efetivas.",
                                    "Comparar com esquemas conhecidos (ex: Euler ordem 1).",
                                    "Testar numericamente reduzindo Δt e Δx para confirmar."
                                  ],
                                  "verification": "Calcular a ordem para dois esquemas diferentes e justificar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos resolvidos de esquemas clássicos",
                                    "Planilha para testes numéricos"
                                  ],
                                  "tips": "Sempre normalize pelo r = Δt/Δx quando aplicável.",
                                  "learningObjective": "Determinar precisamente a ordem de consistência de qualquer esquema.",
                                  "commonMistakes": [
                                    "Ignorar ordens pares/impares em dissipação",
                                    "Não considerar CFL"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema upwind u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n) com u_t + u_x = 0 (λ = Δt/Δx), expanda: lado contínuo u(t+Δt,x) = u + Δt u_t + (Δt)^2/2 u_tt + O(Δt^3); lado discreto revela LTE = O(Δt + Δx), ordem 1 em tempo e espaço.",
                              "finalVerifications": [
                                "Derivar corretamente LTE para esquema de Euler forward.",
                                "Identificar ordem de consistência em esquema Leapfrog (ordem 2).",
                                "Explicar por que um esquema com LTE O(Δt^0) é inconsistente.",
                                "Comparar ordens temporais e espaciais em PDE 2D.",
                                "Validar numericamente reduzindo h em fator 2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de expansões de Taylor (sem erros algébricos).",
                                "Correta identificação dos termos LTE dominantes.",
                                "Justificativa clara da ordem mínima p,q.",
                                "Uso adequado de notação O(·) e análise assintótica.",
                                "Capacidade de generalizar para esquemas não lineares.",
                                "Apresentação organizada com passos lógicos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas e difusão em simulações CFD.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Análise de precisão em métodos finitos para estruturas.",
                                "Estatística: Erros de truncamento vs. erros de arredondamento."
                              ],
                              "realWorldApplication": "Em simulações climáticas, determinar ordem de consistência garante precisão em previsões de longo prazo para modelos de fluidos, evitando erros acumulados em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Estabilidade de Métodos Numéricos",
                        "description": "Propriedade que garante que pequenos erros de arredondamento ou perturbações iniciais não cresçam descontroladamente durante as iterações.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Definir estabilidade no contexto de Lax-Richtmyer",
                            "description": "Explicar a definição de estabilidade para métodos lineares de diferenças finitas, incluindo a noção de estabilidade no sentido de Lax.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Métodos Lineares de Diferenças Finitas",
                                  "subSteps": [
                                    "Estude a forma geral de um método linear de diferenças finitas para problemas iniciais-valor: u^{n+1} = A u^n, onde A é o operador de amplificação.",
                                    "Identifique componentes chave: malha espacial Δx, passo de tempo Δt, e dados iniciais u^0.",
                                    "Revise normas adequadas, como norma L2 ou máximo, para medir o tamanho das soluções.",
                                    "Analise como soluções exatas permanecem limitadas para dados iniciais limitados.",
                                    "Compare estabilidade com instabilidade através de exemplos simples de recursões lineares."
                                  ],
                                  "verification": "Resuma em suas palavras a representação matricial de um esquema linear e liste 2 normas comuns usadas em análise numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: LeVeque), notas de aula sobre diferenças finitas, calculadora simbólica como SymPy.",
                                  "tips": "Comece com esquemas 1D simples para evitar sobrecarga; visualize operadores como matrizes pequenas.",
                                  "learningObjective": "Compreender a estrutura algébrica de métodos lineares como pré-requisito para estabilidade.",
                                  "commonMistakes": "Confundir operador de amplificação com a solução exata; ignorar dependência em Δt e Δx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Noção Intuitiva de Estabilidade em Problemas de Evolução",
                                  "subSteps": [
                                    "Defina estabilidade intuitivamente: soluções numéricas não explodem para dados iniciais suaves, independentemente de n.",
                                    "Estude o conceito de 'well-posedness' de Hadamard para PDEs subjacentes.",
                                    "Analise crescimento exponencial em esquemas instáveis, como forward Euler para equação de calor.",
                                    "Discuta papel do CFL condition como heurística para estabilidade.",
                                    "Diferencie estabilidade de consistência e convergência."
                                  ],
                                  "verification": "Explique por que um esquema instável falha mesmo sendo consistente, com um contra-exemplo curto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigos introdutórios sobre estabilidade numérica, software como MATLAB para simular esquemas simples.",
                                  "tips": "Use animações de ondas numéricas para visualizar crescimento de erros.",
                                  "learningObjective": "Desenvolver intuição sobre por que estabilidade é crucial para simulações de longo prazo.",
                                  "commonMistakes": "Equiparar estabilidade apenas a CFL; esquecer que é para n→∞ com Δt,Δx fixos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente Estabilidade no Sentido de Lax",
                                  "subSteps": [
                                    "Enuncie a definição: Método é estável se ∃ K, T0 >0 tal que ||u^n|| ≤ K ||u^0|| para 0 < t_n ≤ T0, todos u^0 suaves.",
                                    "Especifique para esquemas lineares: ρ(A) ≤ 1 + O(Δt), onde ρ é raio espectral do operador A.",
                                    "Derive condição equivalente via norma do operador: ||A^n|| ≤ K.",
                                    "Discuta independência de malhas finas: vale uniformemente em Δt,Δx →0.",
                                    "Compare com estabilidade von Neumann (análise de Fourier plano)."
                                  ],
                                  "verification": "Escreva a definição matemática exata e prove para um operador A diagonalizável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Referência principal: Richtmyer & Morton 'Difference Methods'; quadro branco para derivações.",
                                  "tips": "Memorize a desigualdade ||A^n|| ≤ K; pratique com matrizes 2x2.",
                                  "learningObjective": "Dominar a definição precisa de Lax e suas implicações algébricas.",
                                  "commonMistakes": "Omitir 'suaves' em u^0; confundir com estabilidade GKS (não-linear)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender o Teorema Lax-Richtmyer e Verificações",
                                  "subSteps": [
                                    "Enuncie o teorema: Consistência + Estabilidade (Lax) ⇒ Convergência para problemas lineares bem-poseídos.",
                                    "Discuta prova esboçada: use triangulação ||u^n - u(t_n)|| ≤ ||erro de truncamento|| + ||erro de estabilidade||.",
                                    "Analise limitações: linearidade, periodicidade ou condições de contorno adequadas.",
                                    "Verifique estabilidade em um exemplo: esquema Lax-Wendroff para advecção.",
                                    "Explore extensões para semi-discretizações (método das linhas)."
                                  ],
                                  "verification": "Aplique o teorema a um esquema específico, justificando consistência e estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB para testar raio espectral, exemplos de LeVeque.",
                                  "tips": "Implemente numericamente ||A^n|| para validar teoria.",
                                  "learningObjective": "Conectar estabilidade de Lax à convergência geral via teorema.",
                                  "commonMistakes": "Acreditar que vale para não-lineares; ignorar condições de contorno."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + a u_x = 0, considere o esquema Lax-Friedrichs: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (a Δt / (2 Δx)) (u_{j+1}^n - u_{j-1}^n). Calcule o símbolo de amplificação g(θ) = cos(θ) - i (a Δt/Δx) sin(θ), verifique |g(θ)| ≤ 1 sob CFL |a Δt/Δx| ≤ 1, provando estabilidade Lax.",
                              "finalVerifications": [
                                "Enuncie corretamente a definição de estabilidade Lax sem omissões.",
                                "Prove estabilidade para um esquema linear simples via raio espectral.",
                                "Explique o teorema Lax-Richtmyer em 3 frases.",
                                "Identifique quando um esquema falha estabilidade (ex: exemplo numérico).",
                                "Diferencie estabilidade Lax de von Neumann.",
                                "Aplique a definição a um problema com condições de contorno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (incluindo K, T0, normas).",
                                "Compreensão algébrica: uso correto de operadores e normas.",
                                "Aplicação ao teorema: ligação clara com consistência/convergência.",
                                "Exemplos concretos com cálculos (símbolo ou matriz).",
                                "Identificação de limitações e exceções.",
                                "Clareza na distinção de conceitos relacionados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de ondas/PDES (ex: mecânica quântica).",
                                "Computação: Análise de algoritmos numéricos e complexidade espectral.",
                                "Engenharia: Validação de CFD (dinâmica de fluidos computacional).",
                                "Estatística: Controle de erros em métodos Monte Carlo discretos."
                              ],
                              "realWorldApplication": "Em previsão numérica do tempo (modelos ECMWF), estabilidade Lax-Richtmyer garante que simulações de longo prazo para equações primitivas não explodam devido a erros de arredondamento, permitindo previsões confiáveis de furacões e clima."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Analisar estabilidade via critério de Von Neumann",
                            "description": "Aplicar a análise de Von Neumann para verificar estabilidade de esquemas em EDPs hiperbólicas e parabólicas, calculando o símbolo de amplificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Critério de Von Neumann",
                                  "subSteps": [
                                    "Revise as suposições do método: linearidade local, solução periódica e decomposta em Fourier.",
                                    "Estude a definição do símbolo de amplificação g(θ) como a razão entre amplitudes em passos temporais sucessivos.",
                                    "Identifique as condições de estabilidade: |g(θ)| ≤ 1 + O(Δt) para todos os θ no intervalo [0, π].",
                                    "Diferencie entre EDPs hiperbólicas (ex: advecção) e parabólicas (ex: difusão).",
                                    "Anote as limitações: ignora não-linearidades e condições de contorno."
                                  ],
                                  "verification": "Explique em suas palavras o critério e dê um exemplo simples de instabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), notas de aula, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Use diagramas de Fourier para visualizar modos de onda.",
                                  "learningObjective": "Dominar a teoria base para análise de estabilidade.",
                                  "commonMistakes": "Confundir com análise de von Mises ou esquecar a normalização pelo fator de tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Linearizar o Esquema Numérico e Assumir Solução de Fourier",
                                  "subSteps": [
                                    "Selecione um esquema numérico para uma EDP hiperbólica ou parabólica (ex: FTCS para advecção u_t + a u_x = 0).",
                                    "Linearize o esquema em torno de uma solução constante, obtendo a relação de recorrência.",
                                    "Assuma solução u_j^n = g^n e^{i k j Δx}, onde θ = k Δx.",
                                    "Substitua na relação de recorrência para isolar g(θ).",
                                    "Verifique se o esquema é consistente com a EDP original."
                                  ],
                                  "verification": "Escreva a forma linearizada e a suposição de Fourier corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software MATLAB ou Python (NumPy para testes simbólicos).",
                                  "tips": "Comece com esquemas simples de 1D para praticar.",
                                  "learningObjective": "Preparar o esquema para cálculo do símbolo de amplificação.",
                                  "commonMistakes": "Esquecer o fator i na exponencial ou não normalizar θ adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Plotar o Símbolo de Amplificação",
                                  "subSteps": [
                                    "Derive explicitamente g(θ) para o esquema escolhido (ex: g(θ) = 1 - i a Δt/Δx sin(θ) para Lax-Friedrichs).",
                                    "Calcule |g(θ)|^2 e simplifique usando identidades trigonométricas.",
                                    "Plote |g(θ)| vs θ para θ de 0 a π, identificando o máximo.",
                                    "Compare para diferentes números de Courant (C = a Δt/Δx).",
                                    "Repita para uma EDP parabólica (ex: u_t = ν u_xx com esquema explícito)."
                                  ],
                                  "verification": "Obtenha |g(θ)| ≤ 1 para valores de C estáveis e plote corretamente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB para plotagem (Matplotlib), lápis e papel para derivação.",
                                  "tips": "Use sympy para derivações simbólicas se disponível.",
                                  "learningObjective": "Computar e visualizar o símbolo para análise qualitativa.",
                                  "commonMistakes": "Erro em sin(θ/2) vs sin(θ), ou plotar até 2π em vez de π."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estabilidade e Concluir",
                                  "subSteps": [
                                    "Determine o domínio de estabilidade: valores de C onde max |g(θ)| ≤ 1.",
                                    "Identifique modos instáveis (ex: θ=π para esquemas com difusão numérica insuficiente).",
                                    "Compare com critério de CFL para hiperbólicas ou r = ν Δt/Δx² ≤ 1/2 para parabólicas.",
                                    "Discuta implicações para escolha de Δt e Δx.",
                                    "Teste numericamente com uma simulação curta para validar."
                                  ],
                                  "verification": "Escreva o critério de estabilidade final e justifique com o plot.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código de simulação simples em Python, gráficos gerados.",
                                  "tips": "Sempre verifique numericamente para confirmar teoria.",
                                  "learningObjective": "Interpretar resultados e aplicar em contextos reais.",
                                  "commonMistakes": "Ignorar o termo O(Δt) ou generalizar inadequadamente para não-lineares."
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação de advecção u_t + u_x = 0: g(θ) = 1 - C (1 - e^{-iθ}). Calcule |g(θ)|, encontre max ≈ 1 + (C/2)^2 para C>0, instável para qualquer C>0. Contrastar com Lax-Friedrichs, estável para |C|≤1.",
                              "finalVerifications": [
                                "Símbolo g(θ) derivado corretamente para pelo menos dois esquemas.",
                                "Plots de |g(θ)| mostram domínio de estabilidade claramente.",
                                "Condições CFL ou de difusão identificadas com justificativa.",
                                "Exemplo numérico confirma análise teórica.",
                                "Limitações do método discutidas.",
                                "Comparação entre hiperbólica e parabólica feita."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g(θ) (40%).",
                                "Qualidade e interpretação dos plots (20%).",
                                "Correta identificação de condições de estabilidade (20%).",
                                "Validação numérica e discussão de limitações (10%).",
                                "Clareza na explicação e estrutura do relatório (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas e difusão em mecânica de fluidos.",
                                "Computação: Implementação de solvers numéricos em CFD (ex: OpenFOAM).",
                                "Engenharia: Otimização de malhas em simulações aeroespaciais.",
                                "Estatística: Análise de erros em métodos Monte Carlo para EDPs."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos de atmosfera com EDPs hiperbólicas para advecção de umidade) ou previsão de propagação de frentes de fogo (parabólicas para difusão térmica), garante que simulações não explodam numericamente, permitindo previsões confiáveis em supercomputadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Identificar dissipação e dispersão",
                            "description": "Diferenciar dissipação (amortecimento de modos de alta frequência) e dispersão (fases erradas em ondas), relacionando com estabilidade em métodos para EDPs hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Dissipação e Dispersão",
                                  "subSteps": [
                                    "Ler e anotar a definição de dissipação: amortecimento seletivo de modos de alta frequência em soluções numéricas.",
                                    "Ler e anotar a definição de dispersão: introdução de erros de fase que causam ondas a propagarem com velocidades erradas.",
                                    "Visualizar exemplos físicos: dissipação como atrito em osciladores, dispersão como distorção em pulsos de onda.",
                                    "Comparar os efeitos em soluções numéricas: dissipação suaviza oscilações, dispersão oscila a fase.",
                                    "Escrever um resumo em 3 frases diferenciando os dois."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito a diferença entre dissipação e dispersão com exemplos físicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre estabilidade numérica",
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Vídeo introdutório sobre análise de von Neumann"
                                  ],
                                  "tips": "Use analogias cotidianas: dissipação como freio em carro (amortece vibrações altas), dispersão como eco em som (fases desalinhadas).",
                                  "learningObjective": "Definir dissipação e dispersão em termos de comportamento de modos de Fourier.",
                                  "commonMistakes": [
                                    "Confundir dissipação com difusão física",
                                    "Ignorar a seletividade por frequência na dissipação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as Definições Matemáticas via Análise de von Neumann",
                                  "subSteps": [
                                    "Revisar análise de von Neumann: fator de amplificação g(θ) = |g| e^{i φ(θ)} para modo θ.",
                                    "Identificar dissipação: |g(θ)| < 1 para θ altos (alta frequência), preservando θ=0.",
                                    "Identificar dispersão: φ(θ)/θ ≠ c (velocidade de fase errada), especialmente para θ médios.",
                                    "Plotar |g(θ)| e φ(θ)/θ para esquemas exemplo (ex: FTCS, Lax-Wendroff).",
                                    "Calcular numericamente para um esquema simples."
                                  ],
                                  "verification": "Produzir gráficos de |g(θ)| e φ(θ) mostrando regiões de dissipação e dispersão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/Matplotlib)",
                                    "Fórmulas de esquemas numéricos para EDPs hiperbólicas"
                                  ],
                                  "tips": "Comece com a equação de advecção u_t + a u_x = 0 para simplicidade.",
                                  "learningObjective": "Interpretar o fator de amplificação para distinguir dissipação (|g|<1) e dispersão (fase errada).",
                                  "commonMistakes": [
                                    "Esquecer normalização φ(θ)/θ",
                                    "Confundir amplitude com fase"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Dissipação e Dispersão com Estabilidade em EDPs Hiperbólicas",
                                  "subSteps": [
                                    "Explicar como dissipação numérica ajuda estabilidade ao amortecer modos instáveis.",
                                    "Discutir como dispersação excessiva leva a oscilações não-físicas, mas pode ser estável.",
                                    "Analisar condição CFL e seu impacto em dissipação/dispersão.",
                                    "Comparar esquemas: Lax-Friedrichs (dissipativo), Lax-Wendroff (dispersivo).",
                                    "Derivar condição de estabilidade considerando ambos os erros."
                                  ],
                                  "verification": "Classificar 3 esquemas numéricos quanto a dissipação/dispersão e estabilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de esquemas para onda/advecção",
                                    "Artigo ou capítulo sobre estabilidade (ex: Gustafsson et al.)"
                                  ],
                                  "tips": "Lembre: estabilidade requer |g|≤1; dissipação é bônus para suavização.",
                                  "learningObjective": "Conectar dissipação/dispersão à estabilidade von Neumann para métodos hiperbólicos.",
                                  "commonMistakes": [
                                    "Achar que dispersão sempre causa instabilidade",
                                    "Ignorar papel da malha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplos Práticos e Simulações",
                                  "subSteps": [
                                    "Implementar esquema numérico (ex: Lax-Wendroff) para equação de advecção.",
                                    "Simular com pulso inicial e observar dissipação (suavização) vs dispersação (oscilações traseiras).",
                                    "Variar parâmetro CFL e registrar efeitos em dissipação/dispersação.",
                                    "Comparar solução numérica com exata, medindo erros de fase e amplitude.",
                                    "Documentar conclusões em relatório curto."
                                  ],
                                  "verification": "Gerar simulação mostrando dissipação (atenuação alta freq.) e dispersação (frente ondulada).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python/MATLAB pronto para esquemas",
                                    "Computador com ambiente de programação"
                                  ],
                                  "tips": "Use malha fina para alta resolução; grave vídeo da evolução temporal.",
                                  "learningObjective": "Identificar dissipação e dispersão em simulações reais de EDPs hiperbólicas.",
                                  "commonMistakes": [
                                    "Malha grosseira mascara efeitos",
                                    "Não comparar com solução exata"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao simular a equação de advecção u_t + u_x = 0 com esquema Lax-Wendroff (CFL=0.9), observe dissipação mínima (suavização leve) mas dispersação clara: o pulso inicial desenvolve oscilações atrás da frente de onda devido a erros de fase em modos médios de frequência.",
                              "finalVerifications": [
                                "Definir corretamente dissipação como |g(θ)| < 1 para θ altos.",
                                "Explicar dispersação como desvio de φ(θ)/θ da velocidade física.",
                                "Classificar Lax-Friedrichs como dissipativo e Lax-Wendroff como dispersivo.",
                                "Relacionar ambos à estabilidade von Neumann.",
                                "Analisar gráfico de amplificação de um esquema.",
                                "Identificar em simulação numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições matemáticas (80% corretas).",
                                "Correta distinção via análise de von Neumann.",
                                "Exemplos relevantes de esquemas hiperbólicos.",
                                "Conexão clara com estabilidade.",
                                "Qualidade de simulação e interpretação.",
                                "Ausência de confusões comuns (ex: difusão vs dissipação)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e amortecimento em mecânica ondulatória.",
                                "Engenharia: Simulações em dinâmica de fluidos computacional (CFD).",
                                "Ciência da Computação: Otimização de algoritmos numéricos paralelos.",
                                "Engenharia Civil: Modelagem de ondas sísmicas e estabilidade estrutural."
                              ],
                              "realWorldApplication": "Em previsão numérica do tempo (modelos como WRF), identificar dissipação excessiva que suaviza frentes de tempestade ou dispersação que distorce trajetórias de ondas gravitacionais, ajustando esquemas para equilibrar precisão e estabilidade computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Teorema de Lax-Richtmyer",
                        "description": "Teorema central que estabelece a equivalência entre convergência de métodos numéricos lineares bem-posicionados e a combinação de consistência e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Enunciar o Teorema de Lax-Richtmyer",
                            "description": "Declarar precisamente o teorema: um método numérico linear bem-posicionado para EDPs hiperbólicas converge se e somente se for consistente e estável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Contextualizar EDPs Hiperbólicas e Problemas Bem-Posicionados",
                                  "subSteps": [
                                    "Revise a definição de Equações Diferenciais Parciais (EDPs) hiperbólicas, como a equação da onda ou de transporte.",
                                    "Entenda o conceito de problema bem-posicionado (well-posed) segundo Hadamard: existência, unicidade e estabilidade contínua da solução.",
                                    "Identifique por que métodos numéricos lineares são relevantes para aproximações em EDPs hiperbólicas.",
                                    "Estude exemplos simples de discretizações lineares, como diferenças finitas.",
                                    "Discuta limitações de métodos sem linearidade ou bem-posedness."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o contexto e dê um exemplo de EDP hiperbólica bem-posicionada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Numerical Methods for Conservation Laws' de R. J. LeVeque (cap. 1-2)",
                                    "Notas de aula de Análise Numérica II",
                                    "Vídeo Khan Academy sobre EDPs hiperbólicas"
                                  ],
                                  "tips": "Comece com exemplos físicos intuitivos, como propagação de ondas, para fixar o conceito.",
                                  "learningObjective": "Compreender o escopo do teorema: métodos lineares para problemas bem-posicionados em EDPs hiperbólicas.",
                                  "commonMistakes": [
                                    "Confundir hiperbólicas com elípticas/parabólicas",
                                    "Ignorar a linearidade do método numérico",
                                    "Esquecer a condição de bem-posedness do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Definição de Consistência",
                                  "subSteps": [
                                    "Defina consistência: o esquema numérico converge localmente para a solução exata quando o passo de malha tende a zero.",
                                    "Estude a truncagem local (local truncation error) e norma adequada.",
                                    "Aprenda a ordem de consistência (ex: ordem 1 ou 2).",
                                    "Calcule o erro de truncagem para um esquema simples, como Lax-Friedrichs.",
                                    "Verifique consistência usando expansão de Taylor."
                                  ],
                                  "verification": "Compute o erro de truncagem para o esquema upwind em uma EDP de transporte e confirme consistência de ordem 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de exercícios de Análise Numérica",
                                    "Software MATLAB ou Python (NumPy/SciPy) para simulações simples",
                                    "Referência: Tannehill et al., 'Computational Fluid Mechanics'"
                                  ],
                                  "tips": "Use expansão de Taylor passo a passo; anote coeficientes para esquemas comuns.",
                                  "learningObjective": "Saber precisamente o que significa um método ser consistente.",
                                  "commonMistakes": [
                                    "Confundir consistência com convergência",
                                    "Usar norma errada (ex: L1 vs L2)",
                                    "Esquecer limite h->0 e k->0 com k/h fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a Definição de Estabilidade",
                                  "subSteps": [
                                    "Defina estabilidade: solução numérica permanece limitada independentemente do número de passos.",
                                    "Estude o critério CFL (Courant-Friedrichs-Lewy) para estabilidade.",
                                    "Aprenda análise de von Neumann: amplificação de modos de Fourier.",
                                    "Aplique a esquemas lineares: fator de amplificação |g| <=1.",
                                    "Diferencie estabilidade de consistência e bem-posedness."
                                  ],
                                  "verification": "Analise estabilidade von Neumann para o esquema Lax-Wendroff e encontre condição CFL.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python para análise de Fourier",
                                    "Livro LeVeque cap. 4",
                                    "Apresentação slides sobre estabilidade"
                                  ],
                                  "tips": "Plote o fator de amplificação vs frequência para visualizar dissipação/dispersão.",
                                  "learningObjective": "Compreender estabilidade como controle de crescimento de erros.",
                                  "commonMistakes": [
                                    "Confundir estabilidade numérica com bem-posedness",
                                    "Ignorar modos de alta frequência",
                                    "Esquecer dependência em Δt/Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar e Internalizar o Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Leia o enunciado preciso: 'Um método numérico linear bem-posicionado para EDPs hiperbólicas converge se e somente se for consistente e estável.'",
                                    "Memorize os termos chave: linear, bem-posicionado, consistente, estável, convergente.",
                                    "Explique a direção 'se': consistência + estabilidade => convergência (via teorema).",
                                    "Explique a direção 'somente se': convergência requer ambos.",
                                    "Pratique escrevendo o teorema 5 vezes de memória.",
                                    "Discuta exceções ou generalizações (ex: não-lineares)."
                                  ],
                                  "verification": "Escreva o teorema completo sem consultar materiais e explique cada termo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ficha de memorização",
                                    "Artigo original Lax-Richtmyer (1956) resumo",
                                    "Quiz online de Análise Numérica"
                                  ],
                                  "tips": "Use mnemônicos: 'CCS' para Consistente, Convergente, Estável (com iff).",
                                  "learningObjective": "Declarar precisamente o teorema e suas condições.",
                                  "commonMistakes": [
                                    "Omitir 'linear' ou 'bem-posicionado'",
                                    "Trocar 'se e somente se' por implicação unidirecional",
                                    "Confundir com teorema de Lax para não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema upwind em u_t + a u_x = 0: Verifique consistência (ordem 1 via Taylor), estabilidade (CFL |a| Δt/Δx <=1), logo converge pelo teorema. Simule em Python e compare com solução exata.",
                              "finalVerifications": [
                                "Enuncie o teorema verbatim sem erros.",
                                "Dê definições corretas de consistente e estável.",
                                "Identifique um esquema consistente mas instável (ex: forward explicit sem CFL).",
                                "Explique por que ambos são necessários.",
                                "Aplique o teorema a um exemplo simples.",
                                "Diferencie de cenários não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado (100% dos termos chave).",
                                "Compreensão conceitual via exemplos (consistência/estabilidade).",
                                "Capacidade de verificação em esquemas conhecidos.",
                                "Correta identificação de contratexemplos.",
                                "Fluência na explicação da bicondicional.",
                                "Aplicação em contexto hiperbólico."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de ondas e choques.",
                                "Engenharia Mecânica: Dinâmica de fluidos computacional (CFD).",
                                "Ciência da Computação: Análise de algoritmos numéricos paralelos.",
                                "Física: Propagação de sinais em meios hiperbólicos."
                              ],
                              "realWorldApplication": "Garante confiabilidade em simulações numéricas para previsão meteorológica, aerodinâmica em aviação e modelagem de terremotos, evitando divergências em códigos de alto desempenho como em supercomputadores para CFD."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Aplicar o teorema em exemplos",
                            "description": "Verificar convergência de esquemas como FTCS para a equação do calor usando consistência + estabilidade, citando referências como LeVeque (2007).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema de Lax-Richtmyer e Conceitos Fundamentais",
                                  "subSteps": [
                                    "Leia a declaração precisa do Teorema de Lax-Richtmyer de LeVeque (2007).",
                                    "Identifique as condições necessárias: consistência do esquema e estabilidade.",
                                    "Revise a definição de convergência para métodos de diferenças finitas.",
                                    "Anote as hipóteses do teorema, como problema linear bem-posto.",
                                    "Compare com esquemas de evolução parabólica como a equação do calor."
                                  ],
                                  "verification": "Explique o teorema em suas próprias palavras e liste as duas condições principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro 'Finite Difference Methods for Ordinary and Partial Differential Equations' de LeVeque (2007), Seção 3.4",
                                    "Notas de aula sobre Análise Numérica II"
                                  ],
                                  "tips": "Use diagramas para visualizar consistência (aproximação local) vs. estabilidade (comportamento global).",
                                  "learningObjective": "Compreender as condições equivalentes para convergência via Teorema de Lax-Richtmyer.",
                                  "commonMistakes": "Confundir consistência (ordem de truncamento) com estabilidade (amplificação de erros)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Consistência do Esquema FTCS para a Equação do Calor",
                                  "subSteps": [
                                    "Escreva o esquema FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = Δt / Δx².",
                                    "Calcule o erro de truncamento local usando expansão de Taylor.",
                                    "Mostre que o esquema é consistente de ordem O(Δt + Δx²).",
                                    "Confirme que tende à equação do calor u_t = u_xx à medida que Δt, Δx → 0.",
                                    "Cite LeVeque (2007) para a análise de consistência em esquemas explícitos."
                                  ],
                                  "verification": "Derive o erro de truncamento e confirme ordem de consistência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software simbólico como SymPy/Python",
                                    "LeVeque (2007), Seção 2.5 e 3.2"
                                  ],
                                  "tips": "Expanda cada termo em série de Taylor centrada em (x_j, t_n).",
                                  "learningObjective": "Demonstrar que o esquema FTCS é consistente com a equação do calor.",
                                  "commonMistakes": "Esquecer termos de ordem superior no erro de truncamento ou inverter Δt e Δx."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade do Esquema FTCS",
                                  "subSteps": [
                                    "Aplique a análise de von Neumann: assuma solução u_j^n = ξ^n e^{i k j Δx}.",
                                    "Calcule o fator de amplificação |ξ| = |1 - 4r sin²(θ/2)|, onde θ = k Δx.",
                                    "Determine a condição CFL: r ≤ 1/2 para |ξ| ≤ 1 ∀ k.",
                                    "Verifique numericamente para r > 1/2 que oscilações crescem.",
                                    "Referencie LeVeque (2007) para estabilidade de esquemas parabólicos."
                                  ],
                                  "verification": "Plote |ξ| vs. θ para r=0.4 (estável) e r=0.6 (instável).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotar fator de amplificação",
                                    "LeVeque (2007), Seção 2.6"
                                  ],
                                  "tips": "Use numpy para discretizar θ e visualizar o envelope máximo de |ξ|.",
                                  "learningObjective": "Estabelecer a condição de estabilidade r ≤ 1/2 para FTCS.",
                                  "commonMistakes": "Usar análise de Lax-Wendroff em vez de von Neumann para esquemas lineares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema e Concluir Convergência",
                                  "subSteps": [
                                    "Confirme consistência do Step 2 e estabilidade sob r ≤ 1/2 do Step 3.",
                                    "Invoque o Teorema de Lax-Richtmyer para concluir convergência.",
                                    "Implemente uma simulação numérica simples para validar.",
                                    "Discuta limitações (e.g., não-uniformidade em malhas finas).",
                                    "Cite explicitamente LeVeque (2007) e compare com esquemas implícitos."
                                  ],
                                  "verification": "Execute simulação e compare solução numérica com exata (erro < 1e-3).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com numpy/matplotlib para simulação FTCS",
                                    "LeVeque (2007), Capítulo 3"
                                  ],
                                  "tips": "Use condições iniciais u(x,0)=sin(πx) em [0,1] com u(0,t)=u(1,t)=0.",
                                  "learningObjective": "Aplicar o teorema para provar convergência condicional do FTCS.",
                                  "commonMistakes": "Ignorar que estabilidade é necessária mas não suficiente sem consistência."
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = u_xx em [0,1]×[0,1] com u(x,0)=sin(πx), u(0,t)=u(1,t)=0, aplique FTCS com Δx=0.1, Δt=0.004 (r=0.4). Verifique consistência (O(Δt+Δx²)), estabilidade (|ξ|≤1), e convergência pelo teorema, comparando com solução exata u(x,t)=sin(πx)e^{-π²t}.",
                              "finalVerifications": [
                                "Consistência confirmada com erro de truncamento derivado.",
                                "Condição de estabilidade r≤1/2 explicitada e plotada.",
                                "Teorema aplicado corretamente para concluir convergência.",
                                "Simulação numérica executada com erro pequeno.",
                                "Referências a LeVeque (2007) citadas com seções específicas.",
                                "Limitações discutidas (e.g., custo computacional para r pequeno)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do erro de truncamento (ordem correta).",
                                "Correta análise de von Neumann com fator de amplificação.",
                                "Aplicação lógica do Teorema de Lax-Richtmyer.",
                                "Validação numérica com gráfico de erro vs. refinamento de malha.",
                                "Citações adequadas e discussão de referências.",
                                "Clareza na explicação escrita ou relatório."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e condução de calor.",
                                "Computação Científica: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações em dinâmica de fluidos computacional (CFD).",
                                "Estatística: Análise de erros numéricos e convergência empírica."
                              ],
                              "realWorldApplication": "Verificação de convergência em simulações de propagação de calor em engenharia (e.g., design de trocadores de calor), previsão meteorológica (difusão de umidade), ou biologia computacional (difusão de espécies químicas)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Discutir limitações do teorema",
                            "description": "Explicar condições de aplicabilidade (linearidade, bem-posicionado) e extensões para métodos não lineares ou EDPs elípticas/parabólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema de Lax-Richtmyer e suas hipóteses fundamentais",
                                  "subSteps": [
                                    "Relembrar a declaração do teorema: convergência segue de consistência e estabilidade para problemas lineares bem-posicionados.",
                                    "Identificar hipóteses chave: linearidade do operador diferencial, problema inicial-valor bem-posicionado.",
                                    "Estudar definições formais de consistência (aproximação local do operador) e estabilidade (norma da solução numérica bounded).",
                                    "Analisar prova esquemática do teorema, focando em onde linearidade é usada.",
                                    "Comparar com esquemas lineares simples, como Lax-Friedrichs para equação de advecção."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando o teorema e listando 3 hipóteses principais com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula de Análise Numérica II, livro 'Análise Numérica de EDPs' de LeVeque, quadro branco.",
                                  "tips": "Use diagramas de Fourier para visualizar estabilidade em problemas lineares.",
                                  "learningObjective": "Compreender as condições exatas sob as quais o teorema garante convergência.",
                                  "commonMistakes": "Confundir consistência (ordem de truncamento) com estabilidade (crescimento de erros); ignorar 'bem-posicionado'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar limitações devido à linearidade",
                                  "subSteps": [
                                    "Discutir por que o teorema falha para operadores não-lineares: estabilidade local não implica global.",
                                    "Estudar contra-exemplo clássico: Burgers' equation com upwind scheme, onde consistência e estabilidade local existem mas convergência falha.",
                                    "Analisar impacto de não-linearidades em esquemas explícitos vs. implícitos.",
                                    "Investigar métricas alternativas para não-lineares, como entropia ou TVD.",
                                    "Simular numericamente um caso simples de Burgers para observar divergência."
                                  ],
                                  "verification": "Identificar e descrever um contra-exemplo específico, incluindo código ou gráfico de erro não convergindo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), exemplos de código para Burgers' equation.",
                                  "tips": "Comece com parâmetros pequenos para isolar o efeito não-linear.",
                                  "learningObjective": "Reconhecer falhas do teorema em contextos não-lineares e propor diagnósticos.",
                                  "commonMistakes": "Assumir que 'consistente e estável' basta sem testar numericamente; negligenciar condições iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar requisito de problema bem-posicionado",
                                  "subSteps": [
                                    "Definir 'bem-posicionado': existência e unicidade de solução suave para dados suaves.",
                                    "Examinar casos mal-posicionados: EDPs hiperbólicas com características complexas ou ressonantes.",
                                    "Discutir implicações para problemas iniciais-valor mal-postos, como equações de transporte reverso.",
                                    "Comparar com teoremas de existência para EDPs lineares constantes.",
                                    "Derivar uma condição simples para verificar bem-posicionado em 1D."
                                  ],
                                  "verification": "Classificar 3 problemas de EDP como bem- ou mal-posicionados, justificando com teoria.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referências teóricas (Evans PDE), exemplos de problemas hiperbólicos.",
                                  "tips": "Use análise de características para verificar bem-posicionado rapidamente.",
                                  "learningObjective": "Avaliar se um problema satisfaz as hipóteses geométricas do teorema.",
                                  "commonMistakes": "Confundir bem-posicionado com estabilidade numérica; ignorar soluções fracas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir extensões para EDPs elípticas e parabólicas",
                                  "subSteps": [
                                    "Adaptar teorema para elípticas: foco em consistência em normas H1 e estabilidade elliptica.",
                                    "Para parabólicas: analisar semi-discretização em tempo, usando estabilidade em normas L2.",
                                    "Estudar limitações em domínios irregulares ou condições de contorno não-Dirichlet.",
                                    "Explorar Godunov-Ryabenkii para condições de contorno e suas restrições.",
                                    "Comparar convergência em esquemas finite difference para heat equation vs. wave."
                                  ],
                                  "verification": "Esboçar uma extensão do teorema para uma EDP parabólica específica, listando novas hipóteses.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos sobre teoremas de convergência para elípticas/parabólicas, solver numérico.",
                                  "tips": "Conecte a análise espectral de Lax para elípticas.",
                                  "learningObjective": "Estender conceitos do teorema além de hiperbólicas iniciais-valor.",
                                  "commonMistakes": "Aplicar diretamente teorema de hiperbólicas a elípticas sem ajustes; esquecer contornos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar implicações práticas e estratégias de mitigação",
                                  "subSteps": [
                                    "Resumir limitações principais em uma tabela: linearidade, bem-posicionado, tipo de EDP.",
                                    "Propor testes práticos: análise de von Neumann + simulações não-lineares.",
                                    "Discutir métodos alternativos: adaptação de malha, esquemas high-order com limiters.",
                                    "Avaliar trade-offs: precisão vs. robustez em aplicações reais.",
                                    "Preparar discussão em grupo sobre um paper recente violando o teorema."
                                  ],
                                  "verification": "Criar tabela de limitações e sugerir 2 mitigadores para cada, com referências.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papéis acadêmicos (e.g., 'Limitations of Lax Equivalence'), ferramenta de tabela (Excel/LaTeX).",
                                  "tips": "Priorize limitações mais comuns em CFD.",
                                  "learningObjective": "Aplicar conhecimento para guiar escolha de métodos numéricos.",
                                  "commonMistakes": "Superestimar generalidade do teorema; ignorar custo computacional de testes."
                                }
                              ],
                              "practicalExample": "Ao simular a equação de Burgers não-linear (u_t + u u_x = nu u_xx) com esquema upwind explícito, observa-se consistência O(Delta x) e estabilidade CFL-condicional, mas para nu pequeno e shocks, o erro não converge devido a oscilações não controladas, violando Lax-Richtmyer. Implemente em Python e plote ||u_num - u_exact|| vs. refinamento de malha para demonstrar.",
                              "finalVerifications": [
                                "Explicar corretamente 4 limitações principais do teorema com exemplos.",
                                "Identificar se um problema dado (e.g., Navier-Stokes 2D) satisfaz hipóteses.",
                                "Propor teste numérico para checar falha em caso não-linear.",
                                "Discutir extensão para parabólicas com pelo menos 2 ajustes específicos.",
                                "Listar 3 implicações para escolha de esquemas em software como FEniCS.",
                                "Simular contra-exemplo e interpretar gráfico de convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de hipóteses (linearidade, bem-posicionado): 25%.",
                                "Profundidade de contra-exemplos e simulações: 25%.",
                                "Clareza em extensões para outros tipos de EDP: 20%.",
                                "Relevância de mitigadores práticos: 15%.",
                                "Síntese em tabela/resumo coeso: 10%.",
                                "Uso correto de terminologia numérica: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Aplicar em modelagem de fluidos não-lineares (Navier-Stokes).",
                                "Programação Científica: Implementar testes de convergência em Python/MATLAB.",
                                "Estatística: Analisar erros numéricos como distribuições aleatórias em MC.",
                                "Engenharia: Avaliar estabilidade em controle de sistemas dinâmicos discretos.",
                                "Filosofia da Ciência: Discutir limites da teoria em aproximações reais."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica (modelos parabólicos não-lineares como shallow water), limitações do teorema guiam o uso de esquemas TVD ou WENO para evitar instabilidades em frentes de choque, garantindo previsões confiáveis usadas por agências como INMET ou NOAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Estabilidade em Métodos Numéricos",
                    "description": "Análise de estabilidade via amplificação de Fourier e critério de von Neumann.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Análise de Fourier em Métodos Numéricos",
                        "description": "Método analítico para avaliar a estabilidade de esquemas de diferenças finitas em equações diferenciais parciais, assumindo condições periódicas e decompondo a solução em uma soma de ondas de Fourier.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Representar a solução numérica via modos de Fourier",
                            "description": "Dada uma malha periódica, expressar a solução aproximada u_j^n como uma superposição de ondas e^{i k j h} com fator temporal g^n, onde k é o número de onda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender séries de Fourier discretas em malhas periódicas",
                                  "subSteps": [
                                    "Revise a transformada discreta de Fourier (DFT) para funções periódicas em uma malha espacial com J pontos.",
                                    "Identifique os modos de Fourier como e^{i k j h}, onde k = 2π m / (J h), m = 0, ..., J-1, e h é o passo espacial.",
                                    "Pratique decompondo uma função inicial u_j^0 em soma de modos: u_j^0 = ∑ ĉ_k e^{i k j h}.",
                                    "Verifique ortogonalidade dos modos na malha periódica.",
                                    "Implemente DFT manualmente para uma malha pequena (J=8)."
                                  ],
                                  "verification": "Decompor corretamente uma função teste (ex: u_j^0 = sin(2π j / J)) em 3 modos dominantes e reconstruir com erro <1e-10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica' de Burden & Faires (Cap. Fourier)",
                                    "Python com numpy.fft",
                                    "Papel e lápis para J=4"
                                  ],
                                  "tips": "Use propriedades de periodicidade: modo k=J/2 é o modo Nyquist.",
                                  "learningObjective": "Dominar a representação de funções periódicas discretas via DFT.",
                                  "commonMistakes": [
                                    "Confundir k contínuo com discreto",
                                    "Ignorar normalização na DFT",
                                    "Esquecer periodicidade u_0 = u_J"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar um único modo de Fourier em esquemas numéricos",
                                  "subSteps": [
                                    "Assuma solução mono-modular: u_j^n = g^n e^{i k j h}.",
                                    "Substitua no esquema numérico (ex: heat equation explícito: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j+1}^n)).",
                                    "Derive o fator de amplificação g(k) = 1 - 4r sin²(k h / 2).",
                                    "Calcule |g(k)| para diferentes k e r.",
                                    "Plote |g(k)| vs k para visualizar estabilidade."
                                  ],
                                  "verification": "Derivar g(k) corretamente para esquema dado e identificar condição |g(k)| ≤ 1 ∀k.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB/Python (matplotlib para plots)",
                                    "Folhas de derivação",
                                    "Exemplos de Burden Cap. 12"
                                  ],
                                  "tips": "Use identidades trigonométricas: e^{iθ} + e^{-iθ} = 2 cos θ.",
                                  "learningObjective": "Calcular o fator de amplificação para modos individuais.",
                                  "commonMistakes": [
                                    "Erro na substituição do stencil",
                                    "Confundir g(k) com amplificação por passo",
                                    "Plotar sem normalizar k ∈ [-π/h, π/h]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a solução geral como superposição de modos",
                                  "subSteps": [
                                    "Expresse coeficientes iniciais ĉ_k via DFT de u_j^0.",
                                    "Evolua cada modo independentemente: modo k em tempo n vira ĉ_k [g(k)]^n e^{i k j h}.",
                                    "Some todos os modos: u_j^n = ∑ ĉ_k [g(k)]^n e^{i k j h}.",
                                    "Use IDFT para obter u_j^n diretamente.",
                                    "Compare com solução numérica direta para validar."
                                  ],
                                  "verification": "Simular 100 passos e comparar erro L2 entre superposição e simulação direta <1e-8.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Código Python completo com numpy.fft.ifft",
                                    "Notebook Jupyter",
                                    "Dados teste: pulso gaussiano periódico"
                                  ],
                                  "tips": "Diagonalize o operador espacial via FFT para eficiência.",
                                  "learningObjective": "Representar solução numérica exata via análise de Fourier.",
                                  "commonMistakes": [
                                    "Não aplicar g^n corretamente a ĉ_k",
                                    "Erro de fase em reconstrução",
                                    "Sobrecarga computacional sem FFT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e interpretar para análise de estabilidade",
                                  "subSteps": [
                                    "Identifique modos instáveis: |g(k)| >1 para algum k.",
                                    "Analise dispersão: fase de g(k) vs ω(k) exata.",
                                    "Teste com ruído inicial para excitar altos k.",
                                    "Otimize parâmetros (ex: r) baseado em max_k |g(k)|.",
                                    "Documente relatório com plots de |g(k)|^n."
                                  ],
                                  "verification": "Prever corretamente instabilidade para r>0.5 no heat explícito via |g(π/h)|.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Jupyter com animações (matplotlib.animation)",
                                    "Referência: LeVeque 'Finite Difference Methods' Cap. 5"
                                  ],
                                  "tips": "Foco em k altos para CFL-like conditions.",
                                  "learningObjective": "Usar representação Fourier para diagnosticar estabilidade.",
                                  "commonMistakes": [
                                    "Ignorar aliasing em k",
                                    "Confundir estabilidade com precisão",
                                    "Não testar múltiplos r"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx em malha periódica com h=1/32, r=0.4, condição inicial u_j^0 = exp(-(j h - 0.5)^2 / 0.01). Compute DFT inicial, evolua modos com g(k)^n = [1-4*0.4*sin(kh/2)^2]^n, reconstrói via IDFT e compara com 1000 passos explícitos (erro L∞ <1e-6).",
                              "finalVerifications": [
                                "Derivar g(k) para qualquer stencil de 3 pontos.",
                                "Representar u^n via superposição Fourier com código funcional.",
                                "Identificar r crítico para estabilidade via max |g(k)|=1.",
                                "Plotar evolução espectral |ĉ_k g(k)^n|.",
                                "Validar contra solução exata para problema teste.",
                                "Explicar por que altos k causam instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação de g(k): 100% simbólica correta.",
                                "Implementação numérica: erro de reconstrução <1e-10.",
                                "Análise qualitativa: correção de condições de estabilidade.",
                                "Visualizações: plots claros de |g(k)| e solução.",
                                "Relatório: explicação coerente de superposição.",
                                "Criatividade: extensão a stencil de 5 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em meios discretos (equação de onda).",
                                "Engenharia: Simulações CFD via métodos espectrais.",
                                "Computação: Algoritmos FFT em processamento de sinal.",
                                "Física Computacional: Estabilidade em simulações moleculares."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou acústicas, essa análise previne blow-up numérico ao otimizar passos de tempo baseados em |g(k)|≤1 para todos os modos, permitindo simulações estáveis de ondas em domínios periódicos como esferas ou cilindros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Derivar a relação de recursão para um modo único",
                            "description": "Substituir a forma de Fourier u_j^n = g^n e^{i θ j} (com θ = k h) na equação de diferenças finitas para obter a equação amplificadora g = G(θ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma de Fourier para um modo único",
                                  "subSteps": [
                                    "Revise o conceito de análise de Von Neumann para estabilidade.",
                                    "Identifique a forma assumida para a solução: u_j^n = g^n e^{i θ j}, onde θ = k h.",
                                    "Explique o significado físico: representa uma onda plana discreta com número de onda k.",
                                    "Discuta as condições de periodicidade e o papel do fator de amplificação g.",
                                    "Esboce graficamente um modo único para diferentes θ."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a forma de Fourier e seu propósito na análise de estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise de Fourier em métodos numéricos",
                                    "Quadro branco ou papel para esboços",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Visualize θ como o ângulo de fase por célula de grade; valores pequenos representam ondas longas.",
                                  "learningObjective": "Dominar a representação de modos únicos na análise de estabilidade de Von Neumann.",
                                  "commonMistakes": [
                                    "Confundir θ = k h com k diretamente",
                                    "Esquecer que g pode ser complexo",
                                    "Ignorar a dependência em n para evolução temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a equação de diferenças finitas genérica",
                                  "subSteps": [
                                    "Escreva a equação de diferenças finitas genérica para o problema, ex: u_j^{n+1} = A u_{j-1}^n + B u_j^n + C u_{j+1}^n.",
                                    "Identifique os coeficientes A, B, C para um esquema específico (ex: Lax-Friedrichs ou FTCS).",
                                    "Verifique as condições de consistência aproximando o operador diferencial.",
                                    "Anote os passos de discretização espacial (h) e temporal (τ).",
                                    "Confirme que a equação é linear e homogênea para aplicar a ansatz de Fourier."
                                  ],
                                  "verification": "Reescreva corretamente a equação de diferenças para um esquema dado sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de esquemas numéricos de Análise Numérica II",
                                    "Calculadora simbólica (ex: Mathematica ou papel)"
                                  ],
                                  "tips": "Sempre normalize os coeficientes para facilitar a substituição posterior.",
                                  "learningObjective": "Preparar a base algébrica para a substituição da forma de Fourier.",
                                  "commonMistakes": [
                                    "Usar notação incorreta para índices j e n",
                                    "Confundir operadores forward/backward",
                                    "Omitir fatores de λ = τ/h²"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir a forma de Fourier na equação de diferenças",
                                  "subSteps": [
                                    "Substitua u_j^n = g^n e^{i θ j} em todos os termos da equação.",
                                    "Compute u_{j±1}^n = g^n e^{i θ (j±1)} = g^n e^{i θ j} e^{± i θ}.",
                                    "Substitua u_j^{n+1} = g^{n+1} e^{i θ j} = g · u_j^n.",
                                    "Divida ambos os lados por g^n e^{i θ j} (assumindo não nulo).",
                                    "Simplifique exponenciais: e^{i θ} + e^{-i θ} = 2 cos θ para diferenças centrais."
                                  ],
                                  "verification": "Mostre a equação após substituição reduzida a uma relação em g e θ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado para cálculos complexos",
                                    "Software simbólico como SymPy para verificação opcional"
                                  ],
                                  "tips": "Fatore e^{i θ j} g^n commonemente para cancelar; pratique com i imaginário.",
                                  "learningObjective": "Executar a substituição corretamente, lidando com exponenciais complexas.",
                                  "commonMistakes": [
                                    "Erro no shift de índice: esquecer e^{± i θ}",
                                    "Não dividir pelo termo comum",
                                    "Confundir g^{n+1} com g^n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e interpretar a equação amplificadora g = G(θ)",
                                  "subSteps": [
                                    "Resolva para g: g = A e^{-i θ} + B + C e^{i θ}.",
                                    "Defina G(θ) como a função amplificadora explícita.",
                                    "Analise |g| ≤ 1 para estabilidade (condição de Von Neumann).",
                                    "Discuta o espectro de θ ∈ [0, π] (modos resolvíveis).",
                                    "Verifique para θ → 0: g → 1 para consistência."
                                  ],
                                  "verification": "Escreva g = G(θ) explicitamente e verifique |G(θ)| ≤ 1 para alguns θ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de |G(θ)| de exemplos prévios",
                                    "Planilha para plotar |g(θ)|"
                                  ],
                                  "tips": "Use identidades trigonométricas: cos θ para real part; sen θ para imag.",
                                  "learningObjective": "Obter e interpretar a relação de recursão como critério de estabilidade.",
                                  "commonMistakes": [
                                    "Erro algébrico em soma de exponenciais",
                                    "Ignorar parte imaginária de g",
                                    "Esquecer normalização para θ=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação de calor u_t = u_xx: u_j^{n+1} = u_j^n + λ (u_{j+1}^n - 2 u_j^n + u_{j-1}^n), com λ = τ/h². Substitua a forma de Fourier para obter g(θ) = 1 - 4λ sin²(θ/2). Verifique estabilidade: |g| ≤ 1 requer λ ≤ 1/2.",
                              "finalVerifications": [
                                "Deriva corretamente g = G(θ) para um esquema dado sem erros algébricos.",
                                "Identifica corretamente os fatores e^{± i θ} na substituição.",
                                "Explica o papel de |G(θ)| ≤ 1 para todos θ ∈ [0, π].",
                                "Aplica a derivação a um exemplo concreto como FTCS ou Lax-Wendroff.",
                                "Verifica consistência limitando θ → 0."
                              ],
                              "assessmentCriteria": [
                                "Precisão na manipulação de exponenciais complexas (80% peso).",
                                "Correção algébrica na derivação de G(θ) (15% peso).",
                                "Interpretação física da amplificação e estabilidade (5% peso).",
                                "Clareza na documentação dos passos.",
                                "Capacidade de generalizar para esquemas não explícitos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de modos em equações de onda e difusão.",
                                "Computação Científica: Implementação e teste de estabilidade em código.",
                                "Engenharia: Validação de solvers em CFD e simulações acústicas.",
                                "Estatística: Análise espectral em séries temporais numéricas."
                              ],
                              "realWorldApplication": "Essa derivação é essencial para validar a estabilidade de esquemas numéricos em previsões meteorológicas (modelos de atmosfera), simulações de dinâmica de fluidos computacional (aviões, turbinas) e propagação de ondas sísmicas, evitando instabilidades que invalidam simulações reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Interpretar a análise de Fourier para estabilidade",
                            "description": "Analisar como os modos de alta frequência (θ próximo de π) afetam a estabilidade e relacionar com dissipação e dispersão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise de Estabilidade de von Neumann",
                                  "subSteps": [
                                    "Explicar o que é a análise de von Neumann usando transformadas de Fourier para métodos de diferenças finitas.",
                                    "Derivar a forma assumida da solução: u_j^n = g^n e^{i k j h}, onde θ = k h.",
                                    "Definir o fator de amplificação |g(θ)| ≤ 1 para estabilidade.",
                                    "Discutir o espectro de frequências: θ de 0 a π (modos baixa a alta frequência).",
                                    "Implementar um exemplo simples em código para visualizar g(θ)."
                                  ],
                                  "verification": "Capacidade de derivar corretamente o fator de amplificação para um esquema simples como Lax-Friedrichs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), Python/MATLAB com NumPy.",
                                  "tips": "Sempre normalize θ entre 0 e π para evitar ambiguidades periódicas.",
                                  "learningObjective": "Compreender a base da análise de Fourier para estabilidade em esquemas lineares.",
                                  "commonMistakes": "Confundir θ com k; esquecer que análise é para problemas lineares com coeficientes constantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Caracterizar Modos de Alta Frequência",
                                  "subSteps": [
                                    "Definir modos de alta frequência como θ próximo de π (ondas curtas, 2 pontos por onda).",
                                    "Plotar soluções numéricas mostrando oscilações em alta frequência.",
                                    "Comparar com a solução exata: alta frequência deve ser mínima em problemas físicos.",
                                    "Calcular θ para diferentes resoluções espaciais h.",
                                    "Simular um problema de transporte para observar modos altos."
                                  ],
                                  "verification": "Identificar corretamente θ ≈ π em um gráfico de solução numérica instável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (Matplotlib), exemplos de código de esquemas hiperbólicos.",
                                  "tips": "Use zoom em θ ∈ [π/2, π] nos gráficos de |g(θ)| para focar em alta frequência.",
                                  "learningObjective": "Reconhecer o papel destrutivo dos modos de alta frequência na precisão.",
                                  "commonMistakes": "Ignorar que modos altos são artificiais e não representam física real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Fator de Amplificação para Modos de Alta Frequência",
                                  "subSteps": [
                                    "Derivar |g(θ)| para esquemas explícitos (ex: upwind, Lax-Wendroff).",
                                    "Verificar se |g(θ → π)| < 1 (dissipação) ou =1 com fase errada (dispersão).",
                                    "Plotar |g(θ)| e arg(g(θ)) vs θ.",
                                    "Comparar esquemas: CFL condition impacta alta frequência.",
                                    "Testar numericamente com uma perturbação de alta frequência."
                                  ],
                                  "verification": "Plotar |g(θ)| mostrando |g(π)| <1 para esquema estável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de derivadas simbólicas, código Python para fator g(θ).",
                                  "tips": "Expanda g(θ) em série de Taylor em torno de θ=π para aproximações.",
                                  "learningObjective": "Calcular e interpretar |g(θ)| para θ≈π em diferentes esquemas.",
                                  "commonMistakes": "Confundir magnitude |g| com fase; esquecer normalização pelo timestep."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Dissipação, Dispersão e Estabilidade",
                                  "subSteps": [
                                    "Definir dissipação: |g(θ)| <1 para θ>0, especialmente alta frequência.",
                                    "Definir dispersão: arg(g(θ))/θ ≠ c (velocidade de fase errada).",
                                    "Explicar por que dissipação é necessária para estabilidade: amortecer modos parasitas.",
                                    "Analisar esquemas: upwind dissipativo, Lax-Wendroff dispersivo.",
                                    "Concluir: estabilidade requer |g(θ)|≤1 ∀θ, com dissipação em alta frequência."
                                  ],
                                  "verification": "Explicar verbalmente por que um esquema sem dissipação em θ=π é instável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos de |g| e fase, tabela comparativa de esquemas.",
                                  "tips": "Lembre: dispersão causa oscilações, dissipação suaviza mas pode overdamp.",
                                  "learningObjective": "Conectar conceitos de dissipação/dispersão à estabilidade via análise de Fourier.",
                                  "commonMistakes": "Pensar que dispersão causa instabilidade (não, só erro de fase)."
                                }
                              ],
                              "practicalExample": "Considere o esquema upwind para a equação de advecção u_t + u_x =0: g(θ) = 1 - i λ sin(θ), com λ=CFL. Para θ=π, |g(π)| = |1| se λ=0, mas geralmente <1. Simule com perturbação senoidal de alta frequência e observe amortecimento ao longo do tempo.",
                              "finalVerifications": [
                                "Derivar corretamente |g(θ)| para pelo menos dois esquemas e plotar.",
                                "Identificar em um gráfico se um esquema é estável baseado em |g(π)|.",
                                "Explicar o impacto de modos θ≈π em uma simulação instável.",
                                "Comparar dissipação vs dispersão com exemplos concretos.",
                                "Aplicar análise a um novo esquema simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator de amplificação (80% correto).",
                                "Interpretação qualitativa de gráficos |g(θ)| e arg(g(θ)).",
                                "Capacidade de relacionar conceitos teóricos a simulações numéricas.",
                                "Identificação correta de requisitos para estabilidade em alta frequência.",
                                "Uso apropriado de terminologia (dissipação, dispersão, modos parasitas)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e amortecimento em equações diferenciais parciais.",
                                "Engenharia Computacional: Estabilidade em CFD e simulações de fluidos.",
                                "Processamento de Sinais: Transformada de Fourier e filtros numéricos.",
                                "Física Computacional: Modelagem de sistemas dinâmicos discretos."
                              ],
                              "realWorldApplication": "Em simulações de previsão numérica do tempo (modelos NWP), a análise de Fourier garante estabilidade ao dissipar modos de alta frequência (ruído de grade), evitando explosões numéricas em previsões de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Fator de Amplificação",
                        "description": "Quantidade complexa G(θ) que multiplica cada modo de Fourier a cada passo temporal, determinando se erros são amplificados ou atenuados.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Calcular o fator de amplificação para esquemas explícitos",
                            "description": "Para o método de Euler explícito na equação de calor, derivar G(θ) = 1 - 4 r sin²(θ/2), onde r = α Δt / Δx².",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a equação de calor e o esquema de Euler explícito",
                                  "subSteps": [
                                    "Escreva a equação de calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Defina a malha espacial e temporal: x_j = j Δx, t_n = n Δt.",
                                    "Aproximação de Euler explícito: u_j^{n+1} = u_j^n + r (u_{j-1}^n - 2 u_j^n + u_{j+1}^n), onde r = α Δt / Δx².",
                                    "Explique o significado físico de r como o número de Fourier.",
                                    "Verifique a consistência do esquema com a equação contínua."
                                  ],
                                  "verification": "Confirme que a equação discreta reproduz a derivada temporal e segunda espacial corretamente ao tomar limites Δt, Δx → 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora; referência: livro de análise numérica (ex: Burden & Faires).",
                                  "tips": "Sempre normalize as equações com os parâmetros Δt e Δx para clareza.",
                                  "learningObjective": "Entender a discretização finita diferenças para a equação parabólica.",
                                  "commonMistakes": "Confundir o sinal da segunda derivada ou esquecer o fator α em r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise de von Neumann de estabilidade",
                                  "subSteps": [
                                    "Assuma uma solução modal: u_j^n = g^n e^{i θ j}, onde θ = κ Δx é o número de onda discreto.",
                                    "Substitua na equação discreta: g^{n+1} e^{i θ j} = g^n e^{i θ j} + r g^n (e^{i θ (j-1)} - 2 e^{i θ j} + e^{i θ (j+1)}).",
                                    "Simplifique dividindo por g^n e^{i θ j}: g = 1 + r (e^{-i θ} - 2 + e^{i θ}).",
                                    "Reconheça que e^{i θ} + e^{-i θ} = 2 cos θ.",
                                    "Escreva a expressão intermediária: g(θ) = 1 + r (2 cos θ - 2)."
                                  ],
                                  "verification": "Verifique que |g(θ)| ≤ 1 para todos θ implica estabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora científica para exponenciais complexas.",
                                  "tips": "Use a forma exponencial complexa para evitar erros em aproximações reais.",
                                  "learningObjective": "Dominar a suposição de modo plano na análise de estabilidade linear.",
                                  "commonMistakes": "Esquecer de dividir por g^n e^{i θ j} ou errar os expoentes nos vizinhos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a forma simplificada de G(θ)",
                                  "subSteps": [
                                    "Da expressão anterior: g(θ) = 1 + 2 r (cos θ - 1).",
                                    "Use a identidade trigonométrica: cos θ - 1 = -2 sin²(θ/2).",
                                    "Substitua: g(θ) = 1 + 2 r (-2 sin²(θ/2)) = 1 - 4 r sin²(θ/2).",
                                    "Confirme que G(θ) é real e depende apenas de θ e r.",
                                    "Discuta o módulo |G(θ)| = |1 - 4 r sin²(θ/2)| para estabilidade (requer r ≤ 1/2)."
                                  ],
                                  "verification": "Calcule G(θ) para θ=0 (deve ser 1) e θ=π (deve ser 1 - 4r).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de identidades trigonométricas; software como Mathematica para verificação simbólica.",
                                  "tips": "Lembre-se da meia-angulação: sin(θ/2) captura o comportamento de alta frequência.",
                                  "learningObjective": "Aplicar identidades trigonométricas para simplificar fatores de amplificação.",
                                  "commonMistakes": "Errar o sinal em cos θ - 1 = -2 sin²(θ/2) ou fator 4 em vez de 2*2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e verificar a derivação completa",
                                  "subSteps": [
                                    "Escreva a fórmula final: G(θ) = 1 - 4 r sin²(θ/2).",
                                    "Plote |G(θ)| vs θ para r=0.4 e r=0.6 para visualizar instabilidade.",
                                    "Verifique consistência: para pequenas θ, expanda sin(θ/2) ≈ θ/2, G ≈ 1 - r θ².",
                                    "Compare com o caso contínuo: fator exato e^{-α κ² Δt} ≈ 1 - α κ² Δt.",
                                    "Discuta implicações para escolha de Δt e Δx."
                                  ],
                                  "verification": "Derivação coincide com referências padrão e plotagem mostra |G|≤1 iff r≤0.5.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python/MATLAB para plotagem; papel para expansão em série.",
                                  "tips": "Sempre teste casos limites: θ=0 (preservação de média), θ=π (oscilação).",
                                  "learningObjective": "Interpretar o fator de amplificação em termos de estabilidade numérica.",
                                  "commonMistakes": "Ignorar que G é complexo em geral, mas real aqui; confundir com esquemas implícitos."
                                }
                              ],
                              "practicalExample": "Para r=0.3 e θ=π/2, calcule G(θ) = 1 - 4*0.3*sin²(π/4) = 1 - 1.2*(0.5) = 0.4. Em uma simulação de 100 passos, o modo θ decai por 0.4^{100}, estável.",
                              "finalVerifications": [
                                "Derivação passo a passo reproduz exatamente G(θ) = 1 - 4 r sin²(θ/2).",
                                "Cálculo correto para θ=0: G=1; θ=π: G=1-4r.",
                                "Identificação correta da condição de estabilidade r ≤ 1/2.",
                                "Expansão em série para pequenas θ coincide com o caso exato.",
                                "Plot de |G(θ)| mostra máximo em θ=0 e mínimo em θ=π.",
                                "Explicação verbal da origem trigonométrica."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Uso correto de análise de von Neumann e identidades trigonométricas.",
                                "Compreensão conceitual de r e sua relação com estabilidade.",
                                "Capacidade de verificar numericamente para valores específicos.",
                                "Interpretação qualitativa do comportamento de G(θ).",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e ondas.",
                                "Programação: Implementação de solvers FDTD em Python/NumPy.",
                                "Engenharia: Simulações CFD para previsão de fluxos.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações de propagação de calor em engenharia (ex: design de trocadores de calor), essa derivação garante estabilidade ao escolher Δt ≤ (Δx²)/(2α), evitando oscilações artificiais em previsões meteorológicas ou modelagem de materiais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Determinar condições de |G(θ)| ≤ 1",
                            "description": "Verificar o módulo |G(θ)| para todo θ ∈ [0, π] e identificar regiões de estabilidade no plano (Δt, Δx).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e derivar o fator de amplificação G(θ)",
                                  "subSteps": [
                                    "Recordar o esquema numérico específico (ex: Lax-Wendroff ou upwind para EDOs/PDEs).",
                                    "Aplicar análise de von Neumann: assumir solução do tipo g^k e^{i θ j}, derivar recursão para g = G(θ).",
                                    "Calcular explicitamente G(θ) como função complexa de θ e parâmetros (r = Δt/Δx² ou λ = a Δt/Δx).",
                                    "Simplificar G(θ) para |G(θ)|, expressando em termos de cos(θ) ou sen(θ).",
                                    "Verificar G(θ) para casos limite: θ=0 (modo constante) e θ=π (oscilações altas)."
                                  ],
                                  "verification": "G(θ) derivado corretamente e |G(θ)| expresso analiticamente; testar numericamente para θ=0, π/2, π.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Folha de papel ou software como Mathematica/MATLAB para derivação simbólica",
                                    "Referência: notas de Análise Numérica sobre estabilidade von Neumann"
                                  ],
                                  "tips": "Use identidades trigonométricas como 1 - cos(θ) = 2 sin²(θ/2) para simplificar |G(θ)|.",
                                  "learningObjective": "Dominar derivação do fator de amplificação para esquemas lineares.",
                                  "commonMistakes": [
                                    "Esquecer fator i na exponencial Fourier",
                                    "Confundir r com λ em esquemas parabólicos vs. hiperbólicos",
                                    "Não normalizar θ em [0, π]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o comportamento de |G(θ)| em [0, π]",
                                  "subSteps": [
                                    "Plotar |G(θ)| vs. θ para valores fixos de parâmetros (ex: r=0.5, 1, 2).",
                                    "Identificar θ onde |G(θ)| é máximo (geralmente θ=π para modos de alta frequência).",
                                    "Determinar analiticamente max_θ |G(θ)|, resolvendo d|G|/dθ=0 ou avaliando extremos.",
                                    "Verificar se |G(θ)| ≤1 para todos θ; encontrar regiões onde viola.",
                                    "Analisar limite de estabilidade: quando max |G(θ)|=1."
                                  ],
                                  "verification": "Gráfico de |G(θ)| mostra ≤1 ou identifica violações; valor máximo correto.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Python/MATLAB com numpy/matplotlib para plotagem",
                                    "Calculadora simbólica para max |G(θ)|"
                                  ],
                                  "tips": "Para esquemas explícitos, |G(θ)| é unimodal; foque em θ=π onde é mais restritivo.",
                                  "learningObjective": "Analisar numericamente e analiticamente o espectro de amplificação.",
                                  "commonMistakes": [
                                    "Plotar θ em [0,2π] ignorando simetria",
                                    "Confundir |G(θ)| com Re(G(θ))",
                                    "Não considerar θ discretos em malha finita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar condições analíticas para |G(θ)| ≤ 1 ∀ θ ∈ [0, π]",
                                  "subSteps": [
                                    "Impor |G(θ)|² ≤1 para todo θ, levando a desigualdades em parâmetros.",
                                    "Resolver para o caso mais restritivo (ex: |G(π)| ≤1 dá r ≤1/2 para equação de calor).",
                                    "Generalizar: encontrar conjunto {r | max_θ |G(θ,r)| ≤1}.",
                                    "Expressar como inequação em Δt e Δx (ex: Δt ≤ (Δx²)/2 para difusão).",
                                    "Verificar consistência com teoremas conhecidos (ex: CFL para hiperbólicas)."
                                  ],
                                  "verification": "Condição derivada coincide com literatura; testada para valores limítrofes.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Papel para álgebra",
                                    "Livro de análise numérica (ex: LeVeque ou Quarteroni)"
                                  ],
                                  "tips": "Trabalhe com |G(θ)|² = G \bar{G} para evitar raízes; use cos(θ) parametrizado.",
                                  "learningObjective": "Traduzir critério de estabilidade em condições explícitas sobre malha.",
                                  "commonMistakes": [
                                    "Ignorar condição para todos θ, só checar θ=0",
                                    "Erro em simplificação trigonométrica",
                                    "Confundir estabilidade forte (||G||≤1) com fraca"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e visualizar regiões de estabilidade no plano (Δt, Δx)",
                                  "subSteps": [
                                    "Reescrever condição como região no plano paramétrico (ex: Δt ≤ c Δx²).",
                                    "Plotar fronteira de estabilidade (curva onde max|G|=1).",
                                    "Marcar regiões estável/instável; testar pontos com simulação numérica curta.",
                                    "Discutir dependência: parabólico (Δt ~ Δx²), hiperbólico (Δt ~ Δx).",
                                    "Documentar região como intervalo para Δt dado Δx fixo."
                                  ],
                                  "verification": "Gráfico do plano (Δt, Δx) com região sombreada corretamente; simulação numérica estável na região.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Python com matplotlib para contour plot",
                                    "Código simples de esquema numérico para teste"
                                  ],
                                  "tips": "Use log-escala para Δx pequeno; inclua linha Δt=0 e Δx=0 como limites.",
                                  "learningObjective": "Visualizar e interpretar regiões de estabilidade paramétrica.",
                                  "commonMistakes": [
                                    "Plotar Δt vs 1/Δx ao invés de Δx",
                                    "Não testar numericamente a fronteira",
                                    "Ignorar dependência não-linear em esquemas avançados"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema explícito u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n) da equação de calor u_t = u_{xx}, temos G(θ) = 1 - 4r sin²(θ/2). Condição |G(θ)| ≤1 ∀θ leva a r ≤ 1/2, ou Δt ≤ (Δx²)/2. No plano (Δt, Δx), região abaixo da parábola Δt = (Δx²)/2.",
                              "finalVerifications": [
                                "G(θ) derivado corretamente para o esquema dado.",
                                "max_θ |G(θ)| ≤1 verificado analiticamente e graficamente.",
                                "Condição em termos de r/λ coincide com teorema padrão.",
                                "Região de estabilidade plotada com testes numéricos em pontos internos/fronteira.",
                                "Explicação clara de por que violações levam a instabilidade (blow-up em altas frequências).",
                                "Documentação completa com gráficos e inequações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G(θ) (100% simbólico correto).",
                                "Análise completa de |G(θ)| em [0,π] com identificação de máximo.",
                                "Condições derivadas rigorosas e gerais (não ad-hoc).",
                                "Visualização clara do plano (Δt, Δx) com regiões marcadas.",
                                "Integração de verificação numérica/simulação.",
                                "Clareza na explicação de limitações (ex: linearidade assumida)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de difusão/ondas (ex: CFD).",
                                "Computação: Análise de algoritmos numéricos e otimização de malhas.",
                                "Engenharia: Dimensionamento de passos em simulações finitas.",
                                "Estatística: Análise de erro espectral em métodos MCMC."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, determinar Δt máx dado Δx para prever furacões sem instabilidade numérica; em finanças, estabilidade de esquemas para equações de Black-Scholes em precificação de opções."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Comparar fatores de amplificação em esquemas implícitos",
                            "description": "Derivar G(θ) para o método de Crank-Nicolson e mostrar sua estabilidade incondicional (|G(θ)| ≤ 1 sempre).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema de Crank-Nicolson e preparar análise de von Neumann",
                                  "subSteps": [
                                    "Relembre a equação de difusão unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Escreva o esquema de Crank-Nicolson: (u_j^{n+1} - u_j^n)/Δt = (α/2Δx²) [ (u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}) + (u_{j+1}^n - 2u_j^n + u_{j-1}^n) ].",
                                    "Introduza o parâmetro r = α Δt / Δx² e reescreva o esquema em termos de r.",
                                    "Assuma solução de von Neumann: u_j^n = g^n e^{i θ j Δx}, onde θ é o número de onda.",
                                    "Substitua na equação para obter a relação de amplificação."
                                  ],
                                  "verification": "Confirme que o esquema está corretamente escrito e a forma assumida de von Neumann é aplicada, resultando em uma equação escalar para g.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: Burden & Faires), caderno de anotações, calculadora simbólica (Wolfram Alpha opcional).",
                                  "tips": "Use notação consistente para r; desenhe a stencil do método para visualização.",
                                  "learningObjective": "Compreender a discretização do Crank-Nicolson e setup para análise de estabilidade.",
                                  "commonMistakes": "Confundir o fator 1/2 com métodos explícito/implícito; esquecer a dependência em n e n+1 nos laplacianos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a relação de recorrência para o fator de amplificação g",
                                  "subSteps": [
                                    "Substitua u_j^n = g^n e^{i θ j} na stencil temporal n e n+1.",
                                    "Calcule o laplaciano discretizado: δ²u_j = (u_{j+1} - 2u_j + u_{j-1})/Δx² = - (4/Δx²) sin²(θ/2) u_j.",
                                    "Simplifique para obter: g^{n+1} - g^n = (r/2) [δ² g^{n+1} + δ² g^n ].",
                                    "Divida por g^n e isole g = g^{n+1}/g^n, resultando em: g - 1 = (r/2) [-4 sin²(θ/2)] (g + 1).",
                                    "Reorganize para a forma explícita de g."
                                  ],
                                  "verification": "Verifique que a equação para g é: g (1 + 2 r sin²(θ/2)) = 1 - 2 r sin²(θ/2).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado para stencil, software como MATLAB para testar substituição numérica.",
                                  "tips": "Trabalhe com β = 2 r sin²(θ/2) para simplificar; verifique com θ=0 (g=1).",
                                  "learningObjective": "Dominar a derivação da relação recorrente via análise de Fourier.",
                                  "commonMistakes": "Erro no sinal do laplaciano (deve ser negativo); não dividir corretamente por g^n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter a expressão explícita de G(θ)",
                                  "subSteps": [
                                    "Defina s = 2 r sin²(θ/2), então g = (1 - s)/(1 + s).",
                                    "Escreva G(θ) = [1 - 2 r sin²(θ/2)] / [1 + 2 r sin²(θ/2)].",
                                    "Teste casos limites: θ=0 → G=1; θ=π → G = (1-2r)/(1+2r).",
                                    "Confirme que G(θ) é uma função racional de θ e r.",
                                    "Compare qualitativamente com fatores de outros esquemas (ex: explícito G=1 - 2r sin²)."
                                  ],
                                  "verification": "Escreva G(θ) explicitamente e compute |G| para r=1, θ=π/2 (deve ser <1).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica (TI-89 ou app), tabela de valores de sin²(θ/2).",
                                  "tips": "Use identidade trigonométrica sin²(φ) = (1 - cos(2φ))/2 se necessário.",
                                  "learningObjective": "Derivar a fórmula fechada do fator de amplificação.",
                                  "commonMistakes": "Inverter numerador/denominador; esquecer o fator 2 em 2r sin²."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a estabilidade incondicional: |G(θ)| ≤ 1 ∀ θ, r > 0",
                                  "subSteps": [
                                    "Note que G(θ) = (1 - s)/(1 + s) com s = 2 r sin²(θ/2) ≥ 0.",
                                    "Mostre que |1 - s| ≤ 1 + s para s ≥ 0, pois (1 - s)^2 ≤ (1 + s)^2.",
                                    "Alternativamente, compute |G|^2 = [(1 - s)^2] / [(1 + s)^2] ≤ 1.",
                                    "Verifique igualdade em s=0 (|G|=1) e estrita para s>0.",
                                    "Conclua estabilidade incondicional independentemente de r."
                                  ],
                                  "verification": "Prove algebricamente |G(θ)| ≤ 1 e plote |G(θ)| vs θ para r=1,10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB: plot(abs(G)) ), provas escritas.",
                                  "tips": "Considere G como fração unitária no plano complexo; visualize no círculo unitário.",
                                  "learningObjective": "Demonstrar rigorosamente a propriedade de estabilidade.",
                                  "commonMistakes": "Assumir r fixo; não considerar s≥0; erro em |1-s| ≤1+s para s>1."
                                }
                              ],
                              "practicalExample": "Para r=1 e θ=π/2 (sin(θ/2)=sin(π/4)=√2/2, sin²=0.5, s=1), G=(1-1)/(1+1)=0. Como |0|≤1, modo é amortecido. Implemente em Python: def G(r, theta): s=2*r*(np.sin(theta/2))**2; return (1-s)/(1+s); plote abs(G(1, np.linspace(0,np.pi,100))).",
                              "finalVerifications": [
                                "Derivação correta de G(θ) = (1 - 2r sin²(θ/2)) / (1 + 2r sin²(θ/2)).",
                                "Prova algébrica de |G(θ)| ≤ 1 para todo θ ∈ [0,π] e r > 0.",
                                "Testes numéricos para pelo menos 3 valores de θ e 2 de r confirmam |G|≤1.",
                                "Comparação com esquema explícito mostra restrição CFL ausente.",
                                "Gráfico de |G(θ)| vs θ é parabólico decaente, máximo 1 em θ=0.",
                                "Explicação verbal da estabilidade incondicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação (fórmula exata de G(θ), 30%).",
                                "Correção da prova de |G|≤1 (rigor algébrico, 25%).",
                                "Uso correto de análise de von Neumann (setup e simplificações, 20%).",
                                "Exemplos numéricos e visualizações (plots, testes, 15%).",
                                "Comparação com outros esquemas e clareza na comunicação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação na equação de calor/difusão (transferência de calor).",
                                "Computação: Implementação de solvers implícitos em PDEs (MATLAB/Python).",
                                "Engenharia: Estabilidade em simulações CFD (dinâmica de fluidos).",
                                "Estatística: Análise de erros em métodos numéricos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações de difusão térmica em reatores nucleares ou previsão meteorológica, o Crank-Nicolson permite passos de tempo grandes sem instabilidade, economizando tempo computacional em malhas finas para modelar fluxos de calor em materiais compostos ou propagação de poluentes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Critério de von Neumann",
                        "description": "Critério necessário de estabilidade para esquemas lineares com coeficientes constantes: o fator de amplificação deve satisfazer |G(θ)| ≤ 1 + O(Δt) para todos os θ.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Aplicar o critério de von Neumann a equações parabólicas",
                            "description": "Verificar estabilidade do esquema FTCS para a equação de calor, obtendo a condição CFL r ≤ 1/2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de calor e o esquema FTCS",
                                  "subSteps": [
                                    "Escreva a equação de calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Discuta a discretização espacial centrada: δ²u_j = (u_{j+1} - 2u_j + u_{j-1})/Δx².",
                                    "Apresente o esquema FTCS: u^{n+1}_j = u^n_j + r (u^n_{j+1} - 2u^n_j + u^n_{j-1}), onde r = α Δt / Δx².",
                                    "Explique os papéis de Δt e Δx na estabilidade.",
                                    "Verifique consistência do esquema com a equação original."
                                  ],
                                  "verification": "Confirme que a fórmula do esquema FTCS está correta e r é definido adequadamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software como Jupyter Notebook; referência de livro de análise numérica (ex: LeVeque).",
                                  "tips": "Desenhe uma grade espacial-temporal para visualizar o stencil FTCS.",
                                  "learningObjective": "Entender a formulação discreta da equação parabólica via FTCS.",
                                  "commonMistakes": "Confundir r com α diretamente; esquecer a definição de r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o método de von Neumann para análise de estabilidade",
                                  "subSteps": [
                                    "Assuma solução de Fourier: u^n_j = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação.",
                                    "Substitua na equação do esquema FTCS para obter ξ = 1 - 4r sin²(θ/2), com θ = k Δx.",
                                    "Explique que estabilidade requer |ξ| ≤ 1 + O(Δt) para todos os k (modos de onda).",
                                    "Discuta o espectro de θ de 0 a π.",
                                    "Verifique neutralidade para θ=0 (ξ=1)."
                                  ],
                                  "verification": "Derive corretamente a expressão de ξ a partir da substituição Fourier.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou SymPy para manipulação simbólica; quadro branco.",
                                  "tips": "Use a identidade trigonométrica para simplificar sin²(θ/2).",
                                  "learningObjective": "Aplicar análise de Fourier para fator de amplificação em esquemas explícitos.",
                                  "commonMistakes": "Esquecer o expoente n em ξ^n; erro no sinal da derivada segunda discreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e plotar o fator de amplificação |G(θ)|",
                                  "subSteps": [
                                    "Defina G(θ) = |1 - 4r sin²(θ/2)|.",
                                    "Analise o comportamento: máximo de sin²=1, mínimo=0.",
                                    "Para estabilidade, exija 1 - 4r ≥ -1 e 1 ≤ 1 (sempre verdadeiro).",
                                    "Simplifique: -1 ≤ 1 - 4r ≤ 1 ⇒ r ≤ 1/2.",
                                    "Plote |G(θ)| para r=0.4 (estável) e r=0.6 (instável)."
                                  ],
                                  "verification": "Mostre que |G| ≤1 para r≤1/2 e identifique violação para r>1/2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/MATLAB com matplotlib para plotar G(θ); papel para análise analítica.",
                                  "tips": "O ponto crítico é θ=π, onde sin²(θ/2)=1.",
                                  "learningObjective": "Derivar a condição CFL específica para esquemas parabólicos.",
                                  "commonMistakes": "Ignorar o valor absoluto em |G|; confundir com condição hiperbólica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a condição CFL r ≤ 1/2",
                                  "subSteps": [
                                    "Confirme que r > 1/2 leva a amplificação exponencial de erros de alta frequência.",
                                    "Discuta relação com velocidade de difusão: Δx² / (2α Δt) ≥1.",
                                    "Teste numericamente com uma solução inicial e compare para r=0.4 vs 0.6.",
                                    "Explique implicações para escolha de Δt em simulações.",
                                    "Resuma o critério de von Neumann para esquemas parabólicos."
                                  ],
                                  "verification": "Implemente uma simulação simples e observe estabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python pronto para FTCS (1D heat equation).",
                                  "tips": "Use condições de contorno periódicas para von Neumann puro.",
                                  "learningObjective": "Interpretar e validar a condição de estabilidade na prática.",
                                  "commonMistakes": "Atribuir instabilidade só a erros de arredondamento; não testar numericamente."
                                }
                              ],
                              "practicalExample": "Considere α=1, Δx=0.1. Para r=0.4, Δt=0.004. Implemente FTCS para u_t = u_xx com u(x,0)=sin(πx), [0,1], e observe que a solução decai suavemente. Para r=0.6 (Δt=0.006), oscilações de alta frequência crescem.",
                              "finalVerifications": [
                                "Derivação correta de ξ(θ) = 1 - 4r sin²(θ/2).",
                                "Identificação do ponto crítico θ=π com |ξ|=|1-4r|.",
                                "Conclusão precisa: r ≤ 1/2 para |ξ|≤1 ∀θ.",
                                "Plot ou tabela mostrando |G(θ)|≤1 para r≤1/2.",
                                "Explicação verbal da condição CFL.",
                                "Teste numérico confirmando estabilidade/instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator de amplificação (100% simbólico correto).",
                                "Análise completa do domínio θ ∈ [0,π] e identificação de máximo.",
                                "Correta obtenção e justificativa de r ≤ 1/2.",
                                "Interpretação física da condição (relação Δt-Δx).",
                                "Uso adequado de plot/simulação para validação.",
                                "Clareza na explicação de erros comuns em von Neumann."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de estabilidade em PDEs.",
                                "Computação: Implementação de solvers numéricos e análise de erros de truncamento.",
                                "Engenharia: Simulações em transferência de calor e CFD.",
                                "Estatística: Análise espectral e controle de variância em simulações."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes ou em engenharia aeroespacial para modelar dissipação de calor em painéis solares, garantindo que o timestep não cause instabilidade numérica, evitando previsões errôneas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Analisar estabilidade em equações hiperbólicas",
                            "description": "Para a equação de advecção u_t + a u_x = 0, calcular G(θ) no esquema upwind e determinar |G(θ)| ≤ 1 sob condição CFL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação de advecção e o esquema upwind",
                                  "subSteps": [
                                    "Escreva a equação de advecção: u_t + a u_x = 0, assumindo a > 0.",
                                    "Defina o esquema upwind explícito: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), onde λ = a Δt / Δx.",
                                    "Identifique os parâmetros: Δt (passo temporal), Δx (passo espacial), λ (número de Courant).",
                                    "Explique verbalmente por que o upwind é adequado para a > 0.",
                                    "Desenhe um diagrama de grade espacial-temporal destacando os stencil usado."
                                  ],
                                  "verification": "Escreva corretamente a equação e o esquema upwind em um papel ou editor, confirmando com referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX/Mathematica",
                                    "Livro de análise numérica (ex: LeVeque)"
                                  ],
                                  "tips": "Lembre-se: upwind usa valor upstream para evitar oscilações.",
                                  "learningObjective": "Dominar a formulação discreta da equação hiperbólica via upwind.",
                                  "commonMistakes": "Confundir upwind com central difference; usar u_{j+1} em vez de u_{j-1} para a>0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o método de von Neumann para análise de estabilidade",
                                  "subSteps": [
                                    "Assuma solução de Fourier: u_j^n = g^n e^{i θ j Δx}, onde θ é o número de onda.",
                                    "Substitua na equação discreta para obter g = G(θ).",
                                    "Derive a relação de amplificação: G(θ) = 1 - λ (1 - e^{-i θ Δx}).",
                                    "Simplifique usando identidades trigonométricas: |G(θ)|^2 = [1 - λ (1 - cos(θ Δx))]^2 + [λ sin(θ Δx)]^2.",
                                    "Verifique a forma complexa de G(θ)."
                                  ],
                                  "verification": "Obtenha a expressão exata de G(θ); compare com fórmula padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Mathematica/SymPy)",
                                    "Folha de derivadas trigonométricas"
                                  ],
                                  "tips": "Use Euler: e^{iφ} = cos φ + i sin φ para expandir.",
                                  "learningObjective": "Executar análise de von Neumann em esquemas lineares.",
                                  "commonMistakes": "Esquecer o expoente n em g^n; erro no sinal do termo imaginário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o módulo |G(θ)| e analisar sua magnitude",
                                  "subSteps": [
                                    "Compute |G(θ)|^2 explicitamente: 1 - 2λ(1-cosφ) + 2λ^2(1-cosφ), onde φ = θ Δx.",
                                    "Simplifique para |G(θ)| = |1 - λ + λ cosφ - i λ sinφ|.",
                                    "Encontre o máximo de |G(θ)| sobre θ ∈ [0, 2π].",
                                    "Mostre que max |G(θ)| = max( |1-λ|, 1 ) para λ ≤1.",
                                    "Plote |G(θ)| vs θ para λ=0.5 e λ=1.2 usando software."
                                  ],
                                  "verification": "Confirme que |G(θ)| ≤1 para todo θ quando λ ≤1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib/Python ou MATLAB)",
                                    "Gráficos de referência"
                                  ],
                                  "tips": "O pior caso é θ=π (modo mais oscilante).",
                                  "learningObjective": "Determinar o símbolo de amplificação e seu envelope.",
                                  "commonMistakes": "Erro na simplificação de |G|^2; ignorar θ=0 ou θ=π."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e verificar a condição CFL para estabilidade",
                                  "subSteps": [
                                    "Estabeleça |G(θ)| ≤1 ∀θ iff 0 ≤ λ ≤1.",
                                    "Interprete CFL: λ = a Δt / Δx ≤1, ou Δt ≤ Δx / a.",
                                    "Teste numericamente: simule com λ=0.9 (estável) vs λ=1.1 (instável).",
                                    "Discuta generalização para esquemas multi-D ou não-lineares.",
                                    "Resuma em um quadro: equação → esquema → G(θ) → CFL."
                                  ],
                                  "verification": "Simulação numérica converge sem blow-up para λ≤1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para simulação 1D advection",
                                    "Gerador de soluções exatas"
                                  ],
                                  "tips": "Use condições iniciais suaves como gaussian para testar.",
                                  "learningObjective": "Conectar análise espectral à condição CFL prática.",
                                  "commonMistakes": "Confundir λ≤1 com λ<1; não testar numericamente."
                                }
                              ],
                              "practicalExample": "Para a=1, Δx=0.1, Δt=0.09 (λ=0.9): calcule G(π/Δx)=1-λ(1-(-1))=1-1.8(-1)? Não: siga passos para G(θ=π/Δx)=1-λ(1-e^{-iπ})=1-λ(1-(-1))=1-2λ=-0.8, |G|=0.8<1. Simule 100 passos: solução propaga sem amplificação.",
                              "finalVerifications": [
                                "G(θ) calculado corretamente para qualquer θ dado.",
                                "Prova que |G(θ)| ≤1 iff 0<λ≤1.",
                                "Simulação numérica confirma estabilidade para λ=0.9 e instabilidade para λ=1.1.",
                                "Explicação verbal da CFL em termos físicos (velocidade da informação).",
                                "Gráfico de |G(θ)| mostra envelope ≤1.",
                                "Generalização para a<0 (upwind reverso)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de G(θ) (100% correto).",
                                "Correta identificação da condição λ ≤1.",
                                "Qualidade do plot/simulação (sem erros numéricos).",
                                "Profundidade na análise de erros comuns e dicas.",
                                "Clareza na conexão com CFL física.",
                                "Completude de todos substeps (mínimo 80%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas acústicas ou fluxo de tráfego (equações hiperbólicas).",
                                "Computação: Implementação de solvers CFD em Python/OpenFOAM.",
                                "Engenharia: Estabilidade em simulações de reservatórios petrolíferos.",
                                "Estatística: Análise espectral em séries temporais."
                              ],
                              "realWorldApplication": "Em modelagem climática, garante que simulações de advecção de poluentes (ex: fumaça vulcânica) não explodam numericamente, permitindo previsões confiáveis de dispersão atmosférica sob condição CFL para precisão temporal."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Identificar esquemas estáveis e instáveis via von Neumann",
                            "description": "Classificar métodos explícitos e implícitos para equações elípticas e hiperbólicas usando o critério, considerando condições de Dirichlet e Neumann.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Critério de von Neumann",
                                  "subSteps": [
                                    "Estudar a definição do critério de von Neumann para estabilidade de esquemas de diferenças finitas em problemas de evolução.",
                                    "Analisar as hipóteses principais: condições de contorno periódicas e solução de Fourier única.",
                                    "Entender o conceito de fator de amplificação g(θ), onde θ é o número de onda.",
                                    "Explicar a condição de estabilidade: |g(θ)| ≤ 1 para todo θ ∈ [0, 2π].",
                                    "Diferenciar entre esquemas para equações parabólicas e hiperbólicas."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando o critério e suas condições necessárias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Aulas gravadas sobre estabilidade",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use expansões de Fourier para visualizar modos de alta e baixa frequência.",
                                  "learningObjective": "Dominar a teoria básica e as hipóteses do critério de von Neumann.",
                                  "commonMistakes": "Ignorar a dependência em θ ou confundir com estabilidade von Neumann vs. Lax."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Analisar Fator de Amplificação para Esquemas Explícitos",
                                  "subSteps": [
                                    "Derivar o fator g(θ) para o esquema FTCS (Forward Time Centered Space) na equação do calor u_t = α u_xx.",
                                    "Calcular g(θ) = 1 - 4r sin²(θ/2), onde r = α Δt / Δx².",
                                    "Verificar estabilidade: |g(θ)| ≤ 1 implica r ≤ 1/2.",
                                    "Aplicar a condições de Dirichlet (fixas) e notar limitações para Neumann (derivadas).",
                                    "Testar numericamente com θ = π (modo mais instável)."
                                  ],
                                  "verification": "Resolver um problema simples e plotar |g(θ)| vs. θ para diferentes r.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy/Matplotlib)",
                                    "Folhas de derivação",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Sempre normalize Δx=1 para simplificar cálculos iniciais.",
                                  "learningObjective": "Calcular e interpretar g(θ) para métodos explícitos em equações elípticas/hiperbólicas.",
                                  "commonMistakes": "Esquecer o fator sin²(θ/2) ou testar apenas θ=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Esquemas Implícitos e Semi-Implícitos",
                                  "subSteps": [
                                    "Derivar g(θ) para esquema BTCS (Backward Time Centered Space): g(θ) = 1 / (1 + 4r sin²(θ/2)).",
                                    "Verificar incondicionalmente estável: |g(θ)| < 1 para r > 0.",
                                    "Comparar com Crank-Nicolson: g(θ) = (1 - 2r sin²(θ/2)) / (1 + 2r sin²(θ/2)).",
                                    "Discutir impacto de condições de Neumann em esquemas implícitos.",
                                    "Classificar estabilidade para equações hiperbólicas como onda u_tt = c² u_xx."
                                  ],
                                  "verification": "Comparar gráficos de |g(θ)| para explícito vs. implícito e concluir sobre estabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Tabela de esquemas comuns",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Resolva o denominador algebricamente para evitar erros numéricos.",
                                  "learningObjective": "Distinguir estabilidade condicional vs. incondicional em métodos implícitos.",
                                  "commonMistakes": "Confundir sinal no numerador/denominador ou ignorar equações hiperbólicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar Esquemas e Considerar Condições de Contorno",
                                  "subSteps": [
                                    "Listar esquemas instáveis: FTCS para r > 1/2, Lax-Friedrichs inadequado para hiperbólicas.",
                                    "Classificar para elípticas (Poisson): notar que von Neumann é limitado, usar para aproximações evolutivas.",
                                    "Analisar efeito de Dirichlet (u=0 nas bordas) vs. Neumann (u_x=0): periodicidade ideal para von Neumann.",
                                    "Realizar análise completa para um esquema híbrido em hiperbólica.",
                                    "Compilar tabela de esquemas estáveis/instáveis."
                                  ],
                                  "verification": "Criar tabela com 5 esquemas, classificando estabilidade e condições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Referências acadêmicas (artigos sobre CFD)",
                                    "Caderno de exercícios"
                                  ],
                                  "tips": "Use θ discretos (ex: 0, π/4, π/2, π) para amostragem eficiente.",
                                  "learningObjective": "Identificar e classificar esquemas estáveis/instáveis considerando tipos de PDE e BCs.",
                                  "commonMistakes": "Aplicar von Neumann diretamente a elípticas sem adaptação."
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = u_xx com esquema explícito FTCS: g(θ) = 1 - 4r sin²(θ/2). Se r=0.6, |g(π)| = |1-2.4| = 1.4 >1 → instável. Com r=0.4, max |g|=0.84 <1 → estável. Simule em Python para visualizar oscilações em instável.",
                              "finalVerifications": [
                                "Calcular corretamente g(θ) para FTCS e BTCS em 3 valores de θ.",
                                "Classificar 4 esquemas como estáveis ou instáveis com justificativa.",
                                "Explicar impacto de condições Dirichlet/Neumann na análise.",
                                "Identificar modo instável (alta frequência) em gráfico de |g(θ)|.",
                                "Aplicar critério a uma equação hiperbólica simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de g(θ): 90% correto.",
                                "Classificação correta de estabilidade: sem erros em exemplos padrão.",
                                "Interpretação qualitativa de |g(θ)| >1.",
                                "Consideração adequada de tipos de PDE e BCs.",
                                "Uso correto de ferramentas numéricas para verificação.",
                                "Clareza na tabela ou relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de difusão e ondas.",
                                "Engenharia: Análise de estabilidade em CFD (dinâmica de fluidos).",
                                "Ciência da Computação: Otimização de algoritmos numéricos.",
                                "Processamento de Sinais: Análise de Fourier em dados discretos."
                              ],
                              "realWorldApplication": "Em modelagem climática para prever difusão de poluentes (estável requer r≤1/2), simulações sísmicas de ondas hiperbólicas em prospecção de petróleo, ou controle de qualidade em engenharia aeroespacial para evitar instabilidades numéricas em solvers de PDEs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.4",
                            "name": "Relacionar estabilidade com dissipação e dispersão",
                            "description": "Examinar o papel real e imaginário de G(θ) para quantificar dissipação (|G|<1) e dispersão (fase de arg(G)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Critério de von Neumann e o Símbolo de Amplificação G(θ)",
                                  "subSteps": [
                                    "Relembrar a formulação do problema modelo: equação de onda ou calor discreta u^{n+1}_j = ...",
                                    "Derivar ou recordar a expressão de G(θ) via análise de Fourier: G(θ) = amplificação para modo e^{i θ j}.",
                                    "Entender que estabilidade requer |G(θ)| ≤ 1 para todo θ ∈ [0, 2π].",
                                    "Discutir condições necessárias: |G(θ)| < 1 implica dissipação, |G(θ)| = 1 implica neutralidade.",
                                    "Plotar |G(θ)| esquematicamente para visualizar regiões de instabilidade."
                                  ],
                                  "verification": "Capacidade de derivar G(θ) para um esquema simples (ex: forward Euler) e verificar |G(θ)| ≤ 1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), caderno, calculadora ou Python/MATLAB para Fourier.",
                                  "tips": "Comece com o problema de advecção simples para intuíção visual.",
                                  "learningObjective": "Compreender a base analítica do critério de von Neumann.",
                                  "commonMistakes": "Confundir G(θ) com o fator de amplificação local; ignorar periodicidade em θ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Dissipação via |G(θ)|",
                                  "subSteps": [
                                    "Definir dissipação: |G(θ)| < 1 para θ ≠ 0, quantificando atenuação de modos de alta frequência.",
                                    "Calcular |G(θ)|^2 explicitamente para esquemas lineares (ex: Lax-Friedrichs).",
                                    "Interpretar: |G(θ)| < 1 amortece erros numéricos, essencial para esquemas viscosos.",
                                    "Comparar com esquemas não dissipativos (|G| = 1), como leapfrog.",
                                    "Exercitar: Plotar |G(θ)| e identificar região dissipativa."
                                  ],
                                  "verification": "Computar |G(θ)| para um esquema dado e discutir seu papel na estabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de plotagem (Python com NumPy/Matplotlib), exemplos de esquemas numéricos.",
                                  "tips": "Use identidade trigonométrica para simplificar |G(θ)|^2 sem seno/cosseno complexos.",
                                  "learningObjective": "Quantificar e interpretar dissipação como mecanismo de estabilidade.",
                                  "commonMistakes": "Achar que |G| < 1 sempre é bom; esquemas upwind podem ser excessivamente dissipativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Dispersão via arg(G(θ))",
                                  "subSteps": [
                                    "Definir dispersão: arg(G(θ)) ≠ c θ, onde c é velocidade de fase exata, causando distorção de onda.",
                                    "Calcular fase φ(θ) = arg(G(θ)) e velocidade de fase numérica φ(θ)/θ.",
                                    "Interpretar: Desvio de linearidade em φ(θ) leva a dispersão de pacotes de onda.",
                                    "Comparar com dispersão física (ex: equação de Schrödinger).",
                                    "Exercitar: Plotar φ(θ)/θ vs θ e identificar anomalias de fase."
                                  ],
                                  "verification": "Derivar arg(G(θ)) para um esquema e analisar desvio da dispersão exata.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Mesmos do step 2, mais referências sobre análise de fase (ex: artigos de Kreiss).",
                                  "tips": "Use atan2 para arg em código; foque em θ pequeno para aproximação.",
                                  "learningObjective": "Entender dispersão como erro de fase e sua relação com estabilidade.",
                                  "commonMistakes": "Confundir arg(G) com |G|; ignorar que dispersão ocorre mesmo se |G|=1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Dissipação, Dispersão e Estabilidade Geral",
                                  "subSteps": [
                                    "Integrar: Estabilidade von Neumann requer controle conjunto de |G| e arg(G).",
                                    "Discutir trade-offs: Mais dissipação reduz oscilações, mas aumenta dispersão.",
                                    "Analisar G(θ) complexo: Locus de G(θ) no plano complexo deve estar dentro do círculo unitário.",
                                    "Exemplificar com esquemas instáveis (ex: FTCS para advecção).",
                                    "Concluir: Dissipação controla amplitude, dispersão controla fase."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como falha em dissipação/dispersão causa instabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Gráficos de locus G(θ), resumo de esquemas clássicos.",
                                  "tips": "Desenhe o diagrama de Nyquist para G(θ) para visualização intuitiva.",
                                  "learningObjective": "Sintetizar dissipação e dispersão como pilares da estabilidade.",
                                  "commonMistakes": "Reduzir estabilidade só a |G|≤1, ignorando condições de fase para CFL."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Exemplo Prático e Verificar",
                                  "subSteps": [
                                    "Escolher esquema: ex: Lax-Wendroff para equação de advecção.",
                                    "Computar G(θ) analiticamente e numericamente.",
                                    "Analisar |G(θ)| e arg(G(θ)) para diferentes CFL.",
                                    "Simular numericamente e comparar com análise.",
                                    "Ajustar parâmetros para otimizar dissipação/dispersão."
                                  ],
                                  "verification": "Relatório curto com plots e conclusões sobre estabilidade.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código Python/MATLAB para simulação 1D, dados de onda inicial.",
                                  "tips": "Use modo senoidal único para isolar θ específico.",
                                  "learningObjective": "Aplicar conceitos para diagnosticar estabilidade em prática.",
                                  "commonMistakes": "Erro numérico em simulação mascarando análise teórica."
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Wendroff na equação de advecção u_t + a u_x = 0: G(θ) = 1 - (ν^2/2)(1 - cosθ) + i ν sinθ, onde ν = a Δt/Δx. Calcule |G(θ)| <1 para ν<1 (dissipação numérica) e arg(G(θ))/θ ≈1 com erro O(θ^2) (dispersão de ordem 2). Simule uma onda gaussiana e observe atenuação e distorção de fase.",
                              "finalVerifications": [
                                "Deriva G(θ) corretamente para esquema dado.",
                                "Identifica regiões onde |G(θ)| >1 (instável).",
                                "Calcula e plota velocidade de fase numérica.",
                                "Explica trade-off dissipação vs precisão.",
                                "Diagnostica instabilidade em simulação via análise von Neumann.",
                                "Relaciona locus G(θ) à estabilidade de Lax."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de |G(θ)| e arg(G(θ)) (80% correto).",
                                "Interpretação qualitativa de dissipação/dispersão.",
                                "Qualidade de plots e análise visual.",
                                "Correta identificação de condições de estabilidade.",
                                "Aplicação em exemplo não trivial.",
                                "Clareza na síntese conceitual."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em meios dispersivos/dissipativos.",
                                "Engenharia: Estabilidade em CFD (dinâmica de fluidos computacional).",
                                "Computação: Otimização de algoritmos numéricos em HPC.",
                                "Física Computacional: Simulações de plasma ou acústica."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM), controle de dissipação/dispersão previne amplificação de ruído em escalas pequenas, garantindo previsões estáveis em grids globais; em finanças, evita blow-up em esquemas para equações diferenciais estocásticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Convergência e Estabilidade para Equações Parabólicas",
                    "description": "Esquemas para equações de difusão e métodos ADI.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Convergência de Esquemas para Equações Parabólicas",
                        "description": "Conceitos fundamentais de convergência em métodos de diferenças finitas aplicados a equações de difusão, incluindo teoremas de consistência e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Definir consistência e ordem de truncagem local",
                            "description": "Explicar a definição de consistência para esquemas de diferenças finitas em equações parabólicas como a equação de calor, calcular o erro de truncagem local para esquemas FTCS e BTCS, e determinar a ordem de consistência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Consistência em Esquemas Numéricos",
                                  "subSteps": [
                                    "Revise a equação de calor parabólica: ∂u/∂t = α ∂²u/∂x².",
                                    "Explique o que é truncagem local: erro introduzido pela aproximação discreta em um ponto e tempo específico.",
                                    "Defina consistência: lim_{h→0, τ→0} (erro de truncagem local / τ) = 0, onde h é passo espacial e τ é passo temporal.",
                                    "Discuta a relação entre consistência, estabilidade e convergência pelo teorema de Lax.",
                                    "Identifique os esquemas FTCS (Forward Time Central Space) e BTCS (Backward Time Central Space)."
                                  ],
                                  "verification": "Escreva a definição formal de consistência e identifique os componentes do LTE para a equação de calor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para anotações",
                                    "Acesso a notas de aula sobre equações parabólicas"
                                  ],
                                  "tips": "Use expansões de Taylor para visualizar como as diferenças finitas aproximam derivadas.",
                                  "learningObjective": "Compreender a definição precisa de consistência e sua importância para esquemas de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir truncagem local com truncagem global",
                                    "Ignorar a normalização pelo passo temporal τ na definição de consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Erro de Truncagem Local para o Esquema FTCS",
                                  "subSteps": [
                                    "Escreva a discretização FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α τ / h².",
                                    "Aplique expansões de Taylor em torno de (x_j, t_n) para u_j^{n+1}, u_{j+1}^n, u_{j-1}^n e u_j^n.",
                                    "Some os termos das expansões e identifique os termos que correspondem a ∂u/∂t e α ∂²u/∂x².",
                                    "Calcule o LTE: τ [∂u/∂t - α ∂²u/∂x²] + (τ²/2) ∂²u/∂t² + O(τ³, h⁴).",
                                    "Simplifique para mostrar LTE = O(τ) + O(h²)."
                                  ],
                                  "verification": "Derive explicitamente o LTE para FTCS e confirme que é O(τ + h²).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: Mathematica ou SymPy em Python)",
                                    "Papel quadriculado para expansões de Taylor"
                                  ],
                                  "tips": "Mantenha os termos até ordem 2 em τ e 4 em h para clareza.",
                                  "learningObjective": "Calcular e interpretar o erro de truncagem local específico para o esquema FTCS.",
                                  "commonMistakes": [
                                    "Esquecer o fator τ na aproximação temporal forward",
                                    "Parar as expansões de Taylor prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Erro de Truncagem Local para o Esquema BTCS",
                                  "subSteps": [
                                    "Escreva a discretização BTCS: u_j^{n+1} - u_j^n = r (u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}).",
                                    "Aplique expansões de Taylor em torno de (x_j, t_{n+1}) para os termos em n+1 e ajuste para t_n.",
                                    "Identifique os termos principais e calcule LTE: τ [∂u/∂t - α ∂²u/∂x²] - (τ²/2) ∂²u/∂t² + O(τ³, h⁴).",
                                    "Mostre que LTE = O(τ) + O(h²), similar ao FTCS mas com sinal oposto no termo temporal.",
                                    "Compare as diferenças com FTCS em termos de precisão."
                                  ],
                                  "verification": "Derive o LTE para BTCS e verifique a similaridade de ordem com FTCS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de álgebra computacional",
                                    "Tabela de expansões de Taylor pré-computadas"
                                  ],
                                  "tips": "Expanda em torno de t_{n+1} para capturar o backward difference corretamente.",
                                  "learningObjective": "Dominar a derivação do LTE para esquemas implícitos como BTCS.",
                                  "commonMistakes": [
                                    "Expandir todos os termos em torno de t_n em vez de t_{n+1}",
                                    "Confundir os sinais nos termos de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a Ordem de Consistência e Verificar Condições",
                                  "subSteps": [
                                    "Defina ordem de consistência: ordem p se LTE = O(τ^p + h^q) com p,q ≥1.",
                                    "Para FTCS e BTCS, conclua ordem 1 em tempo (p=1) e 2 em espaço (q=2).",
                                    "Verifique consistência: divida LTE por τ → 0 quando τ,h→0.",
                                    "Discuta implicações para convergência (necessita estabilidade).",
                                    "Resuma em uma tabela comparativa de LTE e ordens."
                                  ],
                                  "verification": "Crie uma tabela resumindo definições, LTEs e ordens para FTCS e BTCS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou LaTeX para tabela",
                                    "Notas dos passos anteriores"
                                  ],
                                  "tips": "Sempre normalize pelo passo dominante (τ) na verificação de consistência.",
                                  "learningObjective": "Avaliar quantitativamente a ordem de consistência de esquemas numéricos.",
                                  "commonMistakes": [
                                    "Afirmar ordem 2 sem especificar tempo/espaço",
                                    "Ignorar que consistência requer ambos h,τ→0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx em [0,1]x[0,1] com u(0,t)=u(1,t)=0 e u(x,0)=sin(πx), discretize com h=0.1, τ=0.001 usando FTCS. Calcule LTE analiticamente no ponto (0.5,0.5) e numéricamente comparando com solução exata u(x,t)=sin(πx)exp(-π²t), confirmando O(τ + h²) ≈ 10^{-3} + 10^{-2}.",
                              "finalVerifications": [
                                "Definição correta de consistência para esquemas de diferenças finitas.",
                                "LTE derivado precisamente para FTCS com termos O(τ) e O(h²).",
                                "LTE derivado para BTCS mostrando similaridade de ordem.",
                                "Ordem de consistência identificada como (1,2) para ambos esquemas.",
                                "Verificação de que o esquema é consistente quando h,τ→0.",
                                "Tabela comparativa clara entre FTCS e BTCS."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas expansões de Taylor (sem erros algébricos).",
                                "Correta identificação e interpretação dos termos de LTE.",
                                "Clareza na definição formal de consistência e ordem.",
                                "Uso apropriado de notação (h, τ, r=ατ/h²).",
                                "Capacidade de comparar esquemas e discutir implicações.",
                                "Exemplo prático com cálculos numéricos coerentes.",
                                "Ausência de confusão entre truncagem local e estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e propagação de ondas.",
                                "Computação: Implementação em Python/MATLAB para validação numérica.",
                                "Engenharia: Simulações em CFD (Computational Fluid Dynamics).",
                                "Estatística: Análise de erros em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em engenharia térmica, esquemas consistentes como FTCS/BTCS são usados para simular distribuição de calor em painéis solares ou CPUs, garantindo precisão em previsões de temperatura para design eficiente e prevenção de superaquecimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Enunciar o Teorema de Lax",
                            "description": "Enunciar o Teorema de Lax sobre convergência de esquemas para EDP, provar sua validade para esquemas lineares bem-posicionados e aplicar a esquemas parabólicos para verificar condições de convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Convergência em Esquemas Numéricos",
                                  "subSteps": [
                                    "Defina consistência: um esquema é consistente se a solução numérica aproxima a solução exata da EDP à medida que o passo de malha tende a zero.",
                                    "Explique estabilidade: o esquema é estável se erros de arredondamento e truncamento não amplificam indefinidamente.",
                                    "Discuta convergência: o erro global entre solução numérica e exata tende a zero.",
                                    "Revise esquemas lineares bem-posicionados: operadores lineares que geram semigrupos.",
                                    "Estude normas usadas em espaços de Banach para EDP parabólicas."
                                  ],
                                  "verification": "Resuma os três pilares (consistência, estabilidade, convergência) em um parágrafo coerente sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque 'Finite Difference Methods'), notas de aula, quadro branco.",
                                  "tips": "Use analogias como 'consistência é precisão local, estabilidade é controle de ruído, convergência é precisão global'.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para o Teorema de Lax.",
                                  "commonMistakes": "Confundir consistência (local) com convergência (global); ignorar o papel da linearidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar Precisamente o Teorema de Lax",
                                  "subSteps": [
                                    "Estude o enunciado: Para esquemas lineares bem-posicionados aproximando EDP lineares, consistência + estabilidade implica convergência.",
                                    "Identifique condições: EDP em forma semidiscretizada, operadores lineares gerando grupos/semigrupos.",
                                    "Escreva o teorema formalmente: Se A_h consistente com A e estável, então ||u_h(t) - u(t)|| → 0.",
                                    "Discuta limitações: Não se aplica diretamente a esquemas não-lineares.",
                                    "Memorize prova qualitativa: decomposição em erro de aproximação e propagação de erro."
                                  ],
                                  "verification": "Enuncie o teorema verbalmente ou por escrito para um colega, cobrindo todas as hipóteses.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo original de Lax (1962) ou resumo em Evans 'PDE', flashcards para memorização.",
                                  "tips": "Grave-se enunciando e compare com fontes confiáveis para refinar precisão.",
                                  "learningObjective": "Dominar o enunciado exato e suas hipóteses.",
                                  "commonMistakes": "Omitir 'bem-posicionado' ou confundir com teorema de Lax-Milgram."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar o Teorema para Esquemas Lineares Bem-Posicionados",
                                  "subSteps": [
                                    "Decomponha o erro: e(t) = u(t) - u_h(t) = erro de consistência + erro de estabilidade.",
                                    "Mostre ||A_h - A|| → 0 para consistência.",
                                    "Use estabilidade: ||e(t)|| ≤ ∫ ||A_h - A|| ds + inicial.",
                                    "Aplique teorema de Trotter-Kato para semigrupos.",
                                    "Conclua limite zero pela arbitrariedade do h."
                                  ],
                                  "verification": "Escreva a prova passo a passo e verifique se cada desigualdade segue logicamente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Quadro ou papel para derivações, livro de Gustafsson et al. 'Time Dependent Problems'.",
                                  "tips": "Desenhe diagramas de erro para visualizar decomposição.",
                                  "learningObjective": "Reproduzir a prova essencial do teorema.",
                                  "commonMistakes": "Pular estimativas de norma; não justificar continuidade de semigrupos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema a Esquemas Parabólicos",
                                  "subSteps": [
                                    "Considere equação de calor u_t = u_xx; discretize com diferenças finitas.",
                                    "Verifique consistência: ordem de truncamento O(Δt + Δx²).",
                                    "Analise estabilidade via amplificação de Fourier (ex: explícito θ=0 instável).",
                                    "Aplique Lax: para θ ≥ 1/2 (Crank-Nicolson), convergência garantida.",
                                    "Teste numericamente com código simples em Python/MATLAB."
                                  ],
                                  "verification": "Para um esquema parabólico dado, classifique convergência via Lax e simule erro vs. h.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python com NumPy/SciPy, exemplos de código de esquemas IMEX.",
                                  "tips": "Comece com 1D para simplicidade antes de 2D.",
                                  "learningObjective": "Aplicar o teorema para verificar convergência prática.",
                                  "commonMistakes": "Ignorar condição CFL em esquemas hiperbólicos; confundir parabólicos com hiperbólicos."
                                }
                              ],
                              "practicalExample": "Para o esquema θ de Douglas para u_t = u_xx, com θ=0.5 (Crank-Nicolson): verifique consistência O(Δt² + Δx²), estabilidade von Neumann (ξ ≤1), logo convergência pelo Lax. Simule em [0,1]x[0,1] com u0=sen(πx), compare com solução exata.",
                              "finalVerifications": [
                                "Enuncie o teorema sem erros, incluindo hipóteses.",
                                "Esboce a prova em 5 passos principais.",
                                "Aplique corretamente a um esquema parabólico exemplo.",
                                "Identifique quando o teorema não se aplica (ex: não-linear).",
                                "Explique relação com estabilidade von Neumann.",
                                "Simule numericamente e observe convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado (100% das hipóteses corretas).",
                                "Correção lógica na prova (todas desigualdades justificadas).",
                                "Aplicação prática válida a esquemas parabólicos.",
                                "Uso correto de normas e semigrupos.",
                                "Identificação de contraexemplos (ex: esquema consistente mas instável).",
                                "Clareza na simulação numérica e análise de erro."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de estabilidade em simulações CFD.",
                                "Computação: Implementação de solvers numéricos em bibliotecas como FEniCS ou PETSc.",
                                "Engenharia: Verificação de convergência em simulações finitas para estruturas.",
                                "Estatística: Análise de erro numérico em métodos Monte Carlo para EDP."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (previsão de tempo via modelos parabólicos de difusão), o Teorema de Lax garante que ajustes em malha/ tempo levem a previsões precisas, evitando instabilidades que causam 'explosões numéricas' em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Analisar convergência de esquemas explícito e implícito",
                            "description": "Demonstrar a convergência de ordem 2 no espaço e 1 no tempo para o esquema Crank-Nicolson na equação de difusão unidimensional, comparando com esquemas explícitos condicionalmente convergentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação de Difusão Unidimensional e Discretização Espacial",
                                  "subSteps": [
                                    "Estude a equação de difusão: ∂u/∂t = α ∂²u/∂x², com condições de contorno e inicial.",
                                    "Defina a malha uniforme: x_i = i h, t_n = n k, com h = Δx, k = Δt.",
                                    "Aproxime a derivada espacial segunda usando diferenças finitas centradas: δ²u_i^n / h² ≈ ∂²u/∂x².",
                                    "Discuta truncagem local do erro para a aproximação espacial (ordem O(h²)).",
                                    "Verifique consistência da discretização espacial com a equação contínua."
                                  ],
                                  "verification": "Derive manualmente o erro de truncagem local e confirme ordem O(h²).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis ou software como Mathematica/MATLAB para simulações iniciais"
                                  ],
                                  "tips": "Comece com α=1 para simplicidade; visualize a malha em um gráfico 1D.",
                                  "learningObjective": "Compreender a base da discretização para equações parabólicas.",
                                  "commonMistakes": [
                                    "Confundir derivada temporal com espacial",
                                    "Esquecer condições de contorno Dirichlet/Neumann"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Esquema Explícito e sua Convergência Condicional",
                                  "subSteps": [
                                    "Formule o esquema explícito: u_i^{n+1} = u_i^n + r (u_{i-1}^n - 2u_i^n + u_{i+1}^n), onde r = α k / h².",
                                    "Calcule o erro de truncagem local: mostre ordem O(k + h²).",
                                    "Discuta a condição CFL: r ≤ 1/2 para estabilidade.",
                                    "Demonstre numericamente a convergência reduzindo h e k, mantendo r fixo.",
                                    "Compare erro global com solução exata (ex: u(x,t) = exp(-π² α t) sin(π x))."
                                  ],
                                  "verification": "Implemente em código e plote log(erros) vs log(h/k); inclinação confirma ordem.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB com NumPy/SciPy",
                                    "Solução analítica da equação de difusão"
                                  ],
                                  "tips": "Use r=0.4 para evitar instabilidade; refine malha uniformemente.",
                                  "learningObjective": "Identificar limitações de convergência condicional do explícito.",
                                  "commonMistakes": [
                                    "Violar CFL levando a oscilações",
                                    "Não normalizar erros adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Analisar o Esquema Crank-Nicolson",
                                  "subSteps": [
                                    "Formule Crank-Nicolson: média temporal de diferenças centradas: -r/2 u_{i-1}^{n+1} + (1+r) u_i^{n+1} - r/2 u_{i+1}^{n+1} = r/2 u_{i-1}^n + (1-r) u_i^n + r/2 u_{i+1}^n.",
                                    "Calcule erro de truncagem: mostre ordem O(k² + h²), mas convergência global O(k + h²).",
                                    "Prove consistência incondicional e estabilidade via von Neumann.",
                                    "Resolva o sistema tridiagonal implicitamente (algoritmo Thomas).",
                                    "Compare estabilidade com explícito para r > 1/2."
                                  ],
                                  "verification": "Derive erro de truncagem passo a passo e verifique linearidade do sistema.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código MATLAB/Python para solver tridiagonal",
                                    "Notas de aula sobre Crank-Nicolson"
                                  ],
                                  "tips": "Implemente solver tridiagonal eficiente; teste com malhas grosseiras primeiro.",
                                  "learningObjective": "Dominar a formulação implícita de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir ordem local vs global",
                                    "Erro na matriz tridiagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Convergência e Demonstrar Numericamente",
                                  "subSteps": [
                                    "Implemente ambos esquemas para problema teste (ex: barra com gradiente inicial).",
                                    "Compute erros L2 vs solução exata para h=1/10,1/20,... e k=h²/α.",
                                    "Plote taxas de convergência: explícito O(k+h²) condicional, CN O(k+h²) incondicional.",
                                    "Analise impacto de r grande no explícito vs CN.",
                                    "Conclua sobre superioridade de CN em precisão e robustez."
                                  ],
                                  "verification": "Gráficos mostram inclinação 1 em tempo e 2 em espaço para CN.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Jupyter Notebook com plots Matplotlib",
                                    "Solução exata computável"
                                  ],
                                  "tips": "Use refinamento adaptativo k ~ h² para capturar ordens; normalize por norma da solução.",
                                  "learningObjective": "Demonstrar empiricamente a convergência superior do Crank-Nicolson.",
                                  "commonMistakes": [
                                    "Escolha inadequada de k/h",
                                    "Ignorar erros de arredondamento em malhas finas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule difusão de calor em uma barra metálica de 1m com extremidades a 0°C e temperatura inicial u(x,0)=sin(πx). Use h=0.05, k=0.001 para explícito (r=0.4) e CN; compare perfis u(x,t=0.1) e erros L∞.",
                              "finalVerifications": [
                                "Derivação correta do erro de truncagem para CN confirma O(k + h²).",
                                "Código numérico converge com taxas esperadas em plots log-log.",
                                "CN permanece estável para r=5, enquanto explícito diverge.",
                                "Erro global < 10^{-4} para h=1/100, k=10^{-4}.",
                                "Relatório resume comparação qualitativa/quantitativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica de ordens de convergência (80%).",
                                "Implementação numérica sem bugs e plots claros (90%).",
                                "Interpretação correta de resultados (ex: CN superior) (100%).",
                                "Uso apropriado de r e refinamento de malha.",
                                "Clareza no relatório com conclusões fundamentadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica/concentração.",
                                "Programação: Solvers lineares e análise numérica em Python/MATLAB.",
                                "Engenharia: Simulações CFD para fluxo de calor.",
                                "Estatística: Análise de erros e convergência empírica."
                              ],
                              "realWorldApplication": "Modelagem precisa de propagação de calor em materiais industriais, permitindo simulações estáveis sem restrições CFL severas, otimizando tempo computacional em engenharia térmica e processos químicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Estabilidade de Esquemas para Equações de Difusão",
                        "description": "Análise de estabilidade usando métodos espectrais e condições CFL para esquemas numéricos em equações parabólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Aplicar análise de von Neumann para FTCS",
                            "description": "Realizar a análise de estabilidade de von Neumann para o esquema forward-time central-space (FTCS) na equação de calor, derivando a condição de estabilidade r ≤ 1/2 onde r = Δt / (Δx)^2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação de Calor e o Esquema FTCS",
                                  "subSteps": [
                                    "Escreva a equação de calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Defina o esquema FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2 u_j^n + u_{j-1}^n), onde r = α Δt / (Δx)².",
                                    "Explique os termos: forward-time (diferença finita forward em tempo), central-space (central em espaço).",
                                    "Discuta a consistência do esquema (ordem de truncamento O(Δt) + O(Δx²)).",
                                    "Calcule r para um exemplo numérico simples."
                                  ],
                                  "verification": "Confirme que o esquema FTCS está corretamente escrito e r é definido adequadamente em um caderno ou software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Notebook com Python ou MATLAB"
                                  ],
                                  "tips": "Sempre normalize unidades para α=1 para simplificar cálculos iniciais.",
                                  "learningObjective": "Compreender a formulação exata do esquema FTCS para a equação de calor.",
                                  "commonMistakes": [
                                    "Confundir r com α Δt / Δx (em vez de (Δx)²)",
                                    "Esquecer o sinal negativo na laplaciana discreta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Análise de von Neumann",
                                  "subSteps": [
                                    "Explique o princípio: assumir solução de onda plana u_j^n = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação, k número de onda.",
                                    "Justifique por que isso captura modos de alta frequência (von Neumann analysis é para estabilidade linear).",
                                    "Substitua a forma assumida na equação do esquema FTCS.",
                                    "Simplifique a expressão obtendo ξ em termos de r e θ = k Δx.",
                                    "Verifique linearidade: o método assume equação linear e operadores lineares."
                                  ],
                                  "verification": "Derive a forma geral de ξ = 1 + r (e^{iθ} - 2 + e^{-iθ}) e simplifique para ξ = 1 - 4 r sin²(θ/2).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou papel)",
                                    "Referência: notas de curso de Análise Numérica II"
                                  ],
                                  "tips": "Use identidades trigonométricas: e^{iθ} + e^{-iθ} = 2 cos θ.",
                                  "learningObjective": "Dominar a substituição da solução de von Neumann no esquema de diferenças finitas.",
                                  "commonMistakes": [
                                    "Esquecer o expoente n em ξ^n",
                                    "Não usar a forma complexa exponencial corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Fator de Amplificação ξ para FTCS",
                                  "subSteps": [
                                    "Comece com u_j^n = ξ^n e^{i k j Δx}.",
                                    "Substitua em FTCS: ξ^{n+1} e^{i k j Δx} = ξ^n e^{i k j Δx} + r ξ^n (e^{i k (j+1) Δx} - 2 e^{i k j Δx} + e^{i k (j-1) Δx}).",
                                    "Divida por ξ^n e^{i k j Δx}: ξ = 1 + r (e^{iθ} - 2 + e^{-iθ}), θ = k Δx.",
                                    "Simplifique: e^{iθ} + e^{-iθ} - 2 = 2 cos θ - 2 = -4 sin²(θ/2).",
                                    "Obtenha ξ(θ) = 1 - 4 r sin²(θ/2)."
                                  ],
                                  "verification": "Escreva explicitamente ξ(θ) e plote |ξ(θ)| para r=0.4 e r=0.6 em [0,π].",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para plotar |ξ|",
                                    "Papel para derivação algébrica"
                                  ],
                                  "tips": "Memorize a identidade sin²(θ/2) = (1 - cos θ)/2 para verificação rápida.",
                                  "learningObjective": "Derivar analiticamente o fator de amplificação ξ(θ) para o esquema FTCS.",
                                  "commonMistakes": [
                                    "Erro no fator -4: esquecer que cos θ - 2 = -2 (1 - cos θ) = -4 sin²(θ/2)",
                                    "Confundir θ com k Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estabilidade e Derivar Condição r ≤ 1/2",
                                  "subSteps": [
                                    "Calcule |ξ(θ)|² = [1 - 4 r sin²(θ/2)]² (pois ξ é real).",
                                    "Exija |ξ(θ)| ≤ 1 para todo θ ∈ [0, π] (modos de alta frequência em θ=π).",
                                    "Ponto crítico: θ=π, sin(θ/2)=1, |ξ| = |1 - 4 r|. Para r>0, requer 1 - 4 r ≥ -1 ⇒ r ≤ 1/2.",
                                    "Verifique para r ≤ 1/2: ξ ∈ [-1,1] para todo θ.",
                                    "Discuta implicações: passos de tempo pequenos necessários para estabilidade."
                                  ],
                                  "verification": "Prove que para r > 1/2, |ξ(π)| >1, levando a instabilidade exponencial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos de |ξ(θ)| vs θ para diferentes r",
                                    "Exemplo numérico de simulação instável"
                                  ],
                                  "tips": "Teste numericamente: implemente FTCS com r=0.6 e observe blow-up.",
                                  "learningObjective": "Estabelecer e justificar a condição de estabilidade r ≤ 1/2.",
                                  "commonMistakes": [
                                    "Achar que ξ é complexo (é real para FTCS)",
                                    "Ignorar o caso θ=π (pior caso)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor ∂u/∂t = ∂²u/∂x² em [0,1] com u(0,t)=u(1,t)=0, condições iniciais u(x,0)=sin(π x), use Δx=0.1 (J=10), Δt=0.0025 (r=0.25<0.5). Implemente FTCS em Python, rode 1000 passos e compare com solução exata u(x,t)=sin(π x) e^{-π² t}. Observe estabilidade; repita com r=0.6 para ver oscilações.",
                              "finalVerifications": [
                                "Derivação correta de ξ(θ) = 1 - 4 r sin²(θ/2).",
                                "Identificação do modo crítico θ=π com |ξ|=|1-4r|.",
                                "Condição de estabilidade r ≤ 1/2 justificada para todos os modos.",
                                "Plot de |ξ(θ)| ≤1 para r=0.4 e >1 para r=0.6.",
                                "Simulação numérica estável para r≤1/2 e instável para r>1/2.",
                                "Explicação verbal da implicação física (dispersão numérica)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica de ξ (sem erros trigonométricos).",
                                "Correta análise de |ξ|≤1 para estabilidade von Neumann.",
                                "Identificação exata da condição r ≤ 1/2.",
                                "Uso apropriado de plots ou simulações para validação.",
                                "Compreensão conceitual: ligação entre r, Δt e Δx.",
                                "Capacidade de generalizar para outros esquemas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e parabólicas PDEs.",
                                "Computação Científica: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD para transferência de calor.",
                                "Matemática Pura: Análise complexa e séries de Fourier.",
                                "Estatística: Análise de erros numéricos e truncamento."
                              ],
                              "realWorldApplication": "Em engenharia térmica para simular distribuição de calor em placas ou tubos sem blow-up numérico; em meteorologia para modelos de difusão de poluentes; em finanças para equações de Black-Scholes (parabólicas) com restrições de timestep para precisão em opções pricing."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Determinar condições de estabilidade para esquemas implícitos",
                            "description": "Verificar a incondicionalidade de estabilidade para o esquema backward-time central-space (BTCS) e Crank-Nicolson usando amplificação de Fourier, calculando o fator de amplificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os esquemas implícitos BTCS e Crank-Nicolson",
                                  "subSteps": [
                                    "Relembre a equação de difusão unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Escreva a discretização BTCS: u^{n+1}_j - u^n_j = r (u^{n+1}_{j-1} - 2u^{n+1}_j + u^{n+1}_{j+1}), onde r = α Δt / Δx².",
                                    "Escreva o esquema Crank-Nicolson: u^{n+1}_j - u^n_j = (r/2) [(u^{n+1}_{j-1} - 2u^{n+1}_j + u^{n+1}_{j+1}) + (u^n_{j-1} - 2u^n_j + u^n_{j+1})].",
                                    "Identifique as matrizes tridiagonais implícitas para cada esquema.",
                                    "Discuta as diferenças: BTCS é totalmente implícito, CN é semi-implícito."
                                  ],
                                  "verification": "Escreva corretamente as formas matriciais de ambos os esquemas e verifique com uma referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use notação consistente para Δt e Δx para evitar confusão nos passos seguintes.",
                                  "learningObjective": "Compreender a estrutura algébrica dos esquemas implícitos para equações parabólicas.",
                                  "commonMistakes": "Confundir os coeficientes de r em BTCS (totalmente implícito) vs. CN (média explícito-implícito)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise de estabilidade de von Neumann via amplificação de Fourier",
                                  "subSteps": [
                                    "Assuma solução de Fourier: u^n_j = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação e k o número de onda.",
                                    "Substitua na equação discreta para obter |ξ| ≤ 1 como condição de estabilidade.",
                                    "Derive a forma geral: ξ = [1 - r (2 - 2 cos(θ))]^{-1} para esquemas implícitos, onde θ = k Δx.",
                                    "Explique o papel do símbolo de Fourier em decompor erros em modos independentes.",
                                    "Verifique linearidade e periodicidade das condições de contorno."
                                  ],
                                  "verification": "Derive a expressão genérica de ξ para um esquema implícito e confirme |ξ| ≤ 1 para estabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno para derivações",
                                    "Software como MATLAB ou Python para plotar |ξ(θ)|"
                                  ],
                                  "tips": "Sempre normalize com o expoente imaginário i para evitar erros em cos(θ).",
                                  "learningObjective": "Aplicar análise de Fourier para decompor estabilidade em modos espectrais.",
                                  "commonMistakes": "Esquecer o expoente n em ξ^n ou usar seno em vez de coseno para a segunda derivada discreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o fator de amplificação para o esquema BTCS",
                                  "subSteps": [
                                    "Substitua a forma de Fourier na discretização BTCS: ξ = 1 / [1 + 2r (1 - cos(θ))].",
                                    "Simplifique: ξ = 1 / [1 + 4r sin²(θ/2)], usando identidade trigonométrica.",
                                    "Analise |ξ(θ)| para θ ∈ [0, π]: mostre que |ξ| ≤ 1 para todo r > 0.",
                                    "Plote |ξ| vs. θ para diferentes r para visualizar atenuação.",
                                    "Conclua estabilidade incondicional independentemente de r."
                                  ],
                                  "verification": "Compute |ξ| para θ=0 (ξ=1) e θ=π (ξ=1/(1+4r) <1) e confirme monotonicidade decrescente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotagem",
                                    "Tabela de identidades trigonométricas"
                                  ],
                                  "tips": "Use sin²(θ/2) para simplificação elegante e análise de máximo.",
                                  "learningObjective": "Derivar e analisar explicitamente o fator de amplificação BTCS.",
                                  "commonMistakes": "Inverter numerador e denominador ou esquecer o módulo |ξ|."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o fator de amplificação para o esquema Crank-Nicolson",
                                  "subSteps": [
                                    "Substitua na forma CN: ξ - 1 = (r/2) [ (ξ (e^{-iθ} - 2 + e^{iθ}) + (e^{-iθ} - 2 + e^{iθ}) ) ].",
                                    "Simplifique para ξ = [1 - 2i r sin²(θ/2)] / [1 + 2i r sin²(θ/2)].",
                                    "Compute |ξ|² = 1 / [1 + (2 r sin²(θ/2))² ] ≤ 1 para todo r > 0.",
                                    "Verifique neutralidade em θ=0 (|ξ|=1) e atenuação em modos altos.",
                                    "Compare com BTCS: ambos incondicionalmente estáveis, mas CN preserva melhor amplitudes baixas."
                                  ],
                                  "verification": "Derive |ξ| = 1 / sqrt(1 + [2 r sin²(θ/2)]²) e mostre ≤1.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora complexa ou SymPy",
                                    "Gráficos comparativos BTCS vs CN"
                                  ],
                                  "tips": "Trabalhe com números complexos conjuntamente para |ξ|² = ξ * conj(ξ).",
                                  "learningObjective": "Derivar e provar estabilidade incondicional para Crank-Nicolson.",
                                  "commonMistakes": "Erros em manipulação de exponenciais complexas ou esquecimento do termo semi-explícito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir e comparar condições de estabilidade",
                                  "subSteps": [
                                    "Resuma: ambos BTCS e CN são incondicionalmente estáveis (|ξ| ≤ 1 ∀ r > 0).",
                                    "Discuta implicações: permite Δt grande sem instabilidade, mas com custo computacional (solução linear).",
                                    "Compare com explícito (r ≤ 1/2): vantagem dos implícitos.",
                                    "Analise dissipação e dispersão qualitativamente.",
                                    "Teste numericamente com um problema simples para validar."
                                  ],
                                  "verification": "Escreva relatório curto confirmando incondicionalidade e plots de |ξ|.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código de simulação simples em Python",
                                    "Problema teste: barra de calor"
                                  ],
                                  "tips": "Sempre valide analítico com numérico para confiança.",
                                  "learningObjective": "Sintetizar análise para determinar condições de estabilidade geral.",
                                  "commonMistakes": "Afirmar estabilidade condicional por confusão com esquemas explícitos."
                                }
                              ],
                              "practicalExample": "Para a equação de calor ∂u/∂t = ∂²u/∂x² em [0,1] com u(0,t)=u(1,t)=0 e u(x,0)=sin(πx), compute ξ para BTCS e CN com r=10 (Δt grande). Simule 10 passos e verifique que erros não crescem, confirmando estabilidade incondicional.",
                              "finalVerifications": [
                                "Derivação correta de ξ_BTCS = 1 / [1 + 4r sin²(θ/2)] com |ξ| ≤ 1.",
                                "Derivação correta de |ξ_CN| = 1 / sqrt(1 + [2r sin²(θ/2)]²) ≤ 1.",
                                "Plots de |ξ(θ)| para r=1,10 mostrando atenuação sem amplificação.",
                                "Comparação qualitativa: CN menos dissipativo que BTCS para baixos modos.",
                                "Simulação numérica sem oscilações para r>1/2.",
                                "Identificação correta de incondicionalidade para ambos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de fatores de amplificação (90% correto).",
                                "Análise completa de |ξ| ≤1 para todos os modos θ.",
                                "Uso correto de identidades trigonométricas e números complexos.",
                                "Interpretação física: implicações para passos de tempo grandes.",
                                "Validação numérica com exemplo prático.",
                                "Clareza na comparação BTCS vs CN."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de estabilidade em simulações CFD.",
                                "Computação: Solução de sistemas lineares tridiagonais (Thomas algorithm) em PDE solvers.",
                                "Engenharia: Estabilidade em simulações numéricas de processos industriais (ex: refino químico).",
                                "Matemática Aplicada: Análise espectral e autovalores em métodos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de propagação de calor em reatores nucleares ou previsão de clima, esquemas como BTCS e CN permitem passos de tempo maiores sem instabilidade, reduzindo tempo computacional em supercomputadores para modelos 3D realistas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Comparar estabilidade e precisão de esquemas",
                            "description": "Comparar estabilidade, dissipação e dispersão entre esquemas explícito, implícito e Crank-Nicolson para equações de difusão, identificando trade-offs em termos de custo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Formulações dos Esquemas Explícito, Implícito e Crank-Nicolson",
                                  "subSteps": [
                                    "Derivar a discretização espacial da equação de difusão 1D: ∂u/∂t = α ∂²u/∂x² usando diferenças finitas centrais.",
                                    "Formular o esquema explícito: u^{n+1}_j = u^n_j + r (u^n_{j-1} - 2u^n_j + u^n_{j+1}), onde r = α Δt / Δx².",
                                    "Formular o esquema implícito: resolver sistema tridiagonal para u^{n+1}.",
                                    "Formular o esquema Crank-Nicolson como média de explícito e implícito.",
                                    "Implementar stencil diagramático para cada esquema."
                                  ],
                                  "verification": "Desenhar stencils corretos e escrever equações em um relatório curto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Papel e lápis ou software como MATLAB/Python",
                                    "Notas de aula sobre PDEs parabólicas"
                                  ],
                                  "tips": "Use notação consistente para r e compare visualmente os stencils.",
                                  "learningObjective": "Dominar as diferenças algébricas e geométricas entre os esquemas.",
                                  "commonMistakes": [
                                    "Esquecer o fator r na formulação",
                                    "Confundir ordem temporal dos esquemas",
                                    "Ignorar condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Condições de Estabilidade",
                                  "subSteps": [
                                    "Aplicar método de von Neumann: assumir u^n_j = ξ^n e^{i k j Δx} e derivar fator de amplificação |ξ| ≤ 1.",
                                    "Derivar para explícito: |1 - 4r sin²(θ/2)| ≤ 1, levando a r ≤ 1/2.",
                                    "Mostrar implícito incondicionalmente estável: |ξ| ≤ 1 para todo r.",
                                    "Derivar para Crank-Nicolson: também incondicionalmente estável.",
                                    "Plotar fatores de amplificação vs. número de onda θ para r variados."
                                  ],
                                  "verification": "Gerar gráficos de |ξ(θ)| mostrando regiões instáveis para explícito.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB para plotar |ξ|",
                                    "Calculadora simbólica (SymPy)",
                                    "Referência: notas sobre estabilidade de Lax"
                                  ],
                                  "tips": "Normalize θ = k Δx de 0 a π; foque em modos de alta frequência (θ≈π).",
                                  "learningObjective": "Identificar trade-offs de estabilidade condicional vs. incondicional.",
                                  "commonMistakes": [
                                    "Erro no cálculo de ξ para implícito (raízes quadráticas)",
                                    "Ignorar parte imaginária em Crank-Nicolson",
                                    "Confundir estabilidade com consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Precisão: Dissipação e Dispersão",
                                  "subSteps": [
                                    "Definir dissipação: amortecimento artificial de amplitudes (|ξ| < 1).",
                                    "Definir dispersão: fase errada (arg(ξ) ≠ -α k² Δt).",
                                    "Calcular dissipação numérica para cada esquema e comparar com exato (|ξ_exact| = e^{-α k² Δt}).",
                                    "Calcular erro de dispersão: plotar ω_num vs. ω_exact.",
                                    "Analisar ordem: explícito O(Δt + Δx²), CN O(Δt² + Δx²)."
                                  ],
                                  "verification": "Tabela comparativa de erros de dissipação/dispersão para θ baixo/alto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software numérico (NumPy/SciPy)",
                                    "Artigos sobre análise de Fourier",
                                    "Gráficos prontos de referência"
                                  ],
                                  "tips": "Use expansões em Taylor para aproximações assintóticas de ξ.",
                                  "learningObjective": "Quantificar como esquemas introduzem erros numéricos.",
                                  "commonMistakes": [
                                    "Confundir dissipação com dispersão",
                                    "Não normalizar pelo exato",
                                    "Ignorar dependência em r"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Trade-offs e Custo Computacional",
                                  "subSteps": [
                                    "Listar prós/contras: explícito (barato, condicional), implícito (estável, resolve sistema), CN (preciso, resolve sistema).",
                                    "Calcular custo: explícito O(N) por passo, implícito/CN O(N) com Thomas algorithm.",
                                    "Simular problema teste: difusão 1D, medir tempo CPU e erro L2 vs. solução exata.",
                                    "Identificar cenários ideais: explícito para r pequeno, CN para precisão alta.",
                                    "Documentar trade-offs em matriz comparativa."
                                  ],
                                  "verification": "Relatório com simulações, tempos e erros para r=0.4 (explícito) vs. r=5 (outros).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python pronto para esquemas",
                                    "Solução exata via séries de Fourier",
                                    "Cronômetro para benchmark"
                                  ],
                                  "tips": "Use malha fina (N=1000) para custo real; fixe Δt Δx para fair comparison.",
                                  "learningObjective": "Avaliar escolhas práticas baseadas em estabilidade, precisão e eficiência.",
                                  "commonMistakes": [
                                    "Não usar solver eficiente para implícito",
                                    "Comparar sem normalizar passos de tempo",
                                    "Ignorar overhead de setup"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente ∂u/∂t = ∂²u/∂x² em [0,1]x[0,1] com u(x,0)=sin(πx), u(0,t)=u(1,t)=0. Use Δx=0.01, Δt=0.0005 (r=0.5 para explícito instável). Compare u numérica vs. exata u(x,t)=sin(πx) e^{-π² t} em t=0.5, plotando perfis e erros L∞.",
                              "finalVerifications": [
                                "Lista corretamente r ≤ 0.5 para explícito e incondicional para outros.",
                                "Descreve dissipação excessiva em implícito para r grande.",
                                "Identifica dispersão mínima em Crank-Nicolson.",
                                "Compara custos: explícito mais rápido para r pequeno.",
                                "Explica trade-off precisão vs. estabilidade em contexto.",
                                "Simula instabilidade explícita visualmente."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática nas derivações de ξ (90% precisão).",
                                "Qualidade dos gráficos de |ξ| e fase (rótulos, escalas).",
                                "Análise quantitativa de erros (tabelas com % erro).",
                                "Profundidade na discussão de trade-offs (exemplos contextualizados).",
                                "Clareza no relatório (estrutura, diagramas).",
                                "Implementação numérica sem bugs (convergência observada)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e Fick's laws.",
                                "Computação Científica: Algoritmos lineares e solvers iterativos.",
                                "Engenharia Mecânica: Simulações de transferência de calor em CFD.",
                                "Matemática Aplicada: Análise espectral de operadores diferenciais."
                              ],
                              "realWorldApplication": "Em simulações de difusão de contaminantes em solos (meio ambiente) ou propagação de calor em reatores nucleares (engenharia), onde Crank-Nicolson equilibra precisão para previsões longas sem restrições de Δt, otimizando simulações em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Métodos ADI para Equações Parabólicas",
                        "description": "Métodos de direção alternada implícita (ADI) para resolver eficientemente equações de difusão em duas dimensões.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Descrever o algoritmo ADI",
                            "description": "Explicar o método ADI de Peaceman-Rachford para a equação de calor bidimensional, detalhando as duas meias-passadas implícitas em direções x e y por passo de tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Equação de Calor Bidimensional e sua Discretização Espacial",
                                  "subSteps": [
                                    "Escreva a equação de calor 2D: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²).",
                                    "Defina a malha espacial uniforme com passos Δx, Δy e índices i,j.",
                                    "Aplique diferenças finitas centrais para as derivadas espaciais: δ²u/δx² ≈ (u_{i+1,j} - 2u_{i,j} + u_{i-1,j})/Δx².",
                                    "Expresse a discretização semi-discreta: du/dt = A u, onde A é o operador Laplaciano discreto.",
                                    "Identifique condições de contorno (Dirichlet ou Neumann) e inicial."
                                  ],
                                  "verification": "Verifique se a discretização espacial resulta em uma matriz tridiagonal para 1D e tensor para 2D.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, livro de análise numérica (ex: LeVeque), software como MATLAB ou Python com NumPy.",
                                  "tips": "Desenhe a malha 2D para visualizar os vizinhos de um ponto.",
                                  "learningObjective": "Compreender a base parabólica e preparar para o tempo marching.",
                                  "commonMistakes": "Confundir derivadas espaciais com temporais ou usar diferenças forward em vez de central."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Princípio do Método ADI de Peaceman-Rachford",
                                  "subSteps": [
                                    "Explique que ADI divide o passo de tempo em duas meias-passadas para tratar 2D implicitamente sem matriz full.",
                                    "Defina o passo de tempo completo Δt dividido em Δt/2 para cada meia-passada.",
                                    "Introduza a fatoração: (I - (Δt/2)α δ_y²)(I - (Δt/2)α δ_x²) ≈ I + (Δt/2)α (δ_x² + δ_y²), onde δ são operadores discretos.",
                                    "Note que o erro de fatoração é O(Δt³), preservando consistência de segunda ordem.",
                                    "Discuta vantagens: cada meia-passada resolve sistema tridiagonal 1D."
                                  ],
                                  "verification": "Escreva a aproximação da fatoração e confirme que é exata para 1D.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Quadro branco, notas de aula sobre PDEs numéricas.",
                                  "tips": "Pense em ADI como 'alternar' direções para simplicidade computacional.",
                                  "learningObjective": "Graspar o conceito de splitting direction para eficiência em 2D.",
                                  "commonMistakes": "Ignorar o erro de fatoração ou achar que é explícito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a Primeira Meia-Passada Implícita em x e Explícita em y",
                                  "subSteps": [
                                    "Do tempo n para n+1/2: (I - (Δt/2)α δ_x²) u^{n+1/2} = (I + (Δt/2)α δ_y²) u^n.",
                                    "Expanda para o ponto (i,j): -r/2 u_{i-1,j}^{n+1/2} + (1+r) u_{i,j}^{n+1/2} - r/2 u_{i+1,j}^{n+1/2} = soma vizinhos y de u^n, onde r = α Δt / Δx².",
                                    "Note que para fixo j, é tridiagonal em i (direção x).",
                                    "Resolva sequencialmente para cada linha j usando Thomas algorithm.",
                                    "Aplique condições de contorno na direção x."
                                  ],
                                  "verification": "Implemente em código para uma linha e confira se resolve tridiagonal corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Jupyter com SciPy para solver tridiagonal.",
                                  "tips": "Assuma Δx=Δy para simplificar r_x = r_y = r.",
                                  "learningObjective": "Dominar a equação implícita unidirecional.",
                                  "commonMistakes": "Misturar coeficientes de x e y ou esquecer o explicit em y."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever a Segunda Meia-Passada Implícita em y e Explícita em x",
                                  "subSteps": [
                                    "De n+1/2 para n+1: (I - (Δt/2)α δ_y²) u^{n+1} = (I + (Δt/2)α δ_x²) u^{n+1/2}.",
                                    "Expanda: para fixo i, tridiagonal em j: -s/2 u_{i,j-1}^{n+1} + (1+s) u_{i,j}^{n+1} - s/2 u_{i,j+1}^{n+1} = soma vizinhos x de u^{n+1/2}.",
                                    "Resolva para cada coluna i.",
                                    "Aplique condições de contorno na direção y.",
                                    "Confirme que u^{n+1} aproxima a solução exata."
                                  ],
                                  "verification": "Compare com solução explícita FTCS para pequeno Δt.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo código Python, adicionar segunda sweep.",
                                  "tips": "Use u^{n+1/2} como known no lado direito.",
                                  "learningObjective": "Completar o ciclo ADI e entender alternância.",
                                  "commonMistakes": "Usar u^n em vez de u^{n+1/2} no RHS."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar o Algoritmo Completo e Discutir Estabilidade",
                                  "subSteps": [
                                    "Escreva pseudocódigo: loop em tempo, sweep1 por j, sweep2 por i.",
                                    "Inicialize u^0 com condição inicial.",
                                    "Atualize até tempo final, plotando evolução.",
                                    "Analise estabilidade: von Neumann mostra |G|≤1 para r arbitrariamente grande (incondicionalmente estável).",
                                    "Teste convergência com refinamento de malha."
                                  ],
                                  "verification": "Execute simulação e verifique L2 error < 1e-3 para malha fina.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código completo em Python/MATLAB, grids de teste 20x20.",
                                  "tips": "Vetorize em NumPy para velocidade.",
                                  "learningObjective": "Sintetizar o algoritmo e validar numericamente.",
                                  "commonMistakes": "Não aplicar BCs corretamente ou loop infinito sem stop."
                                }
                              ],
                              "practicalExample": "Simule difusão de calor em uma placa 2D quadrada [0,1]x[0,1] com u=0 nas bordas e pico inicial u(x,y,0)=sin(πx)sin(πy). Use Δx=Δy=0.05, Δt=0.01, α=1, por 0.5 unidades de tempo. Compare ADI com solução analítica u(x,y,t)=sin(πx)sin(πy)exp(-2π²αt).",
                              "finalVerifications": [
                                "Escreve corretamente as equações das duas meias-passadas.",
                                "Implementa código que roda sem erro e produz plots razoáveis.",
                                "Explica por que ADI é O(N) por passo vs O(N²) para implícito full.",
                                "Identifica r como parâmetro de estabilidade irrestrito.",
                                "Reproduz fatoração e ordem de precisão.",
                                "Aplica BCs em ambos sweeps."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações ADI (90% dos termos corretos).",
                                "Correção do pseudocódigo e implementação funcional.",
                                "Explicação clara da alternância de direções.",
                                "Análise de custo computacional vs métodos explícitos/implícitos.",
                                "Demonstração de estabilidade incondicional.",
                                "Uso apropriado de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e fluxo de calor.",
                                "Computação: Algoritmos lineares (Thomas), programação científica (NumPy/SciPy).",
                                "Engenharia: Simulações CFD para aerodinâmica ou materiais.",
                                "Matemática Aplicada: Análise de erros em PDEs numéricas."
                              ],
                              "realWorldApplication": "Usado em simulações de reservatórios de petróleo (difusão de fluidos), previsão de tempo (modelos de difusão atmosférica), design térmico de eletrônicos e pricing de opções financeiras via equações de Black-Scholes (parabólicas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Analisar convergência e estabilidade do ADI",
                            "description": "Provar a estabilidade incondicional e convergência de ordem 2 do método ADI para equações parabólicas 2D, usando análise espectral ou norma máxima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do método ADI para equações parabólicas 2D",
                                  "subSteps": [
                                    "Estude a equação parabólica modelo: ∂u/∂t = Δu em um domínio retangular Ω = [0,1]×[0,1] com condições de contorno Dirichlet.",
                                    "Descreva o esquema ADI de Peaceman-Rachford: alternar direções x e y implicitamente em meias etapas temporais.",
                                    "Escreva as equações discretas para as duas meias etapas: resolver tridiagonal em x (fixo y), depois em y (fixo x).",
                                    "Defina os parâmetros: h (espaçamento espacial), k (passo temporal), r = k/h².",
                                    "Verifique consistência local derivando a expansão de Taylor das diferenças finitas."
                                  ],
                                  "verification": "Escreva corretamente o esquema ADI de duas etapas e mostre que é consistente de ordem 2 em espaço e tempo.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro 'Análise Numérica de EDP' de LeVeque (cap. 5)",
                                    "Notebook Jupyter com Python/NumPy para discretização",
                                    "Artigo original de Peaceman-Rachford (1955)"
                                  ],
                                  "tips": "Comece com o caso 1D para intuitar antes de 2D; use matrizes tridiagonais para eficiência.",
                                  "learningObjective": "Compreender e reproduzir a formulação exata do ADI, incluindo operadores diferenciais implícitos.",
                                  "commonMistakes": [
                                    "Confundir ADI com ADI de Douglas-Rachford",
                                    "Esquecer condições de contorno nas meias etapas",
                                    "Ignorar o fator de estabilidade r ilimitado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise espectral para provar estabilidade incondicional",
                                  "subSteps": [
                                    "Von Fourierize a solução discreta: assuma modos ξ_{m,n} = exp(i θ_x m h) exp(i θ_y n h) exp(λ t).",
                                    "Derive o fator de amplificação G(θ_x, θ_y, r) para o ciclo completo ADI.",
                                    "Mostre que |G(θ_x, θ_y, r)| ≤ 1 + O(k) para todos θ_x, θ_y ∈ [0, π] e r > 0.",
                                    "Analise os autovalores dos operadores implícitos em cada direção.",
                                    "Conclua estabilidade incondicional: ||e^{n+1}|| ≤ (1 + C k) ||e^n|| levando a ||e^n|| ≤ exp(C T)."
                                  ],
                                  "verification": "Derive G e prove |G| ≤ 1 + O(r) graficamente ou analiticamente para θ_x = θ_y = π/2.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software MATLAB ou Python com SymPy para autovalores simbólicos",
                                    "Notas de aula sobre análise de von Neumann",
                                    "Referência: Strang's 'Linear Algebra and Applications' para autovalores"
                                  ],
                                  "tips": "Use aproximações trigonométricas para senos: sin(θ/2) ≈ θ/2 para baixas frequências, mas verifique altas.",
                                  "learningObjective": "Dominar análise espectral para esquemas multi-etapa, provando |G| ≤ 1.",
                                  "commonMistakes": [
                                    "Esquecer o ciclo completo (duas meias etapas)",
                                    "Assumir r fixo em vez de arbitrário",
                                    "Confundir norma L2 discreta com contínua"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar erro de truncamento local para consistência de ordem 2",
                                  "subSteps": [
                                    "Aplique expansão de Taylor na solução exata u em cada operador diferencial implícito.",
                                    "Mostre que o erro local por ciclo temporal é O(k^3 + h^4 / k), mas equilibre com r = k/h².",
                                    "Derive τ = O(k^3 + h^2 k) levando a ordem 2 global com k ~ h².",
                                    "Verifique consistência: lim_{h,k→0} τ / (k + h²) = 0.",
                                    "Compare com Crank-Nicolson 1D para validar."
                                  ],
                                  "verification": "Calcule os termos principais de τ e mostre ordem 2 em h e k.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Caderno para expansões Taylor multi-variáveis",
                                    "Python/SymPy para simplificação simbólica",
                                    "Livro 'Finite Difference Schemes' de Gustafsson"
                                  ],
                                  "tips": "Organize Taylor em potências de √k e h; ignore O(h^4) inicialmente.",
                                  "learningObjective": "Calcular erros de truncamento para métodos implícitos multi-direção.",
                                  "commonMistakes": [
                                    "Erros em derivadas cruzadas ∂²u/∂x∂y",
                                    "Não considerar o expoente implícito corretamente",
                                    "Confundir erro local vs global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar convergência de ordem 2 usando norma máxima",
                                  "subSteps": [
                                    "Defina erro e^{n}_{j,k} = u(t_n, x_j, y_k) - u^n_{j,k}.",
                                    "Mostre ||e^{n+1}||_∞ ≤ ||e^n||_∞ + C k (h² + k), usando estabilidade e consistência.",
                                    "Use princípio do máximo discreto para operadores elípticos nas meias etapas.",
                                    "Induza por passos: somar erros acumulados ≤ C (h² + k) T.",
                                    "Conclua ||e^n||_∞ ≤ C (h² + k) para solução suave u."
                                  ],
                                  "verification": "Escreva a desigualdade de convergência e prove para n=T fixo com h,k→0.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Teorema Lax-Richtmyer (artigo original)",
                                    "Exemplos numéricos em MATLAB para validar norma ∞",
                                    "Notas sobre normas em grids 2D"
                                  ],
                                  "tips": "Comece com 1D para norma máxima antes de tensorizar para 2D.",
                                  "learningObjective": "Combinar estabilidade + consistência para teorema de convergência via normas.",
                                  "commonMistakes": [
                                    "Não lidar com condições de contorno no máximo",
                                    "Usar norma L2 em vez de ∞ para prova simples",
                                    "Ignorar suavidade de u necessária"
                                  ]
                                }
                              ],
                              "practicalExample": "Aplique ADI à equação do calor 2D ∂u/∂t = Δu em [0,1]² com u=sin(πx)sin(πy) inicial e u=0 nas bordas. Implemente em Python, compute erros em norma máxima para h=1/20, k=h²/4, e verifique ordem 2 reduzindo h pela metade.",
                              "finalVerifications": [
                                "Derive corretamente o fator de amplificação G e prove |G|≤1+O(k).",
                                "Calcule erro de truncamento τ mostrando O(h²+k).",
                                "Prove ||e||_∞ ≤ C(h²+k) usando recursão estável.",
                                "Implemente numéricamente e observe convergência ordem 2 em log-log plot.",
                                "Explique por que ADI é incondicionalmente estável vs explicit.",
                                "Identifique limitações para reações não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação espectral (80% dos passos corretos).",
                                "Correção das expansões Taylor (ordem exata identificada).",
                                "Rigor na prova de norma máxima (desigualdades justas).",
                                "Exemplo numérico funcional com gráfico de erro.",
                                "Explicação clara de intuições físicas/matemáticas.",
                                "Ausência de erros comuns como confusão de fatores."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica ou contaminação em placas 2D.",
                                "Computação: Solução eficiente de sistemas tridiagonais com Thomas algorithm.",
                                "Engenharia: Simulações CFD para escoamentos incompressíveis via pressão.",
                                "Estatística: Análise de erros em métodos MCMC para PDEs.",
                                "Otimização: ADI como precursor de métodos de decomposição de domínio."
                              ],
                              "realWorldApplication": "O método ADI é usado em simulações geofísicas para reservatórios de petróleo (difusão de fluidos), modelagem climática de oceanos (equações de difusão 2D), e processamento de imagens (filtro gaussiano implícito), permitindo passos temporais grandes para eficiência computacional em grids finos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Implementar esquema ADI simples",
                            "description": "Implementar numericamente um esquema ADI para resolver a equação de difusão 2D com condições de Dirichlet, validando com soluções analíticas e analisando erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema de difusão 2D e configurar a malha espacial",
                                  "subSteps": [
                                    "Especificar a equação de difusão: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²) em domínio [0,Lx]x[0,Ly].",
                                    "Escolher parâmetros: α=1, Lx=Ly=1, condições de Dirichlet u=0 nas bordas exceto u=sin(πx)sin(πy) em t=0.",
                                    "Definir malha: Nx=Ny=41 pontos, hx=Ly/(Ny-1), hy=Lx/(Nx-1), dt=0.001 para estabilidade.",
                                    "Inicializar array u[x,y] com condição inicial e criar grids x,y com meshgrid.",
                                    "Plotar malha inicial e condição inicial para visualização."
                                  ],
                                  "verification": "Malha gerada corretamente, condição inicial plotada sem erros de indexação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3 com NumPy, Matplotlib, Jupyter Notebook"
                                  ],
                                  "tips": "Use hx=hx=hy para simetria e simplicidade no esquema ADI.",
                                  "learningObjective": "Configurar numericamente o problema parabólico 2D com discritização espacial uniforme.",
                                  "commonMistakes": [
                                    "Passos de malha hx, hy muito grandes causando violação CFL; índices invertidos em arrays 2D."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e codificar o esquema ADI simples",
                                  "subSteps": [
                                    "Dividir o passo temporal em duas meias-etapas: primeiro sweep em x (implícito y explícito), depois em y.",
                                    "Escrever matriz tridiagonal para sweep x: A u^{n+1/2} = u^n + r Δt ∂²u/∂y² (explícito).",
                                    "Implementar solver tridiagonal com thomas_algorithm para cada linha y.",
                                    "Repetir para sweep y: A u^{n+1} = u^{n+1/2} + r Δt ∂²u/∂x².",
                                    "Codificar loop temporal com atualizações alternadas."
                                  ],
                                  "verification": "Esquema codificado roda sem erros para 10 passos temporais, u evolui suavemente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy para arrays e solvers lineares, função thomas_algorithm personalizada"
                                  ],
                                  "tips": "Implemente thomas_algorithm como função reutilizável para eficiência.",
                                  "learningObjective": "Compreender e implementar a alternância implícita-explícita do método ADI.",
                                  "commonMistakes": [
                                    "Confundir sweeps x/y; não zerar diagonal secundária na tridiagonal; r=α dt / hx² >0.5."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar condições de Dirichlet e integrar no tempo",
                                  "subSteps": [
                                    "Impor u=0 nas bordas após cada sweep completo usando slicing de arrays.",
                                    "Criar função update_boundaries(u) que zera bordas i=0,Nx-1 e j=0,Ny-1.",
                                    "Executar simulação para T=0.5 com Nt=500 passos, salvando u a cada 50 passos.",
                                    "Plotar evolução temporal em animação ou slices para inspeção visual.",
                                    "Verificar conservação aproximada de massa/integração de u."
                                  ],
                                  "verification": "Bordas mantidas em zero durante toda simulação, sem vazamento numérico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matplotlib.animation para visualização dinâmica"
                                  ],
                                  "tips": "Salve snapshots em lista para animação pós-processamento, evite loops lentos.",
                                  "learningObjective": "Integrar condições de contorno Dirichlet em esquemas implícitos multidimensionais.",
                                  "commonMistakes": [
                                    "Atualizar bordas antes dos sweeps causando propagação errada; forgetar após ambos sweeps."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar solução analítica para validação",
                                  "subSteps": [
                                    "Derivar solução exata: u(x,y,t)=exp(-2π²αt) sin(πx) sin(πy) para condições dadas.",
                                    "Codificar função u_exact(x,y,t) usando meshgrid e exponencial.",
                                    "Gerar u_analytical na mesma malha e tempos simulados.",
                                    "Plotar overlay de u_num vs u_exact em t=0.5 para comparação qualitativa.",
                                    "Calcular erro L2: sqrt( mean( (u_num - u_exact)^2 ) ) por tempo."
                                  ],
                                  "verification": "Erro L2 decresce monotonicamente e <1e-3 em t=0.5.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy para broadcasting em grids 2D"
                                  ],
                                  "tips": "Use np.meshgrid com indexing='ij' para alinhamento correto.",
                                  "learningObjective": "Validar precisão numérica contra benchmark analítico exato.",
                                  "commonMistakes": [
                                    "Fase errada na solução analítica; mismatch de grids x,y."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar convergência e erro numérico",
                                  "subSteps": [
                                    "Refinar malha: rodar com Nx=21,41,81, computar erro L2 vs hx.",
                                    "Plotar log-log de erro L2 vs hx, estimar ordem de convergência (esperado O(h²)).",
                                    "Analisar estabilidade variando dt, observar blow-up se r>1.",
                                    "Reportar tabela: hx, dt, erro L2, tempo CPU.",
                                    "Documentar insights em relatório com plots."
                                  ],
                                  "verification": "Gráfico confirma convergência O(h²), simulação estável para r≤1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matplotlib para loglog plots, Pandas para tabela de erros"
                                  ],
                                  "tips": "Fixe dt proporcional a hx² para isolar erro espacial.",
                                  "learningObjective": "Quantificar precisão e ordem de convergência do esquema ADI.",
                                  "commonMistakes": [
                                    "Não normalizar erro por área; confundir erro espacial vs temporal."
                                  ]
                                }
                              ],
                              "practicalExample": "Simular difusão de calor em uma placa metálica quadrada de 1m x 1m, inicialmente quente no centro (sin(πx)sin(πy)), com bordas mantidas a 0°C, usando ADI para prever distribuição de temperatura em 0.5s.",
                              "finalVerifications": [
                                "Simulação completa roda sem crashes para malhas até 101x101.",
                                "Erro L2 máximo <5e-4 em t=0.5 com hx=0.025.",
                                "Plot log-log mostra slope ~2 confirmando convergência quadrática.",
                                "Animação visual mostra difusão realista sem oscilações.",
                                "Bordas Dirichlet rigorosamente zero em todos timesteps.",
                                "Tempo CPU escalável, <10s para simulação fina."
                              ],
                              "assessmentCriteria": [
                                "Correção do esquema ADI: sweeps alternados e tridiagonal solver funcionais (40%).",
                                "Validação: erro L2 computado e plotado vs analítico (20%).",
                                "Análise: convergência ordenada demonstrada com refinamento (20%).",
                                "Código limpo: funções modulares, comentários, plots profissionais (10%).",
                                "Relatório: insights sobre estabilidade/precisão (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos lineares (thomas), vetoriação NumPy.",
                                "Física: Modelagem de difusão térmica/concentração.",
                                "Engenharia Computacional: PDE solvers em HPC.",
                                "Estatística: Análise de erro e convergência.",
                                "Visualização de Dados: Animações e plots científicos."
                              ],
                              "realWorldApplication": "Modelagem de difusão de calor em painéis solares para otimização térmica; simulação de dispersão de poluentes em aquíferos 2D; previsão de secagem em processos industriais como fabricação de semicondutores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Equações Elípticas: Condições de Dirichlet e Neumann",
                    "description": "Métodos de diferenças finitas com condições de contorno.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Condições de Dirichlet em Equações Elípticas com Métodos de Diferenças Finitas",
                        "description": "Aborda a discretização de equações elípticas, como a equação de Laplace ou Poisson, utilizando métodos de diferenças finitas em malhas retangulares, com imposição de condições de contorno de Dirichlet, que especificam valores fixos da solução na fronteira do domínio.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Discretização da Equação de Laplace com Condições de Dirichlet",
                            "description": "Derivar o esquema de diferenças finitas centradas de segunda ordem para a equação de Laplace ∇²u = 0 em uma malha uniforme 2D, incorporando as condições de Dirichlet u = g na fronteira, resultando em um sistema linear Ax = b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão da Equação de Laplace e Condições de Dirichlet",
                                  "subSteps": [
                                    "Lembre-se da forma da equação de Laplace: ∇²u = 0 em um domínio Ω.",
                                    "Defina o problema de valor de contorno: u = g na fronteira ∂Ω (condições de Dirichlet homogêneas ou não-homogêneas).",
                                    "Discuta propriedades da solução: u é harmônica, máxima em fronteira, etc.",
                                    "Esboce um domínio retangular simples para visualização.",
                                    "Explique por que métodos numéricos são necessários para soluções não-analíticas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as propriedades da equação e condições de contorno.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Use analogias físicas como potencial eletrostático para intuitar.",
                                  "learningObjective": "Compreender o problema matemático subjacente e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir Laplace com Poisson (∇²u = f)",
                                    "Ignorar que condições de Dirichlet especificam u diretamente na fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição da Malha Uniforme 2D",
                                  "subSteps": [
                                    "Defina o domínio retangular [0,a] x [0,b] com passos h_x = a/(N+1), h_y = b/(M+1).",
                                    "Crie pontos internos: (i h_x, j h_y) para i=1..N, j=1..M.",
                                    "Rotule os pontos da malha como u_{i,j} ≈ u(x_i, y_j).",
                                    "Desenhe a malha para N=M=4 como exemplo.",
                                    "Discuta truncamento da soma de Taylor para precisão de segunda ordem."
                                  ],
                                  "verification": "Desenhe corretamente a malha e liste todos os pontos internos e de fronteira.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Software de desenho (ex: GeoGebra ou papel quadriculado)",
                                    "Calculadora para h_x, h_y"
                                  ],
                                  "tips": "Assuma malha quadrada (h_x = h_y = h) para simplificar inicialmente.",
                                  "learningObjective": "Configurar a discretização espacial do domínio.",
                                  "commonMistakes": [
                                    "Incluir pontos de fronteira como desconhecidos",
                                    "Erro no número de intervalos: N+1 pontos para N internos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação da Aproximação de Diferenças Finitas Centradas para ∇²u",
                                  "subSteps": [
                                    "Expanda u(x±h,y) e u(x,y±h) em séries de Taylor até ordem 4.",
                                    "Some as expansões: [u(x+h,y) + u(x-h,y) + u(x,y+h) + u(x,y-h) - 4u(x,y)] / h² ≈ ∇²u.",
                                    "Para ∇²u=0, obtenha u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0.",
                                    "Verifique consistência de segunda ordem: erro O(h²).",
                                    "Escreva a equação stencil de 5 pontos."
                                  ],
                                  "verification": "Derive a equação stencil corretamente a partir de Taylor.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Folha de derivadas parciais",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Divida por h² após somar as expansões para isolar ∇²u.",
                                  "learningObjective": "Derivar o esquema de diferenças finitas centradas de segunda ordem.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem 4 que cancelam",
                                    "Usar diferenças forward/backward em vez de centradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporação das Condições de Dirichlet e Montagem de Ax = b",
                                  "subSteps": [
                                    "Para pontos internos, escreva as equações do stencil.",
                                    "Para fronteira, fixe u_{i,j} = g(x_i,y_j) se na ∂Ω.",
                                    "Ordene os desconhecidos: vetor x com u_{1,1}, u_{1,2}, ..., u_{N,M}.",
                                    "Monte matriz A (tridiagonal por blocos) e vetor b incorporando g.",
                                    "Para exemplo 3x3 interno, mostre A 9x9 esparsa."
                                  ],
                                  "verification": "Monte Ax=b para malha 2x2 interna e verifique com solução conhecida.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Matlab/Python para matriz pequena",
                                    "Papel para montagem manual"
                                  ],
                                  "tips": "Use ordenação natural linha-por-linha para A simétrica positiva definida.",
                                  "learningObjective": "Formar o sistema linear completo pronto para resolução.",
                                  "commonMistakes": [
                                    "Não mover termos de fronteira para b",
                                    "Índices errados na vetorização"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação de Consistência e Preparação para Resolução",
                                  "subSteps": [
                                    "Confirme ordem de precisão via análise de erro local.",
                                    "Discuta propriedades de A: simétrica, definida positiva, dominante diagonalmente.",
                                    "Teste com problema analítico: u=x y em quadrado com g apropriado.",
                                    "Compare solução numérica com exata para h pequeno.",
                                    "Prepare para métodos iterativos como Gauss-Seidel."
                                  ],
                                  "verification": "Calcule erro para malha grosseira e refine.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Código Python/Matlab para solver simples"
                                  ],
                                  "tips": "Para Dirichlet não-homogênea, subtraia solução particular se possível.",
                                  "learningObjective": "Validar o esquema e preparar implementação.",
                                  "commonMistakes": [
                                    "Ignorar normalização de h se h_x ≠ h_y",
                                    "A não ser esparsa na implementação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o quadrado unitário com u=0 em x=0, x=1, y=0 e u=sin(π y) em y=1. Use malha 4x4 interna (h=1/5). Derive stencil, monte A (16x16), b com valores de fronteira, resolva e plote u_num vs u_exata = (sin(π y) x)/(1 - cosh(π) x + sinh(π) x) aproximada.",
                              "finalVerifications": [
                                "Stencil derivado corretamente: soma vizinhos -4u_ij =0.",
                                "Matriz A simétrica com 4 na diagonal, -1 nos off-diagonais.",
                                "Vetor b incorpora g corretamente em linhas de fronteira.",
                                "Ordem de precisão O(h²) confirmada por refinamento.",
                                "Solução numérica converge para analítica em malha fina.",
                                "Sistema pronto para solver direto ou iterativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação Taylor (cancelamento de termos pares).",
                                "Correta vetorização e montagem de A e b.",
                                "Identificação de propriedades de A (SPD).",
                                "Análise de erro e consistência.",
                                "Capacidade de aplicar a exemplo não-trivial.",
                                "Clareza em diagramas de malha e stencil."
                              ],
                              "crossCurricularConnections": [
                                "Física: Potencial eletrostático em placas condutoras.",
                                "Engenharia: Fluxo de calor estacionário em placas.",
                                "Computação: Implementação em Python/NumPy para solvers esparsos.",
                                "Matemática Aplicada: Teoria de autovalores para convergência iterativa.",
                                "Visualização: Uso de Matplotlib para contour plots de u."
                              ],
                              "realWorldApplication": "Simulação de campos eletrostáticos em capacitores irregulares, análise de tensão em circuitos impressos, modelagem de fluxo de água subterrânea estacionário em reservatórios, otimização de design térmico em eletrônicos para dissipação de calor uniforme."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Análise de Consistência e Convergência para Dirichlet",
                            "description": "Demonstrar a consistência do esquema de diferenças finitas para condições de Dirichlet via expansão de Taylor, provando erro de truncamento O(h²), e discutir convergência usando o teorema de Lax-Richtmyer para equações elípticas estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão do Problema de Dirichlet e Esquema de Diferenças Finitas",
                                  "subSteps": [
                                    "Recordar a equação elíptica estacionária: -Δu = f em domínio Ω com condições de Dirichlet u = g em ∂Ω",
                                    "Descrever a discretização em grade uniforme com passo h em ambas direções",
                                    "Derivar o stencil de 5 pontos para o laplaciano discreto: (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h²",
                                    "Explicar imposição de condições de Dirichlet usando valores conhecidos nos pontos de fronteira",
                                    "Definir a solução discreta u_h e o erro e_h = u - u_h em normas adequadas (ex: norma do máximo)"
                                  ],
                                  "verification": "Escrever corretamente o sistema linear Au_h = b para um domínio quadrado simples e identificar imposição de Dirichlet",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: LeVeque)",
                                    "Papel e lápis para diagramas de grade",
                                    "Notebook com Python/MATLAB para visualização opcional"
                                  ],
                                  "tips": "Desenhe a grade 2D e marque pontos interiores vs. fronteira para visualizar claramente",
                                  "learningObjective": "Compreender a formulação discreta do problema elíptico com Dirichlet",
                                  "commonMistakes": [
                                    "Confundir stencil central com forward/backward",
                                    "Ignorar pontos fantasmas desnecessários para Dirichlet pura",
                                    "Erro na escala por h² no laplaciano"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Prova de Consistência via Expansão de Taylor",
                                  "subSteps": [
                                    "Expandir u em Taylor ao redor de (x_i, y_j): u(x_i ± h, y_j) = u ± h u_x + (h²/2) u_xx ± ... até ordem h⁴",
                                    "Aplicar expansões semelhantes para direções y",
                                    "Substituir no operador discreto L_h u_{i,j} e simplificar termos",
                                    "Mostrar que L_h u - Δu = (h²/12)(u_{xxxx} + 2u_{xxyy} + u_{yyyy}) + O(h⁴), provando erro local de truncamento O(h²)",
                                    "Discutir consistência: ||L_h u - L u|| → 0 quando h → 0 para u suave"
                                  ],
                                  "verification": "Derivar explicitamente os termos de erro até O(h²) e confirmar independência de h para a equação exata",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Folha de cálculos simbólicos",
                                    "Software SymPy ou Mathematica para expansões automáticas",
                                    "Referência: capítulos sobre diferenças finitas"
                                  ],
                                  "tips": "Agrupe termos pares/impares sistematicamente; verifique coeficientes somando contribuições de cada vizinho",
                                  "learningObjective": "Dominar a análise de erro de truncamento para esquemas de diferenças finitas",
                                  "commonMistakes": [
                                    "Parar expansão em ordem baixa (h¹)",
                                    "Erros de sinal em derivadas pares",
                                    "Confundir erro local com global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise de Estabilidade do Esquema",
                                  "subSteps": [
                                    "Recordar princípio do máximo discreto para operadores de Laplace: solução u_h atinge máximo na fronteira",
                                    "Provar estabilidade em norma do infinito: ||u_h||_∞ ≤ ||g||_∞ + C ||f||_∞ h²",
                                    "Discutir análise espectral: autovalores do operador discreto limitados por 0 e 4/h²",
                                    "Verificar estabilidade uniforme em h para soluções suaves",
                                    "Comparar com norma L² usando desigualdades de Poincaré-Friedrichs"
                                  ],
                                  "verification": "Provar o princípio do máximo discreto para um exemplo 1D e generalizar para 2D",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre estabilidade elíptica",
                                    "Exemplos numéricos em Python para testar máximo"
                                  ],
                                  "tips": "Use indução ou soma telescópica para provar princípio do máximo",
                                  "learningObjective": "Entender critérios de estabilidade para métodos de diferenças em elípticas",
                                  "commonMistakes": [
                                    "Confundir estabilidade com consistência",
                                    "Ignorar dependência em h na norma",
                                    "Aplicar análise parabólica a elípticas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Convergência via Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Enunciar o teorema: para operadores lineares, consistência + estabilidade ⇒ convergência",
                                    "Citar consistência do passo 2: τ_h(u) = O(h²)",
                                    "Invocar estabilidade do passo 3: ||S_h|| ≤ K independente de h",
                                    "Concluir ||e_h|| ≤ K τ_h(u) h → O(h²) convergência",
                                    "Discutir extensões para condições de regularidade e malha não-uniforme"
                                  ],
                                  "verification": "Escrever prova completa de convergência O(h²) ligando os passos anteriores",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo original Lax-Richtmyer ou resumo em livro",
                                    "Resumo dos passos 1-3"
                                  ],
                                  "tips": "Lembre: teorema aplica a soluções exatas suaves; verifique hipóteses explicitamente",
                                  "learningObjective": "Aplicar teorema Lax-Richtmyer para provar convergência numérica",
                                  "commonMistakes": [
                                    "Omitir uniformidade da estabilidade",
                                    "Confundir ordem de consistência com convergência",
                                    "Ignorar linearidade do operador"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente -Δu = 2π² sin(πx) sin(πy) em Ω=[0,1]² com u=0 na fronteira (solução exata u=sin(πx)sin(πy)). Implemente solver iterativo (Gauss-Seidel) para malhas h=1/10, 1/20, 1/40. Compute erro em norma L∞ e plote log(erros) vs log(h) para verificar ordem 2 de convergência.",
                              "finalVerifications": [
                                "Derivação correta da expansão de Taylor com erro O(h²)",
                                "Prova válida do princípio do máximo discreto",
                                "Enunciado preciso do teorema Lax-Richtmyer",
                                "Cálculo numérico confirmando convergência O(h²) em exemplo prático",
                                "Explicação clara da ligação consistência-estabilidade-convergência",
                                "Identificação de hipóteses necessárias (suavidade, linearidade)"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de Taylor e erro de truncamento (30%)",
                                "Correção na análise de estabilidade e princípio do máximo (25%)",
                                "Aplicação rigorosa do teorema Lax-Richtmyer (20%)",
                                "Qualidade do exemplo numérico e verificação de ordem (15%)",
                                "Clareza conceitual e discussão de limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Equações de Poisson em eletrostática e mecânica dos fluidos incompressíveis",
                                "Computação: Implementação de solvers lineares esparsos (iterativos como multigrid)",
                                "Engenharia: Simulação de distribuições de temperatura em materiais heterogêneos",
                                "Estatística: Análise de erro e validação de modelos numéricos",
                                "Análise de Dados: Otimização de malhas em machine learning para PDEs"
                              ],
                              "realWorldApplication": "Simulações de potenciais elétricos em capacitores (engenharia elétrica), previsão de deformações em placas sob carga (engenharia mecânica), modelagem de fluxo de calor em reatores nucleares e otimização de redes de distribuição de energia."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Estabilidade e Resolução do Sistema Linear",
                            "description": "Analisar a estabilidade do método iterativo de Gauss-Seidel ou SOR aplicado ao sistema tridiagonal Toeplitz gerado pelas condições de Dirichlet, verificando monotonia e convergência diagonal dominante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir e Compreender o Sistema Tridiagonal Toeplitz para Condições de Dirichlet",
                                  "subSteps": [
                                    "Derive a discretização por diferenças finitas para a equação elíptica (ex: Laplace) com condições de Dirichlet homogêneas ou não-homogêneas.",
                                    "Identifique a estrutura tridiagonal Toeplitz da matriz A gerada: diagonais com 2/h², sub e super com -1/h².",
                                    "Escreva o sistema Ax = b explicitamente para uma malha 1D ou 2D.",
                                    "Verifique as propriedades simétricas e positivas definidas da matriz."
                                  ],
                                  "verification": "Construa a matriz A para n=5 e confirme que é tridiagonal Toeplitz com elementos corretos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Notas de aula sobre diferenças finitas",
                                    "Software MATLAB ou Python (NumPy)",
                                    "Papel e lápis para derivação manual"
                                  ],
                                  "tips": "Comece com o caso 1D simples para visualizar a estrutura antes de generalizar para 2D.",
                                  "learningObjective": "Compreender como condições de Dirichlet geram sistemas lineares tridiagonais Toeplitz em problemas elípticos.",
                                  "commonMistakes": [
                                    "Confundir condições de Dirichlet com Neumann na formulação da matriz",
                                    "Esquecer o fator 1/h² nos elementos da diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o Método Iterativo de Gauss-Seidel",
                                  "subSteps": [
                                    "Lembre a iteração de Gauss-Seidel: x^{(k+1)}_i = (b_i - sum_{j<i} a_{ij} x^{(k+1)}_j - sum_{j>i} a_{ij} x^{(k)}_j)/a_{ii} para sistema tridiagonal.",
                                    "Implemente o algoritmo em pseudocódigo ou código para matriz tridiagonal.",
                                    "Execute iterações manuais para um sistema pequeno (n=3) e observe o comportamento.",
                                    "Discuta requisitos gerais de convergência: matriz simétrica positiva definida."
                                  ],
                                  "verification": "Implemente Gauss-Seidel para um exemplo pequeno e verifique se converge para a solução exata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Implementação em Python/MATLAB",
                                    "Exemplos numéricos de livros de análise numérica"
                                  ],
                                  "tips": "Use relaxação sucessiva para acelerar; monitore o erro residual ||Ax - b||.",
                                  "learningObjective": "Dominar a aplicação de Gauss-Seidel a sistemas tridiagonais e identificar padrões de iteração.",
                                  "commonMistakes": [
                                    "Usar valores antigos incorretamente nos somatórios",
                                    "Não normalizar pelo pivô diagonal a_{ii}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o Método SOR e Parâmetro de Relaxação",
                                  "subSteps": [
                                    "Defina SOR: x^{(k+1)}_i = (1-ω) x^{(k)}_i + ω (b_i - sum_{j<i} ...)/a_{ii}, com 1<ω<2 para aceleração.",
                                    "Derive a relação entre SOR, Jacobi e Gauss-Seidel (ω=1 para GS).",
                                    "Escolha ω ótimo para matrizes Toeplitz tridiagonais (aprox. ω = 2 / (1 + sin(π/(n+1))).",
                                    "Implemente SOR e compare taxas de convergência com GS."
                                  ],
                                  "verification": "Para um sistema exemplo, teste ω=1 (GS) vs ω=1.5 e meça número de iterações para erro <10^{-6}.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Código Python/MATLAB com função SOR",
                                    "Gráficos de convergência (semilogy)"
                                  ],
                                  "tips": "Plote o erro vs iterações para visualizar aceleração; ω>2 diverge.",
                                  "learningObjective": "Entender como SOR acelera GS e otimizar ω para estabilidade.",
                                  "commonMistakes": [
                                    "Escolher ω muito grande causando divergência",
                                    "Confundir fórmula de SOR com SSOR (simétrica)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Dominância Diagonal, Monotonia e Condições de Convergência",
                                  "subSteps": [
                                    "Defina dominância diagonal estrita: |a_{ii}| > sum_{j≠i} |a_{ij}| para todo i.",
                                    "Para matriz Toeplitz tridiagonal de Dirichlet, prove que é rigorosamente diagonal dominante (2 > 1+1).",
                                    "Verifique monotonia: A M-matriz (diagonal dominante com a_{ij}≤0 off-diagonal).",
                                    "Aplique teoremas: GS/SOR converge se A diagonal dominante ou simétrica positiva definida."
                                  ],
                                  "verification": "Escreva prova matemática para dominância em A Toeplitz e confirme numericamente para n grande.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Teoremas de convergência (livro Burden/Faires)",
                                    "Wolfram Alpha para autovalores"
                                  ],
                                  "tips": "Para Toeplitz, autovalores conhecidos: use para raio espectral <1 em iterações.",
                                  "learningObjective": "Analisar condições suficientes para estabilidade e convergência de GS/SOR.",
                                  "commonMistakes": [
                                    "Confundir dominância fraca com estrita",
                                    "Ignorar sinal dos off-diagonais negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Estabilidade e Resolver Numericamente",
                                  "subSteps": [
                                    "Calcule raio espectral do iterador GS/SOR para Toeplitz (ρ <1 garante convergência).",
                                    "Simule estabilidade: compare soluções iterativas com exata (FFT ou analítica).",
                                    "Teste sensibilidade a h (refinamento malha) e ω.",
                                    "Conclua sobre estabilidade para condições de Dirichlet."
                                  ],
                                  "verification": "Execute simulação com n=100, confirme convergência em <100 iterações e erro global <10^{-8}.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código completo em Python (SciPy para solver direto como benchmark)",
                                    "Gráficos de solução e resíduos"
                                  ],
                                  "tips": "Use solver direto esparso como referência; monitore ||x^{k+1} - x^k||.",
                                  "learningObjective": "Avaliar estabilidade prática e validar teoria com experimentos numéricos.",
                                  "commonMistakes": [
                                    "Não usar tolerância adaptativa",
                                    "Comparar com solução errada"
                                  ]
                                },
                                {
                                  "practicalExample": "Para a equação -u''=f em [0,1] com u(0)=0, u(1)=sin(1), h=0.1 (n=9), matriz A tridiagonal Toeplitz [2,-1,-1]/h², aplique GS (ω=1) e SOR (ω=1.8). Monitore convergência até ||r||<10^{-10}, compare com solução exata via integrais ou solver direto.",
                                  "finalVerifications": [
                                    "Derivar corretamente a matriz Toeplitz para Dirichlet.",
                                    "Provar dominância diagonal para o sistema.",
                                    "Implementar GS/SOR convergentes para n=50.",
                                    "Calcular ω ótimo e demonstrar aceleração.",
                                    "Interpretar gráficos de erro mostrando monotonia e estabilidade."
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão na prova de dominância diagonal (100% correto).",
                                    "Eficiência numérica: SOR <50% iterações de GS.",
                                    "Análise qualitativa de estabilidade (raio espectral <1).",
                                    "Código limpo, comentado e reproduzível.",
                                    "Interpretação correta de resultados numéricos vs teoria."
                                  ],
                                  "crossCurricularConnections": [
                                    "Programação Científica (implementação NumPy/SciPy).",
                                    "Física Computacional (simulação de potenciais).",
                                    "Engenharia (análise de tensões em placas).",
                                    "Otimização Numérica (escolha de ω).",
                                    "Estatística Computacional (análise de erros)."
                                  ],
                                  "realWorldApplication": "Em modelagem de fluxo de calor estacionário em painéis solares (condições Dirichlet nas bordas), simulações de campos eletrostáticos em capacitores ou análise de deformações em estruturas aeronáuticas usando diferenças finitas."
                                }
                              ]
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Condições de Neumann em Equações Elípticas com Métodos de Diferenças Finitas",
                        "description": "Explora a implementação de condições de contorno de Neumann, que impõem a derivada normal ∂u/∂n = h na fronteira, utilizando aproximações de diferenças finitas de primeira ou segunda ordem para equações elípticas em domínios retangulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Aproximação de Condições de Neumann na Discretização",
                            "description": "Implementar diferenças finitas forward ou backward para a derivada normal ∂u/∂n = h em pontos de fronteira, ajustando o stencil interno para a equação de Poisson -∇²u = f, gerando matriz assimétrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão Teórica da Condição de Neumann e Discretização Interna da Equação de Poisson",
                                  "subSteps": [
                                    "Recordar a equação de Poisson: -∇²u = f em um domínio Ω.",
                                    "Entender a condição de Neumann: ∂u/∂n = h na fronteira Γ.",
                                    "Derivar a discretização por diferenças finitas centrais no interior: stencil de 5 pontos em 2D ou 3 em 1D.",
                                    "Verificar consistência de ordem O(h²) no interior.",
                                    "Desenhar uma grade uniforme e identificar pontos de fronteira."
                                  ],
                                  "verification": "Derive corretamente o stencil central e explique a condição de Neumann em palavras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece em 1D para simplicidade antes de ir para 2D.",
                                  "learningObjective": "Compreender os fundamentos da equação elíptica e sua discretização interna.",
                                  "commonMistakes": [
                                    "Confundir derivada normal com tangencial",
                                    "Esquecer o sinal negativo na Poisson"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aproximação da Derivada Normal ∂u/∂n = h na Fronteira",
                                  "subSteps": [
                                    "Escolher diferença forward (para fronteira esquerda) ou backward (direita): ex. (u_1 - u_0)/h ≈ ∂u/∂x.",
                                    "Identificar o vetor normal n na fronteira (ex: n = (1,0) em borda vertical).",
                                    "Ajustar para 2D: usar stencil assimétrico na direção normal.",
                                    "Verificar truncagem de erro O(h) na aproximação da derivada.",
                                    "Incorporar h diretamente na equação de fronteira."
                                  ],
                                  "verification": "Escreva a equação discreta para ∂u/∂n = h em um ponto de fronteira específico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Grade impressa ou software como MATLAB/Octave",
                                    "Calculadora simbólica (SymPy online)"
                                  ],
                                  "tips": "Teste com função conhecida exata para validar a aproximação.",
                                  "learningObjective": "Dominar a discretização de primeira ordem para derivadas de fronteira.",
                                  "commonMistakes": [
                                    "Usar diferença central na fronteira (inválida)",
                                    "Ignorar a direção do normal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajuste do Stencil Interno e Modificação da Equação na Fronteira",
                                  "subSteps": [
                                    "Combinar a condição de Neumann com o stencil de Laplace no ponto fronteiriço interno.",
                                    "Eliminar a incógnita fantasma fora da grade: ex. u_{-1} = u_1 - 2h h para forward.",
                                    "Substituir no stencil: gerar coeficientes assimétricos.",
                                    "Escrever a equação modificada para o ponto de fronteira.",
                                    "Verificar que a matriz local é assimétrica devido à fronteira."
                                  ],
                                  "verification": "Derive a linha da matriz correspondente ao ponto de fronteira e note a assimetria.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB/Python NumPy)",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use diagramas de stencil para visualizar fantasmas.",
                                  "learningObjective": "Aplicar a eliminação de fantasma para condições de Neumann.",
                                  "commonMistakes": [
                                    "Erro no sinal ao eliminar fantasma",
                                    "Manter stencil simétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construção da Matriz Global e Verificação Numérica",
                                  "subSteps": [
                                    "Montar a matriz esparsa A para toda a grade, incorporando linhas de fronteira Neumann.",
                                    "Confirmar que A é assimétrica e singular (precisa de normalização para Neumann puro).",
                                    "Implementar em código: gerar A e vetor b com f e h.",
                                    "Resolver Au = b com método iterativo (ex: GMRES para assimétrica).",
                                    "Testar convergência com malha refinada."
                                  ],
                                  "verification": "Gere a matriz para uma grade 5x5 e resolva um problema teste; verifique resíduos < 1e-6.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com SciPy/NumPy",
                                    "Jupyter Notebook",
                                    "Exemplo de código base para Poisson"
                                  ],
                                  "tips": "Use sparse matrices para eficiência; plote a solução.",
                                  "learningObjective": "Construir e resolver o sistema linear resultante.",
                                  "commonMistakes": [
                                    "Matriz simétrica por engano",
                                    "Não tratar singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e Análise de Erros",
                                  "subSteps": [
                                    "Escolher problema teste com solução exata (ex: u = x² em 1D).",
                                    "Computar erro L2 e ordem de convergência (esperado O(h) devido a Neumann).",
                                    "Analisar impacto da assimetria em solvers.",
                                    "Refinar malha e plotar erros.",
                                    "Documentar observações sobre estabilidade."
                                  ],
                                  "verification": "Erro diminui linearmente com h; matriz reconhecidamente assimétrica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Compare com Dirichlet para contrastar.",
                                  "learningObjective": "Validar a implementação através de análise de erros.",
                                  "commonMistakes": [
                                    "Esperar O(h²) em Neumann de 1ª ordem",
                                    "Ignorar normalização da solução"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -∇²u = 2π² sin(πx) sin(πy) em [0,1]² com ∂u/∂n = 0 em todas as bordas (Neumann homogêneo). Solução exata: u = sin(πx) sin(πy). Use h=0.1, implemente stencil ajustado, monte matriz assimétrica e resolva com SciPy.sparse.linalg.gmres. Verifique erro L∞ < 0.01.",
                              "finalVerifications": [
                                "Stencil na fronteira usa diferença forward/backward corretamente.",
                                "Matriz A é assimétrica (A ≠ A^T).",
                                "Sistema resolvido com resíduo < 1e-8.",
                                "Ordem de convergência O(h) confirmada em pelo menos 3 malhas.",
                                "Solução visualmente plausível (plote contornos).",
                                "Eliminação de fantasma sem vazamentos numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro L2 < 5% do máximo da solução.",
                                "Correção teórica: Derivação do stencil exata.",
                                "Implementação: Código reproduzível e eficiente (esparso).",
                                "Análise: Identifica assimetria e impacto em solvers.",
                                "Validação: Testes com soluções exatas em 1D e 2D.",
                                "Documentação: Explica ajustes na fronteira claramente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potencial eletrostático com fluxo de campo prescrito.",
                                "Computação Científica: Uso de solvers para matrizes assimétricas (GMRES, BiCGSTAB).",
                                "Engenharia Mecânica: Simulação de difusão com fluxo térmico na superfície.",
                                "Matemática Pura: Propriedades de operadores elípticos com fronteiras.",
                                "Programação: Manipulação de grids e matrizes esparsas em Python/Fortran."
                              ],
                              "realWorldApplication": "Em engenharia térmica, simular distribuição de temperatura em uma placa com fluxo de calor conhecido (h) na borda exposta, como em trocadores de calor ou isolamento industrial, usando diferenças finitas para otimizar designs sem solução analítica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Consistência e Tratamento da Condição de Compatibilidade",
                            "description": "Verificar consistência do esquema com condições de Neumann via análise de erro local O(h), e explicar a condição de compatibilidade ∫h ds = ∫f dΩ para existência de solução, com impactos na convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão das Condições de Neumann e Esquema de Diferenças Finitas",
                                  "subSteps": [
                                    "Relembrar a equação elíptica modelo: -Δu = f em Ω, com ∂u/∂n = h em ∂Ω.",
                                    "Explicar a diferença entre condições de Dirichlet (valor fixo) e Neumann (fluxo normal).",
                                    "Descrever a discretização por diferenças finitas em malha uniforme para o operador Laplaciano.",
                                    "Apresentar a stencil central para aproximação de derivadas de segunda ordem.",
                                    "Discutir adaptações na fronteira para condições de Neumann usando diferenças forward/backward."
                                  ],
                                  "verification": "Desenhar o stencil de diferenças finitas na fronteira e identificar os coeficientes para Neumann.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica II",
                                    "Livro 'Análise Numérica' de Burden & Faires",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Visualize a malha como uma grade quadrada para facilitar a compreensão das aproximações.",
                                  "learningObjective": "Compreender a formulação do problema e a discretização básica para condições de Neumann.",
                                  "commonMistakes": [
                                    "Confundir a aproximação de ∂u/∂n com diferenças centrais internas",
                                    "Ignorar a orientação da normal externa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise de Consistência via Erro de Truncagem Local O(h)",
                                  "subSteps": [
                                    "Derivar o erro de truncagem local para o Laplaciano interno: O(h²).",
                                    "Calcular o erro na fronteira para a aproximação de Neumann: demonstrar O(h).",
                                    "Comparar com condições de Dirichlet, onde o erro é O(h²) em toda a malha.",
                                    "Verificar consistência somando erros locais e analisando o esquema global.",
                                    "Implementar numericamente um exemplo simples para plotar o erro em função de h."
                                  ],
                                  "verification": "Calcular manualmente o erro de truncagem em um ponto de fronteira e confirmar O(h).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplo de código base para diferenças finitas"
                                  ],
                                  "tips": "Use expansão de Taylor para derivar erros; foque no termo linear em h na fronteira.",
                                  "learningObjective": "Analisar e quantificar a consistência do esquema numérico para Neumann.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/h na aproximação de primeira derivada",
                                    "Não considerar a assimetria na stencil de fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação e Explicação da Condição de Compatibilidade",
                                  "subSteps": [
                                    "Integrar a equação -Δu = f em Ω e aplicar o teorema da divergência: ∫∂Ω ∂u/∂n ds = ∫Ω f dΩ.",
                                    "Substituir ∂u/∂n = h na fronteira: obter ∫∂Ω h ds = ∫Ω f dΩ.",
                                    "Explicar que essa condição é necessária para existência de solução (até constantes).",
                                    "Discutir singularidade do sistema discreto e necessidade de remoção de uma equação.",
                                    "Verificar numericamente em um exemplo se a condição é satisfeita."
                                  ],
                                  "verification": "Derivar a condição ∫h ds = ∫f dΩ a partir do teorema da divergência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Teorema da divergência (folha de referência)",
                                    "Quadrado unitário como domínio exemplo"
                                  ],
                                  "tips": "Pense em termos de balanço global de fluxo: entrada deve igualar fonte.",
                                  "learningObjective": "Derivar e interpretar a condição de compatibilidade para existência de solução.",
                                  "commonMistakes": [
                                    "Confundir integral de linha com área",
                                    "Ignorar a normal apontando para fora"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Impactos na Convergência e Estratégias de Tratamento",
                                  "subSteps": [
                                    "Explicar como violação da compatibilidade causa falha na convergência do método iterativo.",
                                    "Discutir tratamento: projeção de h para satisfazer a condição discretizada.",
                                    "Analisar ordem de convergência reduzida para O(h) devido à fronteira Neumann.",
                                    "Implementar correção e comparar erros com/s em casos compatíveis.",
                                    "Explorar extensões para malhas não-uniformes ou elementos finitos."
                                  ],
                                  "verification": "Simular um problema incompatível e corrigir, observando melhora na convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para solver de Poisson-Neumann",
                                    "Gráficos de erro vs. h"
                                  ],
                                  "tips": "Use soma discreta na malha para aproximar ∫h ds e ∫f dΩ.",
                                  "learningObjective": "Avaliar impactos e aplicar tratamentos para garantir convergência.",
                                  "commonMistakes": [
                                    "Não normalizar a solução única até constante",
                                    "Usar solvers diretos sem checar rank deficiente"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 1 em Ω = [0,1]x[0,1] com ∂u/∂n = 0 em ∂Ω (isolamento). Verifique ∫∂Ω 0 ds = 0 = ∫Ω 1 dΩ? Não! Projete h projetado = média de f para compatibilidade, discretize com h=0.1, analise erro O(h) e convergência pós-correção.",
                              "finalVerifications": [
                                "Derivar corretamente o erro local O(h) na fronteira Neumann.",
                                "Explicar verbalmente a condição ∫h ds = ∫f dΩ e sua origem.",
                                "Identificar violação de compatibilidade em um exemplo numérico.",
                                "Demonstrar correção via projeção e melhora na convergência.",
                                "Comparar ordens de convergência Dirichlet vs. Neumann."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de erros de truncagem (O(h) vs. O(h²)).",
                                "Correta aplicação do teorema da divergência para compatibilidade.",
                                "Implementação numérica funcional com verificação de condição.",
                                "Análise qualitativa/quantitativa de impactos na convergência.",
                                "Clareza na explicação de tratamentos e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Lei de Gauss em eletrostática (potencial com fluxos de campo).",
                                "Programação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia Mecânica: Modelagem de fluxo de calor com isolamento.",
                                "Matemática Pura: Teoria de equações elípticas e espaços de Sobolev."
                              ],
                              "realWorldApplication": "Simulações de difusão térmica em materiais isolados (ex.: reatores nucleares), onde condições de Neumann modelam superfícies sem fluxo de calor, garantindo balanço energético via compatibilidade para precisão em previsões de temperatura."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Estabilidade e Métodos Iterativos para Neumann",
                            "description": "Avaliar estabilidade usando normas de matriz para o sistema com Neumann, comparando métodos como Jacobi modificado ou multigrid, e discutir dissipação numérica em aproximações de fronteira.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Discretização de Equações Elípticas com Condições de Neumann",
                                  "subSteps": [
                                    "Estude a equação modelo -Δu = f em domínio Ω com ∂u/∂n = g na fronteira ∂Ω.",
                                    "Derive o stencil de diferenças finitas de segunda ordem para pontos interiores e de fronteira Neumann.",
                                    "Monte o sistema linear Ax = b, incorporando condições de compatibilidade ∫f = ∫g.",
                                    "Verifique propriedades da matriz A: simetria, diagonal-dominância positiva e singularidade.",
                                    "Implemente numericamente em código para um grid 1D ou 2D simples."
                                  ],
                                  "verification": "Sistema Ax=b montado corretamente e resolvido para u exato conhecido, com erro <1e-4.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (e.g., LeVeque)",
                                    "Python com NumPy/SciPy",
                                    "Papel quadriculado"
                                  ],
                                  "tips": [
                                    "Use expansão de Taylor para derivar stencil de fronteira com precisão O(h^2).",
                                    "Sempre cheque compatibilidade para evitar singularidade irremediável."
                                  ],
                                  "learningObjective": "Dominar a formulação discreta correta para condições de Neumann em métodos de diferenças finitas.",
                                  "commonMistakes": [
                                    "Ignorar termo de compatibilidade levando a A singular.",
                                    "Stencil incorreto na fronteira causando assimetria em A."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar Estabilidade via Normas de Matriz",
                                  "subSteps": [
                                    "Revise normas de matriz: ||.||_1, ||.||_2, ||.||_∞ e sua relação com estabilidade.",
                                    "Para método de Richardson ou Gauss-Seidel, compute ||I - D^{-1}A|| <1.",
                                    "Aplique teorema de Gershgorin para estimar raio espectral de D^{-1}A.",
                                    "Calcule cond(A) e analise impacto na estabilidade iterativa.",
                                    "Teste numericamente em código: resolva Ax=b e monitore resíduo ||Ax-b||/||b||."
                                  ],
                                  "verification": "Norma ||I - M|| <1 calculada corretamente para pelo menos dois métodos, com evidência numérica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Documentação SciPy.linalg.norm",
                                    "Jupyter Notebook",
                                    "Exemplos de matrizes tridiagonais"
                                  ],
                                  "tips": [
                                    "Prefira norma ∞ para estabilidade prática em grids Cartesianos.",
                                    "Eigenvalues reais para A simétrica ajudam na análise espectral."
                                  ],
                                  "learningObjective": "Aplicar normas de matriz para quantificar estabilidade de solvers iterativos em sistemas Neumann.",
                                  "commonMistakes": [
                                    "Confundir norma de operador com norma vetorial.",
                                    "Não considerar diagonal-dominância fraca perto de fronteiras Neumann."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Métodos Iterativos: Jacobi Modificado e Multigrid",
                                  "subSteps": [
                                    "Implemente Jacobi padrão e modificado (SOR com ω ótimo) para Ax=b.",
                                    "Estude multigrid: pré-smooth V-cycle com restrição/injeção para Neumann.",
                                    "Compare taxas de convergência: iterações vs. resíduo para grids h=1/20, 1/40.",
                                    "Analise custo computacional: O(N) por iteração vs. O(N) multigrid independente de h.",
                                    "Otimize parâmetros: ω para SOR via ρ(D^{-1}(D-A))."
                                  ],
                                  "verification": "Gráficos de convergência mostrando multigrid superior em grids finos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "PyMultigrid ou código custom SciPy",
                                    "MATLAB para benchmark",
                                    "Artigos sobre MG para elípticas"
                                  ],
                                  "tips": [
                                    "Para Neumann, use Neumann prolongamento na fronteira.",
                                    "Monitore energia de erro para validar convergência ótima."
                                  ],
                                  "learningObjective": "Comparar eficiência de Jacobi modificado vs. multigrid em termos de estabilidade e velocidade.",
                                  "commonMistakes": [
                                    "ω mal escolhido causando divergência em Jacobi.",
                                    "Restrição inadequada propagando erro de fronteira."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Dissipação Numérica em Aproximações de Fronteira",
                                  "subSteps": [
                                    "Defina dissipação numérica: amortecimento de modos altos-frequência em iterações.",
                                    "Estude stencil Neumann: termo ghost point e sua dissipação via Fourier.",
                                    "Simule onda espúria na fronteira e meça taxa de dissipação ||e^{k+1}||/||e^k||.",
                                    "Compare com Dirichlet: explique por que Neumann dissipa menos em ângulos.",
                                    "Mitigue com upwinding ou preconditioners espectrais."
                                  ],
                                  "verification": "Análise Fourier mostrando dissipação <1 para modos >π/2, com gráfico de taxas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SymPy para análise simbólica",
                                    "Python Matplotlib para Fourier",
                                    "Referências em Gustafsson"
                                  ],
                                  "tips": [
                                    "Use análise von Neumann local para estabilidade explícita.",
                                    "Foco em cantos: dissipação anisotrópica comum."
                                  ],
                                  "learningObjective": "Identificar e quantificar dissipação numérica específica de fronteiras Neumann.",
                                  "commonMistakes": [
                                    "Assumir isotropia em stencil Neumann.",
                                    "Ignorar modos estacionários não dissipados."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -Δu = π² sin(πx) sin(πy) em [0,1]² com ∂u/∂n = 0 na fronteira (isolado). Use h=1/32, monte A (N≈1000), aplique Jacobi mod (ω=0.8) e MG V-cycle (2 pré/pós-smooth). Compare 50 iterações: erro Jacobi ~1e-2 vs. MG ~1e-6. Analise ||I-D^{-1}A||_∞=0.95 e dissipação em y=0.",
                              "finalVerifications": [
                                "Explicar corretamente por que normas matriz predizem estabilidade para Neumann.",
                                "Montar e resolver sistema 2D com h=1/20, erro <1e-3.",
                                "Comparar curvas de convergência Jacobi vs. multigrid em log-plot.",
                                "Identificar dissipação reduzida em stencil Neumann via exemplo numérico.",
                                "Discutir trade-offs: custo vs. robustez para grids irregulares.",
                                "Verificar compatibilidade ∫f=∫g numéricamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de stencils e normas (90% correção).",
                                "Correta implementação e interpretação de resultados numéricos.",
                                "Profundidade na comparação de métodos (taxas, custos).",
                                "Análise qualitativa/quantitativa de dissipação.",
                                "Clareza em gráficos e explicações teóricas.",
                                "Identificação de erros comuns e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos eletrostáticos com isolantes (Neumann=0).",
                                "Engenharia Mecânica: Análise de tensões em placas com bordas livres.",
                                "Ciência da Computação: Algoritmos paralelos para MG em HPC.",
                                "Otimização: Preconditioners baseados em normas para solvers lineares."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em paredes isoladas (Neumann=0) para design de edifícios eficientes, ou modelagem de potencial gravitacional em geofísica com fronteiras livres, onde multigrid garante soluções rápidas e estáveis em malhas grandes para previsão climática."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Métodos para Equações Hiperbólicas",
                    "description": "Esquemas explícitos e implícitos, com noções de dispersão e dissipação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Esquemas Explícitos para Equações Hiperbólicas",
                        "description": "Métodos numéricos explícitos baseados em diferenças finitas para resolver equações hiperbólicas, como a equação da onda, destacando a condição de Courant-Friedrichs-Lewy (CFL) para estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Implementar o esquema FTCS para a equação da onda",
                            "description": "Derivar e codificar o esquema Forward-Time Central-Space (FTCS) para a equação da onda unidimensional, identificando sua instabilidade incondicional e calculando o número de Courant.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivação teórica do esquema FTCS para a equação da onda",
                                  "subSteps": [
                                    "Escreva a equação da onda unidimensional: ∂²u/∂t² = c² ∂²u/∂x², onde u(x,t) é a deslocamento, c é a velocidade da onda.",
                                    "Discretize o domínio espacial em uma malha uniforme com passos Δx e pontos x_j = j Δx, j=0 a J.",
                                    "Discretize o tempo com passos Δt, t_n = n Δt, aproximando u(x_j, t_n) por u_j^n.",
                                    "Aplique a diferença finita forward-time para ∂²u/∂t²: (u_j^{n+1} - 2u_j^n + u_j^{n-1}) / (Δt)².",
                                    "Aplique central-space para ∂²u/∂x²: (u_{j+1}^n - 2u_j^n + u_{j-1}^n) / (Δx)².",
                                    "Combine para obter a fórmula de atualização: u_j^{n+1} = 2u_j^n - u_j^{n-1} + σ² (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde σ = c Δt / Δx."
                                  ],
                                  "verification": "Verifique se a fórmula derivada corresponde à forma padrão do FTCS e se as aproximações de diferenças finitas estão corretas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX",
                                    "Referência: Livro de análise numérica (ex: LeVeque 'Finite Difference Methods')"
                                  ],
                                  "tips": "Use notação consistente e desenhe a estêncil de diferenças finitas para visualizar as posições j-1, j, j+1.",
                                  "learningObjective": "Dominar a derivação exata do esquema FTCS a partir das diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir forward-time com central-time",
                                    "Esquecer o termo u_j^{n-1} na aceleração",
                                    "Erro no sinal do laplaciano"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação do esquema FTCS em código",
                                  "subSteps": [
                                    "Configure o ambiente de programação (Python com NumPy e Matplotlib).",
                                    "Defina parâmetros: L (comprimento), J (pontos espaciais), Δx = L/J, T (tempo total), N (passos temporais), Δt = T/N, σ = c Δt / Δx.",
                                    "Inicialize condições iniciais: u(x,0) = pluck (ex: triangular), ∂u/∂t(x,0)=0; use u^{1} via central difference ou similar.",
                                    "Implemente condições de contorno: Dirichlet u(0,t)=u(L,t)=0.",
                                    "Crie loop temporal: atualize u^{n+1} usando a fórmula FTCS para 2 ≤ n ≤ N.",
                                    "Visualize a solução com animação ou plots em tempo."
                                  ],
                                  "verification": "Execute o código e confirme que gera uma matriz u[J+1, N+1] sem erros de índice ou NaN iniciais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3",
                                    "Bibliotecas: numpy, matplotlib",
                                    "Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Use arrays 2D para u e armazene apenas 3 camadas (n-1, n, n+1) para eficiência em memória.",
                                  "learningObjective": "Codificar corretamente o esquema explícito FTCS com condições iniciais e de contorno.",
                                  "commonMistakes": [
                                    "Índices off-by-one em loops",
                                    "Não inicializar u^{n-1} corretamente",
                                    "Usar σ² incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo do número de Courant e análise de estabilidade",
                                  "subSteps": [
                                    "Defina o número de Courant σ = c Δt / Δx e explique seu significado físico (velocidade numérica vs física).",
                                    "Derive a condição de estabilidade via amplificação de Fourier: assuma modo u_j^n = ξ^n e^{i k j Δx}, obtenha |ξ| ≤ 1.",
                                    "Calcule o polinômio característico para FTCS: ξ² - 2(1 - 2σ² sin²(θ/2)) ξ + 1 = 0, onde θ = k Δx.",
                                    "Mostre que para qualquer σ > 0, existe θ tal que |ξ| > 1, provando instabilidade incondicional.",
                                    "Compare com esquemas estáveis como Leapfrog.",
                                    "Implemente função para plotar |ξ|_max vs σ."
                                  ],
                                  "verification": "Confirme analiticamente que max |ξ| > 1 para σ ≠ 0 e plote gráfico confirmando.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel para derivação",
                                    "Código Python para plot de estabilidade"
                                  ],
                                  "tips": "Use identidade trigonométrica sin²(θ/2) = (1 - cos θ)/2 para simplificar.",
                                  "learningObjective": "Compreender e provar a instabilidade incondicional do FTCS para equações hiperbólicas.",
                                  "commonMistakes": [
                                    "Confundir com condição CFL de parabólicas (σ ≤ 1)",
                                    "Erro no polinômio de amplificação",
                                    "Ignorar termo u^{n-1}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simulação numérica e demonstração de instabilidade",
                                  "subSteps": [
                                    "Execute simulações com diferentes σ (ex: 0.1, 0.5, 1.0).",
                                    "Monitore norma L2 ou máximo de ||u|| ao longo do tempo.",
                                    "Observe blow-up numérico: solução explode após poucos passos.",
                                    "Compare com solução analítica para corda pluckada: u(x,t) = soma de séries de Fourier.",
                                    "Gere plots e animações mostrando dispersão e instabilidade.",
                                    "Discuta mitigações: usar esquemas implícitos ou upwind."
                                  ],
                                  "verification": "Plots mostram crescimento exponencial de amplitude para qualquer σ, confirmando instabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código do Step 2 estendido",
                                    "Solução analítica via scipy ou manual"
                                  ],
                                  "tips": "Use dt pequeno inicialmente para ver evolução antes do blow-up.",
                                  "learningObjective": "Demonstrar empiricamente a instabilidade e contrastar com teoria.",
                                  "commonMistakes": [
                                    "Escolher Δt muito pequeno mascarando instabilidade",
                                    "Condições de contorno erradas",
                                    "Não normalizar solução"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma corda de violino pluckada (deslocamento inicial triangular no centro, velocidade zero). Implemente FTCS com L=1, c=1, σ=0.5. Observe que após ~20 passos temporais, a amplitude explode de O(1) para NaN, demonstrando instabilidade.",
                              "finalVerifications": [
                                "Derivação da fórmula FTCS está correta e matches literatura.",
                                "Código Python roda e produz plots iniciais coerentes.",
                                "Análise de Fourier prova |ξ| > 1 para algum modo.",
                                "Simulações mostram blow-up numérico para múltiplos σ.",
                                "Número de Courant σ é calculado corretamente em código.",
                                "Explicação escrita da instabilidade incondicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação teórica (fórmula exata, 30%).",
                                "Corretude e eficiência do código (sem erros, visualizações claras, 25%).",
                                "Profundidade da análise de estabilidade (prova + plots, 20%).",
                                "Demonstração empírica via simulações (blow-up observado, 15%).",
                                "Clareza na discussão de limitações e alternativas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica ondulatória e propagação de ondas.",
                                "Computação: Programação numérica e visualização científica com Python.",
                                "Engenharia: Simulações em acústica e engenharia estrutural.",
                                "Matemática: Análise de Fourier e estabilidade de PDEs."
                              ],
                              "realWorldApplication": "Embora instável, entender FTCS ajuda no desenvolvimento de solvers para simulações de ondas sísmicas, ultrassom médico e modelagem de cordas em instrumentos musicais, guiando para esquemas estáveis como Lax-Wendroff."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Analisar estabilidade do esquema Lax-Friedrichs",
                            "description": "Aplicar o método de von Neumann para analisar a estabilidade do esquema Lax-Friedrichs em equações de advecção hiperbólica, verificando a condição CFL ≤ 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de advecção hiperbólica e o esquema Lax-Friedrichs",
                                  "subSteps": [
                                    "Escreva a equação de advecção linear: ∂u/∂t + a ∂u/∂x = 0.",
                                    "Apresente a discretização do esquema Lax-Friedrichs: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (a Δt / (2 Δx)) (u_{j+1}^n - u_{j-1}^n).",
                                    "Identifique os termos de média e difusão artificial introduzidos pelo esquema.",
                                    "Defina os parâmetros: número de Courant CFL = a Δt / Δx.",
                                    "Discuta as propriedades do esquema: consistência de ordem 1."
                                  ],
                                  "verification": "Escreva corretamente a fórmula do esquema Lax-Friedrichs e identifique o termo de difusão.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque), caderno para anotações, calculadora"
                                  ],
                                  "tips": "Visualize o stencil do esquema no papel para entender a vizinhança de 3 pontos.",
                                  "learningObjective": "Compreender a formulação exata do esquema Lax-Friedrichs para equações de advecção.",
                                  "commonMistakes": [
                                    "Confundir com esquema Lax-Wendroff",
                                    "Esquecer o fator 1/2 na média",
                                    "Ignorar o sinal de 'a' na advecção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o método de von Neumann para análise de estabilidade",
                                  "subSteps": [
                                    "Explique o método: assumir solução u_j^n = g^n e^{i k j Δx}, onde g é o fator de amplificação.",
                                    "Substitua na equação discreta para obter g(k, CFL).",
                                    "Defina a condição de estabilidade: |g(k, CFL)| ≤ 1 + O(Δt) para todo k.",
                                    "Discuta o espectro de frequências: k de 0 a π/Δx.",
                                    "Lembre que para esquemas lineares com coeficientes constantes, von Neumann é aplicável."
                                  ],
                                  "verification": "Descreva os passos do método de von Neumann e escreva a forma assumida da solução.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Notas de aula sobre estabilidade, software como Python/MATLAB para plotar |g| (opcional)",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use ξ = k Δx para simplificar; foque em derivadas espectrais.",
                                  "learningObjective": "Dominar os fundamentos do método de von Neumann aplicado a esquemas explícitos.",
                                  "commonMistakes": [
                                    "Esquecer o expoente n em g^n",
                                    "Confundir g com o modo espacial",
                                    "Não normalizar |g| corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o fator de amplificação para o esquema Lax-Friedrichs",
                                  "subSteps": [
                                    "Substitua u_j^n = g^n e^{i k j Δx} na fórmula do esquema.",
                                    "Simplifique: g = [e^{iθ} + e^{-iθ}]/2 - (CFL/2)(e^{iθ} - e^{-iθ}), onde θ = k Δx.",
                                    "Use identidades trigonométricas: cosθ - i CFL sinθ.",
                                    "Obtenha |g|^2 = cos²θ + (1 - CFL²) sin²θ.",
                                    "Verifique para θ=0: |g|=1, e para θ=π: comportamento dissipativo."
                                  ],
                                  "verification": "Derive explicitamente a expressão de |g(θ, CFL)| e plote para CFL=0.5.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica), exemplos resolvidos de livros"
                                  ],
                                  "tips": "Trabalhe com θ = k Δx desde o início para evitar erros algébricos.",
                                  "learningObjective": "Derivar analiticamente o fator de amplificação g para Lax-Friedrichs.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo CFL",
                                    "Esquecer o i nas exponenciais imaginárias",
                                    "Não elevar ao quadrado corretamente para |g|^2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a condição de estabilidade e verificar CFL ≤ 1",
                                  "subSteps": [
                                    "Exija |g| ≤ 1 para todo θ: cos²θ + (1 - CFL²) sin²θ ≤ 1.",
                                    "Simplifique: (1 - CFL²) sin²θ ≤ sin²θ, implicando 1 - CFL² ≤ 1 (sempre) e análise máxima.",
                                    "Mostre que o máximo de |g| ocorre em θ=π/2: |g| = |1 - CFL|.",
                                    "Conclua que estabilidade requer |CFL| ≤ 1.",
                                    "Discuta dissipação: para CFL<1, o esquema é dissipativo em altas frequências."
                                  ],
                                  "verification": "Prove que |g| ≤ 1 iff |CFL| ≤ 1 e identifique o modo mais instável.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Gráficos de |g| vs θ para diferentes CFL",
                                    "Software para validação numérica"
                                  ],
                                  "tips": "Teste numericamente com uma simulação simples para confirmar.",
                                  "learningObjective": "Estabelecer e justificar a condição CFL ≤ 1 para estabilidade do Lax-Friedrichs.",
                                  "commonMistakes": [
                                    "Achar CFL ≤ 1/2 como em upwind",
                                    "Ignorar o caso CFL>1 onde |g|>1",
                                    "Confundir estabilidade com precisão"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o esquema Lax-Friedrichs em Python para advecção de uma gaussian: u_t + u_x = 0, com Δx=0.01, Δt=0.005 (CFL=0.5). Rode para 1000 passos e compare com CFL=1.2 para observar instabilidade (oscilações).",
                              "finalVerifications": [
                                "Deriva corretamente |g|^2 = cos²θ + (1 - CFL²) sin²θ.",
                                "Prova que max|g| = max(1, |1-CFL|).",
                                "Identifica CFL ≤ 1 como condição necessária e suficiente.",
                                "Explica o papel da difusão artificial na estabilidade.",
                                "Aplica von Neumann a um exemplo numérico simples.",
                                "Discute limitações para advecção não-linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica do fator g (sem erros de sinal ou trigonométricos).",
                                "Correta identificação da condição |CFL| ≤ 1 com justificativa espectral.",
                                "Análise qualitativa da dissipação em altas frequências.",
                                "Uso adequado do método von Neumann (assunção Fourier, normalização).",
                                "Capacidade de plotar e interpretar |g(θ)| para vários CFL.",
                                "Conexão com propriedades do esquema (consistência O(Δt + Δx))."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas ou tráfego veicular (equações hiperbólicas).",
                                "Computação: Implementação em CFD (Finite Differences em NumPy/SciPy).",
                                "Engenharia: Simulações em aerodinâmica (estabilidade numérica crítica).",
                                "Matemática Pura: Análise complexa e funções trigonométricas.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (previsão de frentes de chuva via modelos hiperbólicos) ou hidrodinâmica computacional (ondas de choque em tubos), onde esquemas estáveis como Lax-Friedrichs previnem blow-up numérico em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Verificar consistência e convergência de esquemas explícitos",
                            "description": "Demonstrar a consistência de ordem dois no espaço e um no tempo para esquemas explícitos padrão, relacionando com o teorema Lax de equivalência para convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de consistência em esquemas numéricos",
                                  "subSteps": [
                                    "Recordar a definição de consistência: um esquema é consistente se o erro de truncamento local (LTE) tende a zero quando Δt, Δx → 0.",
                                    "Estudar a expansão de Taylor para aproximar derivadas parciais em esquemas de diferenças finitas.",
                                    "Identificar componentes do LTE: termos de ordem baixa (O(Δt^p, Δx^q)) e ordens de precisão p no tempo e q no espaço.",
                                    "Exemplificar com a equação de advecção hiperbólica u_t + a u_x = 0."
                                  ],
                                  "verification": "Escrever a definição formal de consistência e derivar LTE para um esquema simples como FTCS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e caneta, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Sempre normalize o LTE dividindo pelo operador diferencial para isolar ordens de precisão.",
                                  "learningObjective": "Compreender conceitualmente consistência e sua medição via LTE.",
                                  "commonMistakes": "Confundir consistência com estabilidade; ignorar termos de ordem mista como O(Δt Δx)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o erro de truncamento local para esquemas explícitos padrão",
                                  "subSteps": [
                                    "Selecionar um esquema explícito padrão, como Lax-Wendroff para u_t + a u_x = 0: u_j^{n+1} = u_j^n - (λ/2)(u_{j+1}^n - u_{j-1}^n) + (λ²/2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n).",
                                    "Aplicar expansão de Taylor multivariável em torno de (x_j, t_n) para u_j^{n+1}, u_{j±1}^n.",
                                    "Substituir na PDE e coletar termos: identificar O(Δt) no tempo e O(Δx²) no espaço.",
                                    "Calcular explicitamente os coeficientes do LTE e confirmar ordens (1 no tempo, 2 no espaço).",
                                    "Verificar para esquemas como upwind ou Lax-Friedrichs para comparação."
                                  ],
                                  "verification": "Derivação completa do LTE mostrando termos líderes O(Δt) e O(Δx²), sem erros algébricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de cálculo para expansões Taylor, software simbólico para simplificação.",
                                  "tips": "Use notação compacta: expanda até ordem 2 em Δx e 1 em Δt inicialmente.",
                                  "learningObjective": "Dominar cálculo analítico de LTE para esquemas explícitos hiperbólicos.",
                                  "commonMistakes": "Erros em expansões Taylor (esquecer fatores 1/k!); não truncar corretamente ordens superiores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar ordem de consistência e relacionar com convergência via Teorema Lax",
                                  "subSteps": [
                                    "Definir ordem de consistência: p no tempo se LTE = O(Δt^p + Δx^q), aqui p=1, q=2.",
                                    "Estudar Teorema Lax de equivalência: consistência + estabilidade ⇒ convergência.",
                                    "Discutir condição CFL para estabilidade em esquemas explícitos hiperbólicos.",
                                    "Verificar que para esquemas padrão, consistência de ordem (1,2) implica convergência sob estabilidade.",
                                    "Explorar contraexemplos: esquemas inconsistentes não convergem mesmo estáveis."
                                  ],
                                  "verification": "Enunciar teorema Lax corretamente e justificar convergência para o esquema analisado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Notas de aula sobre estabilidade (von Neumann), referências ao teorema Lax-Richtmyer.",
                                  "tips": "Lembre: convergência é ||u_num - u_exata|| → 0; consistência é pré-requisito.",
                                  "learningObjective": "Conectar análise de consistência à garantia teórica de convergência.",
                                  "commonMistakes": "Omitir necessidade de estabilidade; confundir Lax-Friedrichs (ordem 1,1) com Lax-Wendroff."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar consistência e convergência numericamente para validação",
                                  "subSteps": [
                                    "Implementar o esquema em código (Python/MATLAB) para equação de advecção com solução exata.",
                                    "Refinar malha: variar Δt, Δx e computar erros L2 ou L∞ em função de h = Δx.",
                                    "Estimar ordens de convergência via log-log plot: log(erro) vs log(h), inclinação ≈1 (tempo domina).",
                                    "Confirmar consistência observando erro →0; testar regimes CFL para estabilidade.",
                                    "Comparar com solução exata em t fixo."
                                  ],
                                  "verification": "Gráficos mostrando convergência de ordem ~1, com erro diminuindo monotonicamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com NumPy/Matplotlib, solução exata pré-computada.",
                                  "tips": "Use Δt = λ Δx com λ fixo < CFL para isolar consistência.",
                                  "learningObjective": "Validar teoria analítica com evidência computacional.",
                                  "commonMistakes": "Não controlar CFL levando a instabilidade; escalas log erradas em plots."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x = 0 com u(x,0)=sen(2πx), use Lax-Wendroff: derive LTE mostrando O(Δt + Δx²), implemente em Python com Δx=1/100, λ=0.5, plote erro L2 vs tempo confirmando convergência ordem 1.",
                              "finalVerifications": [
                                "LTE derivado corretamente com ordens 1 no tempo e 2 no espaço.",
                                "Teorema Lax enunciado e aplicado ao esquema.",
                                "Código numérico roda sem erros e mostra convergência.",
                                "Plot log-log confirma ordem observada.",
                                "Discussão de limitações (ex: não-dissipativo) incluída.",
                                "Referências cruzadas com estabilidade CFL."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor e LTE (80% pesos).",
                                "Correta aplicação do teorema Lax (15%).",
                                "Validação numérica robusta e plots claros (5%).",
                                "Clareza na explicação de ordens e relação tempo-espaço.",
                                "Identificação de erros comuns e dicas preventivas.",
                                "Coerência geral e ausência de inconsistências matemáticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas ou transporte em fluidos.",
                                "Computação: Implementação eficiente em solvers PDE (CFD).",
                                "Engenharia: Simulações numéricas em aerodinâmica.",
                                "Estatística: Análise de erros de aproximação e convergência empírica."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos de previsão de tempo), esquemas explícitos consistentes garantem precisão em propagação de frentes de onda; em CFD para aviação, convergência assegura simulações confiáveis de fluxos supersônicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Esquemas Implícitos para Equações Hiperbólicas",
                        "description": "Métodos numéricos implícitos que resolvem sistemas lineares em cada passo de tempo, oferecendo estabilidade incondicional para equações hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Formular o esquema implícito backward para a equação da onda",
                            "description": "Derivar o esquema Backward-Time Central-Space (BTCS) para a equação da onda, configurando o sistema tridiagonal para resolução via Thomas algorithm.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação da onda e definir a grade de discretização",
                                  "subSteps": [
                                    "Escreva a equação da onda unidimensional: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Defina a grade espacial uniforme com Δx e pontos x_i = i Δx, i=0 a N.",
                                    "Defina a grade temporal com Δt e níveis t^n = n Δt.",
                                    "Introduza a notação u_i^n ≈ u(x_i, t^n).",
                                    "Calcule o parâmetro de Courant r = c Δt / Δx."
                                  ],
                                  "verification": "Confirme que a grade está corretamente definida e r é calculado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora; referência ao livro de análise numérica.",
                                  "tips": "Desenhe a grade espacial e temporal para visualizar melhor.",
                                  "learningObjective": "Entender a discretização básica da equação da onda.",
                                  "commonMistakes": "Confundir notação u_i^n com u^n_i ou errar o cálculo de r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a aproximação Backward-Time Central-Space (BTCS)",
                                  "subSteps": [
                                    "Aproxime ∂²u/∂t² em (x_i, t^{n+1}) usando diferenças backward: (u_i^{n+1} - 2u_i^n + u_i^{n-1}) / (Δt)².",
                                    "Aproxime ∂²u/∂x² em (x_i, t^{n+1}) usando diferenças centrais: (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) / (Δx)².",
                                    "Substitua na equação da onda para obter a forma implícita.",
                                    "Iguale os lados e multiplique por (Δt)² para clareza.",
                                    "Simplifique para: u_i^{n+1} - 2u_i^n + u_i^{n-1} = r² (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1})."
                                  ],
                                  "verification": "Verifique se a equação BTCS está balanceada e implícita em n+1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, livro de métodos numéricos para EDPs.",
                                  "tips": "Use símbolos consistentes e isole termos em n+1.",
                                  "learningObjective": "Derivar corretamente a stencil BTCS para equação hiperbólica.",
                                  "commonMistakes": "Usar forward em vez de backward no tempo ou errar o sinal nas diferenças centrais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reorganizar a equação em forma implícita padrão",
                                  "subSteps": [
                                    "Traga todos os termos de u^{n+1} para o lado esquerdo.",
                                    "Escreva: -r² u_{i-1}^{n+1} + (1 + 2 r²) u_i^{n+1} - r² u_{i+1}^{n+1} = u_i^{n+1} - 2u_i^n + u_i^{n-1}, corrigindo para o lado direito correto.",
                                    "Corrija: lado direito é u_i^{n-1} - 2u_i^n + u_i^{n+1}, não, revise: na verdade, do passo anterior, rearranje para ax u_{i-1} + b u_i + c u_{i+1} = d.",
                                    "Defina coeficientes: a = -r², b = 1 + 2 r², c = -r², d = u_i^{n-1} - 2 u_i^n + u_i^{n+1} wait, erro comum: d correto é u_i^n - 2 u_i^{n-1} wait no.",
                                    "Forma final: -r² u_{i-1}^{n+1} + (2 + 2/r²? wait padrão BTCS para onda é específico: confirme d = (Δt/Δx)^2 * known terms, mas padrão é d_i = u_i^{n} - 2 u_i^{n-1} + something? Use referência precisa."
                                  ],
                                  "verification": "A equação deve ter forma tridiagonal implícita com coeficientes simétricos a=c=-r², b=1+2r².",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referência específica (e.g., LeVeque's Finite Difference Methods), software como Mathematica para verificar.",
                                  "tips": "Anote coeficientes a, b, c explicitamente para cada i.",
                                  "learningObjective": "Reorganizar stencil em sistema linear implícito.",
                                  "commonMistakes": "Errar o lado direito: deve ser u_i^{n-1} - 2u_i^n (para leapfrog-like, mas BTCS padrão para onda usa u^{n+1} implícito com known n e n-1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar o sistema tridiagonal e preparar para Thomas algorithm",
                                  "subSteps": [
                                    "Escreva o sistema para i=1 a N-1: a u_{i-1}^{n+1} + b u_i^{n+1} + c u_{i+1}^{n+1} = d_i, com condições de contorno u_0 = u_N =0.",
                                    "Defina vetor U^{n+1} = [u_1^{n+1}, ..., u_{N-1}^{n+1}]^T, d_i = u_i^{n-1} - 2 u_i^n.",
                                    "Note que matriz A é tridiagonal com diagonais a, b, c constantes.",
                                    "Revise Thomas algorithm: decomposição LU para tridiagonal.",
                                    "Especifique passos iniciais: forward sweep para fatores, backward para solução."
                                  ],
                                  "verification": "Matriz A montada com dimensões (N-1)x(N-1), tridiagonal confirmada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Matriz escrita à mão ou Python/MATLAB para montar A pequena.",
                                  "tips": "Teste com N=3 para verificar manualmente.",
                                  "learningObjective": "Montar sistema Ax=b tridiagonal para BTCS.",
                                  "commonMistakes": "Esquecer condições de contorno ou errar d_i (deve depender de níveis anteriores)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar estabilidade e consistência do esquema BTCS",
                                  "subSteps": [
                                    "Analise consistência: ordens de truncagem O(Δt² + Δx²).",
                                    "Para estabilidade, BTCS é incondicionalmente estável para equação da onda.",
                                    "Von Neumann: símbolo amplificação |g| ≤1 para todos k.",
                                    "Confirme convergência via Lax equivalence.",
                                    "Discuta por que implícito é estável vs explícito CFL restrito."
                                  ],
                                  "verification": "Demonstre |g(θ)| ≤1 graficamente ou analiticamente para θ=0,π.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico de símbolo de amplificação, software como Python para plot.",
                                  "tips": "Foquem em θ=0 (g=1) e θ=π (g depende r mas |g|<1).",
                                  "learningObjective": "Entender propriedades do esquema BTCS.",
                                  "commonMistakes": "Confundir com FTCS explícito instável."
                                }
                              ],
                              "practicalExample": "Considere c=1, L=1, Δx=0.1 (N=10), Δt=0.05 (r=0.5). Condições iniciais u(x,0)=sin(πx), ∂u/∂t=0. Condição de Dirichlet u(0,t)=u(1,t)=0. Monte A tridiagonal e resolva para n=1 usando Thomas manualmente para primeiros passos.",
                              "finalVerifications": [
                                "Equação BTCS derivada corretamente com coeficientes a=-r², b=1+2r², c=-r².",
                                "Sistema tridiagonal Ax=b configurado com d_i = u_i^{n-1} - 2u_i^n.",
                                "Condições de contorno incorporadas corretamente.",
                                "Thomas algorithm aplicável confirmado (diagonal dominante).",
                                "Estabilidade incondicional verificada via análise Von Neumann.",
                                "Exemplo numérico resolvido para pelo menos um passo sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da stencil BTCS (100% match com fórmula padrão).",
                                "Correta montagem da matriz tridiagonal e vetor b.",
                                "Identificação correta de propriedades (consistência O(Δt²,Δx²), estabilidade).",
                                "Explicação clara do papel do Thomas algorithm.",
                                "Ausência de erros algébricos nos coeficientes.",
                                "Aplicação coerente das condições de contorno."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas em cordas ou acústica.",
                                "Computação: Implementação de solvers lineares em Python/NumPy.",
                                "Engenharia: Simulações em engenharia sísmica ou aeroacústica.",
                                "Matemática Aplicada: Teoria de EDPs e análise de estabilidade."
                              ],
                              "realWorldApplication": "Usado em simulações numéricas de propagação de ondas sísmicas para previsão de terremotos, modelagem acústica em design de alto-falantes, ou simulações de ondas eletromagnéticas em telecomunicações, onde estabilidade incondicional permite passos de tempo maiores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Comparar estabilidade explícito vs. implícito",
                            "description": "Comparar as regiões de estabilidade no plano (Δt/Δx, kΔx) para esquemas explícitos e implícitos, destacando a vantagem da estabilidade incondicional dos implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade em métodos numéricos",
                                  "subSteps": [
                                    "Relembrar o que é estabilidade numérica e o critério de von Neumann para análise de estabilidade.",
                                    "Identificar diferenças entre esquemas explícitos e implícitos em termos de resolução de sistemas lineares.",
                                    "Estudar a equação de onda 1D como exemplo de equação hiperbólica: ∂u/∂t + c ∂u/∂x = 0.",
                                    "Definir os parâmetros CFL: λ = c Δt / Δx e k = Δt / Δx.",
                                    "Explicar o plano de estabilidade (eixo x: kΔx, eixo y: Δt/Δx)."
                                  ],
                                  "verification": "Resumir em um parágrafo as diferenças chave entre explícito e implícito, confirmando com referências de livros como LeVeque.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Finite Difference Methods for ODEs and PDEs' de Randall LeVeque (capítulos relevantes)",
                                    "Notas de aula sobre análise numérica",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use diagramas para visualizar diferenças antes de mergulhar em cálculos.",
                                  "learningObjective": "Compreender os fundamentos teóricos que precedem a comparação de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com consistência",
                                    "Ignorar o papel do fator de amplificação ξ na análise de von Neumann"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar condições de estabilidade para esquemas explícitos",
                                  "subSteps": [
                                    "Escolher um esquema explícito padrão, como Lax-Friedrichs ou upwind para equação de advecção.",
                                    "Aplicar análise de von Neumann: assumir solução u_j^n = ξ^n e^{i κ j Δx} e calcular |ξ| ≤ 1.",
                                    "Derivar a região de estabilidade: para Lax-Friedrichs, |λ| ≤ 1 onde λ = c Δt / Δx.",
                                    "Plotar a região no plano (Δt/Δx vs. kΔx) usando software como Python/Matplotlib.",
                                    "Analisar restrições: estabilidade condicional, tipicamente Δt ≤ Δx / |c|."
                                  ],
                                  "verification": "Gerar um gráfico da região de estabilidade explícita e anotar os limites CFL.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Código template para análise von Neumann",
                                    "Artigo sobre esquemas para EDOs hiperbólicas"
                                  ],
                                  "tips": "Comece com o caso simples c=1 para simplificar cálculos.",
                                  "learningObjective": "Calcular e visualizar a região de estabilidade condicional dos explícitos.",
                                  "commonMistakes": [
                                    "Erro no cálculo do fator de amplificação",
                                    "Esquecer termos de difusão numérica em Lax-Friedrichs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar condições de estabilidade para esquemas implícitos",
                                  "subSteps": [
                                    "Selecionar um esquema implícito, como o método de Crank-Nicolson ou implícito backward para advecção.",
                                    "Realizar análise de von Neumann similar, resolvendo o sistema tridiagonal para ξ.",
                                    "Mostrar que |ξ| ≤ 1 para todos λ reais, provando estabilidade incondicional.",
                                    "Plotar a região de estabilidade: todo o semiplano esquerdo no plano complexo.",
                                    "Comparar numericamente com explícito usando o mesmo código de plotagem."
                                  ],
                                  "verification": "Confirmar que o gráfico da implícita cobre toda a área permitida sem restrições de Δt.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmo ambiente Python do Step 2",
                                    "Documentação SciPy para solvers lineares",
                                    "Notas derivadas à mão"
                                  ],
                                  "tips": "Use aproximações analíticas para esquemas lineares antes de generalizar.",
                                  "learningObjective": "Demonstrar matematicamente a estabilidade incondicional dos implícitos.",
                                  "commonMistakes": [
                                    "Confundir esquemas implícitos lineares com não-lineares",
                                    "Ignorar custo computacional na verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar regiões de estabilidade e discutir vantagens",
                                  "subSteps": [
                                    "Sobrepor gráficos das regiões explícita e implícita no mesmo plano.",
                                    "Quantificar vantagens: implícitos permitem Δt >> Δx, ideais para simulações longas.",
                                    "Discutir desvantagens: custo por passo (inversão de matriz vs. explícito local).",
                                    "Realizar teste numérico simples: simular pulso de onda com Δt grande em implícito vs. falha em explícito.",
                                    "Concluir com tabela comparativa: estabilidade, precisão, custo."
                                  ],
                                  "verification": "Criar uma tabela e gráfico comparativos salvos em PDF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python para simulação e plot",
                                    "Exemplo de código de simulação de onda 1D"
                                  ],
                                  "tips": "Use animações para visualizar propagação estável vs. instável.",
                                  "learningObjective": "Sintetizar a comparação e destacar aplicações práticas.",
                                  "commonMistakes": [
                                    "Superestimar estabilidade implícita ignorando precisão de fase",
                                    "Não considerar escalabilidade para 2D/3D"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção ∂u/∂t + ∂u/∂x = 0 com u(x,0) = sen(2πx) em [0,1]. Use esquema explícito Lax-Friedrichs com Δx=0.01; falha se Δt>0.5Δx. Agora use implícito backward com Δt=0.1 (10x maior); observe estabilidade mantida após 10 períodos, plotando u em t=10.",
                              "finalVerifications": [
                                "Pode derivar corretamente |ξ| para ambos esquemas.",
                                "Gera gráficos precisos das regiões de estabilidade sobrepostas.",
                                "Explica verbalmente a vantagem incondicional dos implícitos.",
                                "Realiza simulação numérica demonstrando falha explícita vs. sucesso implícito.",
                                "Identifica trade-offs em custo computacional.",
                                "Compara com esquemas híbridos como IMEX."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de estabilidade (90% correto).",
                                "Qualidade e legibilidade dos gráficos no plano de estabilidade.",
                                "Profundidade da comparação qualitativa e quantitativa.",
                                "Correção na simulação prática com diferentes Δt.",
                                "Clareza na discussão de vantagens/desvantagens.",
                                "Uso adequado de terminologia (CFL, von Neumann, incondicional)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas em meios elásticos ou acústicos.",
                                "Computação Científica: Otimização de solvers lineares com bibliotecas como PETSc.",
                                "Engenharia: Simulações CFD onde passos de tempo grandes são cruciais.",
                                "Matemática Aplicada: Análise de erros em métodos multiescala."
                              ],
                              "realWorldApplication": "Em modelagem sísmica ou previsão de tsunamis, esquemas implícitos permitem simular eventos de longa duração sem restrições CFL severas, reduzindo tempo de computação em supercomputadores para grids finos em 3D."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Noções de Dispersão em Esquemas Numéricos",
                        "description": "Análise do erro de dispersão, onde diferentes comprimentos de onda propagam em velocidades numéricas distintas, afetando a precisão de ondas em equações hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Calcular o erro de dispersão via análise de von Neumann",
                            "description": "Usar a análise espectral de von Neumann para computar a velocidade de fase numérica e compará-la com a exata, identificando dispersão em esquemas como Lax-Wendroff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise de von Neumann",
                                  "subSteps": [
                                    "Estude a equação de adveção linear ∂u/∂t + c ∂u/∂x = 0 como modelo para dispersão.",
                                    "Aprenda a assumir solução de Fourier u_j^n = ξ^n e^{i k j Δx} para análise modal.",
                                    "Entenda o fator de amplificação ξ(k Δx) e a condição CFL |ξ| ≤ 1 para estabilidade.",
                                    "Revise a velocidade de fase exata ω_exact = c k e a definição de dispersão.",
                                    "Pratique derivando ξ para esquemas simples como FTCS."
                                  ],
                                  "verification": "Derive corretamente ξ para o esquema FTCS e verifique |ξ| > 1 para instabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque), caderno de anotações, calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Use ondas de Fourier de alta frequência (k Δx ≈ π) para identificar problemas de dispersão.",
                                  "learningObjective": "Compreender os princípios espectrais da análise de von Neumann para esquemas hiperbólicos.",
                                  "commonMistakes": [
                                    "Confundir fator de amplificação ξ com velocidade de fase",
                                    "Ignorar a dependência em k Δx",
                                    "Esquecer normalização da frequência angular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Símbolo do Esquema Lax-Wendroff",
                                  "subSteps": [
                                    "Escreva o esquema Lax-Wendroff: u_j^{n+1} = u_j^n - (σ/2)(u_{j+1}^n - u_{j-1}^n) + (σ²/2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde σ = c Δt / Δx.",
                                    "Substitua a forma de Fourier u_j^n = ξ^n e^{i θ j}, com θ = k Δx.",
                                    "Simplifique para obter ξ(θ) = 1 - i σ sin(θ) - (σ²/2)(1 - cos(θ)).",
                                    "Verifique estabilidade: |ξ(θ)| ≤ 1 para |σ| ≤ 1.",
                                    "Plote |ξ(θ)| vs θ para visualizar dissipação/dispersão."
                                  ],
                                  "verification": "Obtenha ξ(θ) exata e confirme |ξ(π)| = 1 para σ=1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (Matplotlib/Python), papel quadriculado"
                                  ],
                                  "tips": "Expanda sin(θ) e cos(θ) em termos de exponenciais complexas para simplificar.",
                                  "learningObjective": "Derivar o polinômio símbolo ξ(θ) para esquemas de segunda ordem.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo Lax (central difference)",
                                    "Confundir σ com Courant number diretamente",
                                    "Não expandir corretamente os operadores de diferença finita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Velocidade de Fase Numérica",
                                  "subSteps": [
                                    "Defina velocidade de fase numérica v_phase_num = - (1/k) Im[log(ξ)/Δt].",
                                    "Aproxime arg(ξ) ≈ ω_num Δt, onde ω_num = v_phase_num k.",
                                    "Compute ω_num(θ) = - arg(ξ(θ)) / Δt e v_phase_num = ω_num / k.",
                                    "Compare com v_phase_exact = c para vários θ.",
                                    "Calcule erro de dispersão δ = |v_phase_num - c| / c."
                                  ],
                                  "verification": "Para θ pequeno, v_phase_num ≈ c (1 - θ²/6 σ² (1-σ²)); verifique numericamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Complex para arg() e log()",
                                    "Gráficos de v_phase vs θ"
                                  ],
                                  "tips": "Use imag(log(ξ)) para precisão em fase; evite atan2 para ângulos multi-turn.",
                                  "learningObjective": "Extrair e computar velocidades de fase a partir de ξ(θ).",
                                  "commonMistakes": [
                                    "Usar Re[log(ξ)] em vez de Im para fase",
                                    "Esquecer divisão por Δt ou k",
                                    "Não normalizar pelo valor exato"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Quantificar Erro de Dispersão",
                                  "subSteps": [
                                    "Plote v_phase_num(θ)/c vs θ para σ=0.5, 1.0 e identifique dispersão (ondas altas viajam mais devagar).",
                                    "Integre erro de dispersão sobre espectro: ∫ |δ(θ)|^2 dθ.",
                                    "Compare com esquemas como upwind (alta dispersão) vs Lax-Wendroff (baixa).",
                                    "Discuta implicações: oscilações atrás da frente de onda.",
                                    "Gere relatório com gráficos e tabela de erros para θ=0, π/4, π/2, π."
                                  ],
                                  "verification": "Mostre que Lax-Wendroff tem dispersão O(θ^4), superior a O(θ^2) de upwind.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python completo para análise espectral",
                                    "Referências: papers sobre von Neumann"
                                  ],
                                  "tips": "Teste com σ próximo a 1 para maximizar estabilidade sem dissipação.",
                                  "learningObjective": "Interpretar e quantificar dispersão numérica em esquemas hiperbólicos.",
                                  "commonMistakes": [
                                    "Plotar apenas |ξ| ignorando fase",
                                    "Confundir dispersão com dissipação",
                                    "Não variar σ ou θ adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Aplique à equação de adveção u_t + u_x = 0 com σ=0.9 no esquema Lax-Wendroff. Compute ξ(θ) para θ=π/2, encontre v_phase_num ≈ 0.85c (erro 15%), e plote mostrando ondas curtas atrasadas, simulando propagação de pacotes de onda em CFD.",
                              "finalVerifications": [
                                "Derivação correta de ξ(θ) para Lax-Wendroff sem erros algébricos.",
                                "Gráfico preciso de v_phase_num(θ)/c com dispersão visível para θ altos.",
                                "Cálculo numérico de erro médio de dispersão <5% para σ=1.",
                                "Explicação qualitativa: por que Lax-Wendroff dispersa menos que Leapfrog.",
                                "Código Python reproduzível que gera plots e tabela de erros.",
                                "Identificação de θ onde dispersão é máxima (ex: θ=π)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de ξ(θ) (90% correto).",
                                "Qualidade dos gráficos: eixos rotulados, múltiplos σ, legenda clara.",
                                "Correção no cálculo de v_phase_num usando arg(ξ).",
                                "Análise qualitativa de implicações da dispersão.",
                                "Quantificação do erro com métrica integrada ou tabela.",
                                "Eficiência computacional: código vetorizado sem loops desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em mecânica quântica (dispersão de pacotes).",
                                "Computação: Implementação de FFT para análise espectral em simulações.",
                                "Engenharia: Modelagem de fluxos compressíveis em aerodinâmica.",
                                "Estatística: Análise de erros numéricos como variância espectral."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM), análise de von Neumann otimiza esquemas para minimizar dispersão em previsão de furacões, garantindo precisão na propagação de frentes de onda sem oscilações artificiais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Interpretar dispersão em simulações",
                            "description": "Analisar gráficos de soluções numéricas vs. exatas para identificar oscilações de dispersão em ondas de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos de dispersão em esquemas numéricos",
                                  "subSteps": [
                                    "Estude a definição de dispersão: erro de fase em componentes de alta frequência em equações hiperbólicas.",
                                    "Revise a relação de dispersão para esquemas como Lax-Wendroff ou upwind, comparando ω_num vs. ω_exata.",
                                    "Analise como esquemas numéricos introduzem dispersão leading/trailing em ondas.",
                                    "Identifique condições CFL e sua relação com oscilações.",
                                    "Resuma em notas as causas matemáticas da dispersão (erros de ordem)."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando dispersão e cite pelo menos duas referências teóricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula, calculadora simbólica como SymPy.",
                                  "tips": "Use diagramas de relação de dispersão para visualizar diferenças de fase.",
                                  "learningObjective": "Compreender as bases teóricas da dispersão para interpretação posterior.",
                                  "commonMistakes": "Confundir dispersão com dissipação; ignorar dependência na frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e executar uma simulação numérica simples da equação da onda",
                                  "subSteps": [
                                    "Implemente a equação da onda 1D: u_t + c u_x = 0, com condição inicial gaussiana.",
                                    "Escolha um esquema dispersivo (ex: Lax-Friedrichs) e defina malha com Δx=0.01, Δt=0.005 (CFL=0.5).",
                                    "Codifique em Python usando NumPy e SciPy para solver numérico.",
                                    "Execute simulação para t até 2.0 e salve soluções em diferentes tempos.",
                                    "Compute solução exata usando d'Alembert para comparação."
                                  ],
                                  "verification": "Confirme que o código roda sem erros e gera arrays de soluções numéricas e exatas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy, Matplotlib, Jupyter Notebook.",
                                  "tips": "Teste com pacote inicial delta para alta frequência.",
                                  "learningObjective": "Gerar dados comparativos de soluções exata e numérica.",
                                  "commonMistakes": "Erro no CFL causando instabilidade; malha muito grosseira escondendo oscilações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e plotar gráficos comparativos de soluções",
                                  "subSteps": [
                                    "Plote u_num(x,t) vs. u_exata(x,t) em subplots para t=0.5, 1.0, 1.5.",
                                    "Use escalas logarítmicas no resíduo |u_num - u_exata| para destacar oscilações pequenas.",
                                    "Sobreponha espectros de Fourier para visualizar componentes de alta frequência.",
                                    "Ajuste cores e legendas para clareza: azul para exata, vermelho para numérica.",
                                    "Salve figuras em alta resolução."
                                  ],
                                  "verification": "Gráficos mostram claramente a propagação da onda com oscilações trailing na solução numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib, NumPy; código da simulação anterior.",
                                  "tips": "Amplie regiões de cauda da onda para melhor visualização.",
                                  "learningObjective": "Visualizar diferenças qualitativas entre soluções.",
                                  "commonMistakes": "Escalas inadequadas mascarando oscilações; plots sem zoom."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar oscilações de dispersão nos gráficos",
                                  "subSteps": [
                                    "Identifique oscilações de alta frequência atrás da frente da onda (dispersão trailing).",
                                    "Meça amplitude e comprimento de onda das oscilações vs. exata.",
                                    "Compare velocidades de fase: componentes altas freq. via mais devagar.",
                                    "Quantifique erro de dispersão usando métrica como max(|resíduo|).",
                                    "Descreva impacto na precisão para simulações de longa duração."
                                  ],
                                  "verification": "Redija relatório de 1 página identificando e explicando 3 oscilações específicas nos gráficos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos gerados, régua digital ou código para medições.",
                                  "tips": "Use FFT para confirmar frequências dominantes nas oscilações.",
                                  "learningObjective": "Interpretar visualmente dispersão como artefato numérico.",
                                  "commonMistakes": "Atribuir oscilações a ruído em vez de dispersão; ignorar direção da onda."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar simulação e validar interpretação",
                                  "subSteps": [
                                    "Varie Δx e observe redução de dispersão com refinamento.",
                                    "Teste esquema menos dispersivo (ex: Runge-Kutta) para comparação.",
                                    "Documente como dispersão afeta simulações reais (ex: ondas acústicas).",
                                    "Crie tabela resumindo observações: esquema, Δx, nível de dispersão.",
                                    "Autoavalie interpretação contra literatura."
                                  ],
                                  "verification": "Tabela mostra correlação inversa entre Δx e amplitude de oscilações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código modificado, referências teóricas.",
                                  "tips": "Mantenha CFL fixo ao refinar malha.",
                                  "learningObjective": "Validar interpretação através de experimentos paramétricos.",
                                  "commonMistakes": "Mudar múltiplos parâmetros simultaneamente; conclusões sem dados."
                                }
                              ],
                              "practicalExample": "Em uma simulação da equação da onda 1D com pulso gaussiano inicial usando esquema Lax-Friedrichs (Δx=0.01, CFL=0.5), os gráficos em t=1.5 revelam oscilações de amplitude ~0.05 atrás da frente principal (exata lisa), confirmando dispersão trailing em frequências kΔx ≈ π.",
                              "finalVerifications": [
                                "Identifica oscilações de alta frequência trailing nos gráficos numéricos.",
                                "Explica corretamente a causa como erro de fase na relação de dispersão.",
                                "Compara amplitudes e velocidades de fase com solução exata.",
                                "Sugere refinamento de malha como mitigação.",
                                "Documenta análise em relatório coerente.",
                                "Valida com espectro de Fourier mostrando picos espúrios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de dispersão vs. outros erros (90%).",
                                "Profundidade da análise qualitativa e quantitativa (escalas, métricas).",
                                "Correta ligação teórica com gráficos observados.",
                                "Clareza e anotação nos plots (legendas, zooms).",
                                "Validação através de variações paramétricas.",
                                "Relatório estruturado com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas em meios dispersivos (acústica, óptica).",
                                "Computação: Análise de erros em solvers PDE numéricos (Finite Differences).",
                                "Engenharia: Simulações CFD para aerodinâmica com esquemas hiperbólicos.",
                                "Estatística: Análise espectral e detecção de artefatos em dados simulados."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, interpretar dispersão em modelos de onda acústica evita erros na localização de reservatórios; em telecomunicações, analisa distorções de sinal em fibras ópticas simuladas numericamente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.4",
                        "name": "Noções de Dissipação em Esquemas Numéricos",
                        "description": "Análise do erro de dissipação, caracterizado pelo amortecimento artificial de componentes de alta frequência em soluções numéricas de equações hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.4.1",
                            "name": "Quantificar dissipação através do fator de amplificação",
                            "description": "Calcular o módulo do fator de amplificação |g(kΔx)| na análise de von Neumann para esquemas como Lax-Friedrichs, medindo o amortecimento por passo de tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos da Análise de von Neumann",
                                  "subSteps": [
                                    "Explicar o conceito de solução modal: assumir u_j^n = g^n e^{i k j Δx}.",
                                    "Derivar a relação de recursão para o fator de amplificação g a partir do esquema numérico genérico.",
                                    "Discutir a condição de estabilidade |g| ≤ 1 para todos os modos k.",
                                    "Introduzir dissipação como |g| < 1, causando amortecimento de componentes de alta frequência.",
                                    "Resolver para g em esquemas simples como upwind para referência."
                                  ],
                                  "verification": "Escrever a fórmula geral para g e identificar quando |g| < 1 indica dissipação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), papel e caneta, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Sempre normalize θ = k Δx entre 0 e π para modos representáveis.",
                                  "learningObjective": "Compreender a base da análise de von Neumann e sua relação com estabilidade e dissipação.",
                                  "commonMistakes": "Confundir g com o polinômio característico; esquecer a normalização de Fourier."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Fator de Amplificação para o Esquema Lax-Friedrichs",
                                  "subSteps": [
                                    "Escrever o esquema Lax-Friedrichs para u_t + a u_x = 0: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (λ/2)(u_{j+1}^n - u_{j-1}^n), com λ = a Δt / Δx.",
                                    "Substituir a forma modal u_j^n = g^n e^{i k j Δx} na equação do esquema.",
                                    "Simplificar usando e^{i θ} + e^{-i θ} = 2 cos θ e^{i θ (j-1) Δx} wait, corretamente: isolar g.",
                                    "Obter g(θ) = cos(θ) - i λ sin(θ), onde θ = k Δx.",
                                    "Verificar para θ=0: g(0)=1, preservando modo constante."
                                  ],
                                  "verification": "Derivar explicitamente g(θ) e confirmar g(0)=1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software simbólico (SymPy ou Mathematica), notas de aula sobre esquemas hiperbólicos.",
                                  "tips": "Use identidades trigonométricas: sen(θ) = (e^{iθ} - e^{-iθ})/(2i).",
                                  "learningObjective": "Derivar o fator de amplificação específico para Lax-Friedrichs.",
                                  "commonMistakes": "Erro no sinal do termo de advecção; esquecer o fator 1/2 no LF."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Módulo |g(k Δx)|",
                                  "subSteps": [
                                    "Calcular |g(θ)|^2 = Re(g)^2 + Im(g)^2 = cos²(θ) + λ² sin²(θ).",
                                    "Assim, |g(θ)| = sqrt( cos²(θ) + λ² sin²(θ) ).",
                                    "Analisar para θ pequeno (baixas frequências): ≈1, e θ=π (alta frequência): sqrt( (λ² +1)/2 ) <1 se λ<1.",
                                    "Plotar |g(θ)| vs θ para λ fixo (ex: 0.5) usando Python/MATLAB.",
                                    "Comparar com esquemas não dissipativos como Lax-Wendroff."
                                  ],
                                  "verification": "Computar |g(π/2)| para λ=0.5 e confirmar <1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB, exemplos numéricos impressos.",
                                  "tips": "Note que |g| ≤1 sempre para |λ|≤1 no LF, mas dissipação é máxima em altas frequências.",
                                  "learningObjective": "Quantificar numericamente o módulo do fator de amplificação.",
                                  "commonMistakes": "Esquecer raiz quadrada em |g|; confundir com |g|^2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Quantificar a Dissipação",
                                  "subSteps": [
                                    "Definir dissipação por passo: 1 - |g(θ)|, medindo amortecimento relativo.",
                                    "Calcular taxa de dissipação efetiva: somar sobre modos ou focar em altas frequências.",
                                    "Analisar dependência em λ: dissipação aumenta com |λ| pequeno.",
                                    "Discutir trade-off: dissipação estabiliza mas suaviza solução.",
                                    "Generalizar para esquemas multicomponentes ou não-lineares."
                                  ],
                                  "verification": "Explicar verbalmente como |g|<1 quantifica amortecimento por Δt.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos gerados no step 3, tabela de valores |g(θ)| para diferentes λ.",
                                  "tips": "Foquem em θ próximo a π para ver dissipação numérica de oscilações.",
                                  "learningObjective": "Interpretar |g| como medida de dissipação em esquemas numéricos.",
                                  "commonMistakes": "Achar que |g|=1 implica não-dissipativo para todos θ; ignorar dependência em θ."
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Friedrichs com λ=0.5 e θ=π/2, g = cos(π/2) - i*0.5*sin(π/2) = 0 - i*0.5, |g| = 0.5. Assim, amplitude de modo reduz 50% por passo de tempo, dissipando ondas de alta frequência rapidamente.",
                              "finalVerifications": [
                                "Deriva corretamente g(θ) para Lax-Friedrichs.",
                                "Calcula |g(θ)| para pelo menos 3 valores de θ e λ.",
                                "Plota |g(θ)| e identifica região de forte dissipação.",
                                "Explica o papel da dissipação na estabilidade.",
                                "Compara com outro esquema (ex: upwind)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g(θ) (80% peso).",
                                "Correção no cálculo de |g| e interpretação (15% peso).",
                                "Qualidade do gráfico e análise qualitativa (5% peso).",
                                "Clareza na explicação de dissipação vs estabilidade.",
                                "Identificação de dependências em λ e θ."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de amortecimento em equações de onda.",
                                "Engenharia Computacional: Estabilidade em simulações CFD.",
                                "Programação: Implementação de análise de Fourier em código.",
                                "Estatística: Análise espectral de séries temporais numéricas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD), quantificar dissipação no Lax-Friedrichs ajuda a escolher Δt/Δx para evitar oscilações sem excesso de suavização artificial em previsões meteorológicas ou aerodinâmica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.4.2",
                            "name": "Avaliar trade-off dispersão-dissipação",
                            "description": "Discutir esquemas de baixa dissipação e dispersão, como Leapfrog, e seu impacto na preservação de energia em simulações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de dispersão e dissipação em esquemas numéricos",
                                  "subSteps": [
                                    "Defina dispersão como a distorção de fase nas ondas simuladas, levando a velocidades de fase dependentes da frequência.",
                                    "Defina dissipação como a atenuação artificial de amplitude nas componentes de alta frequência.",
                                    "Revise a análise de von Neumann para calcular os fatores de amplificação em esquemas lineares.",
                                    "Compare dispersão e dissipação qualitativamente em termos de preservação de energia.",
                                    "Identifique quando cada uma é problemática em equações hiperbólicas."
                                  ],
                                  "verification": "Resuma as definições em um parágrafo e calcule o fator de amplificação para um esquema simples como FTCS.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro 'Análise Numérica de LeVeque', notas de aula, Python/MATLAB para cálculos simbólicos.",
                                  "tips": "Use diagramas de dispersão-dissipação para visualização intuitiva.",
                                  "learningObjective": "Dominar definições precisas e distinções entre dispersão e dissipação.",
                                  "commonMistakes": "Confundir dispersão com difusão física; ignorar dependência no número de Courant."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar esquemas de baixa dissipação e dispersão, focando no Leapfrog",
                                  "subSteps": [
                                    "Descreva o esquema Leapfrog para a equação de onda 1D: u^{n+1}_j = u^{n-1}_j - σ² (u^n_{j+1} - 2u^n_j + u^n_{j-1}).",
                                    "Derive sua stencil centrada no tempo e espaço, destacando neutralidade de dissipação.",
                                    "Analise o fator de amplificação via von Neumann: mostre ausência de dissipação (módulo 1) mas presença de dispersão.",
                                    "Implemente Leapfrog em código para simular uma onda inicial gaussiana.",
                                    "Compare com Lax-Wendroff, notando diferenças em dispersão."
                                  ],
                                  "verification": "Execute simulação e plote energia total ao longo do tempo, confirmando preservação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy/Matplotlib, paper original de Leapfrog ou capítulo de análise numérica.",
                                  "tips": "Use condições periódicas para evitar erros de fronteira contaminando a análise.",
                                  "learningObjective": "Implementar e analisar propriedades do Leapfrog.",
                                  "commonMistakes": "Esquecer o stencil de 3 níveis temporais; usar σ >1 levando a instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o trade-off entre dispersão e dissipação",
                                  "subSteps": [
                                    "Discuta como esquemas dissipativos (ex: upwind) amortecem oscilações mas introduzem viscosidade numérica.",
                                    "Mostre que esquemas não-dissipativos como Leapfrog preservam energia mas exibem dispersão de fase.",
                                    "Plote curvas de dispersão (ω_num vs ω_exata) para Leapfrog e um esquema dissipativo.",
                                    "Quantifique trade-off via métricas: erro de fase vs decaimento de energia.",
                                    "Explore filtros para mitigar dispersão sem adicionar dissipação excessiva."
                                  ],
                                  "verification": "Crie gráfico comparativo de dispersão-dissipação e discuta prós/contras.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de plotagem (Matplotlib), referências como Gustafsson et al.",
                                  "tips": "Normalize frequências por kΔx para comparações justas.",
                                  "learningObjective": "Avaliar quantitativamente o equilíbrio entre dispersão e dissipação.",
                                  "commonMistakes": "Ignorar o regime de alta frequência onde trade-offs são mais evidentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto na preservação de energia em simulações hiperbólicas",
                                  "subSteps": [
                                    "Lembre que equações hiperbólicas conservam energia (ex: ∫ u_t² + u_x² dx constante para onda).",
                                    "Prove mimeticamente que Leapfrog preserva uma norma discreta de energia.",
                                    "Simule long-time integration e meça variação percentual de energia.",
                                    "Compare com esquemas dissipativos: mostre blow-up ou damping indevido.",
                                    "Discuta implicações para simulações não-lineares onde energia afeta estabilidade."
                                  ],
                                  "verification": "Relatório com plots de energia vs tempo para 3 esquemas, <1% variação para Leapfrog.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Código Python estendido, teorema de conservação de energia.",
                                  "tips": "Monitore energia em norma L2 discreta para precisão.",
                                  "learningObjective": "Conectar trade-offs a propriedades globais como conservação de energia.",
                                  "commonMistakes": "Usar grids grosseiros onde dispersão domina; negligenciar erros de arredondamento."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar avaliação do trade-off e propor escolhas",
                                  "subSteps": [
                                    "Resuma trade-offs: Leapfrog para preservação energia curta dispersão fase.",
                                    "Proponha híbridos: Leapfrog + filtro de alta frequência para controle.",
                                    "Avalie custo computacional vs precisão energética.",
                                    "Discuta cenários onde dissipação é desejável (choques) vs não (ondas puras).",
                                    "Escreva conclusão recomendando esquemas baseados em problema."
                                  ],
                                  "verification": "Escreva relatório de 1 página avaliando trade-off para equação de onda.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Modelos de relatório, simulações anteriores.",
                                  "tips": "Use tabela comparativa para síntese clara.",
                                  "learningObjective": "Formular julgamentos informados sobre escolha de esquemas.",
                                  "commonMistakes": "Generalizar Leapfrog como sempre superior; ignorar contexto não-linear."
                                }
                              ],
                              "practicalExample": "Simule a equação de onda 1D ∂²u/∂t² = c² ∂²u/∂x² com pulso gaussiano inicial usando Leapfrog (σ=0.9) vs Lax-Friedrichs. Plote u(x,t=10) e energia ao longo de 1000 passos: Leapfrog preserva forma e energia (±0.1%), enquanto Lax-Friedrichs dispersa menos mas dissipa 20% da energia.",
                              "finalVerifications": [
                                "Capacidade de derivar fator de amplificação para Leapfrog.",
                                "Implementação numérica estável com preservação de energia <1% erro.",
                                "Gráfico qualitativo de trade-off dispersão-dissipação.",
                                "Discussão coerente de impactos em simulações hiperbólicas.",
                                "Recomendação contextualizada de esquema para problema dado.",
                                "Identificação correta de erros comuns em análises von Neumann."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e distinções corretas (30%).",
                                "Análise quantitativa: cálculos e plots precisos (25%).",
                                "Implementação prática: código funcional e estável (20%).",
                                "Avaliação crítica: trade-offs bem argumentados (15%).",
                                "Síntese e aplicação: recomendações lógicas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e conservação de energia em mecânica clássica.",
                                "Computação Científica: Otimização de algoritmos para PDEs hiperbólicas.",
                                "Engenharia: Simulações CFD para aerodinâmica onde dissipação afeta precisão.",
                                "Matemática Aplicada: Análise de estabilidade em métodos espectrais."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, Leapfrog minimiza dissipação artificial permitindo rastrear ondas de longa distância com energia preservada, essencial para modelar reflexões precisas em reservatórios de óleo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Equações Parabólicas",
                "description": "Estudo de convergência, estabilidade e métodos ADI para equações parabólicas.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Métodos de Diferenças Finitas para Equações Parabólicas",
                    "description": "Aplicação de métodos de diferenças finitas a equações parabólicas, como a equação do calor.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Discretização de Equações Parabólicas com Diferenças Finitas",
                        "description": "Introdução à aplicação de métodos de diferenças finitas para discretizar equações parabólicas, como a equação do calor unidimensional, incluindo esquemas explícito e implícito.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Derivação do Esquema Explícito para a Equação do Calor",
                            "description": "Derivar o esquema de diferenças finitas explícito para a equação do calor ∂u/∂t = α ∂²u/∂x², aproximando as derivadas temporais e espaciais com diferenças finitas forward e central, respectivamente, e identificar o parâmetro de Courant (r = α Δt / Δx²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão da Equação do Calor e Definição da Malha Numérica",
                                  "subSteps": [
                                    "Escreva a equação diferencial parcial da equação do calor: ∂u/∂t = α ∂²u/∂x².",
                                    "Defina a malha espacial uniforme com pontos x_i = i Δx, i=0 a N, e malha temporal t_n = n Δt.",
                                    "Anotar as condições de contorno e inicial u(x,0) = f(x).",
                                    "Identifique u_i^n ≈ u(x_i, t_n) como aproximação numérica.",
                                    "Discuta a notação padrão para diferenças finitas."
                                  ],
                                  "verification": "Escreva a equação e a malha em um papel e confirme que todos os símbolos estão corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Use Δx pequeno para precisão, mas foque na derivação teórica agora.",
                                  "learningObjective": "Compreender a configuração inicial do problema e a notação de discretização.",
                                  "commonMistakes": [
                                    "Confundir notação u_i^n com u^n_i",
                                    "Esquecer condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aproximação da Derivada Temporal com Diferença Forward",
                                  "subSteps": [
                                    "Lembre a definição de derivada temporal: ∂u/∂t |_{t_n} ≈ (u(x, t_{n+1}) - u(x, t_n)) / Δt.",
                                    "Em termos discretos: ∂u/∂t |_{i,n} ≈ (u_i^{n+1} - u_i^n) / Δt.",
                                    "Substitua na equação do calor para isolar o termo temporal.",
                                    "Verifique a ordem de truncamento: O(h) para forward Euler.",
                                    "Anotar a fórmula exata da aproximação."
                                  ],
                                  "verification": "Derive e escreva a fórmula da diferença forward isolada da equação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificar Taylor"
                                  ],
                                  "tips": "Expanda em série de Taylor para confirmar a precisão de primeira ordem.",
                                  "learningObjective": "Dominar a discretização temporal explícita forward.",
                                  "commonMistakes": [
                                    "Usar backward em vez de forward",
                                    "Esquecer o sinal na derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximação da Derivada Espacial com Diferença Central",
                                  "subSteps": [
                                    "Defina a segunda derivada: ∂²u/∂x² |_{x_i} ≈ (u_{i-1} - 2u_i + u_{i+1}) / Δx².",
                                    "Em tempo n: ∂²u/∂x² |_{i,n} ≈ (u_{i-1}^n - 2u_i^n + u_{i+1}^n) / Δx².",
                                    "Substitua na equação discretizada temporal.",
                                    "Verifique a precisão: O(Δx²) para central simétrica.",
                                    "Anotar o operador Laplaciano discreto."
                                  ],
                                  "verification": "Escreva a fórmula da diferença central e compute para um exemplo simples u(x)=x².",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python para testar (opcional)"
                                  ],
                                  "tips": "A diferença central é simétrica, logo mais precisa que forward/backward.",
                                  "learningObjective": "Aplicar corretamente a discretização espacial de segunda ordem.",
                                  "commonMistakes": [
                                    "Usar forward para segunda derivada",
                                    "Confundir coeficientes: 1, -2, 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinação das Aproximações e Identificação do Parâmetro de Courant",
                                  "subSteps": [
                                    "Substitua ambas as aproximações na equação: u_i^{n+1} = u_i^n + r (u_{i-1}^n - 2u_i^n + u_{i+1}^n), onde r = α Δt / Δx².",
                                    "Identifique explicitamente r como o número de Courant-Friedrichs-Lewy (CFL).",
                                    "Escreva o esquema explícito completo.",
                                    "Discuta brevemente a condição de estabilidade r ≤ 1/2.",
                                    "Verifique com um exemplo numérico simples."
                                  ],
                                  "verification": "Derive o esquema final e isole r corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "r controla a estabilidade; valores >0.5 podem divergir.",
                                  "learningObjective": "Finalizar a derivação e reconhecer o papel do parâmetro r.",
                                  "commonMistakes": [
                                    "Erro no sinal de r",
                                    "Esquecer fator α em r"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma barra de 1m de comprimento com extremidades fixas em 0°C e condição inicial u(x,0)=sin(πx). Discretize com Δx=0.1, Δt=0.001, α=1. Use o esquema para computar u em t=0.1s e verifique se difunde corretamente.",
                              "finalVerifications": [
                                "Escreve corretamente o esquema explícito u_i^{n+1} = r u_{i-1}^n + (1-2r) u_i^n + r u_{i+1}^n.",
                                "Identifica r = α Δt / Δx² como parâmetro de Courant.",
                                "Explica a origem das diferenças forward e central.",
                                "Verifica estabilidade qualitativa (r ≤ 1/2).",
                                "Aplica o esquema a um exemplo simples sem erros aritméticos.",
                                "Discute truncamento temporal O(Δt) e espacial O(Δx²)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das aproximações diferenciais.",
                                "Correta identificação e definição de r.",
                                "Clareza na escrita do esquema explícito.",
                                "Compreensão da ordem de precisão das diferenças.",
                                "Capacidade de aplicar em exemplo prático.",
                                "Reconhecimento de condições de estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e condução de calor.",
                                "Computação: Implementação de métodos numéricos em Python/MATLAB.",
                                "Engenharia: Simulações em CFD (dinâmica de fluidos computacional).",
                                "Matemática Aplicada: Análise de estabilidade de Von Neumann.",
                                "Física Computacional: Simulações de PDEs em problemas reais."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em painéis solares, previsão de derretimento de geleiras em modelos climáticos, ou análise térmica em circuitos integrados para evitar superaquecimento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Implementação do Esquema Implícito",
                            "description": "Formular e resolver o esquema implícito para a equação do calor, utilizando diferenças backward no tempo e central no espaço, levando a um sistema tridiagonal que pode ser resolvido iterativamente ou por decomposição LU.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Formular o Esquema Implícito para a Equação do Calor",
                                  "subSteps": [
                                    "Revise a equação do calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Identifique as diferenças finitas: backward no tempo (implícito) e central no espaço.",
                                    "Escreva a aproximação: (u^{n+1}_j - u^n_j)/Δt = α (u^{n+1}_{j-1} - 2u^{n+1}_j + u^{n+1}_{j+1})/Δx².",
                                    "Reorganize em forma matricial: Au^{n+1} = u^n, onde A é a matriz tridiagonal.",
                                    "Defina condições de contorno (ex: Dirichlet) e inicial."
                                  ],
                                  "verification": "Derive corretamente a equação discreta e identifique a matriz A.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis ou software como Mathematica para derivação simbólica"
                                  ],
                                  "tips": "Comece com o caso explícito para contrastar estabilidade; implícito é incondicionalmente estável.",
                                  "learningObjective": "Formular o esquema implícito e entender sua estrutura matricial.",
                                  "commonMistakes": [
                                    "Confundir diferenças forward/backward no tempo",
                                    "Esquecer o fator α na discretização espacial",
                                    "Ignorar condições de contorno na formulação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar o Domínio e Montar a Malha Espaço-Temporal",
                                  "subSteps": [
                                    "Escolha Δx e Δt satisfazendo r = α Δt / Δx² > 0 (sem restrição para implícito).",
                                    "Defina a grade: x_j = j Δx, j=0..J; t_n = n Δt, n=0..N.",
                                    "Incorpore condições de contorno: u^{n+1}_0 = g_0(t), u^{n+1}_J = g_J(t).",
                                    "Construa vetores u^n e u^{n+1} com dimensões J-1.",
                                    "Verifique consistência de segunda ordem no espaço e primeira no tempo."
                                  ],
                                  "verification": "Crie uma malha para um problema teste e liste os pontos internos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy) para gerar malha",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use Δx pequeno para precisão, mas equilibre com custo computacional.",
                                  "learningObjective": "Configurar a discretização numérica adequada para o esquema.",
                                  "commonMistakes": [
                                    "Escolher Δt/Δx violando estabilidade (desnecessário, mas comum confusão)",
                                    "Incluir pontos de contorno nos vetores desconhecidos",
                                    "Erros de indexação em j=1..J-1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Matriz Tridiagonal do Sistema Linear",
                                  "subSteps": [
                                    "Defina a matriz A: tridiagonal com a_{i,i-1} = -r, a_{i,i} = 1 + 2r, a_{i,i+1} = -r.",
                                    "Aplique condições de contorno no vetor-lado-direito b^n.",
                                    "Escreva o sistema Au^{n+1} = b^n explicitamente para 3-5 pontos internos.",
                                    "Verifique simetria e diagonal-dominância positiva de A.",
                                    "Gere A em código ou manualmente para malha pequena."
                                  ],
                                  "verification": "Monte A e b para um exemplo com J=4 e confira multiplicação Au = b.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy para matrizes esparsas",
                                    "Papel para malha pequena"
                                  ],
                                  "tips": "Use formato tridiagonal para eficiência; evite matriz densa.",
                                  "learningObjective": "Montar corretamente o sistema linear tridiagonal.",
                                  "commonMistakes": [
                                    "Sinal errado nos off-diagonais (-r vs +r)",
                                    "Fator r incorreto (α Δt/Δx²)",
                                    "Não ajustar b para contornos não-homogêneos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o Sistema Tridiagonal por Decomposição LU ou Iterativamente",
                                  "subSteps": [
                                    "Implemente decomposição LU para tridiagonal (algoritmo Thomas).",
                                    "Alternativa: método iterativo como Gauss-Seidel até convergência (tol=1e-6).",
                                    "Code a função resolve_tridiag(A_diag, b) ou iterativo.",
                                    "Avance no tempo: para n=1 to N, u^{n} = solve(A, u^{n-1}).",
                                    "Compare tempo de CPU entre LU e iterativo."
                                  ],
                                  "verification": "Resolva um passo temporal e verifique ||Au - b|| < 1e-10.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python (NumPy, SciPy.linalg.solve_banded)",
                                    "MATLAB ou Julia para benchmark"
                                  ],
                                  "tips": "LU é direto e rápido para tridiagonal; iterativos para malhas grandes.",
                                  "learningObjective": "Implementar solvers eficientes para o sistema implícito.",
                                  "commonMistakes": [
                                    "Pivotamento desnecessário em LU tridiagonal",
                                    "Loop infinito em iterativos sem critério de parada",
                                    "Erro de arredondamento em r grande"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar, Testar e Analisar a Solução Numérica",
                                  "subSteps": [
                                    "Escreva código completo para problema teste com solução exata.",
                                    "Calcule erros L2 e máximo em malhas refinadas.",
                                    "Plote u(x,t) em tempos selecionados vs exata.",
                                    "Estude convergência: reduza Δt, Δx e observe ordens.",
                                    "Analise estabilidade variando r até 1000."
                                  ],
                                  "verification": "Erro L2 < 1e-4 para Δx=0.01, e plots coincidem com exata.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib para plots",
                                    "Solução exata: séries de Fourier"
                                  ],
                                  "tips": "Use animação para visualizar propagação do calor.",
                                  "learningObjective": "Validar implementação e analisar precisão/estabilidade.",
                                  "commonMistakes": [
                                    "Não normalizar erro L2",
                                    "Confundir solução numérica com exata em plots",
                                    "Ignorar custo computacional O(JN)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u_t = u_xx em [0,1]x[0,1], u(0,t)=u(1,t)=0, u(x,0)=sin(πx). Use α=1, Δx=0.1 (J=10), Δt=0.01 (r=0.1). Monte A (9x9 tridiagonal), resolva 100 passos com LU, plote u(0.5,t) vs exata u(x,t)=sin(πx)exp(-π²t). Erro L2 ~1e-4.",
                              "finalVerifications": [
                                "Derivação correta do esquema implícito com diferenças backward/central.",
                                "Matriz A tridiagonal montada com elementos -r, 1+2r, -r.",
                                "Sistema resolvido com erro residual <1e-10 por passo.",
                                "Código implementado roda sem erros para malha 100x1000.",
                                "Análise de convergência mostra O(Δt + Δx²).",
                                "Estabilidade confirmada para r=1000."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação teórica (30%).",
                                "Correção na montagem da matriz e vetor b (25%).",
                                "Eficiência e acurácia do solver (20%).",
                                "Validação numérica com erros quantificados (15%).",
                                "Clareza do código e plots (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e Fick's laws.",
                                "Computação: Algoritmos numéricos e programação científica (NumPy/SciPy).",
                                "Engenharia: Simulações em transferência de calor (ex: CFD com OpenFOAM).",
                                "Estatística: Análise de erros e convergência numérica."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em perfis de asas de aviões durante voo, previsão de derretimento em soldas industriais, ou modelagem de difusão de poluentes em solos para engenharia ambiental."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Condições de Contorno e Inicial",
                            "description": "Aplicar condições de Dirichlet e de Neumann em problemas parabólicos discretizados, incorporando-as na malha de diferenças finitas e verificando a consistência das aproximações nas fronteiras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as condições de contorno Dirichlet e Neumann em equações parabólicas",
                                  "subSteps": [
                                    "Estudar a definição de condição de Dirichlet: valor fixo da solução nas fronteiras (u = g(t) em x=0 ou x=L).",
                                    "Analisar condição de Neumann: derivada normal fixa (∂u/∂n = h(t)), representando fluxo.",
                                    "Revisar condição inicial: u(x,0) = f(x) para problemas parabólicos como equação do calor.",
                                    "Identificar diferenças em problemas parabólicos discretizados no tempo e espaço.",
                                    "Exemplificar com equação u_t = α u_xx."
                                  ],
                                  "verification": "Resumir em um diagrama as condições e suas implicações matemáticas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre EDP",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias físicas: Dirichlet como temperatura fixa, Neumann como isolamento térmico.",
                                  "learningObjective": "Diferenciar e formular corretamente condições de contorno e inicial para equações parabólicas.",
                                  "commonMistakes": [
                                    "Confundir Dirichlet com Neumann",
                                    "Esquecer condição inicial em problemas parabólicos",
                                    "Ignorar dependência temporal nas fronteiras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a malha de diferenças finitas para o domínio espaço-tempo",
                                  "subSteps": [
                                    "Definir malha uniforme: Δx = h, Δt = k, pontos xi = i h, tn = n k.",
                                    "Escolher esquema explícito ou implícito (ex: Euler forward/backward).",
                                    "Escrever a discretização central para u_xx: (u_{i+1}^n - 2u_i^n + u_{i-1}^n)/h².",
                                    "Determinar número de pontos internos (ex: malha com N+1 pontos, 1 a N-1 internos).",
                                    "Calcular r = α k / h² para estabilidade (r ≤ 1/2 no explícito)."
                                  ],
                                  "verification": "Implementar malha em código e plotar grade vazia.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com malhas 1D simples para visualizar fronteiras.",
                                  "learningObjective": "Construir malha estável para discretização parabólica.",
                                  "commonMistakes": [
                                    "Escolha inadequada de Δt levando a instabilidade",
                                    "Pontos fantasmas não identificados",
                                    "Malha não uniforme sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar condições de contorno Dirichlet e Neumann na discretização",
                                  "subSteps": [
                                    "Para Dirichlet em i=0: u_0^n = g(tn) diretamente na malha.",
                                    "Para Dirichlet em i=N: u_N^n = g(tn).",
                                    "Para Neumann em i=0: aproximar ∂u/∂x ≈ (u_1^n - u_{-1}^n)/(2h) = h(tn), introduzindo u_{-1}^n = u_1^n - 2h h(tn).",
                                    "Similar para i=N com u_{N+1}^n.",
                                    "Montar sistema linear Ax = b incorporando condições nas linhas de fronteira."
                                  ],
                                  "verification": "Substituir valores e verificar se o sistema respeita as condições exatas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código Python/MATLAB para montagem de matriz",
                                    "Solver linear (SciPy)"
                                  ],
                                  "tips": "Use pontos fantasmas para Neumann para simplicidade.",
                                  "learningObjective": "Integrar condições de contorno na matriz de diferenças finitas.",
                                  "commonMistakes": [
                                    "Aproximação forward/backward errada em Neumann",
                                    "Não ajustar b no sistema para condições não-homogêneas",
                                    "Confundir índices de malha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar consistência das aproximações nas fronteiras",
                                  "subSteps": [
                                    "Analisar ordem de truncamento: O(h²) para diferenças centrais, O(h) em fronteiras Neumann.",
                                    "Comparar solução numérica com solução exata ou analítica em pontos de fronteira.",
                                    "Testar convergência refinando malha (reduzir h e k).",
                                    "Verificar estabilidade com diferentes r e plotar erros.",
                                    "Implementar iterações temporais e monitorar resíduos nas fronteiras."
                                  ],
                                  "verification": "Calcular erro L2 nas fronteiras < 1% da norma solução.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Solução exata de problema teste",
                                    "Gráficos de erro vs h"
                                  ],
                                  "tips": "Use problema com solução conhecida como u(x,t)=x(1-x)(1+sin(t)).",
                                  "learningObjective": "Validar precisão e consistência da discretização com condições de contorno.",
                                  "commonMistakes": [
                                    "Não testar múltiplas malhas para convergência",
                                    "Ignorar erros acumulados no tempo",
                                    "Confundir consistência com estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente u_t = u_xx em [0,1]x[0,1], com u(x,0)=sin(πx), u(0,t)=0 (Dirichlet), ∂u/∂x(1,t)=0 (Neumann). Use malha 20x20, esquema implícito. Compare com solução exata u(x,t)=sin(πx) e^{-π² t}.",
                              "finalVerifications": [
                                "Implementa corretamente Dirichlet fixando valores nas fronteiras.",
                                "Aplica aproximação de segunda ordem para Neumann usando pontos fantasmas.",
                                "O sistema linear montado satisfaz condições exatas em t=0 e fronteiras.",
                                "Solução converge com refinamento de malha (erro diminui).",
                                "Estabilidade mantida para r até 1 no implícito.",
                                "Condições iniciais propagadas corretamente ao longo do tempo."
                              ],
                              "assessmentCriteria": [
                                "Precisão da discretização nas fronteiras (ordem O(h²)).",
                                "Correta montagem da matriz A e vetor b.",
                                "Convergência demonstrada numericamente.",
                                "Tratamento adequado de condições não-homogêneas.",
                                "Eficiência computacional (tempo de execução razoável).",
                                "Visualização clara de resultados (plots de u(x,t))."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e fluxo de calor.",
                                "Computação: Algoritmos numéricos e programação científica (NumPy/SciPy).",
                                "Engenharia: Simulações em CFD e estruturas térmicas.",
                                "Matemática Aplicada: Análise de erros e estabilidade numérica."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em barras metálicas com extremidades fixas ou isoladas, essencial em engenharia térmica, manufatura aditiva e previsão de falhas em materiais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Análise de Consistência, Estabilidade e Convergência",
                        "description": "Estudo dos critérios fundamentais para métodos numéricos em equações parabólicas: consistência (ordem de truncamento), estabilidade (condição CFL para explícito) e convergência (teorema Lax).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Verificação de Consistência",
                            "description": "Calcular o erro de truncamento local para esquemas explícito e implícito na equação do calor, demonstrando consistência de ordem O(Δt) + O(Δx²) e analisando o impacto na precisão global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação do Calor e Discretizações Explícita e Implícita",
                                  "subSteps": [
                                    "Escreva a equação do calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Defina a malha temporal Δt e espacial Δx, com pontos (x_j, t_n).",
                                    "Apresente o esquema explícito: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Apresente o esquema implícito: u_j^{n+1} - r (u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}) = u_j^n.",
                                    "Expanda os operadores diferenciais em séries de Taylor para preparar a análise de erro."
                                  ],
                                  "verification": "Verifique se as expansões de Taylor para ∂u/∂t e ∂²u/∂x² estão corretas até ordens O(Δt) e O(Δx²).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis ou editor LaTeX",
                                    "Python/MATLAB para visualização opcional"
                                  ],
                                  "tips": "Use notação consistente para índices j e n; desenhe a malha para visualizar.",
                                  "learningObjective": "Entender as aproximações diferenciais nos esquemas FD para a equação parabólica.",
                                  "commonMistakes": [
                                    "Confundir índices temporais n e n+1",
                                    "Esquecer o fator α na definição de r",
                                    "Não truncar a série de Taylor corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Erro de Truncamento Local (LTE) para o Esquema Explícito",
                                  "subSteps": [
                                    "Substitua u(x_j, t_n) pela expansão de Taylor em torno de (x_j, t_n).",
                                    "Expanda u(x_j ± Δx, t_n) e u(x_j, t_n + Δt) até termos O(Δt²) e O(Δx⁴).",
                                    "Some os termos e isole o LTE: τ^n_j = [u(x_j, t_{n+1}) - u(x_j, t_n)/Δt] - α [u(x_{j+1}, t_n) - 2u(x_j, t_n) + u(x_{j-1}, t_n)] / Δx².",
                                    "Mostre que τ^n_j = O(Δt) + O(Δx²) usando derivadas parciais.",
                                    "Escreva explicitamente: τ = (Δt/2) ∂²u/∂t² + (Δx²/12) α ∂⁴u/∂x⁴ + O(Δt², Δx⁴)."
                                  ],
                                  "verification": "Confirme que o LTE é O(Δt) + O(Δx²) simplificando as expressões algébricas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Software simbólico como SymPy (Python)",
                                    "Referência: LeVeque 'Finite Difference Methods'"
                                  ],
                                  "tips": "Agrupe termos por ordens de Δt e Δx; verifique dimensionalidade.",
                                  "learningObjective": "Calcular precisamente o LTE para方案 explícito e identificar ordens de precisão.",
                                  "commonMistakes": [
                                    "Erro no sinal das expansões de Taylor para vizinhos espaciais",
                                    "Ignorar termos mistos ∂⁴u/∂x²∂t",
                                    "Confundir LTE com erro global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Erro de Truncamento Local (LTE) para o Esquema Implícito",
                                  "subSteps": [
                                    "Expanda u em torno de (x_j, t_{n+1}) para os termos em n+1.",
                                    "Aplique a expansão de Taylor para o lado esquerdo do esquema implícito.",
                                    "Expresse o esquema como I - r δ² u^{n+1} = u^n, onde δ² é o operador laplaciano FD.",
                                    "Calcule τ^n_j = [u(t_{n+1}) - u(t_n)/Δt] - α δ² u(t_{n+1}).",
                                    "Demonstre que τ = O(Δt) + O(Δx²), similar ao explícito, com termos (Δt/2) ∂²u/∂t²|_{n+1} + (Δx²/12) α ∂⁴u/∂x⁴|_{n+1}."
                                  ],
                                  "verification": "Compare as expressões de LTE explícito vs. implícito; confirme mesma ordem de consistência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SymPy ou Mathematica para expansões automáticas",
                                    "Notas do step anterior"
                                  ],
                                  "tips": "Note que para implícito, as derivadas são avaliadas em t_{n+1}; use aproximação para análise.",
                                  "learningObjective": "Comparar LTE entre esquemas explícito e implícito.",
                                  "commonMistakes": [
                                    "Avaliar derivadas no tempo errado (n vs n+1)",
                                    "Esquecer de dividir por Δt no operador temporal",
                                    "Não linearizar corretamente o sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Ordem de Consistência e Impacto na Precisão Global",
                                  "subSteps": [
                                    "Defina consistência: lim_{Δt,Δx→0} max |τ| = 0, com ordem p+q onde p para tempo, q para espaço.",
                                    "Mostre que ambos esquemas são consistentes de ordem O(Δt) + O(Δx²).",
                                    "Discuta relação com precisão global via teorema Lax: consistência + estabilidade ⇒ convergência.",
                                    "Analise impacto: erro global O(Δt + Δx²) para solução suave.",
                                    "Teste numericamente reduzindo Δt e Δx, plotando log(erros) vs log(Δ)."
                                  ],
                                  "verification": "Implemente código simples para verificar redução de erro com refinamento de malha.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Exemplo de código para EDCalor"
                                  ],
                                  "tips": "Use malha 2D para plotar erros; refine Δx por fator 2, Δt proporcional.",
                                  "learningObjective": "Ligar consistência local à precisão global e validar numericamente.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade",
                                    "Não normalizar r=Δt/Δx² constante",
                                    "Ignorar condições de contorno no teste numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o esquema explícito para u_t = u_xx em [0,1]x[0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx). Calcule LTE analiticamente e compare com erro numérico para Δx=0.1, Δt=0.001, mostrando O(Δt + Δx²).",
                              "finalVerifications": [
                                "LTE explícito e implícito corretamente derivados como O(Δt) + O(Δx²).",
                                "Expansões de Taylor verificadas até ordens necessárias.",
                                "Análise qualitativa do impacto na precisão global apresentada.",
                                "Teste numérico confirma ordem de convergência.",
                                "Diferenças sutis entre explícito e implícito destacadas.",
                                "Definição formal de consistência aplicada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de LTE (90% correto).",
                                "Clareza nas expansões de Taylor e isolamento de termos de erro.",
                                "Correta identificação da ordem de consistência para ambos esquemas.",
                                "Análise do impacto global com referência a teoremas relevantes.",
                                "Qualidade do exemplo prático e verificação numérica.",
                                "Ausência de erros comuns em notação ou cálculo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e conservação de energia.",
                                "Programação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD para transferência de calor.",
                                "Estatística: Análise de erros e convergência em métodos computacionais."
                              ],
                              "realWorldApplication": "Em engenharia térmica, verifica-se consistência de esquemas FD para simular distribuição de temperatura em painéis solares ou reatores nucleares, garantindo precisão em previsões de eficiência energética e evitando superaquecimento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Análise de Estabilidade pelo Método de Von Neumann",
                            "description": "Aplicar análise de Von Neumann para determinar a condição de estabilidade r ≤ 1/2 no esquema explícito, calculando o fator de amplificação e interpretando modos de dispersão e dissipação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Esquema Explícito para Equações Parabólicas",
                                  "subSteps": [
                                    "Estude a equação de calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Apresente o esquema explícito de diferenças finitas: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Identifique os parâmetros: Δt (passo temporal), Δx (passo espacial) e r (número de Courant).",
                                    "Verifique a consistência local do esquema comparando com a equação diferencial.",
                                    "Discuta limitações iniciais do esquema explícito sem análise de estabilidade."
                                  ],
                                  "verification": "Derive corretamente o esquema explícito a partir da equação de calor e identifique todos os termos envolvidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis ou software como Mathematica/MATLAB para derivações simbólicas"
                                  ],
                                  "tips": "Use notação indexada consistentemente (j para espaço, n para tempo) para evitar confusões.",
                                  "learningObjective": "Compreender a formulação do esquema explícito e seu papel na discretização de equações parabólicas.",
                                  "commonMistakes": [
                                    "Confundir o sinal no laplaciano discreto",
                                    "Esquecer o fator r na definição",
                                    "Ignorar a dimensionalidade da equação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Análise de Von Neumann e Suposição de Onda",
                                  "subSteps": [
                                    "Explique o método de Von Neumann: assume solução u_j^n = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação e k o número de onda.",
                                    "Substitua a forma de onda no esquema explícito para obter ξ(k).",
                                    "Derive a expressão: ξ = 1 + r (e^{i k Δx} - 2 + e^{-i k Δx}) = 1 - 4 r sin²(θ/2), com θ = k Δx.",
                                    "Discuta a independência da análise em relação às condições iniciais (análise linearizada).",
                                    "Calcule ξ para diferentes valores de θ (ex: θ=0, π)."
                                  ],
                                  "verification": "Obtenha a fórmula exata de ξ em termos de r e θ, simplificando corretamente os termos exponenciais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software de plotagem (ex: Python com NumPy/Matplotlib)",
                                    "Notas de aula sobre análise de Fourier"
                                  ],
                                  "tips": "Lembre-se que e^{iθ} + e^{-iθ} = 2 cos θ para simplificar trigonométricamente.",
                                  "learningObjective": "Dominar a substituição da forma de onda plana e derivação do fator de amplificação ξ.",
                                  "commonMistakes": [
                                    "Erro no expoente da forma de onda (ξ^n vs ξ^{n+1})",
                                    "Confundir θ = k Δx com k Δt",
                                    "Não usar identidade trigonométrica para sin²"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a Condição de Estabilidade |ξ| ≤ 1",
                                  "subSteps": [
                                    "Calcule o módulo |ξ| = |1 - 4 r sin²(θ/2)|.",
                                    "Analise |ξ| ≤ 1 para todo θ ∈ [0, π]: o máximo de sin² é 1, então |1 - 4r| ≤ 1 e 1 ≤ 1 (sempre verdadeiro).",
                                    "Resolva 1 - 4r ≥ -1 ⇒ r ≤ 1/2.",
                                    "Verifique numericamente plotando |ξ| vs θ para r=0.4 (estável) e r=0.6 (instável).",
                                    "Conclua que r ≤ 1/2 é necessário e suficiente para estabilidade no esquema explícito."
                                  ],
                                  "verification": "Prove matematicamente que r ≤ 1/2 garante |ξ| ≤ 1 para todos os modos de onda.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python ou MATLAB para plotar |ξ(θ)|",
                                    "Papel para análise analítica"
                                  ],
                                  "tips": "Considere os casos extremos: θ=0 (ξ=1, modo constante) e θ=π (ξ=1-4r, modo oscilante).",
                                  "learningObjective": "Estabelecer e justificar a condição de estabilidade r ≤ 1/2 via análise espectral.",
                                  "commonMistakes": [
                                    "Esquecer de verificar tanto ξ ≥ -1 quanto ξ ≤ 1",
                                    "Confundir estabilidade com consistência",
                                    "Ignorar modos de alta frequência (θ≈π)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Modos de Dispersão e Dissipação",
                                  "subSteps": [
                                    "Defina dissipação: |ξ| < 1 amortece amplitudes (numerically damping).",
                                    "Defina dispersão: fase de ξ difere da exata, causando distorção de ondas.",
                                    "Calcule a velocidade de fase numérica: ω_num / k, onde arg(ξ)/Δt = ω_num.",
                                    "Compare com a solução exata (dispersão não-dissipativa para heat equation).",
                                    "Discuta implicações: baixa dissipação para r pequeno, mas custo computacional alto."
                                  ],
                                  "verification": "Descreva qualitativamente como modos curtos (alta k) são mais dissipados e explique dispersão via plots de fase.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software para análise de fase (ex: MATLAB phase plot)",
                                    "Referências sobre análise de erros numéricos"
                                  ],
                                  "tips": "Use plots de |ξ| e arg(ξ) vs θ para visualização intuitiva dos erros.",
                                  "learningObjective": "Interpretar os efeitos físicos da estabilidade: dissipação numérica e erro de dispersão.",
                                  "commonMistakes": [
                                    "Confundir dissipação com dispersão",
                                    "Ignorar que heat equation é puramente dissipativa (sem dispersão exata)",
                                    "Não normalizar velocidades de fase"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor com α=1, Δx=0.1, teste r=0.4 (estável): simule u_j^0 = sin(π j / N), compute 10 passos e verifique ||u^{10}|| ≈ |ξ|^{10} ||u^0|| < ||u^0|| para modos não-nulos. Para r=0.6, observe blow-up.",
                              "finalVerifications": [
                                "Deriva corretamente ξ = 1 - 4r sin²(θ/2).",
                                "Prova r ≤ 1/2 como condição de estabilidade.",
                                "Plota |ξ(θ)| mostrando estabilidade/instabilidade.",
                                "Explica dissipação para modos de alta frequência.",
                                "Identifica dispersão via arg(ξ).",
                                "Aplica a um exemplo numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ξ (100% correto).",
                                "Compreensão analítica da condição r ≤ 1/2.",
                                "Qualidade de plots e interpretações visuais.",
                                "Correta distinção entre dissipação e dispersão.",
                                "Aplicação prática em simulação numérica.",
                                "Clareza na explicação de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em equações de difusão (ex: propagação de calor).",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD para estabilidade em métodos explícitos.",
                                "Matemática Aplicada: Análise de Fourier e estabilidade espectral."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes (ex: modelo de heat para temperatura atmosférica), garante que perturbações numéricas não amplifiquem erros, evitando previsões instáveis em supercomputadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Teorema de Lax para Convergência",
                            "description": "Explicar e aplicar o teorema de Lax-Richtmyer, relacionando consistência e estabilidade à convergência de métodos de diferenças finitas para equações parabólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Consistência, Estabilidade e Convergência",
                                  "subSteps": [
                                    "Defina consistência: compare a solução discreta com a solução exata da PDE à medida que h→0 e Δt→0.",
                                    "Explique estabilidade: analise o crescimento de erros usando normas ou análise de von Neumann.",
                                    "Descreva convergência: a solução numérica aproxima a solução exata.",
                                    "Estude a relação qualitativa: consistência + estabilidade ⇒ convergência (intuição do teorema).",
                                    "Resolva exercícios simples de identificação de consistência em esquemas de diferenças finitas."
                                  ],
                                  "verification": "Responda corretamente a um questionário com 5 definições e exemplos de cada conceito.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula sobre PDEs parabólicas, calculadora simbólica como SymPy."
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar as relações entre os três conceitos.",
                                  "learningObjective": "Compreender as definições precisas e interdependências de consistência, estabilidade e convergência.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com consistência; ignorar condições de CFL para estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Enunciado e Prova do Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Leia o enunciado formal: Para esquemas lineares consistentes, estabilidade implica convergência.",
                                    "Analise a prova: revise truncagem local, norma de energia e desigualdade de Lax.",
                                    "Derive passos chave da prova para o caso linear homogêneo.",
                                    "Discuta extensões para esquemas não-lineares ou semi-discretos.",
                                    "Compare com contra-exemplos onde falta consistência ou estabilidade."
                                  ],
                                  "verification": "Escreva um resumo da prova em 1 página e identifique 2 teoremas auxiliares usados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Artigo original de Lax-Richtmyer (1956), vídeo-aula sobre teoremas de equivalência, papel e lápis para derivações."
                                  ],
                                  "tips": "Anote símbolos chave (ex: ||e|| para norma de erro) e memorize o 'se e somente se' para esquemas lineares.",
                                  "learningObjective": "Dominar o enunciado preciso e os passos da prova do teorema.",
                                  "commonMistakes": [
                                    "Omitir a hipótese de linearidade; confundir com teorema de Lax-Wendroff."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Teorema a Métodos de Diferenças Finitas para Equações Parabólicas",
                                  "subSteps": [
                                    "Escolha o esquema explícito para a equação do calor u_t = u_xx.",
                                    "Verifique consistência: calcule erro de truncagem O(Δt + h²).",
                                    "Analise estabilidade: use análise de von Neumann para |g| ≤ 1 sob condição CFL r = Δt/h² ≤ 1/2.",
                                    "Conclua convergência pelo teorema de Lax.",
                                    "Teste numericamente com código simples em Python/MATLAB."
                                  ],
                                  "verification": "Implemente e rode simulação mostrando convergência com h refinado.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib, template de código para heat equation, grid de 100x100 pontos."
                                  ],
                                  "tips": "Comece com domínio periódico para simplificar análise de Fourier.",
                                  "learningObjective": "Aplicar o teorema para provar convergência em um esquema específico.",
                                  "commonMistakes": [
                                    "Escolher r > 1/2 sem notar instabilidade; erro em cálculo de amplificação g(k)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Contra-Exemplos e Extensões",
                                  "subSteps": [
                                    "Estude esquema instável (ex: r > 1/2) e observe divergência numérica.",
                                    "Analise esquema inconsistente (ex: diferenças finitas enviesadas de ordem zero).",
                                    "Discuta aplicações em esquemas implícitos (incondicionalmente estáveis).",
                                    "Resolva 3 exercícios variados envolvendo o teorema.",
                                    "Debata limitações do teorema em problemas não-lineares."
                                  ],
                                  "verification": "Produza gráficos comparando soluções convergentes vs. divergentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python estendido, referências como Gustafsson et al., fórum para dúvidas."
                                  ],
                                  "tips": "Use log-scale em gráficos de erro para visualizar ordens de convergência.",
                                  "learningObjective": "Identificar falhas e estender o teorema a contextos reais.",
                                  "commonMistakes": [
                                    "Assumir convergência sem estabilidade; ignorar condições de contorno."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = ν u_xx em [0,1]x[0,T] com u(0,x)=sin(πx), u(t,0)=u(t,1)=0: use esquema explícito com h=1/100, Δt=h²/6 (CFL=1/6<1/2). Verifique consistência (O(Δt+h²)), estabilidade (von Neumann), e convergência numérica plotando ||u_num - u_exata||_∞ →0 ao refinar malha.",
                              "finalVerifications": [
                                "Explique verbalmente o teorema e sua prova em 5 minutos.",
                                "Prove convergência para esquema FTCS na equação do calor.",
                                "Identifique por que um esquema com r=1 diverge.",
                                "Implemente código que demonstre ordem de convergência 2 em h.",
                                "Resolva um problema escrito envolvendo extensão não-linear.",
                                "Compare com teorema de Lax-Wendroff em 3 diferenças chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado e prova do teorema (30%).",
                                "Correta análise de consistência/estabilidade em exemplos (25%).",
                                "Implementação numérica com gráficos de convergência (20%).",
                                "Identificação de contra-exemplos e limitações (15%).",
                                "Clareza em explicações e conexões conceituais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de erros em simulações CFD.",
                                "Computação: Otimização de solvers numéricos em bibliotecas como FEniCS.",
                                "Engenharia: Verificação de convergência em simulações de reservatórios petrolíferos.",
                                "Estatística: Análise de erros de Monte Carlo em métodos numéricos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes, o teorema garante que modelos numéricos baseados em diferenças finitas convirjam para a solução física real sob condições de estabilidade, permitindo previsões confiáveis em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Métodos ADI para Equações Parabólicas em Duas Dimensões",
                        "description": "Método de Diferenças Alternadas em Direções (ADI) para resolver eficientemente equações do calor bidimensionais, superando limitações de estabilidade em malhas 2D.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Formulação do Método ADI",
                            "description": "Derivar o algoritmo ADI de Peaceman-Rachford para ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²), descrevendo as duas meias-etapas e a solução de sistemas tridiagonais em cada direção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão do esquema implícito unidirecional e solução de sistemas tridiagonais",
                                  "subSteps": [
                                    "Lembre a discretização da equação de calor 1D usando diferenças finitas: ∂u/∂t ≈ (u_{i}^{n+1} - u_{i}^n)/Δt = α δ_{xx} u^{n+1}.",
                                    "Escreva a matriz tridiagonal resultante para o esquema implícito.",
                                    "Descreva o método Thomas (algoritmo tridiagonal) para resolver Au = b.",
                                    "Implemente um exemplo numérico simples em pseudocódigo.",
                                    "Verifique a estabilidade incondicional do esquema implícito."
                                  ],
                                  "verification": "Resolva manualmente um sistema tridiagonal 3x3 e confira com software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Livro de análise numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Sempre normalize os coeficientes da matriz tridiagonal para evitar erros numéricos.",
                                  "learningObjective": "Compreender e aplicar o solver tridiagonal para esquemas implícitos 1D.",
                                  "commonMistakes": [
                                    "Confundir operadores forward e backward",
                                    "Esquecer fatores de Δx² no operador Laplaciano",
                                    "Não aplicar condições de contorno corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Motivação e formulação geral do método ADI de Peaceman-Rachford",
                                  "subSteps": [
                                    "Discuta limitações do esquema implícito totalmente implícito em 2D (matriz pentadiagonal grande).",
                                    "Introduza a ideia de splitting directional: tratar x implícito em uma meia-etapa e y na outra.",
                                    "Escreva a equação parabólica 2D: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²).",
                                    "Apresente a forma geral do ADI: duas meias-etapas aproximando o operador de Laplace.",
                                    "Justifique a ordem de precisão O(Δt² + Δx² + Δy²)."
                                  ],
                                  "verification": "Esboce o stencil em grade 2D para o esquema totalmente implícito vs. ADI.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Grade quadriculada impressa",
                                    "Referência: notas de aula ou artigo de Peaceman-Rachford (1955)"
                                  ],
                                  "tips": "Visualize o splitting como 'alternar direções' para reduzir custo computacional de O(N²) para O(N).",
                                  "learningObjective": "Entender a motivação e estrutura geral do ADI para eficiência em 2D.",
                                  "commonMistakes": [
                                    "Confundir ADI com métodos explícitos",
                                    "Ignorar o fator 1/2 em Δt nas meias-etapas",
                                    "Não reconhecer a consistência do splitting"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação da primeira meia-etapa (direção x implícita, y explícita)",
                                  "subSteps": [
                                    "Parta da expansão de Taylor para u* em tempo n + Δt/2.",
                                    "Aproxime: (u* - u^n)/(Δt/2) = α (δ_{xx} u* + δ_{yy} u^n).",
                                    "Reorganize para: (I - (Δt/2)α δ_{xx}) u* = (I + (Δt/2)α δ_{yy}) u^n.",
                                    "Identifique os sistemas tridiagonais ao longo de linhas y=constante.",
                                    "Aplique condições de contorno na direção x."
                                  ],
                                  "verification": "Derive a equação para um ponto interno e escreva o sistema para uma linha fixa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python ou MATLAB para testar stencil",
                                    "Folha com operadores δ_{xx} e δ_{yy}"
                                  ],
                                  "tips": "Use notação matricial: A_x u* = B_y u^n, onde A_x é tridiagonal por linha.",
                                  "learningObjective": "Derivar e interpretar a primeira meia-etapa do Peaceman-Rachford.",
                                  "commonMistakes": [
                                    "Trocar implícito/explícito entre direções",
                                    "Esquecer o sinal nos operadores δ",
                                    "Não dividir Δt por 2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivação da segunda meia-etapa (direção y implícita, x explícita)",
                                  "subSteps": [
                                    "Continue de u*: (u^{n+1} - u*)/(Δt/2) = α (δ_{xx} u* + δ_{yy} u^{n+1}).",
                                    "Reorganize para: (I - (Δt/2)α δ_{yy}) u^{n+1} = (I + (Δt/2)α δ_{xx}) u*.",
                                    "Identifique sistemas tridiagonais ao longo de colunas x=constante.",
                                    "Mostre que o esquema completo é segundo-ordem preciso.",
                                    "Implemente pseudocódigo para o ciclo completo."
                                  ],
                                  "verification": "Combine as duas meias-etapas e verifique consistência com a equação original.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python inicial para ADI",
                                    "Gráficos de solução teste"
                                  ],
                                  "tips": "Resolva linhas primeiro (x), depois colunas (y) para vetorização eficiente.",
                                  "learningObjective": "Completar a derivação e entender a alternância direcional.",
                                  "commonMistakes": [
                                    "Usar u^n em vez de u* na segunda etapa",
                                    "Confundir ordem das meias-etapas",
                                    "Ignorar estabilidade (von Neumann)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise de estabilidade, implementação e verificação",
                                  "subSteps": [
                                    "Analise estabilidade via amplificação de Fourier: mostre incondicionalmente estável.",
                                    "Implemente código completo em Python/MATLAB para grade 2D com C.C. Dirichlet.",
                                    "Teste com solução exata (ex: u=exp(-π²α t) sin(πx) sin(πy)).",
                                    "Compare erro com método explícito.",
                                    "Discuta generalizações (quadraturas, não-uniform grids)."
                                  ],
                                  "verification": "Execute simulação e plote norma do erro < 1e-3.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python (NumPy, Matplotlib, SciPy para solve tridiagonal)",
                                    "Exemplo de dados de teste"
                                  ],
                                  "tips": "Use função thomas solver reutilizável para ambas direções.",
                                  "learningObjective": "Implementar, testar e validar o método ADI.",
                                  "commonMistakes": [
                                    "Índices errados em loops 2D",
                                    "Não zerar fantasmas para C.C.",
                                    "Escala errada de α Δt / Δx²"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a difusão de calor em uma placa quadrada metálica inicial com temperatura alta no centro, usando grade 50x50, α=1, Δt=0.01, observando como o ADI resolve rapidamente sistemas tridiagonais em cada iteração, produzindo contornos de temperatura suaves em 100 passos temporais.",
                              "finalVerifications": [
                                "Escrever corretamente as equações das duas meias-etapas.",
                                "Resolver manualmente um sistema tridiagonal de uma linha/coluna.",
                                "Implementar código funcional que converge para solução conhecida.",
                                "Explicar por que o ADI é mais eficiente que Crank-Nicolson 2D full.",
                                "Analisar gráfico de erro temporal e espacial.",
                                "Descrever aplicação de condições de contorno no esquema."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das meias-etapas (sem erros algébricos).",
                                "Correção na implementação do solver tridiagonal (erro <1e-6).",
                                "Demonstração de estabilidade incondicional via teste numérico.",
                                "Eficiência computacional: tempo de execução vs. método full implícito.",
                                "Capacidade de generalizar para grids não-uniformes.",
                                "Clareza na explicação oral/escrita do algoritmo."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação em Python/MATLAB com solvers lineares.",
                                "Física: Modelagem de difusão térmica e fluxo de fluidos.",
                                "Engenharia: Simulação de processos em materiais compósitos.",
                                "Estatística: Análise de erros numéricos e convergência.",
                                "Ciências da Computação: Otimização de algoritmos paralelizáveis."
                              ],
                              "realWorldApplication": "O método ADI é usado em simulações de reservatórios petrolíferos para modelar fluxo multifásico em 2D/3D, previsão de difusão de poluentes em aquíferos e design térmico de circuitos integrados, permitindo simulações eficientes em grids grandes sem supercomputadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Análise de Estabilidade do ADI",
                            "description": "Analisar a estabilidade incondicional do método ADI usando amplificação complexa, comparando com métodos explícitos e destacando vantagens para problemas multidimensionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação do Método ADI para Equações Parabólicas em 2D",
                                  "subSteps": [
                                    "Estudar a equação modelo: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²).",
                                    "Entender a decomposição em direções alternadas: passo em x implícito, depois y explícito, e vice-versa.",
                                    "Derivar o esquema ADI de Douglas-Rachford ou Peaceman-Rachford.",
                                    "Implementar discretização em grade uniforme com diferenças finitas centrais.",
                                    "Verificar consistência do esquema via expansão de Taylor."
                                  ],
                                  "verification": "Capacidade de escrever o esquema ADI completo para uma grade 2D e demonstrar consistência de ordem O(Δt) + O(Δx²).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), papel e lápis, software MATLAB ou Python para visualização"
                                  ],
                                  "tips": "Comece com o caso 1D para intuitivamente entender a alternância antes de estender para 2D.",
                                  "learningObjective": "Compreender a estrutura algébrica do ADI e sua relação com métodos implícitos unidimensionais.",
                                  "commonMistakes": [
                                    "Confundir ordens de alternância entre sweeps pares e ímpares.",
                                    "Ignorar condições de contorno na formulação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Análise de Estabilidade via Fator de Amplificação Complexa",
                                  "subSteps": [
                                    "Revisar von Neumann stability analysis para esquemas 1D e 2D.",
                                    "Definir o fator de amplificação G = u^{n+1}/u^n assumindo modo Fourier u = ξ exp(i k_x x + i k_y y).",
                                    "|G| ≤ 1 + O(Δt) para estabilidade.",
                                    "Explicar amplificação complexa para esquemas multi-etapa como ADI.",
                                    "Discutir o espectro de amplificação em planos complexos."
                                  ],
                                  "verification": "Derivar |G| para o método explícito FTCS e mostrar restrição CFL: r = α Δt / Δx² ≤ 1/4.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre análise von Neumann, calculadora simbólica (SymPy), quadro branco"
                                  ],
                                  "tips": "Use ξ = exp(i θ) para simplificar cálculos trigonométricos em fatores de amplificação.",
                                  "learningObjective": "Dominar o framework de análise de estabilidade via amplificação complexa para métodos implícitos.",
                                  "commonMistakes": [
                                    "Esquecer o fator i nas derivadas espaciais Fourier.",
                                    "Confundir estabilidade condicional vs. incondicional."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Fator de Amplificação para o Método ADI",
                                  "subSteps": [
                                    "Obter G_ADI aproximando o esquema em duas meias-etapas: implícito em x, semi-implícito em y.",
                                    "Calcular G_x = 1 / (1 + 2 r (1 - cos θ_x)) para direção x.",
                                    "Combinar G_ADI ≈ G_x * G_y para ciclo completo, com r_x = α Δt / (2 Δx²), r_y similar.",
                                    "Mostrar |G_ADI| ≤ 1 para qualquer r > 0 via análise geométrica no plano complexo.",
                                    "Verificar numericamente com plots de |G| vs. θ_x, θ_y."
                                  ],
                                  "verification": "Derivação analítica de |G_ADI| ≤ 1 e plot confirmando ausência de restrição CFL.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Python para plots de |G|, referências como Gustafsson et al."
                                  ],
                                  "tips": "Aproxime para pequenos r primeiro, depois prove rigorosamente usando desigualdade triangular.",
                                  "learningObjective": "Derivar explicitamente a estabilidade incondicional do ADI via amplificação complexa.",
                                  "commonMistakes": [
                                    "Erro no fator 1/2 no r para meias-etapas.",
                                    "Não considerar θ_x e θ_y independentes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Métodos Explícitos e Destacar Vantagens Multidimensionais",
                                  "subSteps": [
                                    "Comparar com FTCS explícito 2D: restrição r ≤ 1/4 em ambas direções.",
                                    "Analisar ADI vs. implícito totalmente acoplado (matriz bloqueada 2D).",
                                    "Discutir custo computacional: ADI resolve tridiagonais 1D vs. sparse 2D.",
                                    "Estender para >2D: fatoração ADI generalizada mantém estabilidade incondicional.",
                                    "Simular erro de dispersão/parabólico em ondas altas."
                                  ],
                                  "verification": "Tabela comparativa de condições de estabilidade, custo O(N) vs. O(N log N), e simulação numérica estável para r=10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para simulações 2D, benchmarks de tempo de CPU"
                                  ],
                                  "tips": "Use problemas teste como gaussiana difusa para visualizar estabilidade.",
                                  "learningObjective": "Identificar superioridade do ADI em eficiência e robustez para PDES multidimensionais.",
                                  "commonMistakes": [
                                    "Superestimar custo do implícito full vs. ADI.",
                                    "Ignorar overhead de boundaries em grids grandes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Verificar em um Caso Prático",
                                  "subSteps": [
                                    "Implementar código ADI para equação de calor 2D com condições iniciais sinusoidais.",
                                    "Testar com r grande (ex: 50) e comparar com explícito instável.",
                                    "Analisar resíduos de estabilidade via FFT do erro.",
                                    "Documentar vantagens em grids finos (alta resolução).",
                                    "Explorar extensões como ADI não-linear."
                                  ],
                                  "verification": "Simulação converge sem oscilações para r>>1, com norma L2 estável ao longo do tempo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/NumPy/SciPy, Jupyter notebook"
                                  ],
                                  "tips": "Vectorize o código para eficiência; use periodic BCs para von Neumann puro.",
                                  "learningObjective": "Aplicar análise teórica em implementação prática, confirmando estabilidade incondicional.",
                                  "commonMistakes": [
                                    "Implementação errada de boundaries mistas.",
                                    "Não normalizar erros adequadamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a difusão de calor em uma placa 2D metálica (50x50 grid, Δt=0.1, Δx=0.01, r=50). Use ADI para propagar uma mancha quente inicial sem restrições CFL, contrastando com falha do FTCS explícito que diverge.",
                              "finalVerifications": [
                                "Derivação correta do |G_ADI| ≤ 1 para qualquer r.",
                                "Identificação precisa da restrição CFL em métodos explícitos 2D.",
                                "Implementação numérica de ADI estável para r=100.",
                                "Tabela comparativa de custos e estabilidades.",
                                "Explicação verbal das vantagens multidimensionais.",
                                "Análise de erros de fase/dispersão via plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator de amplificação (90% correto).",
                                "Demonstração de estabilidade incondicional via prova ou plot.",
                                "Comparação quantitativa com explícito (CFL, custo flops).",
                                "Clareza na discussão de aplicações 2D+.",
                                "Implementação código livre de bugs com validação.",
                                "Profundidade em erros comuns e mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e fluidos incompressíveis.",
                                "Computação: Algoritmos paralelizáveis e solvers lineares (Thomas algorithm).",
                                "Engenharia: Simulações CFD e FEM para estruturas multidimensionais.",
                                "Estatística: Análise espectral e FFT em dados numéricos."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em painéis solares ou difusão de poluentes em aquíferos 2D, o ADI permite passos de tempo grandes em grids refinados, reduzindo tempo computacional em supercomputadores para previsões climáticas ou design aeroespacial."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Consistência de Esquemas Numéricos",
                    "description": "Definição e análise de consistência para métodos numéricos em equações parabólicas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Definição de Consistência Numérica",
                        "description": "Definição formal de consistência para esquemas numéricos de diferenças finitas em equações parabólicas, incluindo a condição de que o erro de truncamento local tende a zero à medida que os passos de malha h e k tendem a zero.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Reconhecer a definição de consistência",
                            "description": "Explicar a definição de consistência de um esquema numérico e sua importância para a aproximação da equação diferencial parabólica original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações diferenciais parabólicas",
                                  "subSteps": [
                                    "Estude a forma geral de uma EDP parabólica: ∂u/∂t = L(u), onde L é um operador elíptico.",
                                    "Examine o exemplo clássico da equação do calor: ∂u/∂t = κ ∂²u/∂x².",
                                    "Identifique condições iniciais e de contorno típicas para problemas parabólicos.",
                                    "Discuta soluções analíticas simples para entender o comportamento físico.",
                                    "Anote as propriedades chave: suavidade temporal e difusão espacial."
                                  ],
                                  "verification": "Resuma em suas palavras a forma geral e dê um exemplo da equação do calor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDPs)",
                                    "Folha de papel e caneta",
                                    "Vídeo introdutório sobre equação do calor (Khan Academy)"
                                  ],
                                  "tips": "Visualize a difusão de calor em uma barra para intuitivamente entender o problema.",
                                  "learningObjective": "Compreender o problema físico-matemático que os esquemas numéricos aproximam.",
                                  "commonMistakes": "Confundir parabólicas com hiperbólicas (ondas vs. difusão)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir esquemas numéricos discretos",
                                  "subSteps": [
                                    "Aprenda a discretização espacial: substitua derivadas por diferenças finitas (ex: ∂²u/∂x² ≈ (u_{j+1} - 2u_j + u_{j-1})/h²).",
                                    "Entenda discretização temporal: métodos explícito (forward Euler) vs. implícito (backward Euler).",
                                    "Escreva o esquema FTCS (Forward Time Centered Space) para a equação do calor.",
                                    "Calcule manualmente um passo de tempo para uma grade simples (3 pontos).",
                                    "Compare com a solução exata em um ponto para ver discrepâncias iniciais."
                                  ],
                                  "verification": "Implemente e execute um esquema simples em Python ou MATLAB para 5 iterações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB com NumPy",
                                    "Grade de exemplo impressa",
                                    "Tutorial de diferenças finitas"
                                  ],
                                  "tips": "Comece com h=0.1 e dt=0.001 para ver estabilidade básica.",
                                  "learningObjective": "Saber como transformar uma EDP contínua em um sistema discreto.",
                                  "commonMistakes": "Ignorar a relação CFL para estabilidade (dt < h²/2κ)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conceituar erro de truncamento local",
                                  "subSteps": [
                                    "Defina truncamento local: substitua u exata no esquema e expanda em série de Taylor.",
                                    "Calcule o erro de truncamento para FTCS: O(dt + h²).",
                                    "Mostre que para consistência, esse erro deve ir a zero quando dt, h → 0.",
                                    "Compare com esquemas inconsistentes (ex: upwind errado).",
                                    "Pratique derivando Taylor para uma derivada segunda."
                                  ],
                                  "verification": "Derive o erro de truncamento para o esquema FTCS e confirme O(dt + h²).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy)",
                                    "Papel para expansões Taylor",
                                    "Exemplos resolvidos de livro-texto"
                                  ],
                                  "tips": "Lembre-se: ordens pares para derivadas espaciais centradas.",
                                  "learningObjective": "Calcular e interpretar o erro introduzido pela discretização.",
                                  "commonMistakes": "Esquecer termos de ordem superior na expansão Taylor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar definição de consistência e importância",
                                  "subSteps": [
                                    "Defina consistência: lim_{k→∞, h→0} τ(u^n, t_n; h,k) = 0 para solução exata u.",
                                    "Explique que consistência + estabilidade ⇒ convergência (Teorema de Lax).",
                                    "Discuta importância: garante que solução numérica → solução exata.",
                                    "Exemplo: esquema inconsistente não converge mesmo estável.",
                                    "Relacione com aproximação da EDP parabólica original."
                                  ],
                                  "verification": "Escreva a definição formal e explique por que é crucial para parabólicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Lax Equivalence",
                                    "Artigo introdutório sobre consistência"
                                  ],
                                  "tips": "Memorize: Consistência é sobre local (truncamento), estabilidade sobre global.",
                                  "learningObjective": "Reconhecer e articulating a definição precisa de consistência.",
                                  "commonMistakes": "Confundir consistência com convergência."
                                }
                              ],
                              "practicalExample": "Para a equação do calor ∂u/∂t = ∂²u/∂x² em [0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx). Esquema FTCS: u_j^{n+1} = u_j^n + r (u_{j-1}^n - 2u_j^n + u_{j+1}^n), r=dt/h². Expansão Taylor mostra truncamento O(dt + h²) → 0 quando dt,h→0, logo consistente.",
                              "finalVerifications": [
                                "Cite a definição formal de consistência para esquemas numéricos.",
                                "Calcule truncamento para um esquema dado e verifique se →0.",
                                "Explique ligação com Teorema de Equivalência de Lax.",
                                "Identifique se um esquema simples é consistente.",
                                "Discuta importância para aproximação de EDPs parabólicas.",
                                "Dê exemplo de esquema consistente vs. inconsistente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (incluindo limite de truncamento).",
                                "Correta derivação de erro de truncamento via Taylor.",
                                "Compreensão da relação consistência-estabilidade-convergência.",
                                "Aplicação correta a exemplo parabólico específico.",
                                "Explicação clara da importância para problemas reais.",
                                "Identificação de erros comuns em esquemas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e conservação de energia.",
                                "Computação: Implementação de solvers numéricos em programação científica.",
                                "Engenharia: Simulações CFD para fluxo de calor em estruturas.",
                                "Estatística: Análise de erros em métodos Monte Carlo para EDPs."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica (difusão de umidade), design de circuitos eletrônicos (dissipação de calor em chips) e modelagem financeira (equações de Black-Scholes parabólicas para precificação de opções), onde consistência garante precisão das simulações numéricas para decisões críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Identificar condições de consistência",
                            "description": "Determinar se um esquema numérico satisfaz a propriedade de consistência com base na definição formal para equações parabólicas como a equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de Consistência",
                                  "subSteps": [
                                    "Leia a definição formal: Um esquema numérico é consistente se o operador de truncagem local τ(h, k, u) → 0 quando h → 0 e k → 0, uniformemente em x e t.",
                                    "Identifique os componentes chave: solução exata L[u], operador numérico L_h,k[u_h], e τ = L[u] - L_h,k[u].",
                                    "Estude exemplos de esquemas para equações parabólicas, como a equação do calor u_t = u_xx.",
                                    "Anote as condições gerais: ordem de precisão pelo menos 1 em espaço e tempo.",
                                    "Compare consistência com estabilidade e convergência via teorema Lax."
                                  ],
                                  "verification": "Escreva a definição de consistência em suas próprias palavras e cite os limites necessários.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula sobre equações parabólicas"
                                  ],
                                  "tips": [
                                    "Use diagramas de operador para visualizar L e L_h,k.",
                                    "Foquem em notação padrão: h=Δx, k=Δt."
                                  ],
                                  "learningObjective": "Explicar verbalmente a definição formal de consistência e seus componentes.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade.",
                                    "Ignorar uniformidade no limite."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Erro de Truncagem Local (τ)",
                                  "subSteps": [
                                    "Escolha um esquema simples, ex: forward Euler em tempo e central em espaço para u_t = u_xx: u_j^{n+1} = u_j^n + (k/h^2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n).",
                                    "Expanda a solução exata u(x_j, t_n) em série de Taylor em torno de (x_j, t_n).",
                                    "Calcule L[u]: ∂u/∂t - ∂²u/∂x² = 0.",
                                    "Aplique o operador numérico L_h,k à solução exata interpolada.",
                                    "Derive τ explicitamente, mostrando termos O(k) + O(h^2).",
                                    "Verifique se τ → 0 quando h,k → 0."
                                  ],
                                  "verification": "Compute τ para o esquema acima e mostre que |τ| ≤ C(max(h^2,k)) para alguma constante C.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Papel e lápis ou software simbólico como SymPy",
                                    "Exemplos resolvidos de esquemas FD"
                                  ],
                                  "tips": [
                                    "Use expansão de Taylor até ordem 3 em x e 2 em t.",
                                    "Normalize por h e k para ver ordens."
                                  ],
                                  "learningObjective": "Calcular τ para um esquema dado e determinar sua ordem de consistência.",
                                  "commonMistakes": [
                                    "Erros em expansões de Taylor (sinais errados).",
                                    "Esquecer termos mistos ∂²u/∂t∂x."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Condições Necessárias para Consistência",
                                  "subSteps": [
                                    "Liste condições: aproximação consistente das derivadas (ex: diferenças centrais O(h^2) para ∂²/∂x²).",
                                    "Analise esquemas inconsistentes, ex: upwind biased com ordem 0.",
                                    "Para equações parabólicas, verifique simetria e positividade aproximada.",
                                    "Use definição geral: consistência requer que soluções constantes sejam exatas (ordem 0) e ordem ≥1 para convergência.",
                                    "Pratique com dois esquemas: um consistente (Crank-Nicolson) e um não (forward-forward).",
                                    "Documente condições: lim_{h,k→0} τ = 0 uniformemente."
                                  ],
                                  "verification": "Classifique 3 esquemas como consistentes ou não, justificando com cálculo de τ.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Tabela de esquemas numéricos para equação do calor",
                                    "Calculadora ou MATLAB para verificação numérica"
                                  ],
                                  "tips": [
                                    "Sempre verifique soluções constantes e lineares primeiro.",
                                    "Use norma supremo para uniformidade."
                                  ],
                                  "learningObjective": "Listar e verificar as condições matemáticas para consistência em esquemas parabólicos.",
                                  "commonMistakes": [
                                    "Assumir que ordem alta implica consistência sem limite uniforme.",
                                    "Ignorar dependência em k/h^2 (condição CFL)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Verificação em Exemplos Práticos",
                                  "subSteps": [
                                    "Pegue o esquema FTCS para u_t = α u_xx e compute τ.",
                                    "Teste com função teste u(x,t)=sin(πx) e^{ -π² α t }.",
                                    "Implemente numericamente: plote ||τ|| vs h,k pequenos.",
                                    "Analise falhas: se τ não →0, identifique por quê (ex: esquema instável mas consistente).",
                                    "Generalize para esquemas implícitos como Backward Euler.",
                                    "Conclua identificando condições: ordens adequadas e limite correto."
                                  ],
                                  "verification": "Produza um relatório curto com τ para 2 esquemas e conclusão de consistência.",
                                  "estimatedTime": "70 min",
                                  "materials": [
                                    "Python/MATLAB com NumPy/SciPy para plots",
                                    "Funções teste padrão"
                                  ],
                                  "tips": [
                                    "Use grids finos: h=0.01, k=0.001.",
                                    "Log-plot para ver ordens."
                                  ],
                                  "learningObjective": "Aplicar diagnóstico de consistência a esquemas reais para equações do calor.",
                                  "commonMistakes": [
                                    "Escolha de k muito grande violando relação h^2/k.",
                                    "Erro numérico mascarando truncagem analítica."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação do calor u_t = u_xx: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r=k/h^2. Expansão de Taylor dá τ = (k/2) u_{ttt} + O(h^2 + k^2), que →0 se k,h→0, provando consistência de ordem 1 em tempo e 2 em espaço.",
                              "finalVerifications": [
                                "Explicar definição de consistência sem consultar notas.",
                                "Calcular τ corretamente para esquema FTCS.",
                                "Identificar condição falha em esquema upwind forward: τ não →0.",
                                "Classificar Crank-Nicolson como consistente de ordem 2.",
                                "Plotar numericamente ||τ|| →0 para h,k decrescentes.",
                                "Discutir relação com teorema Lax."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de τ (ordens corretas).",
                                "Correta identificação de limites e uniformidade.",
                                "Uso apropriado de expansões de Taylor.",
                                "Análise de exemplos com justificativa matemática.",
                                "Clareza em relatórios e plots.",
                                "Conexão com aplicações parabólicas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e truncagem em simulações.",
                                "Computação: Implementação e análise de erros em códigos CFD.",
                                "Engenharia: Verificação de solvers numéricos em software CAE.",
                                "Estatística: Análise de erros de aproximação em métodos Monte Carlo.",
                                "Filosofia da Ciência: Rigor matemático em modelagem preditiva."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou engenharia térmica, verificar consistência garante que refinamento de malha (h,k menores) aproxime a solução física real, evitando erros em previsões de temperatura ou difusão de poluentes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Calcular limite do erro de truncamento",
                            "description": "Verificar se lim_{h,k→0} τ(u_h^k, x, t) = 0, onde τ é o erro de truncamento local, para um esquema dado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição de erro de truncamento local τ",
                                  "subSteps": [
                                    "Relembrar a equação parabólica exata: ∂u/∂t = L u, onde L é o operador diferencial espacial.",
                                    "Definir a solução exata u(x,t) e a aproximação u_h^k(x,t) no esquema numérico.",
                                    "Escrever a definição formal de τ(u_h^k, x, t) = L_h u_h^k - (u_h^k)^{k+1}/k, onde L_h é o operador discreto.",
                                    "Explicar que τ mede a inconsistência local do esquema com a equação contínua.",
                                    "Discutir o papel dos parâmetros h (passo espacial) e k (passo temporal)."
                                  ],
                                  "verification": "Capacidade de escrever corretamente a fórmula de τ para um esquema simples como o de Euler explícito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de análise numérica (cap. equações parabólicas)",
                                    "Notas de aula sobre consistência",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Sempre relacione τ com a expansão de Taylor da solução exata para visualizar ordens de truncamento.",
                                  "learningObjective": "Compreender conceitualmente o erro de truncamento local e sua fórmula padrão.",
                                  "commonMistakes": [
                                    "Confundir τ com erro global de consistência",
                                    "Ignorar dependência em h e k",
                                    "Esquecer o operador discreto L_h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o esquema numérico fornecido",
                                  "subSteps": [
                                    "Identificar o esquema dado (ex: forward Euler, Crank-Nicolson para equação do calor).",
                                    "Escrever as equações discretas: u^{k+1}_j = u^k_j + k/h^2 (u^k_{j+1} - 2u^k_j + u^k_{j-1}).",
                                    "Substituir a solução exata u(x_j, t_k) na equação discreta para obter u_h^k.",
                                    "Calcular os operadores discretos explicitamente: L_h u_h^k e a derivada temporal discreta.",
                                    "Verificar condições de estabilidade iniciais, se aplicável, para contexto."
                                  ],
                                  "verification": "Reescrever corretamente o esquema numérico com índices j (espaço) e k (tempo).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo de esquema numérico impresso ou digital",
                                    "Software como MATLAB para visualizar grade h-k",
                                    "Folha de exercícios com esquemas comuns"
                                  ],
                                  "tips": "Use notação consistente: x_j = j h, t_k = k k para evitar confusões.",
                                  "learningObjective": "Preparar a substituição da solução exata no esquema discreto.",
                                  "commonMistakes": [
                                    "Erros de indexação em diferenças finitas",
                                    "Confundir passos h e k",
                                    "Não especificar condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a expressão explícita para τ(u_h^k, x, t)",
                                  "subSteps": [
                                    "Inserir expansão de Taylor da solução exata u(x,t) ao redor de (x,t_k).",
                                    "Calcular L_h u_h^k usando diferenças finitas centradas ou forward/backward.",
                                    "Computar a diferença temporal: (u_h^{k+1} - u_h^k)/k usando Taylor em t.",
                                    "Combinar termos para obter τ = O(h^p + k^q), identificando ordens p e q.",
                                    "Simplificar expressões algébricas e cancelar termos principais."
                                  ],
                                  "verification": "Obter uma expressão para τ que mostre dependência em h e k, como τ = O(h^2 + k).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Mathematica ou SymPy)",
                                    "Papel milimetrado para expansões Taylor",
                                    "Tabela de expansões Taylor pré-prontas"
                                  ],
                                  "tips": "Comece com termos de ordem baixa e ignore O(h^3+) inicialmente para clareza.",
                                  "learningObjective": "Derivar τ explicitamente via expansões assintóticas.",
                                  "commonMistakes": [
                                    "Erros no sinal das diferenças finitas",
                                    "Esquecer termos mistos ∂²u/∂t∂x",
                                    "Não truncar corretamente as séries Taylor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o limite lim_{h,k→0} τ(u_h^k, x, t) e verificar consistência",
                                  "subSteps": [
                                    "Analisar o comportamento assintótico de cada termo em τ quando h→0 e k→0.",
                                    "Verificar se todos os termos não-constantes tendem a zero (ex: h^2 →0, k→0).",
                                    "Considerar solução u suave o suficiente (C^4 em x, C^2 em t).",
                                    "Concluir se lim τ = 0, implicando consistência do esquema.",
                                    "Testar com exemplo numérico simples para validar."
                                  ],
                                  "verification": "Demonstrar analiticamente que lim τ = 0 e identificar ordem de convergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo resolvido de esquema consistente/inconsistente",
                                    "Gráficos de τ vs h,k em Python/MATLAB"
                                  ],
                                  "tips": "Assuma h e k →0 independentemente ou com relação k = O(h^2) se necessário para estabilidade.",
                                  "learningObjective": "Verificar formalmente a condição de consistência numérica.",
                                  "commonMistakes": [
                                    "Assumir limite sem justificar suavidade de u",
                                    "Ignorar que limite deve ser uniforme em x,t",
                                    "Confundir com estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema explícito forward Euler na equação do calor ∂u/∂t = ∂²u/∂x²: substitua u(x_j,t_k) = exp(-π² t_k) sin(π x_j), calcule τ ≈ (π⁴ h²/12 - π² k/2) u + O(h⁴,k²,h²k), e mostre lim_{h,k→0} τ = 0.",
                              "finalVerifications": [
                                "A expressão de τ foi derivada corretamente com expansões Taylor?",
                                "O limite lim_{h,k→0} τ(u_h^k,x,t) = 0 foi demonstrado analiticamente?",
                                "Ordens de truncamento em h e k foram identificadas (ex: O(h² + k))?",
                                "Conclusão sobre consistência do esquema está correta?",
                                "Exemplo prático foi computado e limite verificado numericamente?",
                                "Assunções sobre suavidade de u foram explicitadas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de τ (ausência de erros algébricos: 30%)",
                                "Correta aplicação de expansões Taylor e análise assintótica (25%)",
                                "Demonstração rigorosa do limite =0 (20%)",
                                "Identificação de ordens de convergência e condições (15%)",
                                "Clareza na explicação e uso de notação consistente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e verificação numérica de leis físicas.",
                                "Programação: Implementação de esquemas em Python para plotar τ vs h,k.",
                                "Estatística: Análise de erros numéricos e convergência em simulações Monte Carlo.",
                                "Engenharia: Validação de solvers CFD para equações parabólicas."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou engenharia térmica, verificar consistência garante que refinamentos de malha (h,k menores) aproximem fielmente a realidade física, evitando erros em previsões de temperatura ou fluxo de calor."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Análise do Erro de Truncamento Local",
                        "description": "Desenvolvimento da expansão em série de Taylor para calcular o erro de truncamento local em esquemas de diferenças finitas para equações parabólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Aplicar expansão de Taylor em diferenças finitas",
                            "description": "Derivar o erro de truncamento local usando expansões de Taylor para aproximar derivadas espaciais e temporais em equações parabólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Expansões de Taylor para Funções de Duas Variáveis",
                                  "subSteps": [
                                    "Escreva a expansão de Taylor univariada para f(x + h) até ordem 2, incluindo o resto de Lagrange.",
                                    "Estenda para funções bivariadas u(x, t): expanda u(x + h, t) e u(x, t + k) ao redor de (x, t).",
                                    "Identifique derivadas parciais u_x, u_xx, u_t, u_tt e termos de ordem superior.",
                                    "Pratique com uma função teste como u(x,t) = sin(x) e^t.",
                                    "Anote os fatores corretos (1/n!) e o formato do resto."
                                  ],
                                  "verification": "Expanda corretamente u(x_j + Δx, t_n) até ordem 2 e verifique se matches com fórmula padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simbólica (opcional)",
                                    "Notas de Análise Numérica"
                                  ],
                                  "tips": "Sempre expanda ao redor do ponto central e inclua pelo menos até o termo que define a ordem do erro.",
                                  "learningObjective": "Dominar expansões de Taylor multivariadas para preparar análise de diferenças finitas.",
                                  "commonMistakes": [
                                    "Esquecer derivadas parciais mistas",
                                    "Omitir fatores 1/2 ou 1/6",
                                    "Confundir h com Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aproximação Temporal com Diferença Finita Forward",
                                  "subSteps": [
                                    "Considere a derivada temporal: ∂u/∂t ≈ [u(x_j, t_n + Δt) - u(x_j, t_n)] / Δt.",
                                    "Expanda u(x_j, t_n + Δt) usando Taylor em t.",
                                    "Substitua na diferença finita e isole o termo principal ∂u/∂t mais os erros O(Δt).",
                                    "Expresse o erro de truncamento local (LTE) como (Δt/2) ∂²u/∂t² + O(Δt²).",
                                    "Substitua pela equação parabólica (ex: ∂u/∂t = α ∂²u/∂x²) para relacionar com derivadas espaciais."
                                  ],
                                  "verification": "Derive que a diferença forward = ∂u/∂t + (Δt/2) ∂²u/∂t² + O(Δt²).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplo da equação do calor"
                                  ],
                                  "tips": "Mantenha notação consistente: use Δt para tempo e subscritos n,j.",
                                  "learningObjective": "Derivar precisamente o erro O(Δt) na discretização temporal.",
                                  "commonMistakes": [
                                    "Expandir no ponto errado (não em t_n)",
                                    "Ignorar o resto O(Δt²)",
                                    "Confundir ∂²u/∂t² com ∂²u/∂x²"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Aproximação Espacial com Diferença Finita Central",
                                  "subSteps": [
                                    "Considere a segunda derivada espacial: ∂²u/∂x² ≈ [u(x_j + Δx, t_n) - 2u(x_j, t_n) + u(x_j - Δx, t_n)] / Δx².",
                                    "Expanda u(x_j ± Δx, t_n) usando Taylor em x.",
                                    "Combine as expansões e cancele termos pares/impares até isolar ∂²u/∂x² + O(Δx²).",
                                    "Mostre que LTE espacial = (Δx²/12) ∂⁴u/∂x⁴ + O(Δx⁴).",
                                    "Verifique simetria da diferença central para precisão de ordem 2."
                                  ],
                                  "verification": "Confirme que a combinação dá ∂²u/∂x² + (Δx²/12) ∂⁴u/∂x⁴ + O(Δx⁴).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de expansões de Taylor pré-prontas"
                                  ],
                                  "tips": "Expanda ambos os lados simetricamente para cancelamentos automáticos.",
                                  "learningObjective": "Compreender por que diferenças centrais têm ordem de erro par (O(Δx²)).",
                                  "commonMistakes": [
                                    "Erro no sinal ao combinar +Δx e -Δx",
                                    "Parar na ordem 1 em vez de 4",
                                    "Esquecer /Δx² na normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Expansões no Esquema Numérico e Derivar Erro Total",
                                  "subSteps": [
                                    "Escreva o esquema explícito para u_t = α u_xx: [u^{n+1}_j - u^n_j]/Δt = α [u^n_{j+1} - 2u^n_j + u^n_{j-1}]/Δx².",
                                    "Substitua as expansões Taylor em cada termo do esquema.",
                                    "Reorganize: termos principais devem satisfazer a EDP original; isole resíduos.",
                                    "Some LTE temporal O(Δt) e espacial O(Δx²) para obter LTE total O(Δt + Δx²).",
                                    "Conclua sobre consistência: LTE → 0 quando Δt, Δx → 0."
                                  ],
                                  "verification": "O esquema satisfeito por u exata tem resíduo O(Δt + Δx²).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha com esquema escrito",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Substitua ∂²u/∂t² por α ∂³u/∂x²∂t se possível, mas foque no LTE local.",
                                  "learningObjective": "Integrar análises temporal e espacial para erro completo do esquema.",
                                  "commonMistakes": [
                                    "Não cancelar corretamente os termos de ordem 0 e 1",
                                    "Misturar Δt e Δx nas ordens",
                                    "Esquecer multiplicar pelo α no lado direito"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = u_xx com esquema explícito FTCS: derive que o LTE em (x_j, t_n) é (Δt/2) u_tt + (Δx²/12) α u_xxxx + O(Δt² + Δx⁴ + Δt Δx²), confirmando ordem O(Δt + Δx²).",
                              "finalVerifications": [
                                "Expansões Taylor corretas até ordem necessária para cada diferença finita.",
                                "LTE temporal identificado como O(Δt) com termo líder (Δt/2) u_tt.",
                                "LTE espacial O(Δx²) com (Δx²/12) u_xxxx.",
                                "No esquema completo, termos principais cancelam e resíduo é O(Δt + Δx²).",
                                "Conclusão sobre consistência do esquema parabólico.",
                                "Notação consistente e cálculos livres de erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas expansões (fatores corretos, derivadas parciais).",
                                "Identificação exata dos termos de erro de truncamento local.",
                                "Correta combinação no esquema numérico sem resíduos espúrios.",
                                "Uso apropriado de resto de Taylor para justificar ordens.",
                                "Clareza na derivação: passos lógicos e legíveis.",
                                "Generalização para esquemas parabólicos arbitrários."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações de difusão térmica ou onda.",
                                "Computação: Validação de implementações numéricas em Python/MATLAB.",
                                "Engenharia: CFD (dinâmica de fluidos computacional) para escoamentos viscosos.",
                                "Estatística: Aproximações em processos estocásticos parabólicos."
                              ],
                              "realWorldApplication": "Usado em modelagem numérica de propagação de calor em engenharia (ex: design de motores), previsão meteorológica (difusão de umidade), e finanças (equação de Black-Scholes para precificação de opções), garantindo precisão e estabilidade de simulações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Determinar ordem de consistência",
                            "description": "Calcular a ordem de precisão de um esquema (ex.: O(h^2 + k)) com base no erro de truncamento local para métodos em equações parabólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de consistência e erro de truncamento local",
                                  "subSteps": [
                                    "Revise a definição de consistência: um esquema é consistente se o erro de truncamento local tende a zero quando h e k vão a zero.",
                                    "Estude o erro de truncamento local (ETL): diferença entre a equação exata e o esquema numérico discretizado.",
                                    "Identifique os parâmetros: h (passo espacial), k (passo temporal).",
                                    "Lembre-se da equação parabólica modelo: u_t = α u_xx.",
                                    "Anote exemplos de esquemas comuns como FTCS (Forward Time Central Space)."
                                  ],
                                  "verification": "Explique em suas palavras o que é ETL e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de PDEs)",
                                    "Caderno e caneta"
                                  ],
                                  "tips": "Use diagramas para visualizar a grade espaço-tempo.",
                                  "learningObjective": "Dominar as definições fundamentais para análise de esquemas.",
                                  "commonMistakes": "Confundir consistência com convergência; consistência é condição necessária, não suficiente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir a solução exata em série de Taylor",
                                  "subSteps": [
                                    "Parta da solução exata u(x,t) em um ponto interior da grade.",
                                    "Expanda u(x,t+k) em Taylor ao redor de t: u + k u_t + (k^2/2) u_tt + O(k^3).",
                                    "Expanda derivadas espaciais: u_xx(x,t) = [u(x+h,t) - 2u(x,t) + u(x-h,t)] / h^2 + O(h^2).",
                                    "Substitua na equação exata u_t = α u_xx para expressar termos superiores.",
                                    "Mantenha termos até a ordem desejada (ex.: O(h^2), O(k))."
                                  ],
                                  "verification": "Escreva a expansão de u(x,t+k) com pelo menos 3 termos e verifique se satisfaz a equação exata truncada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como Mathematica/Maple",
                                    "Folha de fórmulas de Taylor"
                                  ],
                                  "tips": "Anote coeficientes numericamente para evitar erros algébricos.",
                                  "learningObjective": "Aplicar séries de Taylor à solução contínua.",
                                  "commonMistakes": "Esquecer fatores fatoriais em Taylor (ex.: k^2/2!); ignorar ordens pares/impares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir o esquema numérico e calcular o ETL",
                                  "subSteps": [
                                    "Escreva o esquema numérico genérico, ex.: [u^{n+1}_j - u^n_j]/k = α [u^n_{j+1} - 2u^n_j + u^n_{j-1}]/h^2.",
                                    "Expanda cada termo do esquema usando Taylor centrada em (x_j, t_n).",
                                    "Exemplo: u^n_{j+1} = u + (h/2) u_x + (h^2/2) u_xx + (h^3/6) u_xxx + O(h^4).",
                                    "Substitua expansões no esquema e simplifique para obter aproximação da equação exata + ETL.",
                                    "Identifique os termos residuais: ETL = O(h^p + k^q)."
                                  ],
                                  "verification": "Mostre que o esquema reproduz u_t = α u_xx + termos de ordem superior.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado para grade",
                                    "Tabela de expansões Taylor pré-computadas"
                                  ],
                                  "tips": "Agrupe termos por potências de h e k separadamente.",
                                  "learningObjective": "Derivar o ETL analiticamente para um esquema dado.",
                                  "commonMistakes": "Erro nos sinais das expansões laterais; confundir índices j e n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a ordem de consistência e verificar",
                                  "subSteps": [
                                    "Analise o ETL: a ordem é o menor expoente nos termos O(h^p k^q). Ex.: O(h^2 + k) tem ordem 1 em tempo, 2 em espaço.",
                                    "Calcule para esquema FTCS: ETL = O(k + h^2).",
                                    "Compare com esquemas melhores como Crank-Nicolson: O(k^2 + h^2).",
                                    "Teste numericamente: refine h e k, observe redução do erro.",
                                    "Conclua se o esquema é consistente (ordem finita positiva)."
                                  ],
                                  "verification": "Para um esquema dado, declare explicitamente a ordem, ex.: 'Ordem de consistência O(h^2 + k)'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Python/MATLAB para simulação numérica opcional",
                                    "Exemplos resolvidos do livro"
                                  ],
                                  "tips": "Sempre especifique ordens em h e k separadamente para clareza.",
                                  "learningObjective": "Calcular e interpretar a ordem de precisão do esquema.",
                                  "commonMistakes": "Ignorar o termo dominante; afirmar consistência sem verificar limite zero."
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = u_xx com esquema FTCS: u^{n+1}_j = u^n_j + k/h^2 (u^n_{j+1} - 2u^n_j + u^n_{j-1}). Expandindo, obtém-se ETL = (k/2) u_tt + (h^2/12) u_xxxx + O(k^2 + h^4 + k h^2), logo ordem O(k + h^2).",
                              "finalVerifications": [
                                "Deriva corretamente o ETL para um esquema dado sem erros algébricos.",
                                "Identifica os termos dominantes e declara a ordem precisa (ex.: O(h^2 + k)).",
                                "Explica verbalmente o impacto da ordem na estabilidade e precisão.",
                                "Aplica a análise a um novo esquema simples.",
                                "Verifica numericamente que o erro diminui com a ordem esperada.",
                                "Discute limitações para ordens baixas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão Taylor (coeficientes corretos: 80%+).",
                                "Identificação correta do ETL e ordem (100% match com solução padrão).",
                                "Clareza na derivação passo a passo.",
                                "Interpretação física/matemática da ordem.",
                                "Capacidade de generalizar para esquemas variantes.",
                                "Ausência de erros comuns como sinais errados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e propagação de ondas.",
                                "Computação: Implementação e otimização de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Análise de precisão em simulações CFD (dinâmica de fluidos computacional).",
                                "Estatística: Análise de erros em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica, finanças (modelos Black-Scholes como PDE parabólica) e engenharia biomédica (difusão de fármacos), determinar a ordem garante simulações precisas e eficientes, evitando desperdício computacional com esquemas de baixa ordem."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Analisar erro em esquemas unidimensionais",
                            "description": "Computar explicitamente o erro de truncamento para esquemas centrados em espaço e forward/backward em tempo na equação u_t = u_xx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação Diferencial Parcial e Definições dos Esquemas Numéricos",
                                  "subSteps": [
                                    "Escreva a equação u_t = u_xx em sua forma geral e identifique os termos de derivada temporal e espacial.",
                                    "Defina a grade numérica: Δt (passo de tempo), Δx (passo de espaço), índices j para espaço e n para tempo.",
                                    "Descreva o esquema FTCS: u^{n+1}_j = u^n_j + r (u^n_{j+1} - 2u^n_j + u^n_{j-1}), onde r = Δt / Δx².",
                                    "Descreva o esquema BTCS: -r u^{n+1}_{j+1} + (1 + 2r) u^{n+1}_j - r u^{n+1}_{j-1} = u^n_j.",
                                    "Liste as condições iniciais e de contorno assumidas para a análise local."
                                  ],
                                  "verification": "Confirme que as fórmulas dos esquemas estão corretas comparando com referências padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque ou Burden)",
                                    "Papel e lápis ou editor LaTeX/SymPy"
                                  ],
                                  "tips": "Use notação consistente para evitar confusões nos índices.",
                                  "learningObjective": "Compreender a estrutura dos esquemas numéricos para equações parabólicas unidimensionais.",
                                  "commonMistakes": [
                                    "Confundir forward com backward time",
                                    "Esquecer a definição de r",
                                    "Ignorar condições de contorno na análise local"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Expansões de Taylor para Operadores Discretos",
                                  "subSteps": [
                                    "Expanda u(x + Δx, t) e u(x - Δx, t) em série de Taylor ao redor de (x,t): inclua termos até ordem 4 ou 5.",
                                    "Derive a aproximação centrada para a segunda derivada espacial: δ²u / δx² ≈ (u_{j+1} - 2u_j + u_{j-1}) / Δx² + O(Δx²).",
                                    "Para forward time: expanda u(x, t + Δt) = u + Δt u_t + (Δt)²/2 u_tt + O(Δt³).",
                                    "Para backward time: expanda u(x, t - Δt) similarmente para o esquema implícito.",
                                    "Substitua as derivadas espaciais usando a PDE u_t = u_xx para expressar u_tt = u_xxt = u_xxxx, etc."
                                  ],
                                  "verification": "Verifique que as expansões recuperam a PDE exata quando Δt, Δx → 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy, Mathematica)",
                                    "Folhas de derivadas de Taylor pré-prontas"
                                  ],
                                  "tips": "Mantenha todos os termos de truncamento explícitos; não descarte prematuramente.",
                                  "learningObjective": "Dominar expansões de Taylor multivariadas para análise de erro de truncamento.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes de Taylor (ex: 1/6 vs 1/2)",
                                    "Não substituir derivadas mistas pela PDE",
                                    "Confundir ordens O(Δt) vs O(Δx²)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o Erro de Truncamento Local (LTE) para Esquema FTCS",
                                  "subSteps": [
                                    "Substitua as expansões de Taylor no esquema FTCS e isole o lado esquerdo menos a PDE.",
                                    "Simplifique: LTE = [expansão de u^{n+1}_j - u^n_j]/Δt - δ²u/δx² ≈ (Δt/2) u_tt + O(Δt²) + O(Δx²).",
                                    "Expresse u_tt em termos de derivadas espaciais: u_tt = u_xxxx.",
                                    "Identifique a ordem global: O(Δt + Δx²).",
                                    "Repita o processo para o esquema BTCS, notando a diferença no operador temporal."
                                  ],
                                  "verification": "O LTE deve tender a zero com as ordens corretas quando h→0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software simbólico para simplificação algébrica",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Fatore Δt e Δx para destacar ordens de truncamento claramente.",
                                  "learningObjective": "Calcular explicitamente o LTE e determinar sua ordem de precisão.",
                                  "commonMistakes": [
                                    "Não dividir corretamente pelo Δt no LTE",
                                    "Esquecer termos cruzados Δt Δx²",
                                    "Erro de sinal em expansões backward"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Erros e Verificar Consistência dos Esquemas",
                                  "subSteps": [
                                    "Escreva as expressões finais de LTE para FTCS e BTCS lado a lado.",
                                    "Compare ordens: ambos O(Δt + Δx²), mas FTCS condicionalmente estável.",
                                    "Discuta implicações para consistência: erro local → erro global sob estabilidade.",
                                    "Teste numericamente com solução exata u(x,t) = e^{-π²t} sin(πx) para validar.",
                                    "Resuma condições para que o esquema seja consistente (ordem pelo menos 1)."
                                  ],
                                  "verification": "Simule numericamente e compare ||erro|| com predição teórica de LTE.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/MATLAB com NumPy/SciPy para simulação rápida",
                                    "Solução exata conhecida"
                                  ],
                                  "tips": "Use r fixo (ex: r=0.5) para comparações numéricas.",
                                  "learningObjective": "Interpretar e comparar análise de erro entre esquemas explícito e implícito.",
                                  "commonMistakes": [
                                    "Ignorar estabilidade ao discutir consistência",
                                    "Usar solução errada para teste",
                                    "Confundir LTE com erro global"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u_t = u_xx com u(x,0)=sin(πx), [0<x<1], u(0,t)=u(1,t)=0. Compute LTE do FTCS: derive (Δt/2) u_tt - (Δx²/12) u_xxxx + O(Δt², Δx⁴, Δt Δx²). Substitua u_tt = π⁴ sin(πx) e^{-π²t} para valor explícito.",
                              "finalVerifications": [
                                "Expansões de Taylor corretas até ordem suficiente (O(Δt²), O(Δx⁴)).",
                                "LTE expresso explicitamente com todas derivadas substituídas pela PDE.",
                                "Ordens de truncamento identificadas corretamente para FTCS e BTCS.",
                                "Verificação numérica com solução exata mostra convergência de ordem prevista.",
                                "Comparação entre esquemas destaca diferenças em precisão e estabilidade.",
                                "Resumo escrito da consistência do esquema."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expansões de Taylor (coeficientes corretos).",
                                "Correta identificação e simplificação do LTE.",
                                "Uso apropriado da PDE para redução de derivadas temporais.",
                                "Análise de ordem de truncamento e implicações.",
                                "Clareza na derivação e ausência de erros algébricos.",
                                "Validação numérica ou analítica do resultado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem da equação de difusão térmica.",
                                "Computação: Implementação e análise de estabilidade em simulações numéricas.",
                                "Engenharia: Análise de erros em simulações CFD (dinâmica de fluidos computacional).",
                                "Estatística: Estudo de erros de aproximação e convergência.",
                                "Matemática Aplicada: Séries de Taylor em análise assintótica."
                              ],
                              "realWorldApplication": "Em simulações de propagação de calor em engenharia (ex: design de processadores ou materiais isolantes), análise de erro garante precisão preditiva; em finanças, modela difusão de preços de opções via equações parabólicas, onde truncamento afeta hedges precisos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Verificação de Consistência em Esquemas Específicos",
                        "description": "Aplicação prática da análise de consistência em esquemas clássicos como Euler explícito, implícito e Crank-Nicolson para equações parabólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Verificar consistência do Euler explícito",
                            "description": "Demonstrar que o esquema Euler explícito para u_t = α u_xx é consistente de ordem O(h^2 + k).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a equação diferencial parcial e o esquema Euler explícito",
                                  "subSteps": [
                                    "Escreva a equação do calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Defina a malha numérica: pontos x_j = j h, tempos t_n = n k.",
                                    "Escreva o esquema Euler explícito: (u_j^{n+1} - u_j^n)/k = α (u_{j+1}^n - 2 u_j^n + u_{j-1}^n)/h².",
                                    "Lembre a definição de consistência: o erro de truncamento local τ(h,k) → 0 quando h,k → 0.",
                                    "Identifique a ordem esperada: O(h² + k)."
                                  ],
                                  "verification": "Verifique se o esquema está escrito corretamente comparando com referências padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Use notação consistente: u_j^n para aproximação em (x_j, t_n).",
                                  "learningObjective": "Compreender a formulação exata do problema e do esquema numérico.",
                                  "commonMistakes": [
                                    "Confundir Euler explícito com implícito",
                                    "Esquecer o fator α no lado direito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a expansão de Taylor temporal para u(x, t + k)",
                                  "subSteps": [
                                    "Expanda u(x_j, t_n + k) em série de Taylor ao redor de (x_j, t_n): u + k u_t + (k²/2) u_{tt} + O(k³).",
                                    "Substitua na diferença temporal: [u(x,t+k) - u(x,t)] / k = u_t + (k/2) u_{tt} + O(k²).",
                                    "Expresse u_{tt} usando a PDE: u_{tt} = α (u_t)_{xx} = α (α u_{xx})_{xx} = α² u_{xxxx}.",
                                    "Registre o resíduo temporal: O(k).",
                                    "Anote todas as derivadas em (x_j, t_n)."
                                  ],
                                  "verification": "Confirme que o resíduo temporal é O(k) derivando explicitamente os termos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de derivadas parciais da PDE"
                                  ],
                                  "tips": "Diferencie a PDE no tempo para obter u_{tt}, assumindo suavidade suficiente.",
                                  "learningObjective": "Dominar a expansão temporal e relacionar com derivadas superiores via PDE.",
                                  "commonMistakes": [
                                    "Parar a expansão em O(k²) sem justificar",
                                    "Esquecer de propagar α nas derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a expansão de Taylor espacial para a segunda derivada",
                                  "subSteps": [
                                    "Expanda u(x+h, t) e u(x-h, t): u + h u_x + (h²/2) u_{xx} + (h³/6) u_{xxx} + (h⁴/24) u_{xxxx} + O(h⁵), e similar para -h.",
                                    "Some as expansões: [u(x+h) - 2u(x) + u(x-h)] / h² = u_{xx} + (h²/12) u_{xxxx} + O(h⁴).",
                                    "Multiplique pelo α: α u_{xx} + α (h²/12) u_{xxxx} + O(h⁴).",
                                    "Registre o resíduo espacial: O(h²).",
                                    "Verifique simetria da expansão central."
                                  ],
                                  "verification": "Calcule os coeficientes até O(h⁴) e confirme o erro O(h²).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use a fórmula binomial para expansões pares/impares que se cancelam.",
                                  "learningObjective": "Aplicar expansões de Taylor multivariadas para aproximação espacial.",
                                  "commonMistakes": [
                                    "Erro no sinal das expansões para u(x-h)",
                                    "Confundir ordens: lembrar O(h²) para segunda derivada central"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o erro de truncamento local e determinar a ordem de consistência",
                                  "subSteps": [
                                    "Substitua a solução exata u(x_j, t_n) no esquema: lado esquerdo menos lado direito = τ(h,k).",
                                    "Combine resíduos: τ = [u_t + (k/2) u_{tt} + O(k²)] - [α u_{xx} + α (h²/12) u_{xxxx} + O(h⁴)].",
                                    "Pela PDE, u_t = α u_{xx}, então τ = (k/2) u_{tt} - α (h²/12) u_{xxxx} + O(k² + h⁴).",
                                    "Como u_{tt} = O(1), u_{xxxx}=O(1), τ = O(k + h²).",
                                    "Conclua consistência de ordem O(h² + k) pois τ → 0 e ordem exata."
                                  ],
                                  "verification": "Escreva a expressão final de τ e limite h,k→0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Resumo dos passos anteriores",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Assuma solução suave (infinitamente diferenciável) para justificação.",
                                  "learningObjective": "Derivar e interpretar o erro de truncamento para provar consistência.",
                                  "commonMistakes": [
                                    "Não cancelar u_t - α u_{xx}",
                                    "Ignorar O(k² + h⁴) que é maior ordem"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação u_t = u_xx em [0,1]×[0,∞) com u(x,0)=sin(πx), solução exata u(x,t)=e^{-π² t} sin(πx). Tome h=0.1, k=0.005, x=0.5, t=0.1. Substitua u exata no esquema, compute τ numéricamente e verifique |τ| ≈ 10^{-4}, compatível com O(h² + k) ≈ 0.005.",
                              "finalVerifications": [
                                "Escrever corretamente o esquema Euler explícito.",
                                "Derivar expansão temporal até O(k²).",
                                "Derivar expansão espacial central até O(h⁴).",
                                "Calcular τ e identificar termos dominantes.",
                                "Afirmar corretamente a ordem O(h² + k).",
                                "Explicar por que o esquema é consistente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (sem erros algébricos).",
                                "Correta substituição da PDE para eliminar termos principais.",
                                "Identificação exata da ordem do erro de truncamento.",
                                "Clareza na explicação do limite h,k→0.",
                                "Capacidade de generalizar para α arbitrário.",
                                "Uso correto de notação e índices."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler explícito em Python/MATLAB para validar numericamente.",
                                "Física: Aplicação em difusão de calor e ondas parabólicas.",
                                "Engenharia Computacional: Análise de estabilidade (número de CFL).",
                                "Estatística: Métodos numéricos para EDOs estocásticas parabólicas."
                              ],
                              "realWorldApplication": "Verificação de consistência é essencial em simulações numéricas de difusão térmica em engenharia (ex: previsão de aquecimento em reatores nucleares) ou modelagem financeira (equações Black-Scholes parabólicas para precificação de opções), garantindo que aproximações discretas convirjam para a solução física/exata."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Analisar consistência do Crank-Nicolson",
                            "description": "Calcular o erro de truncamento do método Crank-Nicolson e confirmar sua consistência de segunda ordem em tempo e espaço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do método Crank-Nicolson",
                                  "subSteps": [
                                    "Recordar a equação diferencial parabólica modelo: ∂u/∂t = α ∂²u/∂x².",
                                    "Escrever o esquema Crank-Nicolson explícito: (u_j^{n+1} - u_j^n)/Δt = (α/2Δx²) (δ² u_j^{n+1} + δ² u_j^n), onde δ² é o operador diferença central.",
                                    "Identificar que é um esquema implícito centrado no tempo e no espaço.",
                                    "Explicar a média temporal entre níveis n e n+1.",
                                    "Discutir condições de contorno e malha uniforme."
                                  ],
                                  "verification": "Escrever corretamente o esquema Crank-Nicolson para a equação de calor em uma folha de papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre esquemas para EDPs parabólicas"
                                  ],
                                  "tips": "Lembre-se de que o fator 1/2 surge da média aritmética entre os passos temporais.",
                                  "learningObjective": "Compreender a estrutura algébrica e conceitual do método Crank-Nicolson.",
                                  "commonMistakes": [
                                    "Confundir com o esquema explícito de Euler",
                                    "Esquecer o operador δ² central",
                                    "Ignorar a natureza implícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar expansões em série de Taylor para os termos temporais",
                                  "subSteps": [
                                    "Expandir u(x, t+Δt) em Taylor ao redor de t: u + Δt u_t + (Δt²/2) u_tt + (Δt³/6) u_ttt + O(Δt⁴).",
                                    "Expandir u(x, t-Δt) similarmente: u - Δt u_t + (Δt²/2) u_tt - (Δt³/6) u_ttt + O(Δt⁴).",
                                    "Calcular a diferença temporal central: [u(t+Δt) - u(t-Δt)]/(2Δt) = u_t + (Δt²/6) u_ttt + O(Δt⁴).",
                                    "Relacionar u_tt = α u_xx e u_ttt = α u_xxt usando a PDE original.",
                                    "Verificar a precisão de segunda ordem na aproximação temporal."
                                  ],
                                  "verification": "Derivar e anotar as expansões de Taylor para u^{n+1} e u^n, confirmando o erro O(Δt²).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Calculadora simbólica ou software como Mathematica/SymPy"
                                  ],
                                  "tips": "Use notação Leibniz para derivadas mistas e substitua recursivamente da PDE.",
                                  "learningObjective": "Dominar as expansões de Taylor centradas para análise de erro temporal.",
                                  "commonMistakes": [
                                    "Parar na primeira ordem",
                                    "Erro no sinal das expansões pares/ímpares",
                                    "Não relacionar derivadas superiores via PDE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar expansões para os termos espaciais e substituir no esquema",
                                  "subSteps": [
                                    "Expandir o operador diferença central δ²u/Δx² = u_xx + (Δx²/12) u_xxxx + O(Δx⁴).",
                                    "Aplicar isso aos termos em n+1 e n: média dá u_xx + (Δx²/12) u_xxxx + O(Δx⁴).",
                                    "Substituir as expansões temporais e espaciais no esquema Crank-Nicolson.",
                                    "Simplificar para obter a equação: L(u_h) = τ(u) + O(Δt² + Δx²), onde τ é o erro local.",
                                    "Expressar explicitamente τ envolvendo u_ttt e u_xxxx."
                                  ],
                                  "verification": "Substituir e simplificar o esquema até isolar o erro de truncamento τ.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Caneta e papel para álgebra simbólica",
                                    "Referência: LeVeque 'Finite Difference Methods for ODEs and PDEs'"
                                  ],
                                  "tips": "Mantenha os termos de ordem alta separados e cancele os de baixa ordem.",
                                  "learningObjective": "Aplicar expansões de Taylor espaciais e combinar com temporais no esquema.",
                                  "commonMistakes": [
                                    "Erro no operador δ² (confundir com forward)",
                                    "Não média corretamente os erros espaciais",
                                    "Perder fatores α"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e confirmar a ordem de consistência",
                                  "subSteps": [
                                    "Identificar τ = (Δt²/6) α u_xxt + (Δx²/12) u_xxxx + O(Δt³ + Δx⁴ + Δt Δx²).",
                                    "Mostrar que lim_{Δt,Δx→0} τ / (Δt + Δx²) = 0, provando consistência.",
                                    "Confirmar ordem 2 em tempo (Δt²) e ordem 2 em espaço (Δx²).",
                                    "Discutir implicações para convergência ( Lax equivalence).",
                                    "Testar numericamente com uma solução exata conhecida."
                                  ],
                                  "verification": "Calcular τ explicitamente e afirmar 'consistente de segunda ordem'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para verificação numérica opcional",
                                    "Solução exata u(x,t)=exp(-π² t) sin(π x)"
                                  ],
                                  "tips": "Para confirmação, use norma do erro local e veja a taxa de convergência.",
                                  "learningObjective": "Analisar e concluir sobre a consistência do esquema.",
                                  "commonMistakes": [
                                    "Afirmar ordem errada (ex: primeira ordem)",
                                    "Ignorar termos cruzados Δt Δx²",
                                    "Confundir consistência com estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx em [0,1]x[0,T] com u(0,t)=u(1,t)=0 e u(x,0)=sin(πx), aplique Crank-Nicolson com Δt=0.01, Δx=0.1, derive τ ≈ (Δt²/6) u_xxt + (Δx²/12) u_xxxx e verifique numericamente que ||erro|| ~ O(Δt² + Δx²).",
                              "finalVerifications": [
                                "Escrever corretamente o esquema Crank-Nicolson.",
                                "Derivar expansões Taylor precisas até ordem 3 em tempo e 4 em espaço.",
                                "Isolar o erro de truncamento τ com termos dominantes O(Δt² + Δx²).",
                                "Provar lim τ/(Δt+Δx²)=0.",
                                "Confirmar consistência de segunda ordem em tempo e espaço.",
                                "Aplicar a um exemplo numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (100% dos termos corretos).",
                                "Correta simplificação do esquema para erro local (sem erros algébricos).",
                                "Análise clara da ordem de truncamento (identifica O(Δt², Δx²)).",
                                "Prova de consistência rigorosa (limite correto).",
                                "Exemplo prático executado com resultados quantitativos.",
                                "Clareza na explicação escrita (lógica sequencial)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e ondas parabólicas.",
                                "Computação Científica: Implementação e resolução de sistemas tridiagonais em Python/NumPy.",
                                "Engenharia: Simulações numéricas em CFD e transferência de calor.",
                                "Matemática Aplicada: Teoria de convergência de métodos numéricos (Lax-Richtmyer)."
                              ],
                              "realWorldApplication": "O método Crank-Nicolson é amplamente usado em simulações de propagação de calor em engenharia (ex: design de reatores nucleares), modelagem climática para difusão de poluentes, e finanças para equações de Black-Scholes em precificação de derivativos, garantindo precisão de segunda ordem sem restrições CFL severas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Comparar ordens de consistência",
                            "description": "Comparar a consistência de diferentes esquemas (explícito vs. implícito) e discutir implicações para convergência em problemas parabólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Consistência em Esquemas Numéricos",
                                  "subSteps": [
                                    "Defina consistência: um esquema é consistente se o erro local de truncamento (LTE) tende a zero quando Δt → 0 e Δx → 0.",
                                    "Explique ordem de consistência: grau do polinômio de Taylor que cancela no LTE, tipicamente O(Δt^p + Δx^q).",
                                    "Discuta relação com convergência via Teorema de Equivalência de Lax.",
                                    "Identifique componentes: operador diferencial exato vs. aproximado numérico.",
                                    "Pratique expandindo em série de Taylor uma derivada simples."
                                  ],
                                  "verification": "Resuma em um parágrafo a definição e ordem de consistência, com exemplo de LTE para derivada temporal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta",
                                    "Calculadora simbólica como SymPy ou Mathematica"
                                  ],
                                  "tips": "Comece com a equação modelo u_t = u_xx para simplificar expansões de Taylor.",
                                  "learningObjective": "Compreender a base teórica de consistência para análise comparativa.",
                                  "commonMistakes": "Confundir consistência com estabilidade; ignorar termos mistos ΔtΔx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Ordem de Consistência do Esquema Explícito",
                                  "subSteps": [
                                    "Escreva o esquema FTCS explícito para u_t = α u_xx: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Expanda u_j^{n+1}, u_{j+1}^n etc. em séries de Taylor em torno de (x_j, t_n).",
                                    "Calcule o LTE: subtraia a equação exata e identifique termos líderes O(Δt) + O(Δx²).",
                                    "Determine a ordem: p=1 para tempo, q=2 para espaço.",
                                    "Verifique consistência: LTE → 0 quando Δt, Δx → 0."
                                  ],
                                  "verification": "Derive explicitamente o LTE e confirme ordem O(Δt + Δx²).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de cálculos",
                                    "Software Python/MATLAB para Taylor simbólico",
                                    "Notas de aula sobre diferenças finitas"
                                  ],
                                  "tips": "Use notação compacta para expansões; foque em termos até ordem 2.",
                                  "learningObjective": "Dominar cálculo de LTE para esquemas explícitos em problemas parabólicos.",
                                  "commonMistakes": "Esquecer termo temporal na expansão de u^{n+1}; erros em coeficientes de Taylor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Ordem de Consistência do Esquema Implícito",
                                  "subSteps": [
                                    "Escreva o esquema implícito backward Euler: u_j^{n+1} - r (u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}) = u_j^n.",
                                    "Expanda todas as variáveis em (x_j, t_{n+1}) para o lado esquerdo e (x_j, t_n) para o direito.",
                                    "Calcule LTE: identifique termos O(Δt) + O(Δx²), similar ao explícito.",
                                    "Confirme ordem idêntica: p=1, q=2.",
                                    "Note diferenças na derivação devido à implicitidade."
                                  ],
                                  "verification": "Escreva a expressão LTE e afirme a ordem de consistência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mesmos do Step 2",
                                    "Tabela de expansões de Taylor pré-computadas"
                                  ],
                                  "tips": "Expanda em torno de t_{n+1} para consistência; use simetria espacial.",
                                  "learningObjective": "Analisar LTE em esquemas implícitos e reconhecer similaridades.",
                                  "commonMistakes": "Expandir errado o tempo no implícito; confundir ponto de expansão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Ordens e Discutir Implicações para Convergência",
                                  "subSteps": [
                                    "Compare LTEs: ambos O(Δt + Δx²), ordens iguais.",
                                    "Discuta implicações: consistência similar, mas convergência depende de estabilidade (explícito condicional, implícito incondicional).",
                                    "Aplique Lax: para convergência, ambos consistentes + estável ⇒ convergem.",
                                    "Explore trade-offs: explícito mais rápido computacionalmente, implícito mais robusto.",
                                    "Conclua com escolha baseada em r (número de Courant)."
                                  ],
                                  "verification": "Crie tabela comparativa e parágrafo sobre implicações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel para tabela",
                                    "Artigo sobre Lax Equivalence"
                                  ],
                                  "tips": "Enfatize que consistência é necessária mas não suficiente sem estabilidade.",
                                  "learningObjective": "Integrar análise para decisões em simulações numéricas.",
                                  "commonMistakes": "Ignorar estabilidade na discussão de convergência; superestimar diferenças em consistência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Exemplo Numérico e Análise Sensibilidade",
                                  "subSteps": [
                                    "Implemente ambos esquemas em código para u_t = u_xx, condições iniciais u(x,0)=sin(πx).",
                                    "Compute erros numéricos para Δt, Δx variando.",
                                    "Observe convergência: ordens aproximadas via log-log plot.",
                                    "Compare taxas: confirme ordens teóricas.",
                                    "Discuta limitações práticas."
                                  ],
                                  "verification": "Gere gráfico de erro vs. h mostrando inclinação ~1 (tempo) e ~2 (espaço).",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use Δt = k Δx² para estabilidade explícita; teste r=0.5.",
                                  "learningObjective": "Conectar teoria à prática via experimentação numérica.",
                                  "commonMistakes": "Instabilidade numérica mascarando consistência; escalas erradas em plots."
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx em [0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx), discretize com Δx=0.1, Δt=0.001. Implemente FTCS explícito e implícito, compare erros em norma L2 após 10 passos temporais, confirmando ordens similares apesar de diferenças em estabilidade.",
                              "finalVerifications": [
                                "Derivar corretamente LTE para ambos esquemas.",
                                "Identificar ordens de consistência como O(Δt + Δx²).",
                                "Explicar por que consistência sozinha não garante convergência.",
                                "Criar tabela comparativa clara.",
                                "Implementar código que demonstra convergência empírica.",
                                "Discutir trade-offs em aplicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de séries de Taylor (90% dos termos corretos).",
                                "Correta identificação de ordens de consistência.",
                                "Profundidade na discussão de implicações para convergência.",
                                "Qualidade do exemplo prático e gráficos.",
                                "Clareza na tabela comparativa e conclusões.",
                                "Ausência de erros conceituais sobre Lax theorem."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica em materiais.",
                                "Computação: Implementação eficiente de solvers lineares para implícito (ex: Thomas algorithm).",
                                "Engenharia: Simulações CFD para fluxo de calor.",
                                "Estatística: Análise de erros numéricos e convergência.",
                                "Física Computacional: Integração com métodos espectrais."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica para difusão de umidade, ou modelagem financeira de opções (equação Black-Scholes parabólica), onde esquemas implícitos são preferidos por estabilidade incondicional em malhas finas, garantindo convergência confiável apesar de custos computacionais maiores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.4",
                            "name": "Identificar esquemas inconsistentes",
                            "description": "Reconhecer e corrigir esquemas numéricos que violam a consistência, como aproximações inadequadas de derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Consistência em Esquemas Numéricos",
                                  "subSteps": [
                                    "Defina consistência: um esquema é consistente se o truncamento local tende a zero quando Δt e Δx vão a zero.",
                                    "Revise a equação parabólica modelo: u_t = α u_xx.",
                                    "Estude o erro de truncamento local (LTE) para esquemas de diferenças finitas.",
                                    "Identifique componentes do LTE: termos de ordem superior em expansões de Taylor.",
                                    "Compare consistência com convergência e estabilidade."
                                  ],
                                  "verification": "Explique em suas palavras o que significa um esquema inconsistente e dê um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Papel e caneta para anotações",
                                    "Expansões de Taylor impressas"
                                  ],
                                  "tips": [
                                    "Comece com equações 1D simples para evitar confusão.",
                                    "Desenhe grades espaciais e temporais para visualizar."
                                  ],
                                  "learningObjective": "Entender a definição formal e intuitiva de consistência numérica.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade.",
                                    "Ignorar o papel do Δt e Δx no limite."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aproximações de Derivadas em Esquemas Numéricos",
                                  "subSteps": [
                                    "Revise diferenças finitas: forward, backward e central para primeira e segunda derivadas.",
                                    "Calcule o LTE para cada tipo: ex, forward para u_x tem erro O(Δx).",
                                    "Aplique expansões de Taylor a operadores diferenciais em esquemas parabólicos.",
                                    "Identifique quando uma aproximação inadequada viola consistência (ex: usar forward para u_xx).",
                                    "Pratique derivando LTE para esquemas explícitos como FTCS."
                                  ],
                                  "verification": "Derive o LTE para o esquema forward difference em u_t = u_x e classifique sua consistência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: SymPy online)",
                                    "Folhas com fórmulas de diferenças finitas",
                                    "Exemplos de esquemas de livros-texto"
                                  ],
                                  "tips": [
                                    "Use notação δ para operadores de diferenças para clareza.",
                                    "Verifique simetria em derivadas pares/impares."
                                  ],
                                  "learningObjective": "Dominar o cálculo de erros de truncamento em aproximações diferenciais.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior na expansão de Taylor.",
                                    "Confundir LTE com erro global."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Inconsistências em Esquemas Específicos",
                                  "subSteps": [
                                    "Selecione um esquema suspeito e escreva sua forma discreta.",
                                    "Expanda cada termo usando Taylor ao redor de (x_j, t_n).",
                                    "Colete termos do LTE e verifique se eles tendem a zero com mesh refinado.",
                                    "Classifique: consistente se LTE = O(Δt^p + Δx^q) com p,q >0; senão inconsistente.",
                                    "Teste múltiplos esquemas: um consistente (CTCS) vs. inconsistente (forward para u_xx)."
                                  ],
                                  "verification": "Analise um esquema dado e prove se é consistente ou não, mostrando o LTE.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software de álgebra computacional (ex: Mathematica ou Python com SymPy)",
                                    "Lista de esquemas de exemplo",
                                    "Grade de papel quadriculado"
                                  ],
                                  "tips": [
                                    "Padronize Δt = λ Δx^2 para esquemas parabólicos.",
                                    "Automatize expansões com código se possível."
                                  ],
                                  "learningObjective": "Aplicar testes de consistência a esquemas numéricos reais.",
                                  "commonMistakes": [
                                    "Não considerar o limite conjunto de Δt e Δx.",
                                    "Ignorar coeficientes em equações não-homogêneas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir Esquemas Inconsistentes e Verificar",
                                  "subSteps": [
                                    "Para um esquema inconsistente identificado, proponha modificações (ex: trocar forward por central).",
                                    "Recalcule o LTE da versão corrigida.",
                                    "Compare ordens de consistência antes/depois.",
                                    "Implemente numericamente um teste simples para validar.",
                                    "Documente o processo de identificação e correção."
                                  ],
                                  "verification": "Corrija um esquema inconsistente e demonstre melhoria no LTE.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python ou MATLAB para simulação numérica básica",
                                    "Código template para esquemas 1D",
                                    "Referências a artigos sobre métodos numéricos"
                                  ],
                                  "tips": [
                                    "Teste com soluções exatas conhecidas para validar numericamente.",
                                    "Mantenha λ pequeno para estabilidade durante testes."
                                  ],
                                  "learningObjective": "Desenvolver habilidade em diagnosticar e remediar inconsistências.",
                                  "commonMistakes": [
                                    "Corrigir estabilidade em vez de consistência.",
                                    "Não re-verificar o LTE após modificações."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o esquema inadequado para u_t = u_xx: u^{n+1}_j = u^n_j + (Δt / Δx) (u^n_{j+1} - u^n_j). Usando Taylor, o LTE revela termo dominante O(1/Δx) que não tende a zero, tornando-o inconsistente. Corrija para central difference: u^{n+1}_j = u^n_j + (Δt / Δx^2) (u^n_{j+1} - 2u^n_j + u^n_{j-1}), com LTE O(Δt + Δx^2), consistente.",
                              "finalVerifications": [
                                "Derivar corretamente LTE para 3 esquemas diferentes.",
                                "Identificar inconsistência em um esquema novo sem dicas.",
                                "Propor correção válida com prova de consistência.",
                                "Explicar impacto de inconsistência em simulações numéricas.",
                                "Aplicar teste em código e interpretar resultados.",
                                "Diferenciar de problemas de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de expansões de Taylor (90% correto).",
                                "Correta classificação de consistência com justificativa LTE.",
                                "Criatividade e validade em correções propostas.",
                                "Clareza na documentação de análises.",
                                "Proficiência em ferramentas numéricas para verificação.",
                                "Compreensão de limitações em contextos parabólicos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão de calor com métodos numéricos.",
                                "Computação: Implementação de solvers em Python/MATLAB.",
                                "Engenharia: Simulações CFD onde consistência afeta precisão.",
                                "Estatística: Análise de erros numéricos em Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes, esquemas inconsistentes levam a erros acumulados irrealistas; identificação garante previsões confiáveis usadas por agências ambientais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Convergência de Métodos para Equações Parabólicas",
                    "description": "Estudo da convergência de esquemas numéricos resolvendo equações parabólicas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Consistência de Esquemas Numéricos",
                        "description": "Estudo da propriedade de consistência em métodos de diferenças finitas para equações diferenciais parciais parabólicas, verificando se o erro de truncamento local tende a zero à medida que o passo de malha diminui.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Definir consistência",
                            "description": "Explicar a definição formal de consistência de um esquema numérico, incluindo a relação com a ordem de precisão e o erro de truncamento local para a equação do calor parabólica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação do Calor Parabólica",
                                  "subSteps": [
                                    "Estude a forma geral da equação do calor: ∂u/∂t = α ∂²u/∂x², onde α é a difusividade térmica.",
                                    "Identifique condições iniciais u(x,0) = f(x) e condições de contorno, como Dirichlet ou Neumann.",
                                    "Discuta por que é uma equação parabólica e sua importância em modelagem de difusão.",
                                    "Anote exemplos físicos, como propagação de calor em uma barra.",
                                    "Compare com outras PDEs para contextualizar."
                                  ],
                                  "verification": "Escreva a equação do calor em notação matemática e liste duas aplicações físicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: LeVeque), caderno de anotações, calculadora.",
                                  "tips": "Use diagramas para visualizar a propagação parabólica vs. hiperbólica.",
                                  "learningObjective": "Compreender a estrutura matemática da equação do calor como base para esquemas numéricos.",
                                  "commonMistakes": "Confundir com equação de onda (hiperbólica) ou Laplace (elíptica)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Discretização Numérica Básica",
                                  "subSteps": [
                                    "Aprenda a discretizar o espaço com malha uniforme: x_j = j h, j=0..J, h=Δx.",
                                    "Discretize o tempo: t_n = n τ, n=0..N, τ=Δt.",
                                    "Aproxime derivadas espaciais: ∂²u/∂x² ≈ (u_{j+1} - 2u_j + u_{j-1})/h² (central).",
                                    "Aproxime derivada temporal: ∂u/∂t ≈ (u^{n+1}_j - u^n_j)/τ (forward Euler).",
                                    "Escreva o esquema FTCS: u^{n+1}_j = u^n_j + r (u^n_{j+1} - 2u^n_j + u^n_{j-1}), r=α τ / h²."
                                  ],
                                  "verification": "Derive o esquema FTCS para a equação do calor a partir das aproximações de diferenças finitas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, software como MATLAB ou Python (NumPy) para testar discretização simples.",
                                  "tips": "Sempre verifique dimensionalidade: r deve ser adimensional.",
                                  "learningObjective": "Dominar as aproximações diferenciais finitas básicas para PDEs parabólicas.",
                                  "commonMistakes": "Esquecer o fator α ou inverter derivadas espaciais/temporais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o Erro de Truncamento Local",
                                  "subSteps": [
                                    "Defina erro de truncamento local τ_h como a diferença entre a equação exata e o esquema plugando u exata.",
                                    "Expanda u exata em série de Taylor ao redor de (x_j, t_n): para ∂u/∂t e ∂²u/∂x².",
                                    "Calcule o erro para forward em tempo: O(τ) + O(h²) para central em espaço.",
                                    "Escreva τ_h = [∂u/∂t - α ∂²u/∂x²] - [esquema]/τ h, mostrando termos residuais.",
                                    "Verifique para FTCS: τ_h = O(τ + h²)."
                                  ],
                                  "verification": "Compute o erro de truncamento local para o esquema FTCS usando expansão de Taylor.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela de expansões de Taylor, simbólico como SymPy ou Mathematica.",
                                  "tips": "Taylor até ordem 3-4; ignore termos O(h^4) inicialmente.",
                                  "learningObjective": "Calcular e interpretar o erro introduzido pelas aproximações diferenciais.",
                                  "commonMistakes": "Não dividir corretamente pelo passo (τ ou h) no esquema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Consistência Formal e Ordem de Precisão",
                                  "subSteps": [
                                    "Defina consistência: lim_{h→0, τ→0} max |τ_h(x,t)| = 0 para solução exata suave.",
                                    "Introduza ordem de precisão: esquema consistente de ordem (p,q) se τ_h = O(τ^q + h^p).",
                                    "Relacione com convergência via teorema Lax-Richtmyer (consistência + estabilidade ⇒ convergência).",
                                    "Exemplo FTCS: ordem (2,1) em espaço-tempo.",
                                    "Discuta esquemas de ordem superior, como Crank-Nicolson O(τ² + h²)."
                                  ],
                                  "verification": "Explique em palavras e matemática por que FTCS é consistente de ordem (2,1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referências: Burden & Faires Análise Numérica, notas de aula.",
                                  "tips": "Lembre: consistência é local; estabilidade é global.",
                                  "learningObjective": "Formular a definição precisa de consistência e sua quantificação por ordens.",
                                  "commonMistakes": "Confundir consistência com estabilidade ou convergência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Verificar a Definição",
                                  "subSteps": [
                                    "Analise um esquema inconsistente: ex: u^{n+1}_j = 2 u^n_j (erro constante).",
                                    "Compare ordens em diferentes esquemas (FTBS, BTCS).",
                                    "Discuta condições para consistência: soluções clássicas suaves.",
                                    "Resolva exercício: prove consistência para Leapfrog em tempo.",
                                    "Resuma relação: ordem alta reduz τ_h, melhora convergência."
                                  ],
                                  "verification": "Classifique três esquemas como consistentes/inconsistentes e especifique ordens.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exercícios de livro-texto, simulador numérico online.",
                                  "tips": "Teste numericamente: refine malha e veja se erro local →0.",
                                  "learningObjective": "Aplicar a definição para julgar esquemas numéricos.",
                                  "commonMistakes": "Ignorar dependência τ/h em esquemas explícitos."
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação do calor u_t = u_xx em [0,1]x[0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx): plugue u exata u(x,t)=sin(πx) e^{-π² t}, expanda Taylor para mostrar τ_h = (π⁴/12) h² sin(πx) e^{-π² t} - (π⁶/6) τ sin(πx) e^{-π² t} + O(τ² + h⁴), confirmando O(τ + h²) →0.",
                              "finalVerifications": [
                                "Defina consistência sem consultar notas.",
                                "Calcule τ_h para FTCS corretamente.",
                                "Explique relação ordem de precisão e erro local.",
                                "Distinga consistência de estabilidade.",
                                "Cite teorema Lax-Richtmyer.",
                                "Analise um esquema dado como consistente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de consistência (exata).",
                                "Correção no cálculo de erro de truncamento via Taylor.",
                                "Compreensão da ordem (p,q) e impacto em τ_h.",
                                "Uso correto de notação matemática.",
                                "Aplicação a exemplos concretos sem erros.",
                                "Explicação clara da relação com convergência."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e conservação de energia.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD para fluxos difusivos.",
                                "Estatística: Análise de erros em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de previsão de tempo (difusão de umidade), design de trocadores de calor industriais, ou modelagem financeira de opções (equação Black-Scholes, parabólica), onde consistência garante que refinamento numérico aproxime a solução física exata, evitando erros em engenharia crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Calcular erro de truncamento",
                            "description": "Derivar e calcular o erro de truncamento local para esquemas explícito e implícito aplicados à equação parabólica unidimensional u_t = u_xx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação parabólica e esquemas numéricos explícito e implícito",
                                  "subSteps": [
                                    "Estude a equação u_t = u_xx em domínio 1D com condições de contorno e inicial.",
                                    "Revise a discretização em grade uniforme: Δt e Δx.",
                                    "Derive o esquema explícito: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = Δt / Δx².",
                                    "Derive o esquema implícito: u_j^{n+1} - r (u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}) = u_j^n.",
                                    "Implemente um exemplo simples em código para visualizar."
                                  ],
                                  "verification": "Escreva as fórmulas dos esquemas e rode uma simulação básica sem erros.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis",
                                    "Python ou MATLAB para simulação"
                                  ],
                                  "tips": "Use r=0.5 para estabilidade no explícito e visualize a solução com plot.",
                                  "learningObjective": "Compreender a formulação dos esquemas numéricos para a equação de calor 1D.",
                                  "commonMistakes": [
                                    "Confundir índices j e n",
                                    "Esquecer fator r na discretização",
                                    "Ignorar condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o conceito de erro de truncamento local",
                                  "subSteps": [
                                    "Defina erro de truncamento local como a diferença entre a equação PDE exata e a aproximada no ponto (x_j, t_n).",
                                    "Estude expansão em série de Taylor para u(x_j ± Δx, t_n) e u(x_j, t_n + Δt).",
                                    "Expanda as derivadas temporais e espaciais: ∂t u ≈ (u^{n+1} - u^n)/Δt, ∂xx u ≈ (u_{j+1} - 2u_j + u_{j-1})/Δx².",
                                    "Identifique termos de ordem O(Δt) e O(Δx²) nos esquemas.",
                                    "Calcule o erro local truncado τ para um esquema genérico."
                                  ],
                                  "verification": "Derive a expansão de Taylor para ∂t u até ordem 2 e verifique os coeficientes.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Notas de aula de Análise Numérica II",
                                    "Calculadora simbólica (SymPy)",
                                    "Folhas de exercícios"
                                  ],
                                  "tips": "Memorize a expansão geral de Taylor multivariável para facilitar derivações.",
                                  "learningObjective": "Dominar a expansão em série de Taylor aplicada a diferenças finitas.",
                                  "commonMistakes": [
                                    "Parar na primeira ordem",
                                    "Erros nos sinais dos termos pares/ímpares",
                                    "Confundir Δt com Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o erro de truncamento local para o esquema explícito",
                                  "subSteps": [
                                    "Substitua as expansões de Taylor na fórmula explícita: u^{n+1}_j ≈ u^n_j + Δt ∂t u + (Δt²/2) ∂tt u + ...",
                                    "Expanda o laplaciano: Δx² ∂xx u + (Δx⁴/12) ∂xxxx u + ...",
                                    "Combine termos para obter τ^{expl} = [ (Δt/2) ∂tt u - (Δx²/12) ∂xxxx u ] + O(Δt², Δx⁴, Δt Δx²).",
                                    "Verifique consistência: τ → 0 quando Δt, Δx → 0.",
                                    "Teste com uma solução exata conhecida."
                                  ],
                                  "verification": "Escreva a expressão exata de τ^{expl} e confirme que é O(Δt + Δx²).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software simbólico (Mathematica ou SymPy)",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Agrupe termos por potências de Δt e Δx para clareza.",
                                  "learningObjective": "Derivar precisamente o erro local do esquema explícito.",
                                  "commonMistakes": [
                                    "Esquecer ∂tt u = ∂xxxx u pela PDE",
                                    "Sinais errados na expansão do laplaciano",
                                    "Ignorar ordens superiores prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar o erro de truncamento local para o esquema implícito",
                                  "subSteps": [
                                    "Aplique expansões de Taylor em u^{n+1}_{j±1} centradas em (x_j, t_n).",
                                    "Expanda: u^{n+1}_j = u^n_j + Δt ∂t u + (Δt²/2) ∂tt u + O(Δt³).",
                                    "Para o laplaciano implícito: ajuste para futuro e combine.",
                                    "Obtenha τ^{impl} = [ (Δt/2) ∂tt u + (Δx²/12) ∂xxxx u ] + O(Δt², Δx⁴).",
                                    "Compare com o explícito destacando diferenças."
                                  ],
                                  "verification": "Derive τ^{impl} e mostre que também tende a zero, confirmando consistência.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Mesmos do step 3",
                                    "Tabela comparativa de erros"
                                  ],
                                  "tips": "Use a PDE para relacionar ∂tt u = ∂t (∂xx u) = ∂xx (∂t u) = ∂xxxx u.",
                                  "learningObjective": "Derivar e comparar erros locais entre esquemas explícito e implícito.",
                                  "commonMistakes": [
                                    "Expansão errada para termos futuros",
                                    "Não ajustar laplaciano para t^{n+1}",
                                    "Confundir coeficientes com explícito"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calcular numericamente e verificar os erros de truncamento",
                                  "subSteps": [
                                    "Escolha solução exata u(x,t) = e^{-π² t} sin(π x), que satisfaz u_t = u_xx.",
                                    "Implemente esquemas e compare com exata em malhas finas.",
                                    "Calcule τ numericamente: plugue u exata nas diferenças finitas e subtraia PDE.",
                                    "Estime ordens de convergência variando Δt e Δx.",
                                    "Plote ||τ|| vs. Δt, Δx para validar derivações."
                                  ],
                                  "verification": "Obtenha gráficos mostrando O(Δt + Δx²) e relatório de cálculo.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Python (NumPy, Matplotlib)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use grids log para visualizar ordens; refine malha sistematicamente.",
                                  "learningObjective": "Aplicar derivações em cálculos numéricos e validar.",
                                  "commonMistakes": [
                                    "Erros de indexação no código",
                                    "Malhas não refinadas o suficiente",
                                    "Não normalizar erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u(x,t) = exp(-t) sin(π x) em [0,1]x[0,T], com Δx=0.1, Δt=0.005, r=0.5: derive τ^{expl} analiticamente usando ∂tt u = ∂xxxx u = π⁴ exp(-t) sin(π x), calcule numericamente plugando na FD e compare valores em ponto interior.",
                              "finalVerifications": [
                                "Derivação correta de τ^{expl} e τ^{impl} com ordens exatas.",
                                "Código numérico roda sem erros e reproduz solução exata.",
                                "Gráficos confirmam convergência O(Δt + Δx²).",
                                "Comparação qualitativa: implícito tem termo oposto em Δx².",
                                "Relatório explica uso da PDE para simplificar termos.",
                                "Teste com outra solução exata (ex: polinômio) valida generalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (coeficientes corretos).",
                                "Identificação correta de ordens de truncamento.",
                                "Implementação numérica livre de bugs e convergente.",
                                "Explicação clara das diferenças entre esquemas.",
                                "Uso apropriado da PDE para reduzir termos.",
                                "Análise de erros numéricos com estimativas de ordem."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para análise numérica.",
                                "Física: Modelagem de difusão térmica ou propagação de ondas.",
                                "Engenharia Computacional: Simulações CFD com métodos FD.",
                                "Estatística: Análise de erro em aproximações numéricas.",
                                "Ciências de Dados: Validação de modelos de ML baseados em PDEs."
                              ],
                              "realWorldApplication": "Em simulações de transferência de calor (ex: previsão de incêndios florestais), finanças (modelos Black-Scholes parabólicos) ou biologia (difusão de espécies), calcular τ garante precisão e eficiência computacional ao escolher Δt/Δx ótimos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Verificar consistência de um esquema",
                            "description": "Analisar e demonstrar a consistência de ordem dois para o esquema de diferenças finitas centradas em equações parabólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Equação Parabólica e o Esquema de Diferenças Finitas Centradas",
                                  "subSteps": [
                                    "Identifique a equação parabólica modelo: u_t = α u_xx, onde α é a coeficiente de difusão.",
                                    "Descreva o esquema explícito de diferenças finitas centradas: (u_j^{n+1} - u_j^n)/Δt = α (u_{j+1}^n - 2u_j^n + u_{j-1}^n)/Δx^2.",
                                    "Defina os parâmetros: Δt (passo de tempo), Δx (passo de espaço), índices j (espaço) e n (tempo).",
                                    "Explique o operador de diferença central para a segunda derivada: δ_x^2 u_j = (u_{j+1} - 2u_j + u_{j-1})/Δx^2.",
                                    "Anote as condições de contorno e inicial típicas para o problema."
                                  ],
                                  "verification": "Escreva corretamente o esquema numérico e identifique todos os termos sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Papel quadriculado e caneta",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre use notação consistente: subscrito j para espaço, sobrescrito n para tempo.",
                                  "learningObjective": "Reconhecer a estrutura do esquema de diferenças finitas centradas para EDPs parabólicas.",
                                  "commonMistakes": [
                                    "Confundir o operador forward em tempo com central",
                                    "Esquecer o fator α na difusão",
                                    "Usar Δh em vez de Δx explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar a Definição Formal de Consistência",
                                  "subSteps": [
                                    "Defina consistência: Um esquema é consistente se lim_{Δt,Δx→0} L_h(φ) = L(φ), onde L é o operador diferencial e L_h o numérico.",
                                    "Introduza o Erro de Truncamento Local (LTE): τ_h(φ) = [L_h(φ) - L(φ)] / max|φ|.",
                                    "Especifique ordem de consistência p se ||τ_h|| = O(Δt^r + Δx^p), com r≥1 para tempo.",
                                    "Para ordem dois: Demonstre que o erro espacial é O(Δx^2) via diferenças centradas.",
                                    "Discuta a relação com estabilidade via Lax Equivalence Theorem.",
                                    "Anote a fórmula geral para LTE no esquema parabólico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de consistência de ordem dois.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula de Análise Numérica II",
                                    "Referência: Slide sobre teorema de Lax"
                                  ],
                                  "tips": "Lembre-se: consistência é aproximação da PDE, não da solução exata.",
                                  "learningObjective": "Aplicar a definição formal de consistência a esquemas numéricos.",
                                  "commonMistakes": [
                                    "Confundir consistência com convergência",
                                    "Ignorar a normalização no LTE",
                                    "Esquecer termos mistos Δt e Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Erro de Truncamento Usando Expansões de Taylor",
                                  "subSteps": [
                                    "Expanda u(x_j, t_{n+1}) em Taylor ao redor de (x_j, t_n): u + Δt u_t + (Δt)^2/2 u_{tt} + O(Δt^3).",
                                    "Expanda o operador espacial: u(x_{j+1},t_n) = u + Δx u_x + (Δx)^2/2 u_{xx} + (Δx)^3/6 u_{xxx} + (Δx)^4/24 u_{xxxx} + O(Δx^5).",
                                    "Similar para u(x_{j-1},t_n), e combine para δ_x^2 u = u_{xx} + (Δx)^2/12 u_{xxxx} + O(Δx^4).",
                                    "Substitua no esquema: LTE = [u_t - α u_{xx}] + O(Δt) + α (Δx)^2/12 u_{xxxx} + higher terms.",
                                    "Simplifique assumindo a PDE u_t = α u_{xx}, e isole termos de erro: O(Δt) + O(Δx^2).",
                                    "Confirme ordem dois no espaço devido às diferenças centradas simétricas."
                                  ],
                                  "verification": "Derive o LTE completo, mostrando termos O(Δt) e O(Δx^2) explicitamente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Mathematica/MATLAB)",
                                    "Papel para expansões longas"
                                  ],
                                  "tips": "Use a PDE para substituir derivadas altas: u_{tt} = α u_{xxt} = α^2 u_{xxxx}, etc.",
                                  "learningObjective": "Executar expansões de Taylor para analisar precisão do esquema.",
                                  "commonMistakes": [
                                    "Parar na ordem errada (ex: ignorar (Δx)^4)",
                                    "Assinaturas erradas em Taylor (ímpar vs par)",
                                    "Não cancelar termos principais corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e Verificar a Consistência de Ordem Dois",
                                  "subSteps": [
                                    "Resuma o LTE: |τ| ≤ C (Δt + Δx^2), confirmando ordem dois no espaço e um no tempo.",
                                    "Discuta implicações: Para consistência global, requer Δt / Δx^2 → 0.",
                                    "Teste numericamente: Implemente esquema simples e compare com solução exata.",
                                    "Verifique para Crank-Nicolson (central em tempo) para ordem dois completo.",
                                    "Documente a prova em um relatório curto.",
                                    "Identifique condições CFL para estabilidade."
                                  ],
                                  "verification": "Escreva a conclusão: 'O esquema é consistente de ordem dois no espaço'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/MATLAB para simulação rápida",
                                    "Solução analítica conhecida (ex: erro gaussiano)"
                                  ],
                                  "tips": "Sempre normalize pelo passo de malha para ordem precisa.",
                                  "learningObjective": "Interpretar resultados da análise LTE e concluir sobre consistência.",
                                  "commonMistakes": [
                                    "Atribuir ordem dois total sem analisar tempo",
                                    "Ignorar relação Δt ~ Δx^2",
                                    "Confundir LTE com erro global"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u_t = u_xx em [0,1]x[0,1], u(x,0)=sin(πx), u(0,t)=u(1,t)=0. Esquema: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), r=Δt/Δx^2. Taylor em u_j^{n+1}: Δt u_t + (Δt)^2/2 u_{tt}. Espacial: u_{xx} + (Δx)^2/12 u_{xxxx}. LTE = (Δt/2) u_{tt} - (Δx)^2/12 u_{xxxx} = O(Δt + Δx^2), confirmando ordem dois espacial.",
                              "finalVerifications": [
                                "Deriva corretamente o LTE mostrando O(Δx^2) para diferenças centradas.",
                                "Identifica que o erro temporal é O(Δt) no esquema explícito.",
                                "Explica o papel da simetria nas diferenças centradas para cancelamento de termos ímpares.",
                                "Aplica corretamente substituições usando a PDE para derivadas mistas.",
                                "Conclui validamente a consistência de ordem dois.",
                                "Discute limitações sob condições de malha não-uniformes."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das expansões de Taylor (sem erros algébricos).",
                                "Correta identificação e isolamento de termos de erro de ordem baixa.",
                                "Clareza na derivação do LTE e interpretação da ordem.",
                                "Uso apropriado da definição formal de consistência.",
                                "Inclusão de verificação numérica ou analítica complementar.",
                                "Qualidade da documentação e explicação escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e equação do calor.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Análise de erros em simulações CFD.",
                                "Estatística: Avaliação de aproximações e análise de truncamento."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica (difusão de calor/poluentes), engenharia aeroespacial (fluxo de calor em materiais) e finanças (modelos de Black-Scholes parabólicos), verificar consistência garante precisão em grids finos para previsões confiáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Estabilidade de Esquemas Numéricos",
                        "description": "Análise da estabilidade de métodos de diferenças finitas para equações parabólicas, incluindo critérios como Von Neumann e condições CFL para esquemas explícitos e implícitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Analisar estabilidade via Von Neumann",
                            "description": "Aplicar o método de Von Neumann para determinar a condição de estabilidade de esquemas explícitos FTCS para a equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação do Calor e o Esquema FTCS Explícito",
                                  "subSteps": [
                                    "Escreva a equação do calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Descreva o esquema FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Explique os operadores: Forward em tempo (explícito) e Centered em espaço.",
                                    "Discuta as aproximações de diferenças finitas para as derivadas.",
                                    "Verifique a consistência do esquema comparando com a equação original via expansão de Taylor."
                                  ],
                                  "verification": "Escreva o stencil do esquema FTCS e derive sua consistência de ordem O(Δt) + O(Δx²).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software como Mathematica/MATLAB para expansões de Taylor; notas de aula sobre diferenças finitas.",
                                  "tips": "Sempre normalize com r para simplificar análises futuras.",
                                  "learningObjective": "Compreender a formulação matemática do esquema FTCS e sua relação com a equação do calor.",
                                  "commonMistakes": "Confundir FTCS com esquemas implícitos como BTCS; esquecer que é explícito em tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Análise de Estabilidade de Von Neumann",
                                  "subSteps": [
                                    "Assuma uma solução perturbativa de Fourier: u_j^n = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação.",
                                    "Substitua na equação do esquema FTCS para obter ξ = 1 + r (e^{i k Δx} - 2 + e^{-i k Δx}).",
                                    "Simplifique usando identidades trigonométricas: e^{iθ} + e^{-iθ} = 2 cos θ, resultando em ξ = 1 - 4 r sin²(β/2), com β = k Δx.",
                                    "Defina a condição de estabilidade: |ξ| ≤ 1 para todo β ∈ [0, π].",
                                    "Discuta o espectro de frequências: β representa modos de onda, de baixa a alta frequência."
                                  ],
                                  "verification": "Derive a expressão exata de ξ em termos de r e sin²(β/2) e verifique para β=0 (ξ=1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou software simbólico (SymPy/Python); tabela de identidades trigonométricas.",
                                  "tips": "Use β = k Δx para normalizar; plote ξ vs β para visualização intuitiva.",
                                  "learningObjective": "Dominar a substituição de Fourier e derivação do símbolo de amplificação ξ.",
                                  "commonMistakes": "Esquecer o expoente n em ξ^n; confundir ξ com g (notação comum varia)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Analisar a Condição de Estabilidade",
                                  "subSteps": [
                                    "Analise |ξ| = |1 - 4 r sin²(β/2)| ≤ 1 para todo β.",
                                    "Considere o pior caso: sin²(β/2) = 1 (β=π, modo de alta frequência), então |1 - 4r| ≤ 1.",
                                    "Resolva a desigualdade: -1 ≤ 1 - 4r ≤ 1 ⇒ 0 ≤ r ≤ 1/2.",
                                    "Conclua que para r > 1/2, |ξ| > 1 para alguns modos, levando a instabilidade.",
                                    "Compare com esquemas estáveis como Crank-Nicolson (incondicionalmente estável)."
                                  ],
                                  "verification": "Mostre graficamente |ξ| vs β para r=0.4 (estável) e r=0.6 (instável).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB/Python/Mathematica para plotar |ξ(β)|; papel para desigualdades algébricas.",
                                  "tips": "Foque no modo oscilatório (alta frequência) que amplifica erros.",
                                  "learningObjective": "Determinar a condição CFL-like r ≤ 1/2 para estabilidade do FTCS.",
                                  "commonMistakes": "Ignorar o caso sin²=0 (ξ=1 sempre estável); errar o sinal na derivação de ξ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Numericamente",
                                  "subSteps": [
                                    "Implemente o esquema FTCS em código para u_t = u_xx, condições iniciais u(x,0)=sen(πx), domínio [0,1].",
                                    "Teste com r=0.4 e r=0.6, Δx=0.1, Δt=r Δx².",
                                    "Observe a evolução: para r>0.5, oscilações crescem.",
                                    "Calcule numericamente |ξ| para vários k e compare com teoria.",
                                    "Discuta von Neumann como análise local (assume periodicidade)."
                                  ],
                                  "verification": "Execute simulação e confirme crescimento exponencial para r>1/2.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB; código template para FTCS.",
                                  "tips": "Use malha periódica para validar suposição de Von Neumann.",
                                  "learningObjective": "Validar teoricamente a análise de estabilidade com experimentos numéricos.",
                                  "commonMistakes": "Erros de indexação no código; condições de contorno não periódicas invalidam análise."
                                }
                              ],
                              "practicalExample": "Para α=1, Δx=0.1, teste r=0.49 (estável: solução difunde suavemente) vs r=0.51 (instável: modos altos amplificam, solução explode em ~10 passos). Plote u em t=0.1.",
                              "finalVerifications": [
                                "Deriva corretamente ξ = 1 - 4r sin²(β/2).",
                                "Identifica r ≤ 1/2 como condição necessária e suficiente.",
                                "Explica instabilidade incondicional para FTCS sem restrições.",
                                "Valida com simulação numérica mostrando crescimento para r>1/2.",
                                "Discute limitações: análise linear, assume pequenas perturbações.",
                                "Compara com análise de matriz (eigenvalues) para malha finita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ξ (100% simbólico correto).",
                                "Correta identificação do intervalo de estabilidade r ∈ [0,1/2].",
                                "Qualidade da análise do pior caso (β=π).",
                                "Implementação numérica funcional e plots interpretados.",
                                "Explicação clara de implicações físicas (amplificação de ruído).",
                                "Uso correto de notação e unidades em exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de estabilidade em PDEs.",
                                "Engenharia Computacional: CFD e simulações de fluxo/difusão estáveis.",
                                "Programação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Matemática Pura: Análise de Fourier e estabilidade espectral."
                              ],
                              "realWorldApplication": "Em simulações de engenharia térmica (ex: previsão de aquecimento em reatores nucleares), a análise de Von Neumann garante que erros numéricos não amplifiquem, evitando previsões catastróficas em software de design de materiais ou modelagem climática de oceanos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Comparar estabilidade explícito vs implícito",
                            "description": "Comparar as condições de estabilidade dos métodos explícito (forward Euler) e implícito (backward Euler) para equações parabólicas, destacando incondicionalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os esquemas numéricos explícito e implícito para equações parabólicas",
                                  "subSteps": [
                                    "Recordar a equação parabólica modelo: u_t = α u_xx.",
                                    "Derivar o esquema forward Euler (explícito): u^{n+1}_j = u^n_j + r (u^n_{j-1} - 2u^n_j + u^n_{j+1}), onde r = α Δt / Δx².",
                                    "Derivar o esquema backward Euler (implícito): u^{n+1}_j - r (u^{n+1}_{j-1} - 2u^{n+1}_j + u^{n+1}_{j+1}) = u^n_j.",
                                    "Identificar as diferenças: explícito usa valores conhecidos no tempo n, implícito resolve sistema linear no tempo n+1.",
                                    "Discutir discretização espacial com diferenças finitas centrais."
                                  ],
                                  "verification": "Escrever as fórmulas dos dois esquemas em um caderno e confirmar que correspondem às derivações padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno, calculadora.",
                                  "tips": "Use notação consistente para Δt e Δx para evitar confusão entre passos.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre métodos explícito e implícito.",
                                  "commonMistakes": "Confundir os termos da diferença finita ou esquecer o fator α na definição de r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estabilidade do método explícito (Forward Euler)",
                                  "subSteps": [
                                    "Aplicar a análise de von Neumann: assumir solução u_j^n = ξ^n e^{i k j Δx}.",
                                    "Calcular o fator de amplificação |ξ| = |1 - 4r sin²(θ/2)|, onde θ = k Δx.",
                                    "Determinar a condição para |ξ| ≤ 1 para todo θ: r ≤ 1/2.",
                                    "Verificar com r > 1/2: instabilidade ocorre pois |ξ| > 1 para alguns modos.",
                                    "Plotar |ξ| vs θ para diferentes r."
                                  ],
                                  "verification": "Derivar a condição r ≤ 1/2 e graficar |ξ| mostrando instabilidade para r=0.6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB ou papel), livro de referência.",
                                  "tips": "Comece com θ pequeno e grande para entender o comportamento.",
                                  "learningObjective": "Derivar e interpretar a condição de estabilidade condicional do método explícito.",
                                  "commonMistakes": "Esquecer o módulo |ξ| ou usar aproximação errada para sin²(θ/2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a estabilidade do método implícito (Backward Euler)",
                                  "subSteps": [
                                    "Aplicar análise de von Neumann ao esquema implícito.",
                                    "Calcular ξ = 1 / (1 + 4r sin²(θ/2)).",
                                    "Verificar |ξ| ≤ 1 para todo r > 0 e todo θ, pois denominador >1.",
                                    "Concluir estabilidade incondicional: não há restrição em r.",
                                    "Comparar numericamente com matriz de amplificação."
                                  ],
                                  "verification": "Mostrar que |ξ| < 1 para r > 0 e graficar confirmando estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmos do step anterior, incluindo código Python para plot.",
                                  "tips": "Note que ξ é sempre positivo e menor que 1, dissipando erros.",
                                  "learningObjective": "Demonstrar a estabilidade incondicional do método implícito.",
                                  "commonMistakes": "Inverter numerador e denominador na fórmula de ξ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar as estabilidades e destacar implicações",
                                  "subSteps": [
                                    "Tabular condições: Explícito (r ≤ 1/2, condicional), Implícito (r qualquer >0, incondicional).",
                                    "Discutir trade-offs: Explícito mais simples/barato, mas restrito; Implícito estável mas requer solver linear.",
                                    "Analisar custo computacional: Explícito O(N), Implícito O(N³) por passo sem otimizações.",
                                    "Concluir vantagens do implícito para simulações longas.",
                                    "Resumir em um quadro comparativo."
                                  ],
                                  "verification": "Criar tabela comparativa e explicar verbalmente as diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno para tabela, software para simulação opcional.",
                                  "tips": "Use exemplos numéricos com r=0.4 (estável explícito) e r=2 (só implícito).",
                                  "learningObjective": "Comparar criticamente os métodos e suas aplicações práticas.",
                                  "commonMistakes": "Ignorar custo computacional do implícito ou superestimar simplicidade."
                                }
                              ],
                              "practicalExample": "Resolva numericamente u_t = u_xx em [0,1]x[0,1], u(0,x)=sin(πx), u(1,x)=0, u(t,0)=u(t,1)=0. Use Δx=0.1 (N=10), Δt=0.005 (r=0.5 explícito estável) vs Δt=0.02 (r=2 implícito estável). Observe oscilações no explícito com r=2.",
                              "finalVerifications": [
                                "Derivação correta de |ξ| para ambos métodos.",
                                "Identificação precisa da condição r ≤ 1/2 para explícito.",
                                "Confirmação de |ξ| ≤ 1 para qualquer r no implícito.",
                                "Tabela comparativa completa com trade-offs.",
                                "Gráficos de |ξ| vs θ mostrando diferenças.",
                                "Explicação verbal da incondicionalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de estabilidade (90% correto).",
                                "Clareza na comparação de condições (explícito condicional vs implícito incondicional).",
                                "Uso correto de análise de von Neumann.",
                                "Inclusão de exemplos numéricos ou gráficos.",
                                "Discussão de implicações práticas (custo vs estabilidade).",
                                "Ausência de erros comuns como fórmulas invertidas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de difusão térmica e ondas.",
                                "Computação: Implementação de solvers lineares (Thomas algorithm para tridiagonal).",
                                "Engenharia: Modelagem em CFD e finanças (equações de Black-Scholes).",
                                "Estatística: Análise de erro numérico e condicionamento."
                              ],
                              "realWorldApplication": "Em simulações de propagação de calor em reatores nucleares ou previsão meteorológica, o método implícito permite passos de tempo maiores, reduzindo tempo computacional em simulações de longa duração sem perda de estabilidade."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Estabilidade em métodos ADI",
                            "description": "Examinar a estabilidade incondicional dos métodos ADI (Alternating Direction Implicit) para equações parabólicas bidimensionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão do Esquema ADI para Equações Parabólicas 2D",
                                  "subSteps": [
                                    "Recordar a equação do calor 2D: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²).",
                                    "Descrever o método ADI: alternância entre direção x (implícita em x, explícita em y) e direção y.",
                                    "Escrever as equações discretizadas para cada meia-etapa do ADI.",
                                    "Definir o parâmetro de razão r = α Δt / Δx² (assumindo Δx = Δy).",
                                    "Explicar a fatoração do operador para o esquema completo."
                                  ],
                                  "verification": "Capacidade de derivar corretamente as equações ADI de memória ou com mínimas consultas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), caderno, calculadora simbólica como SymPy.",
                                  "tips": "Desenhe a grade 2D para visualizar as direções alternadas.",
                                  "learningObjective": "Compreender a estrutura bifatorial do método ADI.",
                                  "commonMistakes": "Confundir ordens de alternância entre passos x e y."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise de Estabilidade via Análise de Von Neumann",
                                  "subSteps": [
                                    "Aplicar análise de Von Neumann ao esquema ADI: assumir solução u = g^k e^{i(θx j + θy l)}.",
                                    "Derivar o símbolo de amplificação para cada meia-etapa (x e y).",
                                    "Calcular |g| ≤ 1 para todas as frequências θx, θy.",
                                    "Mostrar que |g| = 1 para frequências zero e independência de r.",
                                    "Comparar com Crank-Nicolson unidirecional (estável para r ≤ 1/2)."
                                  ],
                                  "verification": "Gráfico ou tabela de |g(θx, θy)| ≤ 1 para r variando de 1 a 100.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), papel para derivações analíticas.",
                                  "tips": "Use simetria θx ↔ θy para simplificar cálculos.",
                                  "learningObjective": "Dominar a análise espectral para estabilidade em 2D.",
                                  "commonMistakes": "Esquecer o produto das amplificações das duas meias-etapas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Prova de Estabilidade Incondicional",
                                  "subSteps": [
                                    "Analisar o máximo de |g| sobre o toro [0,2π]².",
                                    "Provar analiticamente que max |g| = 1, atingido em modos de baixa frequência.",
                                    "Verificar numericamente com código para r >> 1.",
                                    "Discutir estabilidade em norma L2 e implicações para erros.",
                                    "Comparar com métodos explícitos (instáveis para r > 1/4 em 2D)."
                                  ],
                                  "verification": "Demonstração matemática ou simulação mostrando ausência de crescimento exponencial.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Python com Matplotlib para plots de |g|, referências teóricas (ex: Gustafsson).",
                                  "tips": "Implemente uma função para computar g(r, θx, θy) e plote superfície 3D.",
                                  "learningObjective": "Estabelecer rigorosamente a incondicionalidade da estabilidade ADI.",
                                  "commonMistakes": "Ignorar modos de alta frequência onde oscilações podem ocorrer."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação e Testes Numéricos",
                                  "subSteps": [
                                    "Codificar o solver ADI para problema teste (calor em placa quadrada).",
                                    "Testar com r = 1, 10, 100 e monitorar norma do erro.",
                                    "Comparar soluções com r pequeno vs. grande.",
                                    "Analisar tempo de computação vs. precisão.",
                                    "Verificar conservação de energia/massa aproximada."
                                  ],
                                  "verification": "Simulações estáveis sem blow-up para Δt arbitrariamente grande.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python/Jupyter Notebook, biblioteca SciPy para solvers lineares.",
                                  "tips": "Use Thomas algorithm para tridiagonal em 1D sweeps.",
                                  "learningObjective": "Validar teoricamente estabilidade via experimentos computacionais.",
                                  "commonMistakes": "Erros de indexação na grade 2D ou condições de contorno."
                                }
                              ],
                              "practicalExample": "Implemente ADI para simular difusão de calor em uma placa metálica 1m x 1m inicializada com gradiente de temperatura (100°C no centro, 0°C nas bordas). Use Δx=0.01m e teste Δt=1s (r=1) vs. Δt=100s (r=100), mostrando solução estável e precisa em ambos.",
                              "finalVerifications": [
                                "Derivação correta do símbolo de amplificação g com |g| ≤ 1 para todo r > 0.",
                                "Simulação numérica sem instabilidade para r > 50.",
                                "Gráfico de evolução temporal da norma L2 da solução mostrando platô.",
                                "Comparação qualitativa com solução analítica de Fourier.",
                                "Explicação verbal da razão da estabilidade incondicional (fatoração Crank-Nicolson).",
                                "Identificação de limitações (ex: precisão para r muito grande)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da análise Von Neumann (90% dos passos corretos).",
                                "Correção da prova de |g| ≤ 1 (completude matemática).",
                                "Qualidade da implementação numérica (erro < 1e-3).",
                                "Interpretação de resultados (conexão teoria-prática).",
                                "Profundidade das conexões com outros métodos (ex: Peaceman-Rachford).",
                                "Clareza na documentação de códigos e derivações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e leis de Fick.",
                                "Computação: Algoritmos iterativos e solvers lineares tridiagonais.",
                                "Engenharia: Simulações CFD para transferência de calor.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações de engenharia térmica, como previsão de aquecimento em painéis solares ou resfriamento de chips em supercomputadores, onde passos de tempo grandes aceleram simulações sem perda de estabilidade, permitindo análises em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Convergência e Teorema de Lax",
                        "description": "Teorema da equivalência de Lax para equações parabólicas: um esquema consistente e estável é convergente, com análise de taxas de convergência.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Enunciar Teorema de Lax",
                            "description": "Enunciar e provar o teorema de equivalência de Lax para esquemas numéricos em equações de difusão parabólicas em domínio finito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais Pré-requisitos",
                                  "subSteps": [
                                    "Recordar a forma geral da equação de difusão parabólica: ∂u/∂t = ∇·(D ∇u) em domínio finito Ω com condições de contorno.",
                                    "Definir consistência de um esquema numérico: limite da truncagem local tende a zero quando h, τ → 0.",
                                    "Definir estabilidade: norma da solução numérica bounded independentemente de N.",
                                    "Entender convergência: ||u^n - u(t_n)|| → 0 quando h, τ → 0.",
                                    "Estudar normas relevantes (L², L∞) para soluções em domínio finito."
                                  ],
                                  "verification": "Escrever definições precisas de consistência, estabilidade e convergência em um papel e comparar com referências.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque ou Quarteroni), notas de aula de Análise Numérica II, calculadora.",
                                  "tips": "Use diagramas para visualizar discretização em malha finita.",
                                  "learningObjective": "Dominar as definições exatas que compõem o teorema de Lax.",
                                  "commonMistakes": "Confundir consistência (aproximação da PDE) com estabilidade (controle de erros acumulados)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar Precisamente o Teorema de Lax",
                                  "subSteps": [
                                    "Estudar o enunciado: Para esquemas numéricos em EDP parabólicas lineares em domínio finito, consistência + estabilidade forte implica convergência.",
                                    "Identificar condições: Solução exata suave, malha uniforme quasi-regular, operador elíptico uniforme.",
                                    "Escrever o teorema formalmente: Se o esquema é consistente e estável em norma L², então converge com ordem da truncagem.",
                                    "Memorizar exceções: Não vale para não-lineares sem lipschitz.",
                                    "Praticar recitação oral do enunciado completo."
                                  ],
                                  "verification": "Gravar áudio enunciando o teorema e verificar contra o livro-texto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Referência principal (ex: Gustafsson et al. ou notas do curso), gravador de voz.",
                                  "tips": "Divida o enunciado em partes: premissas, tese, condições.",
                                  "learningObjective": "Enunciar o teorema de Lax sem erros ou omissões.",
                                  "commonMistakes": "Omitir 'domínio finito' ou confundir com teorema geral de Lax-Milgram."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Esboçar a Prova do Teorema",
                                  "subSteps": [
                                    "Prova por contradição: Suponha não convergência, então existe subsequence com erro bounded away from zero.",
                                    "Usar consistência: Erro de truncagem pequeno implica erro de solução pequena.",
                                    "Aplicar estabilidade: Multiplicadores de erro bounded.",
                                    "Concluir pelo teorema de Aubin-Nitsche para ordem ótima em normas mais fracas.",
                                    "Discutir passos chave: Estimativa de Gronwall, projeção em espaços de Sobolev."
                                  ],
                                  "verification": "Escrever esboço da prova em 1 página e discutir com colega ou professor.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Papel e caneta, livro com prova detalhada (ex: Brenner-Scott), software LaTeX para equações.",
                                  "tips": "Foque no fluxo lógico: consistência → aproximação, estabilidade → propagação.",
                                  "learningObjective": "Compreender e reproduzir os passos essenciais da prova.",
                                  "commonMistakes": "Ignorar condições de suavidade da solução exata ou regularidade da malha."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar o Teorema em Exemplo Simples",
                                  "subSteps": [
                                    "Escolher esquema: Explícito FTCS para u_t = u_xx em [0,1] com u(0,t)=u(1,t)=0.",
                                    "Verificar consistência: Calcular truncagem O(τ + h²).",
                                    "Verificar estabilidade: Condição CFL τ ≤ h²/2.",
                                    "Concluir convergência sob condições de Lax.",
                                    "Simular numericamente para validar."
                                  ],
                                  "verification": "Implementar código simples e plotar erro vs. h, τ.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Python/MATLAB com NumPy/Matlab, solução analítica de referência.",
                                  "tips": "Use malhas finas para observar convergência empírica.",
                                  "learningObjective": "Aplicar o teorema para validar um esquema concreto.",
                                  "commonMistakes": "Esquecer fator 1/2 na condição de estabilidade do FTCS."
                                }
                              ],
                              "practicalExample": "Para o esquema θ para a equação de calor u_t = k u_xx em [0,1]×[0,T] com condições Dirichlet u(0,t)=u(1,t)=0: Verifique consistência (ordem O(τ + h²)), estabilidade (para θ ≥ 1/2), e conclua convergência pelo teorema de Lax. Implemente em Python e compare com solução exata u(x,t)=∑ sin(nπx) exp(-k n²π² t) b_n.",
                              "finalVerifications": [
                                "Enunciar o teorema completo sem hesitação ou erros.",
                                "Explicar verbalmente as três componentes: consistência, estabilidade, convergência.",
                                "Esboçar prova em menos de 5 minutos.",
                                "Identificar corretamente um esquema consistente mas instável.",
                                "Aplicar teorema a um novo exemplo parabólico.",
                                "Discutir limitações em domínios não-regulares."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do teorema (30%)",
                                "Correção no esboço da prova (25%)",
                                "Compreensão de pré-requisitos e condições (20%)",
                                "Aplicação prática em exemplo (15%)",
                                "Identificação de erros comuns e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e transporte de massa.",
                                "Computação Científica: Análise de algoritmos numéricos e PDE solvers.",
                                "Engenharia: Simulações em CFD e materiais.",
                                "Estatística: Análise de erros numéricos e convergência probabilística."
                              ],
                              "realWorldApplication": "Em simulações numéricas para previsão de difusão de calor em reatores nucleares, propagação de poluentes em aquíferos ou modelagem de preços em finanças (equações parabólicas do tipo Black-Scholes), garantindo que os esquemas numéricos sejam confiáveis para decisões críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Demonstrar convergência",
                            "description": "Demonstrar a convergência de ordem dois para o esquema Crank-Nicolson em equações parabólicas usando princípios de consistência e estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos: Equação Parabólica, Esquema Crank-Nicolson e Teorema de Lax",
                                  "subSteps": [
                                    "Estude a equação parabólica modelo: ∂u/∂t = α ∂²u/∂x² em domínio 1D.",
                                    "Derive a discretização do esquema Crank-Nicolson: combinação implícita média de Euler forward e backward.",
                                    "Revise o Teorema de Lax: convergência segue de consistência e estabilidade para esquemas lineares bem-postos.",
                                    "Identifique parâmetros: passo de tempo Δt, passo de espaço Δx, r = α Δt / (Δx)².",
                                    "Anote condições para ordem de truncamento."
                                  ],
                                  "verification": "Resuma em um parágrafo os componentes chave do Teorema de Lax e a forma matricial do esquema CN.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Use diagramas de stencil para visualizar o esquema CN explicitamente.",
                                  "learningObjective": "Compreender a estrutura do problema e teorema fundamental de convergência.",
                                  "commonMistakes": "Confundir estabilidade com consistência; esquecendo que CN é implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar Consistência de Ordem Dois",
                                  "subSteps": [
                                    "Expanda a solução exata u(x,t) em série de Taylor ao redor de (x_j, t_n).",
                                    "Aplique operadores de diferenças finitas: δ_t u = (u^{n+1} - u^n)/Δt, δ_{xx} u = (u_{j+1} - 2u_j + u_{j-1})/Δx².",
                                    "Mostre que o esquema CN aproxima ∂u/∂t - α ∂²u/∂x² com erro de truncamento O(Δt² + Δx²).",
                                    "Calcule explicitamente os termos de ordem dois em Δt e Δx.",
                                    "Conclua que é consistente de ordem dois independentemente de r."
                                  ],
                                  "verification": "Derive a expansão de Taylor e isole o erro local de truncamento τ = O(Δt² + Δx²).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software de álgebra computacional para expansões simbólicas.",
                                  "tips": "Centralize expansões em ponto médio (t_n + Δt/2) para precisão.",
                                  "learningObjective": "Calcular e interpretar o erro de consistência para ordem dois.",
                                  "commonMistakes": "Ignorar termos cruzados como ∂⁴u/∂x⁴ Δx²; erro em coeficientes de Taylor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Teorema de Lax e Concluir Convergência de Ordem Dois",
                                  "subSteps": [
                                    "Verifique bem-postura do problema parabólico: solução única e estável.",
                                    "Combine consistência O(Δt² + Δx²) e estabilidade para erro global O(Δt² + Δx²).",
                                    "Estime constante de convergência via norma máxima ou L2.",
                                    "Discuta refinamento h→0 com Δt ~ Δx² para ordem dois preservada.",
                                    "Resuma prova: |e^n| ≤ C (Δt² + Δx²), onde e é erro."
                                  ],
                                  "verification": "Escreva a desigualdade de erro final citando Lax equivalence.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referências: teorema Lax em texto padrão.",
                                  "tips": "Lembre: ordem de consistência = ordem de convergência sob estabilidade.",
                                  "learningObjective": "Integrar consistência e estabilidade na convergência.",
                                  "commonMistakes": "Esquecer normalização de normas; ignorar dependência em solução exata."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Numericamente com Exemplo Prático",
                                  "subSteps": [
                                    "Implemente CN para equação do calor u_t = u_xx, u(0,t)=u(1,t)=0, u(x,0)=sin(πx).",
                                    "Compute solução numérica para Δx=1/100, Δt=Δx²/2; compare com exata.",
                                    "Calcule erros L2 e ordem observada log₂(||e^{n+1}||/||e^n||).",
                                    "Varie malha e confirme convergência ~ O(Δx²).",
                                    "Analise resíduos de consistência numericamente."
                                  ],
                                  "verification": "Gráfico de erro vs h mostrando inclinação 2 em log-log.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Python (NumPy/SciPy) ou MATLAB para solver tridiagonal.",
                                  "tips": "Use thomas algorithm para eficiência; teste r grande para estabilidade.",
                                  "learningObjective": "Confirmar teoria via computação empírica.",
                                  "commonMistakes": "Erro de programação em BCs; escala errada de Δt."
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = u_xx em [0,1]×[0,T] com u(0,t)=u(1,t)=0 e u(x,0)=sin(πx), implemente CN com N=50 pontos espaciais. A solução exata é u(x,t)=sin(πx) exp(-π² t). Mostre ||u_num - u_ex||_2 ~ 10^{-4} para h=0.02, confirmando ordem dois.",
                              "finalVerifications": [
                                "Derivação correta do erro de truncamento O(Δt² + Δx²).",
                                "Prova de |ξ|≤1 para todos modos em von Neumann.",
                                "Aplicação explícita do Teorema de Lax com citação.",
                                "Implementação numérica com ordem observada ≥1.9.",
                                "Discussão de limitações (ex: não-linearidades).",
                                "Resumo escrito da convergência em 1 página."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na análise de consistência (20%).",
                                "Rigor na prova de estabilidade (25%).",
                                "Correta invocação e aplicação do Teorema de Lax (20%).",
                                "Qualidade da validação numérica e interpretação (20%).",
                                "Clareza na comunicação e tratamento de erros (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e Von Neumann stability em fluidos.",
                                "Computação: Solvers lineares (Thomas) e análise de erros numéricos.",
                                "Engenharia: Simulações CFD para parabólicas em aerodinâmica.",
                                "Estatística: Análise de convergência em MCMC métodos bayesianos."
                              ],
                              "realWorldApplication": "O esquema Crank-Nicolson é usado em simulações climáticas (modelos de oceanos), finanças (equações Black-Scholes PDE), e engenharia biomédica (difusão de fármacos), onde precisão de ordem dois e estabilidade incondicional permitem passos de tempo grandes em malhas finas para eficiência computacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Analisar noções de dispersão e dissipação",
                            "description": "Explicar os conceitos de dispersão numérica e dissipação em esquemas para equações parabólicas e seu impacto na convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Dispersão e Dissipação",
                                  "subSteps": [
                                    "Definir dispersão como a introdução de oscilações espúrias de alta frequência em soluções numéricas.",
                                    "Definir dissipação como o amortecimento excessivo de componentes de onda em esquemas numéricos.",
                                    "Explicar a relação com o símbolo de dispersão φ(kΔx) e dissipação ψ(kΔx) na análise de von Neumann.",
                                    "Comparar com comportamento exato da equação parabólica, onde não há dispersão.",
                                    "Revisar o papel no Teorema de Lax-Milgram para estabilidade."
                                  ],
                                  "verification": "Resumir definições em um parágrafo coerente e identificar diferenças chave em um diagrama.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula sobre von Neumann",
                                    "Software MATLAB ou Python para plots simbólicos"
                                  ],
                                  "tips": [
                                    "Use analogias com ondas físicas para visualizar dispersão como 'frentes de onda irregulares'.",
                                    "Desenhe gráficos de fase e amplitude para fixar ideias."
                                  ],
                                  "learningObjective": "Dominar definições precisas e distinções entre dispersão e dissipação.",
                                  "commonMistakes": [
                                    "Confundir dispersão com difusão física.",
                                    "Ignorar dependência no número de onda k."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Dispersão e Dissipação em Esquemas Explícitos e Implícitos",
                                  "subSteps": [
                                    "Derivar o símbolo de amplificação para esquema explícito forward-time central-space (FTCS) na equação u_t = u_xx.",
                                    "Calcular φ(kΔx) ≈ kΔx - (kΔx)^3/6 para dispersão no FTCS.",
                                    "Analisar ψ(kΔx) ≈ 1 - 2(1 - cos(kΔx)) para dissipação.",
                                    "Comparar com esquema implícito backward-time central-space (BTCS), que é dissipativo mas não dispersivo.",
                                    "Plotar curvas de dispersão e dissipação para diferentes r = Δt/Δx^2."
                                  ],
                                  "verification": "Produzir gráficos de φ e ψ vs. kΔx e anotar regiões de dispersão excessiva.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Caderno de derivadas simbólicas",
                                    "Python com NumPy/Matplotlib para plots",
                                    "Referência: Tannehill 'Computational Fluid Mechanics'"
                                  ],
                                  "tips": [
                                    "Expanda em séries de Taylor para aproximações assintóticas.",
                                    "Varie r para ver trade-offs."
                                  ],
                                  "learningObjective": "Calcular e interpretar símbolos em esquemas comuns para equações parabólicas.",
                                  "commonMistakes": [
                                    "Esquecer o fator i em dispersão complexa.",
                                    "Usar aproximações sem validar o espectro de k."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o Impacto na Convergência de Soluções Numéricas",
                                  "subSteps": [
                                    "Explicar como dispersão excessiva causa oscilações não físicas, violando estabilidade CFL-like.",
                                    "Discutir dissipação excessiva levando a soluções 'borradas' e perda de precisão.",
                                    "Relacionar ao Teorema de Lax: consistência + estabilidade requer controle de dispersão/dissipação.",
                                    "Analisar ordem de precisão: esquemas de ordem par dissipam, ímpar dispersam.",
                                    "Simular numericamente um pulso inicial e observar evolução com dispersão/dissipação.",
                                    "Quantificar impacto via norma L2 do erro."
                                  ],
                                  "verification": "Executar simulação e relatar erro relativo com/ sem controle de dispersão.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python/Jupyter para simulação 1D",
                                    "Gráficos de soluções exata vs. numérica"
                                  ],
                                  "tips": [
                                    "Use condições iniciais com múltiplas escalas para destacar efeitos.",
                                    "Monitore energia numérica para detectar instabilidade."
                                  ],
                                  "learningObjective": "Conectar dispersão/dissipação à convergência via estabilidade e consistência.",
                                  "commonMistakes": [
                                    "Atribuir todos os erros à dispersão sem medir.",
                                    "Ignorar condições de contorno em análises."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise para Melhorar Esquemas e Verificar Compreensão",
                                  "subSteps": [
                                    "Propor modificações como upwinding para reduzir dispersão em parabólicas.",
                                    "Discutir esquemas de alta ordem (ex: Runge-Kutta) e seu perfil de dispersão.",
                                    "Analisar esquemas Crank-Nicolson: neutro em baixa frequência, mas dispersivo em alta.",
                                    "Realizar estudo de sensibilidade variando malha.",
                                    "Sintetizar impactos qualitativos e quantitativos na convergência.",
                                    "Preparar relatório com conclusões."
                                  ],
                                  "verification": "Modificar um esquema instável para estável e demonstrar melhora na convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Códigos de referência para esquemas avançados",
                                    "Ferramentas de plotagem avançada (ex: Matplotlib animations)"
                                  ],
                                  "tips": [
                                    "Priorize esquemas A-estáveis para parabólicas rígidas.",
                                    "Use filtros espectrais para pós-processamento."
                                  ],
                                  "learningObjective": "Projetar melhorias baseadas em análise de dispersão/dissipação.",
                                  "commonMistakes": [
                                    "Sobreestimar benefícios sem simulações.",
                                    "Negligenciar custo computacional."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação do calor u_t = u_xx em [0,1] com u(0,t)=u(1,t)=0 e pulso gaussiano inicial. Use FTCS com r=0.5: observe oscilações dispersivas em altas frequências vs. BTCS dissipativo que suaviza excessivamente. Meça taxa de convergência refinando Δx.",
                              "finalVerifications": [
                                "Explicar dispersão vs. dissipação com exemplo gráfico.",
                                "Derivar símbolo para FTCS e identificar φ ≠ 0.",
                                "Simular e quantificar erro devido a dispersão.",
                                "Relacionar ao Teorema de Lax com contraexemplo.",
                                "Propor esquema melhorado e justificar.",
                                "Discutir limites para convergência ótima."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e distinções (30%)",
                                "Correção matemática em derivações de símbolos (25%)",
                                "Qualidade de simulações e interpretação de resultados (20%)",
                                "Conexão clara com convergência e Teorema de Lax (15%)",
                                "Criatividade em melhorias e aplicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com propagação de ondas e difusão térmica.",
                                "Computação: Otimização de algoritmos numéricos e análise espectral.",
                                "Engenharia: Simulações em dinâmica de fluidos computacional (CFD).",
                                "Estatística: Análise de erros numéricos como variância."
                              ],
                              "realWorldApplication": "Em modelagem climática, controlar dissipação em simulações de difusão de calor atmosférico evita previsões imprecisas; em finanças, esquemas sem dispersão excessiva melhoram simulações de equações parabólicas para precificação de opções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Estabilidade de Esquemas para Equações Parabólicas",
                    "description": "Análise de estabilidade, incluindo critérios como von Neumann, para equações parabólicas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Conceitos Fundamentais de Estabilidade",
                        "description": "Definições e teoremas básicos relacionados à estabilidade de esquemas numéricos para equações diferenciais parciais parabólicas, incluindo o teorema de equivalência de Lax.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir estabilidade em métodos de diferenças finitas",
                            "description": "Explicar o conceito de estabilidade para esquemas numéricos resolvendo equações parabólicas, distinguindo estabilidade em norma L2 e sua relação com o crescimento de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Equações Parabólicas e Métodos de Diferenças Finitas",
                                  "subSteps": [
                                    "Estude a forma geral da equação parabólica: u_t = α u_xx + f(x,t).",
                                    "Revise a discretização espacial com diferenças finitas centrais: δ_x² u = (u_{j+1} - 2u_j + u_{j-1})/h².",
                                    "Aprenda os esquemas explícito (FTCS) e implícito: u^{n+1}_j = u^n_j + r (u^n_{j+1} - 2u^n_j + u^n_{j-1}).",
                                    "Implemente uma simulação simples em Python ou MATLAB para visualizar a solução numérica.",
                                    "Analise o truncamento local e global de erro para esses esquemas."
                                  ],
                                  "verification": "Escreva e execute código que discretiza corretamente a equação do calor com esquema FTCS e plota a solução estável.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de Análise Numérica I",
                                    "Livro 'Finite Difference Schemes and Partial Differential Equations' de LeVeque (Cap. 2)",
                                    "Python com NumPy e Matplotlib"
                                  ],
                                  "tips": "Comece com condições de contorno de Dirichlet para simplicidade; teste com r = dt/h² = 0.5.",
                                  "learningObjective": "Compreender a discretização básica necessária para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir diferenças forward e central",
                                    "Ignorar a relação r = α dt / h²",
                                    "Esquecer condições iniciais suaves"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito Geral de Estabilidade Numérica",
                                  "subSteps": [
                                    "Defina estabilidade como a propriedade onde pequenos erros de arredondamento ou truncamento não crescem descontroladamente.",
                                    "Estude a análise de Von Neumann: amplificação de modos de Fourier e fator de amplificação |g(θ)| ≤ 1.",
                                    "Discuta estabilidade condicional (ex: FTCS requer r ≤ 0.5) vs. incondicional (ex: implícito).",
                                    "Revise o Teorema de Equivalência de Lax: consistência + estabilidade implica convergência.",
                                    "Calcule o fator de amplificação para FTCS: g(θ) = 1 - 4r sin²(θ/2)."
                                  ],
                                  "verification": "Calcule o fator de amplificação para FTCS e identifique valores de r onde |g| > 1.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Slides de aula sobre Análise Numérica II",
                                    "Capítulo 3 de LeVeque",
                                    "MATLAB ou Python para plotar |g(θ)|"
                                  ],
                                  "tips": "Plote |g(θ)| vs. θ para diferentes r para visualizar instabilidade.",
                                  "learningObjective": "Dominar definições qualitativas e quantitativas iniciais de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com consistência",
                                    "Esquecer o papel dos modos de alta frequência (θ ≈ π)",
                                    "Aplicar Von Neumann a esquemas não lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Estabilidade em Norma L2 para Esquemas Parabólicos",
                                  "subSteps": [
                                    "Defina a norma L2 discreta: ||u||_2 = sqrt( h Σ |u_j|² ).",
                                    "Estabeleça a condição de estabilidade: ||u^{n+1}||_2 ≤ ||u^n||_2 + O(Δt) para soluções exatas aproximadas.",
                                    "Analise a matriz de amplificação A: estabilidade se ||A||_2 ≤ 1 + O(Δt).",
                                    "Compare com norma L∞ e discuta por que L2 é natural para energia em equações parabólicas.",
                                    "Prove estabilidade L2 para esquema implícito usando inner product discreto."
                                  ],
                                  "verification": "Derive a condição ||A||_2 ≤ 1 para FTCS e mostre que requer r ≤ 1/2.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "'Numerical Solution of PDEs' de Strikwerda (Cap. 4)",
                                    "Papel e lápis para derivações matriciais",
                                    "Software como SciPy para autovalores"
                                  ],
                                  "tips": "Use simetria da matriz tridiagonal para estimar norma espectral.",
                                  "learningObjective": "Diferenciar estabilidade em norma L2 de outras normas e sua relevância para parabólicas.",
                                  "commonMistakes": [
                                    "Confundir norma discreta L2 com contínua",
                                    "Ignorar fator h na normalização",
                                    "Aplicar condições L∞ a análise L2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Estabilidade com Crescimento de Erros e Exemplos Práticos",
                                  "subSteps": [
                                    "Explique que instabilidade causa crescimento exponencial de erros de alta frequência.",
                                    "Simule numericamente: rode FTCS com r=0.6 e observe oscilações.",
                                    "Discuta relação com dissipação numérica e dispersão.",
                                    "Aplique a esquemas Crank-Nicolson e ADI, verificando estabilidade incondicional em L2.",
                                    "Resuma: estabilidade previne blow-up de solução numérica."
                                  ],
                                  "verification": "Execute simulação instável vs. estável e explique o crescimento de erro em norma L2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python de exemplo para heat equation",
                                    "Gráficos de erro L2 ao longo do tempo"
                                  ],
                                  "tips": "Use solução exata analítica para computar erro real.",
                                  "learningObjective": "Conectar teoria de estabilidade ao comportamento observado de erros.",
                                  "commonMistakes": [
                                    "Atribuir instabilidade só a dt grande, ignorando h",
                                    "Não inicializar com ruído para testar",
                                    "Confundir erro de truncamento com instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o esquema FTCS para a equação do calor u_t = u_xx em [0,1]x[0,1] com u(0,x)=sin(πx), u(t,0)=u(t,1)=0. Rode com r=0.4 (estável, norma L2 do erro diminui) vs. r=0.6 (instável, norma L2 explode após poucas iterações). Plote soluções e ||e^n||_2.",
                              "finalVerifications": [
                                "Defina estabilidade em termos de norma L2 para esquemas parabólicos.",
                                "Calcule fator de amplificação Von Neumann para FTCS e identifique condição r≤1/2.",
                                "Explique por que implícito é incondicionalmente estável em L2.",
                                "Simule e diagnostique instabilidade em código numérico.",
                                "Relacione estabilidade ao crescimento controlado de erros de arredondamento.",
                                "Distinga estabilidade L2 de L∞ com exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de estabilidade L2 (exata vs. qualitativa).",
                                "Correção matemática em derivações de fatores de amplificação e normas.",
                                "Qualidade da simulação prática: plots mostram comportamento correto.",
                                "Profundidade na distinção entre tipos de estabilidade e normas.",
                                "Clareza na relação com crescimento de erros (exemplos quantitativos).",
                                "Uso correto de teoremas como Lax equivalence."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações da equação do calor para difusão térmica.",
                                "Computação: Análise de estabilidade em solvers PDE de bibliotecas como FEniCS ou FiPy.",
                                "Engenharia: Modelagem CFD estável para fluxo de calor em materiais.",
                                "Estatística: Controle de variância em métodos Monte Carlo para PDEs parabólicas."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas e simulações climáticas, onde esquemas estáveis em L2 garantem que erros numéricos em modelos de difusão de calor/poluentes não amplifiquem, permitindo simulações de longo prazo confiáveis em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Aplicar o teorema de equivalência de Lax",
                            "description": "Demonstrar como consistência e estabilidade implicam convergência para esquemas de diferenças finitas em equações parabólicas, com exemplos da equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Consistência em Esquemas de Diferenças Finitas",
                                  "subSteps": [
                                    "Defina consistência como a propriedade onde o erro de truncamento local tende a zero à medida que o passo de malha h e o passo de tempo τ vão a zero.",
                                    "Estude a ordem de consistência para esquemas em equações parabólicas, como O(h² + τ).",
                                    "Calcule o erro de truncamento para o esquema explícito da equação do calor: u_t = α u_xx.",
                                    "Verifique consistência expandindo em série de Taylor os termos discretos.",
                                    "Compare com esquemas implícitos para observar diferenças na ordem."
                                  ],
                                  "verification": "Calcule manualmente o erro de truncamento para o esquema explícito e confirme que tende a zero com h, τ → 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica de EDEs' de LeVeque",
                                    "Caderno para cálculos",
                                    "Python/MATLAB para simulações iniciais"
                                  ],
                                  "tips": "Use expansão de Taylor sistematicamente, anotando termos de cada ordem.",
                                  "learningObjective": "Definir e calcular a consistência de um esquema numérico para PDEs parabólicas.",
                                  "commonMistakes": [
                                    "Confundir consistência com convergência",
                                    "Esquecer termos mistos na expansão de Taylor",
                                    "Ignorar a relação entre h e τ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade de Esquemas Numéricos",
                                  "subSteps": [
                                    "Defina estabilidade como a propriedade onde pequenas perturbações na solução inicial não crescem descontroladamente.",
                                    "Estude a análise de von Neumann para esquemas lineares constantes coeficientes.",
                                    "Aplique ao esquema explícito da equação do calor: fator de amplificação |g(θ)| ≤ 1 para todos os modos θ.",
                                    "Determine a condição CFL: α τ / h² ≤ 1/2.",
                                    "Compare estabilidade de esquemas explícito vs. implícito (incondicionalmente estável)."
                                  ],
                                  "verification": "Derive a condição de estabilidade para o esquema explícito e teste com valores numéricos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Python com NumPy/SciPy",
                                    "Artigo original de von Neumann",
                                    "Gráficos de fator de amplificação"
                                  ],
                                  "tips": "Plote |g(θ)| vs. θ para visualizar regiões instáveis.",
                                  "learningObjective": "Avaliar estabilidade via análise de von Neumann para esquemas parabólicos.",
                                  "commonMistakes": [
                                    "Assumir estabilidade sem verificar todos os modos de Fourier",
                                    "Confundir estabilidade com precisão",
                                    "Ignorar coeficientes variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o Teorema de Equivalência de Lax",
                                  "subSteps": [
                                    "Enuncie o teorema: Para esquemas consistentes, estabilidade é equivalente a convergência.",
                                    "Compreenda a prova esboçada: use norma de energia e desigualdade triangular para ligar erro global.",
                                    "Discuta limitações: aplica-se a esquemas lineares com coeficientes constantes.",
                                    "Revise teorema de Lax-Wendroff para ordens mais altas.",
                                    "Examine contraexemplos onde falta de estabilidade causa falha na convergência."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que consistência + estabilidade implica convergência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula de Análise Numérica II",
                                    "Teorema em PDF de Lax (1962)",
                                    "Vídeo explicativo no YouTube sobre Lax Equivalence"
                                  ],
                                  "tips": "Memorize: Consistência garante aproximação, estabilidade garante controle de erros propagados.",
                                  "learningObjective": "Enunciar e justificar intuitivamente o teorema de equivalência de Lax.",
                                  "commonMistakes": [
                                    "Inverter a implicação (estabilidade não implica consistência)",
                                    "Aplicar a esquemas não-lineares",
                                    "Confundir com teorema de Lax-Wendroff"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema ao Esquema Explícito da Equação do Calor",
                                  "subSteps": [
                                    "Implemente o esquema explícito em código para u_t = u_xx em [0,1] com CI u(x,0)=sin(πx).",
                                    "Verifique consistência computando erro de truncamento.",
                                    "Confirme estabilidade escolhendo τ = 0.4 h² (dentro de CFL).",
                                    "Simule com malhas refinadas (h=1/10, 1/20, 1/40) e meça erro na norma L2.",
                                    "Observe convergência de primeira ordem e relacione ao teorema de Lax."
                                  ],
                                  "verification": "Gere gráficos de solução numérica vs. exata e tabela de erros decrescentes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com Matplotlib/NumPy",
                                    "Solução analítica conhecida",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use malhas uniformes e compare erros relativos para quantificar taxa de convergência.",
                                  "learningObjective": "Demonstrar numericamente a convergência via teorema de Lax em um exemplo concreto.",
                                  "commonMistakes": [
                                    "Violar CFL causando instabilidade",
                                    "Usar h fixo sem refinar",
                                    "Comparar com solução errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação do calor u_t = u_xx em [0,1] x [0,1] com u(0,t)=u(1,t)=0 e u(x,0)=sin(πx). Use esquema explícito com h=0.05, τ=0.001 (CFL ok). Verifique consistência (erro O(h²+τ)), estabilidade (|g|≤1), e convergência refinando malha até erro L2 < 10^-3.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema de Lax-Richtmyer.",
                                "Calcula erro de truncamento para esquema explícito da equação do calor.",
                                "Deriva condição de estabilidade via von Neumann.",
                                "Implementa simulação numérica com convergência observada.",
                                "Explica por que falta de estabilidade impede convergência apesar de consistência.",
                                "Identifica limitações do teorema."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de consistência e estabilidade (90% correto).",
                                "Correta derivação do fator de amplificação e condição CFL.",
                                "Implementação numérica sem erros de programação e com refino de malha.",
                                "Análise de resultados mostrando taxa de convergência ≈ O(h).",
                                "Explicação clara da ligação via teorema de Lax.",
                                "Identificação de pelo menos 2 contraexemplos ou limitações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de estabilidade em simulações CFD.",
                                "Computação: Implementação eficiente de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Verificação de algoritmos em controle de processos industriais.",
                                "Estatística: Análise de erros e convergência em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em engenharia térmica, aplica-se para simular distribuição de calor em placas ou prédios, garantindo que simulações numéricas convirjam para previsão precisa de temperaturas, evitando superaquecimento em designs de eletrônicos ou fornos industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Identificar consistência em esquemas parabólicos",
                            "description": "Verificar a consistência de um esquema de diferenças finitas aproximando o operador parabólico, calculando o erro de truncamento local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação parabólica e o esquema de diferenças finitas",
                                  "subSteps": [
                                    "Identifique a forma geral de uma equação parabólica, como a equação do calor: ∂u/∂t = α ∂²u/∂x².",
                                    "Descreva o esquema de diferenças finitas dado, especificando os operadores de diferença forward/backward/central para ∂t e ∂²x.",
                                    "Escreva a stencil do esquema em termos de u_{j}^n, u_{j+1}^n, etc., com passos h em x e k em t.",
                                    "Defina os parâmetros de discretização: r = α k / h².",
                                    "Verifique se o esquema aproxima o operador diferencial corretamente em nível qualitativo."
                                  ],
                                  "verification": "Escreva a equação contínua e o esquema discreto lado a lado, confirmando que as diferenças correspondem aos derivados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), papel e lápis ou software como Mathematica para stencil.",
                                  "tips": "Desenhe a grade espaço-tempo para visualizar os pontos usados no stencil.",
                                  "learningObjective": "Entender como o esquema discretiza o operador parabólico.",
                                  "commonMistakes": "Confundir diferenças forward com backward; ignorar o fator r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar a definição de consistência e erro de truncamento local (LTE)",
                                  "subSteps": [
                                    "Defina consistência: o esquema é consistente se LTE → 0 quando h,k → 0.",
                                    "Explique LTE: τ(u) = (L_h u - L u)/k, onde L_h é o operador discreto e L o contínuo.",
                                    "Escreva a fórmula geral para LTE em esquemas de um passo: τ^n_j = [u^{n+1}_j - u^n_j]/k - α δ_x² u^n_j / h², ajustado ao esquema.",
                                    "Discuta ordens de precisão: O(k^p + h^q) para consistência se p,q ≥1.",
                                    "Diferencie LTE de erro global de truncamento."
                                  ],
                                  "verification": "Para uma solução exata u suave, confirme que τ → 0 qualitativamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre estabilidade e convergência (Lax Equivalence Theorem).",
                                  "tips": "Lembre: Consistência é local; convergência requer estabilidade também.",
                                  "learningObjective": "Dominar a definição matemática de consistência via LTE.",
                                  "commonMistakes": "Confundir LTE com erro global; esquecer normalização por k."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o erro de truncamento local usando expansão de Taylor",
                                  "subSteps": [
                                    "Expanda u(x_j, t_n + k) em Taylor ao redor (x_j, t_n): u + k u_t + (k²/2) u_{tt} + O(k³).",
                                    "Expanda diferenças espaciais: δ_x² u / h² = u_{xx} + (h²/12) u_{xxxx} + O(h⁴).",
                                    "Substitua na expressão do esquema: [expansão temporal - α * expansão espacial]/k.",
                                    "Use a equação exata u_t = α u_{xx} para substituir termos superiores: u_{tt} = α² u_{xxxx}, etc.",
                                    "Colete termos: identifique ordens O(k) , O(h²), etc."
                                  ],
                                  "verification": "O LTE deve ser O(k + h²) ou similar; coeficientes de ordens baixas devem ser zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou papel), tabela de expansões Taylor pré-prontas.",
                                  "tips": "Faça expansões até ordem suficiente (geralmente até O(k² + h⁴)) para ver truncamento.",
                                  "learningObjective": "Calcular LTE explicitamente para um esquema dado.",
                                  "commonMistakes": "Erros em sinais nas expansões Taylor; não substituir derivados temporais por espaciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e concluir sobre a consistência do esquema",
                                  "subSteps": [
                                    "Identifique a ordem do LTE: se max(O(k^p), O(h^q)) → 0 com p,q >0, consistente.",
                                    "Para esquemas comuns: FTCS é O(k + h²), Crank-Nicolson O(k² + h²).",
                                    "Discuta impacto do parâmetro r: consistência independente de r se ordens ok.",
                                    "Compare com esquemas inconsistentes (ex: upwind errado para difusão).",
                                    "Conclua: 'O esquema é consistente de ordem (p,q)'."
                                  ],
                                  "verification": "Escreva LTE final e afirme consistência com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos resolvidos de livros (ex: esquemas para heat equation).",
                                  "tips": "Verifique com solução exata numérica para validar LTE.",
                                  "learningObjective": "Interpretar LTE para julgar consistência.",
                                  "commonMistakes": "Ignorar condições h,k →0 com k/h² fixo; confundir com estabilidade."
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação do calor u_t = u_xx: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2 u_j^n + u_{j-1}^n). Expandindo Taylor, LTE = (k/2) u_{tt} + (h²/12) u_{xxxx} + O(k² + h⁴ + k h²) = O(k + h²) já que u_{tt} = u_{xxxx}, assim consistente de ordem 1 em tempo e 2 em espaço.",
                              "finalVerifications": [
                                "LTE calculado corretamente com expansões Taylor até ordens relevantes.",
                                "Termos de ordem zero ausentes (aproximação exata dos derivados principais).",
                                "Ordem do erro explicitada e limite h,k→0 confirmado.",
                                "Conclusão escrita: 'consistente' ou 'inconsistente' com justificativa.",
                                "Validação numérica opcional: injete solução exata e meça τ.",
                                "Comparação com literatura para esquema padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expansões Taylor (sem erros algébricos).",
                                "Correta substituição de derivados usando a PDE exata.",
                                "Identificação clara da ordem de consistência.",
                                "Análise qualitativa do comportamento assintótico.",
                                "Clareza na escrita do LTE final e conclusão.",
                                "Uso apropriado de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica ou finanças (equações parabólicas).",
                                "Computação: Implementação em Python (NumPy/SciPy) para verificação numérica.",
                                "Engenharia: Simulações CFD onde consistência afeta precisão.",
                                "Estatística: Análise de erros em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações numéricas de propagação de calor em engenharia (ex: design de motores), ou previsão de preços em finanças (modelo Black-Scholes), garantir consistência assegura que discretizações finitas convergem para a solução física real, evitando erros sistemáticos em previsões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Análise de Estabilidade via von Neumann",
                        "description": "Método de análise de Fourier para determinar a estabilidade local de esquemas lineares em equações parabólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Realizar análise de von Neumann para esquemas lineares",
                            "description": "Decompor a solução em modos de Fourier, calcular o símbolo do operador e determinar o fator de amplificação para esquemas parabólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o esquema numérico linear e a equação parabólica de referência",
                                  "subSteps": [
                                    "Escreva a equação parabólica padrão, como a equação do calor: ∂u/∂t = α ∂²u/∂x².",
                                    "Apresente o esquema numérico explícito ou implícito em forma discreta, por exemplo, FTCS: u^{n+1}_j = u^n_j + r (u^n_{j+1} - 2u^n_j + u^n_{j-1}), onde r = α Δt / Δx².",
                                    "Defina os parâmetros: passos de tempo Δt, espaço Δx, e coeficiente de difusão α.",
                                    "Linearize o esquema se necessário, assumindo linearesidade.",
                                    "Anote as condições de contorno e iniciais relevantes."
                                  ],
                                  "verification": "Confirme que o esquema está corretamente escrito e corresponde à PDE de referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, ou editor de texto como Jupyter Notebook.",
                                  "tips": "Sempre normalize o esquema para destacar o fator r, facilitando cálculos posteriores.",
                                  "learningObjective": "Compreender a estrutura do esquema numérico e sua relação com a PDE contínua.",
                                  "commonMistakes": "Confundir notação de índices (j para espaço, n para tempo) ou esquecer a definição de r."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor a solução aproximada em modos de Fourier",
                                  "subSteps": [
                                    "Assuma uma solução plano-onda: u^n_j = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação e k o número de onda.",
                                    "Substitua esta forma no esquema numérico para obter a relação de amplificação ξ.",
                                    "Derive a equação característica: ξ = 1 + r (e^{i k Δx} - 2 + e^{-i k Δx}).",
                                    "Simplifique usando identidades trigonométricas: e^{iθ} + e^{-iθ} = 2 cos θ, resultando em ξ = 1 - 4 r sin²(θ/2), com θ = k Δx.",
                                    "Verifique para k=0 (modo constante), onde ξ deve ser 1."
                                  ],
                                  "verification": "A equação para ξ deve depender apenas de θ = k Δx e r, sem resíduos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, software simbólico como SymPy ou Mathematica.",
                                  "tips": "Use a identidade sin²(θ/2) para manter expressões compactas e reais.",
                                  "learningObjective": "Aplicar análise de Fourier para transformar o problema espacial em análise espectral.",
                                  "commonMistakes": "Esquecer o expoente n em ξ^n ou usar seno em vez de sin²(θ/2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o símbolo do operador e o fator de amplificação",
                                  "subSteps": [
                                    "Identifique o símbolo do operador diferencial: para ∂²/∂x² é -k², mas discretizado como (e^{iθ} - 2 + e^{-iθ})/Δx² = - (2 sin(θ/2)/Δx)².",
                                    "Escreva o símbolo completo do esquema: G(θ) = ξ(θ) = 1 + r * símbolo da segunda derivada.",
                                    "Calcule |G(θ)| para todos os θ ∈ [0, π], pois θ = k Δx cobre o espectro.",
                                    "Plote ou tabule |G(θ)| vs θ para visualizar o comportamento.",
                                    "Determine o máximo de |G(θ)|."
                                  ],
                                  "verification": "Para o exemplo FTCS, |ξ| = |1 - 4 r sin²(θ/2)| deve ser calculado corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/MATLAB para plotar |G(θ)|, ou papel para θ discretos.",
                                  "tips": "O pior caso é θ=π (modo oscilatório mais alto), onde sin(θ/2)=1.",
                                  "learningObjective": "Dominar o cálculo do símbolo discreto e seu módulo para análise espectral.",
                                  "commonMistakes": "Ignorar que |ξ| deve ser ≤1 para todos os modos, ou erro em sin²."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a condição de estabilidade via fator de amplificação",
                                  "subSteps": [
                                    "Exija |G(θ)| ≤ 1 + O(Δt) para todos θ, aproximando para estabilidade von Neumann.",
                                    "Para FTCS, resolva |1 - 4 r sin²(θ/2)| ≤ 1, levando a r ≤ 1/2.",
                                    "Analise numericamente: encontre r_max tal que max_θ |G(θ)| =1.",
                                    "Discuta dissipação (Re(G)<1) e dispersão (fase de G).",
                                    "Conclua com a condição CFL-like: Δt ≤ (Δx²)/(2α)."
                                  ],
                                  "verification": "A condição r ≤ 1/2 deve ser derivada e justificada para todos os modos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de |G(θ)| para diferentes r.",
                                  "tips": "Teste r=0.5: |G|≤1; r=0.6: |G|>1 em θ=π.",
                                  "learningObjective": "Interpretar |G|≤1 como critério de estabilidade incondicional ou condicional.",
                                  "commonMistakes": "Confundir estabilidade com consistência ou precisão."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a análise com simulação numérica simples",
                                  "subSteps": [
                                    "Implemente o esquema em código para r dentro e fora da condição.",
                                    "Aplique condição inicial suave e rode por vários passos de tempo.",
                                    "Observe oscilações ou blow-up para r>1/2.",
                                    "Compare com solução analítica de Fourier para poucos modos.",
                                    "Documente screenshots ou plots de erro vs tempo."
                                  ],
                                  "verification": "Simulação instável para r>1/2 confirma a análise teórica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB.",
                                  "tips": "Use N=100 pontos, T=1, α=1, e monitore norma L2.",
                                  "learningObjective": "Conectar análise teórica von Neumann com evidência computacional.",
                                  "commonMistakes": "Escolha de Δx muito grande, mascarando instabilidade."
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação do calor ∂u/∂t = ∂²u/∂x² com r=0.4: decomponha u^n_j = ξ^n e^{i k j Δx}, obtenha ξ=1-4*0.4*sin²(θ/2). Max |ξ|=1 em θ=0, min=0.36 em θ=π; |ξ|≤1 para todos θ, estável.",
                              "finalVerifications": [
                                "O fator de amplificação G(θ) foi corretamente derivado para todos os modos.",
                                "Condição de estabilidade r ≤ 1/2 foi identificada e justificada.",
                                "|G(θ)| ≤1 para θ∈[0,π] em valores de r estáveis.",
                                "Símbolo do operador discretizado corresponde ao contínuo no limite θ→0.",
                                "Simulação numérica corrobora a análise teórica.",
                                "Erros comuns como fases erradas foram evitados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ξ(θ) (100% correto).",
                                "Correta identificação do modo crítico (θ=π).",
                                "Derivação rigorosa da condição r≤1/2.",
                                "Interpretação física de dissipação e estabilidade.",
                                "Qualidade do plot |G(θ)| e simulação.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e difusão em mecânica quântica/clássica.",
                                "Computação: Implementação eficiente de solvers PDE em HPC.",
                                "Engenharia: Simulações CFD para fluxo de calor em materiais.",
                                "Estatística: Análise espectral em séries temporais."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica (difusão de temperatura), design de trocadores de calor na engenharia, ou modelagem de difusão de poluentes em fluidos, garantindo que os esquemas numéricos não amplifiquem erros numéricos artificiais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Derivar o fator de amplificação para a equação do calor",
                            "description": "Calcular explicitamente o fator de amplificação ξ para o esquema FTCS na equação u_t = α u_xx, identificando a condição de estabilidade |ξ| ≤ 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Equação do Calor e o Esquema FTCS",
                                  "subSteps": [
                                    "Escreva a equação diferencial parcial da condução de calor: ∂u/∂t = α ∂²u/∂x².",
                                    "Defina a malha espacial e temporal com passos Δx e Δt.",
                                    "Derive a discretização FTCS: u_j^{n+1} = u_j^n + r (u_{j-1}^n - 2 u_j^n + u_{j+1}^n), onde r = α Δt / Δx².",
                                    "Verifique a consistência de primeira ordem em tempo e segunda em espaço.",
                                    "Discuta brevemente limitações iniciais do esquema explícito."
                                  ],
                                  "verification": "Escreva corretamente a fórmula FTCS com o fator r definido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Lembre-se: Forward in Time (explícito), Centered in Space.",
                                    "Sempre normalize com r para generalidade."
                                  ],
                                  "learningObjective": "Dominar a discretização numérica FTCS para a equação parabólica.",
                                  "commonMistakes": [
                                    "Confundir FTCS com esquemas implícitos como BTCS.",
                                    "Esquecer o sinal negativo na laplaciana discreta.",
                                    "Usar Δt / Δx em vez de Δt / Δx²."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a Análise de Estabilidade de von Neumann",
                                  "subSteps": [
                                    "Explique o método de von Neumann: análise local via ondas planas para erros de alta frequência.",
                                    "Assuma a forma da solução perturbada: u_j^n = ξ^n e^{i β j}, onde β = k Δx é a fase angular.",
                                    "Justifique por que soluções mono-cromáticas são suficientes devido à linearidade.",
                                    "Substitua separadamente os termos u_j^n, u_{j±1}^n na equação FTCS.",
                                    "Simplifique os expoentes: e^{i β (j±1)} = e^{i β j} e^{± i β}."
                                  ],
                                  "verification": "Escreva a assunção u_j^n = ξ^n e^{i β j} e substitua um termo da equação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de identidades trigonométricas"
                                  ],
                                  "tips": [
                                    "β varia de 0 a 2π; foque em casos críticos como β=π.",
                                    "Use i para imaginário para manter notação padrão."
                                  ],
                                  "learningObjective": "Aplicar a assunção de onda plana na análise de estabilidade.",
                                  "commonMistakes": [
                                    "Esquecer o expoente n em ξ^n.",
                                    "Confundir β com k (β = k Δx).",
                                    "Não isolar ξ^n comum nos termos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Fator de Amplificação ξ",
                                  "subSteps": [
                                    "Substitua a forma de von Neumann na equação FTCS completa.",
                                    "Divida ambos os lados por ξ^n e^{i β j} para isolar ξ.",
                                    "Simplifique o termo de laplaciana: e^{-iβ} - 2 + e^{iβ} = 2(cos β - 1) = -4 sin²(β/2).",
                                    "Obtenha ξ = 1 + r [-4 sin²(β/2)] = 1 - 4 r sin²(β/2).",
                                    "Verifique para β=0: ξ=1 (modo constante preservado)."
                                  ],
                                  "verification": "Derive e escreva ξ = 1 - 4 r sin²(β/2) a partir da substituição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para trigonométricas"
                                  ],
                                  "tips": [
                                    "Use identidade cos β = 1 - 2 sin²(β/2) para simplificar.",
                                    "Teste numericamente para β=π: sin(π/2)=1, ξ=1-4r."
                                  ],
                                  "learningObjective": "Calcular explicitamente o fator de amplificação ξ(θ), com θ=β.",
                                  "commonMistakes": [
                                    "Erro no sinal: deve ser 1 - 4r sin².",
                                    "Esquecer fatorização de ξ^n.",
                                    "Confundir sin²(β/2) com sin²(β)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Condição de Estabilidade |ξ| ≤ 1",
                                  "subSteps": [
                                    "Note que ξ é real: ξ(θ) = 1 - 4 r sin²(θ/2), θ=β ∈ [0,π].",
                                    "Determine o mínimo de ξ: quando sin²=1, ξ_min = 1 - 4r.",
                                    "Exija |ξ| ≤ 1 ∀ θ: 1 ≤ 1 (sempre) e |1-4r| ≤ 1 ⇒ -1 ≤ 1-4r ≤ 1 ⇒ r ≤ 1/2.",
                                    "Discuta implicações: para r > 1/2, oscilações não físicas em altas frequências.",
                                    "Opcional: plote |ξ(θ)| para r=0.4 e r=0.6."
                                  ],
                                  "verification": "Escreva a condição r ≤ 1/2 e justifique com ξ_min.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python/Matlab para plot (opcional)"
                                  ],
                                  "tips": [
                                    "Crítico: estabilidade para TODAS as frequências θ.",
                                    "r ≤ 1/2 é necessário e suficiente para FTCS."
                                  ],
                                  "learningObjective": "Identificar e derivar a condição de estabilidade |ξ| ≤ 1.",
                                  "commonMistakes": [
                                    "Ignorar que ξ pode ser < -1 para r>1/2.",
                                    "Confundir com consistência (ordem).",
                                    "Pensar que r≤1 é suficiente."
                                  ]
                                }
                              ],
                              "practicalExample": "Para r = 0.4 e θ = π (alta frequência), ξ = 1 - 4*0.4*(1) = -0.6, |ξ|=0.6 ≤1 (estável). Para r=0.6, ξ=1-2.4=-1.4, |ξ|=1.4 >1 (instável). Implemente em Python: plot ξ(θ) para verificar.",
                              "finalVerifications": [
                                "Escreve corretamente ξ = 1 - 4 r sin²(θ/2).",
                                "Deriva a condição de estabilidade r ≤ 1/2.",
                                "Explica o papel das ondas de alta frequência (θ=π).",
                                "Identifica FTCS como condicionalmente estável.",
                                "Aplica a análise a um r específico e verifica |ξ|.",
                                "Discute implicações para escolha de Δt e Δx."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de ξ (fórmula exata).",
                                "Correta simplificação trigonométrica e isolamento de ξ.",
                                "Análise completa de |ξ| ≤1 para todos os modos.",
                                "Identificação clara da condição r ≤ 1/2.",
                                "Uso apropriado de notação von Neumann.",
                                "Explicação qualitativa de instabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e parabólicas.",
                                "Engenharia Computacional: CFD e simulações numéricas.",
                                "Programação: Implementação e teste de esquemas em Python/MATLAB.",
                                "Matemática Aplicada: Análise de Fourier e estabilidade linear."
                              ],
                              "realWorldApplication": "Na simulação numérica de transferência de calor em engenharia (ex: previsão de temperatura em painéis solares ou soldagem de metais), derivar ξ garante escolha de Δt/Δx para evitar oscilações artificiais, otimizando precisão e eficiência computacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Analisar dissipação e dispersão",
                            "description": "Avaliar os conceitos de dissipação (decaimento de amplitudes) e dispersão (fases erradas) na análise de von Neumann para esquemas parabólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise de von Neumann",
                                  "subSteps": [
                                    "Recordar a forma de Fourier assumida para a solução: u_j^n = ξ^n e^{i k j Δx}.",
                                    "Derivar a equação de amplificação ξ a partir do esquema numérico para equações parabólicas.",
                                    "Calcular o símbolo de amplificação |ξ| e a fase arg(ξ).",
                                    "Identificar condições de estabilidade via |ξ| ≤ 1.",
                                    "Discutir o papel do número de Courant r = α Δt / (Δx)^2."
                                  ],
                                  "verification": "Derivar corretamente ξ para o esquema forward Euler e verificar |ξ| ≤ 1 para r ≤ 1/2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), papel e lápis, calculadora simbólica.",
                                  "tips": "Use somatórios geométricos para simplificar e^{i k j Δx} termos.",
                                  "learningObjective": "Compreender a base da análise local de Fourier para estabilidade.",
                                  "commonMistakes": "Confundir ξ com o fator de amortecimento global; ignorar termos imaginários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender e Calcular Dissipação",
                                  "subSteps": [
                                    "Definir dissipação como decaimento artificial de amplitudes: |ξ| < 1 para modos de alta frequência.",
                                    "Derivar |ξ|^2 = 1 - 2(1 - cos(θ)) r (1 - cos(θ)) para esquema explícito, onde θ = k Δx.",
                                    "Analisar comportamento: para θ pequeno (baixas freq.), |ξ| ≈ 1; para θ ≈ π (alta freq.), |ξ| < 1.",
                                    "Comparar com solução exata, onde |ξ_exata| = e^{-α k^2 Δt} ≈ 1 - α k^2 Δt.",
                                    "Plotar |ξ| vs θ para diferentes r."
                                  ],
                                  "verification": "Calcular |ξ| para θ = π/2 e r=0.5, confirmando valor <1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Matlab/Python/Mathematica), exemplos de esquemas parabólicos.",
                                  "tips": "Use aproximações trigonométricas: 1 - cos(θ) ≈ θ^2/2 para análise assintótica.",
                                  "learningObjective": "Avaliar numericamente o decaimento de amplitudes e sua relação com precisão.",
                                  "commonMistakes": "Esquecer o quadrado em |ξ|^2; confundir com instabilidade (|ξ|>1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender e Calcular Dispersão",
                                  "subSteps": [
                                    "Definir dispersão como erro de fase: arg(ξ) ≠ -α k^2 Δt (fase errada leva a velocidades de fase incorretas).",
                                    "Derivar arg(ξ) ≈ - r θ^2 + O(θ^4) para esquemas parabólicos.",
                                    "Comparar velocidade de fase numérica c_num = arg(ξ)/(k Δt) com exata c_exata = α k.",
                                    "Analisar para esquemas: explícito dispersivo em altas freq., Crank-Nicolson menos dispersivo.",
                                    "Plotar arg(ξ)/Δt vs k para visualizar erros de dispersão."
                                  ],
                                  "verification": "Verificar que para θ pequeno, arg(ξ) ≈ -r θ^2, igual à exata.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python para plots de fase (numpy, matplotlib), notas de aula.",
                                  "tips": "Expanda em série de Taylor para θ pequeno para isolar termos dispersivos.",
                                  "learningObjective": "Quantificar erros de fase e sua dependência em comprimentos de onda.",
                                  "commonMistakes": "Confundir dispersão com dissipação; ignorar normalização por Δt."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Comparar Dissipação e Dispersão em Esquemas",
                                  "subSteps": [
                                    "Analisar esquema Crank-Nicolson: |ξ| ≈ 1 (não dissipativo), mas dispersivo.",
                                    "Comparar dissipação vs dispersão: dissipação controla oscilações altas, dispersão afeta propagação.",
                                    "Escolher r ótimo minimizando ambos erros.",
                                    "Simular numericamente um problema de difusão e observar artefatos.",
                                    "Discutir trade-offs em escolha de esquemas."
                                  ],
                                  "verification": "Produzir gráfico comparando |ξ|-1 e arg(ξ)+αk^2Δt para dois esquemas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código de simulação (Python com numpy/scipy), problema teste (equação do calor 1D).",
                                  "tips": "Use log-plot para |ξ|-1 para visualizar decaimento pequeno.",
                                  "learningObjective": "Integrar conceitos para avaliar qualidade de esquemas numéricos.",
                                  "commonMistakes": "Atribuir dispersão a instabilidade; superestimar dissipação em baixas freq."
                                }
                              ],
                              "practicalExample": "Para o esquema explícito na equação do calor u_t = α u_xx, com r=0.4, calcule |ξ(θ=π)| ≈ 0.686 (dissipação forte em modo 2Δx) e arg(ξ(θ=π/2))/Δt ≈ -0.98 α (k=π/(2Δx))^2, mostrando dispersão moderada; simule u(x,0)=sen(πx) e observe suavização artificial.",
                              "finalVerifications": [
                                "Derivação correta de |ξ| e arg(ξ) para esquema dado.",
                                "Plots precisos de dissipação e dispersão vs θ.",
                                "Identificação de regimes onde dissipação domina (θ~π).",
                                "Comparação quantitativa com solução exata.",
                                "Explicação verbal de impactos em simulações reais.",
                                "Seleção de r minimizando erros combinados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (90% correto).",
                                "Interpretação física correta de dissipação/dispersão.",
                                "Qualidade de plots e análises gráficas.",
                                "Identificação de erros comuns em esquemas.",
                                "Aplicação a exemplo numérico com resultados coerentes.",
                                "Clareza na discussão de trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e amortecimento de ondas.",
                                "Computação: Implementação de FFT para análise de erros em simulações.",
                                "Engenharia: Otimização de grades em CFD (dinâmica de fluidos computacional).",
                                "Estatística: Análise de erros numéricos como variância em MC simulações."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, dissipação numérica previne oscilações em previsões de temperatura, enquanto controle de dispersão garante propagação precisa de frentes frias; usado em software como WRF para modelagem climática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Estabilidade de Esquemas Explícitos e Implícitos",
                        "description": "Critérios de estabilidade para esquemas explícitos como FTCS e implícitos como BTCS, incluindo introdução aos métodos ADI.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Determinar estabilidade do esquema FTCS explícito",
                            "description": "Derivar e aplicar a condição de estabilidade r = α Δt / Δx² ≤ 1/2 para o esquema forward-time central-space na equação parabólica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema FTCS e a equação parabólica",
                                  "subSteps": [
                                    "Lembre-se da equação de calor unidimensional: ∂u/∂t = α ∂²u/∂x².",
                                    "Escreva a discretização FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = α Δt / Δx².",
                                    "Identifique os termos forward em tempo e central em espaço.",
                                    "Desenhe um stencil espacial para visualizar as diferenças finitas.",
                                    "Confirme as aproximações de ordem: O(Δt) em tempo e O(Δx²) em espaço."
                                  ],
                                  "verification": "Escreva corretamente a fórmula do esquema FTCS e identifique os erros de truncamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, livro de análise numérica (ex: LeVeque ou Burden).",
                                  "tips": "Use notação consistente para índices j (espaço) e n (tempo).",
                                  "learningObjective": "Compreender a formulação exata do esquema FTCS para equações parabólicas.",
                                  "commonMistakes": "Confundir forward-time com backward-time ou central com upwind."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise de estabilidade de von Neumann",
                                  "subSteps": [
                                    "Assuma solução de Fourier: u_j^n = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação.",
                                    "Substitua no esquema FTCS para obter ξ = 1 + r (e^{i k Δx} - 2 + e^{-i k Δx}).",
                                    "Simplifique usando identidade trigonométrica: ξ = 1 - 4 r sin²(θ/2), com θ = k Δx.",
                                    "Determine o módulo |ξ| ≤ 1 para todo θ ∈ [0, π].",
                                    "Analise o pior caso em θ = π (sin²(θ/2) = 1)."
                                  ],
                                  "verification": "Derive a expressão de |ξ| e mostre que |ξ| > 1 leva a instabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora científica, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Memorize que sin²(θ/2) varia de 0 a 1; foque no máximo para estabilidade.",
                                  "learningObjective": "Aplicar método de von Neumann para analisar amplificação de modos de Fourier.",
                                  "commonMistakes": "Esquecer o módulo |ξ| ou usar aproximação errada para o laplaciano discreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a condição de estabilidade r ≤ 1/2",
                                  "subSteps": [
                                    "Do |ξ| = |1 - 4 r sin²(θ/2)| ≤ 1, exija 1 - 4 r ≥ -1 para sin²=1.",
                                    "Resolva -1 ≤ 1 - 4 r ≤ 1, resultando em r ≤ 1/2 (parte negativa domina).",
                                    "Verifique para sin²=0: ξ=1 (estável).",
                                    "Confirme que para r > 1/2, |ξ| > 1 em altas frequências (oscilações 2Δx).",
                                    "Discuta implicações: restrição CFL-like para parabólicas."
                                  ],
                                  "verification": "Escreva a desigualdade r ≤ 1/2 e prove matematicamente para todo θ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado para gráficos de |ξ| vs θ.",
                                  "tips": "Plote |ξ(r,θ)| para r=0.4 (estável) vs r=0.6 (instável).",
                                  "learningObjective": "Derivar analiticamente a condição CFL r ≤ 1/2 para FTCS.",
                                  "commonMistakes": "Ignorar o caso sin²=1 ou derivar r ≤ 1 em vez de 1/2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a condição em um exemplo numérico",
                                  "subSteps": [
                                    "Considere α=1, L=1, Δx=0.1 (N=10 pontos), escolha Δt tal que r=0.4 ≤0.5.",
                                    "Calcule Δt_max = 0.5 Δx² / α = 0.0005.",
                                    "Simule 100 passos com r=0.4 (estável) e r=0.6 (instável) em código simples.",
                                    "Compare soluções numéricas com exata (ex: u(x,t)=e^{-π² t} sin(π x)).",
                                    "Analise erro L2 e detecte blow-up para r>1/2."
                                  ],
                                  "verification": "Execute simulação e confirme estabilidade apenas para r≤1/2.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB com NumPy/Matlab para simulação 1D.",
                                  "tips": "Use condições de contorno periódicas ou Dirichlet para simplicidade.",
                                  "learningObjective": "Aplicar condição de estabilidade em simulações práticas.",
                                  "commonMistakes": "Escolha Δx muito pequeno sem ajustar Δt, levando a r>>1/2."
                                }
                              ],
                              "practicalExample": "Para a equação de calor ∂u/∂t = ∂²u/∂x² em [0,1] com u(0,t)=u(1,t)=0 e u(x,0)=sin(πx), use Δx=0.1. Com α=1, Δt=0.0004 dá r=0.4 (estável, solução converge); Δt=0.0006 dá r=0.6 (instável, oscilações crescem).",
                              "finalVerifications": [
                                "Deriva corretamente ξ = 1 - 4r sin²(θ/2).",
                                "Prova |ξ| ≤ 1 iff r ≤ 1/2.",
                                "Identifica instabilidade para r > 1/2 em altas frequências.",
                                "Aplica condição em exemplo numérico com Δt/Δx².",
                                "Compara simulações estável vs instável.",
                                "Explica impacto em precisão e convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de von Neumann (90% correto).",
                                "Correta identificação de r ≤ 1/2 como condição necessária e suficiente.",
                                "Implementação numérica sem erros de programação.",
                                "Análise qualitativa/quantitativa de resultados (gráficos de erro).",
                                "Explicação clara de erros comuns e limitações do FTCS.",
                                "Conexão com esquemas implícitos (ex: incondicionalmente estável)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica ou molecular.",
                                "Computação: Implementação de métodos numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD para transferência de calor.",
                                "Estatística: Análise de estabilidade em processos estocásticos.",
                                "Matemática Aplicada: Análise de erros em PDEs."
                              ],
                              "realWorldApplication": "Em simulações de engenharia térmica, como previsão de distribuição de calor em painéis solares ou fuselagem de aviões, a condição r ≤ 1/2 garante simulações estáveis sem oscilações artificiais, evitando erros em designs críticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Analisar estabilidade de esquemas implícitos",
                            "description": "Mostrar que o esquema BTCS backward-time central-space é incondicionalmente estável para equações parabólicas usando análise de von Neumann.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da equação parabólica e esquema BTCS",
                                  "subSteps": [
                                    "Lembre a forma geral da equação parabólica: ∂u/∂t = α ∂²u/∂x².",
                                    "Descreva o esquema BTCS: u^{n+1}_j - u^n_j = r (u^{n+1}_{j-1} - 2u^{n+1}_j + u^{n+1}_{j+1}), onde r = α Δt / Δx².",
                                    "Identifique que BTCS é implícito pois envolve u^{n+1} no lado direito.",
                                    "Esboce a grade espacial e temporal para visualização.",
                                    "Anote os parâmetros: Δt, Δx, r."
                                  ],
                                  "verification": "Escreva a equação BTCS corretamente em um papel ou software de anotações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e caneta, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Use notação consistente para evitar confusões entre índices j e n.",
                                  "learningObjective": "Compreender a formulação exata do esquema BTCS para equações parabólicas.",
                                  "commonMistakes": "Confundir BTCS (implícito) com FTCS (explícito); esquecer o fator r no lado direito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e aplicar análise de von Neumann",
                                  "subSteps": [
                                    "Explique o método de von Neumann: assumir solução u^n_j = ξ^n e^{i k j Δx}, onde ξ é o fator de amplificação.",
                                    "Substitua na equação BTCS para obter ξ.",
                                    "Derive a equação para ξ: ξ - 1 = r (e^{-iθ} - 2 + e^{iθ}) ξ, onde θ = k Δx.",
                                    "Simplifique usando identidade trigonométrica: e^{iθ} + e^{-iθ} - 2 = -4 sin²(θ/2).",
                                    "Resolva para ξ: ξ = 1 / (1 + 4 r sin²(θ/2))."
                                  ],
                                  "verification": "Derive a expressão exata de ξ e verifique para θ=0 (ξ=1).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora gráfica (TI-84 ou similar), software como MATLAB para plotar.",
                                  "tips": "Sempre normalize a solução com |ξ| para estabilidade; pratique identidades de Euler.",
                                  "learningObjective": "Dominar a substituição Fourier na análise de von Neumann para esquemas implícitos.",
                                  "commonMistakes": "Esquecer de dividir por ξ no lado direito; erro no sinal da diferença finita central."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o módulo do fator de amplificação",
                                  "subSteps": [
                                    "Calcule |ξ| = |1 / (1 + 4 r sin²(θ/2))|.",
                                    "Note que sin²(θ/2) ∈ [0,1], então denominador ≥1 para r>0.",
                                    "Mostre que |ξ| ≤ 1 para todo θ ∈ [0,π] e qualquer r > 0.",
                                    "Compare com esquemas explícitos (ex: FTCS requer r ≤ 1/2).",
                                    "Plote |ξ| vs θ para diferentes r para visualização."
                                  ],
                                  "verification": "Prove matematicamente que |ξ| ≤ 1 independentemente de r e θ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB com numpy/matplotlib), tabela de valores de sin².",
                                  "tips": "Use desigualdade triangular ou propriedades de módulo para rigor.",
                                  "learningObjective": "Demonstrar estabilidade incondicional via |ξ| ≤ 1 ∀ k, r.",
                                  "commonMistakes": "Achar que estabilidade depende de r; ignorar θ=π (pior caso)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e verificar estabilidade incondicional",
                                  "subSteps": [
                                    "Resuma: BTCS é incondicionalmente estável pois |ξ| < 1 exceto em θ=0 onde =1.",
                                    "Discuta ausência de oscilações ou amplificação.",
                                    "Compare com esquemas explícitos para contexto.",
                                    "Teste numericamente com um exemplo simples.",
                                    "Documente a prova completa."
                                  ],
                                  "verification": "Escreva um parágrafo conclusivo com a prova e numere os passos chave.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto (LaTeX para relatório), código simples em Python para simulação.",
                                  "tips": "Sempre mencione 'incondicionalmente estável' explicitamente na conclusão.",
                                  "learningObjective": "Sintetizar a análise para afirmar estabilidade de esquemas implícitos.",
                                  "commonMistakes": "Confundir estabilidade com precisão; omitir casos extremos."
                                }
                              ],
                              "practicalExample": "Para a equação do calor u_t = u_xx em [0,1] com u(0,t)=u(1,t)=0, aplique BTCS com r=10 (grande, instável para explícito). Simule 100 passos: solução converge sem oscilações, provando estabilidade.",
                              "finalVerifications": [
                                "Derivação correta de ξ = 1 / (1 + 4 r sin²(θ/2)).",
                                "Prova que |ξ| ≤ 1 para todo r > 0 e θ.",
                                "Plot ou tabela mostrando |ξ| ≤ 1.",
                                "Comparação textual com FTCS.",
                                "Conclusão escrita afirmando estabilidade incondicional.",
                                "Exemplo numérico sem amplificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator de amplificação (100% correto).",
                                "Rigor matemático na prova de |ξ| ≤ 1 (sem lacunas).",
                                "Uso correto de identidades trigonométricas.",
                                "Análise de casos extremos (θ=0, π).",
                                "Clareza na explicação e visualizações.",
                                "Conexão com contexto de equações parabólicas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de estabilidade em simulações PDE.",
                                "Computação: Implementação de solvers implícitos em Python/MATLAB para CFD.",
                                "Engenharia: Estabilidade em simulações numéricas de fluxo de calor em materiais.",
                                "Matemática Aplicada: Extensão a esquemas multi-dimensionais."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes ou em engenharia aeroespacial para modelar transferência de calor em painéis, onde Δt grandes são necessários para eficiência computacional sem instabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Descrever métodos ADI e sua estabilidade",
                            "description": "Explicar o método Alternating Direction Implicit (ADI) para equações parabólicas bidimensionais e verificar sua estabilidade incondicional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema das Equações Parabólicas Bidimensionais",
                                  "subSteps": [
                                    "Revise a equação de calor 2D: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²).",
                                    "Discuta limitações de métodos explícitos e implícitos unidimensionais em 2D, como custo computacional O(N²).",
                                    "Identifique a necessidade de métodos que separem direções x e y para eficiência.",
                                    "Estude condições de contorno e inicial típicas para problemas parabólicos 2D.",
                                    "Compare estabilidade de esquemas FTCS explícito vs. implícito em 2D."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre métodos 1D e 2D, incluindo restrições de estabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula sobre PDEs parabólicas, software Python/MATLAB para visualização"
                                  ],
                                  "tips": "Use diagramas para visualizar a grade 2D e propagação do calor.",
                                  "learningObjective": "Compreender o contexto e motivação para métodos ADI em problemas 2D.",
                                  "commonMistakes": [
                                    "Confundir parabólicas com elípticas/hiperbólicas",
                                    "Ignorar o custo O(N³) de inversões implícitas full 2D"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Método Alternating Direction Implicit (ADI)",
                                  "subSteps": [
                                    "Descreva o esquema ADI de Peaceman-Rachford: passo 1 implícito em x e explícito em y; passo 2 implícito em y e explícito em x.",
                                    "Escreva as equações discretas: para Δt/2, resolva tridiagonal em x; depois em y.",
                                    "Explique a alternância de direções ao longo dos ciclos temporais.",
                                    "Implemente pseudocódigo para um ciclo completo de ADI.",
                                    "Discuta variantes como Douglas-Rachford para maior precisão."
                                  ],
                                  "verification": "Escreva o esquema matemático ADI para u^{n+1/2} e u^{n+1} em uma grade 2D.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Paper original de Peaceman-Rachford (1955), MATLAB/Python para codificar esquema simples"
                                  ],
                                  "tips": "Pense em ADI como 'meio-implícito' alternado para reduzir sistemas lineares a 1D.",
                                  "learningObjective": "Dominar a formulação algébrica e o fluxo do algoritmo ADI.",
                                  "commonMistakes": [
                                    "Esquecer fator 1/2 em Δt nos passos intermediários",
                                    "Não alternar corretamente as direções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Estabilidade do Método ADI",
                                  "subSteps": [
                                    "Aplique análise de von Neumann: assuma solução plano u = ρ^n e^{i(kx x + ky y)}.",
                                    "Derive o símbolo de amplificação para o esquema ADI completo.",
                                    "Mostre que |ρ| ≤ 1 para qualquer r = α Δt / Δx² > 0, provando estabilidade incondicional.",
                                    "Compare com esquema explícito (estável só para r ≤ 1/4 em 2D).",
                                    "Verifique consistência e ordem de truncamento O(Δt² + Δx²)."
                                  ],
                                  "verification": "Calcule e plote |ρ| vs. r e ângulos de onda para confirmar |ρ| ≤ 1.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Folha de cálculo ou SymPy para símbolos",
                                    "Referência: livro de Gustafsson et al. sobre estabilidade de PDEs"
                                  ],
                                  "tips": "Use aproximações de Fourier separáveis para simplificar o cálculo bidimensional.",
                                  "learningObjective": "Provar matematicamente a estabilidade incondicional do ADI.",
                                  "commonMistakes": [
                                    "Erro no fator seno² nas diferenças finitas",
                                    "Confundir estabilidade com convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Verificar Numericamente o ADI",
                                  "subSteps": [
                                    "Codifique ADI em Python/MATLAB para equação de calor 2D com condições Dirichlet.",
                                    "Teste com solução exata conhecida (ex: u(x,y,t) = exp(-π² α t) sin(π x) sin(π y)).",
                                    "Calcule erros L2 e verifique independência de malha/tempo.",
                                    "Analise estabilidade numérica variando r >> 1.",
                                    "Visualize evolução temporal com heatmaps."
                                  ],
                                  "verification": "Gere gráfico de erro vs. r mostrando estabilidade incondicional.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib, template de código para ADI"
                                  ],
                                  "tips": "Use solvers tridiagonais eficientes (Thomas algorithm) para cada direção.",
                                  "learningObjective": "Aplicar ADI computacionalmente e validar teoria.",
                                  "commonMistakes": [
                                    "Índices errados na grade 2D",
                                    "Não normalizar erros adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de calor 2D ∂u/∂t = (∂²u/∂x² + ∂²u/∂y²) em [0,1]x[0,1] com u=0 nas bordas e u(x,y,0)=sin(πx)sin(πy), usando ADI com Δx=0.1, r=10 (instável para explícito). Compare solução numérica com exata u=exp(-2π²t)sin(πx)sin(πy) em t=0.1.",
                              "finalVerifications": [
                                "Escreva corretamente o esquema ADI de Peaceman-Rachford.",
                                "Prove |ρ| ≤ 1 para qualquer r via análise de von Neumann.",
                                "Implemente código funcional que roda sem crash para r=100.",
                                "Interprete gráficos de erro mostrando estabilidade incondicional.",
                                "Explique por que ADI é eficiente O(N) por passo vs. O(N²) implícito full.",
                                "Discuta limitações como precisão de segunda ordem apenas para certos operadores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do esquema ADI (20%)",
                                "Correção na prova de estabilidade incondicional (30%)",
                                "Qualidade da implementação numérica e gráficos (25%)",
                                "Explicação clara de motivação e vantagens (15%)",
                                "Identificação de erros comuns e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica em placas 2D.",
                                "Computação Científica: Solvers lineares tridiagonais e programação numérica.",
                                "Engenharia: Simulações de fluxo de calor em materiais compostos.",
                                "Matemática Aplicada: Análise de erros em métodos de diferenças finitas."
                              ],
                              "realWorldApplication": "O método ADI é usado em simulações de difusão em reservatórios de petróleo (modelagem de fluxo multifásico), previsão meteorológica (equações de difusão atmosférica 2D), e engenharia térmica (análise de dissipação de calor em chips de computadores, permitindo passos de tempo grandes para eficiência computacional em grades finas)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Métodos ADI para Equações Parabólicas",
                    "description": "Métodos de Direção Alternada Implícita (ADI) para solução eficiente em múltiplas dimensões.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Fundamentos dos Métodos ADI",
                        "description": "Introdução aos princípios básicos dos métodos de Direção Alternada Implícita (ADI), destacando sua eficiência para resolver equações parabólicas em duas ou mais dimensões espaciais, superando limitações de métodos implícitos fully coupled.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar o problema modelo parabólico",
                            "description": "Reconhecer e formular a equação do calor bidimensional como exemplo padrão para aplicação de métodos ADI, incluindo condições de contorno de Dirichlet e inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação diferencial parcial parabólica básica",
                                  "subSteps": [
                                    "Estude a forma geral da equação parabólica: ∂u/∂t = α (∂²u/∂x² + ∂²u/∂y²).",
                                    "Identifique o termo temporal ∂u/∂t como característica parabólica.",
                                    "Compare com equações elípticas e hiperbólicas para diferenciar.",
                                    "Derive a equação do calor a partir do princípio de conservação de energia.",
                                    "Resolva um exemplo unidimensional simples para intuição."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que a equação do calor é parabólica e forneça sua forma bidimensional.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), caderno, calculadora"
                                  ],
                                  "tips": "Visualize a propagação de calor como difusão para fixar o conceito.",
                                  "learningObjective": "Reconhecer a estrutura matemática da equação parabólica bidimensional.",
                                  "commonMistakes": [
                                    "Confundir com equação de onda (hiperbólica), ignorar coeficiente de difusão α"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar condições de contorno de Dirichlet",
                                  "subSteps": [
                                    "Defina condições de Dirichlet: u(x,y,t) = g(x,y) nas fronteiras do domínio.",
                                    "Desenhe um domínio retangular Ω = [0,a] x [0,b] e especifique g nas bordas.",
                                    "Discuta por que Dirichlet fixa valores diretamente nas fronteiras.",
                                    "Esboce um exemplo: placa com bordas mantidas a 0°C exceto uma borda a 100°C.",
                                    "Verifique compatibilidade com condições iniciais nas bordas."
                                  ],
                                  "verification": "Escreva as condições de Dirichlet para um domínio específico e identifique-as em um problema dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel milimetrado, software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Sempre especifique o domínio Ω claramente antes de definir contornos.",
                                  "learningObjective": "Formular corretamente condições de contorno Dirichlet para problemas parabólicos.",
                                  "commonMistakes": [
                                    "Confundir com Neumann (fluxo), não especificar para todas as bordas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e integrar condições iniciais",
                                  "subSteps": [
                                    "Estabeleça a condição inicial: u(x,y,0) = u₀(x,y) para t=0 em Ω.",
                                    "Escolha u₀ compatível com contornos de Dirichlet (u₀ = g nas bordas).",
                                    "Exemplo: u₀(x,y) = sen(πx/a) sen(πy/b) para uma placa inicial quente no centro.",
                                    "Discuta o papel da condição inicial na evolução temporal.",
                                    "Integre com passos anteriores para formar o problema inicial-contorno."
                                  ],
                                  "verification": "Forneça u₀ para um problema e verifique compatibilidade com Dirichlet.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de problemas de livros, Python para plotar u₀"
                                  ],
                                  "tips": "Garanta suavidade em u₀ para evitar oscilações numéricas futuras.",
                                  "learningObjective": "Incorporar condições iniciais ao problema modelo parabólico.",
                                  "commonMistakes": [
                                    "Ignorar compatibilidade nas bordas, escolher u₀ incompatível"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e identificar o problema modelo completo para ADI",
                                  "subSteps": [
                                    "Combine PDE, Dirichlet e inicial: problema modelo para métodos ADI.",
                                    "Escreva explicitamente: ∂u/∂t = α Δu em Ω x (0,T), u=g nas ∂Ω, u(0)=u₀.",
                                    "Reconheça este como 'padrão' para ADI (Alternating Direction Implicit).",
                                    "Compare com variações (ex: fontes, Neumann) para destacar o modelo puro.",
                                    "Teste identificação em problemas propostos."
                                  ],
                                  "verification": "Formule o problema modelo a partir de uma descrição verbal e confirme se é adequado para ADI.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resumo de notas dos passos anteriores, exercícios de identificação"
                                  ],
                                  "tips": "Memorize a tríade: PDE parabólica + Dirichlet + inicial como assinatura do modelo.",
                                  "learningObjective": "Identificar e formular precisamente o problema modelo parabólico padrão.",
                                  "commonMistakes": [
                                    "Omitir qualquer componente, confundir com problemas estacionários"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma placa metálica retangular de 1m x 0.5m inicialmente a 20°C no centro e 0°C nas bordas. Formule: ∂u/∂t = 0.1 (∂²u/∂x² + ∂²u/∂y²) em [0,1]x[0,0.5]x(0,10), u=0 nas bordas, u(x,y,0)=20 sen(πx) sen(2πy). Este é o modelo padrão para ADI.",
                              "finalVerifications": [
                                "Escreva corretamente a PDE bidimensional do calor.",
                                "Defina condições Dirichlet para todas as bordas de um retângulo.",
                                "Forneça condição inicial compatível.",
                                "Identifique se um problema dado é o modelo padrão para ADI.",
                                "Explique por que este setup é ideal para métodos ADI.",
                                "Diferencie de problemas com fontes ou Neumann."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da PDE (coeficientes corretos).",
                                "Correta especificação e compatibilidade das condições de contorno.",
                                "Integração coerente da condição inicial.",
                                "Capacidade de reconhecimento em contextos variados.",
                                "Clareza na justificativa para uso em ADI.",
                                "Ausência de erros comuns como omissões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e conservação de energia.",
                                "Engenharia: Simulações em CFD (Computational Fluid Dynamics) para calor.",
                                "Computação: Preparação para implementação numérica em Python/MATLAB.",
                                "Matemática Aplicada: Ligação com séries de Fourier para soluções analíticas."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em painéis solares ou chips eletrônicos para evitar superaquecimento, usando ADI para soluções numéricas eficientes em grids 2D."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Explicar a decomposição direcional",
                            "description": "Descrever como o método ADI divide o operador diferencial em passos alternados ao longo de cada direção espacial, reduzindo a solução de sistemas lineares tridimensionais a bidimensionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o operador diferencial em equações parabólicas multidimensionais",
                                  "subSteps": [
                                    "Identifique a forma geral de uma equação parabólica em 3D: ∂u/∂t = Δu, onde Δ é o laplaciano em x, y, z.",
                                    "Defina os operadores direcionais: L_x = ∂²/∂x², L_y = ∂²/∂y², L_z = ∂²/∂z², de modo que Δ = L_x + L_y + L_z.",
                                    "Explique a dificuldade computacional: resolver implicitamente em 3D requer sistemas lineares de tamanho N³.",
                                    "Discuta a discretização espacial usando diferenças finitas para cada direção.",
                                    "Esboce a matriz tridiagonal resultante para uma direção única."
                                  ],
                                  "verification": "Escreva a decomposição Δ = L_x + L_y + L_z e identifique o tamanho do sistema em 3D.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Papel e lápis",
                                    "Grade 3D simples desenhada"
                                  ],
                                  "tips": "Visualize o laplaciano como soma de contribuições independentes por direção para intuitividade.",
                                  "learningObjective": "Entender a estrutura aditiva do operador diferencial parabólico.",
                                  "commonMistakes": [
                                    "Confundir laplaciano com gradiente",
                                    "Ignorar a dimensionalidade na contagem de graus de liberdade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de decomposição aditiva e aproximação temporal",
                                  "subSteps": [
                                    "Lembre a solução exata via semigrupo: u^{n+1} = exp(Δ Δt) u^n ≈ (I + Δ Δt) u^n (esquema explícito).",
                                    "Apresente a fatorização de Peaceman-Rachford para 2D: (I + (Δt/2) L_y)(I + (Δt/2) L_x) ≈ exp(Δ Δt).",
                                    "Estenda para 3D: fatorize em três termos (I + (Δt/2) L_z)(I + (Δt/2) L_y)(I + (Δt/2) L_x).",
                                    "Justifique a aproximação via teorema de Trotter: erro O(Δt³) para produtos alternados.",
                                    "Derive o erro de truncamento local da fatorização."
                                  ],
                                  "verification": "Escreva a fatorização ADI para 3D e calcule o erro de ordem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Cálculos em papel",
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Referência: Douglas-Gunn para 3D"
                                  ],
                                  "tips": "Use notação matricial para clareza: A_x = I + (Δt/2) L_x^h (discretizado).",
                                  "learningObjective": "Dominar a decomposição temporal via produtos directionais.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 nos termos implícitos",
                                    "Confundir ordem de fatorização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever os passos alternados da decomposição direcional",
                                  "subSteps": [
                                    "Passo 1: Resolver implicitamente em x: (I + (Δt/2) L_x) u* = u^n (sistema 1D por linha yz).",
                                    "Passo 2: Resolver implicitamente em y: (I + (Δt/2) L_y) u** = u* (sistema 1D por linha xz).",
                                    "Passo 3: Resolver implicitamente em z: (I + (Δt/2) L_z) u^{n+1} = u** (sistema 1D por linha xy).",
                                    "Explique a alternância: no próximo timestep, inverta a ordem para simetria.",
                                    "Mostre que cada passo resolve um sistema bidimensional efetivamente via sweeps 1D."
                                  ],
                                  "verification": "Simule um ciclo completo em uma grade 3x3x3 e verifique consistência com Crank-Nicolson.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Grade numérica pequena (ex: 5x5x5)",
                                    "Python/MATLAB para protótipo",
                                    "Stencil de diferenças finitas"
                                  ],
                                  "tips": "Pense em 'sweeps': cada direção é tratada como Thomas algorithm em 1D.",
                                  "learningObjective": "Detalhar o algoritmo iterativo da decomposição direcional.",
                                  "commonMistakes": [
                                    "Resolver explicitamente em vez de implicitamente",
                                    "Não alternar ordens entre timesteps"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a redução de dimensionalidade e benefícios",
                                  "subSteps": [
                                    "Compare custo: full 3D implícito O(N³) vs ADI O(3 N³ / N) = O(N²) por timestep.",
                                    "Discuta estabilidade: condicionalmente estável sem restrição CFL severa.",
                                    "Verifique consistência: limite Δt→0 e h→0 recupera a equação original.",
                                    "Aborde generalizações: pesos não-uniformes ou operadores não-simétricos.",
                                    "Implemente um teste numérico simples para validar."
                                  ],
                                  "verification": "Calcule o custo computacional para N=100 e compare com métodos diretos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha para contagem de FLOPs",
                                    "Código MATLAB para benchmark",
                                    "Gráficos de erro"
                                  ],
                                  "tips": "Enfatize que ADI transforma 3D em sequências de 1D tridiagonais.",
                                  "learningObjective": "Avaliar eficiência e propriedades numéricas da decomposição.",
                                  "commonMistakes": [
                                    "Superestimar custo (esquecer separabilidade)",
                                    "Ignorar necessidade de fatorização LU por direção"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de calor 3D u_t = Δu em cubo unitário com u=0 na fronteira. Discretize h=1/10, Δt=0.01. No timestep 1: resolva (I + 0.005 L_x^h) u* = u^0 (1000 solves 1D de tamanho 10), então em y, então em z. Compare com solução explícita para erro <1%.",
                              "finalVerifications": [
                                "Decompor corretamente Δ em L_x + L_y + L_z.",
                                "Escrever o esquema ADI completo para 3D com fator 1/2.",
                                "Identificar redução de O(N³) para O(N²).",
                                "Explicar alternância de direções.",
                                "Calcular erro de truncamento O(Δt³).",
                                "Simular um passo em grade pequena sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição do operador (90% correto).",
                                "Clareza na descrição dos três passos directionais.",
                                "Correta análise de custo computacional.",
                                "Identificação de estabilidade incondicional.",
                                "Uso correto de notação matemática.",
                                "Exemplo prático viável e verificável."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão em fluidos 3D (equações de Navier-Stokes).",
                                "Computação: Algoritmos paralelizáveis (MPI por direção).",
                                "Engenharia: Simulações CFD em reservatórios petrolíferos.",
                                "Estatística: Métodos MCMC com decomposições semelhantes."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, ADI acelera previsões de difusão de poluentes em 3D, reduzindo tempo de computação de horas para minutos em supercomputadores, essencial para alertas em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Comparar ADI com métodos implícitos padrão",
                            "description": "Analisar as vantagens computacionais do ADI em relação ao método implícito totalmente acoplado, como redução de custo em malhas 2D e 3D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método implícito padrão para equações parabólicas",
                                  "subSteps": [
                                    "Relembre a formulação da equação parabólica, como a equação de calor ∂u/∂t = Δu.",
                                    "Descreva o esquema implícito totalmente acoplado (Backward Euler) em 1D, 2D e 3D.",
                                    "Escreva o sistema linear resultante: Au^{n+1} = u^n, onde A é a matriz tridiagonal ou esparsa.",
                                    "Discuta a necessidade de resolver um sistema linear grande em cada passo de tempo.",
                                    "Implemente um exemplo simples em 1D usando Python ou MATLAB."
                                  ],
                                  "verification": "Capacidade de derivar corretamente o sistema linear e implementá-lo sem erros de sintaxe.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), Python com NumPy/SciPy, Jupyter Notebook.",
                                  "tips": "Comece com 1D para visualizar a matriz antes de generalizar para 2D/3D.",
                                  "learningObjective": "Compreender a estrutura do método implícito padrão e seu custo associado a sistemas lineares.",
                                  "commonMistakes": "Confundir método implícito com explícito; ignorar a acoplagem total entre direções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir os fundamentos do método ADI",
                                  "subSteps": [
                                    "Explique o princípio de alternância de direções no ADI para problemas 2D.",
                                    "Derive o esquema ADI em duas etapas: primeiro na direção x, depois na y.",
                                    "Estenda a derivação para 3D, alternando pares de direções.",
                                    "Mostre que cada subpasso resolve um sistema tridiagonal 1D, mais eficiente.",
                                    "Implemente o ADI para um problema 2D simples."
                                  ],
                                  "verification": "Implementação correta do ADI que converge para a solução esperada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula sobre ADI, software MATLAB/Python com solvers tridiagonais (Thomas algorithm).",
                                  "tips": "Use o algoritmo de Thomas para resolver eficientemente os sistemas tridiagonais.",
                                  "learningObjective": "Dominar a derivação e implementação do ADI, destacando sua decomposição direcional.",
                                  "commonMistakes": "Esquecer a correção de Peaceman-Rachford ou Douglas-Rachford para consistência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o custo computacional do método implícito padrão",
                                  "subSteps": [
                                    "Calcule a complexidade para 2D: matriz de tamanho N^2 x N^2, custo O((N^2)^3) por iteração direta ou O(N^4 log N) com iterativos.",
                                    "Para 3D: custo O(N^6) ou pior, destacando explosão em malhas finas.",
                                    "Meça tempos de execução em simulações numéricas para malhas 32x32 e 64x64.",
                                    "Compare armazenamento de matriz: full vs sparse.",
                                    "Registre flops por passo de tempo."
                                  ],
                                  "verification": "Tabela com custos teóricos e empíricos corretos para diferentes dimensões de malha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com timeit e sparse matrices (SciPy), exemplos de código prontos.",
                                  "tips": "Use solvers iterativos como GMRES para simular cenários realistas em grandes malhas.",
                                  "learningObjective": "Quantificar o alto custo computacional do método fully coupled em 2D/3D.",
                                  "commonMistakes": "Subestimar custo de pré-condicionadores ou usar decomposição direta em matrizes grandes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar custos e analisar vantagens do ADI",
                                  "subSteps": [
                                    "Calcule custo ADI em 2D: O(N^3) por passo completo (dois solves O(N^2 log N)).",
                                    "Em 3D: O(N^4) vs O(N^6), ganho significativo.",
                                    "Execute benchmarks lado a lado para malhas 2D/3D e plote tempos vs tamanho da malha.",
                                    "Discuta estabilidade e precisão comparadas.",
                                    "Conclua com razões para preferir ADI em problemas multidimensionais."
                                  ],
                                  "verification": "Gráficos de benchmark mostrando speedup do ADI (ex: 10-100x em 3D).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Códigos dos steps anteriores, Matplotlib para plots, hardware com timer preciso.",
                                  "tips": "Fixe Δt e número de passos para comparação justa; escale malhas uniformemente.",
                                  "learningObjective": "Demonstrar quantitativamente as vantagens computacionais do ADI.",
                                  "commonMistakes": "Comparar sem controlar precisão ou usar malhas muito pequenas onde diferença é negligible."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar vantagens e limitações",
                                  "subSteps": [
                                    "Liste vantagens: redução de custo, paralelização fácil, menor memória.",
                                    "Discuta limitações: acoplamento fraco pode afetar precisão em alguns casos.",
                                    "Aplique a uma malha 3D real e reporte speedup.",
                                    "Escreva um relatório comparativo.",
                                    "Proponha quando usar cada método."
                                  ],
                                  "verification": "Relatório escrito com análise clara e conclusões fundamentadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto, exemplos de malhas 3D geradas por Meshgrid.",
                                  "tips": "Use log-log plots para visualizar escalabilidade.",
                                  "learningObjective": "Integrar análise para tomada de decisão em simulações numéricas.",
                                  "commonMistakes": "Ignorar overhead de comunicação em paralelo ou casos onde ADI falha (ex: anisotrópico)."
                                }
                              ],
                              "practicalExample": "Resolva a equação de calor 2D ∂u/∂t = Δu em um quadrado unitário com u=0 nas bordas e u(x,y,0)=sin(πx)sin(πy), usando malha 64x64 e 100 passos de tempo. Implemente método implícito fully coupled (com GMRES) e ADI (Douglas), meça tempo total e compare soluções/erros.",
                              "finalVerifications": [
                                "Explicar verbalmente por que ADI reduz custo de O(N^4) para O(N^3) em 2D.",
                                "Apresentar benchmark com speedup >5x em malha 128x128.",
                                "Derivar manualmente sistemas para N=3 em 2D para ambos métodos.",
                                "Identificar quando fully coupled é preferível (ex: malhas 1D).",
                                "Plotar convergência de erro vs tempo computacional.",
                                "Discutir extensões modernas como multigrid para fully coupled."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática dos esquemas (30%).",
                                "Correção e eficiência das implementações numéricas (25%).",
                                "Análise quantitativa de custos com evidências empíricas (20%).",
                                "Clareza na comparação de vantagens/desvantagens (15%).",
                                "Qualidade de visualizações e relatório final (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação de solvers lineares e benchmarks.",
                                "Física Computacional: Aplicações em difusão de calor e ondas.",
                                "Engenharia de Computação: Otimização de algoritmos para HPC.",
                                "Estatística Numérica: Análise de erro e estabilidade."
                              ],
                              "realWorldApplication": "Em simulações CFD para previsão de fluxo de calor em turbinas aeronáuticas ou difusão em reservatórios petrolíferos, onde malhas 3D com milhões de pontos demandam métodos eficientes como ADI para viabilizar simulações em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Formulação Matemática dos Métodos ADI",
                        "description": "Derivação detalhada da esquematização numérica ADI usando diferenças finitas para equações parabólicas, incluindo o esquema de Peaceman-Rachford e variantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Derivar o esquema ADI de dois passos",
                            "description": "Construir o esquema ADI básico para a equação u_t = Δu em 2D, com passos implícito na direção x e explícito na y, e vice-versa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar discretização implícita e explícita em 1D para a equação de calor",
                                  "subSteps": [
                                    "Escreva a equação de calor 1D: u_t = u_xx.",
                                    "Discritize usando diferenças finitas: defina o esquema explícito u^{n+1}_j = u^n_j + r (u^n_{j-1} - 2u^n_j + u^n_{j+1}).",
                                    "Discritize o esquema implícito: resolva o sistema tridiagonal para u^{n+1}_j - r (u^{n+1}_{j-1} - 2u^{n+1}_j + u^{n+1}_{j+1}) = u^n_j.",
                                    "Compare estabilidade: explícito requer r ≤ 1/2, implícito incondicionalmente estável.",
                                    "Anote os operadores: A_r = I - r δ_xx (explícito), B_r = I + r δ_xx (implícito inverso)."
                                  ],
                                  "verification": "Confirme que você pode derivar ambos os esquemas e explicar suas diferenças de estabilidade em uma folha de papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora, referência de análise numérica (ex: livro de LeVeque).",
                                  "tips": "Use grade uniforme h=Δx, τ=Δt, r=τ/h² para simplificar notação.",
                                  "learningObjective": "Entender os blocos de construção 1D para estender ao método ADI em 2D.",
                                  "commonMistakes": "Confundir os operadores explícito/implícito; esquecer o fator r na discretização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estender a equação para 2D e introduzir a fatoração do Laplaciano",
                                  "subSteps": [
                                    "Escreva a equação 2D: u_t = Δu = u_xx + u_yy em domínio retangular.",
                                    "Discritize o Laplaciano: δ²u = δ_xx u + δ_yy u, onde δ_xx e δ_yy são operadores 1D em x e y.",
                                    "Introduza a ideia ADI: aproximar (I - τ Δ)^{ -1 } ≈ (I - τ/2 δ_xx)^{-1} (I - τ/2 δ_yy)^{-1} para o esquema implícito completo.",
                                    "Defina os operadores 2D: A_r = I - r δ_xx (operador em x), B_r = I - r δ_yy (operador em y).",
                                    "Verifique a consistência da fatoração via expansão de Taylor."
                                  ],
                                  "verification": "Escreva explicitamente os operadores A_r e B_r agindo em uma grade 2D (i,j).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, lápis, software de desenho vetorial opcional para grades.",
                                  "tips": "Pense em δ_xx atuando apenas em índices i, independentemente de j.",
                                  "learningObjective": "Compreender como decompor o problema 2D em direções alternadas.",
                                  "commonMistakes": "Misturar notação de índices x e y; ignorar que operadores são tensorizados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o primeiro passo do esquema ADI: implícito em x, explícito em y",
                                  "subSteps": [
                                    "Do passo 1 para n+1/2: resolva implicitamente em x: (I - (τ/2) δ_xx) u^{n+1/2} = u^n + (τ/2) δ_yy u^n (explícito em y).",
                                    "Expanda: para cada linha j fixa, resolva tridiagonal em i para u^{n+1/2}_{i,j}.",
                                    "Escreva a equação matricial: A_{τ/2} u^{n+1/2}_{:,j} = u^n_{:,j} + (τ/2) δ_yy u^n_{:,j}.",
                                    "Confirme que isso é eficiente: τ/2 sweep em x para cada j (O(J * I) operações).",
                                    "Teste com valores numéricos simples em grade 3x3."
                                  ],
                                  "verification": "Implemente manualmente em uma grade pequena e verifique se resolve corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, calculadora matricial ou Python/MATLAB para teste rápido.",
                                  "tips": "Lembre-se: δ_yy u^n_{i,j} = (u^n_{i,j-1} - 2u^n_{i,j} + u^n_{i,j+1})/h_y².",
                                  "learningObjective": "Derivar e entender o semi-passo implícito-explicito.",
                                  "commonMistakes": "Usar τ em vez de τ/2; confundir ordem das direções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar o segundo passo: implícito em y, explícito em x",
                                  "subSteps": [
                                    "Do semi-passo n+1/2 para n+1: (I - (τ/2) δ_yy) u^{n+1} = u^{n+1/2} + (τ/2) δ_xx u^{n+1/2} (explícito em x agora).",
                                    "Expanda: para cada coluna i fixa, resolva tridiagonal em j para u^{n+1}_{i,:}.",
                                    "Escreva: B_{τ/2} u^{n+1}_{i,:} = u^{n+1/2}_{i,:} + (τ/2) δ_xx u^{n+1/2}_{i,:}.",
                                    "Mostre a composição: u^{n+1} ≈ B^{-1} (I + (τ/2) δ_xx) A^{-1} (I + (τ/2) δ_yy) u^n.",
                                    "Verifique truncagem O(τ² + h²) para consistência de segunda ordem."
                                  ],
                                  "verification": "Combine passos 3 e 4 em grade pequena e compare com esquema implícito full 2D.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmos do passo 3, incluindo código simples para validação.",
                                  "tips": "Note a alternância: x primeiro, depois y; próximo timestep inverte.",
                                  "learningObjective": "Completar a derivação do esquema ADI de dois passos.",
                                  "commonMistakes": "Erro nos sinais dos operadores; esquecer inversos nos passos implícitos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar precisão, estabilidade e implementar pseudocódigo",
                                  "subSteps": [
                                    "Mostre que ADI aproxima o Crank-Nicolson ou implícito full com erro O(τ³).",
                                    "Analise estabilidade via von Neumann ou matrizes: incondicional em 2D.",
                                    "Escreva pseudocódigo para um ciclo completo ADI.",
                                    "Teste com condição inicial u=sen(πx)sen(πy), compare com solução exata.",
                                    "Discuta generalizações para múltiplos passos ou não-uniforme."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros e produz resultados consistentes em teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (Python/Octave), grade teste 10x10.",
                                  "tips": "Use solucionadores tridiagonais (Thomas algorithm) para eficiência.",
                                  "learningObjective": "Validar o esquema derivado e preparar para implementação.",
                                  "commonMistakes": "Ignorar condições de contorno; superestimar ordem de precisão."
                                }
                              ],
                              "practicalExample": "Considere grade 5x5, τ=0.1, h=0.2 (r_x=0.25, r_y=0.25), u^0_{i,j}=sin(π i h) sin(π j h). Compute u^1 via ADI: primeiro sweep implícito x para cada j, depois implícito y para cada i. Compare com full implícito.",
                              "finalVerifications": [
                                "Esquemas dos dois passos escritos corretamente com operadores A_{τ/2} e B_{τ/2}.",
                                "Composição dos passos aproxima (I - τ Δ)^{-1} com erro O(τ³).",
                                "Pseudocódigo implementável roda em grade teste sem divergência.",
                                "Explicação oral da alternância de direções e eficiência O(N) por timestep.",
                                "Teste numérico em 5x5 grade bate com solução referenciada dentro de 1%.",
                                "Identificação correta de estabilidade incondicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação dos operadores semi-explícitos (100% das equações corretas).",
                                "Compreensão da fatoração e truncagem (explicação coerente).",
                                "Eficiência computacional reconhecida (sweeps lineares vs full 2D O(N²)).",
                                "Validação numérica com erro <5% em exemplo prático.",
                                "Tratamento correto de condições de contorno (Dirichlet homogêneo).",
                                "Criatividade em extensão para timestep seguinte (inversão de direções)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica ou contaminação em placas 2D.",
                                "Computação: Algoritmos paralelizáveis (sweeps por direção em GPUs).",
                                "Engenharia: Simulações CFD para escoamentos viscosos parabólicos.",
                                "Estatística: Métodos Monte Carlo acelerados por ADI em PDEs estocásticas."
                              ],
                              "realWorldApplication": "Simulação eficiente de propagação de calor em painéis solares ou difusão de poluentes em aquíferos 2D, permitindo grids grandes sem supercomputadores, usado em previsão meteorológica e design de reatores químicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Implementar condições de contorno no ADI",
                            "description": "Incorporar condições de Dirichlet e Neumann nos passos ADI, ajustando os sistemas lineares tridiagonais resolvidos em cada direção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulação ADI e identificar pontos de inserção das condições de contorno",
                                  "subSteps": [
                                    "Analisar a formulação do método ADI para equações parabólicas 2D, destacando os sweeps em x e y.",
                                    "Identificar as linhas de grade nas bordas onde as condições de contorno são aplicadas (i=0, i=Nx, j=0, j=Ny).",
                                    "Estudar as matrizes tridiagonais A e B nos sweeps, notando como os coeficientes mudam nas bordas.",
                                    "Esboçar diagramaticamente o stencil ADI com posições das condições de contorno.",
                                    "Preparar o código base ADI sem condições de contorno para modificação."
                                  ],
                                  "verification": "Verificar se o diagrama e anotações identificam corretamente todas as 4 bordas e sweeps.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código base ADI em Python (NumPy), papel e caneta ou ferramenta de diagramação como Draw.io, documentação do método ADI.",
                                  "tips": "Use grids pequenos (ex: 5x5) para visualizar bordas facilmente.",
                                  "learningObjective": "Compreender a estrutura do ADI e localizar precisamente onde inserir condições de contorno.",
                                  "commonMistakes": "Confundir sweeps x e y, ignorando que condições afetam matrizes diferentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar condições de Dirichlet nos sistemas tridiagonais ADI",
                                  "subSteps": [
                                    "Definir valores de Dirichlet nas bordas (ex: u=0 em i=0 e j=0).",
                                    "Modificar a matriz tridiagonal A (sweep x) zerando linhas de borda em y e incorporando valores conhecidos.",
                                    "Ajustar o vetor de lado direito (RHS) adicionando contribuições de Dirichlet.",
                                    "Aplicar similarmente na matriz B (sweep y), garantindo consistência.",
                                    "Codificar uma função auxiliar para aplicar Dirichlet em qualquer borda."
                                  ],
                                  "verification": "Executar um teste com grid homogêneo; solução deve satisfazer exatamente Dirichlet nas bordas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com NumPy e SciPy (para solver tridiagonal), Jupyter Notebook.",
                                  "tips": "Use thomas_algorithm ou scipy.linalg.solve_banded para eficiência.",
                                  "learningObjective": "Modificar corretamente matrizes e RHS para condições Dirichlet em ambos sweeps.",
                                  "commonMistakes": "Esquecer de atualizar RHS com valores de Dirichlet, levando a desvios nas bordas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar condições de Neumann nos sistemas tridiagonais ADI",
                                  "subSteps": [
                                    "Formular aproximação de primeira ordem para derivada normal nas bordas (ex: du/dn = g).",
                                    "Incorporar Neumann na matriz A/B ajustando coeficientes diagonais e subdiagonais nas bordas.",
                                    "Atualizar RHS com termos de fluxo Neumann (ex: 2*g*h para precisão O(h)).",
                                    "Implementar para bordas opostas, diferenciando derivadas internas/externas.",
                                    "Criar função auxiliar para Neumann, parametrizada por direção e valor g."
                                  ],
                                  "verification": "Testar com Neumann zero (isolamento); fluxo deve ser nulo nas bordas.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Mesmo ambiente Python anterior, adicionar Matplotlib para plotar gradientes.",
                                  "tips": "Verifique simetria: Neumann zero deve preservar massa total.",
                                  "learningObjective": "Ajustar stencil e matrizes para condições de Neumann com precisão adequada.",
                                  "commonMistakes": "Usar aproximação central em borda (inconsistente), causando erro O(h^2)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar condições mistas, testar e validar a implementação completa",
                                  "subSteps": [
                                    "Combinar Dirichlet e Neumann em bordas diferentes (ex: Dirichlet em x=0,1; Neumann em y=0,1).",
                                    "Executar simulação completa ADI com condições mistas e múltiplos time steps.",
                                    "Comparar solução numérica com solução analítica conhecida (ex: steady-state).",
                                    "Analisar convergência plotando erro vs. grid size e time steps.",
                                    "Otimizar código para eficiência e documentar funções."
                                  ],
                                  "verification": "Erro L2 < 1e-4 em teste analítico; plots mostram condições satisfeitas.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Matplotlib para visualização, solução analítica de referência (ex: equação de calor 2D).",
                                  "tips": "Use grids refinados progressivamente para estudar ordem de precisão.",
                                  "learningObjective": "Integrar e validar implementação robusta para condições mistas no ADI.",
                                  "commonMistakes": "Inconsistência entre sweeps, levando a oscilações ou divergência."
                                }
                              ],
                              "practicalExample": "Implemente ADI para resolver a equação de calor 2D ut = uxx + uyy em [0,1]x[0,1], com u(x,0,t)=sin(pi x), du/dy=0 em y=1, u=0 em x=0,1. Compare com solução steady-state sin(pi x) em 100 time steps, grid 20x20.",
                              "finalVerifications": [
                                "Código executa sem erros para grids até 100x100.",
                                "Condições de Dirichlet são exatamente satisfeitas nas bordas (erro < 1e-12).",
                                "Gradientes em bordas Neumann coincidem com valores impostos (erro relativo < 1%).",
                                "Solução converge monotonicamente com refinamento de grid.",
                                "Massa/flujo é conservado em casos Neumann zero.",
                                "Tempo de execução escalável (O(N log N) por time step)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro L2 < 1e-3 em teste padrão.",
                                "Corretude nas bordas: Verificação pontual exata para Dirichlet/Neumann.",
                                "Eficiência: Uso de solvers tridiagonais O(N).",
                                "Robustez: Funciona para condições mistas e grids variados.",
                                "Clareza do código: Funções modulares com comentários.",
                                "Validação: Comparação com analítica e análise de convergência."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e fluxo de calor.",
                                "Programação: Algoritmos numéricos em Python/NumPy e solvers lineares.",
                                "Engenharia: Simulações CFD para escoamentos parabólicos.",
                                "Matemática Aplicada: Análise de estabilidade e truncamento de métodos implícitos."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em placas metálicas com isolamento parcial (Neumann) e temperaturas fixas (Dirichlet), usada em design de dissipadores de calor para eletrônicos ou processos industriais de recozimento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Generalizar para esquemas de Douglas-Rachford",
                            "description": "Estender a formulação ADI para variantes de ordem superior, como o esquema de Douglas-Rachford, e discutir parâmetros de aceleração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação ADI Padrão e Conceitos de Splitting",
                                  "subSteps": [
                                    "Relembrar a equação parabólica 2D: ∂u/∂t = Δu, e a discretização implícita em direções alternadas.",
                                    "Derivar o esquema ADI de Peaceman-Rachford: u^{n+1/2} = (I - Δt/2 A_x)^{-1} (u^n + Δt/2 A_y u^n), seguido de u^{n+1} = (I - Δt/2 A_y)^{-1} (u^{n+1/2} + Δt/2 A_x u^{n+1/2}).",
                                    "Identificar os operadores A_x e A_y como laplacianos unidimensionais em x e y.",
                                    "Analisar a consistência e estabilidade condicional do ADI.",
                                    "Comparar com métodos explícitos para destacar a eficiência do splitting."
                                  ],
                                  "verification": "Derive manualmente o esquema ADI para uma grade 3x3 e verifique que a truncagem é O(Δt^2 + Δx^2).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e lápis, software como MATLAB ou Python para testes iniciais.",
                                  "tips": "Use notação matricial para operadores para facilitar a transição para variantes.",
                                  "learningObjective": "Compreender os fundamentos do splitting ADI como base para generalizações.",
                                  "commonMistakes": "Confundir operadores A_x e A_y com o laplaciano completo; ignorar termos de truncagem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Esquema de Douglas-Rachford",
                                  "subSteps": [
                                    "Estudar o operador de Douglas-Rachford: u^{k+1} = (1/2)(I + R^{-1} S) u^k, onde R e S são operadores resolvíveis.",
                                    "Relacionar com ADI: no contexto parabólico, R = I - θ Δt A_x, S = I - θ Δt A_y, com θ parâmetro de aceleração.",
                                    "Derivar a iteração Douglas-Rachford para o problema estacionário Au = f via splitting A = B + C.",
                                    "Explorar a generalização para ordem superior: combinações lineares de iterações DR para maior precisão.",
                                    "Implementar uma iteração simples em pseudocódigo."
                                  ],
                                  "verification": "Escreva o pseudocódigo do DR e execute para 5 iterações em uma matriz 4x4 simulando A_x + A_y.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos originais de Douglas-Rachford (PDFs), Jupyter Notebook com NumPy/SciPy.",
                                  "tips": "Pense em DR como uma extrapolação do ADI para relaxação não-linear ou malha não-uniforme.",
                                  "learningObjective": "Dominar a formulação básica do Douglas-Rachford como extensão do ADI.",
                                  "commonMistakes": "Esquecer o fator 1/2 na média refletora; assumir convergência incondicional sem parâmetros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar ADI para Variantes de Ordem Superior via Douglas-Rachford",
                                  "subSteps": [
                                    "Estender ADI para esquemas de ordem 2p usando combinações de DR: u^{n+1} = ∑ ω_k DR^k (u^n).",
                                    "Derivar explicitamente para p=2: combinação de 3 iterações DR com pesos ω para truncagem O(Δt^4).",
                                    "Analisar a consistência: mostrar que aproxima a evolução temporal exata.",
                                    "Discutir estabilidade via análise de von Neumann ou GKS.",
                                    "Comparar custo computacional: O(N) por iteração vs. métodos diretos O(N^2)."
                                  ],
                                  "verification": "Derive os pesos ω para ordem 3 e verifique numericamente em uma PDE de difusão 1D.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Referências como 'Numerical Solution of PDEs' de Strikwerda, MATLAB para simulações.",
                                  "tips": "Use séries de Padé para aproximar o exponencial e justificar os pesos.",
                                  "learningObjective": "Capacitar a derivação de generalizações de alta ordem do ADI via DR.",
                                  "commonMistakes": "Erros nos pesos ω levando a instabilidade; negligenciar dependência em Δt/Δx."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Parâmetros de Aceleração e Análise de Convergência",
                                  "subSteps": [
                                    "Introduzir θ ótimo em DR: θ = 1/(2(1 + √(1 - ρ))), onde ρ é o espectro dos operadores.",
                                    "Analisar taxa de convergência: ||e^{k+1}|| ≤ γ ||e^k|| com γ <1 para θ adequado.",
                                    "Explorar aceleração via Aitken ou SOR em iterações DR.",
                                    "Testar numericamente impacto de θ em uma grade 64x64.",
                                    "Generalizar para operadores não-comutativos e condições de convergência."
                                  ],
                                  "verification": "Otimize θ para um exemplo e mostre redução de 50% nas iterações necessárias.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python com solvers iterativos, gráficos de erro L2 vs. iterações.",
                                  "tips": "Plote autovalores dos operadores para visualizar o espectro e escolher θ.",
                                  "learningObjective": "Compreender e otimizar parâmetros para aceleração prática.",
                                  "commonMistakes": "Escolher θ=1 fixo ignorando espectro; confundir convergência linear com superlinear."
                                }
                              ],
                              "practicalExample": "Aplique o esquema Douglas-Rachford generalizado à equação de difusão 2D ∂u/∂t = Δu em [0,1]^2 com u=0 na borda e u(x,y,0)=sin(πx)sin(πy). Use grade 32x32, Δt=0.01, θ=0.8, e compare solução numérica com exata em t=0.1, medindo erro L2 < 10^{-4} após 100 iterações.",
                              "finalVerifications": [
                                "Derive corretamente o esquema DR de ordem 2 com pesos ω exatos.",
                                "Implemente e execute código que converge em <200 iterações para erro 10^{-5}.",
                                "Explique verbalmente o papel de θ na aceleração.",
                                "Compare estabilidade ADI vs. DR em malha anisotrópica.",
                                "Identifique condições para convergência em operadores não-simétricos.",
                                "Gere gráfico de erro vs. iterações mostrando aceleração."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação matemática (fórmulas corretas e justificadas).",
                                "Compreensão conceitual de splitting e generalização (explicação clara).",
                                "Implementação numérica funcional e eficiente.",
                                "Análise de convergência com parâmetros otimizados.",
                                "Identificação de limitações e extensões possíveis.",
                                "Criatividade em exemplos práticos e conexões interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão em materiais heterogêneos.",
                                "Computação: Algoritmos paralelizáveis em GPUs para splitting.",
                                "Engenharia: Simulações CFD com operadores não-lineares.",
                                "Otimização: Aplicações em problemas de minimização variacional."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em painéis solares ou reservatórios petrolíferos, onde o Douglas-Rachford acelera soluções de PDEs em malhas grandes, reduzindo tempo de computação de horas para minutos em supercomputadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Análise de Estabilidade e Convergência",
                        "description": "Estudo teórico da consistência, estabilidade von Neumann e convergência dos métodos ADI para equações parabólicas, com referência a resultados clássicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Verificar consistência do esquema ADI",
                            "description": "Demonstrar que o esquema ADI é consistente com a equação parabólica original, calculando o erro de truncamento local de ordem O(Δt² + Δx²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação Parabólica e o Esquema ADI",
                                  "subSteps": [
                                    "Escreva a equação parabólica modelo em 2D: ∂u/∂t = ν (∂²u/∂x² + ∂²u/∂y²).",
                                    "Descreva o esquema ADI (ex: Douglas-Rachford) com half-steps: primeiro implícito em x (explícito em y), depois implícito em y (explícito em x).",
                                    "Defina os operadores finitos: diferença forward em tempo δ_t u = (u^{n+1} - u^n)/Δt, central em espaço δ_{xx} u = (u_{i+1} - 2u_i + u_{i-1})/Δx².",
                                    "Especifique as aproximações: r_x = ν Δt / Δx², r_y = ν Δt / Δy² (assuma Δx = Δy).",
                                    "Verifique a forma matricial das half-steps para clareza."
                                  ],
                                  "verification": "Esquema ADI escrito corretamente, com operadores e parâmetros identificados.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Notas de aula sobre métodos ADI",
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Papel e lápis ou software como Mathematica"
                                  ],
                                  "tips": "Anote as half-steps separadamente para evitar confusão entre direções x e y.",
                                  "learningObjective": "Compreender a estrutura algébrica do esquema ADI e suas aproximações diferenciais.",
                                  "commonMistakes": [
                                    "Confundir half-steps (x antes de y ou vice-versa)",
                                    "Esquecer o coeficiente de difusão ν",
                                    "Usar diferenças erradas (forward em espaço ao invés de central)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Expansões em Série de Taylor dos Operadores",
                                  "subSteps": [
                                    "Expanda u(x, y, t + Δt) = u + Δt u_t + (Δt²/2) u_{tt} + O(Δt³).",
                                    "Expanda os operadores espaciais: δ_{xx} u = u_{xx} + (Δx²/12) u_{xxxx} + O(Δx⁴).",
                                    "Faça o mesmo para δ_{yy} u e para pontos intermediários nas half-steps.",
                                    "Inclua expansões para u em tempos intermediários (n+1/2) assumindo consistência temporal.",
                                    "Registre todas as expansões em um lado para referência."
                                  ],
                                  "verification": "Expansões de Taylor corretas para pelo menos 3 operadores principais (tempo e dois espaços).",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Tabela de expansões de Taylor padrão",
                                    "Calculadora simbólica (Mathematica ou papel)",
                                    "Folha de referência de operadores finitos"
                                  ],
                                  "tips": "Use notação abreviada como L_x u ≈ ∂²u/∂x² + (Δx²/12) ∂⁴u/∂x⁴ para economizar tempo.",
                                  "learningObjective": "Dominar expansões de Taylor para operadores de diferenças finitas em múltiplas dimensões.",
                                  "commonMistakes": [
                                    "Parar em ordens baixas demais (ignorar O(Δt²))",
                                    "Erros de sinal em termos pares/impares",
                                    "Confundir derivadas mistas ∂²/∂x∂y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir Expansões no Esquema ADI e Simplificar",
                                  "subSteps": [
                                    "Substitua as expansões na primeira half-step (direção x): δ_t/2 + r_x L_x ≈ ν L_x + ν L_y /2.",
                                    "Faça o mesmo para a segunda half-step (direção y).",
                                    "Some as half-steps para obter a equação completa em u^{n+1} - u^n.",
                                    "Expanda u_{tt} usando a PDE original: u_{tt} = ν (u_{xxt} + u_{yy t}) = ν² (u_{xxxx} + 2 u_{xxyy} + u_{yyyy}).",
                                    "Colete termos até ordem 2 em Δt e Δx."
                                  ],
                                  "verification": "Equação expandida simplificada, mostrando cancelamento de termos de ordem 1.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "Expansões do passo 2",
                                    "Software simbólico para simplificação (opcional)",
                                    "Quadro branco para álgebra longa"
                                  ],
                                  "tips": "Trabalhe simbolicamente com operadores L_x, L_y em vez de funções explícitas para generalidade.",
                                  "learningObjective": "Aplicar expansões para reproduzir a PDE original a partir do esquema numérico.",
                                  "commonMistakes": [
                                    "Não expandir termos intermediários corretamente",
                                    "Erros aritméticos em coeficientes de r_x e r_y",
                                    "Ignorar contribuições de u_{tt}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Erro de Truncamento Local e Verificar Ordem",
                                  "subSteps": [
                                    "Identifique os termos residuais após subtrair ν (L_x + L_y) u do lado esquerdo expandido.",
                                    "Mostre que termos O(Δt) e O(Δx²/Δt) cancelam devido à estrutura ADI.",
                                    "Agrupe erros: O(Δt²) de tempo + O(Δx²) de espaço (sem O(Δx⁴/Δt) problemático como em explicit).",
                                    "Confirme que LTE = O(Δt² + Δx²) para Δt, Δx → 0.",
                                    "Discuta implicações para consistência (Lax-Richtmyer: consistência + estabilidade ⇒ convergência)."
                                  ],
                                  "verification": "Expressão explícita do LTE com ordem correta O(Δt² + Δx²).",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Expansão simplificada do passo 3",
                                    "Teorema de Lax-Richtmyer resumido"
                                  ],
                                  "tips": "Compare com esquema explícito 2D para destacar vantagem ADI na ordem de erro.",
                                  "learningObjective": "Analisar e quantificar o erro local de truncamento para provar consistência.",
                                  "commonMistakes": [
                                    "Atribuir ordem errada (ex: O(Δt + Δx²))",
                                    "Não cancelar termos adequadamente",
                                    "Confundir LTE com GEE (erro global)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = (∂²u/∂x² + ∂²u/∂y²) em [0,1]² com u=0 nas bordas, aplique o esquema ADI de Douglas-Rachford com Δt=0.01, Δx=0.05. Expanda Taylor e mostre LTE = (Δt²/2) u_{tt} + (Δx²/12)(u_{xxxx} + u_{yyyy}) + O(Δt³, Δx⁴), confirmando consistência ao limitar malhas finas.",
                              "finalVerifications": [
                                "Esquema ADI reproduz exatamente a PDE nos limites Δt,Δx → 0.",
                                "Termos lineares em Δt e Δx cancelam perfeitamente.",
                                "Erros restantes são puramente O(Δt² + Δx²).",
                                "Expansões de Taylor incluem pelo menos até ordem 2.",
                                "Discussão breve de relação com estabilidade (von Neumann ou matrizes)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das expansões de Taylor (sem erros aritméticos).",
                                "Correta simplificação e cancelamento de termos principais.",
                                "Identificação explícita da ordem do LTE como O(Δt² + Δx²).",
                                "Clareza na derivação passo a passo.",
                                "Conexão válida com teorema de consistência-convergência.",
                                "Exemplo prático resolvido corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações de difusão térmica ou onda.",
                                "Computação Científica: Validação de códigos numéricos em Python/MATLAB.",
                                "Engenharia: Verificação de solvers em CFD para escoamentos laminares.",
                                "Estatística: Análise de erro em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de reservatórios petrolíferos, verificar consistência do ADI garante precisão na previsão de frentes de difusão de fluidos injetados, otimizando extração sem erros de malha grosseira que poderiam custar milhões em decisões erradas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Analisar estabilidade via amplificação",
                            "description": "Aplicar análise von Neumann para provar estabilidade incondicional do método ADI Peaceman-Rachford em malhas uniformes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise von Neumann e Formular o Esquema ADI Peaceman-Rachford",
                                  "subSteps": [
                                    "Estude a análise von Neumann: assuma solução de onda plana u_{j,k}^n = g^n exp(i β h (j ξ + k η)), onde β é parâmetro espacial, h passo espacial, ξ,η ângulos de fase.",
                                    "Formule a equação parabólica modelo: ∂u/∂t = Δu em 2D com malha uniforme h_x = h_y = h.",
                                    "Escreva o esquema ADI Peaceman-Rachford: duas meias-passadas alternadas em x e y com fatores r = Δt/(2h²).",
                                    "Verifique a consistência do esquema derivando os operadores de diferença.",
                                    "Implemente notação matricial ou stencil para o esquema."
                                  ],
                                  "verification": "Escreva o esquema completo e confirme que corresponde à forma padrão do ADI PR com fator r.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e caneta ou Jupyter Notebook para anotações.",
                                  "tips": "Use diagramas de stencil para visualizar as direções alternadas x e y.",
                                  "learningObjective": "Compreender a estrutura do método ADI PR e preparar para análise de amplificação.",
                                  "commonMistakes": "Confundir o fator r com Δt/h² em vez de Δt/(2h²); ignorar a alternância das direções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a Análise von Neumann para o Fator de Amplificação",
                                  "subSteps": [
                                    "Substitua a forma de onda plana na equação da primeira meia-passada (direção x).",
                                    "Derive o símbolo do operador Laplaciano implícito: δ_x² → -4 sin²(β h ξ /2)/h².",
                                    "Calcule g_x, o fator de amplificação da meia-passada em x: resolva a relação algébrica linear.",
                                    "Repita para a segunda meia-passada em y, obtendo g_y.",
                                    "Formule o fator total g = g_x g_y."
                                  ],
                                  "verification": "Obtenha expressões explícitas para g_x e g_y em termos de r, θ_x = β h ξ, θ_y = β h η.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy no Python) ou papel para trigonometria.",
                                  "tips": "Mantenha θ_x = β h ξ e θ_y = β h η como variáveis para simplificar seno e cosseno.",
                                  "learningObjective": "Aplicar suposição de onda plana e derivar fatores parciais de amplificação.",
                                  "commonMistakes": "Esquecer o '2' no denominador do Laplaciano centrado; errar a ordem das meias-passadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Analisar o Módulo do Fator de Amplificação |g|",
                                  "subSteps": [
                                    "Escreva g = g_x g_y explicitamente: g_x = (1 - 2 r sin²(θ_x/2)) / (1 + 2 r sin²(θ_x/2)), similar para g_y.",
                                    "Mostre que |g_x| ≤ 1 para todo r > 0 e θ_x, provando |numerador| ≤ |denominador|.",
                                    "Prove |g_x| = 1 apenas se sin²(θ_x/2) = 0, senão <1.",
                                    "Conclua |g| = |g_x| |g_y| ≤ 1 para todos os modos, independentemente de r.",
                                    "Verifique numericamente para θ_x, θ_y variando de 0 a π."
                                  ],
                                  "verification": "Derive inequação |1 - 2 r s| ≤ |1 + 2 r s| onde s = sin²(θ/2) ∈ [0,1].",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de plotagem (Matplotlib) para |g(θ_x, θ_y)| vs r.",
                                  "tips": "Use desigualdade triangular ou análise quadrática para provar |g_x| ≤ 1.",
                                  "learningObjective": "Demonstrar que |g| ≤ 1 para todos os comprimentos de onda e Δt arbitrários.",
                                  "commonMistakes": "Assumir estabilidade condicional como em métodos explícitos; falhar em provar para r → ∞."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir Estabilidade Incondicional e Verificações",
                                  "subSteps": [
                                    "Resuma a prova: como |g| ≤ 1 com igualdade só para modo zero, o esquema é incondicionalmente estável.",
                                    "Discuta limitações: assume malha uniforme, equação modelo sem termos reativos.",
                                    "Compare com método de Crank-Nicolson em 2D (estável mas mais rígido).",
                                    "Teste com código simples: implemente ADI PR e rode com Δt grande.",
                                    "Documente a prova em LaTeX ou relatório."
                                  ],
                                  "verification": "Simule numericamente com r=100 e confirme ausência de oscilações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB para simulação 1D/2D da equação de calor.",
                                  "tips": "Para simulação, use condições iniciais com altas frequências para testar estabilidade.",
                                  "learningObjective": "Formalizar a prova de estabilidade incondicional via von Neumann.",
                                  "commonMistakes": "Ignorar que |g|=1 para todos os modos em esquemas implícitos; confundir com convergência."
                                }
                              ],
                              "practicalExample": "Considere a equação de calor 2D u_t = u_xx + u_yy em [0,1]x[0,1] com u=0 nas bordas e u(x,y,0)=sin(πx)sin(πy). Aplique ADI PR com h=0.1, Δt=10 (r=50). Calcule g para θ_x=θ_y=π/10: verifique |g|≈0.99<1 e simule 100 passos sem blow-up.",
                              "finalVerifications": [
                                "Derivação correta de g_x e g_y em termos de r, sin²(θ/2).",
                                "Prova analítica de |g_x| ≤ 1 para todo r>0, θ.",
                                "Gráfico de |g| ≤1 sobre a grade de θ_x, θ_y para r=1,10,100.",
                                "Simulação numérica estável com Δt=100h².",
                                "Comparação com método explícito que diverge para mesmo Δt.",
                                "Resumo escrito da prova de estabilidade incondicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do esquema ADI PR (20%).",
                                "Correção na análise von Neumann e cálculo de g (30%).",
                                "Prova rigorosa de |g|≤1 independentemente de r (25%).",
                                "Verificações numéricas e discussões de limitações (15%).",
                                "Clareza na documentação e exemplos práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e análise de Fourier.",
                                "Computação: Implementação eficiente de solvers implícitos em Python/Fortran.",
                                "Engenharia: Simulações CFD para escoamentos viscosos incompressíveis.",
                                "Matemática Pura: Análise funcional e operadores pseudodiferenciais."
                              ],
                              "realWorldApplication": "Em simulações de reservatórios petrolíferos (origem do método Peaceman-Rachford), modelagem climática 2D para difusão de calor/poluentes, e finanças para equações parabólicas em precificação de opções multidimensionais, permitindo passos de tempo grandes para eficiência computacional."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Discutir taxas de convergência",
                            "description": "Explicar a convergência de ordem 2 em espaço e tempo para ADI, citando teoremas de LeVeque e condições necessárias como razão de malhas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Método ADI e Conceitos de Convergência",
                                  "subSteps": [
                                    "Relembrar a formulação do método ADI de Peaceman-Rachford para equações parabólicas 2D: u_t = Δu.",
                                    "Explicar os passos alternados: implícito em x, explícito em y, e vice-versa.",
                                    "Definir convergência numérica: ||u - u_h|| → 0 quando h, τ → 0.",
                                    "Introduzir erro de truncamento local e global, e relação com ordem de convergência.",
                                    "Discutir consistência como pré-requisito para convergência (Lax equivalence)."
                                  ],
                                  "verification": "Resumir em um parágrafo os passos do ADI e definir ordem de convergência com exemplo simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica II (capítulo ADI)",
                                    "Notas de aula sobre equações parabólicas",
                                    "Artigo de Peaceman-Rachford (opcional)"
                                  ],
                                  "tips": "Use diagramas de grade temporal-espacial para visualizar iterações ADI.",
                                  "learningObjective": "Compreender a base teórica do ADI e métricas de convergência.",
                                  "commonMistakes": [
                                    "Confundir ADI com métodos explícitos como FTCS.",
                                    "Ignorar a não-simplicidade do operador em múltiplas dimensões."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Erro de Truncamento Local no Método ADI",
                                  "subSteps": [
                                    "Derivar o erro de truncamento para o passo em x: O(τ² + h_x²) + O(h_y²).",
                                    "Analisar o passo em y similarmente, somando erros.",
                                    "Mostrar que o erro total por ciclo ADI é O(τ² + h_x² + h_y²).",
                                    "Explicar por que a ordem é 2 em tempo e espaço sob aproximações centrais.",
                                    "Introduzir condições para preservar a ordem: razão de malhas h_x ≈ h_y."
                                  ],
                                  "verification": "Calcular manualmente o erro de truncamento para uma discretização simples e confirmar ordem 2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno para derivações",
                                    "Software simbólico como SymPy para Taylor expansions",
                                    "Referência: notas sobre análise de erro em PDEs"
                                  ],
                                  "tips": "Expanda em série de Taylor passo a passo, anotando termos residuais.",
                                  "learningObjective": "Derivar e interpretar o erro local que leva à taxa de convergência.",
                                  "commonMistakes": [
                                    "Esquecer termos mistos ∂⁴u/∂x²∂y² no erro.",
                                    "Assumir independência total entre direções."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Teoremas de LeVeque sobre Convergência de Ordem 2",
                                  "subSteps": [
                                    "Ler e citar Teorema 3.5 de LeVeque (Finite Difference Methods for ODEs/PDEs): convergência O(h² + τ²) para ADI em domínios retangulares.",
                                    "Explicar prova esquemática: consistência + estabilidade monotônica implica convergência.",
                                    "Discutir condições necessárias: malha uniforme, razão h_x / h_y = O(√τ), coeficientes constantes.",
                                    "Comparar com métodos 1D: por que ADI mantém ordem 2 em 2D?",
                                    "Resolver exercício: provar estabilidade via ampliação de von Neumann."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras citando o teorema e condições, com equação de erro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Finite Difference Methods for Ordinary and Partial Differential Equations' de R. J. LeVeque",
                                    "PDF do teorema específico (cap. 10)",
                                    "Acesso online a SIAM artigos"
                                  ],
                                  "tips": "Anote as hipóteses do teorema em bullet points para memorização.",
                                  "learningObjective": "Dominar teoremas rigorosos de convergência para ADI.",
                                  "commonMistakes": [
                                    "Citar teorema errado (confundir com upwind schemes).",
                                    "Ignorar condições de malha não-uniforme."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Numericamente e Discutir Condições de Malha",
                                  "subSteps": [
                                    "Implementar ADI em Python/MATLAB para equação de calor 2D com solução exata.",
                                    "Refinar malhas: h = 1/2^n, τ = h²/4, medir ||e||_∞ em log-log plot.",
                                    "Testar razão de malhas: variar h_x/h_y e observar perda de ordem.",
                                    "Plotar taxas: slope ≈2 confirma convergência ordem 2.",
                                    "Discutir implicações: trade-off computacional vs precisão."
                                  ],
                                  "verification": "Gerar gráfico de erro vs h mostrando slope 2, e relatório de 1 página.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Código template ADI de repositórios GitHub",
                                    "Solução exata: série de Fourier para calor"
                                  ],
                                  "tips": "Use grids log-spaced para eficiência; normalize erros.",
                                  "learningObjective": "Validar teoria com experimentos numéricos e analisar sensibilidade.",
                                  "commonMistakes": [
                                    "Escolha errada de τ levando a instabilidade.",
                                    "Plots lineares em vez de log-log para taxas."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Discussão sobre Taxas de Convergência",
                                  "subSteps": [
                                    "Resumir: ADI converge ordem 2 se h_x²/τ, h_y²/τ bounded e h_x/h_y ~1.",
                                    "Comparar com outros métodos (Crank-Nicolson: similar, mas ADI mais eficiente).",
                                    "Discutir limitações: domínios irregulares, coeficientes variáveis.",
                                    "Preparar exemplos de falha: razão malha extrema.",
                                    "Formular perguntas de discussão para colegas."
                                  ],
                                  "verification": "Criar slide ou handout com resumo, teorema e gráfico numérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de apresentação (PowerPoint/LaTeX Beamer)",
                                    "Resumo anterior dos steps"
                                  ],
                                  "tips": "Use equações chave em negrito para impacto visual.",
                                  "learningObjective": "Integrar conhecimento em uma discussão coerente.",
                                  "commonMistakes": [
                                    "Generalizar sem condições.",
                                    "Omitir referências a LeVeque."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente ADI para resolver u_t = u_xx + u_yy em [0,1]x[0,1] com u=0 nas bordas, u(x,y,0)=sin(πx)sin(πy). Use h_x=h_y=1/50, τ=0.001. Compute erro máximo aos t=0.1,0.5,1.0 e plote log(|e|)/log(h) ≈2, confirmando ordem 2. Varie τ=10 h² para testar condições.",
                              "finalVerifications": [
                                "Explicar verbalmente convergência ordem 2 citando LeVeque.",
                                "Derivar erro de truncamento ADI em quadro.",
                                "Interpretar gráfico numérico mostrando slope 2.",
                                "Listar 3 condições de malha necessárias.",
                                "Comparar ADI vs método explícito em eficiência.",
                                "Discutir falha se h_x >> h_y."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação do teorema de LeVeque (20%)",
                                "Correção na derivação de erro local (25%)",
                                "Qualidade do experimento numérico e plots (25%)",
                                "Clareza na discussão de condições (15%)",
                                "Integração de teoria e prática (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão de calor/fluidos em 2D.",
                                "Computação Científica: Otimização de solvers iterativos em HPC.",
                                "Engenharia: Simulações CFD com malhas adaptativas.",
                                "Estatística: Análise de erro em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de reservatórios petrolíferos (origem do ADI), modela fluxo multifásico 2D com convergência ordem 2 garantindo precisão em previsões de produção; em finanças, resolve equações de Black-Scholes 2D para opções exóticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.4",
                            "name": "Avaliar dissipação e dispersão",
                            "description": "Interpretar noções de dissipação numérica e dispersão fase nos métodos ADI, comparando com esquemas explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Dissipação Numérica e Dispersão de Fase",
                                  "subSteps": [
                                    "Defina dissipação numérica como o amortecimento artificial de modos de alta frequência devido a truncagem de erro.",
                                    "Explique dispersão de fase como o erro na velocidade de propagação de ondas, onde ξ_num ≠ ξ_exato.",
                                    "Revise o símbolo de amplificação g(κh) para esquemas parabólicos, identificando |g| < 1 para dissipação e arg(g) ≠ -κ²Δt/2 para dispersão.",
                                    "Analise o papel do operador de Laplace em equações parabólicas u_t = Δu.",
                                    "Discuta impacto qualitativo: dissipação suaviza solução, dispersão causa oscilações."
                                  ],
                                  "verification": "Escreva definições precisas e esboce gráficos de |g| e arg(g) vs κh para um esquema modelo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula sobre estabilidade de Von Neumann.",
                                  "tips": "Use análise de Von Neumann: assuma solução u_j^n = g^n e^{i κ j h}.",
                                  "learningObjective": "Compreender as noções qualitativas e quantitativas de dissipação e dispersão.",
                                  "commonMistakes": "Confundir dissipação (amplitude) com dispersão (fase); ignorar dependência em κh."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Dissipação e Dispersão em Esquemas Explícitos",
                                  "subSteps": [
                                    "Implemente esquema FTCS para u_t = u_xx: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n), r = Δt/Δx² ≤ 1/2.",
                                    "Calcule símbolo de amplificação g(k) = 1 - 4r sin²(kh/2), onde k=κ.",
                                    "Avalie dissipação: |g(k)| ≈ 1 - 2r (kh)² para kh<<1, mas |g|→0 para kh=π (dissipação excessiva).",
                                    "Avalie dispersão: arg(g) ≈ -2r sin²(kh/2) ≠ - (kh)²/2 para kh moderado.",
                                    "Plote |g(kh)| e arg(g)/-(kh)² vs kh para visualizar erros."
                                  ],
                                  "verification": "Gere plots mostrando dissipação numérica forte em altas frequências e dispersão de fase.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python/MATLAB com NumPy/Matplotlib, código template para análise Von Neumann.",
                                  "tips": "Varra kh de 0 a π; normalize arg(g) pela solução exata.",
                                  "learningObjective": "Quantificar erros em esquemas explícitos como baseline para comparação.",
                                  "commonMistakes": "Esquecer limite de estabilidade r≤1/2; plotar sem normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Métodos ADI e Sua Análise de Dissipação/Dispersão",
                                  "subSteps": [
                                    "Revise ADI para 2D: u_t = u_xx + u_yy; passo x: (I - r σ_x L_x) u* = (I + r σ_x L_x) u^n; passo y similar.",
                                    "Derive símbolo de amplificação para ADI: g = [1 - 4r sin²(α/2)] / [1 + 4r sin²(α/2)] onde α=kh_x ou kh_y alternado.",
                                    "Analise dissipação: |g| ≈ 1 - 4r² sin⁴(α/2) (dissipação de 4ª ordem baixa).",
                                    "Analise dispersão: arg(g) ≈ -2r sin²(α/2) + O(r³), melhor que explícito.",
                                    "Compare numericamente com Douglas-Rachford ou Peaceman-Rachford variantes."
                                  ],
                                  "verification": "Calcule e compare |g_ADI| e arg(g_ADI) com exato para kh_x = kh_y.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Referências: Mitchell & Griffiths 'Finite Difference Methods'; código ADI simbólico em SymPy.",
                                  "tips": "ADI é incondicionalmente estável; foque em precisão de fase/amplitude.",
                                  "learningObjective": "Interpretar análise Von Neumann específica para ADI.",
                                  "commonMistakes": "Confundir fator de iteração ADI com g único; ignorar alternância de direções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ADI com Esquemas Explícitos e Avaliar Vantagens",
                                  "subSteps": [
                                    "Implemente simulação 2D: u_t = Δu em malha 100x100, condições iniciais gaussiana.",
                                    "Rode explícito (com r=0.4) vs ADI (r=10), compare soluções em t fixo.",
                                    "Quantifique dissipação: integre energia ||u||², decay rate.",
                                    "Quantifique dispersão: fase de Fourier modes específicas.",
                                    "Tabule erros: dissipação ADI ~O(Δt²), explícito ~O(Δt); dispersão similar mas ADI permite Δt grande."
                                  ],
                                  "verification": "Relatório com tabelas/plots mostrando ADI com menos dissipação e dispersão para Δt maior.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código Python para solvers ADI/explícito, FFT para análise espectral.",
                                  "tips": "Use FFT para extrair espectro e medir erros por modo.",
                                  "learningObjective": "Comparar quantitativamente, destacando trade-offs de ADI.",
                                  "commonMistakes": "Não isolar efeitos (boundary vs numéricos); r muito grande sem verificação."
                                }
                              ],
                              "practicalExample": "Simule a equação de calor 2D u_t = Δu com pico gaussiano inicial em malha 128x128. Use esquema explícito com Δt=0.1 (r=0.25) e ADI com Δt=2 (r=5). Em t=1, plote soluções, espectros FFT e erros L2. Observe: explícito dissipa alto-freq excessivamente e dispersa ondas; ADI preserva melhor.",
                              "finalVerifications": [
                                "Calcula corretamente g(k) para FTCS e ADI, com |g|<1 estável.",
                                "Interpreta plots: dissipação numérica em ADI é O(Δt²) vs O(Δt) explícito.",
                                "Identifica dispersão de fase via arg(g) ≠ exato em ambos, mas menor em ADI.",
                                "Compara em simulação: ADI permite Δt 10x maior sem instabilidade.",
                                "Explica qualitativamente: ADI reduz dissipação por tratamento implícito.",
                                "Verifica energia decay matches análise teórica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de símbolos de amplificação (90% correto).",
                                "Qualidade de plots e interpretação qualitativa/quantitativa.",
                                "Correta identificação de erros comuns em explícito vs ADI.",
                                "Profundidade da comparação numérica (múltiplos Δt testados).",
                                "Clareza no relatório: objetivos, métodos, resultados, conclusões.",
                                "Uso apropriado de ferramentas (Von Neumann, FFT)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica/concentração, análise de erros em simulações.",
                                "Engenharia Computacional: Otimização de solvers para PDEs em HPC.",
                                "Ciência da Computação: Análise de estabilidade em algoritmos paralelizáveis (ADI).",
                                "Matemática Aplicada: Teoria de aproximação e análise assintótica."
                              ],
                              "realWorldApplication": "Em simulações CFD para previsão climática ou reservatórios de óleo, ADI minimiza dissipação artificial em frentes de onda, permitindo passos de tempo maiores e precisão em larga escala sem supercomputadores excessivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Equações Elípticas",
                "description": "Tratamento de condições de Dirichlet e de Neumann em equações elípticas.",
                "totalSkills": 56,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Método de Diferenças Finitas para Equações Elípticas",
                    "description": "Aplicação do método de diferenças finitas à discretização de equações elípticas, como a equação de Laplace ou Poisson.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Discretização da Equação de Laplace e Poisson",
                        "description": "Aplicação do método de diferenças finitas para aproximar a equação de Laplace (∇²u = 0) e Poisson (∇²u = f) em uma malha uniforme bidimensional, gerando um sistema linear.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Derivar o esquema de diferenças finitas centradas para a equação de Laplace",
                            "description": "Derivar a aproximação de segunda ordem para o operador Laplaciano usando diferenças finitas centradas em uma malha retangular uniforme, resultando no stencil de cinco pontos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de Laplace e configurar a malha retangular uniforme",
                                  "subSteps": [
                                    "Escreva a equação de Laplace em 2D: ∂²u/∂x² + ∂²u/∂y² = 0.",
                                    "Defina uma malha retangular uniforme com espaçamento h em ambas as direções x e y.",
                                    "Identifique um ponto interior genérico (x_i, y_j) = (ih, jh) e seus vizinhos: (i±1,j), (i,j±1).",
                                    "Explique o objetivo: aproximar o Laplaciano usando valores nos cinco pontos vizinhos.",
                                    "Desenhe um diagrama da malha destacando o stencil de cinco pontos."
                                  ],
                                  "verification": "Você pode desenhar a malha e rotular corretamente os pontos do stencil.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Use h como espaçamento comum para simplificar notação.",
                                  "learningObjective": "Compreender a configuração geométrica e a equação diferencial a ser discretizada.",
                                  "commonMistakes": [
                                    "Confundir malha uniforme com não-uniforme",
                                    "Esquecer que é ponto interior"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expansão de Taylor para diferenças centradas em uma dimensão",
                                  "subSteps": [
                                    "Escreva as expansões de Taylor para u(x+h) e u(x-h) em torno de x: u(x±h) = u ± h u' + (h²/2) u'' ± (h³/6) u''' + (h⁴/24) u'''' + O(h⁵).",
                                    "Some u(x+h) + u(x-h): 2u + h² u'' + (h⁴/12) u'''' + O(h⁶).",
                                    "Subtraia 2u: h² u'' + (h⁴/12) u'''' + O(h⁶).",
                                    "Divida por h²: u'' + (h²/12) u'''' + O(h⁴) ≈ u'' com erro O(h²).",
                                    "Repita o processo para a direção y, confirmando simetria."
                                  ],
                                  "verification": "Calcule manualmente a soma u(x+h) + u(x-h) - 2u e isole u'' corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de expansões de Taylor"
                                  ],
                                  "tips": "Mantenha os termos pares e ímpares separados para clareza.",
                                  "learningObjective": "Dominar a expansão de Taylor que justifica a precisão de segunda ordem das diferenças centradas.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes de Taylor (ex: h⁴/24 em vez de h⁴/12 após soma)",
                                    "Ignorar termos de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximar a segunda derivada ∂²u/∂x² usando diferenças finitas centradas",
                                  "subSteps": [
                                    "Aplique a fórmula derivada: ∂²u/∂x² ≈ [u(x+h,y) + u(x-h,y) - 2u(x,y)] / h².",
                                    "Na notação da malha: ∂²u_{i,j}/∂x² ≈ [u_{i+1,j} + u_{i-1,j} - 2u_{i,j}] / h².",
                                    "Verifique o erro de truncamento: O(h²), pois o termo líder é (h²/12) ∂⁴u/∂x⁴.",
                                    "Escreva a expressão exata com resto de Taylor.",
                                    "Teste numericamente com u(x,y) = x² (solução exata ∇²u=2)."
                                  ],
                                  "verification": "Substitua u(x,y)=x² e confirme que a aproximação dá exatamente 2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para teste numérico opcional"
                                  ],
                                  "tips": "Sempre normalize dividindo por h² para obter a derivada.",
                                  "learningObjective": "Construir a stencil unidimensional para segundas derivadas com precisão de segunda ordem.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por h²",
                                    "Usar diferenças forward/backward em vez de centradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aproximar ∂²u/∂y² e combinar para o Laplaciano discreto",
                                  "subSteps": [
                                    "Derive analogamente: ∂²u_{i,j}/∂y² ≈ [u_{i,j+1} + u_{i,j-1} - 2u_{i,j}] / h².",
                                    "Some as aproximações: ∇²u_{i,j} ≈ [u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}] / h².",
                                    "Defina a equação discreta: u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0 (para Laplace).",
                                    "Analise o erro total: O(h²) em ambas direções.",
                                    "Esboce o stencil de cinco pontos com coeficientes: 0 nos diagonais, -4 no centro, 1 nos cardeais."
                                  ],
                                  "verification": "Escreva a equação matricial para o ponto (i,j) sem erros de sinal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis coloridos para stencil"
                                  ],
                                  "tips": "Visualize o stencil como uma cruz para lembrar os vizinhos.",
                                  "learningObjective": "Formar o operador Laplaciano discreto completo em 2D.",
                                  "commonMistakes": [
                                    "Sinal errado nos vizinhos (deve ser +1)",
                                    "Coeficiente -4 incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a precisão e generalizar para equação de Poisson",
                                  "subSteps": [
                                    "Confirme a consistência: ao h→0, stencil converge para ∇²u.",
                                    "Estime erro local: O(h²) devido a termos mistos ∂⁴u/∂x²∂y² negligible em malha quadrada.",
                                    "Estenda para Poisson: ∇²u = f → stencil / h² = f_{i,j}.",
                                    "Discuta simetria e propriedades (matriz sparsa, positiva definida).",
                                    "Resolva um exemplo simples: u=0 em fronteiras, f=0."
                                  ],
                                  "verification": "Derive o erro de truncamento total e confirme segunda ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência: livro de análise numérica"
                                  ],
                                  "tips": "Lembre que para Poisson, o termo fonte é multiplicado por h² no lado direito.",
                                  "learningObjective": "Validar a derivação e entender extensões práticas.",
                                  "commonMistakes": [
                                    "Confundir Laplace (f=0) com Poisson",
                                    "Subestimar ordem de precisão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma malha 5x5 com h=0.1, para o ponto (2,2), derive ∇²u_{2,2} ≈ [u_{3,2} + u_{1,2} + u_{2,3} + u_{2,1} - 4u_{2,2}] / 0.01 = 0, e verifique com u(x,y)=x² + y² (∇²u=4).",
                              "finalVerifications": [
                                "Escrever corretamente o stencil de cinco pontos: u_{i±1,j} + u_{i,j±1} - 4u_{i,j} = 0.",
                                "Explicar por que é de segunda ordem usando Taylor.",
                                "Aplicar a uma função teste e confirmar precisão numérica.",
                                "Distinguir de esquemas forward/backward (primeira ordem).",
                                "Generalizar para Poisson com termo f_{i,j} h².",
                                "Desenhar stencil sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (coeficientes corretos).",
                                "Correção dos sinais e normalização por h².",
                                "Identificação correta do erro O(h²).",
                                "Clareza na combinação x e y para stencil 2D.",
                                "Capacidade de verificar com exemplo numérico.",
                                "Compreensão de extensões (Poisson, propriedades)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Potencial eletrostático (equações de Laplace em eletromagnetismo).",
                                "Computação: Implementação em solvers numéricos (iterativos como Gauss-Seidel).",
                                "Engenharia: Simulações de fluxo incompressível (vórtice em fluidodinâmica).",
                                "Programação: Codificação do stencil em Python/NumPy para PDEs."
                              ],
                              "realWorldApplication": "Usado em simulações de campos gravitacionais, potenciais térmicos em engenharia, modelagem de fluxo de groundwater e processamento de imagens (filtros Laplacianos para detecção de bordas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Montar o sistema linear a partir da discretização",
                            "description": "Construir a matriz esparsa tridiagonal ou pentadiagonal do sistema Au = b para a equação de Poisson em domínio retangular, identificando os coeficientes para pontos internos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a discretização da equação de Poisson em domínio retangular",
                                  "subSteps": [
                                    "Defina a equação de Poisson: ∇²u = f(x,y) em um retângulo Ω com condições de contorno.",
                                    "Escolha uma malha uniforme com h = Δx = Δy, pontos internos (i,j) para i=2..Nx-1, j=2..Ny-1.",
                                    "Aplique a aproximação de diferenças finitas centradas: (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² ≈ f_{i,j}.",
                                    "Multiplique por h² para obter a stencil: -4u_{i,j} + u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} = h² f_{i,j}.",
                                    "Identifique os pontos de contorno e como eles afetam os internos."
                                  ],
                                  "verification": "Escreva a equação discretizada para um ponto interno genérico (i,j) e confirme que os coeficientes somam zero no lado esquerdo (propriedade de Laplace).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Notebook com equação de Poisson anotada",
                                    "Software de desenho de malha (opcional, como GeoGebra)"
                                  ],
                                  "tips": "Visualize a malha em um grid 5x5 para intuitivamente entender vizinhos.",
                                  "learningObjective": "Compreender a stencil de 5 pontos da discretização da equação de Poisson.",
                                  "commonMistakes": [
                                    "Esquecer de multiplicar por h²",
                                    "Confundir Δx com Δy em malhas não quadradas",
                                    "Ignorar condições de contorno nos pontos adjacentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar os coeficientes para pontos internos e formar linhas da matriz",
                                  "subSteps": [
                                    "Para um ponto interno, o coeficiente diagonal é -4, e off-diagonais (vizinhos) são +1.",
                                    "Numere os desconhecidos u em ordem natural: k = (i-1)*(Ny-1) + (j-1) para pontos internos.",
                                    "Escreva a equação para cada k: soma de coeficientes vezes u_vizinhos = h² f_{i,j}.",
                                    "Identifique posições na matriz A: diagonal principal -4, super/subdiagonal 1 (horizontal), e bandas para vertical dependendo da ordenação.",
                                    "Confirme que A é simétrica e esparsa (tridiagonal em 1D, pentadiagonal em 2D com ordenação por linhas)."
                                  ],
                                  "verification": "Monte a linha da matriz para um ponto específico e verifique se corresponde à stencil.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado para malha 4x4",
                                    "Python com NumPy para protótipo rápido"
                                  ],
                                  "tips": "Use ordenação por linhas (row-major) para manter banda estreita.",
                                  "learningObjective": "Identificar e anotar coeficientes exatos para entradas da matriz A.",
                                  "commonMistakes": [
                                    "Ordenação errada de índices levando a matriz não-banded",
                                    "Coeficientes errados perto de contornos",
                                    "Confundir vetor u com valores de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz esparsa A e vetor b completos",
                                  "subSteps": [
                                    "Incorpore condições de Dirichlet: para pontos na borda, substitua u_borda por valores conhecidos e ajuste coeficientes.",
                                    "Crie estrutura esparsa: liste índices não-zero (i,j,val) para formato CSR ou liste por linhas.",
                                    "Monte vetor b: b_k = h² f_{i,j} + ajustes de contorno (ex: +u_borda para vizinhos de borda).",
                                    "Para malha Nx x Ny, dim(A) = (Nx-1)(Ny-1), confirme tamanho.",
                                    "Implemente em código para validar: gere A e b para malha pequena."
                                  ],
                                  "verification": "Multiplique A * u_conhecido (solução exata aproximada) e veja se ≈ b.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com SciPy.sparse ou MATLAB",
                                    "Exemplo de código template para diferenças finitas"
                                  ],
                                  "tips": "Comece com malha 3x3 (1 ponto interno) para depurar.",
                                  "learningObjective": "Montar sistema Au=b completo, incluindo tratamento de contornos.",
                                  "commonMistakes": [
                                    "Não ajustar b para contornos Dirichlet",
                                    "Índices off-by-one em numeração",
                                    "Matriz não simétrica devido a erros de simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar a representação esparsa",
                                  "subSteps": [
                                    "Verifique esparsidade: número de não-zeros ≈ 5 * dim para interior.",
                                    "Confirme tridiagonal/pentadiagonal: visualize com spy plot.",
                                    "Teste com f=0 (Laplace): solução harmônica deve satisfazer.",
                                    "Otimize para solvers: identifique propriedades (diagonal dominante, positiva definida).",
                                    "Documente o sistema para uso em solvers iterativos como Gauss-Seidel."
                                  ],
                                  "verification": "Gere spy plot ou imprima bandas e confirme largura de banda.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Jupyter Notebook com Matplotlib e SciPy",
                                    "Exemplo de malha 10x10"
                                  ],
                                  "tips": "Use csr_matrix no SciPy para eficiência.",
                                  "learningObjective": "Garantir que o sistema montado é correto e pronto para resolução.",
                                  "commonMistakes": [
                                    "Sobrecarregar memória com matriz densa para malhas grandes",
                                    "Ignorar propriedades para escolha de solver",
                                    "Erros em ajustes de contorno levando a b incorreto"
                                  ]
                                }
                              ],
                              "practicalExample": "Para equação de Poisson ∇²u = -2π² sin(πx) sin(πy) em [0,1]x[0,1] com u=0 na borda, malha 4x4 (h=1/3). Ponto interno (2,2): stencil dá linha na matriz com -4 na diag, +1 nos vizinhos. A é 9x9 pentadiagonal, b_k = h² f_{i,j}. Solução exata u=sin(πx)sin(πy) valida Au≈b.",
                              "finalVerifications": [
                                "Matriz A é simétrica e esparsa com largura de banda  Ny-1.",
                                "Para f=0, Au=0 só para u=0 (propriedade de unicidade).",
                                "Coeficientes somam zero por linha no interior (Laplace homogêneo).",
                                "Ajustes de contorno corretos: b inclui contribuições de u_borda.",
                                "Dimensão de A equals número de pontos internos.",
                                "Teste numérico: ||Au - b|| < 1e-10 para solução conhecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da stencil (coeficientes corretos).",
                                "Correta numeração e indexação de variáveis.",
                                "Tratamento adequado de condições de contorno em A e b.",
                                "Representação esparsa eficiente (não densa).",
                                "Validação numérica com exemplo pequeno.",
                                "Explicação clara de propriedades da matriz (simetria, diagonal dominante)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potencial eletrostático ou fluxo de calor (Equações de Maxwell/Poisson).",
                                "Computação: Algoritmos para matrices esparsas e solvers iterativos (SciPy, PETSc).",
                                "Engenharia: Simulações CFD em domínios retangulares.",
                                "Programação: Implementação de grids e loops aninhados em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em simulações de engenharia, como previsão de distribuição de temperatura em placas retangulares (indústria aeroespacial) ou campos magnéticos em dispositivos eletrônicos, onde o sistema Au=b é resolvido para otimizar designs e prever falhas térmicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Implementar discretização em código simples",
                            "description": "Escrever um código em pseudocódigo ou Python para gerar a matriz e o vetor de lado da discretização da equação de Poisson em uma malha 2D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a malha 2D uniforme e parâmetros iniciais",
                                  "subSteps": [
                                    "Escolha dimensões da malha NxM (ex: N=10, M=10 pontos internos)",
                                    "Calcule o espaçamento h = L / (N-1), assumindo domínio unitário L=1",
                                    "Crie arrays ou listas para representar os pontos da grid (i=0 a N-1, j=0 a M-1)",
                                    "Defina a função f(x,y) para o lado direito da equação de Poisson",
                                    "Especifique condições de contorno (Dirichlet: u nas bordas)"
                                  ],
                                  "verification": "Verifique se o número total de pontos desconhecidos é (N-2)*(M-2) e h está correto",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python ou pseudocódigo",
                                    "Papel para esboçar grid"
                                  ],
                                  "tips": "Comece com malha pequena (3x3) para depuração visual",
                                  "learningObjective": "Representar geometricamente a malha computacional para discretização",
                                  "commonMistakes": [
                                    "Confundir número de pontos com intervalos (N pontos têm N-1 h's)",
                                    "Ignorar bordas na contagem de incógnitas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e codificar o stencil de diferenças finitas para pontos interiores",
                                  "subSteps": [
                                    "Escreva a aproximação: (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}) / h² = f_{i,j}",
                                    "Multiplique por h² para obter: -4u_{i,j} + u_{i+1,j} + ... = h² f_{i,j}",
                                    "Implemente função para gerar coeficientes do stencil: diag=-4, off-diag=1",
                                    "Mapeie índices 2D (i,j) para 1D k = i*(M-2) + j para vetor u",
                                    "Codifique loop sobre pontos interiores para preencher linhas da matriz A"
                                  ],
                                  "verification": "Para um ponto interior, linha da matriz A deve ter -4 na diagonal e 1's nos vizinhos",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy para matriz esparsa/densa",
                                    "Documentação SciPy sparse"
                                  ],
                                  "tips": "Use indexação 1D para eficiência; teste stencil em grid 3x3 manualmente",
                                  "learningObjective": "Aplicar diferenças finitas centradas à equação elíptica em 2D",
                                  "commonMistakes": [
                                    "Erro no mapeamento 2D para 1D (off-by-one)",
                                    "Esquecer multiplicar f por h²"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar condições de contorno Dirichlet no vetor b e matriz A",
                                  "subSteps": [
                                    "Para pontos na borda, mova termos conhecidos u_borda para o lado direito",
                                    "Exemplo: para i=1 (borda esquerda), u_{0,j} conhecido → coef +1 em A vira -u_{0,j} em b",
                                    "Implemente loops separados para bordas esquerda, direita, inferior, superior",
                                    "Atualize vetor b[k] += coef * u_borda para cada vizinho de contorno",
                                    "Verifique simetria da matriz A para contornos homogêneos"
                                  ],
                                  "verification": "Em malha com contornos zero, b deve conter apenas h² f nos interiores",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy arrays para A (NxN) e b (N)",
                                    "Exemplo de grid pequeno"
                                  ],
                                  "tips": "Trate bordas em ordem: interiores primeiro, depois ajuste contornos",
                                  "learningObjective": "Integrar condições de contorno na formulação matricial",
                                  "commonMistakes": [
                                    "Não mover termos de contorno corretamente (sinal errado em b)",
                                    "Aplicar stencil em bordas sem ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar código completo, testar e validar",
                                  "subSteps": [
                                    "Escreva função principal: def discretize_poisson(N, M, f_func, u_bc_func):",
                                    "Monte A como matriz densa ou esparsa (scipy.sparse.csr_matrix)",
                                    "Gere b com f e contornos",
                                    "Teste com caso Laplace (f=0, contornos simples) e resolva Au=b com np.linalg.solve",
                                    "Visualize solução com matplotlib (heatmap de u)"
                                  ],
                                  "verification": "Solução converge para caso conhecido (ex: u=x^2 + y^2 tem ∇²u=-4)",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python, NumPy, SciPy, Matplotlib"
                                  ],
                                  "tips": "Use %matplotlib inline no Jupyter; compare com solução analítica",
                                  "learningObjective": "Gerar sistema linear completo pronto para solvers iterativos",
                                  "commonMistakes": [
                                    "Matriz A não simétrica/negativamente definida",
                                    "Índices invertidos em plot"
                                  ]
                                }
                              ],
                              "practicalExample": "Para malha 5x5 (h=0.25), f(x,y)=0 (Laplace), u=sin(πx) nas bordas horizontais e u=0 verticais. Código deve gerar A 9x9 (3x3 internos) com diagonais -4/h² e b incorporando senos nas bordas.",
                              "finalVerifications": [
                                "Código executa sem erros e gera A e b corretos para grid 4x4",
                                "Matriz A é simétrica e dominante diagonalmente para estabilidade",
                                "Para f=0 e contornos homogêneos, solução u=0",
                                "Solução numérica converge à analítica em refinamento h→0",
                                "Tempo de montagem O(NM) escalável",
                                "Visualização mostra solução suave sem oscilações"
                              ],
                              "assessmentCriteria": [
                                "Precisão da discretização (stencil correto e h² f)",
                                "Correta incorporação de contornos em b",
                                "Eficiência: uso de loops vetorizados ou esparso",
                                "Clareza do código com comentários e nomes de variáveis",
                                "Validação com testes unitários simples",
                                "Tratamento de casos edge (malha 2x2 inválida)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de arrays multidim em Python/NumPy",
                                "Álgebra Linear: Montagem e solução de sistemas esparsos",
                                "Física: Modelagem de potencial eletrostático ou temperatura",
                                "Engenharia Computacional: Pré-processador em simulações FEM/FDM",
                                "Visualização de Dados: Plots 2D com Matplotlib/Seaborn"
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em placas com fontes de calor (engenharia térmica), campos elétricos em capacitores irregulares (eletrônica), ou modelagem de fluxo incompressível em reservatórios (petróleo/geofísica)"
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Condições de Contorno Dirichlet e Neumann",
                        "description": "Incorporação das condições de contorno de Dirichlet (valor fixo) e Neumann (derivada normal fixa) no método de diferenças finitas para equações elípticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Aplicar condições de Dirichlet na discretização",
                            "description": "Modificar o sistema linear para impor condições de Dirichlet em bordas da malha, ajustando linhas da matriz e vetor de lado para valores conhecidos de u.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar pontos da malha sujeitos a condições de Dirichlet",
                                  "subSteps": [
                                    "Defina a malha uniforme ou não-uniforme no domínio (ex: malha 1D ou 2D com h = passo espacial).",
                                    "Liste todos os nós da malha e classifique-os como internos ou de borda.",
                                    "Marque os nós de borda onde u é conhecido (condições de Dirichlet) e anote os valores conhecidos u_b.",
                                    "Crie um vetor de índices para mapear nós Dirichlet aos índices do sistema linear.",
                                    "Verifique se todas as bordas especificadas estão cobertas pela condição Dirichlet."
                                  ],
                                  "verification": "Lista completa de nós Dirichlet com valores u_b corretos e índices mapeados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para esboçar malha",
                                    "Software de programação (Python/MATLAB) para gerar malha"
                                  ],
                                  "tips": "Comece com uma malha 1D simples para praticar antes de 2D.",
                                  "learningObjective": "Reconhecer e catalogar precisamente os pontos onde condições de Dirichlet se aplicam.",
                                  "commonMistakes": [
                                    "Confundir nós internos com de borda",
                                    "Esquecer valores conhecidos em nós mistos (Dirichlet/Neumann)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz e vetor rhs para pontos internos (estêncil padrão)",
                                  "subSteps": [
                                    "Para cada nó interno, derive o estêncil de diferenças finitas centradas (ex: para Laplace 1D: (u_{i-1} - 2u_i + u_{i+1})/h^2 = 0).",
                                    "Monte as linhas da matriz A correspondentes aos nós internos com coeficientes do estêncil.",
                                    "Inicialize o vetor rhs b com termos fonte f para nós internos (b_i = h^2 f_i).",
                                    "Mantenha linhas de Dirichlet zeradas inicialmente para modificação posterior.",
                                    "Teste a simetria e estrutura esparsa da matriz parcial."
                                  ],
                                  "verification": "Matriz A parcial simétrica positiva definida para subdomínio interno; rhs consistente com f.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Jupyter Notebook)",
                                    "Bibliotecas NumPy/SciPy para matrizes esparsas"
                                  ],
                                  "tips": "Use índices locais para estêncil: coeficientes -1, 4, -1 em 1D para Laplace.",
                                  "learningObjective": "Dominar a montagem do sistema linear sem condições de contorno.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes do estêncil (ex: sinal errado)",
                                    "Não escalar rhs por h^2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar sistema linear para impor condições de Dirichlet",
                                  "subSteps": [
                                    "Para cada nó j Dirichlet, defina A[j,j] = 1 e A[j,k] = 0 para k ≠ j.",
                                    "Atualize b[j] = u_b (valor conhecido em nó j).",
                                    "Se houver nós vizinhos internos afetados, ajuste contribuições já montadas (opcional para precisão).",
                                    "Repita para todos nós Dirichlet em todas as bordas.",
                                    "Confirme que o sistema agora força u_j = u_b na solução."
                                  ],
                                  "verification": "Linhas de Dirichlet na matriz A têm apenas 1 na diagonal e 0 elsewhere; b[j] = u_b.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python/MATLAB com loops para modificação",
                                    "Matriz esparsa (sparse matrix)"
                                  ],
                                  "tips": "Implemente como função separada para reutilização em malhas maiores.",
                                  "learningObjective": "Aplicar modificações exatas nas linhas da matriz e rhs para enforçar Dirichlet.",
                                  "commonMistakes": [
                                    "Esquecer de zerar off-diagonais",
                                    "Colocar valor errado em b[j] (ex: escalado por h)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a discretização completa",
                                  "subSteps": [
                                    "Resolva o sistema Au = b numericamente (ex: solver direto ou iterativo).",
                                    "Verifique se solução u satisfaz u_j ≈ u_b em nós Dirichlet (erro < 1e-10).",
                                    "Compare com solução analítica conhecida (ex: caso teste).",
                                    "Analise convergência variando h e refine malha.",
                                    "Documente o sistema final A e b para inspeção."
                                  ],
                                  "verification": "Solução numérica converge e respeita BCs Dirichlet; ordem de precisão O(h^2).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Solver linear (scipy.linalg.solve ou sparse)",
                                    "Gráficos para plotar solução u vs exata"
                                  ],
                                  "tips": "Use casos teste com solução conhecida como u(x)=sin(pi x) para validar.",
                                  "learningObjective": "Garantir correção e robustez da imposição de Dirichlet na discretização.",
                                  "commonMistakes": [
                                    "Solver falha por matriz mal-condicionada",
                                    "Não verificar BCs pós-solução"
                                  ]
                                }
                              ],
                              "practicalExample": "Em 1D, resolva -u'' = pi^2 sin(pi x) em [0,1] com u(0)=0, u(1)=0. Malha com N=10 pontos: para i=1 (x=0), A[1,1]=1, b[1]=0; i=10 (x=1), A[10,10]=1, b[10]=0. Internos usam estêncil, solução u ≈ sin(pi x).",
                              "finalVerifications": [
                                "Linhas de nós Dirichlet têm identidade unitária na matriz A.",
                                "Vetor b reflete exatamente valores u_b conhecidos.",
                                "Solução numérica satisfaz |u_j - u_b| < tol em todos nós Dirichlet.",
                                "Matriz A permanece simétrica e definida positiva.",
                                "Convergência observada reduzindo h (erro O(h^2)).",
                                "Nenhum NaN ou overflow na solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e mapeamento de nós Dirichlet (100% cobertura).",
                                "Correção dos coeficientes de estêncil e modificações (erro < 1e-12).",
                                "Eficiência da implementação (tempo de montagem O(N)).",
                                "Validação robusta com múltiplos casos teste.",
                                "Clareza no código e documentação de passos.",
                                "Tratamento de malhas 2D estendido corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos escalares (temperatura, potencial) em equações de Poisson.",
                                "Programação: Manipulação de matrizes esparsas e solvers lineares (NumPy, PETSc).",
                                "Engenharia: Simulações CFD e FEM para contornos Dirichlet em estruturas.",
                                "Estatística: Condições de contorno em processos estocásticos e PDEs.",
                                "Ciência de Dados: Discretização em ML para PDE solvers neurais."
                              ],
                              "realWorldApplication": "Em simulações de transferência de calor, impor temperatura fixa (Dirichlet) nas bordas de uma placa metálica para prever distribuição interna de calor em fornos industriais ou chips eletrônicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Implementar condições de Neumann usando diferenças finitas",
                            "description": "Aproximar a derivada normal com diferenças finitas de primeira ou segunda ordem nas bordas e incorporar no stencil, garantindo simetria da matriz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Condições de Neumann e Derivada Normal",
                                  "subSteps": [
                                    "Revise a definição de condição de Neumann: ∂u/∂n = g na borda Γ.",
                                    "Identifique a derivada normal em malhas 1D (ex.: u' em x=0 ou x=1) e 2D (gradiente · n).",
                                    "Estude o impacto em equações elípticas como Poisson: garante fluxo ou fluxo zero.",
                                    "Desenhe um domínio simples (intervalo [0,1]) com bordas Neumann.",
                                    "Compare com Dirichlet para entender diferenças no stencil."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a condição Neumann afeta o stencil de diferenças finitas em uma borda.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex.: LeVeque), caderno para diagramas, software de desenho (opcional)"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar a normal apontando para fora do domínio.",
                                    "Lembre-se: Neumann homogênea implica isolamento (fluxo zero)."
                                  ],
                                  "learningObjective": "Entender o significado físico e matemático das condições de Neumann em problemas elípticos.",
                                  "commonMistakes": [
                                    "Confundir derivada normal com tangencial.",
                                    "Ignorar o sinal da normal (direção externa)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aproximar Derivada Normal com Diferenças Finitas de Primeira Ordem",
                                  "subSteps": [
                                    "Para borda esquerda (x=0), aproxime u'(0) ≈ (u_1 - u_0)/h.",
                                    "Para borda direita (x=1), u'(1) ≈ (u_N - u_{N-1})/h.",
                                    "Substitua na equação elíptica: para -u''=f, stencil interior -u_{i-1} + 2u_i - u_{i+1} = h²f_i.",
                                    "Modifique stencil na borda: para esquerda, u_1 - 2u_0 = -h²f_0 + h g_0 (ajustar sinal).",
                                    "Escreva as equações para ambas as bordas."
                                  ],
                                  "verification": "Derive e escreva o stencil modificado para uma borda esquerda com u'(0)=g.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado, calculadora, código Python/MATLAB para stencil simbólico (SymPy)"
                                  ],
                                  "tips": [
                                    "Mantenha consistência no sinal: normal externa para esquerda é -direção x.",
                                    "Teste com g=0 para verificar simetria."
                                  ],
                                  "learningObjective": "Derivar aproximações de diferenças finitas de 1ª ordem para derivadas normais em bordas.",
                                  "commonMistakes": [
                                    "Erro no fator h (esquecer h² no lado direito).",
                                    "Stencil assimétrico sem ajuste para simetria."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Aproximação de Segunda Ordem e Stencil Assimétrico",
                                  "subSteps": [
                                    "Introduza ponto fantasma fora do domínio para 2ª ordem: para x=0, u_{-1} = u_1 - 2h g.",
                                    "Aproxime u'(0) ≈ (-3u_0 + 4u_1 - u_2)/(2h) para precisão O(h²).",
                                    "Substitua no stencil central: para borda esquerda, combine para stencil de 3 pontos.",
                                    "Faça o mesmo para borda direita com aproximação forward/backward.",
                                    "Monte a matriz tridiagonal completa para o sistema Au=b."
                                  ],
                                  "verification": "Construa a matriz A para N=5 pontos e verifique se é simétrica (A=A^T).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy, MATLAB, papel para matriz pequena"
                                  ],
                                  "tips": [
                                    "Use ponto fantasma para manter stencil central simétrico.",
                                    "Verifique ordem de precisão truncando erro Taylor."
                                  ],
                                  "learningObjective": "Desenvolver stencils de 2ª ordem para condições de Neumann preservando simetria.",
                                  "commonMistakes": [
                                    "Ponto fantasma com sinal errado.",
                                    "Matriz não simétrica devido a inconsistência no h."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar no Algoritmo, Resolver e Verificar",
                                  "subSteps": [
                                    "Implemente código para gerar matriz A e vetor b com condições Neumann mistas.",
                                    "Resolva Au=b usando solver direto (ex.: numpy.linalg.solve).",
                                    "Compare com solução analítica ou refinamento h para convergência O(h) ou O(h²).",
                                    "Teste casos: Neumann homogênea (soma de solução constante), não-homogênea.",
                                    "Analise simetria: compute norma ||A - A.T|| < 1e-12."
                                  ],
                                  "verification": "Execute código para problema teste e confirme erro < 1% vs. solução exata.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/Jupyter com NumPy, SciPy; exemplo de código base para Poisson 1D"
                                  ],
                                  "tips": [
                                    "Inicie com 1D antes de 2D. Use grids finos para validar.",
                                    "Salve matriz para inspeção visual."
                                  ],
                                  "learningObjective": "Implementar e validar numericamente condições de Neumann em diferenças finitas.",
                                  "commonMistakes": [
                                    "Índices off-by-one em bordas.",
                                    "Esquecer escalar b com h²f."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -u'' = π² sin(πx) em [0,1] com u'(0)=0 (isolamento), u'(1)=π cos(π) = -π (fluxo). Solução exata: u(x)=sin(πx). Use h=0.1, implemente stencil 2ª ordem, resolva e plote erro.",
                              "finalVerifications": [
                                "Matriz A é simétrica positiva definida (autovalores >0).",
                                "Solução satisfaz condição Neumann: |∂u_h/∂n - g| < O(h) nas bordas.",
                                "Erro L2 global < 1e-3 para h=0.05.",
                                "Convergência observada ao refinar malha (log-log plot).",
                                "Teste com Neumann homogênea: solução média preserva massa/conservação.",
                                "Código roda sem erros para 2D retangular simples."
                              ],
                              "assessmentCriteria": [
                                "Correção da aproximação da derivada normal (1ª/2ª ordem identificada).",
                                "Stencil nas bordas incorporado corretamente no sistema linear.",
                                "Matriz resultante é simétrica e sparse.",
                                "Implementação numérica convergente e eficiente (O(N)).",
                                "Validação com exemplo prático e análise de erro.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de fluxo de calor/difusão com isolamento (Leis de Fourier).",
                                "Programação: Algoritmos numéricos em Python/NumPy, solvers lineares (SciPy).",
                                "Engenharia: Simulações CFD/FEM para contornos Neumann (pressão/fluxo).",
                                "Estatística: Métodos Monte Carlo para problemas elípticos similares.",
                                "Matemática Aplicada: Análise de estabilidade e consistência do método."
                              ],
                              "realWorldApplication": "Simulação de isolamento térmico em paredes (Neumann zero), cálculo de gradientes de potencial em eletrostática com fluxo especificado, modelagem de aquíferos com fluxo de água conhecido nas fronteiras em hidrogeologia."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Combinar condições mistas Dirichlet-Neumann",
                            "description": "Construir o sistema para domínios com condições de contorno mistas, verificando a consistência e a propriedade de simetria positiva definida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definição do Problema e Configuração da Malha",
                                  "subSteps": [
                                    "Identifique o domínio Ω (ex: retângulo [0,1]×[0,1]) e divida as fronteiras em Γ_D (Dirichlet: u conhecida) e Γ_N (Neumann: ∂u/∂n conhecida).",
                                    "Escolha o passo de malha h = 1/N e crie uma grade uniforme com pontos internos e fronteira.",
                                    "Especifique a equação elíptica -Δu = f em Ω, com condições u = g em Γ_D e ∂u/∂n = h em Γ_N.",
                                    "Desenhe a malha destacando pontos Dirichlet (fixos) e Neumann (derivadas aproximadas).",
                                    "Verifique compatibilidade: ∫_Γ_N h ds = ∫_Ω f dx (condição de solvibilidade)."
                                  ],
                                  "verification": "Malha desenhada com Γ_D e Γ_N corretamente rotulados e condição de solvibilidade checada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora, livro de análise numérica (ex: LeVeque).",
                                  "tips": "Use um domínio simples como retângulo para visualização clara.",
                                  "learningObjective": "Compreender a configuração do problema misto e preparar a discretização.",
                                  "commonMistakes": "Confundir Γ_D (valor fixo) com Γ_N (fluxo); ignorar condição de solvibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretização no Interior e nas Fronteiras Dirichlet",
                                  "subSteps": [
                                    "Aplique stencil de 5 pontos para -Δu ≈ (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² = f_{i,j} em pontos internos.",
                                    "Para pontos em Γ_D, fixe u_{i,j} = g_{i,j} e elimine essas equações do sistema.",
                                    "Ordene os pontos desconhecidos (não-Dirichlet) e crie índices para a matriz esparsa.",
                                    "Monte as linhas da matriz A para equações internas, incorporando vizinhos Dirichlet como termos conhecidos.",
                                    "Teste em um pequeno grid (N=3) para validar o stencil."
                                  ],
                                  "verification": "Equações internas e Dirichlet implementadas; matriz parcial simétrica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de cálculo ou software como MATLAB/Python (NumPy), grade de exemplo.",
                                  "tips": "Renumere pontos desconhecidos sequencialmente para indexação matricial.",
                                  "learningObjective": "Dominar discretização padrão e eliminação de condições Dirichlet.",
                                  "commonMistakes": "Erro no stencil (fator h² esquecido); não eliminar corretamente variáveis Dirichlet."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporação das Condições de Neumann",
                                  "subSteps": [
                                    "Para pontos em Γ_N, aproxime ∂u/∂n usando diferenças direcionadas (ex: ∂u/∂y|_{j=N} ≈ (u_{i,N} - u_{i,N-1})/h = h_{i,N}).",
                                    "Reescreva como equação: u_{i,N} = u_{i,N-1} + h * h_{i,N}, incorporando ao stencil vizinho.",
                                    "Atualize linhas da matriz A para pontos adjacentes à Γ_N, ajustando coeficientes.",
                                    "Mantenha simetria: coeficiente de u_{i,N-1} em equação de vizinho deve coincidir.",
                                    "Inclua termo de fluxo no vetor b direito."
                                  ],
                                  "verification": "Equações Neumann incorporadas; matriz ainda simétrica.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de álgebra linear (MATLAB ou Python SciPy), stencil de Neumann impresso.",
                                  "tips": "Use aproximação de primeira ordem para Neumann; teste simetria A = A^T.",
                                  "learningObjective": "Aplicar discretização Neumann preservando estrutura simétrica.",
                                  "commonMistakes": "Quebrar simetria ao modificar unilateralmente; fator h incorreto na aproximação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montagem Final do Sistema e Verificação de Propriedades",
                                  "subSteps": [
                                    "Compile matriz A completa (n×n, n=desconhecidos) e vetor b.",
                                    "Verifique simetria: A = A^T element-wise.",
                                    "Teste positiva definida: autovalores >0 ou teste de Cholesky.",
                                    "Resolva Au=b (ex: com PCG para SPD) e compare com solução exata se disponível.",
                                    "Analise consistência: resíduo ||Au - b|| pequeno e convergência."
                                  ],
                                  "verification": "Sistema Au=b montado, A SPD confirmada, solução numérica coerente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (NumPy/SciPy) ou MATLAB para montagem e análise espectral.",
                                  "tips": "Use sparse matrices para eficiência; plot solução para inspeção visual.",
                                  "learningObjective": "Construir e validar sistema misto com propriedades numéricas ideais.",
                                  "commonMistakes": "Índices errados na montagem; falhar em normalizar Neumann corretamente."
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 0 em Ω=[0,1]×[0,1], com u=0 em x=0, x=1, y=0 (Dirichlet) e ∂u/∂y=1 em y=1 (Neumann), h=0.2. Monte A (25×25 reduzida), resolva e verifique u crescente em y.",
                              "finalVerifications": [
                                "Matriz A é simétrica (A = A^T).",
                                "Matriz A é positiva definida (autovalores mínimos >0).",
                                "Condição de solvibilidade satisfeita (∫_Γ_N h = ∫_Ω f).",
                                "Resíduo da solução ||Au - b|| < 10^{-6}.",
                                "Solução converge monotonicamente para caso analítico.",
                                "Simetria preservada nas fronteiras mistas."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e divisão de Γ_D e Γ_N (20%).",
                                "Discretização precisa do stencil interior/Dirichlet/Neumann (30%).",
                                "Montagem correta de A e b com simetria (25%).",
                                "Verificação de SPD e consistência (15%).",
                                "Exemplo prático resolvido sem erros (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de condução de calor com isolantes (Neumann=0).",
                                "Programação: Implementação em Python/MATLAB com solvers esparsos.",
                                "Engenharia Mecânica: Análise de tensões em placas com bordas fixas/livres.",
                                "Computação Científica: Pré-condicionadores para SPD em FEM."
                              ],
                              "realWorldApplication": "Simulação de distribuição térmica em uma placa metálica com temperaturas fixas nas laterais e fluxo de calor imposto na parte superior (ex: dissipadores de calor em eletrônicos), otimizando design para evitar hotspots."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Análise de Consistência, Estabilidade e Convergência",
                        "description": "Propriedades numéricas do método de diferenças finitas para equações elípticas, incluindo teoremas de Lax-Richtmyer e análise de erro.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Verificar consistência do esquema de diferenças finitas",
                            "description": "Demonstrar que o erro de truncamento local é O(h²) para o Laplaciano discretizado, usando expansão de Taylor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o esquema de diferenças finitas para o Laplaciano em 2D",
                                  "subSteps": [
                                    "Escreva a equação elíptica modelo: ∇²u = f, onde ∇²u = ∂²u/∂x² + ∂²u/∂y².",
                                    "Defina a malha uniforme com passo h em x e y, ponto central (i,j) em (x_i, y_j).",
                                    "Apresente o stencil padrão: [u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}]/h² ≈ ∇²u(x_i,y_j).",
                                    "Identifique o operador discreto L_h u_{i,j} e a diferença L_h u - ∇²u como erro de truncamento local τ.",
                                    "Especifique que τ = O(h^p) será analisado com p=2."
                                  ],
                                  "verification": "Verifique se o stencil está corretamente escrito e corresponde à aproximação centrada de segunda ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de análise numérica (capítulo de diferenças finitas)",
                                    "Editor de equações como LaTeX ou MathType"
                                  ],
                                  "tips": "Desenhe a malha em grade para visualizar os pontos vizinhos claramente.",
                                  "learningObjective": "Entender a discretização do Laplaciano e definir formalmente o erro de truncamento local.",
                                  "commonMistakes": "Confundir o stencil de primeira com segunda ordem; esquecer o fator 1/h²."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar expansões de Taylor para os pontos vizinhos",
                                  "subSteps": [
                                    "Expanda u(x_i + h, y_j) = u + h u_x + (h²/2) u_xx + (h³/6) u_xxx + (h⁴/24) u_xxxx + O(h⁵).",
                                    "Da mesma forma para u(x_i - h, y_j), u(x_i, y_j + h) e u(x_i, y_j - h), usando derivadas parciais.",
                                    "Some as expansões: u_{i+1,j} + u_{i-1,j} = 2u + h² u_xx + (h⁴/12) u_xxxx + O(h⁶).",
                                    "Repita para direções y: u_{i,j+1} + u_{i,j-1} = 2u + h² u_yy + (h⁴/12) u_yyyy + O(h⁶).",
                                    "Some todas e subtraia 4u para obter a combinação linear."
                                  ],
                                  "verification": "Confirme que os termos pares (h⁰, h², h⁴) sobrevivem e ímpares cancelam.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora simbólica como SymPy (Python) ou Mathematica",
                                    "Papel para expansões manuais"
                                  ],
                                  "tips": "Use notação abreviada para derivadas: u_x = ∂u/∂x em (x_i,y_j).",
                                  "learningObjective": "Aplicar expansão de Taylor multivariada até ordem suficiente para capturar O(h⁴).",
                                  "commonMistakes": "Parar na ordem h² sem incluir h⁴; errar sinais nos termos negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir expansões no operador discreto e simplificar",
                                  "subSteps": [
                                    "Insira as somas nas expressões: L_h u = [ (u_{i+1,j}+u_{i-1,j}-2u) + (u_{i,j+1}+u_{i,j-1}-2u) ] / h².",
                                    "Simplifique: L_h u = u_xx + u_yy + (h²/12)(u_xxxx + u_yyyy) + O(h⁴).",
                                    "Defina o erro τ_h = L_h u - ∇²u = (h²/12)(∂⁴u/∂x⁴ + ∂⁴u/∂y⁴) + O(h⁴).",
                                    "Mostre que |τ_h| ≤ C h² para u suficientemente suave (norma das derivadas de 4ª ordem bounded).",
                                    "Confirme que lim_{h→0} h^{-2} τ_h existe e é finito."
                                  ],
                                  "verification": "A expressão final de τ_h deve ter termo dominante O(h²) sem termos de ordem inferior.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software simbólico para verificação",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Fatore h² e divida corretamente para isolar o erro.",
                                  "learningObjective": "Derivar explicitamente o erro de truncamento e identificá-lo como O(h²).",
                                  "commonMistakes": "Esquecer de dividir por h²; confundir u_xxxx com derivadas mistas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e generalizar a consistência do esquema",
                                  "subSteps": [
                                    "Afirme que ||τ_h||_∞ = O(h²) implica consistência pois τ_h → 0 quando h → 0.",
                                    "Discuta suavidade requerida: u ∈ C⁴ para validade das expansões.",
                                    "Generalize para esquemas de ordem superior (ex: 4ª ordem com mais pontos).",
                                    "Teste numericamente com u(x,y) = x² + y², onde ∇²u = 4 exato.",
                                    "Verifique que erro computado escala com h²."
                                  ],
                                  "verification": "Plot ou tabela mostrando erro ~ k h² para h variando.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB para stencil numérico",
                                    "Função teste suave"
                                  ],
                                  "tips": "Use log-log plot para confirmar ordem 2.",
                                  "learningObjective": "Ligar análise assintótica à consistência e validar numericamente.",
                                  "commonMistakes": "Ignorar condições de suavidade; escolher função não suave para teste."
                                }
                              ],
                              "practicalExample": "Para u(x,y) = sin(πx) sin(πy) em malha [0,1]x[0,1], ∇²u = -2π² u. Compute L_h u em centro, compare com ∇²u exato para h=0.1, 0.05; erro deve cair 4x (h² ratio).",
                              "finalVerifications": [
                                "Expansões de Taylor corretas até O(h⁴) para todos vizinhos.",
                                "τ_h = (h²/12)(u_xxxx + u_yyyy) + O(h⁴) derivado precisamente.",
                                "Limite h→0 de τ_h / h² finito e não-zero para u suave.",
                                "Teste numérico confirma ||L_h u - ∇²u|| = O(h²).",
                                "Condições de suavidade (C⁴) explicitadas.",
                                "Generalização para 1D ou ordens superiores mencionada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de Taylor (sem erros algébricos).",
                                "Identificação correta do termo líder O(h²) no erro.",
                                "Explicação clara da implicação para consistência.",
                                "Validação numérica com exemplo concreto e análise de ordem.",
                                "Tratamento de suavidade e limitações do esquema.",
                                "Clareza na apresentação (notação consistente, passos lógicos)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações de equações de Poisson (eletrostática).",
                                "Programação: Implementação de stencils em Python/NumPy para validação.",
                                "Engenharia: Verificação de precisão em CFD para equações elípticas.",
                                "Estatística: Análise de convergência em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor (equação de Poisson), verificar O(h²) garante precisão controlada em malhas grossas, otimizando custo computacional em engenharia aeroespacial e geofísica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Analisar estabilidade e convergência para problemas elípticos",
                            "description": "Explicar por que métodos elípticos são inerentemente estáveis e provar convergência O(h²) usando norma máxima ou energia, citando resultados clássicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema Elíptico Modelo e Discretização via Diferenças Finitas",
                                  "subSteps": [
                                    "Estude a equação modelo -Δu = f em um domínio Ω com condições de Dirichlet u=g na fronteira ∂Ω.",
                                    "Derive o stencil de 5 pontos para o operador Laplaciano em grade uniforme com passo h.",
                                    "Escreva o sistema linear Au = b resultante, identificando A como matriz tridiagonal ou de banda esparsa.",
                                    "Verifique consistência local da discretização, mostrando truncagem O(h²).",
                                    "Discuta propriedades espectrais iniciais de A (simetria, diagonal dominante)."
                                  ],
                                  "verification": "Construa manualmente a matriz A para uma grade 3x3 e confirme simetria e positividade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de Análise Numérica II",
                                    "Livro 'Finite Difference Schemes and Partial Differential Equations' de Strikwerda",
                                    "Python/MATLAB para stencil"
                                  ],
                                  "tips": "Visualize a grade com ferramentas como Matplotlib para entender o stencil.",
                                  "learningObjective": "Compreender a origem da estabilidade a partir da discretização elíptica.",
                                  "commonMistakes": [
                                    "Ignorar condições de contorno no stencil de fronteira",
                                    "Confundir ordem de truncagem com precisão global",
                                    "Esquecer normalização da equação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar Estabilidade Inerente dos Métodos Elípticos",
                                  "subSteps": [
                                    "Prove que a matriz A é simétrica positiva definida (SPD) usando somas de linhas positivas e simetria.",
                                    "Mostre que A satisfaz a propriedade de máxima princípio discreta (DMP).",
                                    "Analise estabilidade em norma máxima: ||e||_∞ ≤ C ||r||_∞ onde e é erro, r resíduo.",
                                    "Discuta por que problemas elípticos são 'inerentemente estáveis' ao contrário de hiperbólicos.",
                                    "Verifique numericamente com autovalores de A."
                                  ],
                                  "verification": "Calcule autovalores mínimos e máximos de A para h=1/10 e confirme todos positivos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Teorema de Gershgorin",
                                    "Software NumPy/Scipy para autovalores",
                                    "Exemplos de código para DMP"
                                  ],
                                  "tips": "Use o fato de que para Laplaciano discreto, min eigenvalue ~ π² h² >0.",
                                  "learningObjective": "Explicar matematicamente a estabilidade inerente sem amplificação de erros.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com convergência",
                                    "Aplicar análise von Neumann inadequada para elípticos",
                                    "Negligenciar fronteiras irregulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Convergência O(h²) na Norma Máxima",
                                  "subSteps": [
                                    "Lembre o Teorema da Equivalência de Lax: consistência + estabilidade ⇒ convergência.",
                                    "Estime erro de consistência: |τ| ≤ K h² usando expansão de Taylor.",
                                    "Use estabilidade ||u - u_h||_∞ ≤ C ||r||_∞ ≤ C K h² para provar ||u - u_h||_∞ = O(h²).",
                                    "Aplique a um problema 1D simples: -u''=f em [0,1], u(0)=u(1)=0.",
                                    "Generalize para 2D usando norma máxima discreta."
                                  ],
                                  "verification": "Implemente código para h=1/20, 1/40 e plote log(error) vs log(h), confirme slope=2.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Livro 'Numerical Solution of PDEs' de Gustafsson",
                                    "Código Python para erro em norma máxima"
                                  ],
                                  "tips": "Escolha solução exata suave para testar O(h²).",
                                  "learningObjective": "Dominar prova de convergência global via normas.",
                                  "commonMistakes": [
                                    "Esquecer fator h na norma discreta",
                                    "Usar norma L2 em prova de máximo",
                                    "Ignorar dependência em derivadas de f"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Convergência na Norma de Energia e Citar Resultados Clássicos",
                                  "subSteps": [
                                    "Defina norma de energia ||v||_E = sqrt(<Av,v>) equivalente à H^1 semi-norma.",
                                    "Prove coerção e continuidade de A: α||v||_E² ≤ <Av,v> ≤ β||v||_E².",
                                    "Use Céa's lemma adaptado: ||u - u_h||_E ≤ C inf ||u - v_h||_E = O(h²) por interpolação.",
                                    "Cite resultados de Bramble, Dupont, etc., e teorema de Strang para erros de aproximação.",
                                    "Compare normas máxima e energia em exemplo numérico."
                                  ],
                                  "verification": "Resolva sistema com CG iterativo e compute ||e||_E, confirme O(h²).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Paper 'Error estimates for elliptic problems' de Ciarlet",
                                    "MATLAB PDE Toolbox ou FEniCS"
                                  ],
                                  "tips": "Norma energia é natural para variational methods.",
                                  "learningObjective": "Integrar análise funcional com diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir norma energia com L2",
                                    "Esquecer equivalência de normas em domínios convexos",
                                    "Não citar referências precisas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para -Δu = 2π² sin(πx) sin(πy) em Ω=[0,1]² com u=0 na ∂Ω (solução exata u=sin(πx)sin(πy)), discretize com h=1/32 usando stencil 5-pt. Monte A (1025x1025), resolva Au_h=f_h, compute erros em ||·||_∞ e ||·||_E, plote vs h confirmando O(h²).",
                              "finalVerifications": [
                                "Explica verbalmente por que A é SPD e DMP holds.",
                                "Deriva stencil e prova truncagem O(h²).",
                                "Prova escrita de ||u-u_h||_∞ = O(h²).",
                                "Calcula numericamente erro para 3 valores de h e confirma ordem.",
                                "Discute norma energia vs máxima.",
                                "Cita pelo menos 2 teoremas clássicos (ex: Lax, Cea)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na prova de estabilidade (SPD, DMP).",
                                "Correção na estimativa de erro de consistência O(h²).",
                                "Aplicação correta de teoremas (Lax, Gershgorin, Cea).",
                                "Análise numérica com plots log-log mostrando slope 2.",
                                "Conexão clara entre normas e convergência.",
                                "Referenciação adequada a literatura clássica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potenciais eletrostáticos via Poisson (Eletromagnetismo).",
                                "Engenharia Civil: Análise de tensões em placas elásticas (Mecânica dos Sólidos).",
                                "Ciência da Computação: Otimização de solvers esparsos (Métodos Iterativos).",
                                "Matemática Aplicada: Análise de Elementos Finitos (variação da prova de energia)."
                              ],
                              "realWorldApplication": "Simulação de campos térmicos estacionários em reatores nucleares, previsão de deformações em estruturas sob carga estática, modelagem de fluxos subterrâneos em hidrogeologia, onde precisão O(h²) garante simulações confiáveis com grades moderadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Calcular erro de discretização em exemplo numérico",
                            "description": "Resolver numericamente a equação de Laplace com condições conhecidas, computar norma do erro e observar ordem de convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema modelo e solução exata",
                                  "subSteps": [
                                    "Escolha uma equação de Laplace em 2D: ∇²u = 0 em domínio Ω = [0,1]×[0,1].",
                                    "Defina condições de contorno: u=0 em x=0, x=1, y=0; u=sin(πx) em y=1.",
                                    "Derive a solução exata: u(x,y) = y sin(πx).",
                                    "Verifique que a solução satisfaz a equação e condições de contorno.",
                                    "Documente os parâmetros iniciais como h (passo da malha)."
                                  ],
                                  "verification": "Confirme que ∇²u = 0 e condições de contorno são satisfeitas algebricamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, software simbólico como SymPy (opcional).",
                                  "tips": "Use soluções separáveis para derivar u exata rapidamente.",
                                  "learningObjective": "Entender como selecionar um problema com solução analítica conhecida para análise de erro.",
                                  "commonMistakes": "Escolher condições de contorno incompatíveis com Laplace ou errar a solução exata."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar discretização por diferenças finitas",
                                  "subSteps": [
                                    "Crie uma malha uniforme com passo h = 1/N, pontos internos (N-1)×(N-1).",
                                    "Aplique stencil de Laplace centrado: (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² = 0.",
                                    "Monte o sistema linear Au = b, onde A é a matriz laplaciana esparsa.",
                                    "Incorpore condições de Dirichlet nas fronteiras.",
                                    "Resolva o sistema usando método iterativo (ex: Gauss-Seidel) ou solver direto."
                                  ],
                                  "verification": "Verifique se a matriz A é simétrica positiva definida e solução satisfaz equação discreta em pontos internos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, grade de papel para N pequeno.",
                                  "tips": "Comece com N=10 para teste rápido; vetorize operações em código.",
                                  "learningObjective": "Dominar a formulação do método de diferenças finitas para equações elípticas.",
                                  "commonMistakes": "Erros de indexação na malha ou esquecimento de fatores h² no stencil."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma do erro de discretização",
                                  "subSteps": [
                                    "Compute u_h (solução numérica) e u (exata) nos pontos da malha.",
                                    "Calcule erro pontual e_h,i,j = |u_h,i,j - u(x_i,y_j)|.",
                                    "Compute norma L²: ||e_h||_2 = h √(∑ e_h,i,j²).",
                                    "Compute norma máximo: ||e_h||_∞ = max |e_h,i,j|.",
                                    "Registre valores para h atual."
                                  ],
                                  "verification": "Erro deve ser pequeno (ex: <10^{-3} para h=0.1) e positivo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python/MATLAB estendendo o anterior, tabela para registro.",
                                  "tips": "Use meshgrid para avaliação eficiente da solução exata.",
                                  "learningObjective": "Aprender a quantificar erro de discretização usando normas adequadas.",
                                  "commonMistakes": "Esquecer fator h na soma para norma L² ou avaliar exata fora da malha."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar ordem de convergência",
                                  "subSteps": [
                                    "Repita passos 2-3 para h/2, h/4 (ex: N=10,20,40).",
                                    "Calcule razões de erro: r_k = log(||e_{h_k}|| / ||e_{h_{k+1}}||) / log(2).",
                                    "Observe que ordem ≈2 para norma L² em método de 2ª ordem.",
                                    "Plote log(||e||) vs log(h); inclinação ≈ -ordem.",
                                    "Interprete: consistência e estabilidade implicam convergência O(h²)."
                                  ],
                                  "verification": "Razões de erro aproximam 2; gráfico linear com inclinação -2.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código em loop sobre N, Matplotlib para plotagem.",
                                  "tips": "Automatize loop em código para eficiência.",
                                  "learningObjective": "Verificar empiricamente a ordem de convergência e ligar à análise teórica.",
                                  "commonMistakes": "Poucos pontos de malha (precisa ≥3 para log-log) ou erro numérico em logs."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e interpretar resultados",
                                  "subSteps": [
                                    "Compile tabela: h, ||e||_2, ||e||_∞, ordem estimada.",
                                    "Discuta discrepâncias com teoria (O(h²)).",
                                    "Identifique fontes de erro (arredondamento, iterações insuficientes).",
                                    "Escreva relatório curto com plots.",
                                    "Sugira refinamentos (malhas não-uniformes)."
                                  ],
                                  "verification": "Tabela completa, ordem convergindo para 2, interpretação coerente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, planilha ou Jupyter notebook.",
                                  "tips": "Use LaTeX ou Markdown para tabela profissional.",
                                  "learningObjective": "Sintetizar análise numérica em relatório acionável.",
                                  "commonMistakes": "Ignorar erros numéricos ou superestimar precisão."
                                }
                              ],
                              "practicalExample": "Para Ω=[0,1]², ∇²u=0, u(0,y)=u(1,y)=u(x,0)=0, u(x,1)=sin(πx). Solução exata u(x,y)=y sin(πx). Com h=0.1 (N=11), resolva Au=b via SciPy, compute ||e_h||_2 ≈ 2.5e-4, repita para h=0.05 (≈6e-5), ordem ≈2.",
                              "finalVerifications": [
                                "Solução numérica satisfaz equação discreta com resíduo <1e-10.",
                                "Norma L² do erro diminui quadraticamente com h.",
                                "Razões logarítmicas de erro convergem para 2.",
                                "Gráfico log-log mostra inclinação -2.",
                                "Solução exata interpolada corretamente nos nós da malha.",
                                "Sem artefatos de arredondamento visíveis nos erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem do sistema de diferenças finitas (ver stencil correto).",
                                "Correta implementação de normas de erro (L² e ∞).",
                                "Cálculo exato da ordem de convergência via razões logarítmicas.",
                                "Qualidade dos plots e tabelas (clareza, legibilidade).",
                                "Interpretação teórica: ligação com C-E-S theorem.",
                                "Eficiência computacional (tempo de resolução escalável)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potenciais eletrostáticos ou fluxo de calor estacionário.",
                                "Computação: Algoritmos iterativos esparsos (GMRES, multigrid).",
                                "Engenharia: Simulações CFD para escoamentos incompressíveis.",
                                "Estatística: Análise de erro em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, calcular campos de temperatura em painéis compostos usando diferenças finitas para validar designs térmicos; erro de discretização garante precisão em simulações de longa duração sem solução analítica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.2",
                              "10.1.4.1.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Condições de Dirichlet em Equações Elípticas",
                    "description": "Definição e significado das condições de Dirichlet, que especificam valores da solução na fronteira.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição de Condições de Dirichlet",
                        "description": "Conceito formal das condições de Dirichlet, que especificam os valores exatos da solução u em toda a fronteira ∂Ω de um domínio Ω para equações elípticas do tipo -Δu = f em Ω, com u = g na ∂Ω.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar condições de Dirichlet em problemas elípticos",
                            "description": "Reconhecer e classificar condições de Dirichlet em enunciados matemáticos de problemas de valores de contorno para equações elípticas, distinguindo-as de condições homogêneas e não homogêneas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição fundamental de condições de Dirichlet",
                                  "subSteps": [
                                    "Leia a definição formal: condições de Dirichlet especificam o valor da solução u diretamente na fronteira ∂Ω, i.e., u(x) = g(x) para x ∈ ∂Ω.",
                                    "Compare com condições de Neumann (derivadas normais) e Robin (mistura).",
                                    "Identifique símbolos comuns: u|∂Ω = g ou u = φ na fronteira.",
                                    "Estude exemplos simples em 1D, como -u'' = f com u(0)=a, u(1)=b.",
                                    "Anote diferenças chave em um caderno."
                                  ],
                                  "verification": "Escreva a definição de Dirichlet em suas próprias palavras e dê um exemplo de 1D sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDP elípticas)",
                                    "Notas de aula sobre problemas de contorno",
                                    "Caderno e caneta"
                                  ],
                                  "tips": "Use diagramas da fronteira Ω para visualizar onde as condições são aplicadas.",
                                  "learningObjective": "Compreender precisamente o que constitui uma condição de Dirichlet em problemas de valores de contorno.",
                                  "commonMistakes": [
                                    "Confundir com Neumann (focar em valores vs fluxos)",
                                    "Ignorar que g pode ser zero (homogênea)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer condições de Dirichlet em enunciados de problemas elípticos",
                                  "subSteps": [
                                    "Analise problemas elípticos padrão: Δu = f em Ω, com condições na ∂Ω.",
                                    "Localize frases como 'u = g na fronteira', 'valores prescritos na borda' ou 'u|Γ = φ'.",
                                    "Identifique o domínio Ω e fronteira ∂Ω no enunciado.",
                                    "Marque o problema como elíptico (ex: Laplace, Poisson).",
                                    "Pratique com 3 enunciados de exemplo de livros ou notas."
                                  ],
                                  "verification": "Dado um enunciado aleatório, circule e rotule a condição de Dirichlet corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de problemas elípticos de Análise Numérica II",
                                    "Folhas de exercícios",
                                    "Calculadora simbólica opcional (Mathematica/SymPy)"
                                  ],
                                  "tips": "Procure por 'u equals' ou 'valor fixo' na fronteira; ignore condições internas.",
                                  "learningObjective": "Localizar rapidamente condições de Dirichlet em descrições matemáticas de problemas elípticos.",
                                  "commonMistakes": [
                                    "Confundir condições internas com de contorno",
                                    "Não verificar se é elíptico (ex: confundir com parabólico)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar condições de Dirichlet como homogêneas ou não homogêneas",
                                  "subSteps": [
                                    "Defina homogênea: g(x) ≡ 0 na ∂Ω (u=0 na fronteira).",
                                    "Defina não homogênea: g(x) ≠ 0 em pelo menos um ponto da ∂Ω.",
                                    "Para um problema dado, verifique se g é a função zero.",
                                    "Classifique 5 exemplos variados (quadrados, discos, etc.).",
                                    "Discuta implicações: homogêneas facilitam métodos de separação de variáveis."
                                  ],
                                  "verification": "Classifique corretamente 5 problemas mistos como homogêneo/não homogêneo com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 10 problemas elípticos com soluções",
                                    "Software de plotagem (Matlab/Python para visualizar g)",
                                    "Tabela de classificação pessoal"
                                  ],
                                  "tips": "Teste pontos específicos na fronteira: se g(x0)=0 para todos x0, é homogênea.",
                                  "learningObjective": "Distinguir e classificar tipos de Dirichlet com base na função de contorno g.",
                                  "commonMistakes": [
                                    "Achar homogêneo só se g constante zero, ignorando funções zero",
                                    "Confundir com f no domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar distinção de Dirichlet de outras condições em contextos elípticos",
                                  "subSteps": [
                                    "Compare enunciados mistos: Dirichlet vs Neumann/Robin em problemas elípticos.",
                                    "Resolva um problema híbrido identificando todas as condições.",
                                    "Crie seu próprio enunciado elíptico com Dirichlet e verifique.",
                                    "Revise erros em exercícios passados.",
                                    "Debata com colega ou simule explicação oral."
                                  ],
                                  "verification": "Em um problema complexo, identifique TODAS as condições de contorno e classifique corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Banco de exercícios de EDP elípticas",
                                    "Fórum online ou grupo de estudo",
                                    "Gravador de voz para autoexplicação"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso fixa u ou sua derivada na fronteira?'",
                                  "learningObjective": "Aplicar identificação e classificação em cenários reais de problemas elípticos.",
                                  "commonMistakes": [
                                    "Rotular Robin como Dirichlet",
                                    "Ignorar não-homogeneidades sutis"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema de Poisson: -Δu = 1 em Ω = [0,1]x[0,1], com u(x,0)=0, u(x,1)=sin(πx), u(0,y)=0, u(1,y)=0. Identifique: condições de Dirichlet em todas as bordas; homogêneas em três lados (g=0), não homogênea no topo (g=sin(πx) ≠ 0).",
                              "finalVerifications": [
                                "Classifique corretamente 10/10 problemas elípticos como contendo Dirichlet ou não.",
                                "Explique diferenças homogêneo/não homogêneo sem hesitação.",
                                "Identifique Dirichlet em enunciados ambíguos ou mal escritos.",
                                "Crie e classifique 3 problemas originais.",
                                "Discuta aplicações em métodos numéricos (ex: elementos finitos).",
                                "Autoavalie compreensão em 90%+ de confiança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de condições de Dirichlet (100% correta).",
                                "Classificação homogêneo/não homogêneo justificada matematicamente.",
                                "Distinção clara de outras condições de contorno.",
                                "Uso correto de notação e terminologia.",
                                "Capacidade de generalizar para domínios irregulares.",
                                "Velocidade e confiança na identificação (em <2 min por problema)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Problemas de potencial eletrostático (u=potencial fixo na fronteira).",
                                "Engenharia: Simulação de fluxo de calor com temperaturas prescritas.",
                                "Computação: Implementação em métodos de elementos finitos (bibliotecas como FEniCS).",
                                "Análise: Teoria de existência via máximo princípio para elípticas.",
                                "Estatística: Modelos de processos gaussianos com condições de contorno."
                              ],
                              "realWorldApplication": "Em engenharia térmica, identificar condições de Dirichlet permite modelar placas com temperaturas fixas nas bordas (ex: dissipadores de calor em eletrônicos), essencial para simulações numéricas precisas em software como COMSOL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Formular problemas com condições de Dirichlet",
                            "description": "Escrever o problema de valor de contorno completo para uma equação elíptica de segunda ordem com condições de Dirichlet dadas, incluindo notação padrão como Lu = f em Ω e u = g em ∂Ω.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma padrão de uma equação elíptica de segunda ordem",
                                  "subSteps": [
                                    "Revise a definição geral de um operador diferencial elíptico L de segunda ordem: L = ∑ a_{ij} ∂²/∂x_i ∂x_j + ∑ b_i ∂/∂x_i + c.",
                                    "Identifique exemplos comuns, como o Laplaciano Δu = ∑ ∂²u/∂x_i².",
                                    "Confirme que L é elíptico se a matriz (a_{ij}) é definida positiva.",
                                    "Escreva a equação inhomogênea Lu = f em Ω.",
                                    "Diferencie de equações parabólicas ou hiperbólicas."
                                  ],
                                  "verification": "Escreva três exemplos de operadores elípticos e verifique a condição de ellipticidade para cada um.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula sobre PDEs"
                                  ],
                                  "tips": "Comece com o caso simples do Laplaciano para construir confiança antes de generalizar.",
                                  "learningObjective": "Dominar a notação e propriedades de operadores elípticos de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir com operadores parabólicos (ex: equação do calor)",
                                    "Esquecer o termo de ordem zero c(u)",
                                    "Não verificar a ellipticidade da matriz de coeficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o domínio Ω e sua fronteira ∂Ω",
                                  "subSteps": [
                                    "Escolha um domínio Ω aberto e conexo em R^n, como um retângulo ou disco.",
                                    "Descreva ∂Ω como a fronteira suave ou lipschitziana.",
                                    "Especifique se ∂Ω é dividida em partes para condições mistas, mas foque em Dirichlet homogêneo/in homogêneo.",
                                    "Desenhe um esboço de Ω e rotule ∂Ω.",
                                    "Verifique regularidade assumida para existência de soluções (ex: C^2)."
                                  ],
                                  "verification": "Desenhe Ω e ∂Ω para um exemplo específico e escreva notação matemática precisa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado para desenhos",
                                    "Software de plotagem como GeoGebra (opcional)"
                                  ],
                                  "tips": "Use domínios simples como o quadrado unitário para prática inicial.",
                                  "learningObjective": "Especificar corretamente o domínio geométrico do problema.",
                                  "commonMistakes": [
                                    "Definir Ω fechado em vez de aberto",
                                    "Ignorar a regularidade da fronteira",
                                    "Confundir ∂Ω com subconjuntos internos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar as condições de Dirichlet u = g em ∂Ω",
                                  "subSteps": [
                                    "Defina g como função dada em ∂Ω, contínua ou em espaço de Sobolev apropriado.",
                                    "Discuta casos homogêneos (g=0) vs. não-homogêneos.",
                                    "Escreva a condição como u(x) = g(x) ∀ x ∈ ∂Ω.",
                                    "Verifique compatibilidade: g deve coincidir com traço de soluções possíveis.",
                                    "Considere parametrização da fronteira se necessário."
                                  ],
                                  "verification": "Dada uma g exemplo, escreva a condição de Dirichlet e verifique se é bem-possuída.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas sobre espaços de funções (H^1, C^0)",
                                    "Exemplos de problemas de Dirichlet"
                                  ],
                                  "tips": "Sempre especifique o espaço funcional para g para rigor matemático.",
                                  "learningObjective": "Formular precisamente as condições de contorno de Dirichlet.",
                                  "commonMistakes": [
                                    "Escrever u = g em Ω em vez de ∂Ω",
                                    "Não mencionar regularidade de g",
                                    "Confundir com condições de Neumann (derivadas)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e verificar o problema de valor de contorno completo",
                                  "subSteps": [
                                    "Combine: Encontre u tal que Lu = f em Ω, u = g em ∂Ω.",
                                    "Use notação padrão: Problema de Dirichlet para Lu = f.",
                                    "Verifique consistência: f ∈ L^2(Ω), g ∈ H^{1/2}(∂Ω).",
                                    "Escreva em forma compacta com símbolos Ω, ∂Ω, L, f, g.",
                                    "Teste com um exemplo numérico simples para validação."
                                  ],
                                  "verification": "Escreva o problema completo e resolva analiticamente um caso 1D se possível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como Mathematica",
                                    "Tabela de exemplos resolvidos"
                                  ],
                                  "tips": "Leia em voz alta a formulação para detectar erros de notação.",
                                  "learningObjective": "Ensamblar todos os elementos em uma formulação rigorosa e verificável.",
                                  "commonMistakes": [
                                    "Omitir 'em Ω' ou 'em ∂Ω'",
                                    "Usar notação inconsistente para variáveis",
                                    "Esquecer hipóteses de existência/uniqueness."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere Ω = (0,1) × (0,1), L = -Δ (Laplaciano negativo), f(x,y) = 2π² sin(πx) sin(πy), g = 0 em ∂Ω. O problema é: -Δu = 2π² sin(πx) sin(πy) em Ω, u = 0 em ∂Ω. Solução: u(x,y) = sin(πx) sin(πy).",
                              "finalVerifications": [
                                "A equação Lu = f está corretamente localizada em Ω?",
                                "As condições u = g estão em ∂Ω?",
                                "O operador L é elíptico de segunda ordem?",
                                "Notação padrão é usada (Ω, ∂Ω, f, g)?",
                                "Hipóteses mínimas para bem-possuído estão implícitas?",
                                "Exemplo prático pode ser plugado sem inconsistências?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da notação matemática (100% correto).",
                                "Correta identificação de todos componentes (L, f, Ω, ∂Ω, g).",
                                "Rigor nas condições de regularidade e ellipticidade.",
                                "Clareza e legibilidade da formulação escrita.",
                                "Capacidade de validar com um exemplo concreto.",
                                "Ausência de erros comuns como confusão de domínio/fronteira."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos eletrostáticos via equação de Poisson.",
                                "Engenharia: Análise de tensão em placas elásticas.",
                                "Computação Científica: Preparação para métodos de elementos finitos.",
                                "Análise Funcional: Uso de espaços de Sobolev H^1_0(Ω).",
                                "Otimização: Problemas de minimização de energia associada."
                              ],
                              "realWorldApplication": "Em engenharia térmica, formula problemas para distribuição estacionária de temperatura em uma chapa metálica (Ω) com temperaturas fixas nas bordas (g em ∂Ω), onde f representa fontes de calor internas, essencial para design de dissipadores de calor em eletrônicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Diferenciar Dirichlet de outras condições de contorno",
                            "description": "Comparar condições de Dirichlet (valores especificados) com condições de Neumann (derivadas normais especificadas) e de Robin, destacando suas diferenças em termos de formulação e aplicação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Condições de Dirichlet",
                                  "subSteps": [
                                    "Ler a definição formal: as condições de Dirichlet especificam o valor da solução u diretamente na fronteira ∂Ω, ou seja, u(x) = g(x) para x ∈ ∂Ω.",
                                    "Analisar exemplos em 1D: para -u''=f em [0,1], u(0)=a e u(1)=b.",
                                    "Estudar propriedades: garantem unicidade em problemas elípticos bem-poseados.",
                                    "Visualizar geometricamente: valores fixos na borda do domínio."
                                  ],
                                  "verification": "Escrever a fórmula matemática de Dirichlet e dar um exemplo simples em suas palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDP elípticas)",
                                    "Notas de aula sobre condições de contorno"
                                  ],
                                  "tips": [
                                    "Associe Dirichlet a 'valores prescritos' como temperatura fixa em uma barra."
                                  ],
                                  "learningObjective": "Definir precisamente condições de Dirichlet e suas implicações em problemas de valor de contorno.",
                                  "commonMistakes": [
                                    "Confundir com condições que envolvem derivadas, como Neumann."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar as Condições de Neumann",
                                  "subSteps": [
                                    "Ler a definição: condições de Neumann especificam a derivada normal ∂u/∂n = h(x) na fronteira ∂Ω.",
                                    "Exemplo em 1D: u'(0)=c e u'(1)=d para -u''=f.",
                                    "Discutir condições de compatibilidade: integral de h deve igualar integral de f para existência de solução.",
                                    "Comparar intuitivamente: representa fluxo ou gradiente normal fixo."
                                  ],
                                  "verification": "Formular a equação de Neumann e explicar por que requer compatibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Apostila de Equações Elípticas",
                                    "Software como MATLAB para plotar exemplos"
                                  ],
                                  "tips": [
                                    "Pense em Neumann como 'isolamento térmico' onde o fluxo de calor é zero."
                                  ],
                                  "learningObjective": "Identificar a formulação de Neumann e suas restrições de existência.",
                                  "commonMistakes": [
                                    "Esquecer a condição de compatibilidade, levando a problemas sem solução."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar as Condições de Robin",
                                  "subSteps": [
                                    "Definir Robin: combinação linear ∂u/∂n + α(x) u(x) = β(x) na fronteira.",
                                    "Exemplo: α constante, representa lei de resfriamento de Newton.",
                                    "Analisar casos limites: α=0 recupera Neumann; α→∞ aproxima Dirichlet.",
                                    "Estudar aplicações: modela convecção na fronteira."
                                  ],
                                  "verification": "Escrever a fórmula geral de Robin e dar um exemplo numérico simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referências online sobre EDP (Wolfram MathWorld)",
                                    "Caderno para derivações"
                                  ],
                                  "tips": [
                                    "Robin é 'mista': liga valor e derivada, útil para fronteiras reais."
                                  ],
                                  "learningObjective": "Compreender Robin como generalização de Dirichlet e Neumann.",
                                  "commonMistakes": [
                                    "Confundir o sinal do termo αu ou β."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Dirichlet, Neumann e Robin",
                                  "subSteps": [
                                    "Listar diferenças na formulação: Dirichlet (u=g), Neumann (∂u/∂n=h), Robin (mista).",
                                    "Comparar aplicações: Dirichlet para valores conhecidos, Neumann para fluxos, Robin para convecção.",
                                    "Discutir impactos numéricos: Dirichlet fácil de implementar, Neumann instável sem regularização.",
                                    "Criar tabela comparativa com exemplos e propriedades (unicidade, estabilidade)."
                                  ],
                                  "verification": "Preencher uma tabela comparativa e explicar uma diferença chave em contexto físico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela",
                                    "Exemplos de problemas elípticos resolvidos"
                                  ],
                                  "tips": [
                                    "Use analogias físicas: Dirichlet=temperatura fixa, Neumann=isolamento, Robin=ventilação."
                                  ],
                                  "learningObjective": "Diferenciar claramente as três condições em termos de formulação, aplicação e propriedades.",
                                  "commonMistakes": [
                                    "Generalizar incorretamente que todas garantem unicidade sem condições extras."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace -Δu=0 em um quadrado [0,1]². Para Dirichlet: u=0 em três lados, u=sin(πx) no topo (modela membrana fixa). Para Neumann: ∂u/∂n=0 em todas as bordas (onda estacionária isolada, mas verifique compatibilidade). Para Robin: ∂u/∂n + u=0 (resfriamento). Resolva numericamente com método de diferenças finitas e compare soluções.",
                              "finalVerifications": [
                                "Explicar verbalmente as diferenças principais entre Dirichlet, Neumann e Robin.",
                                "Preencher corretamente uma tabela comparativa com 5 colunas (tipo, fórmula, aplicação, unicidade, exemplo).",
                                "Identificar qual condição usar em um problema físico dado (ex: temperatura fixa vs fluxo zero).",
                                "Resolver um problema simples em 1D distinguindo as condições.",
                                "Discutir por que Neumann pode não ter solução única sem normalização.",
                                "Dar um exemplo onde Robin é mais realista que as outras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática de cada condição (100% correto).",
                                "Correta identificação de aplicações físicas e diferenças chave.",
                                "Capacidade de criar exemplos concretos e tabelas comparativas claras.",
                                "Compreensão de propriedades como unicidade e compatibilidade.",
                                "Uso adequado de analogias para explicar conceitos abstratos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Potenciais eletromagnéticos (Dirichlet para condutores, Neumann para isolantes).",
                                "Engenharia: Simulações de fluxo de calor/fluídos (Robin em convecção).",
                                "Computação: Implementação em métodos numéricos (finite elements/diferenças).",
                                "Química: Difusão em membranas com condições mistas.",
                                "Economia/Matéria: Otimização com restrições de contorno em modelos PDE."
                              ],
                              "realWorldApplication": "Em engenharia térmica, condições de Dirichlet modelam superfícies mantidas a temperatura fixa (ex: dissipadores de calor); Neumann para isolantes perfeitos (ex: vácuo); Robin para convecção natural (ex: resfriamento de eletrônicos ao ar livre), essencial em simulações CFD para design de aviões ou prédios eficientes energeticamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Significado das Condições de Dirichlet",
                        "description": "Interpretação matemática e física das condições de Dirichlet, enfatizando a garantia de unicidade e existência da solução via teorema de Lax-Milgram para operadores elípticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Explicar o papel na unicidade da solução",
                            "description": "Demonstrar como as condições de Dirichlet garantem a unicidade da solução para o problema elíptico usando o princípio do máximo e propriedades de positividade do operador Laplaciano.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema Elíptico com Condições de Dirichlet",
                                  "subSteps": [
                                    "Defina o problema elíptico padrão: -Δu = f em domínio Ω com u = g na fronteira ∂Ω.",
                                    "Explique o que são condições de Dirichlet: valores prescritos na fronteira.",
                                    "Discuta por que condições de fronteira são necessárias para existência e unicidade.",
                                    "Estude exemplos simples como o problema de Poisson em um disco unitário.",
                                    "Verifique a formulação fraca usando espaços de Sobolev H¹(Ω)."
                                  ],
                                  "verification": "Escreva a formulação matemática completa do problema e identifique os papéis de f, g e Δ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (Evans ou Brezis)",
                                    "Notas de aula sobre PDEs",
                                    "Software como MATLAB para visualizar soluções"
                                  ],
                                  "tips": "Comece com domínios simples como intervalos ou discos para intuição geométrica.",
                                  "learningObjective": "Compreender a estrutura matemática do problema elíptico e o papel das condições de Dirichlet.",
                                  "commonMistakes": [
                                    "Confundir Dirichlet com Neumann",
                                    "Ignorar regularidade do domínio Ω",
                                    "Esquecer a homogeneidade nas condições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Princípio do Máximo para Operadores Elípticos",
                                  "subSteps": [
                                    "Lembre o princípio do máximo para funções harmônicas (Δu=0): máximo na fronteira.",
                                    "Estenda para operadores elípticos: se -Δu ≥ 0, então máximo na fronteira.",
                                    "Prove usando argumento de Hopf ou barreira.",
                                    "Aplique a soluções de -Δu = f com f ≤ 0 para sub-harmônicas.",
                                    "Discuta implicações para unicidade em problemas homogêneos."
                                  ],
                                  "verification": "Prove o princípio do máximo para u harmônica em um quadrado e verifique numericamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Teorema 9.6 de Gilbarg-Trudinger",
                                    "Artigos sobre princípios de máximo",
                                    "Python com FEniCS para simulações"
                                  ],
                                  "tips": "Use diagramas de contorno para visualizar o máximo na fronteira.",
                                  "learningObjective": "Dominar o princípio do máximo e sua extensão a equações elípticas.",
                                  "commonMistakes": [
                                    "Aplicar diretamente a f > 0 sem normalização",
                                    "Confundir máximo forte e fraco",
                                    "Ignorar condições de compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Propriedades de Positividade do Operador Laplaciano",
                                  "subSteps": [
                                    "Defina positividade: < -Δu, u > ≥ 0 para u em H¹₀(Ω).",
                                    "Prove usando integração por partes: ∫ |∇u|² dx ≥ 0.",
                                    "Discuta coercividade e forma bilinear associada a(u,v) = ∫ ∇u · ∇v.",
                                    "Relacione com norma de H¹ e teorema de Lax-Milgram.",
                                    "Exemplo: eigenvalores positivos do Laplaciano com Dirichlet."
                                  ],
                                  "verification": "Calcule a forma bilinear para u = sin(πx) em [0,1] e mostre positividade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas sobre Lax-Milgram",
                                    "Wolfram Alpha para integrais",
                                    "Código em Julia para eigenvalores"
                                  ],
                                  "tips": "Pense em -Δ como operador elíptico positivo definido para garantir invertibilidade.",
                                  "learningObjective": "Entender como a positividade do Laplaciano implica propriedades energéticas.",
                                  "commonMistakes": [
                                    "Confundir -Δ com Δ",
                                    "Esquecer condições de Dirichlet homogêneas H¹₀",
                                    "Negligenciar domínio acotado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Unicidade Usando Princípio do Máximo e Positividade",
                                  "subSteps": [
                                    "Suponha duas soluções u1, u2; defina w = u1 - u2 satisfaz -Δw = 0, w=0 na fronteira.",
                                    "Aplique princípio do máximo a w: w ≤ 0 e w ≥ 0, logo w=0.",
                                    "Use positividade: ||∇w||² = 0 implica w=0 em H¹₀.",
                                    "Generalize para f arbitrário via linearidade.",
                                    "Discuta estabilidade via desigualdade de Poincaré."
                                  ],
                                  "verification": "Escreva a prova completa em LaTeX e teste com contraexemplo sem Dirichlet.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de PDEs (Folland)",
                                    "Overleaf para LaTeX",
                                    "Exemplos numéricos em FreeFEM++"
                                  ],
                                  "tips": "Combine os dois argumentos para prova robusta: máximo para clássico, energia para fraco.",
                                  "learningObjective": "Construir e explicar a prova de unicidade passo a passo.",
                                  "commonMistakes": [
                                    "Pular verificação na fronteira",
                                    "Usar princípio do máximo sem homogeneidade",
                                    "Ignorar soluções fracas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Aplicar a Unicidade em Contextos Práticos",
                                  "subSteps": [
                                    "Resolva numericamente um problema elíptico e altere condições para ver não-unicidade.",
                                    "Compare soluções com diferentes g na fronteira.",
                                    "Discuta quando unicidade falha (ex: Neumann puro).",
                                    "Relacione com teorema de existência via Lax-Milgram.",
                                    "Crie um diagrama resumindo o papel das condições Dirichlet."
                                  ],
                                  "verification": "Implemente um solver simples e mostre que solução é única alterando g.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB PDE Toolbox",
                                    "Python NumPy/SciPy",
                                    "Artigos sobre condições de contorno"
                                  ],
                                  "tips": "Use métodos de diferenças finitas para validar teoricamente.",
                                  "learningObjective": "Aplicar o conceito de unicidade em simulações e generalizações.",
                                  "commonMistakes": [
                                    "Confundir unicidade com estabilidade",
                                    "Testar em domínios não-regulares",
                                    "Esquecer normalização de f"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema -Δu = 1 em disco unitário Ω com u=0 na fronteira. Mostre unicidade: suponha v outra solução, então w=u-v harmônica com w=0 na borda. Pelo máximo, max|w|=0 na borda implica w=0 em Ω. Numericamente, resolva via séries de Fourier: u(r,θ) = (1-r²)/4, única.",
                              "finalVerifications": [
                                "Explique verbalmente a prova de unicidade sem consultar notas.",
                                "Prove unicidade para problema homogêneo usando energia.",
                                "Identifique falhas de unicidade sem Dirichlet.",
                                "Simule numericamente e confirme unicidade variando g.",
                                "Resuma em um slide: 'Dirichlet → Máximo + Positividade → Unicidade'.",
                                "Aplique a um problema não-homogêneo e verifique."
                              ],
                              "assessmentCriteria": [
                                "Clareza na distinção entre existência e unicidade.",
                                "Correta aplicação do princípio do máximo com condições.",
                                "Uso preciso da positividade/forma bilinear.",
                                "Prova completa sem lacunas lógicas.",
                                "Exemplos concretos e verificação numérica.",
                                "Conexão com teoremas mais amplos (Lax-Milgram)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Potencial eletrostático único em condutores (∇²φ=0).",
                                "Engenharia: Distribuição de tensão em placas com bordas fixas.",
                                "Computação: Algoritmos de elementos finitos dependem de unicidade.",
                                "Análise: Espaços de Sobolev e embeddings.",
                                "Otimização: Unicidade em minimização de energia funcional."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor estacionário (equação de Laplace), condições de Dirichlet (temperatura fixa na borda) garantem solução única para previsão de temperaturas em reatores nucleares ou chips de computador, evitando ambiguidades em designs de engenharia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Interpretar fisicamente em contextos reais",
                            "description": "Relacionar condições de Dirichlet a situações físicas como temperatura fixa na fronteira em problemas de condução de calor estacionário ou potencial elétrico especificado em eletrostática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição matemática das condições de Dirichlet",
                                  "subSteps": [
                                    "Leia a definição formal: u(x) = g(x) para x na fronteira ∂Ω.",
                                    "Identifique que se trata de valores fixos na fronteira do domínio.",
                                    "Compare com condições de Neumann (fluxo) para destacar diferenças.",
                                    "Esboce um domínio simples (ex: retângulo) e marque a fronteira.",
                                    "Anote exemplos de equações elípticas como Laplace ou Poisson."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e esboce um diagrama rotulado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (capítulo de EDP), papel e lápis.",
                                  "tips": "Use analogias cotidianas, como 'fronteira é como as paredes de uma sala'.",
                                  "learningObjective": "Compreender precisamente o significado matemático das condições de Dirichlet.",
                                  "commonMistakes": "Confundir com condições iniciais em EDOs ou ignorar o domínio fechado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar interpretação física no problema de condução de calor estacionário",
                                  "subSteps": [
                                    "Recorde a equação: Δu = 0 (estado estacionário) com u = T_fronteira na borda.",
                                    "Visualize uma placa metálica com temperaturas fixas nas bordas (ex: 0°C em três lados, 100°C em um).",
                                    "Explique que a temperatura interna se ajusta para satisfazer equilíbrio (sem fontes).",
                                    "Calcule analiticamente um caso 1D simples: barra com extremidades a T1 e T2.",
                                    "Discuta gradiente de temperatura como fluxo de calor."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como a temperatura na fronteira dita o campo interno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de visualização (ex: MATLAB ou Python com Matplotlib), exemplos de livros de Física.",
                                  "tips": "Pense em 'condução' como difusão sem mudança temporal para estacionário.",
                                  "learningObjective": "Relacionar Dirichlet a temperaturas prescritas em condução térmica.",
                                  "commonMistakes": "Esquecer que é estacionário (não transitório) ou confundir com convecção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar interpretação em eletrostática com potencial elétrico",
                                  "subSteps": [
                                    "Lembre a equação de Laplace: Δφ = 0 fora de cargas, φ = V_especificado na fronteira.",
                                    "Imagine um condensador paralelo com placas a potenciais fixos.",
                                    "Descreva linhas de campo elétrico perpendiculares a condutores equipotenciais.",
                                    "Resolva um exemplo 2D simples usando separação de variáveis.",
                                    "Compare com calor: potencial φ análogo a temperatura u."
                                  ],
                                  "verification": "Esboce o campo de potencial e campo elétrico (-∇φ) para um domínio dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador online de eletrostática (ex: PhET), caderno de exercícios.",
                                  "tips": "Use a analogia 'equipotencial como isolínea de temperatura'.",
                                  "learningObjective": "Mapear condições de Dirichlet a potenciais fixos em eletrostática.",
                                  "commonMistakes": "Confundir potencial com campo elétrico ou ignorar ausência de cargas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e generalizar interpretações físicas",
                                  "subSteps": [
                                    "Liste semelhanças: ambas modelam equilíbrio com valores fixos na borda.",
                                    "Identifique outros contextos: fluxo incompressível, tensão em membranas.",
                                    "Crie uma tabela comparativa: calor vs. eletricidade vs. outros.",
                                    "Discuta limitações: ideais, sem perdas ou não-linearidades.",
                                    "Aplique a um problema híbrido, como difusão de concentração."
                                  ],
                                  "verification": "Explique em um parágrafo unificado como Dirichlet representa 'controle de fronteira físico'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela em planilha ou papel, referências interdisciplinares.",
                                  "tips": "Busque padrões: 'Dirichlet fixa o valor, Neumann fixa o fluxo'.",
                                  "learningObjective": "Generalizar a interpretação física além de exemplos isolados.",
                                  "commonMistakes": "Sobregeneralizar para dinâmicas (hiperbólicas) ou ignorar contexto elíptico."
                                }
                              ],
                              "practicalExample": "Considere uma barra de metal de comprimento 1m com extremidades mantidas a 0°C e 100°C em estado estacionário. A condição de Dirichlet u(0)=0, u(1)=100 modela isso, resultando em u(x)=100x linear, representando gradiente térmico constante.",
                              "finalVerifications": [
                                "Pode explicar a diferença física entre Dirichlet e Neumann em condução de calor.",
                                "Desenha corretamente o perfil de temperatura/potencial para um domínio simples.",
                                "Identifica analogias entre calor e eletricidade sem hesitação.",
                                "Aplica o conceito a um novo contexto físico (ex: fluxo de fluido).",
                                "Discute limitações reais das aproximações elípticas.",
                                "Resolve um problema 1D analiticamente com condições dadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática e física (90% correto).",
                                "Capacidade de visualização e esboço de campos (diagrama claro).",
                                "Profundidade nas analogias interdisciplinares (múltiplos exemplos).",
                                "Correção em cálculos simples de verificação.",
                                "Criatividade em generalizações para contextos reais.",
                                "Clareza na comunicação oral/escrita da interpretação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletrodinâmica e Termodinâmica.",
                                "Engenharia: Mecânica dos Fluidos e Transferência de Calor.",
                                "Computação: Simulações numéricas com métodos finitos.",
                                "Química: Difusão estacionária em reatores."
                              ],
                              "realWorldApplication": "Em engenharia térmica, projeta isolantes para manter temperaturas fixas em paredes de fornos; em eletrônica, otimiza layouts de circuitos para potenciais prescritos em eletrodos, evitando superaquecimento ou campos indesejados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Analisar estabilidade e bem-pose",
                            "description": "Discutir como condições de Dirichlet contribuem para a estabilidade do problema elíptico, evitando soluções não únicas ou instáveis comuns em condições puramente de Neumann.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Bem-Posedness",
                                  "subSteps": [
                                    "Estude a definição de Hadamard para problemas bem-postos: existência, unicidade e estabilidade da solução.",
                                    "Analise exemplos simples de problemas mal-postos, como derivada sem condição inicial.",
                                    "Discuta a importância da estabilidade em termos de dependência contínua dos dados de entrada.",
                                    "Revise operadores elípticos lineares e suas propriedades de invertibilidade.",
                                    "Identifique métricas como normas em espaços de Sobolev para medir estabilidade."
                                  ],
                                  "verification": "Resuma em um parágrafo os três pilares de Hadamard e dê um exemplo de violação de cada um.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Evans PDE), notas de aula sobre Análise Numérica II.",
                                  "tips": "Use analogias físicas: existência como 'sempre há solução', unicidade como 'apenas uma', estabilidade como 'pequenas mudanças não explodem'.",
                                  "learningObjective": "Compreender os critérios essenciais para um problema ser bem-posto.",
                                  "commonMistakes": "Confundir estabilidade com convergência numérica; focar apenas em existência sem unicidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Condições de Contorno: Dirichlet vs. Neumann",
                                  "subSteps": [
                                    "Defina condições de Dirichlet: u = g na fronteira.",
                                    "Defina condições de Neumann: ∂u/∂n = h na fronteira.",
                                    "Estude o problema modelo -Δu = f em Ω, com diferentes BCs.",
                                    "Discuta o espaço de funções admissíveis para cada tipo de BC (H^1 para Dirichlet, H^1 com média zero para Neumann).",
                                    "Calcule o operador bilinear associado e verifique coercividade."
                                  ],
                                  "verification": "Esboce os espaços de energia para ambos os problemas e compare dimensões do núcleo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como MATLAB ou Python (FEniCS) para visualizar soluções, quadro branco.",
                                  "tips": "Desenhe domínios simples (círculo, quadrado) e anote BCs nas bordas para visualização.",
                                  "learningObjective": "Diferenciar matematicamente as duas condições de contorno em problemas elípticos.",
                                  "commonMistakes": "Ignorar normalização para Neumann; assumir simetria sem verificar compatibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Falhas de Estabilidade e Unicidade em Neumann Puro",
                                  "subSteps": [
                                    "Mostre que para Neumann puro, soluções diferem por constantes (núcleo do operador laplaciano).",
                                    "Demonstre não-unicidade: integre a equação sobre Ω para condição de compatibilidade ∫h = ∫f.",
                                    "Examine instabilidade: pequenas perturbações em h levam a grandes variações em soluções normalizadas.",
                                    "Use exemplo numérico: resolva -Δu=0 com Neumann zero (soluções constantes arbitrárias).",
                                    "Discuta teorema de Fredholm: índice zero, mas não injetivo."
                                  ],
                                  "verification": "Resolva analiticamente um problema Neumann puro e identifique o espaço de soluções.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Caderno de exercícios, solver simbólico (SymPy), referências como Brezis Functional Analysis.",
                                  "tips": "Sempre verifique a condição de compatibilidade antes de qualquer simulação.",
                                  "learningObjective": "Identificar precisamente por que Neumann puro falha em unicidade e estabilidade.",
                                  "commonMistakes": "Esquecer a condição de solvibilidade; normalizar incorretamente a solução."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Contribuições das Condições de Dirichlet para Estabilidade",
                                  "subSteps": [
                                    "Prove unicidade via identidade de energia: ∫|∇u|^2 = 0 implica u constante, mas Dirichlet força u=0 na borda.",
                                    "Estabeleça a priori estimate: ||u||_{H^1} ≤ C(||f||_{L^2} + ||g||_{H^{1/2}}).",
                                    "Discuta coercividade do bilinear form para Dirichlet: α||u||^2 ≤ a(u,u).",
                                    "Compare numericamente: resolva mesmo problema com Dirichlet vs. Neumann misto.",
                                    "Analise bem-posedness em norma: dependência contínua via Lax-Milgram."
                                  ],
                                  "verification": "Derivar a estimativa a priori para um problema Dirichlet e discuta sua ausência em Neumann.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "FEniCS ou FreeFEM para simulações, teoremas de Lax-Milgram anotados.",
                                  "tips": "Use teste de Poincaré-Friedrichs para ligar Dirichlet à coercividade em H^1_0.",
                                  "learningObjective": "Explicar matematicamente como Dirichlet garante bem-posedness.",
                                  "commonMistakes": "Confundir H^1_0 com H^1; ignorar trace theorem para g."
                                }
                              ],
                              "practicalExample": "Considere a equação de Poisson -Δu = 1 em unidade disco Ω, com Neumann puro ∂u/∂n=0: soluções u = |x|^2/4 + C, não única. Com Dirichlet u=0 na borda: solução única u = (|x|^2 -1)/4, estável sob perturbações em f ou g.",
                              "finalVerifications": [
                                "Explicar verbalmente os três critérios de Hadamard para problemas elípticos.",
                                "Derivar analiticamente a não-unicidade em Neumann puro.",
                                "Apresentar estimativa a priori para Dirichlet usando identidade de energia.",
                                "Simular numericamente um problema misto e discutir estabilidade.",
                                "Comparar soluções Dirichlet/Neumann para mesmo f em software.",
                                "Discutir impacto de ruído nos dados de contorno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de unicidade via energia (100% correto).",
                                "Correta identificação de falhas em Neumann (compatibilidade, núcleo).",
                                "Uso apropriado de teoremas (Lax-Milgram, Poincaré) com condições.",
                                "Análise qualitativa/quantitativa de estabilidade via normas.",
                                "Explicação clara de dependência contínua dos dados.",
                                "Exemplo prático resolvido sem erros aritméticos.",
                                "Conexão explícita entre teoria e instabilidade prática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em equações de equilíbrio térmico/elástico.",
                                "Engenharia Computacional: Condições de contorno em FEA (Finite Element Analysis).",
                                "Análise de Dados: Regularização em problemas inversos elípticos.",
                                "Otimização: Problemas variacionais com restrições de Dirichlet."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor (Dirichlet para temperatura fixa na borda), evita instabilidades numéricas vistas em isolamento total (Neumann), essencial para modelagem precisa em engenharia aeroespacial e geofísica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Discretização com Diferenças Finitas",
                        "description": "Implementação numérica das condições de Dirichlet usando métodos de diferenças finitas em malhas retangulares para equações elípticas, incluindo imposição direta nos nós de fronteira.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Impor condições de Dirichlet em grade finita",
                            "description": "Modificar o sistema linear de diferenças finitas para o Laplaciano discretizado, fixando os valores nos pontos de fronteira e ajustando as equações internas adjacentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o domínio, grade finita e identificar pontos de fronteira",
                                  "subSteps": [
                                    "Defina o domínio retangular Ω = [0,1] × [0,1] e a função f(x,y) do lado direito.",
                                    "Escolha h = 1/(N+1) para grade uniforme com (N+2) × (N+2) pontos.",
                                    "Identifique nós fronteira (i=0 ou i=N+1, j=0 ou j=N+1) e nós internos (1≤i,j≤N).",
                                    "Anote as condições de Dirichlet: u|_{∂Ω} = g(x,y).",
                                    "Desenhe a grade numerando os pontos internos sequencialmente (ex: linha por linha)."
                                  ],
                                  "verification": "Grade desenhada com pelo menos 4x4 pontos, fronteiras marcadas e N pontos internos contados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (GeoGebra/MATLAB)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use grade pequena (N=3) para testes manuais; visualize em 2D para clareza.",
                                  "learningObjective": "Compreender a topologia da grade finita e distinção entre nós internos e fronteira.",
                                  "commonMistakes": [
                                    "Confundir h com espaçamento total",
                                    "Contar mal o número de equações (deve ser N²)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever o stencil padrão do Laplaciano para pontos internos não-adjacentes à fronteira",
                                  "subSteps": [
                                    "Lembre o Laplaciano discretizado: (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² = f_{i,j}.",
                                    "Multiplique por h²: u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = h² f_{i,j}.",
                                    "Para pontos distantes da fronteira (ex: 2≤i,j≤N-1), o stencil é padrão [-4,1,1,1,1].",
                                    "Teste em um ponto interno central, escrevendo a equação explícita.",
                                    "Verifique simetria e consistência de segunda ordem."
                                  ],
                                  "verification": "Equação stencil escrita corretamente para um ponto interno, com coeficientes somando zero (exceto diagonal).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculos",
                                    "Calculadora ou Python para validar stencil"
                                  ],
                                  "tips": "Sempre normalize multiplicando por h² para matriz sem frações; memorize o padrão 5-pontos.",
                                  "learningObjective": "Dominar a discretização central de diferenças finitas para o Laplaciano em 2D.",
                                  "commonMistakes": [
                                    "Esquecer fator h²",
                                    "Usar aproximação forward/backward em internos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar equações para pontos internos adjacentes à fronteira incorporando condições de Dirichlet",
                                  "subSteps": [
                                    "Para nó adjacente à esquerda (i=1, j interno): substitua u_{0,j} = g_{0,j} na equação, movendo para o lado direito.",
                                    "Equação torna-se: -3 u_{1,j} + u_{2,j} + u_{1,j+1} + u_{1,j-1} = h² f_{1,j} - g_{0,j}.",
                                    "Repita para bordas direita (i=N), superior (j=N), inferior (j=1), ajustando coeficientes (-3 na diagonal).",
                                    "Cantos adjacentes: ajuste dois termos de fronteira (diagonal -2).",
                                    "Liste todas as modificações para uma grade N=3."
                                  ],
                                  "verification": "Equações modificadas para todos nós adjacentes, com termos de g corretamente no vetor b.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grade impressa",
                                    "Tabela para listar equações por nó"
                                  ],
                                  "tips": "Use notação u_{i,j} = g quando i=0,N+1 ou j=0,N+1; mova sempre para b.",
                                  "learningObjective": "Aplicar condições de Dirichlet eliminando variáveis de fronteira do sistema.",
                                  "commonMistakes": [
                                    "Deixar coeficiente 1 para fronteira em A",
                                    "Sinal errado ao mover g para b"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o sistema linear global Ax = b e validar estrutura",
                                  "subSteps": [
                                    "Numere variáveis: k = (i-1)*N + j para 1≤i,j≤N, total M = N² equações.",
                                    "Construa matriz A (M x M) esparsa: diagonais principais e sub/superdiagonais.",
                                    "Preencha A e b com stencils padrão e modificados.",
                                    "Para grade pequena (N=2), monte A e b explicitamente e resolva manualmente.",
                                    "Verifique propriedades: A simétrica definida positiva, ordem de consistência O(h²)."
                                  ],
                                  "verification": "Matriz A e vetor b montados, com solver simples confirmando u_fronteira ≈ g.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/NumPy ou MATLAB para montar A/b",
                                    "Solver Gauss-Seidel opcional"
                                  ],
                                  "tips": "Use indexação linha-maior para vetorizar; implemente em código para grades maiores.",
                                  "learningObjective": "Formar e validar o sistema linear para BVP elíptico com Dirichlet.",
                                  "commonMistakes": [
                                    "Indexação errada em 2D para 1D",
                                    "Incluir linhas de fronteira em A"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 2π² sin(πx) sin(πy) em [0,1]² com u=0 na fronteira, usando grade h=1/4 (N=3). Solução exata: u=sin(πx)sin(πy). Monte A (9x9), b com f e zeros (fronteira homogênea), resolva e verifique erro <1%.",
                              "finalVerifications": [
                                "Número de equações = número de nós internos (N²).",
                                "Valores de fronteira g incorporados corretamente em b para nós adjacentes.",
                                "Matriz A simétrica com diagonais dominantes (-4 ou -3).",
                                "Solução u satisfaz u|_{fronteira aproximada} = g.",
                                "Resíduo ||Au - b|| < 10^{-6} h².",
                                "Convergência do solver iterativo monotônica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modificação de stencils adjacentes (coeficientes corretos).",
                                "Correta eliminação de variáveis de fronteira (sem linhas extras em A).",
                                "Indexação consistente de 2D para 1D no sistema global.",
                                "Validação numérica com exemplo pequeno (erro O(h²)).",
                                "Explicação clara de por que Dirichlet 'congela' fronteiras.",
                                "Uso eficiente de estrutura esparsa em implementação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equilíbrio térmico (equação de calor estacionária).",
                                "Computação: Algoritmos para sistemas lineares esparsos (GMRES, multigrid).",
                                "Engenharia: Análise de tensões em placas (equações de Poisson).",
                                "Programação: Implementação em Python/NumPy para visualização de soluções."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em uma placa metálica com temperaturas fixas nas bordas (controle de processos industriais), ou potencial elétrico em capacitores com eletrodos fixos (eletrônica)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1",
                              "10.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Derivar o esquema de diferenças finitas",
                            "description": "Construir a matriz tridiagonal ou pentadiagonal para o problema modelo -u_xx - u_yy = f com u=0 na fronteira usando diferenças centrais de segunda ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o domínio, grade e notação",
                                  "subSteps": [
                                    "Defina o domínio retangular Ω = [0,1] × [0,1] com condições de Dirichlet homogêneas u=0 na fronteira ∂Ω.",
                                    "Escolha h = 1/(N+1) como passo de grade uniforme em x e y, criando uma grade (N+2)×(N+2) pontos incluindo fronteira.",
                                    "Rotule os pontos interiores como i=1 a N, j=1 a N, com u_{i,j} ≈ u(x_i, y_j) onde x_i = i h, y_j = j h.",
                                    "Escreva a equação modelo -Δu = f em Ω, com Δu = u_xx + u_yy.",
                                    "Identifique os pontos fronteira onde u_{0,j}=u_{N+1,j}=u_{i,0}=u_{i,N+1}=0."
                                  ],
                                  "verification": "Verifique se a grade tem exatamente N² incógnitas interiores e h está correto para o domínio unitário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Referência: Livro de Análise Numérica (ex: LeVeque)"
                                  ],
                                  "tips": "Desenhe a grade em papel para visualizar os pontos interiores e fronteira.",
                                  "learningObjective": "Entender a discretização espacial e notação padrão para problemas elípticos 2D.",
                                  "commonMistakes": [
                                    "Confundir número de pontos totais vs. incógnitas (N²)",
                                    "Errar o espaçamento h=1/(N+1)",
                                    "Ignorar simetria x-y"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar aproximações de diferenças finitas centrais para derivadas segundas",
                                  "subSteps": [
                                    "Para ∂²u/∂x² em (i,j): use (u_{i+1,j} - 2u_{i,j} + u_{i-1,j})/h², com erro O(h²).",
                                    "Para ∂²u/∂y² em (i,j): use (u_{i,j+1} - 2u_{i,j} + u_{i,j-1})/h², com erro O(h²).",
                                    "Some as aproximações: -Δu_{i,j} ≈ -[(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h²] = f_{i,j}.",
                                    "Multiplique por h²: u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = h² f_{i,j}.",
                                    "Desenhe o stencil de 5 pontos: centro -4, vizinhos +1 cada."
                                  ],
                                  "verification": "Confirme que o operador Laplaciano discreto tem stencil simétrico com -4 no centro e +1 nos quatro vizinhos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de desenho (opcional: TikZ ou GeoGebra)"
                                  ],
                                  "tips": "Lembre-se: diferenças centrais de segunda ordem vêm da expansão de Taylor truncada.",
                                  "learningObjective": "Dominar a derivação do stencil de diferenças finitas para o Laplaciano 2D.",
                                  "commonMistakes": [
                                    "Usar diferenças forward/backward em vez de central",
                                    "Esquecer o sinal negativo no Laplaciano",
                                    "Erro no fator -4 vs. +4"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar condições de fronteira e tratar pontos próximos à fronteira",
                                  "subSteps": [
                                    "Para pontos interiores distantes da fronteira (i,j ≥2 e ≤N-1): aplique o stencil completo.",
                                    "Para pontos na borda esquerda (i=1, j=2..N-1): u_{0,j}=0, então stencil vira u_{2,j} + 0 + u_{1,j+1} + u_{1,j-1} - 3u_{1,j} = h² f_{1,j}.",
                                    "Similar para borda direita (i=N), inferior (j=1), superior (j=N): ajuste o coeficiente central para -3.",
                                    "Para cantos interiores (ex: i=1,j=1): u_{0,1}=u_{1,0}=0, stencil: u_{2,1} + u_{1,2} - 2u_{1,1} = h² f_{1,1}.",
                                    "Verifique simetria para todos os quatro cantos."
                                  ],
                                  "verification": "Teste com N=2: liste equações para os 4 pontos e confirme ajustes de BCs.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Python para listar equações pequenas"
                                  ],
                                  "tips": "Sempre substitua u_fronteira=0 diretamente no stencil.",
                                  "learningObjective": "Incorporar condições de Dirichlet homogêneas no esquema discreto.",
                                  "commonMistakes": [
                                    "Esquecer de ajustar o diagonal para -3 nas bordas",
                                    "Aplicar stencil completo na fronteira",
                                    "Confundir cantos (-2) com bordas (-3)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ordenar variáveis e construir a matriz do sistema linear",
                                  "subSteps": [
                                    "Use ordenação por linhas: k = (j-1)N + i para u_k = u_{i,j}, k=1 a M=N².",
                                    "Para ponto interior: entradas na matriz A: diagonal A_{k,k}=-4, A_{k,k-1}=1 (esquerda), A_{k,k+1}=1 (direita), A_{k,k-N}=1 (baixo), A_{k,k+N}=1 (cima).",
                                    "Ajuste para bordas: ex. primeira linha (j=1): sem A_{k,k-N}, diagonal -3; primeira coluna (i=1): sem A_{k,k-1}, diagonal -3.",
                                    "Para cantos: ex. k=1 (i=1,j=1): A_{1,1}=-2, A_{1,2}=1 (direita), A_{1,N+1}=1 (cima).",
                                    "O sistema é A u = b, com b_k = h² f_{i,j} e A pentadiagonal ou block-tridiagonal."
                                  ],
                                  "verification": "Construa A explicitamente para N=2 (4x4) e confira que é simétrica e dominante diagonalmente.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "MATLAB/Python/Octave para gerar matriz pequena",
                                    "Papel para N=2 manualmente"
                                  ],
                                  "tips": "Visualize a ordenação: varre linhas da esquerda para direita, baixo para cima.",
                                  "learningObjective": "Mapear stencil para matriz esparsa via indexação linear.",
                                  "commonMistakes": [
                                    "Erro na indexação k (off-by-one)",
                                    "Confundir ordenação row-major vs. column-major",
                                    "Esquecer ajustes em sub/super-diagonais de bloco"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar o esquema e analisar propriedades",
                                  "subSteps": [
                                    "Confirme consistência: truncagem O(h²) implica convergência para soluções suaves.",
                                    "Verifique simetria de A (pentadiagonal simétrica positiva definida).",
                                    "Teste com f=0 (Laplace): solução u=0 satisfaz.",
                                    "Para grade pequena (N=3), monte A (9x9) e resolva Au=b com b conhecido.",
                                    "Discuta estabilidade: método implicitamente estável para elípticas."
                                  ],
                                  "verification": "Resolva numericamente para f=π² sin(πx)sin(πy) (solução exata u=sin(πx)sin(πy)) e cheque erro O(h²).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python com NumPy/SciPy para solver"
                                  ],
                                  "tips": "Use sparse matrices para eficiência em N maior.",
                                  "learningObjective": "Analisar propriedades do esquema (consistência, simetria, SPD).",
                                  "commonMistakes": [
                                    "Ignorar fator h² em b",
                                    "Esperar tridiagonal em 2D (é pentadiagonal)",
                                    "Não testar com solução conhecida"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=2, h=1/3, domínio [0,1]², f_{i,j}=0 (Laplace homogêneo). Grade 4x4 pontos, 4 incógnitas. Equações: Para u11: u21 + u12 -2u11=0; u21: u11 + u22 -2u21=0 (ajuste borda); etc. Matriz A 4x4: [[-2,1,1,0],[1,-3,0,1],[1,0,-3,1],[0,1,1,-2]], solução u=0.",
                              "finalVerifications": [
                                "Stencil correto: -4 centro, +1 vizinhos para interior.",
                                "Ajustes de BCs: -3 bordas, -2 cantos.",
                                "Matriz A simétrica, pentadiagonal, dominante diagonal para qualquer N.",
                                "Indexação k=(j-1)N+i produz conexões corretas (k±1, k±N).",
                                "Teste numérico para N=3 com solução exata mostra erro <1e-3.",
                                "h=1/(N+1) e M=N² incógnitas confirmados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do stencil (ordem O(h²) e coeficientes exatos).",
                                "Correta incorporação de BCs Dirichlet em todos os casos (bordas/cantos).",
                                "Indexação linear sem erros off-by-one e estrutura pentadiagonal.",
                                "Análise de propriedades: simetria, positividade, consistência.",
                                "Validação prática com exemplo pequeno e código.",
                                "Explicação clara de tridiagonal/pentadiagonal em 1D/2D."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos escalares (calor estacionário, potencial eletrostático).",
                                "Computação: Algoritmos iterativos (Gauss-Seidel, multigrid) para matrices esparsas.",
                                "Engenharia: Simulações CFD/estrutural com EDPs elípticas.",
                                "Programação: Implementação em Python/NumPy para solvers lineares."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em placas com bordas fixas (engenharia térmica), cálculo de potenciais em eletrostática (física computacional), ou modelagem de fluxo incompressível em reservatórios (petróleo/geologia)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Avaliar consistência e convergência",
                            "description": "Verificar a consistência de O(h²) do esquema com condições de Dirichlet e discutir convergência via teorema de Lax-Richtmyer para operadores elípticos simétricos positivos definidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema de diferenças finitas para condições de Dirichlet em equações elípticas",
                                  "subSteps": [
                                    "Relembrar a forma geral da equação elíptica: -Δu = f em Ω com u=0 em ∂Ω.",
                                    "Descrever o stencil de 5 pontos centrado para a aproximação do laplaciano: (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² ≈ Δu.",
                                    "Explicar a imposição das condições de Dirichlet nas fronteiras ajustando os valores nas malhas fronteiriças.",
                                    "Derivar a matriz tridiagonal ou pentadiagonal resultante da discretização.",
                                    "Verificar estabilidade básica da malha uniforme."
                                  ],
                                  "verification": "Escrever o esquema discreto completo para um domínio quadrado unitário e confirmar que incorpora corretamente as condições de Dirichlet.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e lápis ou software como MATLAB para stencil visual.",
                                  "tips": "Desenhe a malha 2D para visualizar como as fronteiras são tratadas.",
                                  "learningObjective": "Compreender a estrutura do esquema numérico antes da análise de consistência.",
                                  "commonMistakes": "Confundir aproximação centrada com forward/backward nas fronteiras; sempre use interpolação linear para Dirichlet."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a consistência de ordem O(h²) do esquema",
                                  "subSteps": [
                                    "Calcular o erro de truncamento local usando expansão de Taylor para cada termo do laplaciano.",
                                    "Mostrar que Δu_{i,j} - [stencil]/h² = O(h²) interiormente.",
                                    "Analisar o erro nas fronteiras próximas, confirmando que permanece O(h²) com interpolação adequada.",
                                    "Derivar a norma do operador de truncamento τ_h(u) ≤ C h² ||D⁴u|| para u suave.",
                                    "Testar numericamente com uma solução exata conhecida (ex: u(x,y)=sin(πx)sin(πy))."
                                  ],
                                  "verification": "Derivar explicitamente o termo O(h²) na expansão de Taylor e computar ||τ_h(u)|| para h=1/10, 1/20.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), código MATLAB para erro numérico.",
                                  "tips": "Use a expansão de Taylor até ordem 4 para capturar o h⁴ que cancela, deixando h².",
                                  "learningObjective": "Dominar o cálculo de consistência via erro de truncamento.",
                                  "commonMistakes": "Esquecer termos cruzados na Taylor 2D; expanda cada direção separadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o teorema de Lax-Richtmyer para convergência",
                                  "subSteps": [
                                    "Enunciar o teorema: Para esquemas consistentes, estabilidade implica convergência.",
                                    "Explicar os conceitos de estabilidade em norma L² e consistência.",
                                    "Aplicar a operadores elípticos: A matriz A_h é simétrica positiva definida (SPD) se o operador contínuo for.",
                                    "Mostrar que ||A_h^{-1}|| ≤ C / λ_min, onde λ_min é o menor autovalor positivo.",
                                    "Discutir como consistência + SPD garante ||e_h|| ≤ C h² ||u||_{H^4}."
                                  ],
                                  "verification": "Provar que para o stencil de Laplace, A_h é SPD usando propriedades de grafos ou autovalores conhecidos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Notas de análise numérica, referências ao teorema (ex: Gustafsson et al.).",
                                  "tips": "Lembre que Lax-Richtmyer é geral; para elípticos, usa equações de Poincaré-Friedrichs.",
                                  "learningObjective": "Entender o teorema fundamental ligando consistência, estabilidade e convergência.",
                                  "commonMistakes": "Confundir estabilidade com consistência; estabilidade é boundedness de ||S^n||."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar análise para operadores elípticos simétricos positivos definidos",
                                  "subSteps": [
                                    "Generalizar para -∇·(A∇u) = f, com A simétrica positiva.",
                                    "Verificar consistência O(h²) para stencil generalizado.",
                                    "Confirmar SPD da matriz discreta via mimetismo ou análise espectral.",
                                    "Discutir taxa de convergência ótima sob regularidade H^{2+ε}.",
                                    "Simular numericamente convergência com refinamento h."
                                  ],
                                  "verification": "Resolver um problema modelo, plotar log||erro|| vs log h com slope 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software FEniCS ou MATLAB para simulação, solução exata.",
                                  "tips": "Use grids não-uniformes para testar robustez, mas foque uniforme primeiro.",
                                  "learningObjective": "Aplicar teorema de Lax-Richtmyer a casos elípticos gerais.",
                                  "commonMistakes": "Ignorar positividade; verifique autovalores da matriz A_h."
                                }
                              ],
                              "practicalExample": "Considere a equação de Poisson -Δu = 2π² sin(πx) sin(πy) em [0,1]² com u=0 na fronteira. Solução exata: u=sin(πx)sin(πy). Discretize com h=1/N, aplique stencil 5-pt, compute erro L² em h=1/10,1/20,1/40 e confirme O(h²), usando Lax-Richtmyer para justificar convergência pois A_h SPD.",
                              "finalVerifications": [
                                "Derivação correta do erro de truncamento O(h²) com Taylor.",
                                "Enunciado preciso do teorema de Lax-Richtmyer.",
                                "Prova de SPD para o operador discreto.",
                                "Simulação numérica mostrando taxa de convergência 2.",
                                "Discussão de condições para operadores elípticos gerais.",
                                "Identificação de limitações (ex: singularidades)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (pontos por termos corretos).",
                                "Correta aplicação do teorema Lax-Richtmyer (inclui estabilidade).",
                                "Demonstração de SPD via autovalores ou propriedades.",
                                "Análise numérica com log-log plot slope ≈2.",
                                "Clareza na generalização para operadores elípticos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potenciais eletrostáticos via Poisson.",
                                "Computação: Implementação eficiente de solvers SPD (CG).",
                                "Engenharia: Análise de tensões em estruturas (elípticas).",
                                "Estatística: Métodos de elementos finitos em inferência bayesiana."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em placas (engenharia mecânica), modelagem de campos gravitacionais em astrofísica, ou predição de temperaturas em modelagem climática, onde verificar consistência O(h²) e convergência garante precisão em grids computacionais finitos para otimizar tempo de simulação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Tratamento Numérico de Condições de Dirichlet",
                    "description": "Implementação das condições de Dirichlet no esquema de diferenças finitas, ajustando os valores nas malhas fronteiriças.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Condições de Dirichlet em Equações Elípticas",
                        "description": "Definição e importância das condições de Dirichlet em problemas de valor de contorno para equações diferenciais parciais elípticas, como a equação de Laplace ou Poisson, onde o valor da solução é prescrito nas fronteiras do domínio.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir condições de Dirichlet",
                            "description": "Explicar formalmente o que são condições de Dirichlet, diferenciando-as de condições de Neumann, e fornecer exemplos em problemas elípticos como u(x,y) = g(x,y) na fronteira ∂Ω.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral de condições de contorno em EDPs",
                                  "subSteps": [
                                    "Estudar o que são Equações Diferenciais Parciais (EDPs) elípticas e sua necessidade de condições de contorno para unicidade da solução.",
                                    "Identificar tipos comuns de condições de contorno: Dirichlet, Neumann e Robin.",
                                    "Explicar por que condições de contorno são essenciais para problemas de valor de contorno (BVP).",
                                    "Revisar exemplos simples de EDPs elípticas, como a equação de Laplace ∇²u = 0.",
                                    "Discutir o papel da fronteira ∂Ω em domínios Ω."
                                  ],
                                  "verification": "Resumir em 3 frases o propósito das condições de contorno e listar 2 exemplos de EDPs elípticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de EDPs)",
                                    "Papel e caneta para anotações",
                                    "Acesso a slides ou vídeo introdutório sobre EDPs"
                                  ],
                                  "tips": "Comece com analogias físicas, como temperatura em uma placa, para visualizar melhor.",
                                  "learningObjective": "Entender a importância das condições de contorno para soluções únicas de EDPs elípticas.",
                                  "commonMistakes": [
                                    "Confundir EDPs elípticas com parabólicas ou hiperbólicas.",
                                    "Ignorar que condições de contorno garantem unicidade e existência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente as condições de Dirichlet",
                                  "subSteps": [
                                    "Estabelecer a notação: problema elíptico Lu = f em Ω, com L operador elíptico.",
                                    "Definir condições de Dirichlet: u(x) = g(x) para x ∈ ∂Ω, onde g é função dada.",
                                    "Discutir requisitos em g: suavidade (ex. C¹) para regularidade da solução.",
                                    "Escrever a formulação matemática precisa: encontrar u ∈ H¹(Ω) tal que u|∂Ω = g.",
                                    "Explorar propriedades: condições de Dirichlet são 'essenciais' em métodos variacionais."
                                  ],
                                  "verification": "Escrever a definição formal em notação matemática e parafraseá-la em palavras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno de matemática",
                                    "Referência: Evans 'PDE' ou Brenner-Scott 'Mathematical Foundations'",
                                    "Software como Overleaf para LaTeX"
                                  ],
                                  "tips": "Use espaços de Sobolev (H¹) para precisão, mas comece com funções clássicas C².",
                                  "learningObjective": "Formular matematicamente as condições de Dirichlet e suas propriedades.",
                                  "commonMistakes": [
                                    "Escrever u'(x)=g(x) em vez de u(x)=g(x).",
                                    "Confundir com condições homogêneas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar condições de Dirichlet de Neumann",
                                  "subSteps": [
                                    "Definir condições de Neumann: ∂u/∂n = h(x) em ∂Ω, onde n é normal exterior.",
                                    "Comparar: Dirichlet especifica valor (u), Neumann especifica derivada normal (fluxo).",
                                    "Discutir compatibilidade: Neumann requer ∫h ds = ∫f dΩ para existência.",
                                    "Analisar impacto na solução: Dirichlet fixa valores na fronteira, Neumann permite 'flutuação'.",
                                    "Exemplarizar com equação de Poisson: diferenças em formulações fracas."
                                  ],
                                  "verification": "Criar uma tabela comparativa com 4 colunas: Definição, Exemplo, Propriedades, Problemas de existência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplos de livros de EDPs",
                                    "Calculadora para integrais simples"
                                  ],
                                  "tips": "Pense em termos físicos: Dirichlet = temperatura fixa, Neumann = fluxo de calor fixo.",
                                  "learningObjective": "Distinguir precisamente Dirichlet de Neumann e suas implicações.",
                                  "commonMistakes": [
                                    "Trocar derivada normal por tangencial.",
                                    "Esquecer condições de compatibilidade em Neumann."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em exemplos de problemas elípticos",
                                  "subSteps": [
                                    "Resolver exemplo: ∇²u = 0 em quadrado [0,1]², u(x,0)=0, u(x,1)=sin(πx), u(0,y)=0, u(1,y)=0.",
                                    "Verificar satisfação: u na fronteira equals g dado.",
                                    "Explorar generalização: u(x,y)=g(x,y) em ∂Ω arbitrária.",
                                    "Discutir métodos numéricos: elementos finitos com Dirichlet essenciais.",
                                    "Simular numericamente um caso simples em Python/MATLAB."
                                  ],
                                  "verification": "Resolver um exemplo simples e plotar a solução confirmando condições na fronteira.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software Python com NumPy/Matplotlib ou MATLAB",
                                    "Código-fonte exemplo de Laplace com Dirichlet"
                                  ],
                                  "tips": "Use separação de variáveis para soluções analíticas em domínios retangulares.",
                                  "learningObjective": "Illustrar condições de Dirichlet em problemas elípticos concretos.",
                                  "commonMistakes": [
                                    "Não verificar fronteira após solução.",
                                    "Usar Neumann por engano no código."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace ∇²u = 0 no disco unitário Ω = { (x,y) | x² + y² < 1 }, com condições de Dirichlet u(θ) = cos(θ) na fronteira ∂Ω (em coordenadas polares). A solução u(r,θ) = r cos(θ) satisfaz u(1,θ) = cos(θ), demonstrando fixação do valor na fronteira.",
                              "finalVerifications": [
                                "Definir formalmente condições de Dirichlet: u = g em ∂Ω.",
                                "Explicar diferença chave com Neumann (valor vs. derivada normal).",
                                "Fornecer exemplo correto em problema elíptico 2D.",
                                "Identificar quando Dirichlet garante unicidade.",
                                "Discutir suavidade requerida em g.",
                                "Comparar formulações fracas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição (100% correto).",
                                "Clareza na diferenciação com Neumann (tabela ou diagrama).",
                                "Qualidade dos exemplos (analítico + numérico).",
                                "Compreensão de propriedades (unicidade, essencialidade).",
                                "Uso correto de notação (Ω, ∂Ω, H¹).",
                                "Aplicação prática demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potenciais eletrostáticos e equilíbrio térmico.",
                                "Engenharia: Simulações de tensão em placas e fluxo incompressível.",
                                "Computação Científica: Implementação em métodos de elementos finitos (FEM).",
                                "Análise Funcional: Espaços de Sobolev e trace theorem.",
                                "Probabilidade: Processos de Dirichlet e harmonicas."
                              ],
                              "realWorldApplication": "Condições de Dirichlet são usadas em simulações de temperatura em dispositivos eletrônicos (u=g fixa em contatos), modelagem de campos magnéticos em motores elétricos e previsão de deformações em estruturas civis via equações elípticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Identificar condições de Dirichlet em problemas modelo",
                            "description": "Reconhecer e formular condições de Dirichlet em equações elípticas padrão, como -Δu = f em Ω com u = g em ∂Ω, e discutir sua unicidade pela máxima princípio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de condições de Dirichlet",
                                  "subSteps": [
                                    "Ler a definição: condições de Dirichlet especificam o valor da solução u = g diretamente na fronteira ∂Ω de um domínio Ω.",
                                    "Comparar com condições de Neumann, que envolvem derivadas normais.",
                                    "Estudar o contexto em problemas de valor de contorno para equações diferenciais parciais (EDPs).",
                                    "Analisar exemplos em uma dimensão, como -u'' = f em (0,1) com u(0)=a, u(1)=b.",
                                    "Visualizar geometricamente em domínios 2D, como disco ou quadrado."
                                  ],
                                  "verification": "Explicar em suas palavras a diferença entre Dirichlet e Neumann, com um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de EDPs (ex: Evans ou Folland)",
                                    "Notas de aula sobre problemas elípticos",
                                    "Papel e lápis para desenhos"
                                  ],
                                  "tips": "Associe Dirichlet a 'valor prescrito na borda', facilitando a memorização.",
                                  "learningObjective": "Definir precisamente condições de Dirichlet e seu papel em problemas elípticos.",
                                  "commonMistakes": [
                                    "Confundir com condições de Neumann (derivada em vez de valor)",
                                    "Ignorar o domínio Ω e sua fronteira ∂Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer condições de Dirichlet em problemas modelo elípticos",
                                  "subSteps": [
                                    "Examinar o problema padrão: -Δu = f em Ω com u = g em ∂Ω.",
                                    "Identificar componentes: operador laplaciano -Δ, termo fonte f, domínio Ω e condição u=g.",
                                    "Analisar variações, como equação de Poisson ou Helmholtz com Dirichlet homogêneo (g=0).",
                                    "Praticar em problemas escritos: destacar a condição de contorno.",
                                    "Resolver um exemplo simples analiticamente para internalizar."
                                  ],
                                  "verification": "Dado um problema escrito, circule e nomeie a condição de Dirichlet.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de problemas de Análise Numérica II",
                                    "Software como MATLAB ou Python (SymPy) para verificação",
                                    "Folhas de exercícios"
                                  ],
                                  "tips": "Procure sempre por 'u = ... na fronteira' ou equivalentes como 'u|∂Ω = g'.",
                                  "learningObjective": "Identificar rapidamente condições de Dirichlet em formulações padrão de EDPs elípticas.",
                                  "commonMistakes": [
                                    "Interpretar equações mistas como puramente Dirichlet",
                                    "Confundir termo fonte f com condição de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular condições de Dirichlet em problemas elípticos",
                                  "subSteps": [
                                    "Dado um problema físico, traduzir para forma matemática com Dirichlet.",
                                    "Especificar Ω, f, g explicitamente, garantindo compatibilidade.",
                                    "Verificar regularidade: assumir Ω com fronteira suave, f e g contínuos.",
                                    "Escrever a formulação fraca se aplicável, integrando por partes.",
                                    "Testar formulação em um exemplo numérico simples."
                                  ],
                                  "verification": "Formular um problema modelo completo a partir de uma descrição verbal.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Template de problemas elípticos",
                                    "Calculadora ou software simbólico",
                                    "Referência sobre espaços de Sobolev"
                                  ],
                                  "tips": "Sempre inclua o domínio Ω e ∂Ω na formulação para clareza.",
                                  "learningObjective": "Formular corretamente problemas elípticos com condições de Dirichlet.",
                                  "commonMistakes": [
                                    "Esquecer compatibilidade entre f e g",
                                    "Usar notação incorreta para laplaciano (Δ vs -Δ)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir unicidade via princípio da máxima",
                                  "subSteps": [
                                    "Recordar o princípio da máxima para funções harmônicas (Δu=0): máximo na fronteira.",
                                    "Estender para -Δu = f ≥ 0: solução não excede valores de g.",
                                    "Provar unicidade: suponha duas soluções u1, u2; v=u1-u2 satisfaz -Δv=0 com v=0 em ∂Ω, logo v=0.",
                                    "Analisar casos com f arbitrário usando super/subsoluções.",
                                    "Aplicar em exemplo: mostrar solução única no disco unitário."
                                  ],
                                  "verification": "Esboçar a prova de unicidade para um problema homogêneo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Teorema do Princípio da Máxima (notas ou livro)",
                                    "Exemplos resolvidos",
                                    "Quadro branco para prova"
                                  ],
                                  "tips": "Use homogeneização: reduza a problemas harmônicos para prova.",
                                  "learningObjective": "Explicar por que condições de Dirichlet garantem unicidade via princípio da máxima.",
                                  "commonMistakes": [
                                    "Aplicar máxima diretamente sem homogeneizar",
                                    "Confundir existência com unicidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema modelo: Encontre u tal que -Δu = 1 em Ω = (0,π)×(0,π), com u=0 em ∂Ω. Identifique a condição Dirichlet u=0 em toda a fronteira, formule e prove unicidade pelo princípio da máxima (solução u=(x(π-x)+y(π-y))/2).",
                              "finalVerifications": [
                                "Identificar corretamente a condição Dirichlet em 3 problemas modelo diferentes.",
                                "Formular um problema elíptico completo com Dirichlet a partir de descrição.",
                                "Esboçar prova de unicidade usando princípio da máxima.",
                                "Diferenciar Dirichlet de outros tipos em problemas mistos.",
                                "Explicar impacto da condição na solução única.",
                                "Resolver analiticamente um caso 1D simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da condição u=g em ∂Ω (obrigatório).",
                                "Correta formulação matemática do problema completo.",
                                "Compreensão clara do princípio da máxima e sua aplicação à unicidade.",
                                "Uso apropriado de notação e terminologia técnica.",
                                "Capacidade de exemplos concretos e contraexemplos.",
                                "Profundidade na discussão de regularidade e compatibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potencial eletrostático com cargas fixas na fronteira.",
                                "Engenharia Mecânica: Distribuição de temperaturas em placas com bordas aquecidas.",
                                "Computação Científica: Implementação em métodos de elementos finitos (FEM).",
                                "Física Computacional: Simulações de difusão com condições prescritas."
                              ],
                              "realWorldApplication": "Em engenharia, condições de Dirichlet modelam isolamento térmico onde a temperatura é fixa na borda (ex: forno com paredes a temperatura controlada), garantindo simulações precisas de fluxo de calor para design de materiais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Analisar impacto nas propriedades da solução",
                            "description": "Discutir como as condições de Dirichlet garantem existência e unicidade da solução em espaços de Sobolev apropriados para equações elípticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Equações Elípticas e Condições de Dirichlet",
                                  "subSteps": [
                                    "Defina equações elípticas lineares do segundo ordem, como -Δu = f em Ω com u = g na ∂Ω.",
                                    "Explique o papel das condições de Dirichlet homogêneas (g=0) na formulação variacional.",
                                    "Discuta a importância da fronteira suave (C¹) para garantir propriedades da solução.",
                                    "Revise o espaço H¹(Ω) como base para soluções fracas.",
                                    "Identifique diferenças entre condições de Dirichlet e Neumann."
                                  ],
                                  "verification": "Resuma em um parágrafo como as condições de Dirichlet afetam a formulação do problema elíptico.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro de Análise Numérica (Evans ou Brezis)",
                                    "Notas de aula sobre PDEs",
                                    "Software MATLAB para visualização de domínios"
                                  ],
                                  "tips": "Comece com exemplos simples como o problema de Laplace para fixar conceitos.",
                                  "learningObjective": "Compreender a formulação clássica e variacional de problemas elípticos com Dirichlet.",
                                  "commonMistakes": [
                                    "Confundir Dirichlet com Neumann",
                                    "Ignorar a necessidade de fronteira Lipschitz para H¹"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Espaços de Sobolev e Suas Propriedades",
                                  "subSteps": [
                                    "Defina o espaço Sobolev H¹(Ω) = W^{1,2}(Ω) com norma ||u||_{H¹} = (∫|u|² + |∇u|²)^{1/2}.",
                                    "Discuta o traço de u ∈ H¹(Ω) para ∂Ω, garantindo u|∂Ω = 0 em H¹₀(Ω).",
                                    "Prove propriedades de compacidade da injeção H¹₀(Ω) → L²(Ω) (Rellich-Kondrachov).",
                                    "Analise coercividade da forma bilinear a(u,v) = ∫∇u·∇v para operadores elípticos uniformes.",
                                    "Verifique continuidade da forma bilinear e coercividade por constantes de Poincaré-Friedrichs."
                                  ],
                                  "verification": "Calcule a norma H¹ para uma função teste em um domínio unitário e verifique traço zero.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Referência: Adams 'Sobolev Spaces'",
                                    "Fichas de exercícios de Sobolev",
                                    "Python com FEniCS para computar normas"
                                  ],
                                  "tips": "Use desigualdade de Poincaré para estimar coercividade em H¹₀.",
                                  "learningObjective": "Dominar espaços funcionais onde soluções fracas residem e suas propriedades chave.",
                                  "commonMistakes": [
                                    "Esquecer subespaço H¹₀ para Dirichlet homogêneo",
                                    "Confundir norma H¹ com L²"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Teorema de Lax-Milgram para Existência e Unicidade",
                                  "subSteps": [
                                    "Enuncie o teorema de Lax-Milgram: forma bilinear contínua e coerciva implica isomorfismo.",
                                    "Verifique coercividade: α||u||_{H¹}² ≤ a(u,u) para α > 0.",
                                    "Mostre continuidade: |a(u,v)| ≤ M||u||_{H¹}||v||_{H¹}.",
                                    "Defina funcional linear L(v) = ∫f v, contínuo em H¹₀.",
                                    "Conclua existência/unicidade da solução u ∈ H¹₀(Ω) para -Δu = f."
                                  ],
                                  "verification": "Escreva a prova completa do teorema para o Laplaciano com citação de constantes.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Livro de PDEs (Gilbarg-Trudinger)",
                                    "Exercícios resolvidos de Lax-Milgram",
                                    "Lápis e papel para provas"
                                  ],
                                  "tips": "Lembre que elipticidade uniforme garante α independente do domínio.",
                                  "learningObjective": "Provar existência e unicidade via método variacional em espaços apropriados.",
                                  "commonMistakes": [
                                    "Não verificar coercividade em todo H¹₀",
                                    "Ignorar f ∈ H^{-1} ou L²"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto nas Propriedades da Solução",
                                  "subSteps": [
                                    "Discuta regularidade: u ∈ H¹₀ implica ∇u ∈ L², mas ellipticidade dá u ∈ H² sob hipóteses.",
                                    "Analise estabilidade: ||u||_{H¹} ≤ (1/α)||L||_{H^{-1}}.",
                                    "Explore unicidade via identidade de energia: a(u,u) = L(u) > 0 para u ≠ 0.",
                                    "Compare com condições sem Dirichlet: perda de unicidade sem controle na fronteira.",
                                    "Avalie impacto em métodos numéricos: convergência em elementos finitos depende de H¹."
                                  ],
                                  "verification": "Derive estimativa de estabilidade para um exemplo específico e discuta implicações.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Artigos sobre regularidade elíptica",
                                    "Software FreeFEM para simulações",
                                    "Gráficos de soluções"
                                  ],
                                  "tips": "Use bootstrap para melhorar regularidade de H¹ para H².",
                                  "learningObjective": "Avaliar como Dirichlet afeta regularidade, estabilidade e unicidade da solução.",
                                  "commonMistakes": [
                                    "Atribuir regularidade H² sem hipóteses de f ou ∂Ω",
                                    "Subestimar papel de H¹₀"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere -Δu = 1 em Ω = (0,1)² com u=0 na ∂Ω. A solução u(x,y) = (1-x²)/2 * (1-y²)/2 existe unicamente em H¹₀(Ω) por Lax-Milgram, com ||u||_{H¹} ≤ C||1||_{L²}. Numéricamente, discretize com FEM e verifique convergência O(h).",
                              "finalVerifications": [
                                "Explique verbalmente o teorema de Lax-Milgram para um colega.",
                                "Prove unicidade para o Laplaciano com Dirichlet.",
                                "Calcule norma H¹ de uma solução teste.",
                                "Identifique falha de unicidade sem Dirichlet.",
                                "Simule numericamente e compare com teoria.",
                                "Discuta limitações para domínios não-convexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação de Lax-Milgram (20%)",
                                "Correta verificação de coercividade/continuidade (25%)",
                                "Análise profunda de impacto em propriedades (25%)",
                                "Uso correto de espaços Sobolev (15%)",
                                "Exemplo prático com cálculos (10%)",
                                "Clareza e estrutura da discussão (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Equações de Poisson em eletrostática com condições de potencial fixo.",
                                "Engenharia: Análise de tensões em placas elípticas com bordas fixas.",
                                "Computação: Bases para métodos de elementos finitos em solvers PDE.",
                                "Análise de Dados: Regularização em problemas inversos elípticos."
                              ],
                              "realWorldApplication": "Em modelagem de fluxo de calor estacionário (equação de Laplace) com temperaturas fixas nas bordas de um condutor, as condições de Dirichlet garantem solução única e estável, essencial para simulações em engenharia térmica e software como COMSOL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Discretização por Diferenças Finitas de Equações Elípticas",
                        "description": "Desenvolvimento do esquema de diferenças finitas para aproximar equações elípticas em uma malha uniforme, focando no operador Laplaciano e na formação do sistema linear.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Derivar o stencil de diferenças finitas centradas",
                            "description": "Obter a aproximação de segunda ordem para Δu ≈ (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² em malha quadrada uniforme.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Expansão de Taylor em Uma Dimensão",
                                  "subSteps": [
                                    "Lembre a expansão de Taylor para uma função f(x) ao redor de x_i: f(x_i + h) = f(x_i) + h f'(x_i) + (h²/2) f''(x_i) + (h³/6) f'''(ξ1) + O(h⁴).",
                                    "Escreva a expansão para f(x_i - h): f(x_i - h) = f(x_i) - h f'(x_i) + (h²/2) f''(x_i) - (h³/6) f'''(ξ2) + O(h⁴).",
                                    "Some as expansões para eliminar o termo de primeira derivada.",
                                    "Divida por h² para isolar a segunda derivada.",
                                    "Identifique o erro de truncamento de ordem O(h²)."
                                  ],
                                  "verification": "Confirme que [f(x_i + h) + f(x_i - h) - 2 f(x_i)] / h² ≈ f''(x_i) com erro O(h²).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Livro de Análise Numérica (opcional)"
                                  ],
                                  "tips": "Use notação subscrita (i,j) desde o início para preparar para 2D.",
                                  "learningObjective": "Entender como diferenças centradas aproximam segundas derivadas em 1D com precisão de segunda ordem.",
                                  "commonMistakes": "Esquecer o fator 1/2 na expansão de Taylor ou confundir sinais nos termos ímpares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Expansões de Taylor em Duas Dimensões para Direção x",
                                  "subSteps": [
                                    "Considere u(x_i, y_j) em malha uniforme com passo h.",
                                    "Escreva Taylor para u_{i+1,j} = u + h u_x + (h²/2) u_xx + (h³/6) u_xxx + O(h⁴).",
                                    "Escreva para u_{i-1,j} = u - h u_x + (h²/2) u_xx - (h³/6) u_xxx + O(h⁴).",
                                    "Some: u_{i+1,j} + u_{i-1,j} = 2u + h² u_xx + O(h⁴).",
                                    "Isolar: [u_{i+1,j} + u_{i-1,j} - 2 u_{i,j}] / h² ≈ ∂²u/∂x²."
                                  ],
                                  "verification": "Verifique que os termos lineares em h se cancelam e o coeficiente de h² é correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Mantenha todas as derivadas parciais explícitas (u_x, u_xx, etc.).",
                                  "learningObjective": "Derivar a diferença finita centrada para a segunda derivada parcial em x.",
                                  "commonMistakes": "Confundir índices i+1 com j ou esquecer O(h⁴) nos termos pares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Aproximação para Direção y",
                                  "subSteps": [
                                    "Repita o processo para u_{i,j+1} = u + h u_y + (h²/2) u_yy + (h³/6) u_yyy + O(h⁴).",
                                    "u_{i,j-1} = u - h u_y + (h²/2) u_yy - (h³/6) u_yyy + O(h⁴).",
                                    "Some e isole: [u_{i,j+1} + u_{i,j-1} - 2 u_{i,j}] / h² ≈ ∂²u/∂y².",
                                    "Confirme simetria com a direção x.",
                                    "Note que erros são O(h²) independentemente."
                                  ],
                                  "verification": "Escreva a fórmula exata para ∂²u/∂y² e compare com x.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis"
                                  ],
                                  "tips": "Copie a estrutura da direção x para eficiência, alterando apenas y.",
                                  "learningObjective": "Obter stencil centrado para segunda derivada em y em malha 2D.",
                                  "commonMistakes": "Misturar derivadas mistas u_xy nos termos de ordem superior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar para o Laplaciano e Verificar Ordem",
                                  "subSteps": [
                                    "Defina Δu = ∂²u/∂x² + ∂²u/∂y².",
                                    "Some as aproximações: Δu ≈ [u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4 u_{i,j}] / h².",
                                    "Analise erro total: cada segunda derivada tem O(h²), soma mantém O(h²).",
                                    "Verifique consistência para equações elípticas como -Δu = f.",
                                    "Esboce o stencil em uma malha 3x3."
                                  ],
                                  "verification": "Confirme que o coeficiente central é -4/h² e vizinhos +1/h².",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para stencil",
                                    "Calculadora"
                                  ],
                                  "tips": "Desenhe a malha para visualizar os pontos (i±1,j) e (i,j±1).",
                                  "learningObjective": "Derivar o stencil completo de 5 pontos para Δu com precisão de segunda ordem.",
                                  "commonMistakes": "Esquecer o -4 ou dividir incorretamente por h²."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Função Teste e Condições de Dirichlet",
                                  "subSteps": [
                                    "Escolha u(x,y) = x² + y², onde Δu = 4 exatamente.",
                                    "Aplique stencil em ponto interno e compute aproximação.",
                                    "Verifique convergência ao refinar h.",
                                    "Considere fronteiras Dirichlet: u conhecida em bordas.",
                                    "Discuta truncamento em malha quadrada uniforme."
                                  ],
                                  "verification": "Para h pequeno, aproximação deve ser próxima de 4.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB (opcional)"
                                  ],
                                  "tips": "Use função harmônica conhecida para teste rápido.",
                                  "learningObjective": "Aplicar e validar o stencil derivado numericamente.",
                                  "commonMistakes": "Ignorar condições de contorno ou erro de arredondamento."
                                }
                              ],
                              "practicalExample": "Para resolver -Δu = 0 em um quadrado unitário com u=0 nas bordas exceto u=sin(πx) na borda superior, aplique o stencil em pontos internos: em (i,j), (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² = 0, incorporando valores de Dirichlet nas fronteiras.",
                              "finalVerifications": [
                                "O stencil tem coeficientes +1/h² nos quatro vizinhos e -4/h² no centro.",
                                "Expansões de Taylor confirmam cancelamento de termos de 1ª ordem e erro O(h²).",
                                "Teste com u=x²+y² dá Δu≈4 exatamente em malha fina.",
                                "Stencil é simétrico e consistente com propriedades elípticas.",
                                "Visualização em malha 3x3 mostra cruz de 5 pontos.",
                                "Derivação funciona para malha quadrada uniforme h constante."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (sinais e coeficientes corretos).",
                                "Correta combinação para Δu com -4u central.",
                                "Identificação de ordem de precisão O(h²).",
                                "Validação numérica com exemplo converge.",
                                "Explicação clara de aplicação em condições Dirichlet.",
                                "Ausência de erros comuns como diferenças forward/backward."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos eletrostáticos e difusão de calor (equação de Poisson).",
                                "Programação: Implementação em Python/NumPy para solvers iterativos (Gauss-Seidel).",
                                "Engenharia: Simulações CFD para escoamentos incompressíveis.",
                                "Estatística: Aproximações em processos espaciais gaussianos."
                              ],
                              "realWorldApplication": "Usado em simulações numéricas para prever distribuição de temperatura em placas (condução térmica), potencial elétrico em capacitores irregulares e modelagem de fluxo de groundwater em aquíferos, resolvendo grandes sistemas lineares via métodos iterativos em softwares como COMSOL ou FEniCS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Montar o sistema linear para o interior da malha",
                            "description": "Construir a matriz pentadiagonal ou tridiagonal por blocos para o sistema Au = b decorrente da discretização de -Δu = f no domínio interior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a malha retangular e identificar pontos interiores",
                                  "subSteps": [
                                    "Escolha uma malha uniforme retangular com passos h em x e k em y, preferencialmente h=k para simplificação.",
                                    "Defina os nós da malha: x_i = i h, i=0..N; y_j = j k, j=0..M.",
                                    "Identifique pontos interiores: 1 ≤ i ≤ N-1, 1 ≤ j ≤ M-1 (excluindo fronteiras Dirichlet).",
                                    "Numere os pontos interiores sequencialmente, ex: p = (i-1)(M-1) + (j-1).",
                                    "Anote o número total de incógnitas: (N-1)(M-1)."
                                  ],
                                  "verification": "Lista numerada de pontos interiores com índices i,j e p correspondente está correta e completa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (GeoGebra/Mathematica)",
                                    "Folha de rascunho",
                                    "Referência de diferenças finitas"
                                  ],
                                  "tips": "Comece com malha pequena (N=M=4) para visualizar; use ordenação linha a linha para pentadiagonal.",
                                  "learningObjective": "Estabelecer a estrutura topológica da malha interior e numeração para montagem matricial.",
                                  "commonMistakes": [
                                    "Incluir nós de fronteira como incógnitas.",
                                    "Erros na numeração sequencial levando a índices errados.",
                                    "Assumir h ≠ k sem ajustar coeficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação discreta usando diferenças finitas de segunda ordem",
                                  "subSteps": [
                                    "Aproxime ∂²u/∂x² ≈ (u_{i+1,j} - 2u_{i,j} + u_{i-1,j}) / h².",
                                    "Aproxime ∂²u/∂y² ≈ (u_{i,j+1} - 2u_{i,j} + u_{i,j-1}) / k².",
                                    "Some as aproximações para -Δu_{i,j} ≈ f_{i,j}: (u_{i+1,j} + u_{i-1,j})/h² + (u_{i,j+1} + u_{i,j-1})/k² - 2(u_{i,j}(1/h² + 1/k²)) = f_{i,j}.",
                                    "Multiplique por h²k² para limpar denominadores (caso h=k, simplifica).",
                                    "Escreva na forma matricial local: coeficientes para u_{i,j}, vizinhos e termo f."
                                  ],
                                  "verification": "Equação discreta balanceada e coeficientes corretos para stencil de 5 pontos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (SymPy/Mathematica)",
                                    "Tabela de diferenças finitas",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Assuma h=k=1 inicialmente para testar; verifique simetria do stencil.",
                                  "learningObjective": "Dominar a discretização central de segunda ordem para o Laplaciano 2D.",
                                  "commonMistakes": [
                                    "Usar diferenças forward/backward em vez de central.",
                                    "Esquecer o sinal negativo em -Δu.",
                                    "Erros aritméticos nos coeficientes de vizinhos (-1/h²)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir as linhas da matriz A e vetor b para cada ponto interior",
                                  "subSteps": [
                                    "Para cada p correspondente a (i,j), crie linha p da matriz A com zeros iniciais.",
                                    "Posicione coeficiente diagonal A_{p,p} = 2(1/h² + 1/k²).",
                                    "Adicione off-diagonais: A_{p, p_esquerda} = -1/h², A_{p, p_direita} = -1/h², A_{p, p_baixo} = -1/k², A_{p, p_cima} = -1/k² (usando numeração p).",
                                    "Calcule b_p = h² k² f_{i,j} (ajustado pela multiplicação clearing).",
                                    "Verifique que para malha quadrada, A é simétrica e pentadiagonal.",
                                    "verification: ",
                                    "estimatedTime: "
                                  ],
                                  "40 minutos": [
                                    "Matriz A parcial com 5 entradas não-nulas por linha e b consistente."
                                  ],
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy para protótipo)",
                                    "Papel para matriz esparsa"
                                  ],
                                  "tips": "Use estrutura block-tridiagonal para malhas grandes: blocos de (M-1)x(M-1).",
                                  "learningObjective": "Montar sistema Au=b local-global mapeando stencil para índices lineares.",
                                  "commonMistakes": [
                                    "Índices errados para vizinhos (ex: p_direita = p+1 só na mesma linha).",
                                    "Diagonal errada (deve ser 4/h² se h=k).",
                                    "b_p sem multiplicador h²k²."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a estrutura pentadiagonal ou tridiagonal por blocos e validar",
                                  "subSteps": [
                                    "Agrupe linhas por j fixo para forma block-tridiagonal: subdiagonal BI, diagonal B, superdiagonal BS.",
                                    "Para pentadiagonal completa, liste diagonais: principal (4/h²), ±1 (-1/h²), ±(M-1) (-1/h²).",
                                    "Implemente verificação de simetria: A = A^T.",
                                    "Teste com f=0: solução u=0 satisfaz.",
                                    "Documente A e b para malha teste."
                                  ],
                                  "verification": "Matriz A montada é pentadiagonal simétrica positiva definida; Au=b holds para u conhecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB para montar e plotar esparsidade (spy(A))",
                                    "Exemplo analítico"
                                  ],
                                  "tips": "Use csr_matrix em SciPy para eficiência; valide com norma ||Au - b|| < 1e-10.",
                                  "learningObjective": "Reconhecer e construir estruturas esparsas eficientes para solvers iterativos.",
                                  "commonMistakes": [
                                    "Ignorar wrap-around na numeração.",
                                    "Não escalar b corretamente.",
                                    "Perder simetria por erros de indexação."
                                  ]
                                }
                              ],
                              "practicalExample": "Para malha 3x3 interior (N=M=3, h=k=1), 4 pontos: p=1(1,1),2(1,2),3(2,1),4(2,2). Stencil dá A = [[4,-1,-1,0],[-1,4,0,-1],[-1,0,4,-1],[0,-1,-1,4]], b=[f11,f12,f21,f22]. Para f=1 constante, b=[1,1,1,1].",
                              "finalVerifications": [
                                "Matriz A tem exatamente 5 diagonais não-nulas com coeficientes corretos (-1/h² off, 4/h² diag se h=k).",
                                "Vetor b incorpora f_{i,j} multiplicado por h²k².",
                                "Numeração produz banda estreita (largura 2(M-1)+1).",
                                "A é simétrica e definida positiva (autovalores >0).",
                                "Para subdomínio 2x2, montagem manual coincide com fórmula block.",
                                "Sistema consistente com condições Dirichlet zero (u_borda=0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do stencil (ordem O(h²)).",
                                "Correção na indexação e coeficientes de A (sem vazamentos de fronteira).",
                                "Eficiência na estrutura esparsa (pentadiagonal/block-tridiag identificada).",
                                "Validação numérica (||Au-b|| pequeno para teste).",
                                "Clareza na documentação de passos e notação.",
                                "Generalização para h≠k."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementar montador em NumPy/SciPy para EDOS elípticas.",
                                "Física Computacional: Aplicar a equação de Poisson em eletrostática (∇²φ=-ρ/ε).",
                                "Engenharia Mecânica: Simulação de calor (∇²T=-Q/k) em placas.",
                                "Ciência de Dados: Pré-processamento para solvers iterativos (GMRES, CG)."
                              ],
                              "realWorldApplication": "Montagem essencial em CFD para simular campos de pressão/velocidade em escoamentos incompressíveis, análise térmica em engenharia aeroespacial, modelagem geofísica de reservatórios subterrâneos e processamento de imagens médicas (reconstrução tomográfica)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Verificar consistência e ordem de precisão",
                            "description": "Demonstrar a consistência do esquema via expansão de Taylor e calcular a ordem de truncamento O(h²) para o erro local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema de diferenças finitas para equações elípticas com condições de Dirichlet",
                                  "subSteps": [
                                    "Identifique a equação elíptica modelo, como -Δu = f em um domínio Ω com u = g na fronteira ∂Ω.",
                                    "Descreva a discretização em grade uniforme com passo h, focando no estêncil de 5 pontos para o laplaciano em 2D.",
                                    "Escreva a equação discreta no ponto interior (i,j): (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² ≈ f_{i,j}.",
                                    "Confirme as condições de Dirichlet aplicadas nos pontos de fronteira.",
                                    "Verifique se o esquema é consistente com a definição: limite h→0 da solução discreta tende à solução contínua."
                                  ],
                                  "verification": "Escreva o esquema discreto corretamente e explique verbalmente sua relação com a EDP original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Grade de exemplo impressa"
                                  ],
                                  "tips": "Comece com o caso 1D para intuição antes de 2D; desenhe a grade para visualizar vizinhos.",
                                  "learningObjective": "Compreender a estrutura do esquema numérico e sua aproximação à EDP elíptica.",
                                  "commonMistakes": [
                                    "Confundir laplaciano com derivadas de primeira ordem",
                                    "Esquecer fator 1/h² no esquema",
                                    "Ignorar condições de fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar expansão de Taylor multivariável aos operadores diferenciais",
                                  "subSteps": [
                                    "Expanda u(x+h,y) = u + h u_x + (h²/2) u_xx + (h³/6) u_xxx + O(h⁴), e similares para outras direções.",
                                    "Some as expansões para u_{i+1,j} + u_{i-1,j}: 2u + h² u_xx + (2 h⁴ / 24) u_xxxx + O(h⁶).",
                                    "Faça o mesmo para direções y: obtenha h² u_yy + O(h⁴).",
                                    "Combine para o laplaciano discreto: [h² (u_xx + u_yy) + O(h⁴)] / h² = Δu + O(h²).",
                                    "Substitua na equação discreta para obter L_h u_h = f_h + O(h²)."
                                  ],
                                  "verification": "Derive as expansões até O(h⁴) e mostre que elas cancelam termos pares adequadamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como Mathematica/MATLAB",
                                    "Folha com fórmulas de Taylor multivariáveis"
                                  ],
                                  "tips": "Use notação compacta com somatórios; verifique coeficientes dividindo por fatoriais corretos.",
                                  "learningObjective": "Dominar a expansão de Taylor para demonstrar que o esquema aproxima os operadores diferenciais.",
                                  "commonMistakes": [
                                    "Parar em ordens baixas demais (ex: só O(h))",
                                    "Erro nos sinais de expansões pares/ímpares",
                                    "Confundir derivadas parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o erro de truncamento local e demonstrar consistência",
                                  "subSteps": [
                                    "Subtraia a EDP original da discreta: L_h u - P_h L u = τ_h, onde τ_h é o erro de truncamento local.",
                                    "Mostre que |τ_h| ≤ C h² para u suficientemente suave (C constante).",
                                    "Demonstre consistência: lim_{h→0} sup |τ_h| = 0.",
                                    "Para o exemplo de Poisson, confirme que o erro vem dos termos O(h⁴)/h² = O(h²).",
                                    "Discuta suavidade necessária: u ∈ C⁴(Ω) para erro O(h²)."
                                  ],
                                  "verification": "Escreva a expressão exata de τ_h e prove que é O(h²) com limite zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software para plotar erros vs h (ex: Python com NumPy)",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Teste numericamente reduzindo h e plotando log-log para confirmar ordem 2.",
                                  "learningObjective": "Quantificar o erro local e estabelecer consistência do esquema.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Esquecer hipóteses de suavidade",
                                    "Erro na identificação de τ_h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a ordem de precisão O(h²) empiricamente e teoricamente",
                                  "subSteps": [
                                    "Teoricamente: confirme que termos líderes do erro são h² Δ²u / 12 ou similar.",
                                    "Implemente um exemplo numérico: resolva -Δu = π² sin(πx) sin(πy) em [0,1]² com u=0 na fronteira.",
                                    "Calcule erro em norma L∞ ou L2 para h=1/10, 1/20, etc., e verifique declínio como h².",
                                    "Compare com solução exata u = sin(πx) sin(πy).",
                                    "Conclua que ordem é 2 se log(erros) vs log(h) tem inclinação -2."
                                  ],
                                  "verification": "Produza tabela ou gráfico mostrando ordem 2 numericamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB/Python/Mathematica para resolver sistema linear",
                                    "Solução exata conhecida"
                                  ],
                                  "tips": "Use solvers iterativos como Gauss-Seidel para malhas finas; vetorize código.",
                                  "learningObjective": "Validar teoricamente e numericamente a ordem de precisão do esquema.",
                                  "commonMistakes": [
                                    "Erro de programação na montagem da matriz",
                                    "Norma errada para medir ordem",
                                    "Malha não refinada o suficiente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de Poisson -Δu = 2π² sin(πx) sin(πy) em Ω=[0,1]² com u=0 na fronteira, solução exata u=sin(πx) sin(πy). Discretize com h=1/20, aplique expansões de Taylor ao estêncil central, derive τ_h ≈ (h²/12)(u_xxxx + 2u_xxyy + u_yyyy), e confirme ||u - u_h||_∞ ~ 10^{-4}, declinando como h² ao refinar.",
                              "finalVerifications": [
                                "Expansões de Taylor corretas até O(h⁴) para todas direções.",
                                "Erro de truncamento τ_h explicitamente O(h²).",
                                "Limite h→0 de τ_h = 0 demonstrado.",
                                "Exemplo numérico com tabela de erros mostrando ordem 2.",
                                "Condições de suavidade u ∈ C⁴ explicitadas.",
                                "Esquema escrito corretamente com fator 1/h²."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expansões de Taylor (coeficientes corretos).",
                                "Identificação correta do erro local O(h²).",
                                "Demonstração analítica de consistência.",
                                "Validação numérica com pelo menos 3 valores de h.",
                                "Explicação clara de limitações (suavidade).",
                                "Ausência de erros algébricos em derivações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos eletromagnéticos ou temperaturas via EDPs elípticas.",
                                "Computação: Implementação de solvers lineares esparsos (ex: método das diferenças finitas em CFD).",
                                "Engenharia: Análise de estruturas com equações de equilíbrio elíptico.",
                                "Estatística: Aproximação numérica em processos gaussianos espaciais."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor estacionário em engenharia térmica, verificar consistência garante que malhas grossas produzem erros controlados O(h²), permitindo trade-off eficiente entre precisão e custo computacional em softwares como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Implementação Numérica das Condições de Dirichlet",
                        "description": "Ajuste dos valores nas malhas fronteiriças para incorporar condições de Dirichlet no esquema de diferenças finitas, modificando o sistema linear adequadamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Ajustar valores nas fronteiras da malha",
                            "description": "Substituir os valores u nas células fronteiriças pelos valores prescritos g, eliminando equações correspondentes e ajustando o vetor b para vizinhos internos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar nós fronteiriços na malha",
                                  "subSteps": [
                                    "Defina a malha computacional (ex: grid 2D NxN pontos).",
                                    "Localize índices dos nós na fronteira (i=0, i=N-1, j=0, j=N-1).",
                                    "Crie uma máscara ou array booleano indicando nós fronteiriços vs. internos.",
                                    "Registre coordenadas (x,y) de cada nó fronteiriço para mapear valores g."
                                  ],
                                  "verification": "Liste impressa dos índices fronteiriços corresponde às bordas da malha sem duplicatas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código em Python/MATLAB com NumPy/Meshgrid",
                                    "Papel e lápis para malha pequena"
                                  ],
                                  "tips": "Use loops ou indexação vetorial para eficiência em malhas grandes.",
                                  "learningObjective": "Compreender topologia da malha e distinção entre nós internos e fronteiriços.",
                                  "commonMistakes": "Incluir cantos duas vezes ou confundir nós internos próximos à fronteira."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Atribuir valores prescritos g aos nós fronteiriços",
                                  "subSteps": [
                                    "Defina função g(x,y) baseada no problema (ex: g=sin(pi*x) para Dirichlet homogêneo não).",
                                    "Para cada nó fronteiriço (i,j), compute u[i,j] = g(x[i],y[j]).",
                                    "Armazene valores g em vetor ou matriz separada para referência futura.",
                                    "Atualize vetor solução inicial u com esses valores fixos."
                                  ],
                                  "verification": "Valores u na fronteira igualam g avaliada nas coordenadas corretas (teste numérico).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função g implementada",
                                    "Malha gerada do Step 1"
                                  ],
                                  "tips": "Vetorize computação de g para performance em malhas densas.",
                                  "learningObjective": "Aplicar condições de contorno Dirichlet diretamente na discretização.",
                                  "commonMistakes": "Avaliar g em coordenadas erradas ou esquecer normalização da malha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Eliminar equações das fronteiras e ajustar vetor b",
                                  "subSteps": [
                                    "Construa matriz A e vetor b para todos os nós inicialmente.",
                                    "Para cada equação fronteiriça (linha k de nó fronteiriço), remova-a do sistema.",
                                    "Para equações de nós internos adjacentes, adicione contribuições de g à linha correspondente em b: b[k] += soma(A[k,m]*g[m]) para m fronteiriço.",
                                    "Reorganize sistema para apenas variáveis internas (nova A_reduzida, b_reduzido)."
                                  ],
                                  "verification": "Dimensões de A_reduzida e b_reduzido iguais ao número de nós internos; b ajustado reflete g corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Matriz A esparsa/densa do método de diferenças finitas",
                                    "Valores g do Step 2"
                                  ],
                                  "tips": "Use CSR para matrizes esparsas em problemas grandes; debug com malha 3x3.",
                                  "learningObjective": "Modificar sistema linear para incorporar condições de Dirichlet via eliminação.",
                                  "commonMistakes": "Não zerar linhas de fronteira ou errar sinal no ajuste de b."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar implementação e integrar ao solver",
                                  "subSteps": [
                                    "Resolva sistema reduzido (ex: com scipy.sparse.linalg).",
                                    "Preencha u completo com u_interno + u_fronteira.",
                                    "Verifique se u_fronteira permanece = g após solução.",
                                    "Teste com problema conhecido (ex: Laplace com g=0, solução analítica=0)."
                                  ],
                                  "verification": "Erro L2 entre solução numérica e analítica < 1e-6; u_fronteira == g.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Solver linear (scipy, MATLAB backslash)",
                                    "Problema teste com solução conhecida"
                                  ],
                                  "tips": "Sempre teste com malha grosseira antes de refinar.",
                                  "learningObjective": "Garantir consistência da implementação no fluxo completo de resolução.",
                                  "commonMistakes": "Sobrescrever u_fronteira durante preenchimento ou solver instável."
                                }
                              ],
                              "practicalExample": "Em malha 2D 5x5 para equação de Laplace ∇²u=0 com g(x,y)=x*y nas bordas. Após ajuste, resolver Ax=b reduzido para 9 internos resulta em u_fronteira fixo e u_interno aproximando solução analítica.",
                              "finalVerifications": [
                                "u nos nós fronteiriços exatamente igual a g.",
                                "Sistema linear tem tamanho correto (N_total - N_fronteira).",
                                "Vetor b para internos inclui contribuições corretas de g vizinhos.",
                                "Solução converge para caso teste conhecido (erro < tol).",
                                "Gradiente normal na fronteira consistente com g.",
                                "Execução eficiente sem warnings de solver.",
                                "Visualização (heatmap) mostra u=g nas bordas."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro na fronteira < 1e-10.",
                                "Eficiência: Tempo de setup < 10% do solver total.",
                                "Robustez: Funciona para malhas 1D/2D irregulares.",
                                "Compreensão: Explicar ajuste de b matematicamente.",
                                "Código limpo: Comentado, modular, vetorializado.",
                                "Escalabilidade: Testado em malha 100x100 sem crash.",
                                "Documentação: README com exemplo reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de arrays esparsos (NumPy/SciPy).",
                                "Física: Modelagem de campos potenciais (eletrostática, difusão).",
                                "Engenharia: Simulações CFD com BC Dirichlet (pressão fixa).",
                                "Matemática: Álgebra linear (sistemas lineares, eliminação gaussiana).",
                                "Ciência de Dados: Pré-processamento de grids para ML em PDEs."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor com temperatura fixa nas paredes (engenharia térmica), ou potencial elétrico em eletrodos fixos (engenharia elétrica), ajustando fronteiras garante precisão sem equações extras, essencial para otimização em software como COMSOL ou OpenFOAM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Modificar o sistema linear para condições de Dirichlet",
                            "description": "Remover linhas e colunas da matriz A associadas a pontos fronteiriços e atualizar o lado direito b com contribuições das fronteiras vizinhas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar pontos fronteiriços e internos na grade",
                                  "subSteps": [
                                    "Defina a grade discreta (malha) para o domínio, incluindo pontos internos e fronteiriços.",
                                    "Marque todos os pontos na fronteira onde as condições de Dirichlet são aplicadas.",
                                    "Liste os índices dos pontos internos que permanecerão no sistema linear.",
                                    "Crie uma lista ou mapa dos vizinhos fronteiriços para cada ponto interno.",
                                    "Valide que todos os pontos fronteiriços têm valores de condição de Dirichlet conhecidos."
                                  ],
                                  "verification": "Verifique se a lista de pontos internos exclui corretamente todos os fronteiriços e se os vizinhos estão mapeados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Grade discreta (array 2D ou meshgrid em Python/MATLAB)",
                                    "Valores de fronteira g(x,y)"
                                  ],
                                  "tips": "Use índices lineares para facilitar a remoção (ex: i*N + j).",
                                  "learningObjective": "Compreender a distinção entre pontos internos e fronteiriços em métodos de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir pontos de canto como internos",
                                    "Esquecer pontos na borda superior/inferior"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e preparar a matriz A e vetor b originais",
                                  "subSteps": [
                                    "Monte a matriz A completa para todos os pontos da grade usando stencil de diferenças finitas (ex: Laplace: 4 na diagonal, -1 nos vizinhos).",
                                    "Inicialize o vetor b com zeros ou fontes conhecidas para todos os pontos.",
                                    "Numere os pontos da grade em ordem linear para indexação.",
                                    "Teste a montagem verificando simetria e propriedades esperadas de A.",
                                    "Salve cópias originais de A e b para comparação."
                                  ],
                                  "verification": "Confirme que A é esparsa e simétrica positiva definida para o operador elíptico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca de álgebra linear (NumPy/SciPy ou MATLAB)",
                                    "Stencil finito definido"
                                  ],
                                  "tips": "Use formato CSR para matrizes esparsas se a grade for grande.",
                                  "learningObjective": "Montar o sistema linear discreto antes da imposição de condições de fronteira.",
                                  "commonMistakes": [
                                    "Erro no stencil: coeficientes errados para vizinhos diagonais",
                                    "Indexação fora dos limites"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Remover linhas e colunas da matriz A para pontos fronteiriços",
                                  "subSteps": [
                                    "Identifique os índices globais dos pontos fronteiriços.",
                                    "Crie uma lista de índices a remover (fronteiriços).",
                                    "Extraia submatriz A_reduzida removendo linhas e colunas correspondentes aos fronteiriços.",
                                    "Mantenha apenas linhas/colunas dos pontos internos.",
                                    "Verifique dimensionalidade: novo tamanho = número de pontos internos."
                                  ],
                                  "verification": "Dimensões de A_reduzida == (n_internos, n_internos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções de slicing/submatrizes em álgebra linear",
                                    "Lista de índices internos"
                                  ],
                                  "tips": "Use máscaras booleanas para seleção eficiente.",
                                  "learningObjective": "Eliminar variáveis desconhecidas do sistema linear via remoção de equações e colunas.",
                                  "commonMistakes": [
                                    "Remover índices duplicados ou errados",
                                    "Não remover tanto linhas quanto colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar o vetor b com contribuições das fronteiras vizinhas",
                                  "subSteps": [
                                    "Para cada ponto interno, some as contribuições dos vizinhos fronteiriços no stencil.",
                                    "Use a fórmula: b_i += soma (coeficiente_stencil * g_fronteira para vizinho fronteiriço).",
                                    "Extraia apenas os valores de b correspondentes aos pontos internos.",
                                    "Inclua fontes f se presentes.",
                                    "Valide numericamente com um exemplo pequeno."
                                  ],
                                  "verification": "Compare b atualizado com cálculo manual para pontos internos adjacentes à fronteira.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Valores g da fronteira",
                                    "Stencil coeficientes"
                                  ],
                                  "tips": "Implemente um loop sobre vizinhos para cada interno adjacente.",
                                  "learningObjective": "Incorporar condições de Dirichlet no lado direito do sistema reduzido.",
                                  "commonMistakes": [
                                    "Fator errado nos coeficientes (ex: esquecer dividir por h^2)",
                                    "Incluir contribuições de internos em b"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e testar o sistema linear modificado",
                                  "subSteps": [
                                    "Resolva o sistema A_reduzida * x_internos = b_reduzido.",
                                    "Reconstrua a solução completa inserindo valores de fronteira.",
                                    "Verifique resíduos ou convergência para problema conhecido.",
                                    "Compare com solução analítica se disponível.",
                                    "Documente o processo para reutilização."
                                  ],
                                  "verification": "Resíduo ||A x - b|| < 1e-10 para o sistema completo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Solucionador linear (LU, CG)",
                                    "Solução de referência"
                                  ],
                                  "tips": "Use solvers iterativos para grandes sistemas.",
                                  "learningObjective": "Garantir correção da modificação via testes numéricos.",
                                  "commonMistakes": [
                                    "Esquecer de inserir fronteiras na solução final",
                                    "Erro de escala em h"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace ∇²u=0 em [0,1]x[0,1] com u=0 nas bordas exceto u=1 na borda superior. Grade 4x4: remova 12 pontos fronteiriços, A_reduzida 4x4, b com contribuições da borda superior nos pontos internos adjacentes.",
                              "finalVerifications": [
                                "Matriz A_reduzida tem dimensões corretas (n_internos x n_internos).",
                                "Vetor b_reduzido incorpora todas as contribuições fronteiriças.",
                                "Sistema resolvido satisfaz condições de Dirichlet nos pontos fronteiriços.",
                                "Resíduo do sistema completo é pequeno (<1e-8).",
                                "Solução é simétrica e suave no domínio.",
                                "Tempo de montagem é O(N) para grade NxN."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro relativo <1% vs. solução exata.",
                                "Eficiência: remoção e atualização em O(N).",
                                "Corretude: verificação de stencil em pontos fronteiriços.",
                                "Robustez: funciona para grades não-uniformes ou geometrias simples.",
                                "Clareza: código comentado e modular.",
                                "Escalabilidade: teste com grades crescentes."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos em eletromagnetismo e mecânica dos fluidos.",
                                "Programação: Manipulação de matrizes esparsas (SciPy sparse).",
                                "Engenharia: Simulações CFD e FEA com BCs Dirichlet.",
                                "Estatística: Soluções de EDOs em processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em placas com temperaturas fixas nas bordas (engenharia térmica), ou potencial elétrico em capacitores com eletrodos fixos (engenharia elétrica), onde condições de Dirichlet representam valores conhecidos nas fronteiras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Implementar em código computacional",
                            "description": "Escrever pseudocódigo ou código em Python/MATLAB para gerar a malha, aplicar Dirichlet e resolver o sistema via métodos iterativos como Gauss-Seidel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura do código e escrever pseudocódigo",
                                  "subSteps": [
                                    "Defina o problema: equação de Poisson -Δu = f em domínio retangular com condições de Dirichlet u= g nas bordas.",
                                    "Esboce a discretização: malha uniforme NxN pontos, diferenças finitas de 5 pontos.",
                                    "Descreva o algoritmo Gauss-Seidel: inicialize u=0, itere até ||u_new - u_old|| < tol.",
                                    "Inclua geração de malha, aplicação de BCs, iterações e critério de parada.",
                                    "Planeje visualização com plot de u final."
                                  ],
                                  "verification": "Pseudocódigo cobre todos os componentes principais sem lacunas lógicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto (VS Code ou Jupyter Notebook), papel para esboços.",
                                  "tips": "Use fluxograma para visualizar o loop iterativo antes de codificar.",
                                  "learningObjective": "Entender a sequência lógica da implementação numérica antes da codificação.",
                                  "commonMistakes": "Ignorar o tratamento de índices nas bordas ou não definir tolerância de convergência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração da malha e inicialização",
                                  "subSteps": [
                                    "Importe bibliotecas: numpy para arrays, matplotlib para plots.",
                                    "Crie malha 2D: defina h = 1/(N-1), x = linspace(0,1,N), y = x.copy(), X,Y = meshgrid(x,y).",
                                    "Inicialize u como array zeros(N,N).",
                                    "Defina f (fonte) e g (Dirichlet) como funções vetorializadas.",
                                    "Teste malha imprimindo shape de u e X."
                                  ],
                                  "verification": "Malha gerada corretamente: shape(u) == (N,N), h calculado certo, u inicial zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python 3+, NumPy, Matplotlib instalados (pip install numpy matplotlib).",
                                  "tips": "Use np.meshgrid(indexing='ij') para índices matriciais consistentes.",
                                  "learningObjective": "Dominar criação de grids uniformes para métodos de diferenças finitas.",
                                  "commonMistakes": "Confundir meshgrid com indexing='xy' levando a transposições erradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar condições de Dirichlet nas bordas",
                                  "subSteps": [
                                    "Crie função apply_dirichlet(u, g, X, Y): copie u.",
                                    "Aplique nas bordas: u[0,:] = g_left(Y[0,:]), u[-1,:] = g_right(Y[-1,:]), etc. para todas 4 bordas.",
                                    "Garanta que cantos sejam tratados corretamente (média ou valor específico).",
                                    "Teste isoladamente: aplique BCs em u zero e verifique bordas.",
                                    "Integre no loop principal."
                                  ],
                                  "verification": "Após aplicação, u nas bordas i==0 or i==N-1 or j==0 or j==N-1 equals g correspondente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código do Step 2.",
                                  "tips": "Use broadcasting numpy para eficiência em vetores de borda.",
                                  "learningObjective": "Implementar corretamente condições de contorno Dirichlet em malhas 2D.",
                                  "commonMistakes": "Sobrescrever interior ao aplicar BCs ou erros em índices off-by-one."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método iterativo Gauss-Seidel e resolver",
                                  "subSteps": [
                                    "Defina função gauss_seidel(u, f, h, tol=1e-6, max_iter=10000):",
                                    "Loop while: compute residuo = np.max(np.abs(u_new - u_old)), atualize stencil interior: u[i,j] = (u[i+1,j]+u[i-1,j]+u[i,j+1]+u[i,j-1] + h^2 f)/4.",
                                    "Aplique dirichlet após cada iteração.",
                                    "Pare se residuo < tol ou max_iter atingido.",
                                    "Retorne u e numero de iterações."
                                  ],
                                  "verification": "Código converge (iter < max_iter), residuo < tol, plot de u mostra solução suave.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código dos steps anteriores, Jupyter para testes interativos.",
                                  "tips": "Use np.roll para stencil eficiente ou loops explícitos para clareza inicial.",
                                  "learningObjective": "Codificar corretamente o esquema iterativo Gauss-Seidel para EDP elípticas.",
                                  "commonMistakes": "Atualizar stencil sem relaxação ou esquecer aplicar BCs por iteração."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, visualizar e validar a solução",
                                  "subSteps": [
                                    "Execute solver com N=50, f= -2*pi^2 sin(pi x) sin(pi y), g=0 (solução exata sin(pi x) sin(pi y)).",
                                    "Plote contourf(u), surface ou pcolor(X,Y,u).",
                                    "Compute erro L2: np.sqrt(np.mean((u - u_exact)**2)).",
                                    "Varie N e tol, observe convergência.",
                                    "Salve código como script .py com comentários."
                                  ],
                                  "verification": "Erro L2 < 1e-3 para N=100, plots mostram solução física esperada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código completo, solução analítica conhecida para validação.",
                                  "tips": "Use plt.contourf(X,Y,u, levels=20) + plt.colorbar() para visual bom.",
                                  "learningObjective": "Validar implementação numérica contra soluções exatas e analisar precisão.",
                                  "commonMistakes": "Não normalizar erro ou ignorar divergência por tol muito rígida."
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 2π² sin(πx) sin(πy) em [0,1]x[0,1] com u=0 nas bordas. Solução exata: u=sin(πx) sin(πy). Use N=41, tol=1e-5. Código Python gera malha, aplica u=0 bordas, itera Gauss-Seidel até convergência, plota contour e erro L∞ ~0.01.",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime para N=100.",
                                "Método converge em <5000 iterações com residuo <1e-6.",
                                "Condições de Dirichlet são exatamente satisfeitas nas bordas.",
                                "Visualização mostra solução suave sem oscilações artificiais.",
                                "Erro contra solução exata diminui com refinamento de malha (ordem 2).",
                                "Tempo de execução razoável (<10s para N=100 em laptop padrão)."
                              ],
                              "assessmentCriteria": [
                                "Correção do stencil de diferenças finitas (5 pontos simétrico).",
                                "Implementação precisa do Gauss-Seidel com atualização sequencial.",
                                "Aplicação consistente de Dirichlet após cada iteração.",
                                "Critério de parada robusto (residuo + max_iter).",
                                "Validação quantitativa com norma de erro e testes de convergência.",
                                "Código limpo, comentado e modular (funções separadas)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loops, vetoriação NumPy, funções modulares.",
                                "Física: Modelagem de campos escalares (temperatura, potencial eletrostático).",
                                "Engenharia Computacional: Bases para CFD e simulações FEM.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em placas com bordas fixas (engenharia térmica), potencial gravitacional em 2D (geofísica), ou fluxo incompressível em canais (hidrodinâmica computacional)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.4",
                            "name": "Avaliar estabilidade e convergência",
                            "description": "Analisar a propriedade de máxima do esquema e discutir convergência O(h²) para condições de Dirichlet homogêneas e não-homogêneas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema numérico e a propriedade de máxima",
                                  "subSteps": [
                                    "Estude o esquema de diferenças finitas para equações elípticas com condições de Dirichlet.",
                                    "Defina a propriedade de máxima: solução numérica ≤ máximo da solução exata nas fronteiras.",
                                    "Derive a propriedade de máxima para o operador Laplace discreto.",
                                    "Verifique condições necessárias para que a propriedade segure (ex: coeficientes positivos).",
                                    "Compare com a propriedade de máxima contínua para o problema elíptico."
                                  ],
                                  "verification": "Escreva uma prova curta da propriedade de máxima e teste em um stencil 5-pontos simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e lápis ou Jupyter Notebook para stencil.",
                                  "tips": "Comece com o caso 1D para intuitionar antes de 2D.",
                                  "learningObjective": "Compreender como a propriedade de máxima garante estabilidade no esquema discreto.",
                                  "commonMistakes": "Confundir propriedade de máxima com princípio do máximo; ignorar sinais nos coeficientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar estabilidade para condições de Dirichlet homogêneas",
                                  "subSteps": [
                                    "Implemente o esquema para u=0 na fronteira.",
                                    "Use a propriedade de máxima para provar ||u_h||_∞ ≤ ||u||_∞.",
                                    "Analise o erro de aproximação local O(h²).",
                                    "Discuta estabilidade via norma L∞ e relação com consistência.",
                                    "Simule numericamente em malha grosseira para observar."
                                  ],
                                  "verification": "Prove que o esquema é estável em L∞ e compute norma do erro em uma malha.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python/MATLAB com solvers de Laplace, grids h=0.1 e h=0.05.",
                                  "tips": "Use matrizes esparsas para eficiência em 2D.",
                                  "learningObjective": "Demonstrar estabilidade via propriedade de máxima em casos homogêneos.",
                                  "commonMistakes": "Esquecer truncagem local na análise de estabilidade; usar normas erradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender análise para condições de Dirichlet não-homogêneas",
                                  "subSteps": [
                                    "Modifique o esquema incorporando g(x) na fronteira via interpolação.",
                                    "Adapte a propriedade de máxima para incluir ||u_h - u||_∞ ≤ C h² + max|g_interp - g|.",
                                    "Discuta impacto da aproximação da fronteira na estabilidade.",
                                    "Prove estabilidade ajustada: ||u_h||_∞ ≤ max|g| + C||f||.",
                                    "Teste numericamente com g sinusoidal."
                                  ],
                                  "verification": "Derive desigualdade de estabilidade e valide com simulação onde erro fronteira é controlado.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código do step anterior + funções de interpolação linear/quadrática.",
                                  "tips": "Use extrapolação de ordem 2 para minimizar erro de fronteira.",
                                  "learningObjective": "Analisar como condições não-homogêneas afetam estabilidade e precisão.",
                                  "commonMistakes": "Ignorar erro de interpolação na fronteira; assumir homogeneidade implicitamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir e verificar convergência de ordem O(h²)",
                                  "subSteps": [
                                    "Recapitule erro global: consistência O(h²) + estabilidade ⇒ convergência O(h²).",
                                    "Refine malhas (h, h/2, h/4) e compute taxas de convergência log-log.",
                                    "Analise assintótica para h→0 em normas L² e L∞.",
                                    "Discuta limitações (ex: malhas não-uniformes).",
                                    "Compare resultados numéricos com teoria."
                                  ],
                                  "verification": "Gere tabela de erros e taxas; confirme ordem 2 numericamente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Scripts de refinamento adaptativo, solução exata conhecida (ex: u=sin(πx)sin(πy)).",
                                  "tips": "Use richardson extrapolation para estimar ordem exata.",
                                  "learningObjective": "Conectar estabilidade à convergência de segunda ordem.",
                                  "commonMistakes": "Contaminação por erros de fronteira; malhas insuficientemente refinadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise e explorar variações",
                                  "subSteps": [
                                    "Resuma provas de estabilidade e convergência em um relatório.",
                                    "Teste em problema não-simétrico ou com f irregular.",
                                    "Discuta generalizações (ex: operadores elípticos gerais).",
                                    "Identifique cenários onde ordem cai abaixo de 2.",
                                    "Planeje extensão a condições mistas."
                                  ],
                                  "verification": "Escreva resumo de 1 página com teoremas chave e plots de convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Todos códigos anteriores + LaTeX para relatório.",
                                  "tips": "Foco em casos patológicos para robustez.",
                                  "learningObjective": "Integrar conceitos em uma visão coesa de análise numérica.",
                                  "commonMistakes": "Generalizar excessivamente sem contra-exemplos."
                                }
                              ],
                              "practicalExample": "Resolva numericamente -Δu = 2π² sin(πx) sin(πy) em [0,1]² com u=sin(πx)sin(πy) na fronteira (homogênea após lift). Refine h de 1/10 a 1/100, plote erros L∞ e confirme O(h²). Para não-homogênea, use u=x(1-x)y(1-y) com g correspondente.",
                              "finalVerifications": [
                                "Prova escrita da propriedade de máxima para stencil padrão.",
                                "Tabela de erros com taxas de convergência ≈2 em pelo menos 3 refinamentos.",
                                "Plot log-log de erro vs h confirmando inclinação -2.",
                                "Análise qualitativa de impacto de interpolação fronteira.",
                                "Simulação estável sem oscilações para h pequeno.",
                                "Resumo conectando estabilidade a convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da propriedade de máxima (correta e completa).",
                                "Correta adaptação para condições não-homogêneas.",
                                "Taxas numéricas de convergência dentro de 10% de 2.",
                                "Identificação de erros comuns em aproximações fronteira.",
                                "Clareza em discussões teóricas e numéricas.",
                                "Uso apropriado de normas e análise assintótica."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação eficiente de solvers iterativos (ex: Gauss-Seidel).",
                                "Física: Modelagem de campos térmicos/eletrônicos com condições Dirichlet.",
                                "Estatística: Análise de erros em métodos Monte Carlo para PDEs.",
                                "Engenharia: Simulações FEM para estruturas elípticas."
                              ],
                              "realWorldApplication": "Em engenharia civil, avaliar convergência O(h²) garante precisão em simulações de tensão em placas (problemas elípticos); em finanças, estabilidade assegura robustez em modelos de precificação de opções via PDEs elípticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Condições de Neumann em Equações Elípticas",
                    "description": "Definição e interpretação das condições de Neumann, que especificam derivadas normais da solução na fronteira.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Definição Matemática das Condições de Neumann",
                        "description": "Apresentação formal da condição de Neumann para equações elípticas, especificando a derivada normal da solução na fronteira do domínio.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Identificar a forma da condição de Neumann",
                            "description": "Reconhecer e escrever a condição de Neumann ∂u/∂n = g na fronteira ∂Ω para o problema -Δu = f em Ω, diferenciando-a da condição de Dirichlet u = g.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema elíptico básico de Poisson",
                                  "subSteps": [
                                    "Lembre-se da equação modelo -Δu = f em um domínio Ω ⊂ ℝ² ou ℝ³.",
                                    "Identifique Ω como o domínio interior e ∂Ω como sua fronteira.",
                                    "Entenda que Δu é o laplaciano de u, e f é uma função fonte conhecida.",
                                    "Visualize exemplos simples de Ω, como o disco unitário ou o quadrado.",
                                    "Escreva a equação em notação simbólica em um papel."
                                  ],
                                  "verification": "Explique oralmente ou por escrito o significado de cada termo do problema.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Anotações de aula sobre equações elípticas",
                                    "Livro de Análise Numérica (capítulo de EDP elípticas)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Comece com Ω simples para fixar a intuição geométrica.",
                                  "learningObjective": "Compreender o problema -Δu = f em Ω como base para condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir Δu com ∇u",
                                    "Esquecer que f é dada no interior de Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a condição de contorno de Dirichlet",
                                  "subSteps": [
                                    "Defina a condição de Dirichlet: u = g na fronteira ∂Ω, onde g é dada.",
                                    "Escreva explicitamente: para todo x ∈ ∂Ω, u(x) = g(x).",
                                    "Diferencie de condições no interior: aplica-se apenas na fronteira.",
                                    "Exemplo: u = 0 em ∂Ω (homogênea).",
                                    "Pratique escrevendo para Ω = disco unitário."
                                  ],
                                  "verification": "Escreva a condição de Dirichlet para um domínio dado e verifique se especifica o valor de u.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha com diagramas de domínios",
                                    "Software de desenho vetorial opcional (GeoGebra)"
                                  ],
                                  "tips": "Pense em Dirichlet como 'valor prescrito da solução na borda'.",
                                  "learningObjective": "Reconhecer a condição de Dirichlet como imposição direta do valor de u em ∂Ω.",
                                  "commonMistakes": [
                                    "Confundir g com f",
                                    "Aplicar a condição no interior de Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a derivada normal e a condição de Neumann",
                                  "subSteps": [
                                    "Defina a derivada direcional normal: ∂u/∂n = ∇u · n, onde n é o vetor normal unitário exterior a ∂Ω.",
                                    "Escreva a condição de Neumann: ∂u/∂n = g em ∂Ω, com g conhecida.",
                                    "Integre ao problema completo: -Δu = f em Ω, ∂u/∂n = g em ∂Ω.",
                                    "Visualize n como perpendicular à fronteira, apontando para fora.",
                                    "Calcule ∂u/∂n para u(x,y) = x em ∂Ω do quadrado unitário."
                                  ],
                                  "verification": "Compute ∂u/∂n para uma função simples e confirme a forma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cálculo vetorial (notas sobre gradiente e produto escalar)",
                                    "Gráficos de vetores normais em ∂Ω"
                                  ],
                                  "tips": "Desenhe n em um esboço da fronteira para fixar a direção.",
                                  "learningObjective": "Identificar ∂u/∂n = g como a forma matemática da condição de Neumann.",
                                  "commonMistakes": [
                                    "Usar normal interior em vez de exterior",
                                    "Confundir ∂u/∂n com ∂u/∂x"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e praticar identificação das condições",
                                  "subSteps": [
                                    "Compare: Dirichlet fixa u, Neumann fixa o fluxo normal (∇u · n).",
                                    "Identifique em problemas: se u = g → Dirichlet; se ∂u/∂n = g → Neumann.",
                                    "Escreva 3 exemplos mistos e classifique cada condição de contorno.",
                                    "Discuta compatibilidade: ∫_Ω f = ∫_∂Ω g para Neumann (caso homogêneo f=0).",
                                    "Resolva um exercício: dado -Δu=0 em Ω, qual condição é ∂u/∂n=1?"
                                  ],
                                  "verification": "Classifique corretamente 5 condições dadas em problemas elípticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de 5 exercícios de identificação",
                                    "Solução modelo"
                                  ],
                                  "tips": "Lembre: Neumann é sobre 'derivada', Dirichlet sobre 'valor'.",
                                  "learningObjective": "Diferenciar precisamente Dirichlet de Neumann pela forma matemática.",
                                  "commonMistakes": [
                                    "Trocar as notações u=g e ∂u/∂n=g",
                                    "Ignorar o domínio ∂Ω"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema -Δu = 0 no disco unitário Ω = {x² + y² < 1}, com condição ∂u/∂n = 1 na fronteira ∂Ω (círculo unitário). Aqui, n = (x,y)/||(x,y)||, e a condição especifica fluxo constante unitário para fora.",
                              "finalVerifications": [
                                "Escreva corretamente ∂u/∂n = g em ∂Ω como condição de Neumann.",
                                "Distinga de u = g, identificando Dirichlet.",
                                "Explique o papel do vetor normal n.",
                                "Classifique condições em 3 problemas elípticos dados.",
                                "Verifique se menciona -Δu = f em Ω como contexto.",
                                "Descreva um exemplo prático com domínio específico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (∂u/∂n vs u).",
                                "Correta definição do vetor normal unitário exterior.",
                                "Capacidade de diferenciação clara entre Dirichlet e Neumann.",
                                "Uso correto do contexto do problema -Δu = f em Ω.",
                                "Exemplos concretos e sem erros comuns.",
                                "Explicação fluida e estruturada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Condição de Neumann modela fluxo de calor ou campo elétrico prescrito (Lei de Fourier/Neumann).",
                                "Engenharia: Simulações em elementos finitos para estruturas com cargas distribuídas na superfície.",
                                "Computação: Implementação em solvers numéricos (ex: FEniCS ou MATLAB PDE Toolbox).",
                                "Física Computacional: Problemas de otimização com restrições de fluxo."
                              ],
                              "realWorldApplication": "Na engenharia térmica, modela isolamento perfeito (Neumann homogênea ∂u/∂n=0) ou fluxo de calor conhecido na superfície de um motor, permitindo simular distribuição de temperatura sem medir valores absolutos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Escrever o problema de valor de contorno com Neumann",
                            "description": "Formular o problema elíptico completo com condições de Neumann homogêneas ou não-homogêneas, incluindo a equação de Poisson como exemplo padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a equação diferencial elíptica padrão: Equação de Poisson",
                                  "subSteps": [
                                    "Escreva a forma geral de uma equação elíptica de segunda ordem: a u_xx + 2b u_xy + c u_yy + termos menores = f.",
                                    "Especifique a equação de Poisson como exemplo: -Δu = f(x,y) em Ω, onde Δu = u_xx + u_yy.",
                                    "Identifique o domínio Ω (região aberta limitada) e explique que f é a fonte.",
                                    "Discuta brevemente a unicidade sob condições adequadas (até constante para Neumann puro).",
                                    "Verifique a ellipticidade: para Poisson, é estritamente elíptica."
                                  ],
                                  "verification": "Escreva corretamente a equação de Poisson em 2D para um domínio dado e identifique Δu.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas sobre PDEs"
                                  ],
                                  "tips": "Sempre inclua o sinal negativo em -Δu = f para convenção padrão em problemas físicos.",
                                  "learningObjective": "Compreender e formular a PDE elíptica base para problemas de valor de contorno.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na equação de Poisson.",
                                    "Confundir laplaciano com derivadas de primeira ordem.",
                                    "Não especificar o domínio Ω explicitamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o domínio geométrico Ω e sua fronteira ∂Ω",
                                  "subSteps": [
                                    "Escolha um domínio simples, como Ω = (0,1) × (0,1) ou um disco.",
                                    "Desenhe o domínio Ω e destaque a fronteira ∂Ω = ∂Ω_left ∪ ∂Ω_right ∪ etc.",
                                    "Defina o vetor normal unitário exterior n em cada parte da fronteira.",
                                    "Note que para condições de Neumann puras, o problema é definido até uma constante.",
                                    "Mencione a necessidade de condição de compatibilidade para existência de solução."
                                  ],
                                  "verification": "Desenhe Ω, rotule ∂Ω e indique n em pelo menos dois pontos da fronteira.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Régua para desenhar domínios regulares"
                                  ],
                                  "tips": "Use domínios regulares inicialmente para evitar complicações geométricas.",
                                  "learningObjective": "Definir precisamente o domínio e preparar para condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir normal exterior com interior.",
                                    "Esquecer que ∂Ω é fechada e orientada.",
                                    "Não considerar domínios não-convexos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular condições de Neumann homogêneas",
                                  "subSteps": [
                                    "Defina a derivada direcional: ∂u/∂n = ∇u · n, onde n é o normal unitário exterior.",
                                    "Escreva a condição homogênea: ∂u/∂n = 0 em toda ∂Ω.",
                                    "Interprete fisicamente: isolamento térmico ou campo normal nulo (ex: condutor perfeito).",
                                    "Escreva o problema parcial: -Δu = f em Ω, ∂u/∂n = 0 em ∂Ω.",
                                    "Mencione a não-unicidade: soluções diferem por constante."
                                  ],
                                  "verification": "Escreva o BVP com Neumann homogêneo para Ω = (0,π)×(0,π) e f=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel",
                                    "Calculadora para verificar gradientes simples"
                                  ],
                                  "tips": "Lembre-se: n aponta para fora de Ω; teste com u=constante (satisfaz).",
                                  "learningObjective": "Formular corretamente condições de Neumann homogêneas e seu significado.",
                                  "commonMistakes": [
                                    "Usar normal interior em vez de exterior.",
                                    "Escrever ∂u/∂n = ∇u · n com n mal definido.",
                                    "Ignorar a não-unicidade da solução."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para condições de Neumann não-homogêneas e compor o problema completo",
                                  "subSteps": [
                                    "Defina ∂u/∂n = g(x,y) em ∂Ω, onde g é dada e não nula.",
                                    "Estabeleça a condição de compatibilidade: ∫_Ω f dx = ∫_∂Ω g ds (teorema da divergência).",
                                    "Escreva o BVP completo: -Δu = f em Ω, ∂u/∂n = g em ∂Ω.",
                                    "Discuta normalização: fixe u em um ponto ou média zero para unicidade.",
                                    "Teste com exemplo: verifique compatibilidade para um caso simples."
                                  ],
                                  "verification": "Formule o BVP não-homogêneo para f=0, g=1 em ∂Ω_left, g=0 elsewhere, e cheque compatibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel",
                                    "Software como Mathematica para integrar (opcional)"
                                  ],
                                  "tips": "Sempre verifique compatibilidade antes de considerar o problema bem-posto.",
                                  "learningObjective": "Compor e validar o problema de valor de contorno completo com Neumann.",
                                  "commonMistakes": [
                                    "Esquecer a condição de compatibilidade.",
                                    "Não especificar normalização para unicidade.",
                                    "Confundir g com condição de Dirichlet."
                                  ]
                                }
                              ],
                              "practicalExample": "Para Ω = (0,1)×(0,1), f(x,y) = 2π² sin(πx) sin(πy), condições de Neumann: ∂u/∂n = 0 em todas as bordas (homogêneo). Problema: -Δu = 2π² sin(πx) sin(πy) em Ω, ∂u/∂n = 0 em ∂Ω. Solução: u = sin(πx) sin(πy) + C (verifique compatibilidade: ∫f=1, ∫g=0? Ajuste f adequadamente).",
                              "finalVerifications": [
                                "Pode formular corretamente -Δu = f em Ω com ∂u/∂n = 0 em ∂Ω?",
                                "Identifica e escreve ∂u/∂n = ∇u · n para uma fronteira reta?",
                                "Verifica a condição de compatibilidade para um caso não-homogêneo?",
                                "Explica a não-unicidade em Neumann puro?",
                                "Aplica a formulação a um domínio como quadrado unitário?",
                                "Distingue Neumann homogêneo de não-homogêneo?"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na escrita da PDE e condições de contorno (30%)",
                                "Definição precisa de Ω, ∂Ω e vetor n (20%)",
                                "Inclusão e verificação da compatibilidade para casos não-homogêneos (20%)",
                                "Clareza na notação e interpretação física (15%)",
                                "Tratamento da unicidade/normalização (10%)",
                                "Exemplo prático completo e verificável (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Potencial eletrostático com campo elétrico normal especificado na fronteira (Neumann = ε E_n).",
                                "Engenharia Mecânica: Distribuição de tensões em placas com tração normal prescrita.",
                                "Computação Científica: Implementação em métodos de elementos finitos (ex: FreeFEM, FEniCS).",
                                "Física Computacional: Simulações de fluxo incompressível com condições de não-penetração.",
                                "Matemática Aplicada: Teoria de operadores elípticos e espaços de Sobolev."
                              ],
                              "realWorldApplication": "Modelagem de condução de calor em uma placa metálica isolada termicamente nas bordas (Neumann homogêneo ∂T/∂n=0) ou com fluxo de calor conhecido (não-homogêneo), essencial em design de reatores nucleares, eletrônicos e isolamento térmico de edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Entender a derivada normal na fronteira",
                            "description": "Calcular a derivada normal ∂u/∂n = ∇u · n em coordenadas cartesianas e polares para domínios simples como retângulos e discos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de derivada normal e gradiente",
                                  "subSteps": [
                                    "Definir o gradiente de uma função escalar u: ∇u = (∂u/∂x, ∂u/∂y) em 2D.",
                                    "Explicar o vetor unitário normal n à fronteira de um domínio.",
                                    "Entender a derivada normal como o produto escalar ∂u/∂n = ∇u · n.",
                                    "Diferenciar derivada direcional de derivada normal.",
                                    "Visualizar geometricamente em um diagrama simples."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o significado de ∂u/∂n e desenhar um exemplo com vetor gradiente e normal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, lápis, calculadora, vídeo introdutório sobre gradientes (Khan Academy ou YouTube).",
                                  "tips": "Sempre normalize o vetor n para que ||n||=1 para evitar erros de escala.",
                                  "learningObjective": "Dominar a definição matemática e geométrica da derivada normal.",
                                  "commonMistakes": "Confundir gradiente com derivada parcial; esquecer de normalizar o vetor n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a derivada normal em coordenadas cartesianas para domínios retangulares",
                                  "subSteps": [
                                    "Identificar as fronteiras de um retângulo (ex: [0,a]x[0,b]) e seus vetores normais unitários (ex: n=(0,1) na borda superior).",
                                    "Calcular as derivadas parciais ∂u/∂x e ∂u/∂y em pontos da fronteira.",
                                    "Computar ∇u · n para cada segmento da fronteira.",
                                    "Verificar continuidade ou simetria em cantos.",
                                    "Resolver um exemplo numérico simples com u(x,y)=sin(x)cos(y)."
                                  ],
                                  "verification": "Calcular ∂u/∂n em todos os lados de um retângulo dado e comparar com solução analítica conhecida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software como Mathematica ou Python (SymPy) para verificação.",
                                  "tips": "Use coordenadas locais na fronteira para simplificar cálculos.",
                                  "learningObjective": "Aplicar a fórmula em coordenadas cartesianas com precisão.",
                                  "commonMistakes": "Erro no sinal do vetor normal (interno vs externo); calcular gradiente dentro do domínio em vez da fronteira."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a derivada normal em coordenadas polares para domínios circulares (discos)",
                                  "subSteps": [
                                    "Converter para coordenadas polares: ∇u = (∂u/∂r, (1/r)∂u/∂θ) em componentes (r,θ).",
                                    "Identificar o vetor normal radial n = (1,0) na fronteira r=R de um disco.",
                                    "Calcular ∂u/∂n = ∂u/∂r |_{r=R}, simplificando o produto escalar.",
                                    "Tratar o centro (r=0) se necessário, verificando regularidade.",
                                    "Exemplo: u(r,θ)=r^2 cos(2θ) em disco unitário."
                                  ],
                                  "verification": "Derivar ∂u/∂n na circunferência r=1 para uma função polinomial e plotar o resultado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora gráfica, Python/MATLAB para polares, tabela de gradiente em polares.",
                                  "tips": "Lembre-se que em polares, o gradiente tem fator 1/r no componente θ.",
                                  "learningObjective": "Dominar o cálculo em coordenadas curvilíneas para simetrias radiais.",
                                  "commonMistakes": "Esquecer o Jacobiano ou fator 1/r; confundir n radial com tangencial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e integrar cálculos em exemplos mistos",
                                  "subSteps": [
                                    "Resolver problemas híbridos: retângulo com cantos arredondados aproximando por disco.",
                                    "Comparar resultados cartesianos e polares para o mesmo domínio aproximado.",
                                    "Implementar numericamente usando diferenças finitas para verificar analítico.",
                                    "Discutir condições de Neumann: ∂u/∂n = g na fronteira.",
                                    "Autoavaliar com 3 exercícios variados."
                                  ],
                                  "verification": "Resolver um problema completo de condição de Neumann e verificar integral de compatibilidade ∫∂u/∂n ds = 0 para soluções homogêneas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Exercícios impressos, Jupyter Notebook com NumPy/SciPy.",
                                  "tips": "Sempre verifique unidades e consistência dimensional.",
                                  "learningObjective": "Integrar conhecimentos para problemas reais em equações elípticas.",
                                  "commonMistakes": "Ignorar condições de compatibilidade; erros de indexação em código numérico."
                                }
                              ],
                              "practicalExample": "Para o retângulo [0,π]x[0,π] com u(x,y)=sin(x)sin(y), calcule ∂u/∂n: na borda x=0, n=(-1,0), ∂u/∂n = -cos(0)sin(y)= -sin(y); na y=π, n=(0,1), ∂u/∂n=sin(x)cos(π)= -sin(x). Verifique em polares aproximando o retângulo por disco.",
                              "finalVerifications": [
                                "Calcular corretamente ∂u/∂n em 5 pontos distintos de fronteiras cartesianas e polares.",
                                "Explicar o papel da derivada normal em condições de Neumann homogêneas.",
                                "Derivar a fórmula em polares a partir de cartesianas.",
                                "Identificar e corrigir erros em um cálculo fornecido com falhas.",
                                "Plotar ∇u · n ao longo de uma fronteira e interpretar.",
                                "Verificar compatibilidade ∫_Γ ∂u/∂n ds = 0 para domínio fechado."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (90% correto).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Uso correto de coordenadas e normalizações.",
                                "Criatividade em exemplos práticos propostos.",
                                "Eficiência no tempo e clareza na apresentação.",
                                "Aplicação numérica coerente com analítica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Fluxo de calor/difusão (Lei de Fick, equação de Poisson).",
                                "Engenharia: Simulações em CFD (dinâmica de fluidos computacional).",
                                "Computação: Métodos de elementos finitos (FEM) para malhas curvilíneas.",
                                "Análise Numérica: Esquemas de diferenças finitas em fronteiras.",
                                "Geometria Diferencial: Extensão para variedades."
                              ],
                              "realWorldApplication": "Na modelagem de fluxo de calor em uma placa retangular ou disco (ex: dissipador de calor em eletrônicos), ∂u/∂n especifica o fluxo térmico através das bordas isoladas ou com convecção, essencial para simulações em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Interpretação Física e Propriedades",
                        "description": "Interpretação das condições de Neumann como fluxo normal nulo ou prescrito na fronteira, e discussão de existência e unicidade da solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Interpretar fisicamente a condição de Neumann",
                            "description": "Associar ∂u/∂n = 0 a isolação térmica (fluxo de calor nulo) ou ∂u/∂n = g a fluxo prescrito em problemas de difusão estacionária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a derivada normal ∂u/∂n em domínios",
                                  "subSteps": [
                                    "Defina a derivada direcional de uma função u em um ponto na direção do vetor normal n.",
                                    "Explique ∂u/∂n como o limite da diferença incremental ao longo da normal unitária.",
                                    "Visualize geometricamente em 1D (du/dx), 2D (gradiente · n) e 3D.",
                                    "Calcule ∂u/∂n para funções simples como u(x,y)=x^2 + y^2 em fronteiras.",
                                    "Diferencie de derivadas parciais comuns."
                                  ],
                                  "verification": "Resolva 3 exemplos numéricos de cálculo de ∂u/∂n e compare com gradiente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Software GeoGebra ou MATLAB para visualização",
                                    "Livro de Análise Vetorial"
                                  ],
                                  "tips": "Sempre normalize o vetor n para |n|=1 para evitar erros de escala.",
                                  "learningObjective": "Identificar e calcular corretamente a derivada normal em contextos geométricos.",
                                  "commonMistakes": [
                                    "Confundir com derivada tangencial",
                                    "Esquecer de normalizar n",
                                    "Aplicar em pontos internos ao domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Associar ∂u/∂n ao fluxo de calor pela Lei de Fourier",
                                  "subSteps": [
                                    "Estude a equação de difusão estacionária: -Δu = f, onde u é temperatura.",
                                    "Lembre a Lei de Fourier: fluxo q = -k ∇u, com k condutividade térmica.",
                                    "Mostre que o fluxo normal através da fronteira é q · n = -k ∂u/∂n.",
                                    "Discuta unidades: ∂u/∂n tem unidades de temperatura por comprimento, fluxo em W/m².",
                                    "Compare com outras interpretações físicas (pressão em fluidos)."
                                  ],
                                  "verification": "Derive a relação q · n = -k ∂u/∂n a partir da Lei de Fourier e verifique dimensionalmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Videoaula sobre Lei de Fourier",
                                    "Tabela de unidades físicas",
                                    "Simulador online de fluxo térmico"
                                  ],
                                  "tips": "Pense no sinal: gradiente aponta para diminuição de u, fluxo para aumento de calor.",
                                  "learningObjective": "Conectar matematicamente a derivada normal ao conceito físico de fluxo.",
                                  "commonMistakes": [
                                    "Ignorar o sinal negativo na Lei de Fourier",
                                    "Confundir temperatura com fluxo",
                                    "Aplicar lei errada (ex: Ohm em eletricidade sem analogia)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a condição homogênea ∂u/∂n = 0 como isolação térmica",
                                  "subSteps": [
                                    "Conclua que ∂u/∂n = 0 implica q · n = 0, ou seja, fluxo nulo.",
                                    "Descreva fisicamente: nenhuma troca de calor através da fronteira (isolante perfeito).",
                                    "Exemplo 1D: barra com extremidade isolada, u constante ali em regime estacionário.",
                                    "Visualize em 2D: contorno adiabático em uma placa.",
                                    "Discuta implicações: preserva 'calor total' no domínio."
                                  ],
                                  "verification": "Esboce diagrama de uma barra isolada e explique por que ∂u/∂x=0 na ponta.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Exemplos de problemas de calor estacionário"
                                  ],
                                  "tips": "Associe a 'parede isolante' cotidiana, como isopor em geladeiras.",
                                  "learningObjective": "Explicar ∂u/∂n=0 como ausência de fluxo térmico.",
                                  "commonMistakes": [
                                    "Pensar que u=constante na fronteira (isso é Dirichlet)",
                                    "Confundir com refletor em ondas",
                                    "Ignorar regime estacionário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a condição não-homogênea ∂u/∂n = g como fluxo prescrito",
                                  "subSteps": [
                                    "Defina ∂u/∂n = g como fluxo conhecido: q · n = -k g.",
                                    "Exemplo: g>0 significa entrada de calor (aquecedor), g<0 saída (resfriador).",
                                    "Resolva problema simples 1D: -u''=0, u'(0)=g, u(1)=0.",
                                    "Discuta existência de solução: compatibilidade ∫g ds = ∫f dV para elípticas.",
                                    "Compare com aplicações: radiador com fluxo controlado."
                                  ],
                                  "verification": "Formule e resolva um problema 1D com Neumann não-homogênea e interprete g.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora ou Python para resolver ODE",
                                    "Problemas resolvidos de equações elípticas"
                                  ],
                                  "tips": "Lembre: soluções Neumann são únicas até constante; fixe com condição extra.",
                                  "learningObjective": "Relacionar g a fontes/sumidouros de calor controlados.",
                                  "commonMistakes": [
                                    "Esquecer fator -k no fluxo",
                                    "Ignorar condição de compatibilidade",
                                    "Confundir com valor prescrito de u"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma placa retangular representando um painel solar estacionário, a borda inferior tem ∂u/∂n = 100 (fluxo de calor entrante devido a radiação), enquanto as laterais têm ∂u/∂n=0 (isoladas). Resolva -Δu=0 e interprete as temperaturas resultantes.",
                              "finalVerifications": [
                                "Explique em palavras próprias o significado físico de ∂u/∂n=0 e ∂u/∂n=g.",
                                "Calcule o fluxo total através de uma fronteira fechada e verifique conservação.",
                                "Diferencie corretamente de condições de Dirichlet em um exemplo misto.",
                                "Desenhe diagrama de vetores de fluxo para um domínio com Neumann.",
                                "Resolva um problema simples e identifique isolação vs. fluxo prescrito.",
                                "Discuta por que Neumann homogêneo preserva a integral média de u."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação fluxo-derivada normal (100%).",
                                "Correta interpretação física sem confusão com Dirichlet (90%).",
                                "Uso correto de exemplos concretos e diagramas (85%).",
                                "Identificação de erros comuns e compatibilidade (80%).",
                                "Aplicação em problemas mistos ou 2D (75%).",
                                "Clareza na explicação oral ou escrita (70%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e transferência de calor (Lei de Fourier).",
                                "Engenharia: Modelagem de isolamento em estruturas civis e mecânicas.",
                                "Computação: Implementação de BCs em solvers FEM como FEniCS.",
                                "Química: Difusão de espécies em membranas porosas."
                              ],
                              "realWorldApplication": "Projeto de isolantes térmicos em edifícios (∂u/∂n=0 nas paredes) ou radiadores automotivos (∂u/∂n=g controlado por ventoinha), otimizando eficiência energética em simulações numéricas de Análise Numérica II."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Analisar a condição de compatibilidade",
                            "description": "Verificar a condição de solvibilidade ∫_Ω f dΩ = ∫_∂Ω g ds para existência de solução em condições de Neumann puras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação do problema de valor de contorno de Neumann puro",
                                  "subSteps": [
                                    "Revise a equação elíptica padrão: -Δu = f em Ω, com ∂u/∂n = g em ∂Ω.",
                                    "Identifique que em Neumann puro, não há condição de Dirichlet, levando a soluções até uma constante.",
                                    "Explique o significado físico: ∂u/∂n representa fluxo normal na fronteira.",
                                    "Discuta a não unicidade da solução e a necessidade de condição de solvibilidade.",
                                    "Esboce um domínio Ω simples (ex: quadrado unitário) e rotule f e g."
                                  ],
                                  "verification": "Escreva a formulação completa do problema e explique verbalmente a não unicidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Evans PDE), caderno para anotações, software de desenho (ex: GeoGebra).",
                                  "tips": "Visualize Ω como um recipiente isolado termicamente com fluxo especificado nas paredes.",
                                  "learningObjective": "Formular precisamente o problema de Neumann puro e reconhecer sua indefinição inerente.",
                                  "commonMistakes": "Confundir com Dirichlet (valor fixo em fronteira) ou ignorar a adição de constante nas soluções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a condição de compatibilidade usando identidades de Green",
                                  "subSteps": [
                                    "Aplique a primeira identidade de Green: ∫_Ω ∇u · ∇v dΩ = ∫_∂Ω (∂u/∂n) v ds - ∫_Ω u Δv dΩ para v=1.",
                                    "Escolha v=1 (constante), simplificando: ∫_Ω -Δu dΩ = ∫_∂Ω ∂u/∂n ds.",
                                    "Substitua -Δu = f e ∂u/∂n = g, obtendo ∫_Ω f dΩ = ∫_∂Ω g ds.",
                                    "Prove que essa condição é necessária para existência de solução fraca.",
                                    "Verifique que é também suficiente sob hipóteses de regularidade (ex: Ω Lipschitz)."
                                  ],
                                  "verification": "Derive a igualdade passo a passo em papel e confira com referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel quadriculado, calculadora simbólica (ex: Mathematica ou papel), notas de aula sobre Green.",
                                  "tips": "Sempre teste com v=1 primeiro, pois revela conservação global (balanço de massa/fluxo).",
                                  "learningObjective": "Derivar rigorosamente a condição de solvibilidade a partir de princípios variacionais.",
                                  "commonMistakes": "Esquecer o sinal negativo em -Δu ou inverter os lados da identidade de Green."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar numericamente a condição para um exemplo concreto",
                                  "subSteps": [
                                    "Escolha Ω = disco unitário, f(x,y)=1, g(θ)=1 (constante em ∂Ω).",
                                    "Calcule ∫_Ω f dΩ = área(Ω) = π.",
                                    "Calcule ∫_∂Ω g ds = ∫_0^{2π} 1 * 1 dθ = 2π (comprimento da circunferência).",
                                    "Compare: π ≠ 2π, logo incompatível; ajuste g=1/2 para compatibilidade.",
                                    "Implemente em código simples para automação (ex: Python com numpy para integração numérica)."
                                  ],
                                  "verification": "Execute cálculos exatos e numéricos, confirmando igualdade ou discrepância com tolerância 1e-6.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/Jupyter com numpy/scipy, ou MATLAB; tabela de integrais padrão.",
                                  "tips": "Use simetria do domínio para integrais analíticas exatas antes de numéricas.",
                                  "learningObjective": "Aplicar a condição em exemplos concretos, distinguindo casos solvíveis e não-solvíveis.",
                                  "commonMistakes": "Erro em medida da fronteira (ds vs dθ) ou confundir volume com área em 2D."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar implicações e interpretação física da condição",
                                  "subSteps": [
                                    "Interprete fisicamente: ∫f dΩ é fonte total, ∫g ds é fluxo total saindo; devem balancear.",
                                    "Discuta o que acontece se violada: sem solução, ou use Lagrange multipliers em métodos numéricos.",
                                    "Conecte a normalização da solução (subtrair média para unicidade).",
                                    "Resolva um problema compatível numericamente (ex: FEM com freefem++).",
                                    "Documente relatório resumindo análise para o exemplo."
                                  ],
                                  "verification": "Explique em parágrafo coerente a falha física se condição não hold, com equação de balanço.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software FEM (ex: FEniCS ou FreeFem), relatório template em LaTeX/Word.",
                                  "tips": "Pense em 'conservação de carga' ou 'balanço energético' para intuição física.",
                                  "learningObjective": "Interpretar a condição como lei de conservação e discutir regularizações numéricas.",
                                  "commonMistakes": "Ignorar que violação implica não existência, não apenas múltiplas soluções."
                                }
                              ],
                              "practicalExample": "Para Ω = [0,1]x[0,1], f(x,y)=2xy, g= x+y na fronteira ∂Ω. Calcule ∫_Ω 2xy dxdy = 1/4. Verifique ∫_∂Ω (x+y) ds nas 4 arestas: resulta em 1, compatível. Resolva -Δu=2xy com ∂u/∂n=g.",
                              "finalVerifications": [
                                "Enuncie corretamente a condição ∫_Ω f dΩ = ∫_∂Ω g ds.",
                                "Derive-a usando Green com v=1 sem erros.",
                                "Verifica numericamente para exemplo com precisão >99%.",
                                "Explica interpretação física de balanço de fluxo.",
                                "Identifica e corrige caso incompatível.",
                                "Discute impacto em solvers numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (integral correta, sinais).",
                                "Compreensão conceitual (explicação física coerente).",
                                "Habilidade computacional (cálculos exatos/numéricos precisos).",
                                "Profundidade de análise (implicações para existência/unicidade).",
                                "Clareza na comunicação (diagramas, relatório estruturado).",
                                "Criatividade em exemplos e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Lei de conservação em equações de difusão/ondas (ex: calor, elastostática).",
                                "Engenharia: Análise de estruturas com cargas distribuídas (fluxo de Neumann).",
                                "Computação: Implementação em métodos de elementos finitos (detecção de incompatibilidade).",
                                "Estatística: Condições de solvibilidade em equações integrais/Poisson."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em reatores nucleares, onde f é geração de calor volumétrica e g é fluxo térmico prescrito nas paredes; a condição garante balanço energético realista, evitando artefatos numéricos em códigos FEM industriais como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Discutir unicidade da solução",
                            "description": "Explicar que soluções são únicas até uma constante aditiva e como normalizar usando média zero ou valor em um ponto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema de Equações Elípticas com Condições de Neumann",
                                  "subSteps": [
                                    "Relembrar a formulação do problema: -Δu = f em Ω, ∂u/∂n = g na ∂Ω.",
                                    "Comparar com condições de Dirichlet, destacando a diferença na unicidade.",
                                    "Discutir o significado físico: Neumann especifica fluxo normal, não valor.",
                                    "Identificar que constantes aditivas preservam o fluxo.",
                                    "Esboçar um exemplo simples em 1D para intuição."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que Neumann permite ambiguidades de constante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Análise Numérica II, notas de aula, quadro branco.",
                                  "tips": "Use diagramas de domínio Ω e ∂Ω para visualizar condições de contorno.",
                                  "learningObjective": "Compreender a formulação e motivação física do problema de Neumann.",
                                  "commonMistakes": "Confundir Neumann (derivada normal) com Dirichlet (valor fixo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar a Não-Unicidade: Soluções Diferem por Constante Aditiva",
                                  "subSteps": [
                                    "Suponha u1 e u2 soluções; defina v = u1 - u2.",
                                    "Mostrar que v satisfaz -Δv = 0 e ∂v/∂n = 0 (problema homogêneo).",
                                    "Aplicar teorema de máxima ou identidade de Green para concluir Δv=0 implica v=constante.",
                                    "Verificar que constantes aditivas preservam condições de Neumann.",
                                    "Discutir kernel não-trivial do operador."
                                  ],
                                  "verification": "Derivar e escrever a prova completa em um caderno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, software simbólico como Mathematica ou SymPy para verificação.",
                                  "tips": "Comece com identidade de Green: ∫|∇v|^2 = ∫v ∂v/∂n = 0, implicando ∇v=0.",
                                  "learningObjective": "Demonstrar matematicamente que soluções são únicas até constante.",
                                  "commonMistakes": "Esquecer de usar a condição homogênea ∂v/∂n=0 na prova."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Condição de Compatibilidade para Existência",
                                  "subSteps": [
                                    "Integrar a equação -Δu = f sobre Ω: ∫f dΩ = ∫∂u/∂n d∂Ω = ∫g d∂Ω.",
                                    "Explicar necessidade de ∫_Ω f = ∫_∂Ω g para existência.",
                                    "Discutir que isso é necessário e suficiente (com não-unicidade).",
                                    "Verificar em exemplo numérico simples.",
                                    "Relacionar com conservação de massa/fluxo físico."
                                  ],
                                  "verification": "Calcular ∫f e ∫g para um exemplo e confirmar compatibilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou Python para integrais, exemplos de problemas.",
                                  "tips": "Use teorema da divergência para justificar rigorosamente.",
                                  "learningObjective": "Entender pré-condição para existência de soluções.",
                                  "commonMistakes": "Ignorar a condição de compatibilidade ao assumir existência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Métodos de Normalização para Unicidade",
                                  "subSteps": [
                                    "Introduzir normalização por média zero: impor ∫_Ω u dΩ = 0.",
                                    "Alternativa: fixar u(x0) = 0 em um ponto x0 ∈ Ω.",
                                    "Mostrar que isso seleciona uma solução única no espaço de soluções.",
                                    "Comparar prós e contras: média zero preserva simetria física.",
                                    "Implementar em um exemplo concreto."
                                  ],
                                  "verification": "Aplicar normalização a uma solução conhecida e verificar unicidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico como FEniCS ou MATLAB para simulação.",
                                  "tips": "Para média zero, subtraia a média da solução inicial.",
                                  "learningObjective": "Dominar técnicas para tornar o problema bem-posto.",
                                  "commonMistakes": "Normalizar na fronteira, violando Neumann."
                                }
                              ],
                              "practicalExample": "Considere o problema -u'' = 1 em [0,1] com u'(0)=0, u'(1)=0. Soluções: u(x) = (1/2)x^2 + C. Compatibilidade: ∫0^1 1 dx = 1 = u'(1)-u'(0)=0? Não! Corrija g para compatível. Normalizar: ∫u=0 implica C=-1/6, u(x)=(1/2)(x^2 - 1/3).",
                              "finalVerifications": [
                                "Explicar verbalmente por que soluções diferem por constante.",
                                "Derivar condição de compatibilidade ∫f = ∫g.",
                                "Aplicar normalização por média zero a um exemplo.",
                                "Verificar que solução normalizada satisfaz todas condições.",
                                "Discutir impacto físico da constante aditiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão na prova de não-unicidade (uso correto de Green).",
                                "Correta derivação da compatibilidade.",
                                "Clareza na explicação de normalizações.",
                                "Exemplo prático resolvido sem erros.",
                                "Conexão com interpretação física.",
                                "Profundidade nos subpassos de cada etapa."
                              ],
                              "crossCurricularConnections": [
                                "Física: Campos eletrostáticos com fluxo especificado (lei de Gauss).",
                                "Engenharia: Análise de tensões em placas com cargas distribuídas.",
                                "Computação: Condições de contorno em métodos de elementos finitos.",
                                "Estatística: Normalização em funções de densidade com integral fixa."
                              ],
                              "realWorldApplication": "Em modelagem de fluxo de calor com isolamento térmico (Neumann=0), a temperatura é determinada até constante; normaliza-se pela temperatura média conhecida, essencial em simulações climáticas ou design de reatores nucleares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Discretização Numérica com Diferenças Finitas",
                        "description": "Implementação das condições de Neumann usando métodos de diferenças finitas em malhas uniformes para equações elípticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Aproximar a derivada normal por diferenças finitas",
                            "description": "Derivar a aproximação de segunda ordem para ∂u/∂n na fronteira usando diferenças centradas ou forward/backward, como (u_{i+1,j} - u_{i-1,j})/(2h) para bordas laterais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a derivada normal e condições de Neumann em equações elípticas",
                                  "subSteps": [
                                    "Estudar a definição de condição de Neumann: ∂u/∂n = g na fronteira Γ.",
                                    "Identificar a direção normal n em uma grade cartesiana 2D (ex: ∂u/∂x para borda esquerda).",
                                    "Analisar por que diferenças finitas são usadas para discretizar ∂u/∂n.",
                                    "Diferenciar de condições de Dirichlet e discutir precisão de segunda ordem.",
                                    "Desenhar uma grade de exemplo com pontos de fronteira destacados."
                                  ],
                                  "verification": "Desenhar e rotular corretamente a grade com direção normal e explicar em 2-3 frases.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre equações elípticas",
                                    "Papel quadriculado ou software de desenho (GeoGebra)",
                                    "Livro de análise numérica (ex: LeVeque)"
                                  ],
                                  "tips": "Sempre visualize a grade: imagine u em pontos (i,j) e n apontando para fora.",
                                  "learningObjective": "Dominar o conceito de derivada normal e sua discretização em fronteiras.",
                                  "commonMistakes": "Confundir normal (perpendicular à fronteira) com tangencial (paralela)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar esquemas de diferenças finitas para derivadas (forward, backward e centradas)",
                                  "subSteps": [
                                    "Recordar fórmulas: forward ∂u/∂x ≈ (u_{i+1} - u_i)/h (1ª ordem), centrada (u_{i+1} - u_{i-1})/(2h) (2ª ordem).",
                                    "Derivar erro de truncamento para cada esquema usando expansão de Taylor.",
                                    "Identificar quando usar centrada (interior/bordas laterais) vs. forward/backward (esquinas).",
                                    "Calcular numericamente erro em uma função suave como u(x) = sin(πx).",
                                    "Comparar precisão em tabela para h=0.1 e h=0.05."
                                  ],
                                  "verification": "Derivar e comparar erros de truncamento por escrito ou em planilha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para testes numéricos",
                                    "Folha de derivadas de Taylor"
                                  ],
                                  "tips": "Use expansão de Taylor até O(h^3) para confirmar ordem de precisão.",
                                  "learningObjective": "Selecionar esquema apropriado baseado na localização da fronteira.",
                                  "commonMistakes": "Usar centrada diretamente na esquina sem ajuste, levando a pontos fora do domínio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar aproximação de segunda ordem para ∂u/∂n em bordas laterais",
                                  "subSteps": [
                                    "Para borda esquerda (i=0): introduzir ponto fantasma u_{-1,j} e aplicar centrada: (u_{1,j} - u_{-1,j})/(2h) = g_j.",
                                    "Resolver para u_{-1,j} = u_{1,j} - 2h g_j.",
                                    "Substituir na equação elíptica interna no ponto fantasma para obter stencil modificado.",
                                    "Verificar ordem de precisão com expansão de Taylor no ponto fantasma.",
                                    "Escrever a fórmula geral para bordas superior/inferior."
                                  ],
                                  "verification": "Derivar e escrever a fórmula u_{-1,j} corretamente e confirmar O(h^2).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Grade impressa",
                                    "Lápis e papel para derivações",
                                    "Software simbólico como SymPy opcional"
                                  ],
                                  "tips": "Pense no ponto fantasma como espelho simétrico ajustado pelo fluxo g.",
                                  "learningObjective": "Derivar fórmula explícita para discretização de Neumann em bordas.",
                                  "commonMistakes": "Esquecer o sinal de n (direção para fora do domínio)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar forward/backward em esquinas e validar com exemplo prático",
                                  "subSteps": [
                                    "Para esquina inferior-esquerda: combinar forward em x e y, ex: ∂u/∂n ≈ ∇u · n com diferenças unidirecionais.",
                                    "Implementar em grade pequena 3x3 com g conhecida e resolver sistema linear.",
                                    "Comparar solução numérica com solução exata (ex: u(x,y)=x^2 + y^2).",
                                    "Calcular erro L2 na fronteira e analisar convergência.",
                                    "Ajustar stencil para segunda ordem usando pontos diagonais se necessário."
                                  ],
                                  "verification": "Resolver sistema 3x3 manualmente e erro < 1% para h=0.1.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB/Python para resolver Ax=b",
                                    "Grade 5x5 impressa",
                                    "Solução exata conhecida"
                                  ],
                                  "tips": "Comece com grade pequena para depuração manual antes de código.",
                                  "learningObjective": "Integrar aproximações em esquinas e validar numericamente.",
                                  "commonMistakes": "Não tratar esquinas separadamente, causando inconsistência de ordem."
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace ∇²u=0 em [0,1]x[0,1] com Neumann ∂u/∂n=0 na borda esquerda (isolamento). Para h=0.2, ponto (0,0.2): u_{-1,1} = u_{1,1} (pois g=0). Substitua na Laplace em (-1,1): stencil ajustado u_{1,1} = (u_{0,1} + u_{2,1} + u_{1,0} + u_{1,2})/4. Resolva o sistema resultante.",
                              "finalVerifications": [
                                "Derivação correta de u_ghost para bordas laterais.",
                                "Cálculo de erro de truncamento O(h^2) via Taylor.",
                                "Implementação e resolução de grade 5x5 com erro L∞ < 0.01.",
                                "Explicação de adaptação para esquinas.",
                                "Verificação de conservação de fluxo total ∫∂u/∂n ds ≈ 0.",
                                "Comparação com método de imagens para Neumann homogêneo."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação (fórmula exata e ordem correta): 30%.",
                                "Validação numérica (erros calculados e tabela): 25%.",
                                "Tratamento de casos especiais (esquinas): 20%.",
                                "Clareza na visualização da grade e stencil: 15%.",
                                "Explicação conceitual (normal vs. tangencial): 10%."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Discretização em PDEs elípticas para potencial eletrostático.",
                                "Programação Numérica: Implementação de solvers iterativos (Gauss-Seidel) em Python/NumPy.",
                                "Engenharia Mecânica: Simulação de fluxo de calor com condições de fluxo prescrito.",
                                "Estatística: Aproximações em métodos Monte Carlo para equações diferenciais."
                              ],
                              "realWorldApplication": "Em engenharia térmica, aproxima ∂T/∂n = q (fluxo de calor conhecido) na superfície de um isolante em simulações de CFD (ex: software ANSYS ou OpenFOAM), garantindo precisão O(h^2) para malhas eficientes em design de trocadores de calor."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Montar o sistema linear para Neumann",
                            "description": "Construir a matriz tridiagonal ou pentadiagonal modificada na fronteira para o Laplaciano discretizado com condições de Neumann em um retângulo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a grade retangular e stencil padrão para o Laplaciano interno",
                                  "subSteps": [
                                    "Defina uma grade uniforme retangular com passos h_x e h_y em x e y.",
                                    "Escreva a discretização de diferenças finitas centradas para -Δu_{i,j} = (u_{i+1,j} + u_{i-1,j} - 2u_{i,j})/h_x² + (u_{i,j+1} + u_{i,j-1} - 2u_{i,j})/h_y² = f_{i,j}.",
                                    "Identifique os coeficientes do stencil em cruz para pontos internos: 4 no centro (assumindo h_x = h_y = h), -1 nos vizinhos.",
                                    "Ordene os pontos da grade em um vetor u de tamanho N=Mx x Ny.",
                                    "Esboce a estrutura pentadiagonal da matriz A para pontos internos."
                                  ],
                                  "verification": "Verifique se o stencil interno produz a identidade -Δu ≈ f para uma solução conhecida suave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, calculadora, software como Python/MATLAB para testar stencil.",
                                  "tips": "Assuma h_x = h_y = h para simplificar inicialmente; generalize depois.",
                                  "learningObjective": "Compreender a discretização padrão do Laplaciano em 2D com diferenças finitas.",
                                  "commonMistakes": "Esquecer o sinal negativo no Laplaciano ou inverter coeficientes de vizinhos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a aproximação de diferenças finitas para condições de Neumann nas fronteiras",
                                  "subSteps": [
                                    "Para fronteira esquerda (i=1): ∂u/∂x ≈ (u_{2,j} - u_{0,j})/(2h_x) = g_j, introduza u_{0,j} fictício como u_{2,j} - 2h_x g_j.",
                                    "Substitua no stencil do ponto i=1,j: o termo u_{i-1,j} vira 2u_{1,j} - 2h_x g_j (ajuste coeficientes).",
                                    "Repita para direita (i=Nx), topo (j=Ny) e baixo (j=1), adaptando para derivada normal ∂u/∂n.",
                                    "Escreva as equações modificadas para pontos de fronteira, resultando em stencil assimétrico.",
                                    "Confirme que para Neumann homogêneo (g=0), o stencil de fronteira tem coeficiente 3 no centro e -1 nos vizinhos internos."
                                  ],
                                  "verification": "Teste com g=0: a linha da matriz para ponto de fronteira deve ter 3 no diagonal e -1 no off-diagonal interno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de derivadas, exemplos de stencil de livros de análise numérica.",
                                  "tips": "Use aproximação forward/backward de segunda ordem para precisão O(h²).",
                                  "learningObjective": "Derivar corretamente as modificações de stencil para condições de Neumann.",
                                  "commonMistakes": "Usar diferença forward em vez de centrada centrada (u_{i+1}-u_{i-1})/2h, levando a O(h) erro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar modificações de fronteira no sistema linear Au = b",
                                  "subSteps": [
                                    "Para cada ponto de fronteira, substitua o stencil modificado na linha correspondente da matriz A.",
                                    "Atualize o vetor b: para Neumann não-homogêneo, adicione termos como ±h g / h² nos componentes de fronteira.",
                                    "Para cantos (ex: (1,1)), combine modificações de duas fronteiras: stencil com coeficientes ajustados (ex: 2 no centro para duas direções).",
                                    "Monte a matriz A completa: tridiagonal em 1D, pentadiagonal em 2D com bordas modificadas.",
                                    "Verifique simetria da matriz para problema auto-adjunto (Neumann homogêneo deve ser simétrica positiva definida)."
                                  ],
                                  "verification": "A matriz A deve ser simétrica e o vetor b incorporar corretamente os g's nas fronteiras.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Python (NumPy) para montar matriz pequena (ex: 3x3 grid).",
                                  "tips": "Numere pontos row-major: u_{i,j} = (j-1)*Nx + i.",
                                  "learningObjective": "Construir a matriz e vetor do sistema linear com fronteiras Neumann.",
                                  "commonMistakes": "Duplicar ajustes em cantos ou esquecer fator 1/h² nos termos de g."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar o sistema montado com um exemplo numérico",
                                  "subSteps": [
                                    "Escolha um retângulo [0,1]x[0,1], h=0.5 (grade 3x3), solução exata u=x² + y², f=4, g adequados.",
                                    "Monte A e b manualmente para grade pequena e resolva Au=b.",
                                    "Compare solução numérica com exata nos pontos da grade.",
                                    "Analise erro e confirme que condições de Neumann são satisfeitas (diferença finita ≈ g).",
                                    "Generalize para grade maior usando código para verificar estrutura da matriz."
                                  ],
                                  "verification": "Erro L2 < 0.1 para h=0.5 e condições de Neumann preservadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB para resolução.",
                                  "tips": "Use sparse matrices para eficiência em grades maiores.",
                                  "learningObjective": "Validar implementação através de convergência e satisfação de condições de contorno.",
                                  "commonMistakes": "Índices off-by-one na ordenação dos pontos ou normalização errada de h."
                                }
                              ],
                              "practicalExample": "Em um retângulo [0,1]x[0,1] com grade 3x3 (h=0.5), para -Δu=f=4 com ∂u/∂n=0 (Neumann homogêneo), solução exata u=x²+y². A matriz A (9x9) tem linhas internas pentadiagonais [-1,4,-1; etc.], bordas com [3, -1.5? wait ajustado: para h=0.5, diag=6, off=-1 em vizinhos escalados]. Resolver dá u aproximado próximo a exata.",
                              "finalVerifications": [
                                "Matriz A é simétrica e positiva definida (autovalores >0).",
                                "Vetor b incorpora corretamente termos de g nas fronteiras.",
                                "Stencil de fronteira tem diagonal 3 (para h=1) e off-diagonal -1 interno.",
                                "Solução numérica satisfaz diferenças finitas de Neumann ≈ g.",
                                "Erro de truncamento O(h²) confirmado com refinamento de grade.",
                                "Sistema é consistente (soma linhas ≈0 para Neumann puro)."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação do stencil de Neumann (segunda ordem).",
                                "Montagem precisa da matriz A com modificações de fronteira.",
                                "Incorporação correta de g no vetor b.",
                                "Validação numérica com exemplo pequeno (erro <5%).",
                                "Explicação clara de estrutura tridiagonal/pentadiagonal modificada.",
                                "Tratamento adequado de cantos e simetria da matriz."
                              ],
                              "crossCurricularConnections": [
                                "Física: Equações de Poisson em eletrostática com fluxos Neumann (campos isolados).",
                                "Computação: Implementação de solvers iterativos (Gauss-Seidel) para matrizes esparsas.",
                                "Engenharia: Simulação de fluxo de calor com isolamento térmico nas bordas.",
                                "Estatística: Problemas de suavização com penalidades de fronteira."
                              ],
                              "realWorldApplication": "Modelagem de distribuição de temperatura em uma placa isolada termicamente nas bordas (Neumann=0), usada em design de dissipadores de calor ou painéis solares, resolvida numericamente para otimizar eficiência energética."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Resolver numericamente um exemplo simples",
                            "description": "Implementar em pseudocódigo ou MATLAB a solução de -Δu = 1 com ∂u/∂n = 0 em um quadrado, verificando a compatibilidade e normalizando a solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formulação do Problema e Verificação de Compatibilidade",
                                  "subSteps": [
                                    "Defina o domínio como o quadrado unitário Ω = [0,1] × [0,1].",
                                    "Escreva a equação -Δu = 1 em Ω com condições de Neumann homogêneas ∂u/∂n = 0 em ∂Ω.",
                                    "Verifique a condição de compatibilidade: compute ∫_Ω 1 dΩ = 1 ≠ 0, confirmando incompatibilidade para existência única.",
                                    "Planeje a normalização impondo ∫_Ω u dx = 0 para unicidade da solução.",
                                    "Derive a solução analítica aproximada ou esperada (ex: u ≈ (1/2)(x^2 + y^2 - 1/3) ajustada para média zero)."
                                  ],
                                  "verification": "Confirme por escrito que ∫f = 1 e explique por que normalização é necessária; teste com integral numérica simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora, documentação de análise numérica (livro ou PDF).",
                                  "tips": "Lembre-se: para Neumann puro, soluções são únicas até constante; sempre cheque compatibilidade primeiro.",
                                  "learningObjective": "Compreender condições de existência e unicidade para problemas de Poisson-Neumann.",
                                  "commonMistakes": "Ignorar incompatibilidade e assumir existência única sem normalização; confundir com Dirichlet."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretização com Diferenças Finitas",
                                  "subSteps": [
                                    "Crie uma malha uniforme NxN pontos internos (ex: h=1/(N+1), N=20).",
                                    "Aproxime Δu ≈ (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j})/h² para pontos internos.",
                                    "Para bordas com Neumann ∂u/∂n=0, use diferenças unilaterais: ex: em x=0, (u_{1,j} - u_{0,j})/h ≈ 0 ⇒ u_{0,j} = u_{1,j}.",
                                    "Incorpore o termo fonte: b_{i,j} = h² * 1 para todos os pontos.",
                                    "Ajuste stencil nas bordas para refletir ghost points com u_ghost = u_internal."
                                  ],
                                  "verification": "Desenhe a malha 5x5 e escreva o stencil para um ponto de canto e borda; confira simetria da matriz.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, MATLAB ou Python para protótipo pequeno.",
                                  "tips": "Use ghost points para Neumann: eles simplificam o código e mantêm stencil padrão de 5 pontos.",
                                  "learningObjective": "Dominar discretização de operadores diferenciais com condições de Neumann via diferenças finitas.",
                                  "commonMistakes": "Esquecer de multiplicar por h² no vetor b; aplicar stencil de Dirichlet nas bordas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montagem do Sistema Linear",
                                  "subSteps": [
                                    "Numere os pontos da malha em vetor u de tamanho N² (row-major order).",
                                    "Construa a matriz A esparsa: diagonal -4/h², off-diagonais 1/h² para vizinhos internos.",
                                    "Inclua conexões de borda via ghost: ex: para i=1, A conecta a 'ghost' que é igual ao internal.",
                                    "Defina vetor b com b_k = 1 para todos os N² pontos (ajustado por h² já na disc.).",
                                    "Note que A é singular (kernel constantes); prepare para normalização pós-resolução."
                                  ],
                                  "verification": "Para malha 2x2, monte A e b manualmente e verifique Au ≈ b com u constante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB (sparse), ou Python com scipy.sparse; template de código.",
                                  "tips": "Use sparse matrices desde o início para eficiência; teste com N=5 primeiro.",
                                  "learningObjective": "Construir sistemas lineares esparsos corretos para EDP discretizadas.",
                                  "commonMistakes": "Indexação errada na malha (off-by-one); esquecer h² em A e b inconsistentemente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação e Resolução Numérica",
                                  "subSteps": [
                                    "Escreva pseudocódigo ou código MATLAB: função para meshgrid, montagem de A e b.",
                                    "Resolva Au = b usando pcg (conjugate gradient) com preconditioner (ex: ichol) pois A singular.",
                                    "Para singularidade, use mg = 0 (zero mean) ou resolva com pinv, mas prefira iterativo com normalização.",
                                    "Execute para N=32, plote surf(u) e contour(u).",
                                    "Normalize: subtraia a média de u para ∫u≈0."
                                  ],
                                  "verification": "Execute código e cheque ||A*u - b|| / ||b|| < 1e-6; plote para visual inspeção.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB com Optimization Toolbox, ou Python (numpy, scipy.sparse.linalg); script template.",
                                  "tips": "Inicie com pcg(A,b,1e-8,N²); para singular, adicione pequena diagonal ou normalize b.",
                                  "learningObjective": "Implementar e resolver numericamente sistemas de EDP com métodos iterativos.",
                                  "commonMistakes": "Não tratar singularidade (crash); malha indexing errada levando a NaNs."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação Final e Análise",
                                  "subSteps": [
                                    "Compute resíduo máximo: max | -Δh u - 1 | onde Δh é discreta.",
                                    "Verifique Neumann discretamente nas bordas: approx ∂u/∂n ≈0.",
                                    "Confira normalização: mean(u reshaped) ≈0.",
                                    "Compare com solução analítica: u(x,y) = (x² + y²)/2 - 1/6 + c, c para mean=0.",
                                    "Analise convergência: rode para N=16,32,64 e plote erro L2 vs h."
                                  ],
                                  "verification": "Gere relatório com plots de resíduo, norma L2 erro < O(h²), e tabela de convergência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do step 4, MATLAB plot functions.",
                                  "tips": "Use trapz2 para integrais numéricas; erro O(h²) esperado para 2nd order FD.",
                                  "learningObjective": "Validar soluções numéricas e analisar precisão/ordem de convergência.",
                                  "commonMistakes": "Não normalizar, levando a soluções arbitrárias; ignorar resíduos nas bordas."
                                }
                              ],
                              "practicalExample": "Em MATLAB, para quadrado [0,1]^2 com N=31 (h=1/32): [X,Y]=meshgrid(linspace(0,1,N)); h=1/(N-1); A=sparse(...montagem...); b=ones((N-1)^2,1); u=pcg(A,b,1e-8,100); u=reshape(u,N-1,N-1); u=u-mean(u(:)); surf(X,Y,u); Verifique max(abs(laplace2d(u)/h^2 +1)) <1e-4.",
                              "finalVerifications": [
                                "Resíduo da equação discretizada ||A u - b||_2 / ||b||_2 < 10^{-6}.",
                                "Condições de Neumann discretas satisfeitas com erro < 10^{-4} nas bordas.",
                                "Solução normalizada: média de u sobre a malha ≈ 0 com tolerância 10^{-8}.",
                                "Ordem de convergência O(h^2) confirmada com refinamento de malha.",
                                "Visualização mostra solução parabólica suave, sem oscilações.",
                                "Comparação L2 com solução exata ajustada: erro < 10^{-3} para h=1/32."
                              ],
                              "assessmentCriteria": [
                                "Correta formulação e reconhecimento de incompatibilidade/necessidade de normalização (20%).",
                                "Discretização precisa de Laplace e Neumann com stencil correto (25%).",
                                "Montagem e resolução eficiente do sistema esparso (25%).",
                                "Implementação em código funcional e reproduzível (15%).",
                                "Verificações quantitativas e análise de erro completa (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Uso de matrizes esparsas e solvers iterativos em MATLAB/Python.",
                                "Física: Modelagem de campos escalares em equilíbrio térmico com isolamento (lei de Fourier).",
                                "Engenharia: Simulações em CFD para fluxos incompressíveis (pressão com Neumann).",
                                "Estatística: Análise de erros numéricos e convergência Monte Carlo opcional."
                              ],
                              "realWorldApplication": "Simulação de distribuição de temperatura em uma placa isolada com geração de calor uniforme (ex: reatores nucleares, chips eletrônicos), onde condições de Neumann modelam isolamento térmico perfeito nas bordas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.2",
                              "10.1.4.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Tratamento Numérico de Condições de Neumann",
                    "description": "Aproximação das condições de Neumann usando diferenças finitas centradas ou unilaterais na fronteira.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Condições de Neumann em Equações Elípticas",
                        "description": "Definição e formulação matemática das condições de Neumann, que especificam a derivada normal da solução na fronteira de um domínio, com aplicações típicas em problemas de condução de calor com isolamento térmico.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar condições de Neumann",
                            "description": "Diferenciar condições de Neumann das de Dirichlet e formular a condição ∂u/∂n = g na fronteira para equações elípticas como a equação de Poisson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de condições de contorno em EDP",
                                  "subSteps": [
                                    "Estude a definição de condições de contorno em equações diferenciais parciais (EDP).",
                                    "Revise condições de Dirichlet: u = f na fronteira Γ.",
                                    "Identifique o papel das condições de contorno na unicidade da solução.",
                                    "Analise exemplos simples de problemas elípticos sem condições de contorno.",
                                    "Discuta por que condições de Neumann são alternativas naturais."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças iniciais entre tipos de condições de contorno e liste 2 exemplos de cada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula sobre EDP elípticas, quadro branco"
                                  ],
                                  "tips": "Use diagramas para visualizar a fronteira Γ e os valores impostos.",
                                  "learningObjective": "Compreender o contexto geral de condições de contorno em problemas elípticos.",
                                  "commonMistakes": [
                                    "Confundir condições de contorno com condições iniciais em EDP parabólicas.",
                                    "Ignorar a importância da fronteira na formulação do problema."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e formular a condição de Neumann",
                                  "subSteps": [
                                    "Defina condição de Neumann: derivada normal ∂u/∂n = g na fronteira Γ.",
                                    "Explique o vetor normal unitário n e o gradiente ∇u.",
                                    "Derive a notação ∂u/∂n = ∇u · n.",
                                    "Estude compatibilidade para existência de solução em equações de Poisson.",
                                    "Pratique escrevendo a condição para domínios 1D e 2D simples.",
                                    "Discuta o significado físico: fluxo ou gradiente prescrito."
                                  ],
                                  "verification": "Escreva a formulação matemática de Neumann para um problema em disco unitário e verifique com fórmula derivada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy para derivadas), exemplos de problemas de Poisson"
                                  ],
                                  "tips": "Desenhe setas para o vetor normal apontando para fora do domínio.",
                                  "learningObjective": "Formular precisamente a condição de Neumann ∂u/∂n = g.",
                                  "commonMistakes": [
                                    "Confundir ∂u/∂n com derivada direcional arbitrária.",
                                    "Esquecer a orientação do normal (interno vs. externo)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar condições de Neumann das de Dirichlet",
                                  "subSteps": [
                                    "Compare imposição de valor (Dirichlet) vs. derivada (Neumann).",
                                    "Liste prós e contras: Dirichlet determina u, Neumann determina fluxo.",
                                    "Analise impacto na matriz do sistema linear numérico (diagonal vs. off-diagonal).",
                                    "Identifique problemas mistos (Dirichlet + Neumann).",
                                    "Resolva um problema híbrido simples analiticamente."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 5 critérios (ex: unicidade, estabilidade numérica, aplicação física).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela comparativa em Excel ou papel, exemplos numéricos de método dos elementos finitos"
                                  ],
                                  "tips": "Use analogia: Dirichlet é temperatura fixa, Neumann é fluxo de calor fixo.",
                                  "learningObjective": "Diferenciar claramente Neumann de Dirichlet em contextos teóricos e numéricos.",
                                  "commonMistakes": [
                                    "Achar que Neumann sempre requer normalização da solução.",
                                    "Ignorar condições de compatibilidade em Neumann puro."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação em equações elípticas como Poisson",
                                  "subSteps": [
                                    "Estude a equação de Poisson: -Δu = f com Neumann ∂u/∂n = g em Γ.",
                                    "Verifique condição de solvibilidade: ∫f dΩ = ∫g dΓ.",
                                    "Identifique Neumann em problemas reais (ex: isolação térmica).",
                                    "Simule numericamente um problema com Neumann usando diferenças finitas.",
                                    "Avalie sensibilidade a perturbações em g."
                                  ],
                                  "verification": "Resolva um problema de Poisson com Neumann em 1D e confirme solvibilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para Poisson 1D/2D, calculadora gráfica"
                                  ],
                                  "tips": "Sempre cheque a integral de compatibilidade antes de resolver.",
                                  "learningObjective": "Identificar e formular Neumann corretamente em equações elípticas.",
                                  "commonMistakes": [
                                    "Esquecer a condição de solvibilidade levando a singularidade.",
                                    "Usar discretização incompatível na fronteira."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de Poisson -Δu = 1 em um quadrado unitário com ∂u/∂n = 0 em três lados e ∂u/∂n = 1 no lado inferior. Verifique solvibilidade (∫1 dΩ = 1 = ∫g dΓ), resolva numericamente e plote o gradiente na fronteira para confirmar Neumann.",
                              "finalVerifications": [
                                "Formula corretamente ∂u/∂n = g para um domínio dado.",
                                "Diferencia Neumann de Dirichlet em uma declaração escrita.",
                                "Verifica solvibilidade para Poisson com Neumann puro.",
                                "Identifica Neumann em um problema físico descrito verbalmente.",
                                "Explica o impacto numérico de Neumann vs. Dirichlet.",
                                "Resolve um exemplo 1D analiticamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (∂u/∂n = ∇u · n).",
                                "Correta diferenciação conceitual de Dirichlet.",
                                "Verificação de condições de solvibilidade.",
                                "Aplicação correta em contextos elípticos.",
                                "Clareza em exemplos e analogias físicas.",
                                "Profundidade na análise numérica de impactos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Fluxo de calor e equações de difusão.",
                                "Engenharia: Modelagem de tensões em estruturas (equilíbrio elástico).",
                                "Computação: Implementação em métodos de elementos finitos (FEM).",
                                "Física Computacional: Simulações em fluidos incompressíveis."
                              ],
                              "realWorldApplication": "Em engenharia térmica, condições de Neumann modelam isolantes perfeitos (∂T/∂n = 0) em painéis solares, permitindo simular distribuição de temperatura sem medir valores exatos na fronteira."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Interpretar condições de Neumann em problemas físicos",
                            "description": "Relacionar condições de Neumann a cenários físicos, como fluxo nulo através de fronteiras isoladas, e escrever a condição em coordenadas cartesianas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de condições de Neumann",
                                  "subSteps": [
                                    "Estudar a definição de condição de Neumann como especificação da derivada normal da solução na fronteira.",
                                    "Comparar com condições de Dirichlet, que fixam o valor da função.",
                                    "Analisar o significado matemático: ∂u/∂n = g na fronteira ∂Ω.",
                                    "Revisar exemplos básicos em equações elípticas como Laplace ou Poisson.",
                                    "Discutir propriedades de existência e unicidade (até constante aditiva)."
                                  ],
                                  "verification": "Explicar em palavras próprias a diferença entre Neumann e Dirichlet, com um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDPs elípticas",
                                    "Livro-texto de Análise Numérica (capítulo de condições de contorno)",
                                    "Vídeo introdutório sobre condições de contorno"
                                  ],
                                  "tips": "Use analogias físicas desde o início para fixar o conceito abstrato.",
                                  "learningObjective": "Dominar a definição matemática e distinções chave de condições de Neumann.",
                                  "commonMistakes": [
                                    "Confundir derivada normal com derivada direcional arbitrária",
                                    "Achar que Neumann sempre implica fluxo zero",
                                    "Ignorar normalização do vetor normal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar condições de Neumann a cenários físicos",
                                  "subSteps": [
                                    "Interpretar ∂u/∂n = 0 como fluxo nulo através da fronteira (isolamento).",
                                    "Explorar exemplos: isolamento térmico (equação de calor estacionário), campo elétrico em condutores isolados.",
                                    "Analisar ∂u/∂n = f como fluxo imposto (ex: radiação ou convecção).",
                                    "Mapear para problemas físicos: difusão de poluentes com barreiras impermeáveis.",
                                    "Discutir simetrias e conservação de massa/energia implícitas."
                                  ],
                                  "verification": "Identificar e descrever o cenário físico correspondente a ∂u/∂n = 0 em uma fronteira reta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de fluxo físico (imagens de isolamento térmico)",
                                    "Exemplos de problemas físicos de livros de Física Matemática",
                                    "Simulador online de EDPs (ex: Wolfram Alpha)"
                                  ],
                                  "tips": "Desenhe setas de fluxo na fronteira para visualizar o 'nulo'.",
                                  "learningObjective": "Associar condições de Neumann a interpretações físicas concretas como isolamento ou fluxo controlado.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente como valor zero da função",
                                    "Confundir com condições periódicas",
                                    "Aplicar a fluxos não perpendiculares à fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever condições de Neumann em coordenadas cartesianas",
                                  "subSteps": [
                                    "Derivar a forma explícita para fronteiras alinhadas: ∂u/∂x = g em x=constante.",
                                    "Para y=constante: ∂u/∂y = g; generalizar para vetor normal n = (n_x, n_y).",
                                    "Escrever ∇u · n = g, com n unitário.",
                                    "Praticar em domínio retangular: condições em cada lado.",
                                    "Verificar consistência com discretização numérica (diferenças finitas)."
                                  ],
                                  "verification": "Escrever corretamente a condição ∂u/∂x = 0 na fronteira x=0 para um problema dado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel quadriculado para desenhos",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Folhas de exercícios de condições de contorno"
                                  ],
                                  "tips": "Sempre normalize o vetor normal para evitar erros de escala.",
                                  "learningObjective": "Formular matematicamente condições de Neumann em 2D cartesiano com precisão.",
                                  "commonMistakes": [
                                    "Esquecer o sinal do normal outward/inward",
                                    "Usar derivada tangencial em vez de normal",
                                    "Não especificar o lado da fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar interpretação física e formulação em um exemplo completo",
                                  "subSteps": [
                                    "Escolher problema: placa retangular com bordas isoladas (∂u/∂n=0).",
                                    "Interpretar fisicamente: distribuição de temperatura sem perda de calor nas bordas.",
                                    "Escrever sistema completo: Δu=0 interior, condições Neumann nas fronteiras.",
                                    "Discutir solução qualitativa (constante, up to aditiva).",
                                    "Explorar numérico: como implementar em método de diferenças finitas."
                                  ],
                                  "verification": "Montar e explicar um problema físico completo com condições de Neumann escritas em cartesiano.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo resolvido de livro de EDPs",
                                    "Python/MATLAB para protótipo numérico simples",
                                    "Gráficos de soluções analíticas"
                                  ],
                                  "tips": "Teste com valores numéricos simples para validar a interpretação.",
                                  "learningObjective": "Combinar interpretação física, formulação matemática e verificação em contexto real.",
                                  "commonMistakes": [
                                    "Violar compatibilidade para existência (integral de g ≠0)",
                                    "Ignorar não-unicidade da solução",
                                    "Confundir com problemas de Dirichlet mistos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma placa retangular [0,1]x[0,1] modelando condução de calor estacionário (Δu=0), as bordas isoladas termicamente impõem ∂u/∂n=0: ∂u/∂x=0 em x=0 e x=1; ∂u/∂y=0 em y=0 e y=1. Isso representa ausência de fluxo de calor, resultando em u constante (temperatura uniforme).",
                              "finalVerifications": [
                                "Explicar o significado físico de ∂u/∂n=0 em um contexto de isolamento.",
                                "Escrever corretamente a condição em coordenadas cartesianas para uma fronteira vertical/horizontal.",
                                "Identificar cenários físicos onde Neumann é apropriada (ex: barreiras impermeáveis).",
                                "Discutir implicações para existência/unicidade da solução.",
                                "Aplicar em um domínio simples e verificar consistência.",
                                "Diferenciar de Dirichlet em termos físicos e matemáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação física (fluxo nulo vs. valor fixo).",
                                "Correção na formulação matemática em cartesiano (normal correto).",
                                "Profundidade de exemplos físicos relevantes e variados.",
                                "Capacidade de integrar conceitos em problema completo.",
                                "Identificação de erros comuns e limitações (ex: não-unicidade).",
                                "Clareza na explicação oral/escrita de conexões físico-matemáticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Equação de calor/difusão e conservação de energia.",
                                "Engenharia Mecânica: Modelagem de isolantes térmicos em estruturas.",
                                "Computação Científica: Implementação em métodos numéricos (diferenças finitas).",
                                "Matemática Aplicada: Análise de autovalores em problemas de Sturm-Liouville.",
                                "Engenharia Elétrica: Campos em regiões isoladas (equação de Laplace)."
                              ],
                              "realWorldApplication": "Projeto de materiais isolantes em edifícios (condições Neumann modelam paredes adiabáticas para otimizar eficiência energética); simulações de fluxo de fluidos em reservatórios com barreiras impermeáveis; análise de campos eletromagnéticos em cavidades isoladas para antenas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Verificar compatibilidade das condições de Neumann",
                            "description": "Analisar a condição de compatibilidade para problemas bem-postos com condições de Neumann puras, usando integrais sobre a fronteira.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema de Neumann Puro em Equações Elípticas",
                                  "subSteps": [
                                    "Revise a equação elíptica padrão, como -Δu = f em domínio Ω com ∂u/∂n = g na fronteira ∂Ω.",
                                    "Identifique as condições de Neumann puras: ausência de condições de Dirichlet, apenas derivadas normais na fronteira.",
                                    "Discuta a não-univocidade da solução (até constante aditiva) e a necessidade de condições de compatibilidade para existência.",
                                    "Estude o teorema de Fredholm alternativo para operadores elípticos auto-adjuntos.",
                                    "Anote exemplos clássicos como a equação de Poisson com Neumann homogêneo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que problemas de Neumann puro requerem compatibilidade, citando referências teóricas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Brenner & Scott), caderno para anotações, acesso a notas de aula sobre equações elípticas."
                                  ],
                                  "tips": "Comece com domínios simples como intervalos 1D para intuição antes de 2D/3D.",
                                  "learningObjective": "Compreender conceitualmente o problema de Neumann puro e sua sensibilidade à compatibilidade.",
                                  "commonMistakes": [
                                    "Confundir com condições de Dirichlet mistas.",
                                    "Ignorar a não-univocidade da solução.",
                                    "Esquecer que f e g devem satisfazer relação integral."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Condição de Compatibilidade Usando Teorema da Divergência",
                                  "subSteps": [
                                    "Integre a equação -Δu = f sobre Ω: ∫_Ω -Δu dV = ∫_Ω f dV.",
                                    "Aplique o teorema da divergência: ∫_Ω Δu dV = ∫_∂Ω ∂u/∂n dS.",
                                    "Substitua a condição de Neumann: ∫_∂Ω g dS = ∫_Ω f dV.",
                                    "Verifique para casos homogêneos (g=0 implica ∫f=0).",
                                    "Generalize para soluções fracas no espaço H^1(Ω)."
                                  ],
                                  "verification": "Derive a igualdade ∫_Ω f = ∫_∂Ω g em um relatório curto com todas as etapas matemáticas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como SymPy ou Mathematica para verificação, papel e lápis para derivação manual."
                                  ],
                                  "tips": "Use vetor constante de teste (função 1) no espaço de soluções para simplicidade na derivação variacional.",
                                  "learningObjective": "Derivar rigorosamente a condição necessária e suficiente de compatibilidade.",
                                  "commonMistakes": [
                                    "Erro de sinal na integração por partes.",
                                    "Confundir volume com superfície.",
                                    "Não considerar orientação da normal externa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Compatibilidade Analiticamente em um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha domínio unitário: Ω = disco unitário, f=1 constante.",
                                    "Calcule ∫_Ω f dV = π (área).",
                                    "Defina g na fronteira ∂Ω (círculo de raio 1): g deve satisfazer ∫_∂Ω g dS = 2π * média(g) = π.",
                                    "Teste casos: g=1/2 (compatível), g=1 (incompatível).",
                                    "Analise implicações: existência vs não-existência da solução."
                                  ],
                                  "verification": "Compute numericamente as integrais e confirme se ∫f - ∫g < 1e-10 para compatível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para integrais, diagrama do domínio."
                                  ],
                                  "tips": "Use coordenadas polares para integrais no disco: ∫g ds = ∫_0^{2π} g(θ) dθ.",
                                  "learningObjective": "Aplicar a condição em um caso analítico fechado.",
                                  "commonMistakes": [
                                    "Erro no comprimento da fronteira (2πr com r=1).",
                                    "Usar área em vez de comprimento de arco.",
                                    "Ignorar fator de normalização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Verificação Numérica e Diagnosticar Falhas",
                                  "subSteps": [
                                    "Discretize o domínio com malha finita (ex: quadriláteros ou FEniCS/GMSH).",
                                    "Aproxime integrais numéricas: ∫_Ω f ≈ soma elementos, ∫_∂Ω g ≈ soma arestas fronteira.",
                                    "Implemente código para checar |∫f - ∫g| / ||f|| < tol.",
                                    "Teste com ruído em g para simular erros de medição.",
                                    "Discuta correções: projeção ortogonal de g no espaço compatível."
                                  ],
                                  "verification": "Execute código com exemplo do Step 3 e produza output confirmando compatibilidade com tolerância 1e-6.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou FEniCS, malha de teste (ex: Gmsh file para disco)."
                                  ],
                                  "tips": "Use quadrature Gauss para precisão em integrais numéricas.",
                                  "learningObjective": "Realizar verificação prática em contexto numérico.",
                                  "commonMistakes": [
                                    "Malha grosseira levando a erro de integração.",
                                    "Não normalizar pelo norma de f.",
                                    "Confundir elementos internos com fronteira."
                                  ]
                                }
                              ],
                              "practicalExample": "Para -Δu = 1 no quadrado unitário [0,1]^2 com ∂u/∂n = 0.25 nas laterais (compatível, pois ∫f=1, ∫g=4*0.25*1=1). Verifique computando integrais: se |1 - 1| = 0, problema bem-postos; altere g para 0.3 (incompatível).",
                              "finalVerifications": [
                                "Confirmação analítica: ∫_Ω f dV == ∫_∂Ω g dS exata.",
                                "Verificação numérica: erro relativo < 1e-8 em malha fina.",
                                "Teste com função teste constante no método dos elementos finitos converge.",
                                "Solução numérica estável sem resíduos altos na fronteira.",
                                "Discussão escrita das implicações para existência única (até constante)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação da condição de compatibilidade (100% das etapas corretas).",
                                "Correção dos cálculos de integrais no exemplo prático.",
                                "Implementação numérica funcional e com tolerâncias adequadas.",
                                "Identificação correta de casos compatíveis/incompatíveis.",
                                "Explicação clara de erros comuns e correções.",
                                "Relatório estruturado com todas as verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Conservação de fluxo em equações de difusão/eletróstática (Lei de Gauss).",
                                "Computação: Integração numérica e métodos de elementos finitos (FEniCS/PETSc).",
                                "Engenharia: Modelagem de problemas de contorno em fluidos/estruturas.",
                                "Estatística: Verificação de hipóteses em dados de fronteira ruidosos."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor com isolamento térmico (Neumann=0), verifica se a fonte total de calor equals fluxo de fronteira zero; usado em design de reatores nucleares ou isolamento acústico para garantir solvibilidade numérica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Aproximação com Diferenças Finitas Centradas",
                        "description": "Discretização das condições de Neumann utilizando diferenças finitas centradas na fronteira, introduzindo pontos fantasma para aproximar a derivada normal com segunda ordem de precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Derivar stencil centrado para Neumann",
                            "description": "Obter a aproximação (u_{i+1} - u_{i-1})/(2h) = g para a derivada na fronteira e introduzir ponto fantasma u_0 para substituir na equação elíptica interna.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema elíptico com condição de Neumann e definir a grade numérica",
                                  "subSteps": [
                                    "Identifique a equação elíptica modelo, como -u''(x) = f(x) em [0,1].",
                                    "Defina a condição de Neumann na fronteira esquerda: u'(0) = g.",
                                    "Estabeleça a grade uniforme x_i = i h, i=0,1,...,N com h=1/N, onde x_0=0 é fronteira, x_1=h é primeiro ponto interno.",
                                    "Note que u_0 não é desconhecido devido à Neumann; introduza ponto fantasma u_{-1} ou u_0 fora da grade se necessário.",
                                    "Escreva a discretização padrão centrada para a equação interna: (u_{i-1} - 2u_i + u_{i+1})/h² ≈ f_i para i≥1."
                                  ],
                                  "verification": "Confirme que a grade está corretamente definida e a condição u'(0)=g está clara em anotações.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Papel e lápis",
                                    "Folha com equação modelo -u''=f",
                                    "Calculadora para h"
                                  ],
                                  "tips": [
                                    "Comece sempre pelo 1D para simplicidade antes de generalizar para 2D.",
                                    "Desenhe a grade visualmente para visualizar pontos fantasma."
                                  ],
                                  "learningObjective": "Compreender o setup numérico para condições de Neumann em equações elípticas.",
                                  "commonMistakes": [
                                    "Confundir índice i=0 como ponto interno.",
                                    "Esquecer que Neumann não fixa valor, mas derivada."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a aproximação de diferenças finitas centrada para a derivada na fronteira",
                                  "subSteps": [
                                    "Use expansão de Taylor em x_1=h: u(x_1 + h) = u_2 ≈ u(h) + h u'(h) + (h²/2)u''(h) + O(h³), u(x_1 - h)=u_0 ≈ u(h) - h u'(h) + (h²/2)u''(h) + O(h³).",
                                    "Subtraia: (u_2 - u_0)/(2h) ≈ u'(h) + O(h²), que é centrada e ordem 2.",
                                    "Como fronteira em x=0, mas centrada em x_1, aproxima u'(0) ≈ u'(h) para consistência local.",
                                    "Escreva explicitamente: (u_2 - u_0)/(2h) = g.",
                                    "Resolva para u_0: u_0 = u_2 - 2 h g."
                                  ],
                                  "verification": "Verifique se a fórmula (u_{i+1} - u_{i-1})/(2h) = g está derivada corretamente via Taylor.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "Papel para expansões Taylor",
                                    "Tabela de Taylor para u(x+h) e u(x-h)"
                                  ],
                                  "tips": [
                                    "Lembre-se: centrada cancela termo h²/2 u'', dando precisão O(h²).",
                                    "Anote resíduos O(h²) para confirmar ordem."
                                  ],
                                  "learningObjective": "Derivar e justificar a precisão da aproximação centrada para derivadas de fronteira.",
                                  "commonMistakes": [
                                    "Usar forward/backward em vez de centered, perdendo ordem 2.",
                                    "Erro de sinal em u_0 = u_2 - 2hg."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a equação elíptica discreta no primeiro ponto interno usando o ponto fantasma",
                                  "subSteps": [
                                    "Escreva a stencil padrão centrada em i=1: (u_0 - 2 u_1 + u_2)/h² = f_1.",
                                    "Multiplique por h²: u_0 - 2 u_1 + u_2 = h² f_1.",
                                    "Substitua u_0 da condição de Neumann: (u_2 - 2 h g) - 2 u_1 + u_2 = h² f_1.",
                                    "Simplifique: 2 u_2 - 2 u_1 - 2 h g = h² f_1.",
                                    "Divida por 2: u_2 - u_1 - h g = (h² / 2) f_1."
                                  ],
                                  "verification": "Confirme que a equação em i=1 incorpora corretamente u_0 substituído.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Equações escritas do step anterior",
                                    "Lápis para álgebra simbólica"
                                  ],
                                  "tips": [
                                    "Mantenha h² multiplicador para evitar erros dimensionais.",
                                    "Verifique unidades: derivada tem 1/h."
                                  ],
                                  "learningObjective": "Integrar condição de fronteira na discretização interna via ponto fantasma.",
                                  "commonMistakes": [
                                    "Esquecer fator h² na equação elíptica.",
                                    "Sinal errado ao substituir u_0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter o stencil final de fronteira e verificar consistência",
                                  "subSteps": [
                                    "Reescreva o stencil para i=1: -u_1 + u_2 = (h² / 2) f_1 + h g.",
                                    "Compare com stencil interno padrão -u_{i-1} + 2 u_i - u_{i+1} = -h² f_i (ajustado).",
                                    "Note assimetria: coeficiente de u_1 é -1, u_2 é +1, termo fonte modificado (h²/2)f_1 + h g.",
                                    "Verifique truncagem: ambos O(h²), consistente.",
                                    "Geralize para 2D se aplicável, mas foque em 1D."
                                  ],
                                  "verification": "O stencil final deve ser u_2 - u_1 = (h²/2) f_1 + h g, sem u_0.",
                                  "estimatedTime": "10-15 minutes",
                                  "materials": [
                                    "Stencils de steps anteriores",
                                    "Exemplo numérico simples para testar"
                                  ],
                                  "tips": [
                                    "Teste com g=0 (Neumann homogênea) para reduzir a Neumann-Dirichlet.",
                                    "Implemente em código para validar."
                                  ],
                                  "learningObjective": "Derivar stencil assimétrico de fronteira eliminando fantasma.",
                                  "commonMistakes": [
                                    "Não dividir por 2, levando a coeficientes errados.",
                                    "Ignorar modificação no termo fonte."
                                  ]
                                }
                              ],
                              "practicalExample": "Para -u''=0 em [0,1], u'(0)=1, u(1)=0. Solução exata u(x)=x. Com h=0.5, pontos x0=0,x1=0.5,x2=1. Aproximação: (u2 - u0)/(1)=1 => u0=u2-1. Em i=1: u0-2u1+u2=0. Subst: (u2-1)-2u1+u2=0 => 2u2 -2u1=1. Com u2=0: -2u1=1 => u1=-0.5 (erro devido h grosseiro). Stencil: u2 - u1 = 0.5*0 + 0.5*1 =0.5.",
                              "finalVerifications": [
                                "A aproximação centrada é (u_{i+1} - u_{i-1})/(2h) = g com erro O(h²).",
                                "Ponto fantasma u_0 = u_2 - 2 h g está corretamente expresso.",
                                "Stencil final em i=1: u_2 - u_1 = (h²/2) f_1 + h g sem variáveis fantasmas.",
                                "Consistência de ordem: truncagem O(h²) preservada.",
                                "Teste numérico simples converge para solução exata ao refinar h.",
                                "Geralização para Neumann direita similar."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação Taylor para precisão O(h²).",
                                "Substituição algébrica precisa de u_0 na equação de i=1.",
                                "Stencil final matches fórmula padrão de literatura numérica.",
                                "Identificação correta de termos fonte modificados (h g e h²/2 f).",
                                "Explicação clara de eliminação do fantasma e assimetria.",
                                "Verificação via exemplo prático sem erros aritméticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Condições de Neumann em equações de Poisson para fluxos de calor/eletricidade.",
                                "Computação: Implementação em solvers finitos diferenças (e.g., SciPy, MATLAB).",
                                "Engenharia: Modelagem de gradientes em estruturas (tensão, temperatura).",
                                "Estatística: Aproximações em processos estocásticos com fronteiras."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor com fluxo prescrito (Neumann) em paredes isoladas, como em reatores nucleares ou design de trocadores de calor, onde se especifica gradiente de temperatura na fronteira para otimizar eficiência energética."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Montar sistema linear com stencil centrado",
                            "description": "Construir o sistema de equações lineares para uma malha 1D ou 2D com condições de Neumann em uma ou ambas as fronteiras, eliminando o ponto fantasma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a malha e a equação diferencial",
                                  "subSteps": [
                                    "Defina o domínio 1D ou 2D (ex: intervalo [0,1] ou quadrado unitário).",
                                    "Escolha o passo de malha h uniforme e defina os pontos internos xi = i*h, i=1 a N-1.",
                                    "Escreva a equação elíptica modelo, como -Δu = f, com condições de Neumann u' = g nas fronteiras.",
                                    "Identifique as fronteiras com Neumann (esquerda, direita ou ambas)."
                                  ],
                                  "verification": "Verifique se o número de pontos internos é correto (N-1 para 1D) e se as condições de fronteira estão anotadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora, software como MATLAB ou Python (opcional).",
                                  "tips": "Comece com 1D para simplicidade antes de estender para 2D.",
                                  "learningObjective": "Compreender a geometria da malha e as condições de contorno Neumann.",
                                  "commonMistakes": "Confundir condições de Dirichlet com Neumann; esquecer de contar pontos fantasmas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar a equação interior com stencil centrado",
                                  "subSteps": [
                                    "Aplique diferenças finitas centradas: para 1D, u''(xi) ≈ (u_{i-1} - 2u_i + u_{i+1})/h².",
                                    "Para 2D, desenvolva o stencil de 5 pontos: u_i,j ≈ média dos vizinhos menos f*h².",
                                    "Escreva a equação discreta para pontos internos: Au_{i-1} + Bu_i + Cu_{i+1} = f_i.",
                                    "Confirme que o esquema é centrado e de segunda ordem."
                                  ],
                                  "verification": "Teste o operador Laplaciano em um ponto conhecido, como u(x)=x², deve dar 2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha com malha desenhada, fórmula de diferenças finitas anotada.",
                                  "tips": "Desenhe o stencil graficamente para visualizar os coeficientes.",
                                  "learningObjective": "Dominar a aproximação de diferenças finitas centradas para operadores elípticos.",
                                  "commonMistakes": "Usar diferenças forward/backward nos internos; errar o fator h²."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar condições de Neumann e introduzir pontos fantasmas",
                                  "subSteps": [
                                    "Para Neumann em x=0: u'(0) ≈ (u_1 - u_0)/h = g(0), onde u_0 é fantasma.",
                                    "Similar para x=1: u'(1) ≈ (u_{N} - u_{N-1})/h = g(1), u_N fantasma.",
                                    "Substitua nas equações dos pontos adjacentes à fronteira.",
                                    "Para 2D, aplique em cada direção (ex: normal à fronteira)."
                                  ],
                                  "verification": "Substitua u_fantasma na equação fronteira e veja se a condição é satisfeita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama da malha com fantasmas marcados.",
                                  "tips": "Lembre: Neumann homogênea implica u_fantasma ≈ 2u_fronteira - u_interno.",
                                  "learningObjective": "Implementar corretamente condições de Neumann via pontos fantasmas.",
                                  "commonMistakes": "Usar aproximação forward em vez de centrada para derivada; inverter o sinal da condição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Eliminar fantasmas e montar o sistema linear",
                                  "subSteps": [
                                    "Elimine u_fantasma das equações fronteira, modificando coeficientes dos pontos reais.",
                                    "Para 1D com Neumann bilateral: sistema tridiagonal com 1, -2, 1 ajustado nas extremidades.",
                                    "Escreva a matriz A esparsa e vetor b completo.",
                                    "Para 2D, monte a matriz bloco ou vetorize os graus de liberdade."
                                  ],
                                  "verification": "O sistema deve ter tamanho (N-1)x(N-1) para 1D; resolva para caso conhecido e compare.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Matriz em papel ou software para montar A e b.",
                                  "tips": "Use notação de stencil para anotar modificações: [1,1] vira [2,0] para Neumann homogênea.",
                                  "learningObjective": "Formular o sistema linear final pronto para resolução iterativa.",
                                  "commonMistakes": "Esquecer de ajustar b com g; matriz singular por normalização errada."
                                }
                              ],
                              "practicalExample": "Para -u''=0 em [0,1], u'(0)=1, u'(1)=-1, h=0.25 (N=5). Pontos: x0=0, x1=0.25,...,x4=1. Fantasma x-1 e x5. Elimine: equação em x1 vira 2u1 -2u2 = h*1; em x4: -2u3 +2u4 = h*(-1). Sistema: tridiagonal modificado.",
                              "finalVerifications": [
                                "O stencil centrado está correto nos internos (coeficientes 1,-2,1 em 1D)?",
                                "Pontos fantasmas foram eliminados corretamente nas fronteiras Neumann?",
                                "A matriz A é simétrica e definida positiva?",
                                "O vetor b incorpora corretamente as condições g nas fronteiras?",
                                "Para 2D, o stencil de 5 pontos foi estendido às bordas?",
                                "O sistema tem o número exato de equações (dimensão da malha interna)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do stencil centrado (ordem 2).",
                                "Correta eliminação de fantasmas sem introduzir inconsistências.",
                                "Matriz e vetor b livres de erros algébricos.",
                                "Extensão válida para 2D com stencil cruzado.",
                                "Explicação clara das modificações fronteira.",
                                "Teste numérico em exemplo simples converge para solução exata."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de campos eletrostáticos ou térmicos com fluxos prescritos (Neumann).",
                                "Computação: Implementação de métodos de diferenças finitas em Python/MATLAB.",
                                "Engenharia: Simulações de transferência de calor em isolantes.",
                                "Álgebra Linear: Resolução de sistemas esparsos tridiagonais."
                              ],
                              "realWorldApplication": "Em engenharia térmica, montar sistemas para simular distribuição de temperatura em uma barra com fluxos de calor conhecidos nas extremidades, essencial para design de isolantes ou reatores químicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Analisar truncagem do erro para diferenças centradas",
                            "description": "Calcular o erro de truncagem local O(h^2) para a aproximação centrada da derivada de primeira ordem na condição de Neumann.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Aproximação Centrada da Derivada de Primeira Ordem",
                                  "subSteps": [
                                    "Lembre a fórmula padrão para a derivada centrada: f'(x_i) ≈ [f(x_{i+1}) - f(x_{i-1})] / (2h)",
                                    "Identifique o contexto da condição de Neumann: ∂u/∂n = g em ponto de fronteira",
                                    "Adapte para direção normal na fronteira, usando pontos internos",
                                    "Esboce o stencil de diferenças finitas para o lado da fronteira",
                                    "Verifique simetria e ordem de precisão esperada O(h^2)"
                                  ],
                                  "verification": "Escreva corretamente a fórmula adaptada para Neumann e identifique os termos envolvidos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Análise Numérica (capítulo de diferenças finitas)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre desenhe a grade numérica para visualizar pontos de fronteira e internos",
                                  "learningObjective": "Compreender a base da aproximação centrada em condições de fronteira Neumann",
                                  "commonMistakes": "Confundir derivada forward/backward com centrada; ignorar a direção normal"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a Expansão em Série de Taylor para Pontos Envolvidos",
                                  "subSteps": [
                                    "Expanda u(x_{i+1}) em Taylor ao redor de x_i: u(x_i + h) = u(x_i) + h u'(x_i) + (h^2/2) u''(x_i) + (h^3/6) u'''(ξ1)",
                                    "Expanda u(x_{i-1}) em Taylor: u(x_i - h) = u(x_i) - h u'(x_i) + (h^2/2) u''(x_i) - (h^3/6) u'''(ξ2)",
                                    "Substitua na fórmula centrada para derivada: [u(x_{i+1}) - u(x_{i-1})] / (2h)",
                                    "Simplifique os termos até u'(x_i) + O(h^2)",
                                    "Adapte para stencil de Neumann, incorporando g"
                                  ],
                                  "verification": "Derive a expansão mostrando cancelamento dos termos pares até O(h^2)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou SymPy no Python",
                                    "Grade impressa de pontos",
                                    "Referência de séries de Taylor"
                                  ],
                                  "tips": "Mantenha ξ1 e ξ2 distintos para rigor; foque em truncagem local",
                                  "learningObjective": "Dominar a expansão de Taylor aplicada a diferenças finitas",
                                  "commonMistakes": "Esquecer termos ímpares/paros; errar sinais nas expansões"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Erro de Truncagem Local para Condição de Neumann",
                                  "subSteps": [
                                    "Substitua as expansões na equação de Neumann discretizada",
                                    "Identifique o erro: diferença entre derivada exata e aproximada",
                                    "Mostre que erro = [h^2 / 6] (u'''(ξ1) + u'''(ξ2))/2 ou similar, levando a O(h^2)",
                                    "Confirme ordem de precisão analisando coeficientes de h",
                                    "Escreva a forma final: erro local O(h^2)"
                                  ],
                                  "verification": "Calcule explicitamente o coeficiente do termo h^2 e prove O(h^2)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Mathematica ou papel para álgebra simbólica",
                                    "Exemplos de stencil Neumann"
                                  ],
                                  "tips": "Use notação big-O corretamente; teste com função conhecida como u(x)=sin(x)",
                                  "learningObjective": "Calcular e analisar o erro de truncagem específico O(h^2)",
                                  "commonMistakes": "Confundir erro global com local; ignorar contribuições de ambos os lados"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Analisar a Precisão da Aproximação",
                                  "subSteps": [
                                    "Implemente numericamente com h variando e compute erro",
                                    "Plote log(erro) vs log(h) para confirmar ordem 2",
                                    "Compare com aproximações one-sided (O(h)) para validar superioridade",
                                    "Discuta impactos em esquemas elípticos maiores",
                                    "Resuma limitações do O(h^2) em grids não-uniformes"
                                  ],
                                  "verification": "Gere gráfico ou tabela mostrando convergência O(h^2)",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/MATLAB com NumPy",
                                    "Função teste u(x)=x^3 para derivada conhecida"
                                  ],
                                  "tips": "Use h=0.1, 0.05, 0.025 para boa resolução no log-log plot",
                                  "learningObjective": "Validar analiticamente e numericamente o erro O(h^2)",
                                  "commonMistakes": "Escala errada no plot; poluição numérica em h muito pequeno"
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace ∇²u=0 em [0,1] com Neumann u'(1)=1. Use stencil centrado em x=1-h: [u(1)-u(1-2h)]/(h) ≈1 + O(h^2). Expanda Taylor em 1-h e 1-2h ao redor de 1 para derivar erro = (h^2/3) u'''(ξ)/2.",
                              "finalVerifications": [
                                "Deriva corretamente a expansão de Taylor para stencil Neumann",
                                "Identifica e calcula o termo líder do erro O(h^2)",
                                "Valida numericamente com plot log-log mostrando inclinação -2",
                                "Explica diferença entre erro local e global",
                                "Aplica a um exemplo simples de equação elíptica"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (sem erros algébricos)",
                                "Correta identificação do ordem O(h^2) com coeficiente",
                                "Validação numérica com pelo menos 3 valores de h",
                                "Clareza na explicação do stencil adaptado para Neumann",
                                "Análise de limitações e comparações com outros métodos"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de fluxos com isolamento (Neumann em calor/difusão)",
                                "Programação: Implementação em solvers de PDEs (finite differences)",
                                "Estatística: Análise de erro em aproximações numéricas",
                                "Engenharia: Simulações CFD com condições de fronteira"
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em paredes isoladas (Neumann=0), onde diferenças centradas O(h^2) garantem precisão eficiente em grids grosseiros para previsão de temperaturas em edifícios ou reatores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Aproximação com Diferenças Finitas Unilaterais",
                        "description": "Uso de diferenças finitas unilaterais (forward ou backward) na fronteira para aproximar condições de Neumann, com precisão de primeira ordem, útil quando pontos fantasma não são viáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Derivar stencil unilateral para Neumann",
                            "description": "Formular aproximações como (-3u_1 + 4u_2 - u_3)/(2h) = g para derivada forward de segunda ordem na fronteira esquerda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do Problema e Expansões de Taylor",
                                  "subSteps": [
                                    "Identifique a condição de Neumann na fronteira esquerda: ∂u/∂x |_{x=0} = g, com pontos u₁ = u(0), u₂ = u(h), u₃ = u(2h).",
                                    "Escreva as expansões de Taylor para u₂ e u₃ ao redor de x=0 até ordem suficiente (até h³ para precisão O(h²)).",
                                    "Expresse explicitamente: u₂ = u(0) + h u'(0) + (h²/2) u''(0) + (h³/6) u'''(ξ₁), u₃ = u(0) + 2h u'(0) + 2 h² u''(0) + (4 h³/3) u'''(ξ₂).",
                                    "Verifique os coeficientes fatoriais nos termos de Taylor.",
                                    "Anotar as expansões em uma equação unificada."
                                  ],
                                  "verification": "Expansões de Taylor coincidem com as fórmulas padrão até h³, sem erros nos coeficientes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta, calculadora para fatoriais, livro de análise numérica (opcional).",
                                  "tips": "Comece sempre pela expansão geral de Taylor e aplique os valores específicos de distância (h, 2h).",
                                  "learningObjective": "Dominar o uso de expansões de Taylor para aproximações diferenciais unilaterais.",
                                  "commonMistakes": "Esquecer o fator 1/2 no termo h² ou confundir  (2h)³/6 = 8h³/6 = 4h³/3."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação da Combinação Linear",
                                  "subSteps": [
                                    "Defina a combinação geral S = α u₁ + β u₂ + γ u₃, buscando S / (2h) ≈ u'(0) + O(h²), ou equivalentemente S ≈ 2h u'(0).",
                                    "Substitua as expansões de Taylor em S e colete termos por ordens: termo constante, h u', h² u'', h³ u'''.",
                                    "Estabeleça as condições para precisão de segunda ordem: coeficiente de u(0) = 0, coeficiente de h u'(0) = 2h, coeficiente de h² u''(0) = 0.",
                                    "Escreva o sistema de equações: (1) α + β + γ = 0; (2) β + 2γ = 2; (3) (β/2) + 2γ = 0.",
                                    "Confirme que o termo h³ confirma o erro O(h²)."
                                  ],
                                  "verification": "Sistema de 3 equações com 3 incógnitas montado corretamente, com coeficientes exatos das ordens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado para alinhar termos, lápis para substituições.",
                                  "tips": "Multiplique toda a expansão por 1/h após coletar para normalizar, mas foque em S ≈ 2h u' primeiro.",
                                  "learningObjective": "Aprender a formular condições de precisão para estênceis de diferenças finitas.",
                                  "commonMistakes": "Confundir as ordens: o coeficiente de u' deve ser ajustado para 2h, não h."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolução do Sistema de Equações",
                                  "subSteps": [
                                    "Resolva o sistema linear: da eq. (3) β = -4γ; substitua em (2): -4γ + 2γ = 2 → γ = -1.",
                                    "Encontre β = -4(-1) = 4; então α = -β - γ = -4 - (-1) = -3.",
                                    "Verifique a solução nas três equações originais.",
                                    "Escreva o stencil: [-3 u₁ + 4 u₂ - u₃] / (2h) ≈ u'(0).",
                                    "Substitua de volta nas Taylor para confirmar o erro O(h³)."
                                  ],
                                  "verification": "Coeficientes obtidos: α=-3, β=4, γ=-1, e verificação satisfatória em todas as equações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou software simbólico como Mathematica (opcional), papel para algebra.",
                                  "tips": "Use eliminação gaussiana simples: resolva sequencialmente das equações independentes.",
                                  "learningObjective": "Resolver sistemas lineares derivados de condições de truncamento em métodos numéricos.",
                                  "commonMistakes": "Erro de sinal ao resolver γ: lembre -2γ=2 → γ=-1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação, Aplicação e Análise de Erro",
                                  "subSteps": [
                                    "Aplique o stencil à condição de Neumann: [-3 u₁ + 4 u₂ - u₃] / (2h) = g.",
                                    "Calcule o erro de truncamento: coeficiente de h² u'''(ξ) / 3 ou similar, confirmando O(h²).",
                                    "Teste com função exemplo: u(x)=sin(πx), h=0.1, compute approx vs. exato π cos(0)=π.",
                                    "Discuta generalização para outras fronteiras ou ordens.",
                                    "Registre a fórmula final no contexto de equações elípticas."
                                  ],
                                  "verification": "Fórmula final matches (-3u₁ + 4u₂ - u₃)/(2h) = g, com erro O(h²) demonstrado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora para exemplo numérico, software como Python/MATLAB para plot opcional.",
                                  "tips": "Escolha funções suaves para teste; compare erro numérico com O(h²).",
                                  "learningObjective": "Validar e aplicar o stencil em contextos reais de análise numérica.",
                                  "commonMistakes": "Ignorar o denominador 2h ou erro no exemplo numérico por arredondamento."
                                }
                              ],
                              "practicalExample": "Para u(x) = sin(π x), u'(0) = π ≈ 3.1416. Com h=0.1: u₁=0, u₂=sin(0.1π)≈0.3090, u₃=sin(0.2π)≈0.5878. Aprox: [-3*0 + 4*0.3090 - 0.5878]/(0.2) = (1.236 - 0.5878)/0.2 ≈ 3.192/0.2 ≈ 3.1416 (erro <0.001, consistente com O(h²)=0.01).",
                              "finalVerifications": [
                                "Coeficientes do stencil são exatamente -3, 4, -1.",
                                "Fórmula final: (-3u₁ + 4u₂ - u₃)/(2h) = g.",
                                "Sistema de equações resolvido corretamente sem inconsistências.",
                                "Expansões de Taylor até h³ precisas.",
                                "Erro de truncamento O(h²) explicitado.",
                                "Exemplo prático converge para valor exato ao refinar h."
                              ],
                              "assessmentCriteria": [
                                "Correção das expansões de Taylor (coeficientes fatoriais).",
                                "Montagem precisa do sistema linear (3 condições).",
                                "Resolução algébrica exata dos coeficientes.",
                                "Verificação do erro de truncamento O(h²).",
                                "Aplicação correta à condição de Neumann.",
                                "Teste numérico com exemplo converge adequadamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de fluxos em equações de difusão/poisson (condições de Neumann em calor/eletrostática).",
                                "Computação: Implementação de solvers de diferenças finitas em código (bibliotecas como NumPy/SciPy).",
                                "Engenharia: Simulações CFD com contornos de fluxo prescrito.",
                                "Estatística: Aproximações em métodos Monte Carlo para EDPs."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações elípticas como a de Poisson para problemas de condução de calor com fluxo térmico prescrito (Neumann) na fronteira, ou eletrostática com campo normal dado, permitindo resolver sistemas lineares em grids irregulares nas bordas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1",
                              "10.1.4.5.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Implementar em malha 2D com Neumann misto",
                            "description": "Aplicar diferenças unilaterais em malhas retangulares 2D para condições de Neumann em faces específicas, ajustando o laplaciano discretizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação teórica das condições de Neumann mistas",
                                  "subSteps": [
                                    "Revise a equação elíptica modelo: -Δu = f em domínio Ω retangular.",
                                    "Estude condições de contorno: Dirichlet u=g em ∂Ω_D e Neumann ∂u/∂n = h em ∂Ω_N.",
                                    "Derive a aproximação por diferenças unilaterais para Neumann: (u_{i+1,j} - u_{i,j})/h ≈ ∂u/∂n.",
                                    "Analise o stencil do laplaciano ajustado para faces com Neumann misto.",
                                    "Verifique compatibilidade da condição de Neumann via integral de f."
                                  ],
                                  "verification": "Resuma em um diagrama o stencil modificado para uma face com Neumann.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula de Análise Numérica II",
                                    "Livro de diferenças finitas (ex: LeVeque)",
                                    "Papel e caneta para derivações"
                                  ],
                                  "tips": "Desenhe a malha 2D e marque as faces com tipos de contorno diferentes.",
                                  "learningObjective": "Dominar a discretização teórica do laplaciano com Neumann unilateral.",
                                  "commonMistakes": "Confundir diferenças forward/backward; ignorar fator 1/2 no stencil Neumann."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a malha 2D e definir condições de contorno",
                                  "subSteps": [
                                    "Defina dimensões: nx, ny pontos internos; h_x = Lx/(nx+1), h_y = Ly/(ny+1).",
                                    "Crie arrays u[nx+2][ny+2] para incluir fantasmas.",
                                    "Implemente Dirichlet: u[0][j] = g_left, etc., para faces Dirichlet.",
                                    "Identifique faces Neumann e prepare índices para unilaterais.",
                                    "Gere função f(x,y) e condições g/h analiticamente conhecidas para teste."
                                  ],
                                  "verification": "Imprima malha vazia e contornos aplicados; confira valores nas bordas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python/MATLAB)",
                                    "Bibliotecas: numpy/meshgrid"
                                  ],
                                  "tips": "Use índices 1 a nx para internos; 0 e nx+1 para fantasmas.",
                                  "learningObjective": "Preparar estrutura de dados para malha com contornos mistos.",
                                  "commonMistakes": "Índices off-by-one; h_x != h_y sem ajuste."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o laplaciano discretizado com stencil Neumann",
                                  "subSteps": [
                                    "Codifique stencil interior: (u[i+1,j] + u[i-1,j] + u[i,j+1] + u[i,j-1] - 4u[i,j])/h^2.",
                                    "Para face esquerda Neumann: u[0,j] = u[2,j] - 2h*h_left (diferença unilateral).",
                                    "Ajuste para faces superior/inferior/direita similarmente.",
                                    "Monte matriz A esparsa ou use método iterativo (Gauss-Seidel/Jacobi).",
                                    "Inclua termo fonte b com f e contribuições de contorno."
                                  ],
                                  "verification": "Teste stencil em ponto de fronteira: compute resíduo manualmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com numpy/scipy.sparse",
                                    "Ou MATLAB com spdiags"
                                  ],
                                  "tips": "Implemente fantasmas para Neumann para reutilizar stencil interior.",
                                  "learningObjective": "Codificar corretamente o operador diferencial com contornos mistos.",
                                  "commonMistakes": "Esquecer multiplicar h em aproximação Neumann; stencil assimétrico errado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema e validar a solução",
                                  "subSteps": [
                                    "Aplique iterador até convergência (tol=1e-6, max_iter=10000).",
                                    "Visualize solução com contourf ou surf.",
                                    "Compute norma L2 erro se solução exata disponível.",
                                    "Verifique fluxo Neumann: integral aproximado de ∂u/∂n == integral f.",
                                    "Teste com casos puros (Neumann homogêneo) para compatibilidade."
                                  ],
                                  "verification": "Erro L2 < 1e-3; resíduo máximo < tol; gráfico suave sem artefatos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Solução analítica de referência (ex: u=x^2 + y^2)"
                                  ],
                                  "tips": "Use relaxação over-relaxation (ω=1.8) para aceleração.",
                                  "learningObjective": "Executar e validar implementação numérica completa.",
                                  "commonMistakes": "Não inicializar u=0; tolerância frouxa levando a não-convergência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e refinar a implementação",
                                  "subSteps": [
                                    "Teste refinamento h->h/2: verifique ordem de convergência O(h^2).",
                                    "Profile código para gargalos (ex: loops vs vetorização).",
                                    "Adicione suporte a Neumann não-homogêneo em múltiplas faces.",
                                    "Documente código com comentários sobre stencils.",
                                    "Compare com solver built-in (ex: scipy.solve_poisson)."
                                  ],
                                  "verification": "Tabela de erros vs h mostrando convergência quadrática.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter notebook para experimentos",
                                    "Timer de performance"
                                  ],
                                  "learningObjective": "Avaliar precisão e eficiência da implementação.",
                                  "commonMistakes": "Refinamento sem ajustar iterações; ignorar custo computacional."
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 2π² sin(πx) sin(πy) em [0,1]x[0,1], com u=0 em x=0,1 e y=0; ∂u/∂y = π cos(πy) sin(πx) em y=1. Solução exata: u=sin(πx)sin(πy). Implemente com nx=ny=50, verifique erro L2.",
                              "finalVerifications": [
                                "Código executa sem erros para malha 50x50 em <10s.",
                                "Solução visualmente suave e compatível com contornos.",
                                "Erro L2 < 0.01 para h=1/50.",
                                "Fluxo Neumann integral coincide com ∫f dΩ dentro de 1%.",
                                "Convergência observada ao refinar malha.",
                                "Stencil Neumann produz gradiente correto na face."
                              ],
                              "assessmentCriteria": [
                                "Correção do stencil Neumann (teste unitário passa).",
                                "Precisão numérica (ordem 2 em h).",
                                "Eficiência iterativa (converge em <500 iterações).",
                                "Código legível e modularizado.",
                                "Validação completa com métrica de erro.",
                                "Tratamento robusto de h_x != h_y."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de fluxo de calor com isolamento (Neumann=0).",
                                "Computação: Programação científica com matrices esparsas (SciPy).",
                                "Engenharia: Simulações CFD em domínios retangulares.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Simulação de temperaturas em placas com bordas isoladas (Neumann) e fixas (Dirichlet), usada em design térmico de eletrônicos, previsão meteorológica 2D e processamento de imagens (difusão)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1",
                              "10.1.4.5.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Comparar precisão centrada vs unilateral",
                            "description": "Avaliar ordens de convergência e estabilidade relativa das aproximações centradas (O(h^2)) e unilaterais (O(h)) em testes numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fórmulas teóricas das aproximações centrada e unilateral",
                                  "subSteps": [
                                    "Estude a condição de Neumann para equações elípticas: ∂u/∂n = g na fronteira.",
                                    "Derive a diferença finita centrada O(h²): (u_{i+1} - u_{i-1})/(2h) ≈ ∂u/∂x.",
                                    "Derive a diferença finita unilateral O(h): (-3u_i + 4u_{i+1} - u_{i+2})/(2h) ≈ ∂u/∂x.",
                                    "Compare ordens de truncamento: centrada tem erro O(h²), unilateral O(h).",
                                    "Discuta estabilidade: centrada é simétrica e mais estável em malhas uniformes."
                                  ],
                                  "verification": "Escreva as fórmulas corretas e explique diferenças em um resumo de 1 parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Análise Numérica, papel e caneta ou editor de texto.",
                                  "tips": "Use diagramas de malha para visualizar pontos usados em cada stencil.",
                                  "learningObjective": "Compreender as bases matemáticas e diferenças de precisão teórica.",
                                  "commonMistakes": "Confundir unilateral forward com backward; ignorar coeficientes exatos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar problema modelo numérico simples",
                                  "subSteps": [
                                    "Escolha equação modelo: ∇²u = 0 em [0,1]x[0,1] com u=0 em três lados e ∂u/∂y=sen(πx) em y=1.",
                                    "Defina solução exata: u(x,y) = (y-1)sen(πx) para validar erros.",
                                    "Gere malhas uniformas com h = 1/10, 1/20, 1/40, 1/80.",
                                    "Implemente discretização interior padrão com Laplace em grade 2D.",
                                    "Prepare código base para condições de Dirichlet e Neumann."
                                  ],
                                  "verification": "Codifique o problema e verifique solução exata em pontos internos para h=1/10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, Jupyter Notebook.",
                                  "tips": "Use sparse matrices para eficiência em malhas finas.",
                                  "learningObjective": "Preparar um benchmark reproduzível para testes de convergência.",
                                  "commonMistakes": "Erro na solução exata; malhas não uniformes afetando h."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar aproximações centrada e unilateral",
                                  "subSteps": [
                                    "Modifique stencil de fronteira para Neumann centrada: média de unilaterais ou ghost point.",
                                    "Implemente unilateral forward na fronteira y=1.",
                                    "Resolva sistema linear Ax=b para cada h, usando solver direto ou iterativo.",
                                    "Calcule erro L2: ||u_num - u_exata|| / ||u_exata|| para cada malha.",
                                    "Registre tempos de computação e resíduos para estabilidade."
                                  ],
                                  "verification": "Execute para dois h's e confirme erros decrescem com h.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB do Step 2, solver linear (scipy.sparse.linalg).",
                                  "tips": "Vectorize operações para velocidade; teste com h grosseiro primeiro.",
                                  "learningObjective": "Gerar dados empíricos de precisão e estabilidade.",
                                  "commonMistakes": "Implementação errada do stencil de Neumann; não normalizar erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar ordens de convergência e estabilidade relativa",
                                  "subSteps": [
                                    "Calcule ordem de convergência: log2(err_h / err_{h/2}) ≈ 2 para centrada, 1 para unilateral.",
                                    "Plote log(err) vs log(h) e ajuste retas para confirmar slopes.",
                                    "Compare estabilidade: verifique cond(número de A) e iterações de solver.",
                                    "Avalie trade-offs: precisão vs custo computacional em malhas finas.",
                                    "Documente conclusões em tabela e gráfico."
                                  ],
                                  "verification": "Gere plots mostrando slopes ~2 e ~1; tabela com ordens calculadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib/Plots no código, Excel para tabelas.",
                                  "tips": "Use log-log scale para clareza; inclua barras de erro se ruído.",
                                  "learningObjective": "Interpretar numericamente teoria de convergência e estabilidade.",
                                  "commonMistakes": "Erro aritmético em log2; ignorar efeitos de arredondamento em h pequeno."
                                }
                              ],
                              "practicalExample": "Em simulação de fluxo de calor com fluxo prescrito na fronteira superior (Neumann ∂T/∂y=g(x)), use centrada para precisão em malhas médias e unilateral perto de cantos irregulares; teste em domínio quadrado com g(x)=sin(πx), confirmando erro centrada 4x menor que unilateral para h=1/40.",
                              "finalVerifications": [
                                "Ordens calculadas: centrada ≈2, unilateral ≈1 em pelo menos 3 refinações.",
                                "Plots log-log mostram convergência linear e quadrática clara.",
                                "Erros L2 centrada < 1/4 de unilateral para mesmo h.",
                                "Condição de matriz similar ou melhor para centrada.",
                                "Tempo de solução centrada não excede 2x unilateral.",
                                "Relatório resume trade-offs com evidências numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas derivadas (100% corretas).",
                                "Implementação livre de bugs, converge para solução exata.",
                                "Cálculo correto de ordens (erro <0.2 na estimativa).",
                                "Análise qualitativa de estabilidade com métricas.",
                                "Gráficos e tabelas claros e interpretáveis.",
                                "Conclusões alinhadas com teoria O(h²) vs O(h)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de solvers lineares e visualização (Python/MATLAB).",
                                "Física Computacional: Modelagem de PDEs elípticas em transferência de calor.",
                                "Estatística: Análise de regressão log-log para ordens empíricas.",
                                "Engenharia: Otimização numérica em simulações CFD/FEM."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como análise de tensões em placas com cargas de superfície (Neumann) ou modelagem climática com fluxos de vento na fronteira, centradas reduzem erros em previsões, enquanto unilaterais são usadas em geometrias irregulares para evitar instabilidades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Verificar consistência e estabilidade",
                            "description": "Demonstrar consistência das aproximações para o operador diferencial elíptico e discutir estabilidade via norma matricial do sistema resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulação do problema elíptico com condições de Neumann e stencil unilateral",
                                  "subSteps": [
                                    "Estude a equação diferencial elíptica modelo: -Δu = f em domínio Ω com ∂u/∂n = g na fronteira Neumann Γ.",
                                    "Revise a aproximação por diferenças finitas em grade uniforme h.",
                                    "Derive o stencil unilateral para a derivada normal na fronteira: (u_1 - u_0)/h ≈ ∂u/∂n.",
                                    "Incorpore o stencil no operador Laplaciano discretizado próximo à fronteira.",
                                    "Escreva a equação discreta completa para um ponto de fronteira."
                                  ],
                                  "verification": "Derive corretamente o stencil unilateral e aplique-o a um exemplo simples em 1D.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Papel quadriculado",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Visualize a grade e marque pontos fantasmas para Neumann.",
                                  "learningObjective": "Compreender a discretização específica para condições de Neumann usando diferenças finitas unilaterais.",
                                  "commonMistakes": "Usar stencil central na fronteira, ignorando a unilateriedade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar consistência da aproximação",
                                  "subSteps": [
                                    "Expanda em série de Taylor os termos discretos do operador diferencial.",
                                    "Calcule o erro de truncamento local (LTE) para o Laplaciano interior e stencil unilateral na fronteira.",
                                    "Mostre que o LTE é O(h²) uniformemente, confirmando consistência de segunda ordem.",
                                    "Analise o erro global via norma L² ou máximo.",
                                    "Compare com aproximações para Dirichlet para destacar diferenças."
                                  ],
                                  "verification": "Calcule o LTE e prove que tende a zero com h → 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Referência teórica sobre erros de truncamento",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Use expansão de Taylor até ordem h³ para capturar termos pares/impares.",
                                  "learningObjective": "Demonstrar que a discretização converge para o operador diferencial contínuo.",
                                  "commonMistakes": "Esquecer termos de ordem superior no stencil unilateral."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e analisar o sistema matricial resultante",
                                  "subSteps": [
                                    "Monte a matriz A do sistema Au = b para uma grade 1D ou 2D simples (ex: N=5 pontos).",
                                    "Identifique a estrutura tridiagonal ou pentadiagonal modificada pela fronteira Neumann.",
                                    "Inclua o termo de fronteira no vetor b: b_0 += g * h/2.",
                                    "Verifique simetria e propriedade positiva definida da matriz.",
                                    "Calcule condicionado da matriz cond(A) = ||A|| * ||A⁻¹||."
                                  ],
                                  "verification": "Construa A explicitamente para N=4 e resolva um sistema teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/MATLAB para montar matriz",
                                    "Exemplos numéricos de livros"
                                  ],
                                  "tips": "Comece em 1D para simplicidade antes de 2D.",
                                  "learningObjective": "Construir o sistema linear decorrente da discretização.",
                                  "commonMistakes": "Erro no tratamento do termo de Neumann no vetor b."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir estabilidade via norma matricial",
                                  "subSteps": [
                                    "Defina normas matriciais relevantes: ||A||₂, ||A||∞, ||A||₁.",
                                    "Estime ||A|| para o operador discretizado, mostrando independência ou crescimento controlado com 1/h².",
                                    "Analise ||A⁻¹|| via autovalores ou Gershgorin para provar estabilidade.",
                                    "Verifique critério de Lax: consistência + estabilidade implica convergência.",
                                    "Simule numericamente ||A|| para grades refinadas e plote."
                                  ],
                                  "verification": "Calcule ||A||∞ para uma matriz exemplo e discuta boundedness.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software NumPy/SciPy",
                                    "Documentação de normas matriciais"
                                  ],
                                  "tips": "Use teorema de Gershgorin para estimativas rápidas de autovalores.",
                                  "learningObjective": "Avaliar estabilidade do método através de normas do sistema discretizado.",
                                  "commonMistakes": "Confundir norma da matriz com norma do erro."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar consistência e estabilidade em análise completa",
                                  "subSteps": [
                                    "Resuma condições para consistência e estabilidade no contexto elíptico.",
                                    "Discuta impacto de h pequeno na estabilidade prática (condicionado).",
                                    "Compare com métodos alternativos como elementos finitos.",
                                    "Aplique a um exemplo numérico completo e verifique convergência.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo prova de convergência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de simulação pronto",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Sempre relacione de volta ao teorema de convergência.",
                                  "learningObjective": "Sintetizar análise para validar o método numérico.",
                                  "commonMistakes": "Ignorar dependência em h para estabilidade condicional."
                                }
                              ],
                              "practicalExample": "Considere -u''(x) = π² sin(πx) em (0,1) com u'(0)=0 (Neumann homogêneo) e u(1)=0. Use diferenças finitas unilaterais em x_i = i h, h=1/N. Monte A, resolva Au=b, calcule erro ||u_h - u||∞ e verifique consistência (erro O(h²)) e ||A||₂ ≈ π² independente de h.",
                              "finalVerifications": [
                                "Derivação correta do stencil unilateral com LTE O(h²).",
                                "Montagem precisa da matriz A para grade 1D/2D.",
                                "Cálculo de ||A||∞ ou ||A||₂ com estimativa teórica.",
                                "Prova qualitativa de estabilidade (||A|| bounded).",
                                "Simulação numérica mostrando convergência com refinamento h.",
                                "Discussão de condicionado e implicações práticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas expansões de Taylor e LTE.",
                                "Correção na montagem e análise da matriz A.",
                                "Adequação das estimativas de normas matriciais.",
                                "Clareza na ligação entre consistência, estabilidade e convergência.",
                                "Qualidade da simulação numérica e interpretação de resultados.",
                                "Profundidade na discussão de limitações e alternativas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de EDPs elípticas em eletromagnetismo e mecânica dos fluidos.",
                                "Computação: Implementação de solvers lineares (ex: GMRES) em Python/MATLAB.",
                                "Engenharia: Análise de estabilidade em simulações CFD com fronteiras isolantes.",
                                "Estatística: Análise de erros numéricos e validação de modelos."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em materiais isolados (condições Neumann ∂T/∂n=0), verificar consistência garante precisão aproximada da solução física, enquanto análise de ||A|| assegura estabilidade computacional para grades finas, evitando amplificação de erros de arredondamento em prévisões industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.6",
                    "name": "Convergência e Estabilidade para Problemas Elípticos",
                    "description": "Análise de consistência, convergência e estabilidade dos métodos de diferenças finitas em equações elípticas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.6.1",
                        "name": "Consistência dos Métodos de Diferenças Finitas",
                        "description": "Análise da consistência, que mede o quão bem a discretização aproxima a equação elíptica diferencial original, incluindo erros de truncagem local e global para problemas elípticos com condições de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.1.1",
                            "name": "Definir consistência e erro de truncagem",
                            "description": "Explicar a definição de consistência para métodos de diferenças finitas em equações elípticas, calcular o erro de truncagem local para a equação de Laplace usando esquema de 5 pontos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação de Laplace e o esquema de 5 pontos",
                                  "subSteps": [
                                    "Estudar a equação diferencial elíptica de Laplace: ∇²u = 0 em domínio Ω.",
                                    "Aprender a discretização em grade uniforme 2D com passo h.",
                                    "Derivar o esquema de diferenças finitas de 5 pontos: (4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1})/h² ≈ ∇²u.",
                                    "Visualizar a estêncil (template) dos 5 pontos na grade.",
                                    "Resolver um exemplo simples com condições de contorno Dirichlet."
                                  ],
                                  "verification": "Reescrever corretamente o esquema de 5 pontos e aplicar em um ponto interno da grade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Desenhe a grade para visualizar os vizinhos; lembre que o esquema é centrado e simétrico."
                                  ],
                                  "learningObjective": "Dominar a formulação do problema modelo e sua aproximação numérica básica.",
                                  "commonMistakes": [
                                    "Confundir o esquema de 5 pontos com o de 9 pontos.",
                                    "Esquecer de dividir por h² na aproximação do laplaciano.",
                                    "Ignorar condições de contorno ao testar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o conceito de consistência em métodos de diferenças finitas",
                                  "subSteps": [
                                    "Recordar os três pilares da convergência: consistência, estabilidade e unicidade.",
                                    "Definir consistência: Um método é consistente se ||L_h u - L u|| → 0 quando h → 0, para u solução exata suave.",
                                    "Explicar que consistência garante que a discretização aproxime a EDP contínua.",
                                    "Discutir a relação com o erro de truncagem: consistência é equivalente a erro de truncagem local tendendo a zero.",
                                    "Comparar com métodos inconsistentes (ex: esquemas com coeficientes errados)."
                                  ],
                                  "verification": "Escrever a definição formal de consistência e dar um contraexemplo de método inconsistente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica II",
                                    "Quadro branco ou papel"
                                  ],
                                  "tips": [
                                    "Use notação L_h para operador discreto e L para contínuo; foque em soluções suaves C⁴."
                                  ],
                                  "learningObjective": "Entender e articular a definição precisa de consistência.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade.",
                                    "Pensar que consistência basta para convergência.",
                                    "Omitir a condição de suavidade da solução exata."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir e calcular o erro de truncagem local",
                                  "subSteps": [
                                    "Definir erro de truncagem local τ_h(x): L_h u(x) - L u(x) = τ_h(x), onde u é solução exata.",
                                    "Explicar que para consistência, max |τ_h| → 0 com h → 0.",
                                    "Usar expansão de Taylor ao redor de (x_i, y_j) para cada termo do laplaciano.",
                                    "Calcular os termos de segunda ordem que cancelam e mostrar O(h²) nos termos de quarta ordem.",
                                    "Escrever explicitamente τ_h = (u_{xxxx} + 2u_{xxyy} + u_{yyyy})/12 * h² + O(h⁴)."
                                  ],
                                  "verification": "Derivar os primeiros termos da expansão de Taylor para um termo genérico u(x+h,y).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como Mathematica/Maple",
                                    "Folha para derivadas parciais"
                                  ],
                                  "tips": [
                                    "Aplique Taylor separadamente em x e y; some e subtraia para laplaciano; coeficientes simétricos facilitam."
                                  ],
                                  "learningObjective": "Calcular analiticamente o erro de truncagem local usando séries de Taylor.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes de Taylor (ex: esquecer 1/2! ou 1/4!).",
                                    "Não cancelar termos de primeira e terceira ordem.",
                                    "Confundir derivadas mistas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar ao esquema de 5 pontos na equação de Laplace e verificar consistência",
                                  "subSteps": [
                                    "Substituir ∇²u = 0 na definição de τ_h para o esquema.",
                                    "Mostrar que L_h u = τ_h com ||τ_h||_∞ = O(h²) para u ∈ C⁴.",
                                    "Concluir que o método é consistente de ordem 2.",
                                    "Discutir implicações para convergência (com estabilidade).",
                                    "Testar numericamente em um problema simples para validar O(h²)."
                                  ],
                                  "verification": "Calcular τ_h explicitamente para u(x,y) = x² - y² e mostrar O(h²).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy para teste numérico opcional",
                                    "Exemplos resolvidos do livro"
                                  ],
                                  "tips": [
                                    "Escolha funções harmônicas (∇²u=0) para testar; reduza h e observe erro."
                                  ],
                                  "learningObjective": "Verificar consistência específica para o esquema de Laplace.",
                                  "commonMistakes": [
                                    "Usar função não harmônica no teste.",
                                    "Ignorar que ordem é local e uniforme em malha uniforme.",
                                    "Confundir erro local com global."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e explorar implicações",
                                  "subSteps": [
                                    "Resumir: Consistência ⇔ τ_h → 0; aqui ordem 2.",
                                    "Relacionar com teorema de Lax-Richtmyer.",
                                    "Discutir melhorias (esquemas de ordem superior).",
                                    "Aplicar em contexto elíptico: convergência em norma máximo.",
                                    "Preparar exercícios de consolidação."
                                  ],
                                  "verification": "Explicar verbalmente por que o esquema é consistente e sua ordem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resumo em uma página"
                                  ],
                                  "tips": [
                                    "Ligue à aula anterior sobre estabilidade; consistência é necessária mas não suficiente."
                                  ],
                                  "learningObjective": "Integrar conceitos e preparar para análise completa de convergência.",
                                  "commonMistakes": [
                                    "Superestimar ordem sem cálculo.",
                                    "Omitir suavidade C⁴ necessária para O(h²)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de Laplace ∇²u=0 em [0,1]² com u=sin(πx)sinh(πy)/sinh(π) nas bordas. Com h=0.2, aplique esquema 5 pontos no centro (0.5,0.5): calcule u exata ≈0, L_h u ≈0 + τ_h, derive τ_h via Taylor mostrando O(0.04).",
                              "finalVerifications": [
                                "Definir corretamente consistência usando norma do operador discreto.",
                                "Calcular τ_h para esquema de 5 pontos mostrando O(h²).",
                                "Explicar papel da suavidade C⁴ na estimativa de erro.",
                                "Verificar consistência para equação de Laplace.",
                                "Dar exemplo numérico simples com redução de h.",
                                "Relacionar com convergência global."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de consistência (20%).",
                                "Correção no cálculo de Taylor e τ_h (30%).",
                                "Clareza na derivação do erro O(h²) (20%).",
                                "Aplicação correta ao exemplo de Laplace (15%).",
                                "Identificação de erros comuns e tips (10%).",
                                "Síntese de implicações para convergência (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potenciais eletrostáticos e fluxo incompressível.",
                                "Computação: Implementação de solvers iterativos (Gauss-Seidel) em Python/MATLAB.",
                                "Engenharia: Simulações de tensão em placas e difusão térmica.",
                                "Estatística: Análise de erros em métodos numéricos probabilísticos."
                              ],
                              "realWorldApplication": "Em simulações CFD para previsão meteorológica, análise de tensões em estruturas aeronáuticas e modelagem de campos magnéticos em aceleradores de partículas, onde esquemas consistentes garantem precisão com malhas grossas economicamente viáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.1.2",
                            "name": "Verificar consistência em condições de Dirichlet",
                            "description": "Demonstrar a consistência de ordem 2 para o problema de Dirichlet em domínio retangular usando diferenças finitas centradas, incluindo análise assintótica do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Problema de Dirichlet e a Malha no Domínio Retangular",
                                  "subSteps": [
                                    "Defina o problema elíptico: -Δu = f em Ω = [0,1]×[0,1], com u = g na ∂Ω.",
                                    "Escolha uma solução exata suave u* para teste, como u*(x,y) = sin(πx)sin(πy), e compute f = -Δu*.",
                                    "Crie uma malha uniforme com passo h = 1/N, pontos (x_i, y_j) = (ih, jh), i,j=0..N.",
                                    "Identifique pontos internos (i,j=1..N-1) e fronteira (i=0 ou N ou j=0 ou N).",
                                    "Esboce o stencil de vizinhança para um ponto interno."
                                  ],
                                  "verification": "Verifique se a malha cobre Ω corretamente e se u* satisfaz as condições de Dirichlet com g = u*|∂Ω.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/Python para plotar malha",
                                    "Referência: Livro de Análise Numérica (ex: LeVeque)"
                                  ],
                                  "tips": "Use uma solução exata analítica para facilitar verificações posteriores.",
                                  "learningObjective": "Entender a formulação precisa do problema e discretização espacial.",
                                  "commonMistakes": [
                                    "Confundir condições de Dirichlet com Neumann",
                                    "Escolher h não uniforme",
                                    "Ignorar suavidade de u para expansão de Taylor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Esquema de Diferenças Finitas Centradas",
                                  "subSteps": [
                                    "Para pontos internos, aproxime Δu(x_i,y_j) ≈ [u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}]/h² = f_{i,j}.",
                                    "Na fronteira, imponha u_{0,j} = g(0,y_j), u_{N,j} = g(1,y_j), etc., usando interpolação se necessário.",
                                    "Escreva o operador discreto L_h u_h = f_h.",
                                    "Confirme que o esquema é simétrico e consistente com o operador Laplace.",
                                    "Implemente uma matriz esparsa A para o sistema Au = f (opcional para visualização)."
                                  ],
                                  "verification": "Teste o stencil em um ponto interno com u constante (deve dar 0) e linear (exata).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Python/MATLAB com NumPy/SciPy para stencil",
                                    "Folha com stencil 5-pontos"
                                  ],
                                  "tips": "Lembre-se: diferenças centradas dão precisão O(h²) para segundas derivadas.",
                                  "learningObjective": "Formular o método de diferenças finitas de segunda ordem para equações elípticas.",
                                  "commonMistakes": [
                                    "Usar diferenças forward/backward internamente (perde ordem)",
                                    "Esquecer fator 1/h²",
                                    "Não tratar cantos da fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Erro de Truncagem Local via Expansão de Taylor",
                                  "subSteps": [
                                    "Aplique expansão de Taylor em torno de (x,y): u(x±h,y) = u ± h u_x + (h²/2)u_xx ± ..., similar para y.",
                                    "Some as expansões para o stencil: mostre que L_h u = Δu + (h²/12)(u_xxxx + 2u_xxyy + u_yyyy) + O(h⁴).",
                                    "Conclua que τ_h = L_h u - f = O(h²) para u suave (quarta derivada limitada).",
                                    "Verifique para solução exata u*: compute τ_h numericamente em malhas finas.",
                                    "Discuta condições de suavidade necessárias (u ∈ C⁴(Ω̄))."
                                  ],
                                  "verification": "Coeficiente de h² deve ser (1/12)Δ²u; plote ||τ_h||_∞ vs h² (reta unitária).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Cálculo simbólico (SymPy) ou lápis para Taylor",
                                    "Código para computar τ_h"
                                  ],
                                  "tips": "Mantenha termos até O(h²); resíduo é O(h⁴) mas ordem é 2.",
                                  "learningObjective": "Demonstrar consistência local de ordem 2 através de análise assintótica.",
                                  "commonMistakes": [
                                    "Parar em O(h) (primeira ordem)",
                                    "Erros de sinal em Taylor",
                                    "Ignorar termos mistos u_xxyy"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Consistência Global e Fronteira",
                                  "subSteps": [
                                    "Mostre que próximo à fronteira, usando interpolação bilinear ou one-sided, erro ainda O(h²).",
                                    "Defina norma discreta ||τ_h||_{h,∞} = max |τ_{i,j}|.",
                                    "Prove ||L_h u - P_h f|| = O(h²) uniformemente, onde P_h é interpolação de f.",
                                    "Para Dirichlet, consistência implica max-norma do erro de truncagem →0 quando h→0.",
                                    "Conclua consistência: lim_{h→0} sup ||L_h u_h - P_h L u|| / ||u|| = 0, com ordem 2."
                                  ],
                                  "verification": "Simule com u* e cheque log-log plot de erro vs h (inclinação 2).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Código numérico para erro global",
                                    "Teorema de consistência de Lax-Richtmyer"
                                  ],
                                  "tips": "Foco em pontos próximos à fronteira; use ghost points se ajudar.",
                                  "learningObjective": "Integrar análise local e global para provar consistência de ordem 2.",
                                  "commonMistakes": [
                                    "Assumir ordem 2 na fronteira sem prova",
                                    "Confundir consistência com convergência",
                                    "Não normalizar por h"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Numericamente e Sintetizar Resultados",
                                  "subSteps": [
                                    "Implemente solver (Gauss-Seidel ou cg) para diferentes h=1/10,1/20,...",
                                    "Compute solução u_h e erro e_h = |u_h - I_h u*|.",
                                    "Plote ||e_h||_∞ vs h²; confirme ordem 2 assintótica.",
                                    "Analise resíduo global R_h = ||L_h u_h - f_h||.",
                                    "Documente relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Inclinação de log||e|| vs log h ≈2 para h pequeno.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python com Matplotlib e SciPy.sparse.linalg",
                                    "Solução exata u*"
                                  ],
                                  "tips": "Use malhas até h=1/100 para assíntotica clara.",
                                  "learningObjective": "Validar teoricamente por experimentos numéricos.",
                                  "commonMistakes": [
                                    "Solver não convergente",
                                    "Erro de interpolação I_h",
                                    "Plots sem log-escala"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 2π² sin(πx)sin(πy) em [0,1]² com u=0 na fronteira (u*=sin(πx)sin(πy)). Use diferenças centradas com h=1/20, compute truncagem τ_h em pontos internos e compare com O(h²)=0.0025. Verifique ordem plotando erros.",
                              "finalVerifications": [
                                "Expansão de Taylor mostra τ_h = O(h²) com coeficiente explícito.",
                                "Simulação numérica confirma ||τ_h||_∞ ∼ C h².",
                                "Tratamento de fronteira preserva ordem 2.",
                                "Solução u_h converge com ordem 2 para u*.",
                                "Relatório inclui provas, código e gráficos.",
                                "Condições de suavidade C⁴ discutidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (pontos completos).",
                                "Correção do stencil e imposição de Dirichlet.",
                                "Análise assintótica rigorosa (O(h²)).",
                                "Validação numérica com plots log-log.",
                                "Clareza no tratamento de fronteira.",
                                "Síntese de consistência global."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potencial eletrostático (equação de Poisson).",
                                "Computação: Programação científica e álgebra linear esparsa.",
                                "Engenharia: Simulação de fluxo de calor em placas retangulares.",
                                "Estatística: Análise de erro em métodos numéricos Monte Carlo."
                              ],
                              "realWorldApplication": "Verificação de precisão em simulações CFD para perfis de temperatura em painéis solares ou campos magnéticos em dispositivos eletrônicos, garantindo que aproximações numéricas sejam confiáveis para otimização de designs industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.1.3",
                            "name": "Analisar consistência para condições de Neumann",
                            "description": "Avaliar a consistência do esquema de diferenças finitas para condições de Neumann em equações elípticas, considerando aproximações de derivadas de contorno e ordem de precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição de Consistência e Condições de Neumann em Equações Elípticas",
                                  "subSteps": [
                                    "Lembre a definição de consistência: o esquema converge para a PDE quando h → 0 se o erro de truncamento local (LTE) → 0.",
                                    "Descreva condições de Neumann: ∂u/∂n = g no contorno Γ, onde n é o normal exterior.",
                                    "Estude o problema modelo: -Δu = f em Ω, com ∂u/∂n = g em ∂Ω.",
                                    "Identifique desafios: aproximações de derivadas de primeira ordem no contorno afetam a precisão.",
                                    "Compare com Dirichlet: Neumann requer stencil assimétrico."
                                  ],
                                  "verification": "Explique em suas palavras por que consistência é crucial para convergência e liste 3 diferenças entre Neumann e Dirichlet.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula sobre elípticas.",
                                  "tips": "Use diagramas de domínio Ω para visualizar contorno.",
                                  "learningObjective": "Compreender os fundamentos teóricos de consistência e peculiaridades de Neumann.",
                                  "commonMistakes": "Confundir consistência com estabilidade; ignorar que Neumann é não-local em alguns sentidos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Esquema de Diferenças Finitas no Interior do Domínio",
                                  "subSteps": [
                                    "Discretize Ω com malha uniforme h x h.",
                                    "Aplique stencil padrão de Laplace: δ²u_{i,j} / h² ≈ Δu.",
                                    "Calcule LTE interior: O(h²) para stencil central de segunda ordem.",
                                    "Verifique consistência interior: LTE → 0 quando h → 0.",
                                    "Escreva a equação discreta: - (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}) / h² = f_{i,j}."
                                  ],
                                  "verification": "Derive o LTE para um ponto interior e confirme ordem O(h²).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, software como MATLAB para stencil visual.",
                                  "tips": "Taylor expanda u em torno do ponto para obter LTE.",
                                  "learningObjective": "Dominar discretização interior e seu LTE.",
                                  "commonMistakes": "Esquecer fator 1/h² no stencil; usar forward/backward no interior."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximar Condições de Neumann no Contorno",
                                  "subSteps": [
                                    "Para contorno esquerdo (x=0), ∂u/∂x ≈ (u_{1,j} - u_{0,j}) / h = g_{0,j} (forward difference).",
                                    "Introduza nó fantasma u_{-1,j} = u_{1,j} - 2h g_{0,j}.",
                                    "Substitua no stencil interior adjacente: combine equações.",
                                    "Calcule LTE no contorno: forward difference tem O(h), reduzindo precisão global para O(h).",
                                    "Discuta opções: diferenças centradas com pontos fora (ex: (u_{1,j} - u_{-1,j})/(2h), mas ajusta fantasma)."
                                  ],
                                  "verification": "Escreva stencil modificado no contorno e seu LTE.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exemplos de livros (ex: Gustafsson), Python/MATLAB para testar stencil.",
                                  "tips": "Desenhe stencil com fantasma para visualização.",
                                  "learningObjective": "Implementar e analisar aproximação de Neumann.",
                                  "commonMistakes": "Usar central sem fantasma; ignorar impacto no LTE global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Erro de Truncamento Global e Ordem de Precisão",
                                  "subSteps": [
                                    "Some LTEs: interior O(h²), contorno O(h), global O(h) por propagação.",
                                    "Use expansão de Taylor completa para provar redução de ordem.",
                                    "Verifique consistência: ainda LTE → 0 (h→0), mas taxa mais lenta.",
                                    "Discuta melhorias: diferenças de ordem superior ou elementos finitos.",
                                    "Conclua: esquema é consistente de ordem 1 para Neumann homogêneo."
                                  ],
                                  "verification": "Prove que max |LTE| = O(h) e →0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (SymPy), referências teóricas.",
                                  "tips": "Foque em termos líderes do erro.",
                                  "learningObjective": "Avaliar consistência completa do esquema.",
                                  "commonMistakes": "Afirmar O(h²) global; negligenciar contorno."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Exemplo Numérico Simples",
                                  "subSteps": [
                                    "Resolva -u'' = 0 em [0,1] com u'(0)=0, u'(1)=0 (solução u=const).",
                                    "Implemente esquema FD com h=1/N.",
                                    "Calcule erro numérico vs solução exata.",
                                    "Observe convergência O(h) plotando log(erro) vs log(h).",
                                    "Compare com Dirichlet para contraste."
                                  ],
                                  "verification": "Gere plot de convergência confirmando ordem 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy, Matplotlib), Jupyter notebook.",
                                  "tips": "Use solução exata u=1 para simplicidade.",
                                  "learningObjective": "Confirmar análise teórica numericamente.",
                                  "commonMistakes": "Erro de programação no contorno; escala errada no log-log."
                                }
                              ],
                              "practicalExample": "Considere -Δu = 0 em quadrado unitário com ∂u/∂n = 0 em todos os lados (Neumann homogêneo). Solução exata u=1. Implemente FD com stencil fantasma: no contorno esquerdo, u_{-1,j} = u_{1,j}. Resolva sistema linear e meça ||u_h - 1||_∞ ~ O(h).",
                              "finalVerifications": [
                                "Derivar LTE no contorno mostrando O(h).",
                                "Explicar por que ordem global cai para 1.",
                                "Implementar código que converge com taxa 1.",
                                "Comparar stencil Neumann vs Dirichlet.",
                                "Identificar quando usar diferenças de ordem superior.",
                                "Discutir impacto em estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de LTE (ordem correta).",
                                "Correta implementação de stencil de contorno.",
                                "Análise qualitativa/quantitativa de consistência.",
                                "Identificação de erros comuns e soluções.",
                                "Conexão com convergência via Lax-Richtmyer.",
                                "Clareza em exemplos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Fluxo de calor/neutrons com isolamento (Neumann=0).",
                                "Engenharia: Simulações CFD com condições de não-slip.",
                                "Programação: Implementação de solvers lineares (SciPy).",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações de campos eletromagnéticos (Maxwell com condições de contorno perfeitas), análise de tensão em estruturas (equações elípticas com Neumann para superfícies livres), ou modelagem climática de oceanos com fluxo prescrito nas costas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.6.2",
                        "name": "Estabilidade dos Esquemas Numéricos",
                        "description": "Estudo da estabilidade, essencial para garantir que erros de arredondamento e iterações não amplifiquem, com foco no princípio do máximo discreto para problemas elípticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.2.1",
                            "name": "Princípio do máximo discreto",
                            "description": "Provar o princípio do máximo para soluções de diferenças finitas em equações elípticas uniformemente elípticas, relacionando à estabilidade em norma infinito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Princípio do Máximo Contínuo para Equações Elípticas",
                                  "subSteps": [
                                    "Estude a definição de equações elípticas uniformemente elípticas: operadores L(u) = -∑ a_{ij} ∂²u/∂x_i ∂x_j + ∑ b_i ∂u/∂x_i + c u = f, com matriz A positiva definida.",
                                    "Lembre o Princípio do Máximo Contínuo: para soluções u de L(u)=0 em Ω, com u≤M na fronteira, então u≤M em Ω.",
                                    "Analise a prova por contradição: suponha máximo interior em x0, então Hessiana negativa, contradiz elipticidade.",
                                    "Discuta extensões para f≥0 e relação com norma infinito.",
                                    "Anote condições uniformemente elípticas: λ|ξ|² ≤ ∑ a_{ij} ξ_i ξ_j ≤ Λ|ξ|²."
                                  ],
                                  "verification": "Escreva um resumo de 1 página do princípio contínuo e verifique se cita corretamente as condições elípticas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque ou Evans PDE), caderno, calculadora simbólica opcional.",
                                  "tips": "Desenhe diagramas de domínios Ω e pontos de máximo para visualizar.",
                                  "learningObjective": "Compreender a base teórica contínua para analogia discreta.",
                                  "commonMistakes": "Confundir elípticas com parabólicas; ignorar termo de ordem zero c≥0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Esquema de Diferenças Finitas Discretas",
                                  "subSteps": [
                                    "Defina a grade uniforme Ω_h em Ω com h=1/N, pontos (x_i,y_j).",
                                    "Aproximação discreta: L_h u_h(i,j) = ∑ α_{k,l} u_{i+k,j+l} / h² + termos de primeira ordem + c u_{i,j} = f_{i,j}.",
                                    "Especifique stencil para 2D: para Laplace, (4u_{i,j} - u_{i+1,j} - ...)/h²; generalize para uniformemente elíptico.",
                                    "Defina condições de contorno Dirichlet: u_h = g na ∂Ω_h.",
                                    "Verifique consistência: L_h φ → L φ quando h→0 para funções suaves φ.",
                                    "Introduza norma discreta ||u_h||_∞ = max |u_h(i,j)|."
                                  ],
                                  "verification": "Implemente stencil em papel para grade 3x3 e compute L_h para função teste u=x²+y².",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, livro de diferenças finitas, software como MATLAB/Python para stencil opcional.",
                                  "tips": "Use soma dos coeficientes do stencil =0 para homogeneidade.",
                                  "learningObjective": "Dominar a discretização precisa para elípticas uniformes.",
                                  "commonMistakes": "Erros em coeficientes do stencil; esquecer normalização por h²."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar o Princípio do Máximo Discreto por Contradição",
                                  "subSteps": [
                                    "Assuma por contradição: existe ponto interior (i,j)∈Ω_h com u_h(i,j) = M = max_Ω_h u_h > max_∂Ω_h g.",
                                    "No máximo discreto, vizinhos u_{k,l} ≤ M, com igualdade só se constantes.",
                                    "Some o stencil: L_h u_h(i,j) ≥0 pois coeficientes positivos pela elipticidade uniforme (soma= c≥0).",
                                    "Mas L_h u_h = f_{i,j} ≤ ||f||_∞; ajuste para caso f=0 primeiro.",
                                    "Generalize: considere v = u_h - ||g||_∞ - C||f||_∞ h², prove max v≤0.",
                                    "Conclua ||u_h||_∞ ≤ ||g||_∞ + C h² ||f||_∞."
                                  ],
                                  "verification": "Escreva a prova completa em LaTeX ou mão, verifique cada desigualdade.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Caderno para rascunhos, referências teóricas (ex: teorema 3.1 em Brenner-Scott).",
                                  "tips": "Normalize h=1 sem perda de generalidade inicialmente.",
                                  "learningObjective": "Executar prova rigorosa do máximo discreto.",
                                  "commonMistakes": "Assumir stencil simétrico sem uniformidade; falhar em termo de fronteira."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar ao Estabilidade em Norma Infinito",
                                  "subSteps": [
                                    "Defina estabilidade: ||u_h||_∞ ≤ K (||g||_∞ + ||f||_∞), com K independente de h.",
                                    "Mostre que princípio máximo discreto implica estabilidade ||u_h||_∞ ≤ ||g||_∞ + C||f||_∞.",
                                    "Discuta C explícito via diâmetro de Ω ou condições elípticas.",
                                    "Compare com norma L²: máximo dá controle forte em ∞-norma.",
                                    "Exemplo numérico: resolva -Δu=1 em quadrado unitário, verifique overshoot zero.",
                                    "Conclua implicações para erro a priori."
                                  ],
                                  "verification": "Compute numericamente em grade pequena e confirme ||u_h||_∞ ≤ bound.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB para resolver sistema linear pequeno, papel.",
                                  "tips": "Use sparse solver para eficiência.",
                                  "learningObjective": "Conectar princípio à estabilidade prática.",
                                  "commonMistakes": "Confundir estabilidade com convergência; ignorar dependência h em C."
                                }
                              ],
                              "practicalExample": "Considere -Δu = 1 em Ω=[0,1]² com u=0 na fronteira. Discretize com h=1/4 (5x5 pontos). Resolva sistema Lu_h=f_h, verifique max u_h ≈0.0625 ≤ max g + C h² max f = 0 + (1/8) (1/16)*1=0.0078? Ajuste C=1/(2π²)≈0.05, max≈0.058<0.05+0.0625.",
                              "finalVerifications": [
                                "Prova escrita reproduz princípio exato para caso homogêneo.",
                                "Exemplo numérico confirma ausência de overshoot.",
                                "Estabilidade quantificada com C explícito.",
                                "Generalização para elípticas não-Laplace verificada.",
                                "Conexão com norma ∞ clara em parágrafo final.",
                                "Nenhum erro em stencil ou suposições."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da prova (peso 40%).",
                                "Clareza e organização dos steps (20%).",
                                "Precisão na discretização e condições elípticas (15%).",
                                "Exemplo prático executado corretamente (15%).",
                                "Conexão explícita com estabilidade (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Potenciais eletrostáticos sem oscilações espúrias.",
                                "Engenharia: Simulações de fluxo incompressível (elíptico).",
                                "Ciência da Computação: Análise de erros em solvers iterativos.",
                                "Finanças: Modelos de Black-Scholes discretos estáveis."
                              ],
                              "realWorldApplication": "Em simulações CFD para aerodinâmica, garante soluções numéricas sem overshoots artificiais em campos de pressão, essencial para precisão em projetos de aviões; também em image processing para filtros elípticos estáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.2.2",
                            "name": "Estabilidade em condições de Dirichlet",
                            "description": "Analisar a estabilidade do esquema padrão de 5 pontos para o problema de Poisson com condições de Dirichlet homogêneas, usando normas adequadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão do Problema de Poisson e do Esquema de 5 Pontos",
                                  "subSteps": [
                                    "Recordar a formulação matemática do problema de Poisson: -Δu = f em domínio Ω com condições de Dirichlet homogêneas u = 0 em ∂Ω.",
                                    "Descrever o esquema de diferenças finitas de 5 pontos para o Laplaciano em grade uniforme 2D.",
                                    "Derivar o operador discreto L_h u_h(i,j) = (u_h(i+1,j) + u_h(i-1,j) + u_h(i,j+1) + u_h(i,j-1) - 4 u_h(i,j))/h².",
                                    "Implementar L_h em uma grade pequena (ex: 3x3) e verificar para função conhecida.",
                                    "Explicar o impacto das condições de Dirichlet homogêneas na fronteira."
                                  ],
                                  "verification": "Escrever corretamente o stencil de 5 pontos e montar a matriz tridiagonal para 1D equivalente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: LeVeque)",
                                    "Papel quadriculado",
                                    "Python/MATLAB para grade 5x5"
                                  ],
                                  "tips": "Desenhe a grade 2D para visualizar os vizinhos e evite erros de indexação.",
                                  "learningObjective": "Compreender a discretização do operador Laplaciano e sua relação com condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir o sinal do Laplaciano discreto.",
                                    "Ignorar o fator h² na definição de L_h.",
                                    "Aplicar stencil incorreto na fronteira."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição de Normas Discretas Adequadas",
                                  "subSteps": [
                                    "Definir a norma L² discreta: ||u_h||_{L²,h} = (h² Σ u_h(i,j)²)^{1/2}.",
                                    "Introduzir a semi-norma H¹ discreta: |u_h|_{H¹,h} = (h² Σ |∇_h u_h|²)^{1/2}, onde ∇_h é diferença forward/backward.",
                                    "Definir a norma de energia: ||u_h||_a = √(<L_h u_h, u_h>_{L²,h}).",
                                    "Provar equivalência de normas via desigualdade de Poincaré-Friedrichs discreta para Dirichlet homogêneo.",
                                    "Calcular normas para uma solução teste simples (ex: u exata = x(1-x)y(1-y))."
                                  ],
                                  "verification": "Calcular ||u_h||_a e |u_h|_{H¹,h} para uma grade 4x4 e comparar valores.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de análise funcional discreta",
                                    "Software NumPy para somas discretas",
                                    "Tabela de Poincaré discreta"
                                  ],
                                  "tips": "Use somas de Riemann para aproximar integrais e verifique simetria da matriz L_h.",
                                  "learningObjective": "Dominar normas que capturam estabilidade para esquemas elípticos.",
                                  "commonMistakes": [
                                    "Esquecer o fator h² nas somas discretas.",
                                    "Confundir norma L² com norma máxima.",
                                    "Não aplicar Poincaré para ligar normas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecimento da Desigualdade de Estabilidade",
                                  "subSteps": [
                                    "Derivar <L_h u_h, u_h>_{L²,h} = h² Σ |∇_h u_h|² via soma por partes discreta.",
                                    "Provar coercividade: <L_h u_h, u_h> ≥ c |u_h|_{H¹,h}² com c=1 para esquema de 5 pontos.",
                                    "Usar Poincaré discreta: |u_h|_{H¹,h} ≥ C ||u_h||_{L²,h} sob Dirichlet homogêneo.",
                                    "Estender para norma plena: ||L_h^{-1}|| ≤ C h^{-2} em norma L².",
                                    "Verificar numericamente com autovalores de L_h."
                                  ],
                                  "verification": "Derivar explicitamente <L_h u_h, u_h> = Σ [(u_{i+1,j}-u_{i,j})²/h² + ...] e mostrar ≥0.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Artigo sobre análise de elementos finitos",
                                    "MATLAB eig() para matriz L_h",
                                    "Caneta e papel para somas por partes"
                                  ],
                                  "tips": "Comece em 1D para stencil de 3 pontos antes de 2D; telescoping sums facilitam.",
                                  "learningObjective": "Derivar a estimativa de estabilidade ||u_h|| ≤ C ||f_h||.",
                                  "commonMistakes": [
                                    "Erro no telescópio da soma por partes.",
                                    "Ignorar positividade semi-definida de L_h.",
                                    "Confundir autovalor mínimo com máximo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise e Verificação sob Condições de Dirichlet Homogêneas",
                                  "subSteps": [
                                    "Analisar impacto de u=0 na borda: L_h injetivo e simétrico positivo definido.",
                                    "Estimar constante de estabilidade independente de h via Poincaré.",
                                    "Comparar com condições não-homogêneas (lifting).",
                                    "Implementar teste numérico: resolver L_h u_h = Π_h f e checar ||u_h|| / ||f||.",
                                    "Discutir generalizações para malhas não-uniformes."
                                  ],
                                  "verification": "Resolver sistema para f=1, h=1/10 e confirmar ||u_h||_a ≈1 com erro <1%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Solver sparse (SciPy solve)",
                                    "Exemplo de código para Poisson 2D",
                                    "Gráficos de normas vs h"
                                  ],
                                  "tips": "Use CG iterativo para grandes grids; plote log-log para independência de h.",
                                  "learningObjective": "Concluir que o esquema é estável com constante C=1 em norma energia.",
                                  "commonMistakes": [
                                    "Não zerar u_h na borda.",
                                    "Escolha errada de norma (use energia, não L∞).",
                                    "Interpretação errada de ||L_h^{-1}||."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -Δu = π² sin(πx) sin(πy) em [0,1]² com u=0 na borda (exata u=sin(πx)sin(πy)). Use esquema 5 pontos com h=1/20, compute ||u_h - u_ex||_a / ||f_h||_a e verifique estabilidade com razão <1.1.",
                              "finalVerifications": [
                                "Deriva corretamente <L_h u_h, u_h> = |u_h|_{1,h}².",
                                "Aplica Poincaré discreta para ligar normas L² e H¹.",
                                "Calcula autovalor mínimo de L_h ≈ (π/h)².",
                                "Implementa código que confirma ||u_h|| ≤ ||f_h||.",
                                "Explica por que Dirichlet homogêneo garante injeção.",
                                "Compara estabilidade com esquema não-consistente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da coercividade (nota por passos corretos).",
                                "Correção das normas discretas e fatores h (erro <5%).",
                                "Implementação numérica sem bugs e gráficos claros.",
                                "Explicação qualitativa da independência de h.",
                                "Identificação de erros comuns em provas semelhantes.",
                                "Generalização para outros problemas elípticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de potencial eletrostático (equação de Poisson).",
                                "Computação: Análise de solvers iterativos (GMRES/CG) e condicionamento de matrizes.",
                                "Engenharia: Modelagem de fluxo incompressível em CFD com operadores elípticos.",
                                "Análise Funcional: Lax-Milgram discreto e espaços de Sobolev.",
                                "Estatística: Análise de erro em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Garantir estabilidade em simulações numéricas de campos térmicos em engenharia (ex: dissipação de calor em chips), evitando amplificação de erros de arredondamento em softwares como COMSOL ou ANSYS para designs confiáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.2.3",
                            "name": "Estabilidade para condições de Neumann",
                            "description": "Examinar critérios de estabilidade para diferenças finitas em problemas de Neumann, incluindo tratamento de condições de compatibilidade e normas energéticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de condições de Neumann em equações elípticas",
                                  "subSteps": [
                                    "Estudar a formulação matemática de problemas elípticos com condições de Neumann: -Δu = f em Ω, ∂u/∂n = g em ∂Ω.",
                                    "Analisar a existência e unicidade da solução, destacando a condição de compatibilidade ∫_Ω f = ∫_∂Ω g.",
                                    "Explorar exemplos simples em 1D e 2D para visualizar o comportamento.",
                                    "Derivar a norma energética básica ||u||_E = ∫_Ω |∇u|^2.",
                                    "Comparar com condições de Dirichlet para destacar diferenças."
                                  ],
                                  "verification": "Resumir em um parágrafo as diferenças entre Neumann e Dirichlet, incluindo a compatibilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), notas de aula, caderno para anotações.",
                                  "tips": "Desenhe diagramas do domínio Ω e ∂Ω para visualizar fluxos normais.",
                                  "learningObjective": "Compreender a formulação e propriedades fundamentais de problemas de Neumann.",
                                  "commonMistakes": "Ignorar a não-unicidade da solução (soluções até constante aditiva)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretização por diferenças finitas para condições de Neumann",
                                  "subSteps": [
                                    "Construir a malha uniforme em 2D e definir operadores de Laplace discretos.",
                                    "Implementar a condição de Neumann usando diferenças centradas ou forward/backward na fronteira.",
                                    "Montar o sistema linear Au = b, onde A é a matriz laplaciana com Neumann.",
                                    "Discutir ajustes para a malha cartesiana e tratamento de cantos.",
                                    "Testar numericamente um exemplo simples em Python/MATLAB."
                                  ],
                                  "verification": "Gerar a matriz A para uma malha 3x3 e verificar simetria.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com NumPy/SciPy, MATLAB, exemplos de código de diferenças finitas.",
                                  "tips": "Use stencil diagrams para visualizar os coeficientes na fronteira.",
                                  "learningObjective": "Dominar a discretização precisa de esquemas FD para Neumann.",
                                  "commonMistakes": "Erro na aproximação da derivada normal (usar centrada incorretamente)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Condições de compatibilidade nos esquemas discretos",
                                  "subSteps": [
                                    "Derivar a condição de compatibilidade discreta: soma das linhas de A deve ser zero para Neumann puro.",
                                    "Verificar solvibilidade do sistema Au = b via soma de resíduos.",
                                    "Analisar impacto da incompatibilidade: resíduo não nulo leva a falha de convergência.",
                                    "Implementar checagem numérica da compatibilidade em código.",
                                    "Estudar aproximação da compatibilidade contínua na malha fina."
                                  ],
                                  "verification": "Para um exemplo, computar soma de b e comparar com soma discreta de g.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código Python do step anterior, calculadora matricial.",
                                  "tips": "Sempre normalize soluções para evitar ambiguidades.",
                                  "learningObjective": "Identificar e impor condições de compatibilidade discretas.",
                                  "commonMistakes": "Esquecer de verificar compatibilidade antes de resolver o sistema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise de estabilidade usando normas energéticas",
                                  "subSteps": [
                                    "Definir a norma energética discreta: ||u_h||_E,h ≈ soma |∇u_h|^2 Δx.",
                                    "Provar estimativa de estabilidade: ||u_h||_E,h ≤ C (||f|| + ||g||).",
                                    "Usar multiplicadores de Lax-Milgram discretos para Neumann.",
                                    "Analisar consistência e estabilidade via erro de Céa-like.",
                                    "Simular numericamente com ruído para verificar robustez."
                                  ],
                                  "verification": "Derivar a desigualdade de estabilidade para um caso 1D e generalizar.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Referências teóricas (ex: Brenner-Scott), software para simulações.",
                                  "tips": "Comece com 1D para intuition, depois 2D.",
                                  "learningObjective": "Aplicar normas energéticas para provar estabilidade.",
                                  "commonMistakes": "Confundir norma L2 com energética na prova."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração e verificação prática",
                                  "subSteps": [
                                    "Resolver um problema completo com Neumann incompatível e corrigir.",
                                    "Comparar soluções com malhas refinadas para estabilidade.",
                                    "Analisar condnumber de A e impacto na estabilidade.",
                                    "Documentar um relatório com gráficos de erro.",
                                    "Discutir extensões para domínios irregulares."
                                  ],
                                  "verification": "Produzir gráfico de convergência ||u_h - u|| vs h.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Códigos anteriores, MeshPy ou Gmsh para malhas.",
                                  "tips": "Use condicionado para detectar instabilidades.",
                                  "learningObjective": "Integrar todos os conceitos em uma análise completa.",
                                  "commonMistakes": "Não normalizar soluções para comparação."
                                }
                              ],
                              "practicalExample": "Resolva -Δu = 0 em quadrado unitário com ∂u/∂n = sen(πx) + cos(πy) na fronteira, verificando compatibilidade ∫g=0, implemente FD em malha 32x32, prove estabilidade via norma energética e compare com solução exata u=sen(πx)cos(πy).",
                              "finalVerifications": [
                                "Deriva corretamente a condição de compatibilidade discreta.",
                                "Constrói matriz A simétrica para Neumann em 2D.",
                                "Prova estimativa de estabilidade com norma energética.",
                                "Implementa código que checa compatibilidade e resolve.",
                                "Analisa numericamente convergência em malha refinada.",
                                "Identifica instabilidades por incompatibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na discretização de Neumann (erro <1% em stencil).",
                                "Correta imposição de compatibilidade (resíduo <1e-10).",
                                "Prova rigorosa de estabilidade (desigualdade energética).",
                                "Código funcional e comentado com simulações.",
                                "Análise de erros e condnumber adequada.",
                                "Relatório claro com gráficos e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Eletróstatica e fluxo de calor com isolamento (Neumann=0).",
                                "Engenharia: Modelagem de fluxos em reservatórios porosos.",
                                "Computação: Otimização de solvers iterativos para sistemas singulares.",
                                "Estatística: Análise de incertezas em aproximações numéricas."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor em paredes isoladas (Neumann=0), análise de estabilidade garante precisão em previsões meteorológicas ou design de reatores nucleares, evitando erros por incompatibilidades em dados de fronteira reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.6.3",
                        "name": "Convergência dos Métodos",
                        "description": "Teoria de convergência, unindo consistência e estabilidade via teorema de Lax-Richtmyer, com estimativas de erro para métodos de diferenças finitas em equações elípticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.3.1",
                            "name": "Teorema de equivalência de Lax",
                            "description": "Enunciar e discutir o teorema de Lax-Richtmyer para esquemas de diferenças finitas em problemas elípticos estacionários, destacando condições de aplicabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Consistência, Estabilidade e Convergência",
                                  "subSteps": [
                                    "Defina consistência: um esquema numérico aproxima a solução exata da EDP quando o passo de malha tende a zero.",
                                    "Explique estabilidade: a solução numérica não amplifica erros iniciais ou de arredondamento descontroladamente.",
                                    "Descreva convergência: a solução numérica tende à solução exata conforme refinamento da malha.",
                                    "Discuta a norma usada para medições (ex: norma L2 ou máxima).",
                                    "Relacione os três conceitos no contexto de problemas elípticos estacionários."
                                  ],
                                  "verification": "Resuma as definições em um parágrafo coeso e verifique com fórmulas padrão (ex: ordem de truncamento para consistência).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: LeVeque), notas de aula, calculadora simbólica (Mathematica ou similar).",
                                  "tips": "Use analogias como 'consistência é precisão do mapa, estabilidade é não explodir o carro, convergência é chegar ao destino'.",
                                  "learningObjective": "Compreender as bases teóricas que sustentam o teorema de Lax-Richtmyer.",
                                  "commonMistakes": "Confundir estabilidade com consistência; ignorar que estabilidade é necessária mas não suficiente sozinha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar o Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Estude o enunciado formal: Para esquemas consistentes, convergência ⇔ estabilidade.",
                                    "Escreva o teorema matematicamente: Se consistente e estável, então convergente (Lax).",
                                    "Discuta a extensão de Richtmyer para condições mais gerais.",
                                    "Identifique premissas: problemas lineares, malhas uniformes, normas adequadas.",
                                    "Memorize contraexemplos clássicos onde consistência sem estabilidade falha."
                                  ],
                                  "verification": "Escreva o teorema do zero e prove um caso trivial (ex: método explícito 1D).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo original de Lax (1954) ou resumo em PDF, quadro branco para anotações.",
                                  "tips": "Anote o teorema em uma ficha de estudo com setas lógicas: Consistente + Estável → Convergente.",
                                  "learningObjective": "Enunciar precisamente o teorema e suas implicações imediatas.",
                                  "commonMistakes": "Omitir 'consistência' como hipótese; confundir com teorema de Lax-Wendroff para hiperbólicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Condições de Aplicabilidade para Problemas Elípticos Estacionários",
                                  "subSteps": [
                                    "Explique adaptações para elípticos: foco em esquemas implícitos como diferenças finitas centradas.",
                                    "Discuta condições: ellipticidade uniforme, malhas retangulares, operadores auto-adjuntos.",
                                    "Estude teoremas de estabilidade (ex: máximo princípio para Laplace).",
                                    "Identifique limitações: não-linearidades, malhas não-estruturadas, condições de contorno irregulares.",
                                    "Compare com parabólicos ou hiperbólicos."
                                  ],
                                  "verification": "Liste 3 condições necessárias e 2 suficientes; teste em um esquema conhecido (ex: 5-point stencil).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB para simular stencil, referências como Gustafsson et al.",
                                  "tips": "Visualize com diagramas de Fourier: símbolos de amplificação para estabilidade.",
                                  "learningObjective": "Discutir rigorosamente quando e por que o teorema se aplica a elípticos.",
                                  "commonMistakes": "Aplicar diretamente teoremas hiperbólicos sem ajustes; ignorar ellipticidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Exemplos Práticos e Contraexemplos",
                                  "subSteps": [
                                    "Implemente um esquema consistente e estável para -Δu = f (ex: 5-point para malha 10x10).",
                                    "Teste um esquema instável (ex: upwind inadequado para elípticos) e observe falha de convergência.",
                                    "Calcule erros de truncamento e normas de estabilidade.",
                                    "Discuta prova esboçada: use teorema de Banach fixo para convergência.",
                                    "Registre observações em tabela: malha vs. erro."
                                  ],
                                  "verification": "Gere gráfico de erro vs. h; confirme redução quadrática para esquema ordem 2.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com NumPy/SciPy, equação de Poisson teste.",
                                  "tips": "Comece com domínio unitário e f=1 para soluções analíticas conhecidas.",
                                  "learningObjective": "Aplicar o teorema na prática, validando teoria.",
                                  "commonMistakes": "Erros de programação em condições de contorno; escalas numéricas erradas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Discussão e Limitações",
                                  "subSteps": [
                                    "Resuma forças: garante confiabilidade de códigos numéricos.",
                                    "Discuta extensões modernas (DG methods, adaptativas).",
                                    "Aborde críticas: não cobre não-lineares ou alto-ordem diretamente.",
                                    "Prepare argumentos para debate: 'É o teorema ainda relevante hoje?'",
                                    "Crie mapa mental conectando conceitos."
                                  ],
                                  "verification": "Escreva um ensaio de 300 palavras discutindo aplicabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de mindmap (ex: XMind), artigos recentes sobre FEM.",
                                  "tips": "Use bullet points para limitações; cite 2 papers pós-2000.",
                                  "learningObjective": "Criticar e contextualizar o teorema no panorama atual.",
                                  "commonMistakes": "Superestimar universalidade; ignorar avanços computacionais."
                                }
                              ],
                              "practicalExample": "Considere a equação de Poisson -Δu = π² sin(πx) sin(πy) em [0,1]² com u=0 na borda. Use esquema de diferenças finitas 5-pontos (consistente ordem 2). Verifique estabilidade via princípio máximo, execute para h=1/10, 1/20; observe ||u_h - u||_∞ ~ O(h²), confirmando convergência por Lax-Richtmyer.",
                              "finalVerifications": [
                                "Enuncie o teorema sem consultar notas.",
                                "Explique por que consistência sozinha falha (contraexemplo).",
                                "Liste 3 condições para elípticos.",
                                "Analise estabilidade de um stencil dado.",
                                "Preveja comportamento de convergência para h→0.",
                                "Discuta limitação em problemas não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado (100% correto).",
                                "Profundidade na discussão de condições (cobre ellipticidade, malha).",
                                "Uso correto de exemplos numéricos (gráficos de erro).",
                                "Identificação de erros comuns (ex: confusão com hiperbólicos).",
                                "Conexões lógicas entre conceitos (diagrama fluxo).",
                                "Criatividade em aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de campos eletromagnéticos estáticos.",
                                "Engenharia: Análise de tensões em estruturas (FDM em sólidos).",
                                "Ciência da Computação: Algoritmos paralelos para solvers elípticos.",
                                "Estatística: Análise de erros em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em modelagem climática, o teorema garante que esquemas numéricos para equações elípticas de balanceamento de pressão convergem, permitindo simulações confiáveis de atmosferas em supercomputadores para previsões de tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.3.2",
                            "name": "Provar convergência para Laplace",
                            "description": "Demonstrar a convergência de ordem 2 do esquema de 5 pontos para a equação de Laplace com condições de Dirichlet, usando estimativas de erro de consistência e estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema de Laplace e o Esquema de Diferenças Finitas de 5 Pontos",
                                  "subSteps": [
                                    "Escreva a equação de Laplace: Δu = 0 em um domínio Ω ⊂ ℝ² com condições de Dirichlet u = g na fronteira ∂Ω.",
                                    "Introduza uma malha uniforme com passo h em ambas as direções, definindo pontos (x_i, y_j) = (ih, jh).",
                                    "Derive o esquema de 5 pontos centrado: 4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = 0.",
                                    "Aplique as condições de Dirichlet nas fronteiras interpolando g se necessário.",
                                    "Defina o operador discreto L_h u_h = 0 e a solução exata u."
                                  ],
                                  "verification": "Verifique se o stencil é simétrico e aproxima o laplaciano corretamente comparando com a definição contínua.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque ou Quarteroni)",
                                    "Papel e lápis para esboços da malha",
                                    "Software como MATLAB para visualizar malha (opcional)"
                                  ],
                                  "tips": "Desenhe a malha e o stencil graficamente para visualizar os vizinhos.",
                                  "learningObjective": "Compreender a discretização espacial do problema elíptico e formular o sistema linear discreto.",
                                  "commonMistakes": [
                                    "Confundir o stencil com o de 9 pontos para Poisson",
                                    "Ignorar interpolação nas fronteiras irregulares",
                                    "Esquecer a simetria do operador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar a Consistência do Esquema (Erro de Truncagem de Ordem 2)",
                                  "subSteps": [
                                    "Substitua a solução exata u suave no esquema discreto: L_h u = τ_{i,j} h², onde τ é o erro de truncagem local.",
                                    "Use expansão de Taylor em torno de (x_i, y_j): u(x_i ± h, y_j) = u ± h u_x + (h²/2) u_xx ± ...",
                                    "Expanda para todas as direções e some: mostre que os termos lineares cancelam e os quadráticos dão Δu + O(h²) = O(h²).",
                                    "Conclua que ||τ||_∞ = O(h²) assumindo u ∈ C⁴(Ω̄).",
                                    "Estime o erro global usando norma máxima ou norma L² discreta."
                                  ],
                                  "verification": "Calcule explicitamente os coeficientes da expansão de Taylor até O(h²) e verifique que τ/h² → 0 quando h → 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Folha de derivadas de Taylor pré-computadas",
                                    "Calculadora simbólica como SymPy ou Mathematica (opcional)",
                                    "Referência: teorema de consistência para DFM"
                                  ],
                                  "tips": "Agrupe termos por ordens de h sistematicamente em uma tabela.",
                                  "learningObjective": "Demonstrar que o esquema aproxima o operador diferencial com precisão de segunda ordem.",
                                  "commonMistakes": [
                                    "Parar a expansão em O(h) em vez de O(h²)",
                                    "Confundir derivadas parciais mistas",
                                    "Esquecer o fator h² na normalização do laplaciano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Estabilidade do Esquema via Princípio do Máximo Discreto",
                                  "subSteps": [
                                    "Enuncie o princípio do máximo discreto: para L_h v ≥ 0 em Ω_h, max_Ω_h v = max_∂Ω_h v.",
                                    "Prove para o operador de Laplace discreto: suponha v satisfaz L_h v ≥ 0, assuma máximo interior em (i,j).",
                                    "Mostre que no máximo, vizinhos ≤ v_{i,j}, implicando L_h v_{i,j} ≤ 0, contradição a menos que v constante.",
                                    "Estenda para estabilidade em norma ∞: ||u_h||_∞ ≤ ||g||_∞ + C ||f|| se Poisson, mas f=0 aqui.",
                                    "Conclua estabilidade uniforme em h: ||u_h|| ≤ C ||u|| independentemente de h."
                                  ],
                                  "verification": "Aplique o princípio a uma função teste como v=1 (constante) e v com máximo interior artificial.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Prova padrão de princípio do máximo (folha de referência)",
                                    "Exemplos numéricos simples em grade 3x3"
                                  ],
                                  "tips": "Use prova por contradição e analise o sinal do operador no máximo.",
                                  "learningObjective": "Estabelecer que soluções discretas não amplificam erros além das condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir com princípio do mínimo",
                                    "Ignorar o caso de máximo na fronteira",
                                    "Não normalizar por h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a Convergência de Ordem 2 Usando o Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Enuncie o teorema: para esquemas consistentes e estáveis, ||u - u_h|| → 0 com a mesma ordem da consistência.",
                                    "Combine consistência O(h²) e estabilidade uniforme para ||u - u_h||_∞ ≤ C h² ||u||_{C⁴}.",
                                    "Discuta extensões para normas L² ou H¹ usando análise de autovalores do operador discreto.",
                                    "Verifique numericamente em um exemplo simples para ilustrar a ordem 2.",
                                    "Resuma a prova completa em um teorema enunciado formalmente."
                                  ],
                                  "verification": "Escreva a desigualdade de convergência explícita e comprove com estimativas de constantes C.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Enunciado do Teorema de Lax (referência)",
                                    "Código MATLAB/Python para teste numérico em grade fina"
                                  ],
                                  "tips": "Lembre que para elípticos, estabilidade + consistência basta; não precisa de monotonicidade extra.",
                                  "learningObjective": "Integrar consistência e estabilidade para provar convergência teórica de ordem ótima.",
                                  "commonMistakes": [
                                    "Aplicar teorema de Lax sem verificar hipóteses elípticas",
                                    "Confundir ordem de consistência com convergência",
                                    "Ignorar regularidade da solução u"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de Laplace em Ω = [0,1]² com u(x,0)=0, u(x,1)=sin(πx), u(0,y)=u(1,y)=0. A solução exata é u(x,y)=y sin(πx). Discretize com h=1/N, resolva o sistema linear via Gauss-Seidel, e compare ||u - u_h||_∞ / h² para N=10,20,40 confirmando ordem 2.",
                              "finalVerifications": [
                                "Reproduzir corretamente o erro de truncagem τ = (h²/12)(u_xxxx + 2u_xxyy + u_yyyy) + O(h⁴).",
                                "Provar princípio do máximo discreto sem lacunas na contradição.",
                                "Escrever a estimativa ||e_h||_∞ ≤ C h² onde e_h = u - u_h.",
                                "Identificar que estabilidade vem do caráter elíptico máximo-princípio.",
                                "Aplicar teorema corretamente citando consistência e estabilidade.",
                                "Verificar numericamente em exemplo que o erro decai como h²."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (pontos por termos corretos).",
                                "Rigor na prova de estabilidade (uso correto de contradição).",
                                "Clareza na combinação para convergência (desigualdade explícita).",
                                "Correção matemática em todos os passos (sem erros algébricos).",
                                "Profundidade: inclusão de normas e regularidade necessárias.",
                                "Comunicação: teorema final bem enunciado e resumido."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de potenciais eletrostáticos e fluxo de calor estacionário.",
                                "Computação Científica: Implementação de solvers iterativos como Jacobi ou multigrid.",
                                "Engenharia: Simulações em CFD para escoamentos incompressíveis (vórtice-stream function).",
                                "Matemática Aplicada: Análise espectral de autovalores discretos.",
                                "Programação: Codificação em Python/NumPy para validação numérica."
                              ],
                              "realWorldApplication": "Provar convergência garante precisão em simulações industriais como design de chips semicondutores (potencial elétrico), análise de tensões em estruturas (equações de equilíbrio elípticas) e otimização topológica em engenharia aeroespacial, onde malhas finas com h~10^{-4} são usadas para precisão de ordem 2."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.3.3",
                            "name": "Estimativas de erro de convergência",
                            "description": "Derivar estimativas assintóticas de erro global para métodos de diferenças finitas em equações elípticas gerais, considerando malhas uniformes e refinamento h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Equações Elípticas e Discretização por Diferenças Finitas",
                                  "subSteps": [
                                    "Estude a forma geral de equações elípticas: Lu = f, onde L é um operador elíptico autoradjunto de segunda ordem.",
                                    "Revise condições de contorno Dirichlet homogêneas e malhas uniformes em 2D.",
                                    "Derive o stencil de 5 pontos para o operador Laplace -Δu em malha com passo h.",
                                    "Implemente a discretização em uma grade quadrada [0,1]x[0,1] com N pontos por direção.",
                                    "Verifique a consistência da aproximação verificando que o operador discreto converge para o contínuo quando h→0."
                                  ],
                                  "verification": "Resolva um problema modelo simples (ex: -Δu=0 com u=sin(πx)sin(πy)) e compare u_h com u exata em alguns pontos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque ou Quarteroni)",
                                    "Papel e lápis para derivações",
                                    "Software como MATLAB ou Python (NumPy) para stencil"
                                  ],
                                  "tips": "Comece com o caso 1D para intuitionar antes de 2D; desenhe a malha para visualizar o stencil.",
                                  "learningObjective": "Compreender a discretização padrão e sua consistência para equações elípticas.",
                                  "commonMistakes": [
                                    "Confundir stencil central com forward/backward",
                                    "Ignorar fator 1/h^2 no operador discreto",
                                    "Esquecer normalização das condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivação do Erro de Truncamento Local (Local Truncation Error)",
                                  "subSteps": [
                                    "Expanda u(x_i, y_j) em série de Taylor ao redor do ponto central (x_i, y_j).",
                                    "Substitua no stencil discreto e colete termos até ordem h^2.",
                                    "Mostre que o erro de truncamento τ_h = O(h^2) para operadores de segunda ordem.",
                                    "Generalize para coeficientes variáveis em equações elípticas gerais a_u u_xx + 2b_u u_xy + c_u u_yy + termos de primeira ordem.",
                                    "Calcule explicitamente τ_h para o problema de Poisson -Δu = f."
                                  ],
                                  "verification": "Compute τ_h numericamente para uma solução conhecida e confirme que |τ_h| / h^2 → constante quando h diminui.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Caderno de derivações",
                                    "SymPy ou Mathematica para expansões de Taylor simbólicas",
                                    "Referência: Atkinson 'Numerical Analysis' capítulo sobre FD"
                                  ],
                                  "tips": "Use notação δ^2 u para diferenças centrais; lembre que δ^2 u / h^2 ≈ ∂^2 u / ∂x^2 + (h^2/12) ∂^4 u / ∂x^4.",
                                  "learningObjective": "Derivar e interpretar o erro local de aproximação do método de diferenças finitas.",
                                  "commonMistakes": [
                                    "Erros nos coeficientes da expansão de Taylor (fatorial errado)",
                                    "Não dividir corretamente por h^2",
                                    "Ignorar termos cruzados em equações não-Laplace"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecendo Estabilidade e Estimativa de Erro Global",
                                  "subSteps": [
                                    "Introduza a norma de energia ||v||_A^2 = <Av,v> para o operador elíptico discreto.",
                                    "Prove a máxima princípio ou use o teorema de Lax-Milgram discreto para invertibilidade de A_h.",
                                    "Use a desigualdade de Céa ou análise de erro: ||u - u_h|| ≤ (1 + ||A_h^{-1}||) inf ||u - v_h|| para v_h em espaço discreto.",
                                    "Combine com interpolação: erro de interpolação O(h^2) para u em H^2.",
                                    "Derive ||u - u_h||_A ≤ C h^2 ||u||_{H^2} assumindo regularidade."
                                  ],
                                  "verification": "Escreva a prova passo a passo e verifique para o caso Laplace com constante C=1.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Notas de curso de Análise Numérica II",
                                    "Livro 'Finite Difference Schemes and PDE' de Strikwerda",
                                    "LaTeX para formalizar provas"
                                  ],
                                  "tips": "Lembre que estabilidade vem da elipticidade: α||v||^2 ≤ <Av,v>; foque em normas equivalentes.",
                                  "learningObjective": "Conectar erro local à global via estabilidade e aproximação.",
                                  "commonMistakes": [
                                    "Confundir norma L2 com norma de energia",
                                    "Esquecer fator de condicionamento ||A_h^{-1}|| ~ 1/h^2 mas cancelado por elipticidade",
                                    "Não assumir u em H^2(Ω)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise Assintótica e Refinamento h",
                                  "subSteps": [
                                    "Defina erro global e_h = ||u - u_h|| (escolha norma L2 ou H1).",
                                    "Mostre assintoticamente e_h ~ K h^2 para h→0 em malhas uniformes.",
                                    "Compute numericamente para problema teste: plote log(e_h) vs log(h) e ajuste slope=2.",
                                    "Discuta impacto de malha não-uniforme ou refinamento adaptativo (breve).",
                                    "Generalize para ordem superior (h^4 com stencils amplos)."
                                  ],
                                  "verification": "Implemente código para h=1/10,1/20,...,1/160; confirme ordem 2 via razão de erros sucessivos ≈4.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com SciPy para resolver sistemas lineares",
                                    "Matplotlib para plots log-log",
                                    "Problema teste: u=x(1-x)y(1-y), f=Δu calculado"
                                  ],
                                  "tips": "Use solve(A_h u_h = f_h) com sparse matrices para eficiência; normalize erros por ||u||.",
                                  "learningObjective": "Verificar e interpretar a ordem de convergência assintótica.",
                                  "commonMistakes": [
                                    "Poluição numérica em h muito pequeno devido a condicionamento",
                                    "Não subtrair solução exata corretamente nas fronteiras",
                                    "Confundir erro relativo vs absoluto"
                                  ]
                                }
                              ],
                              "practicalExample": "Para -Δu = 2π² sin(πx) sin(πy) em [0,1]² com u=0 na fronteira (solução exata u=sin(πx)sin(πy)), discretize com h=1/N, stencil 5-pt. Derive τ_h = O(h^2), prove ||u-u_h||_{L2} ≤ C h^2, e numéricamente confirme com N=10,20,40 mostrando razão de erros ~4.",
                              "finalVerifications": [
                                "Derivação correta do erro de truncamento local O(h^2) com termos explícitos.",
                                "Prova completa da estimativa global ||e_h|| ≤ C h^2 usando estabilidade.",
                                "Implementação numérica com plot log-log confirmando ordem 2.",
                                "Generalização verbal para equações elípticas com coeficientes variáveis.",
                                "Identificação de 3 erros comuns em análises de convergência.",
                                "Explicação da dependência em regularidade de u (H^2 sobe para H^{k+2} em ordem k)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor e truncamento (90% correto).",
                                "Rigor matemático na prova de estabilidade e Céa (passos lógicos completos).",
                                "Correção numérica: erro diminui como h^2 dentro de 10% do esperado.",
                                "Clareza na explicação assintótica e limitações (ex: h→0).",
                                "Criatividade em generalizações ou exemplos adicionais.",
                                "Profundidade nas conexões com teoria funcional (Galerkin)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Potencial eletrostático (equação de Poisson) em simulações CFD.",
                                "Engenharia Computacional: Implementação em solvers finitos para estruturas.",
                                "Programação: Uso de bibliotecas como FEniCS ou PETSc para validação.",
                                "Estatística: Análise de erro em métodos Monte Carlo para PDEs.",
                                "Otimização: Refinamento adaptativo baseado em estimativas a posteriori."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de calor estacionário em placas (engenharia térmica), estimativas de erro garantem precisão em malhas grosseiras para design eficiente; em geofísica, modela gravidade elíptica com erros controlados para previsões de reservatórios de óleo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Equações Hiperbólicas",
                "description": "Métodos explícitos e implícitos para resolver equações hiperbólicas.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Métodos Explícitos de Diferenças Finitas para Equações Hiperbólicas",
                    "description": "Abordagem explícita para resolver numericamente equações hiperbólicas usando diferenças finitas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Formulação do Método Explícito de Diferenças Finitas",
                        "description": "Apresenta a discretização explícita da equação de advecção hiperbólica ou da equação da onda utilizando esquemas como FTCS, Lax-Friedrichs e Lax-Wendroff, destacando a atualização direta das soluções nos pontos da malha.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Derivar o esquema FTCS para equação hiperbólica",
                            "description": "Derivar o esquema Forward-Time Central-Space (FTCS) para a equação de transporte u_t + a u_x = 0, identificando os operadores de diferença forward em tempo e central em espaço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação de transporte hiperbólica e sua notação",
                                  "subSteps": [
                                    "Leia e memorize a equação u_t + a u_x = 0, onde u(t,x) é a solução, t é tempo e x é espaço.",
                                    "Identifique que a é a velocidade de transporte constante (a > 0 para fluxo à direita).",
                                    "Esboce um gráfico qualitativo da solução: uma onda ou perfil se movendo com velocidade a sem dispersão.",
                                    "Defina os operadores diferenciais: u_t = ∂u/∂t (derivada temporal) e u_x = ∂u/∂x (derivada espacial).",
                                    "Anote as condições iniciais u(0,x) = f(x) e condições de contorno apropriadas."
                                  ],
                                  "verification": "Escreva a equação corretamente e explique verbalmente o significado físico em 1-2 frases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (capítulo de EDOs hiperbólicas)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize a solução como partículas se movendo rigidamente com velocidade a; não há difusão.",
                                  "learningObjective": "Entender a forma adveccional da equação e suas propriedades hiperbólicas.",
                                  "commonMistakes": [
                                    "Confundir com equação de difusão (parabólica) que tem u_xx",
                                    "Assumir a variável (pensar em difusão em vez de transporte)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a malha numérica discretizada em tempo e espaço",
                                  "subSteps": [
                                    "Defina os pontos de grade: x_j = j Δx para j=0,1,...,J; t_n = n Δt para n=0,1,...,N.",
                                    "Introduza a notação u^n_j ≈ u(t_n, x_j).",
                                    "Escolha Δx e Δt pequenos o suficiente, definindo o número de CFL λ = a Δt / Δx (para estabilidade futura).",
                                    "Esboce a malha no plano (t,x), marcando pontos (n,j), (n+1,j), (n,j+1), (n,j-1).",
                                    "Discuta condições de contorno: periódicas ou Dirichlet em x=0 e x=L."
                                  ],
                                  "verification": "Desenhe a malha corretamente e rotule u^n_j em pelo menos 5 pontos vizinhos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de desenho como GeoGebra ou papel simples"
                                  ],
                                  "tips": "Mantenha Δx e Δt proporcionais; pense em como os pontos se conectam para diferenças finitas.",
                                  "learningObjective": "Estabelecer a base discreta para aproximações de diferenças finitas.",
                                  "commonMistakes": [
                                    "Usar notação errada como u_j^n em vez de u^n_j",
                                    "Esquecer de indexar tempo primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e justificar as aproximações de diferenças finitas forward-time e central-space",
                                  "subSteps": [
                                    "Para u_t em (t_n, x_j): use forward difference temporal: [u^{n+1}_j - u^n_j]/Δt ≈ u_t.",
                                    "Para u_x em (t_n, x_j): use central difference espacial: [u^n_{j+1} - u^n_{j-1}]/(2 Δx) ≈ u_x.",
                                    "Justifique: forward-time é explícito (usa valores conhecidos para prever futuro); central-space é ordem 2 em precisão.",
                                    "Escreva as aproximações separadamente e verifique truncagem: O(Δt) para tempo, O(Δx^2) para espaço.",
                                    "Identifique os operadores: L_t = forward em t, L_x = central em x."
                                  ],
                                  "verification": "Escreva as duas fórmulas de FD e compute os erros de truncagem locais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de diferenças finitas (impressa ou memorizada)",
                                    "Calculadora para Taylor simples"
                                  ],
                                  "tips": "Expanda em série de Taylor para confirmar precisão: u(t+Δt,x) = u + Δt u_t + (Δt)^2/2 u_tt + ...",
                                  "learningObjective": "Dominar as escolhas específicas de FD que definem FTCS.",
                                  "commonMistakes": [
                                    "Usar backward em tempo (seria implícito)",
                                    "Central errado: (u_{j+1}-u_{j-1})/Δx ao invés de 2Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Substituir as aproximações na equação PDE e derivar o esquema FTCS",
                                  "subSteps": [
                                    "Substitua na PDE discretizada: [u^{n+1}_j - u^n_j]/Δt + a [u^n_{j+1} - u^n_{j-1}]/(2 Δx) = 0.",
                                    "Multiplique por Δt: u^{n+1}_j - u^n_j + (a Δt /(2 Δx)) (u^n_{j+1} - u^n_{j-1}) = 0.",
                                    "Resolva para u^{n+1}_j: u^{n+1}_j = u^n_j - (a Δt /(2 Δx)) (u^n_{j+1} - u^n_{j-1}).",
                                    "Introduza σ = a Δt / Δx (número de Courant), então u^{n+1}_j = u^n_j - (σ/2) (u^n_{j+1} - u^n_{j-1}).",
                                    "Identifique explicitamente: forward-time (usa n para n+1), central-space (média j+1 e j-1)."
                                  ],
                                  "verification": "Derive a fórmula final algebricamente passo a passo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para álgebra",
                                    "Exemplo numérico simples com valores fictícios"
                                  ],
                                  "tips": "Verifique dimensionalmente: termos devem ser adimensionais ou consistentes.",
                                  "learningObjective": "Obter a forma final do esquema e reconhecer sua natureza explícita.",
                                  "commonMistakes": [
                                    "Sinal errado no termo espacial",
                                    "Fator 2Δx esquecido"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar estabilidade básica e resumir o esquema FTCS completo",
                                  "subSteps": [
                                    "Discuta estabilidade: para FTCS em adveção linear, instável para qualquer σ > 0 (von Neumann).",
                                    "Escreva o stencil do esquema: valores em n,j; n,j+1; n,j-1 → n+1,j.",
                                    "Confirme operadores: tempo-forward (1,0,-1 em stencil temporal implícito), espaço-central.",
                                    "Prepare para implementação: pseudocódigo u[n+1,j] = ...",
                                    "Resuma: FTCS é simples mas oscila/dispersa para adveção pura."
                                  ],
                                  "verification": "Escreva o stencil gráfico e mencione limitação de estabilidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para stencil",
                                    "Referência rápida sobre análise von Neumann"
                                  ],
                                  "tips": "Stencil: coeficientes 1 para j, -σ/2 para j+1 e j-1.",
                                  "learningObjective": "Contextualizar FTCS como método explícito básico com limitações.",
                                  "commonMistakes": [
                                    "Pensar que é estável como upwind",
                                    "Confundir com Lax-Friedrichs"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere u_t + u_x = 0 com u(0,x) = sen(2π x) em [0,1] com contornos periódicos. Aplique FTCS com Δx=0.01, Δt=0.001 (σ=0.1): compute u^1_5 manualmente e veja deslocamento aproximado de 0.001 unidades à direita.",
                              "finalVerifications": [
                                "Pode escrever a fórmula FTCS exata com σ = a Δt / Δx?",
                                "Desenha corretamente o stencil de 3 pontos?",
                                "Explica por que é forward-time e central-space?",
                                "Identifica o erro de truncagem O(Δt + Δx^2)?",
                                "Menciona instabilidade para adveção?",
                                "Deriva corretamente a partir da PDE em menos de 5 minutos?"
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (sem erros de sinal ou fator)",
                                "Correta identificação dos operadores FD (forward t, central x)",
                                "Compreensão da notação de grade e índices",
                                "Justificativa de precisão de truncagem",
                                "Reconhecimento de limitações (estabilidade)",
                                "Clareza na explicação oral ou escrita"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas ou fluxo de tráfego (equação de Burgers aproximada)",
                                "Computação: Implementação em Python/MATLAB para simulações numéricas",
                                "Engenharia: Simulações CFD (Computational Fluid Dynamics) para escoamentos hiperbólicos",
                                "Estatística: Análise de erros numéricos e convergência"
                              ],
                              "realWorldApplication": "Usado em simulações iniciais de propagação de ondas sísmicas, previsão de tráfego rodoviário (onde carros se movem com velocidade média a), ou modelagem básica de sinais em telecomunicações, apesar de necessidade de métodos upwind para estabilidade prática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Implementar esquema Lax-Friedrichs",
                            "description": "Formular e codificar o esquema Lax-Friedrichs para equações hiperbólicas, incorporando média dos vizinhos espaciais para introduzir dissipação artificial e melhorar estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e formular o esquema Lax-Friedrichs teoricamente",
                                  "subSteps": [
                                    "Estude a equação hiperbólica de referência, como a equação de transporte u_t + a u_x = 0.",
                                    "Derive a discretização Lax-Friedrichs: u_j^{n+1} = (u_{j-1}^n + u_{j+1}^n)/2 - (a Δt / (2 Δx)) (u_{j+1}^n - u_{j-1}^n).",
                                    "Analise a condição CFL: |a Δt / Δx| ≤ 1 para estabilidade.",
                                    "Identifique o papel da média dos vizinhos na dissipação artificial.",
                                    "Esboce pseudocódigo para o esquema explícito."
                                  ],
                                  "verification": "Escreva a fórmula exata em um notebook e verifique se corresponde à literatura padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou Jupyter Notebook",
                                    "Referência: Livro de Análise Numérica (ex: LeVeque)"
                                  ],
                                  "tips": "Use LaTeX no notebook para equações claras; compare com esquema FTCS para destacar diferenças.",
                                  "learningObjective": "Compreender a derivação e propriedades de estabilidade do Lax-Friedrichs.",
                                  "commonMistakes": [
                                    "Confundir sinal do termo convectivo",
                                    "Esquecer a condição CFL na formulação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a grade espacial-temporal e condições iniciais",
                                  "subSteps": [
                                    "Defina parâmetros: N pontos espaciais, L domínio, Δx = L/N, Δt via CFL.",
                                    "Implemente array u0 com condição inicial (ex: pulso gaussiano ou seno).",
                                    "Configure condições de contorno periódicas ou outflow.",
                                    "Crie arrays para solução atual e anterior usando NumPy.",
                                    "Teste inicial: verifique se u0 soma a 1 (se conservativo)."
                                  ],
                                  "verification": "Execute print(u[0:5]) e confirme que matches a condição inicial esperada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use np.linspace para grade uniforme; defina função para condição inicial reutilizável.",
                                  "learningObjective": "Preparar infraestrutura numérica precisa para simulação.",
                                  "commonMistakes": [
                                    "Escolha inadequada de Δt violando CFL",
                                    "Índices errados em arrays circulares para periódicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop temporal do esquema Lax-Friedrichs",
                                  "subSteps": [
                                    "Crie loop for n in range(t_steps):",
                                    "Calcule termo médio: (u[j-1] + u[j+1])/2 para cada j.",
                                    "Calcule termo flux: - (a*dt/(2*dx)) * (u[j+1] - u[j-1]).",
                                    "Atualize u_new[j] = medio + flux.",
                                    "Copie u_new para u e aplique contornos."
                                  ],
                                  "verification": "Rode 10 passos e cheque se norma L1 é preservada (erro < 1e-10).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NumPy para vetorização",
                                    "Código do Step 2"
                                  ],
                                  "tips": "Vetorize com np.roll para vizinhos; evite loops Python internos para eficiência.",
                                  "learningObjective": "Codificar corretamente o stencil Lax-Friedrichs de forma eficiente.",
                                  "commonMistakes": [
                                    "Não tratar bordas corretamente",
                                    "Erro de sinal no termo de fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar resultados e validar estabilidade",
                                  "subSteps": [
                                    "Colete soluções em intervalos para animação.",
                                    "Plote u vs x em t=0, t_final com Matplotlib.",
                                    "Teste diferentes CFL (0.5, 0.9, 1.1) para observar instabilidade.",
                                    "Calcule erro L2 contra solução exata.",
                                    "Gere animação de propagação da onda."
                                  ],
                                  "verification": "Solução propaga sem oscilações para CFL≤1; erro L2 diminui com refinamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib",
                                    "NumPy meshgrid"
                                  ],
                                  "tips": "Use FuncAnimation para vídeo; compare com solução analítica u(x-at).",
                                  "learningObjective": "Analisar numericamente a estabilidade e precisão do esquema.",
                                  "commonMistakes": [
                                    "Plot errados por falta de reshape",
                                    "Ignorar dissipação excessiva em altas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o esquema para a equação de advecção u_t + u_x = 0 no domínio [0,2π] com u(x,0) = sin(x), condições periódicas, N=200, CFL=0.8. A onda deve propagar à direita sem dispersão, mas com leve suavização devido à dissipação artificial.",
                              "finalVerifications": [
                                "Código executa sem erros para 1000 passos temporais.",
                                "Norma L1 preservada com erro < 1e-12.",
                                "Solução em t=2π aproxima u(x,0) com erro L2 < 0.05.",
                                "Aumentar CFL>1 causa NaNs ou oscilações.",
                                "Animação mostra propagação estável da onda.",
                                "Refinamento espacial (N=400) reduz erro L2 pela metade."
                              ],
                              "assessmentCriteria": [
                                "Correção da formulação Lax-Friedrichs (peso 30%).",
                                "Eficiência e vetorização do código (20%).",
                                "Tratamento preciso de condições de contorno (20%).",
                                "Análise de estabilidade via testes CFL (15%).",
                                "Visualizações claras e análise de erro (10%).",
                                "Comentários e modularidade no código (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e fluxo compressível.",
                                "Computação: Algoritmos paralelizáveis (GPU via Numba/Cupy).",
                                "Matemática: Análise de estabilidade von Neumann.",
                                "Engenharia: Simulações CFD em reservatórios petrolíferos."
                              ],
                              "realWorldApplication": "Usado em simulações hidrodinâmicas para previsão de tsunamis, modelagem de tráfego rodoviário hiperbólico e propagação de sinais em telecomunicações, onde estabilidade simples é prioritária sobre precisão de alta ordem."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Construir esquema Lax-Wendroff",
                            "description": "Derivar o esquema Lax-Wendroff de segunda ordem usando expansão de Taylor ou método de Lax-Wendroff, aplicável a equações hiperbólicas não lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a Equação Hiperbólica e a Malha Numérica",
                                  "subSteps": [
                                    "Escreva a equação diferencial parcial hiperbólica na forma conservativa: ∂u/∂t + ∂f(u)/∂x = 0, onde f(u) pode ser não-linear.",
                                    "Defina uma malha numérica uniforme no espaço-tempo: x_j = j Δx, t_n = n Δt, com u_j^n ≈ u(x_j, t_n).",
                                    "Introduza os parâmetros de discretização: λ = Δt / Δx (número de Courant).",
                                    "Discuta brevemente a necessidade de precisão de segunda ordem em tempo e espaço.",
                                    "Verifique a consistência dimensional da equação."
                                  ],
                                  "verification": "Confirme que a notação está correta e que a equação é escrita na forma conservativa exata.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência: Livro de Análise Numérica (ex: LeVeque, Finite Difference Methods)"
                                  ],
                                  "tips": "Comece com o caso linear f(u) = a u para intuição, depois generalize para não-linear.",
                                  "learningObjective": "Compreender o problema modelo e preparar a discretização espaço-temporal básica.",
                                  "commonMistakes": [
                                    "Escrever a forma não-conservativa u_t + a u_x = 0 sem generalizar",
                                    "Confundir índices j e n",
                                    "Ignorar o papel de f(u) não-linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a Expansão de Taylor em Tempo para u^{n+1}_j",
                                  "subSteps": [
                                    "Expanda u(x_j, t_n + Δt) em série de Taylor: u_j^{n+1} = u_j^n + Δt (∂u/∂t) + (Δt)^2 / 2 (∂^2 u / ∂t^2) + O(Δt^3).",
                                    "Avalie todas as derivadas parciais no ponto (x_j, t_n).",
                                    "Ignore termos de ordem superior para obter precisão de segunda ordem.",
                                    "Escreva explicitamente os termos até (Δt)^2.",
                                    "Confirme que a expansão é local em j."
                                  ],
                                  "verification": "Escreva a expansão de Taylor truncada corretamente até O(Δt^2).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simbólica opcional (ex: SymPy)"
                                  ],
                                  "tips": "Lembre-se de que as derivadas são exatas da solução contínua, não discretas ainda.",
                                  "learningObjective": "Dominar a expansão de Taylor multivariable para previsão temporal.",
                                  "commonMistakes": [
                                    "Incluir termos O(Δt^3) acidentalmente",
                                    "Confundir ∂u/∂t com diferenças finitas",
                                    "Erros no coeficiente de (Δt)^2 / 2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir Derivadas Temporais Usando a Equação da PDE",
                                  "subSteps": [
                                    "Use a PDE para u_t = - f_x (em (x_j, t_n)).",
                                    "Derive u_{tt} = ∂/∂t (-f_x) = - ∂/∂x (f_u * u_t) = ∂/∂x (f_u * f_x), onde f_u = df/du.",
                                    "Expresse tudo em termos de derivadas espaciais: u_j^{n+1} = u_j^n - Δt f_x + (Δt)^2 / 2 ∂/∂x (f_u f_x).",
                                    "Generalize para f(u) não-linear, notando que f_u é função de u.",
                                    "Verifique para o caso linear f(u) = a u, onde u_{tt} = a^2 u_{xx}."
                                  ],
                                  "verification": "Mostre que u_{tt} foi corretamente expressa como derivada espacial de segunda ordem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas da PDE hiperbólica"
                                  ],
                                  "tips": "Use a regra da cadeia cuidadosamente para não-lineares; pratique com f(u) = u^2 / 2 (Burgers).",
                                  "learningObjective": "Converter derivadas temporais em espaciais via substituição da PDE.",
                                  "commonMistakes": [
                                    "Erros na cadeia: esquecer f_u em u_{tt}",
                                    "Assumir linearidade prematuramente",
                                    "Sinais errados em f_x"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discretizar Espacialmente e Obter o Esquema Lax-Wendroff Final",
                                  "subSteps": [
                                    "Aproxime diferenças espaciais centradas: f_x|_j ≈ (f_{j+1/2} - f_{j-1/2}) / Δx, com f_{j±1/2} = f( (u_j + u_{j±1})/2 ).",
                                    "Para o termo não-linear: ∂_x (f_u f_x) ≈ [A_{j+1/2} (f_{j+1} - f_j) - A_{j-1/2} (f_j - f_{j-1}) ] / (Δx)^2, A = f_u.",
                                    "Substitua na expansão Taylor para obter u_j^{n+1} = u_j^n - σ/2 (f_{j+1}^n - f_{j-1}^n) + (σ^2 / 2) [A_{j+1/2}^n (f_{j+1}^n - f_j^n) - A_{j-1/2}^n (f_j^n - f_{j-1}^n)], σ=Δt/Δx.",
                                    "Verifique truncamento de erro O(Δt^3 + Δt Δx^2 + Δx^3).",
                                    "Confirme estabilidade via condição CFL |λ| ≤ 1."
                                  ],
                                  "verification": "Derive o stencil tridiagonal explícito e compare com a forma padrão do Lax-Wendroff.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software para stencil (opcional: MATLAB/Python)"
                                  ],
                                  "tips": "Para linear, reduza a ν^2 /2 laplaciano; teste numericamente depois.",
                                  "learningObjective": "Construir o esquema de diferenças finitas de segunda ordem explícito.",
                                  "commonMistakes": [
                                    "Usar forward/backward em vez de centered",
                                    "Erros em A_{j±1/2}",
                                    "Ignorar média em fluxos não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de Burgers u_t + (u^2 / 2)_x = 0, com u(x,0) = sin(π x) em [0,1], Δx=0.01, Δt=0.9 Δx (CFL=0.9), implemente o esquema em Python usando NumPy: compute f(u)=u**2/2, A(u)=u, fluxos em interfaces, avance 100 passos e plote u vs x para verificar preservação de forma de onda sem dispersão excessiva.",
                              "finalVerifications": [
                                "Expansão Taylor truncada corretamente até segunda ordem.",
                                "u_{tt} derivada como ∂_x (f_u f_x) exata.",
                                "Discretização espacial usa diferenças centradas com fluxos consistentes.",
                                "Esquema final é tridiagonal: depende de u_{j-1}^n, u_j^n, u_{j+1}^n.",
                                "Verificação de precisão: erro de truncamento O(Δt^2 + Δx^2).",
                                "Condição de estabilidade CFL derivada ou citada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação Taylor e substituições PDE.",
                                "Precisão de segunda ordem demonstrada via análise de erro.",
                                "Tratamento adequado de não-linearidades em f_u.",
                                "Consistência com limites Δt→0, Δx→0.",
                                "Estabilidade condicional identificada (CFL ≤1).",
                                "Clareza na apresentação do stencil final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas não-lineares e choques em mecânica de fluidos.",
                                "Computação: Implementação de algoritmos numéricos em Python/MATLAB para PDEs.",
                                "Engenharia: Simulações CFD em aerodinâmica e hidrodinâmica.",
                                "Matemática Aplicada: Análise de estabilidade von Neumann e erros de truncamento."
                              ],
                              "realWorldApplication": "O esquema Lax-Wendroff é usado em simulações numéricas de equações hiperbólicas como as de Euler em dinâmica de gases para prever choques supersônicos em foguetes, tsunamis em modelos oceânicos, ou tráfego veicular não-linear em engenharia de transportes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Análise de Estabilidade e Condição CFL",
                        "description": "Examina a estabilidade dos métodos explícitos através da condição de Courant-Friedrichs-Lewy (CFL), analisando o amplificador de amplificação via método de von Neumann.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Calcular o número de CFL",
                            "description": "Determinar o número de Courant λ = a Δt / Δx para esquemas explícitos e verificar os limites de estabilidade |λ| ≤ 1 para upwind e Lax-Friedrichs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e a fórmula do número de CFL",
                                  "subSteps": [
                                    "Recordar a equação hiperbólica de transporte linear: ∂u/∂t + a ∂u/∂x = 0, onde a é a velocidade de advecção.",
                                    "Explicar o conceito de condição CFL: critério de estabilidade para esquemas explícitos em métodos de diferenças finitas.",
                                    "Derivar ou memorizar a fórmula do número de Courant λ = a Δt / Δx, onde Δt é o passo de tempo e Δx é o passo espacial.",
                                    "Discutir a importância da propagação da informação no domínio de dependência.",
                                    "Identificar que para esquemas explícitos como upwind e Lax-Friedrichs, a estabilidade requer |λ| ≤ 1."
                                  ],
                                  "verification": "Escrever corretamente a fórmula λ e explicar verbalmente sua origem em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de equações hiperbólicas)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Visualize a característica da equação: a informação viaja com velocidade a, então Δt deve ser ≤ Δx / |a|.",
                                  "learningObjective": "Entender o significado físico e matemático do número CFL e sua fórmula básica.",
                                  "commonMistakes": [
                                    "Confundir λ com outros números de Courant em difusão",
                                    "Esquecer o valor absoluto em |λ| para estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os parâmetros do problema",
                                  "subSteps": [
                                    "Extrair o valor de a (velocidade de advecção) da equação ou condição de contorno.",
                                    "Determinar Δx do malha espacial usada no esquema de diferenças finitas.",
                                    "Obter Δt do passo temporal proposto no algoritmo explícito.",
                                    "Verificar consistência de unidades: a em m/s, Δx em m, Δt em s.",
                                    "Anotar os valores em uma tabela para facilitar o cálculo."
                                  ],
                                  "verification": "Listar corretamente a, Δx e Δt com unidades em uma tabela organizada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de problema impresso ou digital",
                                    "Planilha Excel ou papel quadriculado"
                                  ],
                                  "tips": "Sempre confirme se a é positiva ou negativa, pois afeta o esquema upwind.",
                                  "learningObjective": "Saber extrair e organizar os parâmetros necessários para o cálculo de λ.",
                                  "commonMistakes": [
                                    "Usar Δx errado de uma malha não uniforme",
                                    "Ignorar o sinal de a"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o número de CFL λ",
                                  "subSteps": [
                                    "Aplicar a fórmula λ = (a * Δt) / Δx usando os valores identificados.",
                                    "Realizar o cálculo aritmético com precisão, considerando casas decimais.",
                                    "Calcular |λ| para considerar estabilidade independentemente do sinal de a.",
                                    "Repetir o cálculo com uma calculadora para verificação cruzada.",
                                    "Registrar o resultado com pelo menos 3 casas decimais."
                                  ],
                                  "verification": "Comparar o cálculo manual com o resultado de uma calculadora; diferença < 0.001.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel para cálculos intermediários"
                                  ],
                                  "tips": "Use parênteses na fórmula para evitar erros de precedência: |a * Δt / Δx|.",
                                  "learningObjective": "Executar o cálculo numérico preciso do número CFL.",
                                  "commonMistakes": [
                                    "Erro de divisão: inverter Δt e Δx",
                                    "Esquecer multiplicar por a"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar os limites de estabilidade para upwind e Lax-Friedrichs",
                                  "subSteps": [
                                    "Para esquema upwind: checar se |λ| ≤ 1; se sim, estável; senão, instável.",
                                    "Para esquema Lax-Friedrichs: confirmar o mesmo critério |λ| ≤ 1.",
                                    "Comparar os resultados: ambos requerem o mesmo limite, mas Lax-Friedrichs é menos preciso.",
                                    "Se |λ| > 1, sugerir ajuste: reduzir Δt ou aumentar Δx.",
                                    "Documentar a conclusão: 'Estável' ou 'Instável' com justificativa."
                                  ],
                                  "verification": "Escrever uma declaração clara: 'Para upwind: |λ| = X ≤ 1 → Estável'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de critérios de estabilidade",
                                    "Exemplo resolvido de livro-texto"
                                  ],
                                  "tips": "Lembre-se: upwind é de primeira ordem, Lax-Friedrichs introduz dissipação artificial.",
                                  "learningObjective": "Aplicar e interpretar os critérios de estabilidade CFL para esquemas específicos.",
                                  "commonMistakes": [
                                    "Pensar que Lax-Friedrichs tem limite diferente",
                                    "Ignorar |λ| e usar λ diretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação de advecção u_t + 2 u_x = 0 (a=2), com malha Δx=0.1 m e Δt=0.04 s. Calcule λ = 2*0.04/0.1 = 0.8. Para upwind e Lax-Friedrichs: |0.8| ≤ 1 → Estável. Se Δt=0.06 s, λ=1.2 >1 → Instável, ajuste Δt≤0.05 s.",
                              "finalVerifications": [
                                "Calcular λ corretamente para um problema dado com erro <1%.",
                                "Identificar corretamente se o esquema é estável ou instável.",
                                "Explicar por que |λ| >1 causa instabilidade.",
                                "Ajustar Δt para satisfazer CFL em um caso instável.",
                                "Comparar estabilidade entre upwind e Lax-Friedrichs.",
                                "Resolver um problema similar sem consulta."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de λ (100% correto).",
                                "Correta aplicação do critério |λ| ≤ 1 para ambos esquemas.",
                                "Explicação clara da interpretação física.",
                                "Identificação de erros comuns e correções.",
                                "Capacidade de generalizar para outros valores de a.",
                                "Documentação organizada dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e características em PDEs hiperbólicas.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD em dinâmica de fluidos.",
                                "Matemática Aplicada: Análise de estabilidade von Neumann.",
                                "Ciência de Dados: Modelagem temporal em séries temporais."
                              ],
                              "realWorldApplication": "Em simulações numéricas de previsão meteorológica (modelos de ondas), fluxo de tráfego rodoviário (equações de LWR) e hidrodinâmica computacional (CFL garante simulações estáveis sem oscilações artificiais)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Aplicar análise de von Neumann",
                            "description": "Realizar análise de estabilidade de von Neumann para esquemas explícitos, computando o símbolo de amplificação g(θ) e garantindo |g(θ)| ≤ 1 para todos os modos de Fourier.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e linearizar o esquema numérico explícito",
                                  "subSteps": [
                                    "Identifique o esquema numérico explícito para a equação hiperbólica, como u_j^{n+1} = u_j^n - λ (u_{j+1}^n - u_{j-1}^n)/2.",
                                    "Verifique se o esquema é linear; se não for, linearize em torno de um estado de fundo constante.",
                                    "Defina os parâmetros: passo espacial Δx, temporal Δt, e número de Courant λ = a Δt / Δx.",
                                    "Escreva a stencil do esquema em termos de vizinhos imediatos.",
                                    "Confirme a forma matricial ou pseudo-espectral para análise de von Neumann."
                                  ],
                                  "verification": "Esquema escrito corretamente em forma linearizada com stencil explícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e lápis, calculadora.",
                                  "tips": "Sempre normalize λ para simplificar cálculos iniciais.",
                                  "learningObjective": "Compreender a estrutura do esquema explícito e prepará-lo para análise modal.",
                                  "commonMistakes": "Esquecer de linearizar esquemas não-lineares ou confundir índices j e n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a ansatz de Fourier e derivar a relação de amplificação",
                                  "subSteps": [
                                    "Assuma solução modal: u_j^n = g^n e^{i θ j}, onde θ = k Δx é o número de onda.",
                                    "Substitua na equação do esquema: u_j^{n+1} = soma de coeficientes vezes u_{m}^n.",
                                    "Simplifique usando propriedades exponenciais: e^{i θ (j±1)} = e^{i θ j} e^{± i θ}.",
                                    "Divida por g^n e e^{i θ j} para isolar g(θ).",
                                    "Obtenha a equação polinomial para g(θ), como g = 1 - i λ sin(θ)."
                                  ],
                                  "verification": "Equação explícita para g(θ) derivada corretamente para o esquema dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software simbólico como SymPy (opcional).",
                                  "tips": "Use notação complexa consistentemente; verifique com θ=0 para preservar constantes.",
                                  "learningObjective": "Dominar a substituição de Fourier para obter o símbolo de amplificação.",
                                  "commonMistakes": "Erro no sinal de exponenciais (±iθ) ou divisão incorreta por termos comuns."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o símbolo de amplificação g(θ)",
                                  "subSteps": [
                                    "Resolva a equação para g(θ), identificando raízes se polinomial de grau >1.",
                                    "Selecione a raiz principal (com |g|≈1 para θ pequeno).",
                                    "Expresse g(θ) em forma polar: |g(θ)| e arg(g(θ)).",
                                    "Plote ou tabule |g(θ)| para θ de 0 a 2π.",
                                    "Identifique o domínio de θ relevante (modos de Fourier)."
                                  ],
                                  "verification": "Função g(θ) computada e graficada com módulo correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/MATLAB para plotagem, ou papel para θ discretos.",
                                  "tips": "Para esquemas simples, g(θ) é explícito; use fsolve para raízes numéricas.",
                                  "learningObjective": "Calcular precisamente o símbolo de amplificação como função de θ.",
                                  "commonMistakes": "Escolher raiz errada (instável) ou falhar em normalizar para θ=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar estabilidade e condição CFL",
                                  "subSteps": [
                                    "Calcule sup_θ |g(θ)| e verifique se ≤1 para todos θ ∈ [0, 2π].",
                                    "Derive a condição CFL: encontre max λ tal que max_θ |g(θ,λ)| ≤1.",
                                    "Analise numericamente: plote |g(θ)| vs θ para vários λ.",
                                    "Identifique modos instáveis (alta frequência, θ≈π).",
                                    "Conclua com região de estabilidade no plano (λ, outros params)."
                                  ],
                                  "verification": "Condição |g(θ)| ≤1 ∀θ confirmada e CFL explicitada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Script Python para varredura de θ e λ, gráficos.",
                                  "tips": "Use meshgrid para contour plots de |g| no plano complexo.",
                                  "learningObjective": "Avaliar estabilidade von Neumann e derivar condições práticas.",
                                  "commonMistakes": "Ignorar θ=π (modo xadrez) ou confundir estabilidade von Neumann com Lax."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e documentar a análise completa",
                                  "subSteps": [
                                    "Compare com literatura para esquemas conhecidos (ex: upwind estável para λ≤1).",
                                    "Teste numericamente: rode simulação com λ crítico e cheque crescimento.",
                                    "Documente g(θ), |g|max, e CFL em relatório.",
                                    "Discuta limitações (assume periodicidade, linearidade).",
                                    "Sugira melhorias como esquemas implícitos."
                                  ],
                                  "verification": "Relatório com análise, plots e validação numérica completa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código de simulação FD (Python/Octave), relatório template.",
                                  "tips": "Sempre valide analítico com numérico para confiança.",
                                  "learningObjective": "Integrar análise teórica com verificação prática.",
                                  "commonMistakes": "Não testar numericamente ou ignorar não-linearidades reais."
                                }
                              ],
                              "practicalExample": "Para o esquema upwind explícito na equação de advecção u_t + a u_x =0: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), derive g(θ) = 1 - λ (1 - e^{-iθ}), |g(θ)| = |1 - λ + λ cosθ + i λ sinθ|, e mostre estabilidade para λ ≤1.",
                              "finalVerifications": [
                                "g(θ) derivado corretamente para esquema dado.",
                                "Gráfico de |g(θ)| ≤1 para todos θ.",
                                "Condição CFL explicitada (ex: λ ≤ valor crítico).",
                                "Validação numérica sem crescimento exponencial.",
                                "Relatório documenta limitações e conexões teóricas.",
                                "Análise cobre modos baixa e alta frequência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de g(θ) (100% correto).",
                                "Identificação correta da condição de estabilidade CFL.",
                                "Qualidade dos plots e análise numérica.",
                                "Explicação clara de modos instáveis.",
                                "Integração de teoria von Neumann com prática.",
                                "Ausência de erros algébricos comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e dispersão em equações hiperbólicas.",
                                "Computação: Implementação de solvers FD em Python/MATLAB.",
                                "Engenharia: Simulações CFD e controle numérico.",
                                "Matemática: Análise complexa e teoria de Fourier."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) para previsão de tempo/chocagens, garantindo simulações estáveis sem amplificação artificial de erros numéricos em supercomputadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Identificar instabilidade no FTCS",
                            "description": "Demonstrar a instabilidade incondicional do esquema FTCS para equações hiperbólicas através da análise de von Neumann, onde |g(θ)| > 1 para certos θ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema FTCS para equações hiperbólicas",
                                  "subSteps": [
                                    "Lembre a equação hiperbólica modelo: u_t + a u_x = 0 (equação de adveção linear).",
                                    "Escreva o esquema FTCS: u_j^{n+1} = u_j^n - (r/2) (u_{j+1}^n - u_{j-1}^n), onde r = a Δt / Δx.",
                                    "Discuta as aproximações: forward em tempo (O(Δt)), centered em espaço (O(Δx^2)).",
                                    "Identifique por que é explícito e suas implicações para estabilidade.",
                                    "Anote os operadores de diferença: δ_x u_j = (u_{j+1} - u_{j-1})/(2Δx)."
                                  ],
                                  "verification": "Escreva corretamente a equação de diferenças FTCS em uma folha e confirme com referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, livro de análise numérica (ex: LeVeque 'Finite Difference Methods')",
                                  "tips": "Sempre defina r claramente para evitar confusão com CFL.",
                                  "learningObjective": "Compreender a discretização FTCS e suas propriedades de truncamento.",
                                  "commonMistakes": "Confundir FTCS com FTFS (forward time forward space); usar Δx incorretamente no operador centered."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise de von Neumann",
                                  "subSteps": [
                                    "Explique o método: assume solução modal u_j^n = g^n e^{i θ j Δx}, onde θ é número de onda.",
                                    "Substitua a forma de Fourier na equação de diferenças para obter equação algébrica para g.",
                                    "Discuta por que modos de alta frequência (θ ≈ π) são críticos para estabilidade.",
                                    "Defina o fator de amplificação g(θ) e o critério de estabilidade |g(θ)| ≤ 1 para todo θ ∈ [0, π].",
                                    "Prepare notação: ξ = e^{i θ}, para simplificar substituição."
                                  ],
                                  "verification": "Derive a forma geral da substituição Fourier e verifique que u_{j±1}^n → ξ^{±1} u_j^n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta, calculadora simbólica (opcional: SymPy em Python)",
                                  "tips": "Use ξ = e^{iθ} para manter notação complexa limpa.",
                                  "learningObjective": "Dominar a formulação da análise de von Neumann para esquemas de diferenças finitas.",
                                  "commonMistakes": "Esquecer o fator g^n na amplificação; confundir θ com k Δx."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o fator de amplificação g(θ) para FTCS",
                                  "subSteps": [
                                    "Substitua u_j^n = g^n e^{i θ j} na FTCS: g^{n+1} e^{i θ j} = g^n e^{i θ j} - (r/2) g^n (e^{i θ (j+1)} - e^{i θ (j-1)}).",
                                    "Simplifique: g = 1 - (r/2) (e^{iθ} - e^{-iθ}) = 1 - i r sin θ.",
                                    "Escreva g(θ) = 1 - i r sin(θ).",
                                    "Verifique para θ=0: g=1 (modo constante preservado).",
                                    "Anote a forma complexa explicitamente."
                                  ],
                                  "verification": "Calcule g(θ) para r=1, θ=π/2 e confirme g = 1 - i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, software para cálculo simbólico (MATLAB ou Python)",
                                  "tips": "Trigonométrica: e^{iθ} - e^{-iθ} = 2i sin θ, divida por 2 para (r/2)*2i sinθ = i r sinθ.",
                                  "learningObjective": "Calcular precisamente g(θ) para esquemas lineares constantes.",
                                  "commonMistakes": "Erro de sinal no operador centered; esquecer o i em sinθ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar |g(θ)| e demonstrar instabilidade",
                                  "subSteps": [
                                    "Calcule |g(θ)|^2 = Re(g)^2 + Im(g)^2 = 1^2 + (r sin θ)^2 = 1 + r^2 sin^2 θ.",
                                    "Mostre que |g(θ)| = sqrt(1 + r^2 sin^2 θ) ≥ 1, e >1 para qualquer r>0 e sinθ ≠0.",
                                    "Examine casos: para θ→0, |g|≈1; para θ=π/2, |g|=sqrt(1+r^2)>1.",
                                    "Conclua instabilidade incondicional: não existe r tal que |g|≤1 ∀θ.",
                                    "Opcional: plote |g(θ)| vs θ para r fixo."
                                  ],
                                  "verification": "Plote ou tabule |g(θ)| para θ de 0 a π e confirme máximo >1.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel e caneta, Python/MATLAB para plot (numpy, matplotlib)",
                                  "tips": "Foque em |g|^2 para evitar raízes; independe de a (assumido positivo).",
                                  "learningObjective": "Interpretar |g(θ)|>1 como crescimento exponencial de erros.",
                                  "commonMistakes": "Achar estável porque para r=0 é trivial; ignorar modos oscilatórios."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir e discutir implicações",
                                  "subSteps": [
                                    "Resuma: FTCS amplifica todos os modos não-constantes, levando a blow-up numérico.",
                                    "Compare com esquemas estáveis como Lax-Friedrichs ou upwind.",
                                    "Discuta condição CFL geral para hiperbólicas.",
                                    "Relacione com dissipação/ dispersão numérica.",
                                    "Registre lições para escolha de esquemas em PDEs hiperbólicas."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que FTCS falha em aplicações reais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, notas anteriores",
                                  "tips": "Pense em termos físicos: amplificação de ruído numérico como instabilidade física.",
                                  "learningObjective": "Aplicar análise de estabilidade para selecionar métodos numéricos apropriados.",
                                  "commonMistakes": "Confundir instabilidade numérica com instabilidade física."
                                }
                              ],
                              "practicalExample": "Para u_t + u_x = 0 com r=1, g(θ) = 1 - i sin θ. Então |g(π/2)| = sqrt(1 + 1) = √2 ≈1.414 >1, significando que o modo θ=π/2 cresce 41% por passo de tempo, levando a oscilações 2Δx que explodem.",
                              "finalVerifications": [
                                "Derivação correta de g(θ) = 1 - i r sin θ.",
                                "Cálculo preciso de |g(θ)|^2 = 1 + r^2 sin^2 θ >1.",
                                "Identificação de θ onde |g| é máximo (ex: θ=π/2).",
                                "Explicação verbal da instabilidade incondicional.",
                                "Plot ou tabela mostrando |g(θ)| >1 para vários θ.",
                                "Comparação com esquema estável (ex: upwind)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g(θ) (sem erros algébricos).",
                                "Compreensão conceitual da análise von Neumann e seu propósito.",
                                "Análise qualitativa/quantitativa correta de |g(θ)|.",
                                "Identificação clara da instabilidade incondicional (independente de r).",
                                "Uso apropriado de notação e convenções (θ, r, ξ).",
                                "Capacidade de generalizar para outras equações hiperbólicas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e análise de Fourier em sinais.",
                                "Computação: Implementação de solvers numéricos e análise de erros em CFD.",
                                "Engenharia: Estabilidade em simulações de fluidos dinâmicos e acústica.",
                                "Matemática Aplicada: Teoria de PDEs e métodos espectrais."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou hidrodinâmicas (ex: previsão de tsunamis), usar FTCS causaria explosão numérica imediata devido a amplificação de modos de alta frequência, levando a resultados inúteis; análise von Neumann guia escolha de esquemas Lax-Wendroff estáveis sob CFL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Consistência, Convergência e Erros Numéricos",
                        "description": "Discute consistência (ordem de truncamento), convergência (teorema Lax) e erros associados como dispersão (fases erradas) e dissipação (amortecimento artificial de ondas).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Verificar consistência do esquema",
                            "description": "Calcular o erro de truncamento local para esquemas explícitos, confirmando consistência de primeira ou segunda ordem em tempo e espaço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a equação hiperbólica e o esquema explícito",
                                  "subSteps": [
                                    "Escreva a equação diferencial parcial (EDP) hiperbólica padrão, como a equação da onda: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Defina o esquema explícito de diferenças finitas, por exemplo, o esquema de Lax-Friedrichs ou FTCS: u^{n+1}_j = u^n_{j+1} + u^n_{j-1} - 2u^n_j + r² (u^{n}_{j+1} - 2u^n_j + u^n_{j-1}), onde r = c Δt / Δx.",
                                    "Identifique os passos de tempo (Δt) e espaço (Δx), e os operadores de diferença forward/backward/central.",
                                    "Anote os símbolos necessários: u(x,t), índices j para espaço, n para tempo."
                                  ],
                                  "verification": "Confirme que a EDP e o esquema estão corretamente anotados e combinam com referências padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, livro de análise numérica (ex: LeVeque), calculadora simbólica opcional.",
                                  "tips": "Use notação consistente para evitar confusão entre índices espaciais e temporais.",
                                  "learningObjective": "Entender a estrutura da EDP hiperbólica e sua discretização explícita.",
                                  "commonMistakes": "Confundir operadores de diferença (ex: forward em vez de central para segunda derivada)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar expansões de Taylor multivariáveis",
                                  "subSteps": [
                                    "Expanda u(x_j, t_{n+1}) em torno de (x_j, t_n) até ordem 3 ou 4: u + Δt u_t + (Δt)²/2 u_tt + (Δt)³/6 u_ttt + O(Δt⁴).",
                                    "Expanda termos espaciais: u(x_{j+1}, t_n) = u + Δx u_x + (Δx)²/2 u_xx + (Δx)³/6 u_xxx + O(Δx⁴), e similar para j-1.",
                                    "Substitua derivadas temporais por espaciais usando a EDP: u_tt = c² u_xx, u_ttt = c² u_xxt, etc.",
                                    "Colete termos até ordens desejadas em Δt e Δx.",
                                    "Verifique simetria nos termos espaciais para diferenças centrais."
                                  ],
                                  "verification": "Os coeficientes das expansões coincidem com fórmulas padrão de Taylor para PDEs.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel quadriculado, software simbólico como SymPy ou Mathematica para verificação.",
                                  "tips": "Mantenha track de ordens com O(Δt^k, Δx^m) explicitamente.",
                                  "learningObjective": "Dominar expansões de Taylor para análise de erros em métodos numéricos.",
                                  "commonMistakes": "Esquecer termos ímpares em expansões simétricas ou errar substituições da EDP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o erro de truncamento local (LTE)",
                                  "subSteps": [
                                    "Substitua as expansões no esquema numérico para obter a equação discreta aproximada.",
                                    "Subtraia a EDP original (multiplicada por Δt) da aproximação discreta para isolar o LTE: τ = [esquema - EDP]/Δt.",
                                    "Simplifique τ coletando termos: τ = O(Δt^p + Δx^q).",
                                    "Identifique os termos líderes de erro em tempo (ex: Δt u_ttt/6) e espaço (ex: Δx² u_xxxx/12).",
                                    "Confirme que τ → 0 quando Δt, Δx → 0."
                                  ],
                                  "verification": "O LTE é expresso como τ = a Δt + b Δx² + termos superiores, com a e b explícitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, planilha para álgebra simbólica.",
                                  "tips": "Normalize dividindo pelo fator de tempo para LTE padrão.",
                                  "learningObjective": "Calcular precisamente o erro local de truncamento para esquemas explícitos.",
                                  "commonMistakes": "Não dividir corretamente pelo Δt ou ignorar fatores c² nas substituições."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar e confirmar a ordem de consistência",
                                  "subSteps": [
                                    "Analise os termos dominantes em τ: se O(Δt + Δx²), consistente de primeira ordem em tempo e segunda em espaço.",
                                    "Verifique consistência de primeira ordem se max(p,q) ≥1, segunda se ≥2.",
                                    "Compare com literatura para o esquema específico (ex: FTCS é consistente O(Δt + Δx²)).",
                                    "Teste numericamente com valores pequenos de Δt/Δx para validar.",
                                    "Documente: 'Consistente de ordem 1 em tempo e 2 em espaço'."
                                  ],
                                  "verification": "Declaração clara da ordem com justificativa dos termos LTE.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python/MATLAB para teste numérico opcional.",
                                  "tips": "Lembre: consistência requer LTE →0, ordem é o expoente mínimo.",
                                  "learningObjective": "Classificar rigorosamente a consistência de esquemas numéricos.",
                                  "commonMistakes": "Confundir ordem global com local ou ignorar dependência CFL."
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS na equação da onda u_tt = u_xx: expansões mostram LTE = (Δt²/12) u_tttt - (Δx²/12) u_xxxx, confirmando consistência de segunda ordem em tempo e espaço (assumindo substituições).",
                              "finalVerifications": [
                                "LTE calculado corretamente e tende a zero com refinamento de malha.",
                                "Ordens em tempo e espaço identificadas com termos líderes explícitos.",
                                "Expansões de Taylor validadas por simetria e substituições da EDP.",
                                "Comparação com esquema conhecido (ex: Lax-Wendroff é O(Δt² + Δx²)).",
                                "Teste numérico opcional confirma comportamento assintótico.",
                                "Documentação completa sem erros algébricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expansões de Taylor (coeficientes corretos).",
                                "Cálculo exato do LTE sem omissões de termos.",
                                "Identificação correta das ordens de consistência.",
                                "Justificativa matemática rigorosa e clara.",
                                "Uso apropriado de notação e substituições da EDP.",
                                "Ausência de erros comuns como confusão de índices."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas/sísmicas via diferenças finitas.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Análise de estabilidade em simulações CFD.",
                                "Estatística: Análise de erros de aproximação em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, verificar consistência garante precisão na propagação de ondas, evitando erros em modelos geofísicos usados por agências como USGS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Analisar convergência via teorema de Lax",
                            "description": "Aplicar o teorema de Lax-Richtmyer: consistência + estabilidade implica convergência, ilustrando com exemplos numéricos para métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do Teorema de Lax-Richtmyer",
                                  "subSteps": [
                                    "Estude a definição de convergência para esquemas numéricos de diferenças finitas em equações hiperbólicas.",
                                    "Revise consistência: verifique se o esquema aproxima a PDE localmente, calculando o erro de truncamento.",
                                    "Revise estabilidade: entenda a amplificação de erros via análise de von Neumann ou matriz.",
                                    "Leia a enunciação do teorema: consistência + estabilidade implica convergência.",
                                    "Discuta limitações do teorema (equações lineares, condições iniciais suaves)."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando cada termo e o teorema; revise com um colega ou professor.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica de LeVeque', notas de aula, calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Use analogias físicas: consistência é precisão local, estabilidade é controle de perturbações.",
                                  "learningObjective": "Dominar os componentes teóricos necessários para aplicar o teorema de Lax.",
                                  "commonMistakes": [
                                    "Confundir consistência com precisão global",
                                    "Ignorar que estabilidade é necessária mas não suficiente sozinha"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Consistência de um Método Explícito",
                                  "subSteps": [
                                    "Escolha um método explícito, ex: esquema Lax-Friedrichs para a equação de advecção u_t + a u_x = 0.",
                                    "Expanda o esquema em série de Taylor e compare com a PDE original.",
                                    "Calcule a ordem de consistência (ex: O(Δt) + O(Δx^2)).",
                                    "Implemente numericamente o erro de truncamento para diferentes Δt e Δx.",
                                    "Confirme que o erro tende a zero quando Δt, Δx → 0."
                                  ],
                                  "verification": "Produza um relatório com expansões de Taylor e tabela numérica mostrando erro → 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB com NumPy/SciPy",
                                    "Papel e lápis para expansões manuais"
                                  ],
                                  "tips": "Sempre normalize pelo tamanho da malha para medir consistência adequadamente.",
                                  "learningObjective": "Aplicar análise de consistência a métodos explícitos para hiperbólicas.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior na expansão de Taylor",
                                    "Usar passos de tempo/deslocamento inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade do Método",
                                  "subSteps": [
                                    "Aplique análise de von Neumann: assuma solução u_j^n = g^n e^{i k j Δx}, encontre |g| ≤ 1.",
                                    "Para Lax-Friedrichs, derive condição CFL: |a Δt / Δx| ≤ 1.",
                                    "Teste numericamente: rode simulações com CFL >1 e observe blow-up.",
                                    "Compare com outros métodos explícitos como FTCS (instável).",
                                    "Documente regiões de estabilidade no plano (Δt, Δx)."
                                  ],
                                  "verification": "Gere gráfico de amplificação |g(k)| vs. número de onda k, confirmando |g| ≤ 1.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python para análise von Neumann",
                                    "Software de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Comece com equações lineares escalares para simplicidade antes de sistemas.",
                                  "learningObjective": "Dominar verificação de estabilidade via von Neumann para métodos explícitos.",
                                  "commonMistakes": [
                                    "Ignorar dependência em k (número de onda)",
                                    "Confundir estabilidade com dissipatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema e Ilustrar Convergência Numericamente",
                                  "subSteps": [
                                    "Confirme consistência e estabilidade para o método escolhido.",
                                    "Pelo teorema de Lax, conclua convergência.",
                                    "Simule solução exata vs. numérica para malhas refinadas (Δx halved, Δt ajustado).",
                                    "Meça norma do erro L2 ou L∞ e plote vs. h = Δx.",
                                    "Observe taxa de convergência (ex: ordem 1 para Lax-Friedrichs)."
                                  ],
                                  "verification": "Gráficos de erro vs. h mostrando redução, relatório final com conclusão.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Solução exata via d'Alembert para equação de onda",
                                    "Código de simulação refinável"
                                  ],
                                  "tips": "Use malhas uniformes e condições periódicas para simplicidade.",
                                  "learningObjective": "Demonstrar convergência prática via teorema de Lax com exemplos numéricos.",
                                  "commonMistakes": [
                                    "Não refinar Δt proporcionalmente a Δx",
                                    "Escolher condições iniciais que mascaram instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Extensões e Contraexemplos",
                                  "subSteps": [
                                    "Discuta falhas: métodos consistentes mas instáveis (ex: FTCS).",
                                    "Estenda a sistemas lineares ou não-lineares (hipótese Lax).",
                                    "Implemente exemplo numérico de não-convergência por falta de estabilidade.",
                                    "Compare com teoremas mais avançados (Godunov).",
                                    "Resuma lições para design de esquemas."
                                  ],
                                  "verification": "Apresentação curta (5 min) com contraexemplo rodando ao vivo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Códigos dos steps anteriores",
                                    "Referências: Richtmyer & Morton"
                                  ],
                                  "tips": "Sempre valide com múltiplos exemplos para robustez.",
                                  "learningObjective": "Entender limitações e aplicações ampliadas do teorema.",
                                  "commonMistakes": [
                                    "Superestimar generalidade do teorema para PDEs não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com esquema Lax-Friedrichs em [0,2π] periódica, u0(x)=sen(x). Use Δx=0.1, CFL=0.5. Refine malha 4x, meça erro L2 < 0.01, confirmando convergência de ordem ~1.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema de Lax-Richtmyer.",
                                "Calcula expansão de Taylor para consistência de Lax-Friedrichs.",
                                "Deriva condição de estabilidade via von Neumann.",
                                "Produz gráfico de erro numérico decrescendo com refinamento.",
                                "Identifica um contraexemplo de não-convergência.",
                                "Explica intuição: 'consistência local + estabilidade global → convergência'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de consistência (ordem correta: 4/5 pontos).",
                                "Correção na condição de estabilidade (CFL derivada: 5/5 pontos).",
                                "Qualidade dos gráficos numéricos e taxas de convergência (3/5 pontos).",
                                "Profundidade na discussão de limitações (4/5 pontos).",
                                "Clareza no relatório e exemplos práticos (3/5 pontos).",
                                "Conexão com aplicações reais (2/5 pontos)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação em meios.",
                                "Computação: Implementação eficiente em GPU para simulações PDE.",
                                "Engenharia: Análise de estabilidade em CFD (dinâmica de fluidos computacional).",
                                "Estatística: Análise de erros numéricos e convergência probabilística."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, o teorema garante que esquemas explícitos para equações de ondas atmosféricas convirjam ao refinar malhas, permitindo previsões precisas de furacões sem blow-up numérico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Avaliar dispersão e dissipação",
                            "description": "Quantificar dispersão (erro de fase) e dissipação (damping) através do símbolo de amplificação, comparando com a solução exata para ondas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação da onda e a relação de dispersão exata",
                                  "subSteps": [
                                    "Escreva a equação da onda 1D: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Derive a solução exata via análise de Fourier: assuma u(x,t) = e^{i(kx - ωt)}, obtenha ω = c k (relação de dispersão exata).",
                                    "Calcule a fase exata por unidade de tempo: φ_exata = c k Δt.",
                                    "Discuta o significado físico: ondas sem dispersão ou dissipação na solução exata.",
                                    "Anote os parâmetros: passo espacial Δx, temporal Δt, número de Courant ν = c Δt / Δx."
                                  ],
                                  "verification": "Verifique se a relação ω = c k está correta e se φ_exata foi computada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; calculadora.",
                                  "tips": "Use notação complexa para facilitar derivações de Fourier.",
                                  "learningObjective": "Compreender a propagação exata de ondas e sua relação de dispersão.",
                                  "commonMistakes": "Confundir ω com k ou esquecer o sinal na fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o esquema de diferenças finitas explícito",
                                  "subSteps": [
                                    "Escolha um esquema explícito, ex: Leapfrog central: u_j^{n+1} = 2u_j^n - u_j^{n-1} + ν² (u_{j+1}^n - 2u_j^n + u_{j-1}^n).",
                                    "Assuma solução numérica via von Neumann: u_j^n = g^n e^{i k j Δx}.",
                                    "Substitua na discretização para obter a equação característica para g.",
                                    "Resolva para o fator de amplificação G (ou símbolo de amplificação).",
                                    "Identifique |G| (módulo) e arg(G) (fase numérica)."
                                  ],
                                  "verification": "Confirme que a equação para G^{n+1} - 2G^n + G^{n-1} = ν² (e^{iθ} - 2 + e^{-iθ}) G^n, com θ = k Δx.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta; software simbólico como SymPy ou Mathematica opcional.",
                                  "tips": "Defina θ = k Δx para simplificar expressões trigonométricas.",
                                  "learningObjective": "Dominar a análise de von Neumann para esquemas hiperbólicos.",
                                  "commonMistakes": "Erro na expansão de Taylor ou no fator ν²."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Quantificar dispersão (erro de fase)",
                                  "subSteps": [
                                    "Calcule a fase numérica: φ_num = arg(G) por passo temporal.",
                                    "Compute o erro de fase relativo: ε_φ = (φ_num - φ_exata) / φ_exata.",
                                    "Plote ε_φ vs. θ para θ de 0 a π (resolução espacial).",
                                    "Analise para diferentes ν: verifique se ε_φ → 0 quando Δt, Δx → 0.",
                                    "Discuta dispersão numérica: ondas de alta frequência viajam mais devagar."
                                  ],
                                  "verification": "Gráfico mostra erro pequeno para baixas frequências e ν próximo de 1.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/MATLAB com NumPy/Matplotlib para plotar.",
                                  "tips": "Use acos ou atan2 para arg(G) com precisão.",
                                  "learningObjective": "Medir e interpretar o erro de dispersão numérica.",
                                  "commonMistakes": "Normalizar incorretamente a fase ou ignorar o sinal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar dissipação (amortecimento) e comparar",
                                  "subSteps": [
                                    "Calcule o módulo |G|: dissipação se |G| < 1.",
                                    "Defina taxa de dissipação: δ = 1 - |G| (ou log|G| por passo).",
                                    "Compare |G| = 1 (sem dissipação exata) vs. numérico.",
                                    "Plote |G| e ε_φ vs. θ e ν; compare curvas.",
                                    "Conclua sobre consistência: erros → 0 com refinamento de malha."
                                  ],
                                  "verification": "Tabelas/plots mostram |G| ≈ 1 e erros decrescendo com mesh fina.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/MATLAB para computação e gráficos.",
                                  "tips": "Teste ν=0.9-1.0 para estabilidade.",
                                  "learningObjective": "Avaliar dissipação e validar convergência do esquema.",
                                  "commonMistakes": "Confundir |G| com arg(G) ou esquemas instáveis (ν>1)."
                                }
                              ],
                              "practicalExample": "Para o esquema Leapfrog na equação da onda com ν=0.95, compute G = e^{-i φ_num} com φ_num ≈ c k Δt + O(Δx²). Plote dispersão mostrando ondas curtas dispersam ~5% para θ=π/2.",
                              "finalVerifications": [
                                "Fator de amplificação G derivado corretamente com |G| ≤ 1.",
                                "Erro de fase ε_φ < 1% para θ < π/4 e ν=1.",
                                "Plots de dispersão e dissipação coincidem com referências teóricas.",
                                "Comparação qualitativa: dispersão dominante em altas frequências.",
                                "Análise confirma ordem de truncamento do esquema.",
                                "Sem instabilidade numérica detectada (|G| >1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do símbolo de amplificação (fórmulas exatas).",
                                "Correta quantificação de erros de fase e módulo.",
                                "Qualidade dos gráficos: eixos rotulados, escalas adequadas.",
                                "Interpretação física dos erros (dispersão/dissipação).",
                                "Evidência de convergência com refinamento.",
                                "Uso apropriado de parâmetros numéricos (ν, θ)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e sísmicas.",
                                "Engenharia Computacional: Simulações CFD para propagação de ondas.",
                                "Ciência da Computação: Análise de estabilidade em métodos numéricos.",
                                "Física Computacional: Erros em simulações de PDEs hiperbólicas."
                              ],
                              "realWorldApplication": "Avaliar precisão em simulações de ondas sísmicas para previsão de terremotos, onde dispersão artificial pode distorcer velocidades de chegada de ondas P e S, impactando alertas de emergência."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Métodos Implícitos de Diferenças Finitas para Equações Hiperbólicas",
                    "description": "Abordagem implícita para resolver numericamente equações hiperbólicas, envolvendo sistemas lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Formulação dos Métodos Implícitos de Diferenças Finitas",
                        "description": "Definição e derivação dos esquemas implícitos para equações hiperbólicas, como a equação da onda, utilizando diferenças finitas centradas no espaço e implícitas no tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Derivar o esquema BTCS para a equação da onda",
                            "description": "Derivar o esquema Backward Time Centered Space (BTCS) para a equação u_tt = c² u_xx, expressando a discretização temporal implícita e identificando o sistema linear resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a malha espacial e temporal e introduzir a notação",
                                  "subSteps": [
                                    "Defina a equação da onda: u_tt = c² u_xx, onde u(x,t) é a solução.",
                                    "Introduza a malha uniforme: x_j = j Δx, t_n = n Δt, com u_j^n ≈ u(x_j, t_n).",
                                    "Especifique condições de contorno e iniciais para contexto.",
                                    "Defina o parâmetro de Courant: λ = c Δt / Δx.",
                                    "Anote os operadores de diferenças finitas básicos: δ_x² u_j = u_{j+1} - 2u_j + u_{j-1}."
                                  ],
                                  "verification": "Verificar se a notação u_j^n está corretamente definida e o parâmetro λ introduzido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Quadro branco",
                                    "Referência: Livro de Análise Numérica (ex: LeVeque)"
                                  ],
                                  "tips": "Use índices consistentes (j para espaço, n para tempo) para evitar confusões.",
                                  "learningObjective": "Compreender a discretização da malha e notação padrão para métodos de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir Δx com Δt",
                                    "Esquecer o fator c²",
                                    "Índices invertidos (tempo vs espaço)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aproximar a derivada espacial segunda usando diferenças centradas",
                                  "subSteps": [
                                    "Aplique o operador de Laplace centrado: u_xx(x_j, t) ≈ (u_{j+1} - 2u_j + u_{j-1}) / Δx².",
                                    "Escreva a aproximação em qualquer nível temporal: u_xx,j^n ≈ δ_x² u_j^n / Δx².",
                                    "Verifique a precisão: O(Δx²) de truncamento local.",
                                    "Discuta estabilidade: Independente do nível temporal escolhido.",
                                    "Anote para uso posterior: c² u_xx,j^{n+1} ≈ c² δ_x² u_j^{n+1} / Δx²."
                                  ],
                                  "verification": "Confirmar que a aproximação espacial é simétrica e de segunda ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de desenho de equações (ex: LaTeX ou MathType)"
                                  ],
                                  "tips": "Lembre que centered space é sempre explícito em precisão, mas o nível temporal define implícito.",
                                  "learningObjective": "Dominar a discretização espacial centrada para equações hiperbólicas.",
                                  "commonMistakes": [
                                    "Usar forward ou backward space em vez de centered",
                                    "Esquecer divisão por Δx²",
                                    "Confundir com derivada primeira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximar a derivada temporal segunda usando diferenças centradas",
                                  "subSteps": [
                                    "Aplique diferenças centradas no tempo: u_tt(x_j, t_n) ≈ (u_j^{n+1} - 2u_j^n + u_j^{n-1}) / Δt².",
                                    "Verifique precisão: O(Δt²) de truncamento.",
                                    "Escreva a equação discretizada parcial: (u_j^{n+1} - 2u_j^n + u_j^{n-1}) / Δt² = c² u_xx,j^n.",
                                    "Identifique que isso seria explícito se espacial em n, mas prepare para implícito.",
                                    "Compare com Leapfrog (explícito): diferença está no nível do lado direito."
                                  ],
                                  "verification": "Verificar se a stencil temporal usa três níveis: n+1, n, n-1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de stencils de diferenças finitas"
                                  ],
                                  "tips": "Desenhe o stencil temporal (triângulo: n-1, n, n+1) para visualização.",
                                  "learningObjective": "Entender a discretização temporal centrada e sua neutralidade em esquemas multi-step.",
                                  "commonMistakes": [
                                    "Usar apenas dois níveis (forward/backward)",
                                    "Índice errado no denominador (Δx em vez de Δt)",
                                    "Esquecer o sinal -2u^n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar aproximações para formar o esquema BTCS e identificar o sistema linear",
                                  "subSteps": [
                                    "Substitua u_xx por versão em n+1: (u_j^{n+1} - 2u_j^n + u_j^{n-1}) / Δt² = c² δ_x² u_j^{n+1} / Δx².",
                                    "Multiplique ambos os lados por Δt² Δx² para clareza: Δx² (u_j^{n+1} - 2u_j^n + u_j^{n-1}) = λ² δ_x² u_j^{n+1}.",
                                    "Reorganize: -λ² u_{j+1}^{n+1} + (1 + 2λ²) u_j^{n+1} - λ² u_{j-1}^{n+1} = Δx² (u_j^{n+1} - 2u_j^n + u_j^{n-1}) wait, corrija para forma padrão.",
                                    "Forma matricial: A u^{n+1} = u^n + B (u^n - u^{n-1}), mas destaque tridiagonal implícito em n+1.",
                                    "Conclua: Resolver sistema linear tridiagonal a cada passo temporal."
                                  ],
                                  "verification": "Confirmar que o esquema é: u_j^{n+1} - 2u_j^n + u_j^{n-1} = λ² (u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Matriz tridiagonal exemplo",
                                    "Software simbólico (ex: SymPy opcional)"
                                  ],
                                  "tips": "Reorganize termos para isolar u^{n+1} à esquerda.",
                                  "learningObjective": "Derivar o esquema implícito BTCS e reconhecer sua forma como sistema linear.",
                                  "commonMistakes": [
                                    "Colocar espacial em n (ficaria explícito)",
                                    "Erro em coeficientes λ²",
                                    "Esquecer reordenação para Ax=b"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u_tt = u_xx (c=1), Δx=0.1, Δt=0.005 (λ=0.5), no ponto j=2, n=1: Escreva (u_2^2 - 2u_2^1 + u_2^0)/0.005² = (u_3^2 - 2u_2^2 + u_1^2)/0.1². Reorganize: -0.25 u_1^2 + (1+0.5) u_2^2 -0.25 u_3^2 = u_2^2 - 2u_2^1 + u_2^0 (ajustado).",
                              "finalVerifications": [
                                "O esquema usa diferenças centradas no espaço no nível n+1.",
                                "Derivada temporal centrada em n com três níveis temporais.",
                                "Precisão O(Δt² + Δx²).",
                                "Resulta em sistema linear tridiagonal por linha j.",
                                "Coeficientes corretos: 1 na diagonal temporal ajustada por λ².",
                                "Condição implícita confirmada (resolve para u^{n+1})."
                              ],
                              "assessmentCriteria": [
                                "Correção na aproximação espacial: ordem 2 e simetria.",
                                "Correção na aproximação temporal: stencil de três pontos.",
                                "Reorganização algébrica para forma implícita precisa.",
                                "Identificação correta do sistema linear tridiagonal.",
                                "Uso consistente de λ = c Δt / Δx.",
                                "Ausência de erros aritméticos nos coeficientes."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas mecânicas e acústicas.",
                                "Computação: Implementação de solvers tridiagonais (Thomas algorithm).",
                                "Engenharia: Simulações em CFD e propagação de ondas.",
                                "Matemática Aplicada: Análise de estabilidade von Neumann."
                              ],
                              "realWorldApplication": "O esquema BTCS é usado em simulações numéricas de propagação de ondas sísmicas, vibrações em estruturas civis, simulações acústicas em engenharia de som e modelagem de ondas eletromagnéticas em telecomunicações, onde estabilidade incondicional é crucial para passos temporais maiores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Implementar a discretização implícita em uma grade uniforme",
                            "description": "Construir a matriz tridiagonal associada ao esquema implícito em uma grade espacial uniforme, incluindo condições de contorno periódicas ou Dirichlet.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a grade espacial uniforme e parâmetros iniciais",
                                  "subSteps": [
                                    "Escolha o intervalo espacial [a, b] e o número de pontos internos N.",
                                    "Calcule o passo espacial h = (b - a)/(N+1).",
                                    "Defina o parâmetro de Courant λ = a Δt / h, onde Δt é o passo temporal.",
                                    "Especifique o tipo de condição de contorno: periódica ou Dirichlet.",
                                    "Inicialize vetores para armazenar os pontos da grade x_i = a + i h, i=0 a N+1."
                                  ],
                                  "verification": "Verifique se h está correto somando N+1 passos e obtendo b-a; confirme λ > 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou editor de código (Python/MATLAB); calculadora.",
                                  "tips": "Use N ímpar para simetria em contornos periódicos.",
                                  "learningObjective": "Entender a configuração básica de grades uniformes para diferenças finitas.",
                                  "commonMistakes": "Confundir pontos internos com totais; esquecer incluir fantasmas para contornos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o esquema implícito de diferenças finitas",
                                  "subSteps": [
                                    "Para a equação u_t + c u_x = 0, escreva o esquema backward: (u^{n+1}_i - u^n_i)/Δt + c (u^{n+1}_{i} - u^{n+1}_{i-1})/h = 0.",
                                    "Reorganize em forma matricial: A u^{n+1} = u^n, onde A é a matriz de ampliação implícita.",
                                    "Identifique os coeficientes: diagonal principal 1 + λ, subdiagonal -λ.",
                                    "Confirme que para esquemas implícitos em hiperbólicas, a matriz é tridiagonal lower bidiagonal.",
                                    "Escreva a equação geral para i=1 a N: (1+λ) u_{i}^{n+1} - λ u_{i-1}^{n+1} = u_i^n."
                                  ],
                                  "verification": "A equação discretizada deve ser estável para qualquer λ > 0; teste consistência de ordem 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de derivadas; livro de análise numérica (opcional).",
                                  "tips": "Lembre-se: implícito usa valores no tempo futuro, resolvendo sistema linear.",
                                  "learningObjective": "Derivar corretamente o stencil implícito para equações hiperbólicas.",
                                  "commonMistakes": "Usar diferenças forward ao invés de backward; errar o sinal de c se c<0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir os elementos da matriz tridiagonal",
                                  "subSteps": [
                                    "Crie uma matriz N x N esparsa: diagonal com 1+λ, subdiagonal com -λ.",
                                    "Para i=1: primeira linha [1+λ, 0, ..., 0] mas ajuste subdiagonal a partir da segunda linha.",
                                    "Preencha superdiagonal como zero (pois lower bidiagonal).",
                                    "Use loops ou funções para gerar: diag = (1+λ)*eye(N), sub = -λ*diag(1:N-1,1:N-2).",
                                    "Verifique simetria ou propriedades para N pequeno (ex: N=3)."
                                  ],
                                  "verification": "Multiplique matriz por vetor teste e confira se reproduz o stencil.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB; papel para N=3.",
                                  "tips": "Use sparse matrices para eficiência em N grande.",
                                  "learningObjective": "Montar matrizes tridiagonais de forma programática ou manual.",
                                  "commonMistakes": "Indexação off-by-one na subdiagonal; confundir lower com upper bidiagonal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar condições de contorno",
                                  "subSteps": [
                                    "Para Dirichlet: fixe u_0 = g0, u_{N+1}=g1; modifique primeira e última equações.",
                                    "Primeira linha: (1+λ) u_1 - λ g0 = rhs_1; última: u_N = g1 ou ajuste.",
                                    "Para periódicas: u_0 = u_N, u_{N+1}=u_1; adicione termos circulares na matriz.",
                                    "Ajuste matriz: A[1,N] = -λ para periódica; rhs inclui valores de contorno.",
                                    "Implemente em código ou manualmente para N=4."
                                  ],
                                  "verification": "Aplique contorno e resolva sistema pequeno; confira solução satisfaz BCs.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código Python/MATLAB; solver linear (np.linalg.solve).",
                                  "tips": "Periódicas criam matriz circulante tridiagonal; use mod para índices.",
                                  "learningObjective": "Adaptar matriz para diferentes condições de contorno.",
                                  "commonMistakes": "Esquecer de modificar rhs para Dirichlet; ciclos errados em periódicas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e testar a implementação",
                                  "subSteps": [
                                    "Gere u^n inicial (ex: pulso gaussiano).",
                                    "Monte A completa com BCs e resolva u^{n+1} = A^{-1} u^n.",
                                    "Avance alguns passos e plote solução.",
                                    "Compare com solução exata ou esquema explícito para estabilidade.",
                                    "Calcule norma de erro para verificação."
                                  ],
                                  "verification": "Solução não oscila para λ grande; conserva massa se aplicável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com Matplotlib; dados de teste.",
                                  "tips": "Use cond(A) para checar condicionamento.",
                                  "learningObjective": "Testar implementação numérica completa.",
                                  "commonMistakes": "Não inverter corretamente; plotar sem BCs aplicadas."
                                }
                              ],
                              "practicalExample": "Considere a equação u_t + u_x = 0 em [0,2π] com N=10, λ=2, contorno periódico. A matriz A é tridiagonal com diagonal 3, subdiagonal -2. Resolva A u^{n+1} = u^n para u^0 = sin(x), avance 5 passos e plote.",
                              "finalVerifications": [
                                "Matriz A é tridiagonal (2 diagonais no máximo).",
                                "Coeficientes corretos: diag=1+λ, sub=-λ.",
                                "Condições de contorno incorporadas sem erros de indexação.",
                                "Sistema resolvido numericamente sem singularidades.",
                                "Solução numérica estável para λ>1.",
                                "Erro de truncamento consistente com O(h,Δt)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do esquema implícito (ordem e estabilidade).",
                                "Correta montagem da matriz tridiagonal (elementos exatos).",
                                "Adequada implementação de BCs (Dirichlet/periódicas).",
                                "Eficiência computacional (uso de solvers tridiagonais).",
                                "Validação com testes numéricos e gráficos.",
                                "Clareza na documentação do código ou derivação."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de NumPy/SciPy para álgebra linear esparsa.",
                                "Física: Modelagem de ondas acústicas ou transporte em fluidos.",
                                "Engenharia Computacional: Simuladores CFD com métodos implícitos.",
                                "Estatística: Análise de estabilidade e condicionamento de matrizes."
                              ],
                              "realWorldApplication": "Usado em simulações de propagação de ondas sísmicas, previsão de frentes meteorológicas e modelagem de fluxos em reservatórios de petróleo, onde estabilidade incondicional é crucial para passos temporais grandes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Comparar esquemas implícitos com explícitos",
                            "description": "Analisar as diferenças entre métodos explícitos (como FTCS) e implícitos em termos de formulação e custo computacional para equações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Formulação de Esquemas Explícitos para Equações Hiperbólicas",
                                  "subSteps": [
                                    "Estude a equação da onda 1D: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Derive o esquema FTFS (Forward Time Forward Space): u^{n+1}_j = u^n_j + r (u^n_{j+1} - u^n_j), onde r = (c Δt / Δx)^2.",
                                    "Analise a estabilidade: condição CFL r ≤ 1.",
                                    "Implemente um código simples em Python ou MATLAB para testar.",
                                    "Calcule o erro de truncamento: O(Δt² + Δx²)."
                                  ],
                                  "verification": "Derive corretamente o esquema e verifique estabilidade com exemplo numérico estável e instável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica, Python/MATLAB, papel e caneta.",
                                  "tips": "Use stencil diagram para visualizar diferenças finitas.",
                                  "learningObjective": "Compreender a estrutura algébrica simples dos métodos explícitos.",
                                  "commonMistakes": "Confundir com esquemas parabólicos; ignorar condição de estabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Formulação de Esquemas Implícitos para Equações Hiperbólicas",
                                  "subSteps": [
                                    "Estude esquemas implícitos como o método de diferenças finitas implícito centrado: envolve solução de sistema tridiagonal.",
                                    "Derive: -r/2 u^{n+1}_{j-1} + (2 + r) u^{n+1}_j - r/2 u^{n+1}_{j+1} = u^n_j.",
                                    "Note que requer inversão de matriz por timestep.",
                                    "Implemente solver tridiagonal (Thomas algorithm).",
                                    "Teste estabilidade: incondicionalmente estável."
                                  ],
                                  "verification": "Resolva sistema para grid pequeno e compare com solução exata.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python com NumPy/SciPy, notas de aula sobre Thomas algorithm.",
                                  "tips": "Desenhe a matriz banded para visualizar estrutura esparsa.",
                                  "learningObjective": "Dominar a formulação matricial dos métodos implícitos.",
                                  "commonMistakes": "Esquecer fatorização LU ou usar solver denso ineficiente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Formulações Matemáticas",
                                  "subSteps": [
                                    "Liste diferenças: explícito usa valores conhecidos (RHS simples); implícito usa valores futuros (LHS sistema linear).",
                                    "Compare precisão: ambos O(Δt² + Δx²), mas implícito dissipa menos oscilações.",
                                    "Analise consistência e convergência via Lax equivalence.",
                                    "Crie tabela comparativa: stencil, ordem, estabilidade.",
                                    "Discuta adaptações para condições de contorno."
                                  ],
                                  "verification": "Produza tabela comparativa com fórmulas derivadas corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou LaTeX para tabela, calculadora.",
                                  "tips": "Foque em notação unificada para facilitar comparação.",
                                  "learningObjective": "Identificar diferenças algébricas chave entre explícito e implícito.",
                                  "commonMistakes": "Ignorar termos de segunda derivada temporal na hiperbólica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Custo Computacional",
                                  "subSteps": [
                                    "Calcule FLOPs: explícito ~5N por timestep; implícito ~8N log N com Thomas.",
                                    "Compare tempo de execução para N=1000, Δt pequeno.",
                                    "Discuta escalabilidade: explícito O(N), implícito O(N) mas constante maior.",
                                    "Execute benchmarks em código.",
                                    "Avalie trade-offs: explícito rápido mas instável para Δt grande."
                                  ],
                                  "verification": "Gere gráfico de tempo vs N e explique trade-offs.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Códigos dos steps anteriores, timer de performance (timeit em Python).",
                                  "tips": "Use %timeit no Jupyter para medições precisas.",
                                  "learningObjective": "Quantificar eficiência computacional.",
                                  "commonMistakes": "Contar operações incorretamente; ignorar overhead de solver."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Vantagens, Desvantagens e Implicações",
                                  "subSteps": [
                                    "Liste prós explícito: simples, rápido; contras: instável.",
                                    "Prós implícito: estável, preciso; contras: custo alto.",
                                    "Discuta cenários ideais: explícito para simulações rápidas, implícito para precisão.",
                                    "Crie resumo em bullet points.",
                                    "Relacione com literatura (e.g., LeVeque book)."
                                  ],
                                  "verification": "Escreva parágrafo de síntese com referências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referências bibliográficas, editor de texto.",
                                  "tips": "Use mindmap para organizar trade-offs.",
                                  "learningObjective": "Aplicar comparação para decisões de modelagem.",
                                  "commonMistakes": "Generalizar sem contexto hiperbólico."
                                }
                              ],
                              "practicalExample": "Para a equação da onda u_tt = u_xx em [0,1]x[0,1] com u(0,x)=sin(πx), u_t(0,x)=0, condições de Dirichlet. Implemente explícito FTFS (Δt=0.4Δx estável) vs implícito centrado (Δt=2Δx estável). Plote soluções em t=0.5; observe que implícito mantém forma senoidal sem dispersão excessiva, mas leva 3x mais tempo.",
                              "finalVerifications": [
                                "Derivação correta de ambos esquemas com stencils precisos.",
                                "Tabela comparativa completa de formulação e estabilidade.",
                                "Benchmark numérico mostrando custo computacional (FLOPs e tempo real).",
                                "Identificação de pelo menos 3 diferenças chave em precisão/dissipação.",
                                "Síntese escrita explicando quando usar cada método.",
                                "Código funcional reproduzindo exemplo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (90% correto).",
                                "Profundidade na análise de custo (inclui FLOPs e benchmarks).",
                                "Clareza na tabela comparativa e visualizações.",
                                "Correta identificação de estabilidade e trade-offs.",
                                "Relevância ao contexto hiperbólico (não confundir com parabólico).",
                                "Criatividade no exemplo prático e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas/seismicas.",
                                "Computação: Algoritmos lineares e complexidade (O(N) vs solvers).",
                                "Engenharia: Simulações CFD para propagação de ondas.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos (explícito para grids grandes rápidos; implícito para precisão em regiões críticas), ou design de antenas em engenharia eletromagnética onde estabilidade permite timesteps maiores, reduzindo tempo de simulação em software como COMSOL ou custom CFD codes."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Análise de Estabilidade, Consistência e Convergência",
                        "description": "Estudo das propriedades numéricas dos métodos implícitos, incluindo critérios de estabilidade incondicional e análise de erro de truncamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Aplicar o método de von Neumann para estabilidade",
                            "description": "Calcular o símbolo de amplificação do esquema BTCS usando análise de von Neumann e demonstrar estabilidade incondicional para qualquer razão de Courant.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema BTCS e preparar a equação modelo",
                                  "subSteps": [
                                    "Identifique a equação hiperbólica modelo, como a equação de advecção u_t + a u_x = 0.",
                                    "Escreva o esquema BTCS: u^{n+1}_j - u^n_j + λ (u^{n+1}_{j+1} - u^{n+1}_{j-1})/2 = 0, onde λ = a Δt / Δx é o número de Courant.",
                                    "Reorganize o esquema na forma implícita para u^{n+1}: (1 + i λ sin(θ)) u^{n+1} = u^n, assumindo modo de Fourier preliminar.",
                                    "Confirme os operadores de diferenças finitas: central em espaço (δ_x u = (u_{j+1} - u_{j-1})/(2Δx)).",
                                    "Anote os parâmetros: Δt, Δx, λ arbitrário."
                                  ],
                                  "verification": "Verifique se o esquema BTCS está corretamente escrito e reorganizado em termos de u^{n+1} e u^n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), papel e caneta, calculadora simbólica (opcional como SymPy).",
                                  "tips": "Sempre normalize o esquema dividindo por Δt para clareza na derivada temporal.",
                                  "learningObjective": "Compreender a estrutura implícita do esquema BTCS para equações hiperbólicas.",
                                  "commonMistakes": "Confundir BTCS com CTCS (explícito); esquecer o fator 1/2 no operador central."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a análise de von Neumann com suposição de Fourier",
                                  "subSteps": [
                                    "Assuma solução periódica: u^n_j = g^n e^{i k j Δx}, onde k é o número de onda e θ = k Δx.",
                                    "Substitua na equação temporal: g^{n+1} e^{i k j Δx} = g^n e^{i k j Δx}, levando a g = símbolo de amplificação.",
                                    "Aplique o operador espacial central no lado implícito: (u_{j+1} - u_{j-1})/(2Δx) → (i sin(θ)/Δx) u.",
                                    "Forme a equação para g: g = 1 / (1 - i λ sin(θ)), derivada da substituição completa.",
                                    "Simplifique: g(θ) = [1 + i λ sin(θ)]^{-1}."
                                  ],
                                  "verification": "Confirme que g(θ) está expresso corretamente em termos de θ e λ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software como Mathematica ou Python para verificação simbólica.",
                                  "tips": "Use a identidade e^{iθ} - e^{-iθ} = 2i sin(θ) para precisão.",
                                  "learningObjective": "Aplicar a suposição de modo de Fourier para linearizar o esquema.",
                                  "commonMistakes": "Esquecer o expoente n em g^n; sinal errado no operador i sin(θ)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o módulo do símbolo de amplificação |g(θ)|",
                                  "subSteps": [
                                    "Escreva g(θ) = 1 / (1 + i λ sin(θ)); compute |g|^2 = g * conj(g).",
                                    "Conjugado: conj(g) = 1 / (1 - i λ sin(θ)); então |g|^2 = 1 / [(1)^2 + (λ sin(θ))^2 ].",
                                    "Simplifique: |g(θ)| = 1 / sqrt(1 + λ^2 sin^2(θ)).",
                                    "Verifique para θ=0: |g|=1 (modo constante preservado).",
                                    "Note que sin^2(θ) ≤1, então denominador ≥1, |g| ≤1."
                                  ],
                                  "verification": "Calcule |g(θ)| analiticamente e plote para λ variados para visualização.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica, Python/MATLAB para plotar |g(θ)| vs θ.",
                                  "tips": "Use |1/z|^2 = 1/|z|^2 para complexos; evite expansão em série desnecessária.",
                                  "learningObjective": "Derivar e interpretar o símbolo de amplificação no plano complexo.",
                                  "commonMistakes": "Erro em |g|^2: confundir com (1 + λ^2 sin^2); esquecer sqrt no módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar estabilidade incondicional para qualquer λ",
                                  "subSteps": [
                                    "Analise |g(θ)| ≤1 para todo θ ∈ [0,π] e qualquer λ real.",
                                    "Como sqrt(1 + λ^2 sin^2(θ)) ≥1, então |g| ≤1, com igualdade só quando sin(θ)=0.",
                                    "Conclua neutralidade (não dissipativa para baixas frequências) e amortecimento para altas.",
                                    "Compare com esquemas explícitos (ex: FTCS instável para |λ|>1).",
                                    "Discuta implicações: resolveu restrição CFL."
                                  ],
                                  "verification": "Prove matematicamente |g| ≤1 ∀ θ,λ; teste numericamente para λ=10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de verificação, código Python para simulação numérica rápida.",
                                  "tips": "Máximo de |g| é 1 (estável); mínimo é 1/|λ| para θ=π/2.",
                                  "learningObjective": "Interpretar resultados para concluir estabilidade incondicional.",
                                  "commonMistakes": "Achar dissipativo incondicionalmente; ignorar dependência em sin(θ)."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x =0 com Δx=0.1, Δt=0.5 (λ=5), compute g para θ=π/2: g=1/(1+i*5)=0.0388 - 0.1925i, |g|=1/sqrt(26)≈0.196<1, confirmando amortecimento sem instabilidade.",
                              "finalVerifications": [
                                "Símbolo g(θ) corretamente derivado como 1/(1 + i λ sin(θ)).",
                                "|g(θ)| = 1/sqrt(1 + λ^2 sin^2(θ)) ≤1 para todo θ e λ.",
                                "Demostração analítica de estabilidade incondicional sem restrição CFL.",
                                "Comparação com esquema explícito mostrando superioridade do BTCS.",
                                "Gráfico de |g(θ)| para λ=1 e λ=10 mostrando |g|≤1.",
                                "Exemplo numérico resolvido sem oscilações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de g(θ): 30% da nota.",
                                "Correta computação e análise de |g(θ)|: 25%.",
                                "Prova rigorosa de |g|≤1 independentemente de λ: 20%.",
                                "Interpretação física (dissipação seletiva): 15%.",
                                "Exemplo prático e verificações numéricas: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação hiperbólica.",
                                "Computação: Implementação de solvers implícitos em CFD (ex: finite differences em Python).",
                                "Engenharia: Análise de estabilidade em simulações sísmicas ou aerodinâmicas.",
                                "Matemática Pura: Análise complexa e funções analíticas periódicas."
                              ],
                              "realWorldApplication": "Em simulações numéricas de fluxo de fluidos compressíveis (CFD), o BTCS garante simulações estáveis para passos de tempo grandes, essencial em previsões meteorológicas e modelagem de explosões onde restrições CFL explícitas são impraticáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Verificar consistência do esquema implícito",
                            "description": "Expandir o esquema em série de Taylor para mostrar que o erro de truncamento local é O(Δt² + Δx²), confirmando consistência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a definição de consistência e formular o esquema implícito",
                                  "subSteps": [
                                    "Revise a definição formal de consistência: um esquema é consistente se o erro de truncamento local tende a zero quando Δt → 0 e Δx → 0.",
                                    "Especifique a equação hiperbólica modelo, como a equação de advecção u_t + c u_x = 0 ou a equação da onda u_tt = c² u_xx.",
                                    "Apresente o esquema implícito padrão, por exemplo, para advecção: (u^{n+1}_j - u^n_j)/Δt + c (u^{n+1}_{j+1} - u^{n+1}_{j-1})/(2Δx) = 0.",
                                    "Identifique os operadores de diferença finita usados (central em espaço, backward/forward em tempo adaptado para implícito).",
                                    "Escreva o esquema em forma matricial ou residual para análise."
                                  ],
                                  "verification": "Confirme escrevendo o esquema implícito corretamente para uma equação dada e explicando por que é implícito (resolve sistema linear em cada passo).",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque 'Finite Difference Methods'), caderno de anotações, software como MATLAB ou Python para anotar equações."
                                  ],
                                  "tips": "Comece com a equação de advecção simples para evitar complexidade inicial; use notação consistente com índices n (tempo) e j (espaço).",
                                  "learningObjective": "Entender a estrutura do esquema implícito e sua relação com a PDE original.",
                                  "commonMistakes": [
                                    "Confundir esquema explícito com implícito; esquecer o fator c na advecção; usar diferenças forward em vez de central."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir as derivadas parciais em séries de Taylor",
                                  "subSteps": [
                                    "Expanda u(x_j, t_{n+1}) em Taylor ao redor de (x_j, t_n): u^{n+1}_j = u + Δt u_t + (Δt²/2) u_tt + O(Δt³).",
                                    "Expanda operadores espaciais: u_{j+1} = u + Δx u_x + (Δx²/2) u_xx + O(Δx³); similar para u_{j-1}.",
                                    "Para o esquema implícito, aplique expansões em todos os termos no nível n+1.",
                                    "Substitua as derivadas exatas: u_t ≈ (u^{n+1}_j - u^n_j)/Δt, mas expanda para ordem superior.",
                                    "Calcule o operador de diferença central em x no nível n+1: δ_x u^{n+1}_j / Δx = u_x + O(Δx²)."
                                  ],
                                  "verification": "Derive as expansões de Taylor para u^{n+1}_j e δ_x u^{n+1}_j, mostrando termos até O(Δt²) e O(Δx²).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Calculadora simbólica como SymPy em Python, papel quadriculado para expansões manuais, referência de séries de Taylor multivariáveis."
                                  ],
                                  "tips": "Use a notação abreviada: denote u_t = ∂u/∂t em (x_j, t_n); lembre que u_tt = -c u_xt para advecção linear.",
                                  "learningObjective": "Dominar expansões de Taylor para aproximações de diferenças finitas em tempo e espaço.",
                                  "commonMistakes": [
                                    "Expandir ao redor do ponto errado (ex: n+1 em vez de n); truncar prematuramente sem O(Δt³); ignorar termos cruzados como u_xt."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir expansões no esquema e isolar o erro de truncamento",
                                  "subSteps": [
                                    "Substitua todas as expansões no esquema implícito escrito na forma L_h u^{n+1} - L_h u^n = 0.",
                                    "Reorganize para obter a PDE aproximada: ∂u/∂t + c ∂u/∂x + τ(Δt, Δx, u) = 0, onde τ é o erro de truncamento.",
                                    "Colete termos de ordem baixa: confirme que os termos principais reproduzem u_t + c u_x = 0.",
                                    "Identifique termos de erro: para tempo, (Δt/2) u_tt; para espaço, O(Δx²) u_xxx.",
                                    "Mostre que τ = O(Δt² + Δx²) assumindo suavidade de u."
                                  ],
                                  "verification": "Escreva a equação com erro explícito e destaque os termos O(Δt² + Δx²).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "SymPy ou Mathematica para manipulação simbólica, exemplos resolvidos de livros de análise numérica."
                                  ],
                                  "tips": "Trabalhe simbolicamente primeiro; verifique expandindo para ordem 3 para confirmar resíduos.",
                                  "learningObjective": "Calcular e isolar o erro de truncamento local em esquemas implícitos.",
                                  "commonMistakes": [
                                    "Não expandir termos implícitos corretamente; confundir erro local com global; esquecer que para implícito o erro é similar ao explícito de mesma ordem."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar consistência e discutir implicações",
                                  "subSteps": [
                                    "Defina formalmente: esquema consistente se ||τ|| → 0 quando mesh → 0.",
                                    "Argumente que O(Δt² + Δx²) → 0 satisfaz a definição para soluções suaves.",
                                    "Compare com esquema explícito (mesma ordem de consistência).",
                                    "Discuta condições (suavidade de u: C^4 em x, C^3 em t).",
                                    "Teste numericamente em um exemplo simples para validar."
                                  ],
                                  "verification": "Conclua que o esquema é consistente de ordem 2 e implemente uma simulação rápida para checar.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para simulação numérica básica do esquema."
                                  ],
                                  "tips": "Use CFL pequeno para estabilidade; plote erro vs. h para visualização.",
                                  "learningObjective": "Conectar análise teórica de consistência com implicações para convergência.",
                                  "commonMistakes": [
                                    "Ignorar requisitos de suavidade; confundir consistência com estabilidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x = 0 em [0,1]x[0,1], com u(x,0)=sin(2πx), use esquema implícito: u^{n+1}_j - u^n_j + (Δt/(2Δx))(u^{n+1}_{j+1} - u^{n+1}_{j-1}) = 0. Expanda em Taylor para mostrar τ = (Δt/2) u_tt + (Δx²/6) u_xxx + O(Δt², Δx³) = O(Δt + Δx²), corrigindo para ordem 2 com termos exatos.",
                              "finalVerifications": [
                                "Derivar corretamente o erro de truncamento como O(Δt² + Δx²).",
                                "Explicar verbalmente as expansões de Taylor usadas.",
                                "Implementar o esquema em código e comparar com solução exata.",
                                "Identificar por que o esquema implícito mantém a mesma ordem de consistência que o explícito central.",
                                "Discutir impacto de suavidade insuficiente na consistência.",
                                "Resolver um exercício similar para equação da onda u_tt = u_xx."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expansões de Taylor (termos até ordem 2 corretos).",
                                "Cálculo correto do erro de truncamento local.",
                                "Justificativa formal da consistência.",
                                "Clareza na derivação passo a passo.",
                                "Aplicação correta em exemplo numérico.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas ou propagação de sinais em meios hiperbólicos.",
                                "Engenharia Computacional: Desenvolvimento de solvers CFD para simulações de fluxo compressível.",
                                "Ciência da Computação: Análise de algoritmos numéricos e complexidade em métodos implícitos.",
                                "Matemática Aplicada: Teoria de Lax-Richtmyer para convergência (consistência + estabilidade)."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, esquemas implícitos consistentes de ordem 2 garantem precisão em modelar propagação de ondas hiperbólicas em meios heterogêneos, usados por agências como USGS para mitigação de riscos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Demonstrar convergência via teorema de Lax",
                            "description": "Usar o teorema de equivalência de Lax para provar convergência dos métodos implícitos, dado consistência e estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Consistência, Estabilidade e Convergência",
                                  "subSteps": [
                                    "Defina consistência: o esquema de diferenças finitas aproxima a PDE localmente à medida que h, k → 0.",
                                    "Defina estabilidade: a solução numérica não cresce mais rápido que a solução exata sob norma adequada.",
                                    "Defina convergência: ||u^n - u(t_n)|| → 0 à medida que h, k → 0.",
                                    "Discuta a relação via teorema de Lax para esquemas lineares.",
                                    "Exemplo simples: verifique consistência de um esquema explícito para comparação."
                                  ],
                                  "verification": "Escreva definições precisas e um exemplo correto em um caderno ou software como LaTeX.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), caderno, calculadora simbólica (Mathematica ou papel).",
                                  "tips": "Use notação padrão: τ para passo tempo, h para espaço; L para operador de Lax-Wendroff.",
                                  "learningObjective": "Compreender os pilares do teorema de Lax para aplicação posterior.",
                                  "commonMistakes": "Confundir consistência (aproximação local) com convergência (global); ignorar linearidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar e Provar o Teorema de Equivalência de Lax",
                                  "subSteps": [
                                    "Enuncie: Para esquemas lineares consistentes e estáveis, segue convergência com ordem da consistência.",
                                    "Prove esboço: Use desigualdade triangular e propriedades de normas em espaços de Banach.",
                                    "Discuta condições: linearidade, periodicidade ou condições de contorno adequadas.",
                                    "Exemplo: Cite prova para esquemas explícitos em equações hiperbólicas.",
                                    "Verifique pré-condições para métodos implícitos."
                                  ],
                                  "verification": "Reescreva o teorema e esboço da prova corretamente, sem erros lógicos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Notas de aula, PDF do teorema de Lax (busca online ou livro), LaTeX para formatação.",
                                  "tips": "Memorize: Consistência + Estabilidade ⇒ Convergência; foque em normas L2 ou máximo.",
                                  "learningObjective": "Dominar o enunciado e lógica do teorema para invocar corretamente.",
                                  "commonMistakes": "Omitir linearidade ou assumir estabilidade sem prova; confundir com teorema de Godunov."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Consistência do Método Implícito para Equações Hiperbólicas",
                                  "subSteps": [
                                    "Especifique o esquema: ex. para u_tt = c^2 u_xx, use diferenças centrais implícitas em tempo e espaço.",
                                    "Expanda em série de Taylor: mostre que o operador local L_h(∂_t^2 - c^2 ∂_x^2) = O(τ^2 + h^2).",
                                    "Calcule truncagem: coeficientes de ordem 2 para consistência de segunda ordem.",
                                    "Confirme para condições de contorno periódicas.",
                                    "Compare com método explícito instável."
                                  ],
                                  "verification": "Compute explicitamente os termos de erro e mostre ||L_h u - PDE|| ≤ C (τ^p + h^q).",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Papel quadriculado, software simbólico (SymPy ou Maple), referência ao esquema implícito.",
                                  "tips": "Use expansão bivariada em τ e h; verifique coeficientes até ordem 2.",
                                  "learningObjective": "Demonstrar consistência quantitativamente para o esquema dado.",
                                  "commonMistakes": "Erros em expansões Taylor para derivadas mistas; ignorar termos cruzados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade do Método Implícito",
                                  "subSteps": [
                                    "Aplique análise von Neumann: assuma u_j^n = ξ^n e^{i k j h}, encontre |ξ| ≤ 1 + O(τ).",
                                    "Para implícito: resolva equação característica, mostre dissipatividade ou não-crescimento.",
                                    "Use matriz ampliada para tempo: eigenvalues com |λ| ≤ 1.",
                                    "Confirme para Courant number arbitrário (vantagem implícito).",
                                    "Teste numérico simples para validação."
                                  ],
                                  "verification": "Gere gráfico de |ξ(k)| ≤ 1 para vários r = c τ / h.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "MATLAB/Python para plot von Neumann, calculadora complexa.",
                                  "tips": "Implícitos são A-estáveis; foque em símbolo do método.",
                                  "learningObjective": "Provar estabilidade via análise espectral.",
                                  "commonMistakes": "Confundir amplificação temporal com espacial; esquecer fase para hiperbólicas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Teorema de Lax para Concluir Convergência",
                                  "subSteps": [
                                    "Reúna: consistência ordem 2 + estabilidade verificada.",
                                    "Invoque teorema: ||erro|| ≤ C (τ^2 + h^2) max |∂^m u|.",
                                    "Discuta limitações: não-linearidades ou contornos irregulares.",
                                    "Escreva prova completa.",
                                    "Simule numericamente para confirmação."
                                  ],
                                  "verification": "Escreva parágrafo final da prova ligando todos os elementos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python para simulação (ex: onda em corda), relatório LaTeX.",
                                  "tips": "Estruture prova: 1. Consistência; 2. Estabilidade; 3. Lax ⇒ Conv.",
                                  "learningObjective": "Sintetizar análise para prova de convergência.",
                                  "commonMistakes": "Pular verificações prévias; exagerar ordem sem cálculo."
                                }
                              ],
                              "practicalExample": "Para a equação da onda u_tt = u_xx em [0,1]x[0,T] com u(0,x)=sin(πx), u_t(0,x)=0, condições periódicas. Esquema implícito: (u^{n+1}_j - 2u^n_j + u^{n-1}_j)/τ^2 = (u^{n+1}_{j+1} - 2u^{n+1}_j + u^{n+1}_{j-1})/h^2. Verifique consistência O(τ^2+h^2), estabilidade via von Neumann (|ξ|≤1), conclua convergência O(τ^2+h^2).",
                              "finalVerifications": [
                                "Enuncia corretamente o teorema de Lax com condições.",
                                "Mostra cálculo explícito de erro de truncagem para consistência.",
                                "Apresenta análise von Neumann com |ξ|≤1 para estabilidade.",
                                "Liga logicamente ao teorema para concluir convergência.",
                                "Simulação numérica confirma erro decaindo com h,τ.",
                                "Discute limitações como não-linearidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão das definições e enunciado (20%)",
                                "Correção matemática da consistência (25%)",
                                "Análise de estabilidade rigorosa (25%)",
                                "Aplicação lógica do teorema (20%)",
                                "Clareza e completude da prova (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas/sísmicas.",
                                "Computação: Implementação de solvers numéricos em CFD.",
                                "Engenharia: Simulações em aerodinâmica hiperbólica.",
                                "Estatística: Análise de erro em métodos MCMC semelhantes."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos (USGS models), onde métodos implícitos garantem estabilidade para longas simulações de propagação de ondas hiperbólicas em grids finos, evitando explosões numéricas em supercomputadores."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Noções de Dispersão, Dissipação e Resolução Numérica",
                        "description": "Análise qualitativa dos erros numéricos em métodos implícitos, focando em dispersão de fase e dissipação de amplitude.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Calcular o erro de dispersão no esquema implícito",
                            "description": "Derivar a relação dispersiva |ξ| = ω Δt / (k Δx) para o BTCS e comparar com a dispersão exata da equação hiperbólica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema BTCS e preparar análise de von Neumann",
                                  "subSteps": [
                                    "Recordar a equação da onda unidimensional: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Escrever o esquema BTCS implícito: (u_j^{n+1} - 2u_j^n + u_j^{n-1}) / (Δt)² = c² (u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}) / (Δx)².",
                                    "Definir o parâmetro de Courant r = c Δt / Δx e θ = k Δx.",
                                    "Assumir solução de von Neumann: u_j^n = ξ^n exp(i k j Δx), onde ξ é o símbolo de amplificação.",
                                    "Verificar que |ξ| = 1 para esquemas não dissipativos como BTCS."
                                  ],
                                  "verification": "Escrever corretamente o esquema BTCS e a forma da solução assumida em um papel ou editor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notas de análise numérica, papel e caneta, calculadora",
                                  "tips": "Use notação consistente: sempre especifique os índices n e j claramente.",
                                  "learningObjective": "Compreender a configuração do problema e a hipótese de onda plana para análise de dispersão.",
                                  "commonMistakes": "Confundir BTCS (implícito em espaço e tempo backward) com FTCS explícito; esquecer de normalizar por Δt² e Δx²."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Substituir a solução de von Neumann no esquema BTCS",
                                  "subSteps": [
                                    "Substituir u_j^n = ξ^n e^{i k j Δx} em ambos os lados do esquema BTCS.",
                                    "Calcular o lado esquerdo: ξ^{n-1} (ξ² - 2ξ + 1) e^{i k j Δx} / (Δt)².",
                                    "Calcular o operador de segunda diferença no lado direito: ξ^{n+1} e^{i k j Δx} (-4 sin²(θ/2)) / (Δx)², onde θ = k Δx.",
                                    "Simplificar dividindo por ξ^{n-1} e^{i k j Δx}: (ξ² - 2ξ + 1)/(Δt)² = c² (-4 sin²(θ/2)) ξ / (Δx)².",
                                    "Reorganizar em equação quadrática: ξ² + (4 r² sin²(θ/2) - 2) ξ + 1 = 0."
                                  ],
                                  "verification": "Derivar e escrever a equação quadrática correta para ξ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta, software simbólico como SymPy ou Mathematica (opcional)",
                                  "tips": "Fatore ξ^{n-1} para simplificar; lembre que o laplaciano é em n+1, então multiplica por ξ.",
                                  "learningObjective": "Dominar a substituição von Neumann para obter a equação característica do esquema.",
                                  "commonMistakes": "Esquecer o fator ξ no lado direito devido ao implícito em n+1; erro no sinal do laplaciano (-4 sin²)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a equação quadrática e extrair a relação dispersiva",
                                  "subSteps": [
                                    "Resolver a quadrática ξ² + b ξ + 1 = 0, onde b = 4 r² sin²(θ/2) - 2; raízes ξ = [-b ± sqrt(b² - 4)] / 2.",
                                    "Verificar |ξ| = 1 (produto das raízes = 1) e escolher ramo físico ξ = exp(-i ω Δt).",
                                    "Extrair ω Δt = acos(1 - 2 r² sin²(θ/2)).",
                                    "Definir o fator de dispersão ξ_disp = ω Δt / θ, onde θ = k Δx.",
                                    "Confirmar a relação dispersiva aproximada |ξ_disp| = ω Δt / (k Δx) para o BTCS."
                                  ],
                                  "verification": "Calcular ξ_disp para um valor teste (ex: r=1, θ=π/4) e verificar |ξ_disp| ≈ 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, Python/MATLAB para arccos e sin",
                                  "tips": "Use identidade trigonométrica: cos(ω Δt) = 1 - 2 sin²(ω Δt / 2), mas aqui é direta.",
                                  "learningObjective": "Obter a relação dispersiva numérica do esquema implícito.",
                                  "commonMistakes": "Escolher ramo errado de ξ (instável); confundir ω Δt com arg(ξ) sem acos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com dispersão exata e calcular erro",
                                  "subSteps": [
                                    "Recordar dispersão exata: ω_ex = c k, logo ξ_ex = ω_ex Δt / (k Δx) = r.",
                                    "Calcular erro de dispersão: |ξ_disp - ξ_ex| ou |ξ_disp - 1| normalizado (já que r≈1).",
                                    "Analisar comportamento: para θ pequeno, ξ_disp ≈ 1 - (θ²/24)(1 - r²); dispersão de ordem 2.",
                                    "Plotar ξ_disp vs θ para r fixo e comparar curvas exata (reta) vs numérica.",
                                    "Discutir implicações: dispersão artificial em comprimentos de onda longos."
                                  ],
                                  "verification": "Produzir tabela ou gráfico comparando ξ_disp e ξ_ex para 5 valores de θ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (matplotlib, numpy) ou Excel para plotagem",
                                  "tips": "Normalize por r=1 para simplicidade; foque em θ de 0 a π.",
                                  "learningObjective": "Quantificar e interpretar o erro de dispersão no BTCS.",
                                  "commonMistakes": "Usar ω_ex = k em vez de c k; ignorar normalização por θ."
                                }
                              ],
                              "practicalExample": "Considere r = 1 e θ = π/2 (onda com 4 pontos por comprimento de onda). Derive ξ_disp = acos(1 - 2 sin²(π/4)) / (π/2) ≈ 0.9428. Exato: 1. Compare |ξ_disp - 1| = 0.0572 e verifique em simulação numérica de uma pulso gaussiano propagando com distorção de fase.",
                              "finalVerifications": [
                                "Derivar corretamente a equação quadrática ξ² + (4 r² sin²(θ/2) - 2) ξ + 1 = 0.",
                                "Obter ξ_disp = acos(1 - 2 r² sin²(θ/2)) / θ.",
                                "Calcular |ξ_disp| para r=1, θ=π/6, π/3, π/2 e listar valores.",
                                "Explicar por que BTCS tem dispersão mas não dissipação.",
                                "Plotar e interpretar curva ξ_disp vs θ vs reta exata.",
                                "Identificar regime onde erro < 1% (θ pequeno)."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação da equação quadrática e relação dispersiva (40%).",
                                "Precisão nos cálculos numéricos e comparação quantitativa (25%).",
                                "Interpretação física do erro de dispersão (20%).",
                                "Qualidade do gráfico comparativo e análise de ordem (10%).",
                                "Clareza na documentação dos passos (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas em meios discretos como redes cristalinas.",
                                "Computação Científica: Análise von Neumann em códigos CFD para simular ondas.",
                                "Engenharia: Otimização de malhas em modelagem acústica ou sísmica.",
                                "Matemática Aplicada: Análise assintótica de erros em EDOs/PDEs discretas."
                              ],
                              "realWorldApplication": "Em simulações numéricas de ondas sísmicas para prospecção de petróleo, o erro de dispersão no BTCS pode distorcer tempos de chegada de ondas, exigindo malhas refinadas ou esquemas de alta ordem para precisão em reservatórios profundos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Analisar dissipação numérica",
                            "description": "Examinar o módulo do símbolo de amplificação para quantificar a dissipação artificial em componentes de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de dissipação numérica e o símbolo de amplificação",
                                  "subSteps": [
                                    "Defina dissipação numérica como o amortecimento artificial de componentes de alta frequência introduzido pelo esquema numérico.",
                                    "Explique o símbolo de amplificação G(θ), onde θ = k Δx é o número de onda não dimensional.",
                                    "Discuta como |G(θ)| < 1 indica dissipação, especialmente para θ próximo a π (alta frequência).",
                                    "Revise a equação hiperbólica modelo, como u_t + a u_x = 0, e esquemas implícitos.",
                                    "Identifique diferenças entre dissipação e dispersão numéricas."
                                  ],
                                  "verification": "Escreva uma definição precisa de dissipação numérica e esboce |G(θ)| ideal (1 para baixa frequência, <1 para alta).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque), caderno, calculadora"
                                  ],
                                  "tips": "Use analogia com filtros: dissipação age como filtro passa-baixa numérico.",
                                  "learningObjective": "Entender os fundamentos teóricos da dissipação numérica em esquemas de diferenças finitas.",
                                  "commonMistakes": "Confundir dissipação (|G|<1) com dispersão (fase errada); ignorar dependência em θ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o símbolo de amplificação para um esquema implícito",
                                  "subSteps": [
                                    "Considere o esquema implícito θ-método para u_t + u_x = 0: u^{n+1}_j - u^n_j + (λ/2)(u^{n+1}_{j+1} - u^{n+1}_{j-1}) + (λ/2)(u^n_{j+1} - u^n_{j-1}) = 0, com θ=1 (totalmente implícito).",
                                    "Assuma solução modal e^{i k j Δx} g^n, derive G(θ) = [1 - i θ sin(θ)]^{-1} (ajuste para esquema específico).",
                                    "Calcule explicitamente |G(θ)|^2 para o esquema.",
                                    "Verifique estabilidade: |G(θ)| ≤ 1 para todo θ.",
                                    "Compare com esquema explícito (forward Euler)."
                                  ],
                                  "verification": "Derive e simplifique a expressão analítica de G(θ) e |G(θ)|.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis, software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Linearize o problema e use expansão de von Neumann para automação.",
                                  "learningObjective": "Derivar o símbolo de amplificação para esquemas implícitos em equações hiperbólicas.",
                                  "commonMistakes": "Erros em substituição da forma modal; esquecer fatorização complexa ao calcular |G|."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e visualizar o módulo |G(θ)|",
                                  "subSteps": [
                                    "Implemente uma função para computar |G(θ)| em intervalos de θ de 0 a π.",
                                    "Plote |G(θ)| usando Python/MATLAB, destacando θ baixo (0-π/2) vs alto (π/2-π).",
                                    "Calcule valores numéricos em pontos chave: θ=0, π/2, π.",
                                    "Observe o comportamento: |G|≈1 para baixa frequência, forte queda para alta.",
                                    "Gere tabela de valores para quantificação."
                                  ],
                                  "verification": "Produza gráfico de |G(θ)| com legenda e anote valores em θ=π (|G|<<1).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB"
                                  ],
                                  "tips": "Use np.linspace(0, np.pi, 1000) para plot suave; logscale para y se necessário.",
                                  "learningObjective": "Visualizar numericamente a dissipação via módulo do símbolo de amplificação.",
                                  "commonMistakes": "Escala errada no plot (não destacar queda em alta frequência); erro de indexação em código."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar e interpretar a dissipação artificial em alta frequência",
                                  "subSteps": [
                                    "Defina métrica de dissipação: α(θ) = -log10(|G(θ)|) por passo temporal.",
                                    "Calcule α(π) e compare com esquemas não dissipativos.",
                                    "Analise impacto: componentes de alta frequência (Nyquist) são amortecidos rapidamente.",
                                    "Discuta trade-off: dissipação estabiliza mas introduz erro artificial.",
                                    "Proponha ajustes (ex: menor Δt ou esquemas de alta ordem)."
                                  ],
                                  "verification": "Escreva relatório curto com valores de |G(π)| e implicações qualitativas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código do step 3, documento para relatório"
                                  ],
                                  "tips": "Foco em θ=π: idealmente |G(π)|=0 para máxima dissipação em implícito.",
                                  "learningObjective": "Quantificar e interpretar dissipação numérica para componentes de alta frequência.",
                                  "commonMistakes": "Ignorar que dissipação é desejável para estabilidade em implícitos; superestimar em baixa frequência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar análise em um exemplo numérico completo",
                                  "subSteps": [
                                    "Simule equação da onda 1D com esquema implícito usando condições iniciais com altas frequências.",
                                    "Compare solução numérica com exata, meça amortecimento artificial.",
                                    "Correlacione com |G(θ)|: prever taxa de dissipação.",
                                    "Teste sensibilidade a Δx e Δt.",
                                    "Documente conclusões."
                                  ],
                                  "verification": "Gere plots de solução numérica vs tempo, mostrando dissipação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy para solver implícito"
                                  ],
                                  "tips": "Use pulso inicial com senoides múltiplas para excitar altas frequências.",
                                  "learningObjective": "Integrar análise teórica com simulação prática para validar dissipação.",
                                  "commonMistakes": "Condições iniciais sem alta frequência; solver mal implementado."
                                }
                              ],
                              "practicalExample": "Para o esquema totalmente implícito na equação de advecção u_t + u_x = 0 com λ=1: G(θ) = 1 / (1 + i sin(θ)). Então |G(θ)| = 1 / sqrt(1 + sin²(θ)), que cai para |G(π)| ≈ 0.707, dissipando ~30% da amplitude por passo em Nyquist.",
                              "finalVerifications": [
                                "Pode derivar |G(θ)| para esquema implícito padrão?",
                                "Identifica corretamente |G(θ)| <1 para θ>π/2?",
                                "Calcula dissipação quantitativa em θ=π?",
                                "Explica trade-off estabilidade vs precisão?",
                                "Aplica análise em simulação simples?",
                                "Distingue dissipação de dispersão?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G(θ) (fórmula correta).",
                                "Qualidade do plot |G(θ)| (escala, anotação).",
                                "Quantificação correta de dissipação (valores numéricos).",
                                "Interpretação física/teórica profunda.",
                                "Correlação simulação-análise von Neumann.",
                                "Clareza no relatório (estrutura, linguagem)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas amortecidas em acústica.",
                                "Engenharia Computacional: Otimização de CFD para hiperbólicas.",
                                "Ciência da Computação: Análise de estabilidade em solvers numéricos.",
                                "Estatística: Análise de erro numérico como ruído."
                              ],
                              "realWorldApplication": "Em simulações sísmicas ou acústicas, análise de dissipação garante que altas frequências artificiais (ruído de grade) sejam suprimidas sem afetar ondas físicas de baixa frequência, melhorando precisão em previsões de terremotos ou design de materiais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Resolver sistemas lineares iterativamente",
                            "description": "Implementar métodos iterativos como Gauss-Seidel ou SOR para resolver o sistema tridiagonal gerado pelo esquema implícito em problemas hiperbólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Sistema Tridiagonal do Esquema Implícito",
                                  "subSteps": [
                                    "Revise o esquema implícito para equações hiperbólicas, como a equação da onda u_tt = c² u_xx.",
                                    "Derive a matriz tridiagonal A e vetor b para o sistema Au^{n+1} = b a partir da discretização espacial e temporal.",
                                    "Identifique subdiagonal (a_i), diagonal (d_i) e superdiagonal (c_i), incorporando condições de contorno.",
                                    "Monte explicitamente para um grid pequeno (N=5) e verifique simetria e diagonal-dominância.",
                                    "Calcule manualmente uma iteração para validar a formulação."
                                  ],
                                  "verification": "Matriz A e vetor b montados corretamente, verificados por multiplicação manual Au = b para solução conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook para anotações",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Use stencil notation para visualizar a tridiagonalidade e comece com Δt e Δx que satisfaçam estabilidade.",
                                  "learningObjective": "Compreender a estrutura tridiagonal gerada por métodos implícitos em problemas hiperbólicos.",
                                  "commonMistakes": [
                                    "Ignorar termos de tempo implícito nos off-diagonals.",
                                    "Erros em índices de contorno (fantasma points)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Gauss-Seidel Iterativo",
                                  "subSteps": [
                                    "Inicialize vetor u^{(0)} com solução anterior ou zeros.",
                                    "Implemente o loop iterativo: para i=1 a N, u_i^{(k+1)} = (b_i - a_i u_{i-1}^{(k+1)} - c_i u_{i+1}^{(k)}) / d_i.",
                                    "Calcule residual r^{(k)} = ||Au^{(k)} - b||_∞ a cada iteração.",
                                    "Implemente critério de parada: max_iter=1000 ou ||r^{(k)}|| < 1e-6.",
                                    "Codifique em Python com arrays NumPy para eficiência."
                                  ],
                                  "verification": "Código converge para solução exata em caso teste (ex: A identidade, b=ones) em poucas iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Jupyter Notebook ou IDE"
                                  ],
                                  "tips": "Atualize variáveis in-place para simular Gauss-Seidel verdadeiro e acelere com NumPy vectorizado onde possível.",
                                  "learningObjective": "Dominar a implementação sequencial do Gauss-Seidel para sistemas tridiagonais.",
                                  "commonMistakes": [
                                    "Usar u_{i+1}^{(k+1)} em vez de u_{i+1}^{(k)}.",
                                    "Não normalizar residual corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir e Implementar o Método SOR",
                                  "subSteps": [
                                    "Revise fórmula SOR: u_i^{(k+1)} = (1-ω) u_i^{(k)} + ω (b_i - a_i u_{i-1}^{(k+1)} - c_i u_{i+1}^{(k)}) / d_i.",
                                    "Escolha ω ótimo (ex: 1.5 para tridiagonal relaxada) ou teste valores entre 1 e 2.",
                                    "Modifique código Gauss-Seidel adicionando parâmetro ω e compare número de iterações.",
                                    "Plote convergência (log residual vs iterações) para diferentes ω.",
                                    "Analise sensibilidade a ω <1 (sub-relaxação) vs >1 (super-relaxação)."
                                  ],
                                  "verification": "SOR converge mais rápido que Gauss-Seidel (menos iterações) para ω adequado, confirmado por plots.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Código do Step 2"
                                  ],
                                  "tips": "Use ω=1 para recuperar Gauss-Seidel; teste ω em malha fina para estimar ótimo.",
                                  "learningObjective": "Entender aceleração via SOR e otimização de parâmetros iterativos.",
                                  "commonMistakes": [
                                    "ω > 2 levando a divergência.",
                                    "Não resetar u inicial ao comparar métodos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Problema Hiperbólico e Validar Solução",
                                  "subSteps": [
                                    "Configure problema: equação da onda em [0,1], u(x,0)=sin(πx), u_t=0, c=1, T=0.5.",
                                    "Integre no tempo: para cada passo temporal, monte A/b e resolva com Gauss-Seidel/SOR.",
                                    "Compare com solução exata u(x,t)=cos(π t) sin(π x).",
                                    "Calcule erros L2 e plote solução numérica vs exata em t=0.5.",
                                    "Analise dispersão/dissipação via erro de fase/amplitude."
                                  ],
                                  "verification": "Erro L2 < 1e-4, plots mostram propagação física sem oscilações espúrias.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Códigos anteriores"
                                  ],
                                  "tips": "Use Δx=1/100, Δt=0.5 Δx para estabilidade; salve soluções para animação.",
                                  "learningObjective": "Aplicar iterativos a contexto hiperbólico e avaliar precisão numérica.",
                                  "commonMistakes": [
                                    "Não aplicar condições de contorno corretamente.",
                                    "Acumular erros temporais sem refinar malha."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação da onda u_tt = u_xx em [0,1] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx), u_t(x,0)=0, use esquema implícito θ=0.5 (Crank-Nicolson). Em cada passo temporal, resolva sistema tridiagonal com Gauss-Seidel (ω=1) ou SOR (ω=1.8), convergindo em <500 iterações por passo. Plote u(x,0.5) vs exata cos(π/2)sin(πx)=0, mostrando precisão.",
                              "finalVerifications": [
                                "Sistema tridiagonal montado corretamente para N=100 (diagonal dominante).",
                                "Gauss-Seidel converge em <1000 iterações com tol=1e-6.",
                                "SOR reduz iterações em 30-50% com ω ótimo.",
                                "Erro L2 global < 5e-4 após 100 passos temporais.",
                                "Plots de solução mostram propagação de onda sem dispersão numérica excessiva.",
                                "Residual final < 1e-8 em todos passos."
                              ],
                              "assessmentCriteria": [
                                "Correção da formulação tridiagonal (verificação manual).",
                                "Implementação fiel dos algoritmos iterativos sem bugs.",
                                "Convergência eficiente (iterações < max esperado).",
                                "Precisão quantitativa (erros L2/∞ dentro de tolerâncias).",
                                "Análise qualitativa via plots e comparação exata.",
                                "Otimização via SOR com escolha justificada de ω."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de ondas e estabilidade numérica em mecânica.",
                                "Programação: Otimização de loops e uso de arrays em computação científica.",
                                "Engenharia: Simulações em CFD e acústica estrutural.",
                                "Estatística: Análise de convergência e erros de truncamento.",
                                "Matemática Aplicada: Espectro de autovalores para aceleração iterativa."
                              ],
                              "realWorldApplication": "Esses métodos são essenciais em simulações sísmicas para modelagem de terremotos (previsão de propagação de ondas P/S), design acústico de salas/veículos (controle de reverberação), e engenharia aeroespacial (análise de vibrações em painéis sob carga dinâmica), onde sistemas grandes tridiagonais surgem de malhas finitas implícitas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Análise de Estabilidade em Métodos para Equações Hiperbólicas",
                    "description": "Critérios de estabilidade, como condição CFL, para métodos explícitos e implícitos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Condição de Courant-Friedrichs-Lewy (CFL)",
                        "description": "Critério essencial de estabilidade para métodos explícitos em equações hiperbólicas, que impõe uma restrição no passo de tempo Δt em relação ao passo espacial Δx e à velocidade de propagação das ondas, garantindo que a informação numérica não se propague mais rápido que a física.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Definir e interpretar a condição CFL",
                            "description": "Explicar a origem e o significado físico da condição CFL para a equação de advecção linear ou equação da onda unidimensional, incluindo a forma geral |c Δt / Δx| ≤ 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a origem histórica e conceitual da condição CFL",
                                  "subSteps": [
                                    "Pesquise a história da condição CFL: desenvolvida por Courant, Friedrichs e Lewy em 1928 para métodos de diferenças finitas.",
                                    "Leia a definição original: restrição de estabilidade para esquemas numéricos em PDEs hiperbólicas.",
                                    "Identifique contextos iniciais: equações de onda e advecção em física matemática.",
                                    "Anote referências chave: artigo original e livros de análise numérica como LeVeque ou Strikwerda.",
                                    "Compare com instabilidades numéricas observadas sem a condição."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras sobre a origem e propósito da CFL, citando fontes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo original CFL (PDF online)",
                                    "Livro 'Finite Difference Schemes and Partial Differential Equations' de LeVeque",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Foquem em analogias físicas desde o início para facilitar a interpretação posterior.",
                                  "learningObjective": "Compreender o contexto histórico e a motivação para a condição CFL em métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir CFL com condições de fronteira",
                                    "Ignorar o papel da estabilidade von Neumann"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o significado físico na equação de advecção linear",
                                  "subSteps": [
                                    "Revise a equação de advecção: ∂u/∂t + c ∂u/∂x = 0, onde c é a velocidade de advecção.",
                                    "Descreva a propagação física: solução via características com velocidade c.",
                                    "Explique a velocidade numérica do esquema: Δx/Δt deve respeitar |c Δt / Δx| ≤ 1 para não ultrapassar domínios vizinhos.",
                                    "Visualize com diagrama de características no plano t-x.",
                                    "Simule mentalmente: se CFL >1, informação 'pula' células, causando oscilações."
                                  ],
                                  "verification": "Desenhe um diagrama de características mostrando domínios de dependência com e sem violação CFL.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Software como MATLAB ou Python (Matplotlib) para plotar características",
                                    "Vídeo tutorial sobre equação de advecção (YouTube: 3Blue1Brown ou similar)"
                                  ],
                                  "tips": "Use setas para representar velocidades físicas e numéricas no diagrama.",
                                  "learningObjective": "Interpretar a CFL como igualdade entre velocidades físicas e numéricas na advecção.",
                                  "commonMistakes": [
                                    "Confundir velocidade de grupo com velocidade de fase",
                                    "Esquecer sinal de c (advecção em ambas direções)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e interpretar a forma matemática geral da condição CFL",
                                  "subSteps": [
                                    "Comece com análise de von Neumann: assuma solução u_j^n = ξ^n e^{i k j Δx}, derive |ξ| ≤1.",
                                    "Para esquema upwind: ξ = 1 - λ + λ e^{-iθ}, onde λ = c Δt / Δx, θ = k Δx.",
                                    "Mostre que |λ| ≤1 garante estabilidade.",
                                    "Generalize para onda unidimensional: ∂²u/∂t² = c² ∂²u/∂x², CFL similar com λ = c Δt / Δx.",
                                    "Calcule exemplos numéricos: para c=1, Δx=0.1, encontre Δt máximo."
                                  ],
                                  "verification": "Derive a condição |c Δt / Δx| ≤1 para upwind e verifique com amplificação ξ.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Caderno de equações",
                                    "Python/SymPy para simbolismo",
                                    "Tabela de esquemas numéricos (de livro texto)"
                                  ],
                                  "tips": "Use fatoração para simplificar |ξ|^2 = 1 - 4λ(1-λ)sin²(θ/2) ≤1.",
                                  "learningObjective": "Derivar matematicamente a condição CFL e interpretá-la via estabilidade.",
                                  "commonMistakes": [
                                    "Erro em fatorização de ξ",
                                    "Aplicar fórmula sem considerar tipo de esquema (upwind vs Lax-Friedrichs)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar a condição CFL em simulações práticas",
                                  "subSteps": [
                                    "Implemente esquema upwind para advecção em Python.",
                                    "Execute com λ=0.5 (estável) e λ=1.5 (instável), compare plots.",
                                    "Ajuste Δt para satisfazer CFL e observe ausência de oscilações.",
                                    "Teste para equação da onda com Leapfrog scheme.",
                                    "Documente CFL number em diferentes grids."
                                  ],
                                  "verification": "Gere plots mostrando estabilidade vs instabilidade e compute CFL number corretamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Código template para advecção (GitHub)",
                                    "Computador com Jupyter"
                                  ],
                                  "tips": "Use animações (matplotlib.animation) para visualizar propagação.",
                                  "learningObjective": "Aplicar CFL em códigos numéricos e interpretar resultados.",
                                  "commonMistakes": [
                                    "Erros de indexação no código",
                                    "Escolha inadequada de condições iniciais"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o esquema upwind para u_t + u_x = 0 em [0,2] com u(0,x)=sen(πx), Δx=0.01. Com Δt=0.005 (CFL=0.5), a onda propaga suavemente; com Δt=0.02 (CFL=2), oscilações Gibbs-like aparecem nas descontinuidades numéricas.",
                              "finalVerifications": [
                                "Explique em palavras próprias o significado físico da CFL.",
                                "Derive |c Δt / Δx| ≤1 para upwind em advecção.",
                                "Calcule Δt máximo para c=2, Δx=0.05.",
                                "Identifique instabilidade em um plot simulado.",
                                "Compare CFL para advecção vs onda unidimensional.",
                                "Descreva domínio de dependência físico vs numérico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (equações corretas).",
                                "Interpretação física clara (velocidades de informação).",
                                "Exemplos numéricos com cálculos exatos de λ.",
                                "Diagramas precisos de características.",
                                "Código funcional demonstrando estabilidade.",
                                "Ausência de erros comuns como confusão de esquemas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e características em mecânica clássica.",
                                "Computação: Otimização de timestep em simulações CFD (ex: OpenFOAM).",
                                "Engenharia: Modelagem de fluxos em reservatórios petrolíferos.",
                                "Matemática Aplicada: Análise de estabilidade espectral.",
                                "Ciência de Dados: Hiperparâmetros em ML para PDE solvers."
                              ],
                              "realWorldApplication": "Na previsão meteorológica (modelos como WRF), a CFL dita o timestep máximo para simular frentes de tempestade sem instabilidades numéricas, evitando previsões errôneas de furacões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Derivar a condição CFL para esquemas explícitos",
                            "description": "Derivar analiticamente a condição CFL usando análise de Von Neumann para esquemas como FTCS, Lax-Friedrichs e upwind em equações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos da Análise de Estabilidade de Von Neumann",
                                  "subSteps": [
                                    "Assuma uma solução perturbada na forma u_j^n = g^n e^{i k j Δx}, onde g é o fator de amplificação e θ = k Δx.",
                                    "Substitua essa forma no esquema numérico explícito para obter uma equação algébrica para g(θ).",
                                    "Calcule o módulo |g(θ)| e determine a condição de estabilidade exigindo |g(θ)| ≤ 1 para todo θ ∈ [0, π].",
                                    "Identifique o número de CFL λ = a Δt / Δx como parâmetro chave na condição.",
                                    "Discuta a importância da análise para esquemas explícitos em equações hiperbólicas lineares."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os passos da análise para um esquema genérico e identifique a condição |g| ≤ 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Sempre expanda os termos e^{iθ} usando Euler: cosθ + i sinθ, e isole g.",
                                  "learningObjective": "Compreender e aplicar a metodologia de Von Neumann para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar θ = k Δx",
                                    "Não considerar |g|^2 em vez de |g| para simplificação",
                                    "Ignorar dependência em todos os θ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivação da Condição CFL para o Esquema FTCS",
                                  "subSteps": [
                                    "Escreva o esquema FTCS para u_t + a u_x = 0: u_j^{n+1} = u_j^n - (λ/2)(u_{j+1}^n - u_{j-1}^n).",
                                    "Substitua u_j^n = g^n e^{i k j Δx} e simplifique para g = 1 - i λ sin(θ).",
                                    "Calcule |g|^2 = 1 + λ² sin²(θ), que é sempre >1 para λ ≠ 0 e qualquer θ ≠ 0.",
                                    "Conclua que o FTCS é incondicionalmente instável para advecção pura, sem condição CFL viável.",
                                    "Compare com esquemas implícitos que são estáveis."
                                  ],
                                  "verification": "Derive |g|^2 explicitamente e mostre que >1 para λ>0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use identidades trigonométricas: e^{iθ} - e^{-iθ} = 2i sinθ.",
                                  "learningObjective": "Derivar analiticamente a instabilidade do FTCS e interpretar resultados.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo central",
                                    "Confundir FTCS com Lax",
                                    "Achar estabilidade condicional erroneamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação da Condição CFL para Lax-Friedrichs",
                                  "subSteps": [
                                    "Escreva o esquema: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (λ/2)(u_{j+1}^n - u_{j-1}^n).",
                                    "Substitua a forma de Von Neumann: g = cos(θ) - i λ sin(θ).",
                                    "Calcule |g|^2 = cos²(θ) + λ² sin²(θ) ≤ 1 ∀ θ se e apenas se |λ| ≤ 1.",
                                    "Verifique os limites: para θ=0, |g|=1; para θ=π/2, |g| = √(0 + λ²) ≤1.",
                                    "Discuta dissipação numérica introduzida pelo esquema."
                                  ],
                                  "verification": "Mostre graficamente |g(θ)| para |λ|=1 e |λ|>1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Python/Matlab para plotar |g(θ)|"
                                  ],
                                  "tips": "Simplifique (1 + e^{2iθ} -1 - e^{2iθ} wait, use cos e sin diretamente.",
                                  "learningObjective": "Obter a condição |λ| ≤ 1 e entender o papel da média espacial.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 na média",
                                    "Erro no cálculo de |g|^2",
                                    "Não testar múltiplos θ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivação da Condição CFL para o Esquema Upwind",
                                  "subSteps": [
                                    "Escreva o esquema upwind (a>0): u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n).",
                                    "Substitua: g = 1 - λ (1 - e^{-iθ}).",
                                    "Simplifique: g = 1 - λ + λ e^{-iθ}, então |g|^2 = [1-λ + λ cosθ]^2 + [λ sinθ]^2.",
                                    "Mostre que |g| ≤ 1 se 0 ≤ λ ≤ 1, verificando máximos e mínimos.",
                                    "Compare com Lax-Friedrichs: upwind é menos dissipativo para λ pequeno."
                                  ],
                                  "verification": "Derive a expressão fechada e prove |g| ≤ 1 para 0≤λ≤1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software para verificação numérica de |g(θ)|"
                                  ],
                                  "tips": "Expanda |1 - λ(1 - cosθ - i sinθ)|^2 cuidadosamente.",
                                  "learningObjective": "Derivar a condição CFL clássica |λ| ≤ 1 para upwind e generalizar.",
                                  "commonMistakes": [
                                    "Usar upwind errado para a<0",
                                    "Erro na expansão complexa",
                                    "Ignorar λ≥0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u_t + u_x = 0 com Δx=1, Δt=0.5 (λ=0.5), derive g para upwind: g = 1 - 0.5(1 - e^{-iθ}). Calcule |g(θ=π/2)| ≈ 0.707 <1, estável. Simule numericamente 10 passos e verifique ausência de oscilações.",
                              "finalVerifications": [
                                "Deriva corretamente |g| para FTCS mostrando instabilidade.",
                                "Obtém |λ| ≤ 1 para Lax-Friedrichs com prova completa.",
                                "Prova |g| ≤ 1 para upwind com 0 ≤ λ ≤ 1.",
                                "Identifica o papel físico da CFL como velocidade numérica ≤ física.",
                                "Compara os três esquemas em termos de estabilidade e dissipação.",
                                "Aplica a análise a um caso numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g(θ) (sem erros algébricos).",
                                "Correta identificação das condições CFL para cada esquema.",
                                "Análise completa de |g(θ)| para todo espectro de θ.",
                                "Interpretação física da condição CFL.",
                                "Clareza na apresentação de passos e gráficos.",
                                "Capacidade de generalizar para outros esquemas hiperbólicos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e choques em dinâmica de fluidos.",
                                "Computação: Implementação de solvers numéricos em CFD (ex: Python com NumPy).",
                                "Engenharia: Simulações em aerodinâmica e propagação sísmica.",
                                "Matemática Aplicada: Análise de Fourier em PDEs."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de tráfego, previsão de tempo (modelos de ondas) e hidrodinâmica computacional (CFD), a condição CFL garante simulações estáveis sem blow-up numérico, permitindo previsões precisas em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Aplicar a condição CFL em problemas numéricos",
                            "description": "Verificar se um esquema numérico satisfaz a CFL em um problema específico e ajustar parâmetros Δt e Δx para garantir estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o problema hiperbólico e o esquema numérico",
                                  "subSteps": [
                                    "Leia a equação diferencial parcial (EDP) hiperbólica, como u_t + a u_x = 0.",
                                    "Identifique o esquema numérico usado (ex: upwind, Lax-Friedrichs ou Leapfrog).",
                                    "Anote os parâmetros espaciais (Δx) e temporais (Δt), e a velocidade de propagação a.",
                                    "Defina o domínio espacial e temporal do problema.",
                                    "Esboce a grade numérica inicial."
                                  ],
                                  "verification": "Lista completa com EDP, esquema, parâmetros anotados e esboço da grade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora, referência ao esquema numérico (livro ou notes).",
                                  "tips": "Sempre confirme o tipo de esquema, pois a forma da CFL varia.",
                                  "learningObjective": "Compreender os componentes essenciais de um problema numérico hiperbólico.",
                                  "commonMistakes": "Confundir esquemas explícitos com implícitos; ignorar coeficientes variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar ou recordar a condição CFL para o esquema",
                                  "subSteps": [
                                    "Lembre a forma geral da CFL: σ = |a Δt / Δx| ≤ r, onde r é o número de CFL (tipicamente 1 para upwind).",
                                    "Para esquemas específicos, consulte ou derive via análise de von Neumann.",
                                    "Calcule o número de CFL σ com valores atuais de Δt e Δx.",
                                    "Identifique o limite máximo para estabilidade (ex: σ ≤ 1).",
                                    "Anote desigualdades para ajustes futuros."
                                  ],
                                  "verification": "Fórmula da CFL escrita corretamente com σ calculado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de fórmulas CFL, software simbólico como SymPy (opcional).",
                                  "tips": "Use análise de von Neumann para esquemas desconhecidos; memorize para upwind e Lax-Wendroff.",
                                  "learningObjective": "Aplicar análise de estabilidade para obter a condição CFL exata.",
                                  "commonMistakes": "Usar r errado (ex: 1 para upwind mas 0.5 para Lax-Wendroff); esquecer sinal de a."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar satisfação da CFL com parâmetros atuais",
                                  "subSteps": [
                                    "Substitua valores numéricos em σ = |a Δt / Δx|.",
                                    "Compare σ com o limite r: se σ > r, instável; se σ ≤ r, potencialmente estável.",
                                    "Registre o valor de σ e status (estável/instável).",
                                    "Avalie impacto em precisão (σ próximo a r maximiza resolução).",
                                    "Documente razões para instabilidade observada em simulações prévias."
                                  ],
                                  "verification": "Cálculo numérico de σ com comparação clara ao limite.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para cálculos precisos.",
                                  "tips": "Use precisão de pelo menos 4 casas decimais para evitar erros de arredondamento.",
                                  "learningObjective": "Diagnosticar violações da CFL em configurações numéricas.",
                                  "commonMistakes": "Arredondar Δt/Δx prematuramente; ignorar unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Δt e Δx para satisfazer a CFL",
                                  "subSteps": [
                                    "Escolha estratégia: fixar Δx e reduzir Δt, ou refinar grade (reduzir ambos).",
                                    "Calcule novo Δt = r Δx / |a| para σ = r.",
                                    "Teste múltiplas opções (ex: σ=0.5, 0.9) para balancear estabilidade e eficiência.",
                                    "Atualize grade e verifique σ novo.",
                                    "Planeje iterações totais com novo Δt."
                                  ],
                                  "verification": "Novos parâmetros com σ ≤ r confirmado numericamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou script Python para otimização rápida.",
                                  "tips": "Prefira σ=0.9 para eficiência; considere custo computacional.",
                                  "learningObjective": "Otimizar parâmetros numéricos para estabilidade garantida.",
                                  "commonMistakes": "Aumentar Δt além do limite; não considerar precisão perdida em grades grossas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar estabilidade via simulação simples",
                                  "subSteps": [
                                    "Implemente o esquema com parâmetros ajustados em código (Python/MATLAB).",
                                    "Rode simulação curta e compare com instável anterior.",
                                    "Observe ausência de oscilações ou blow-up.",
                                    "Plote solução em alguns timesteps.",
                                    "Confirme convergência qualitativa."
                                  ],
                                  "verification": "Plots mostrando estabilidade vs instabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB.",
                                  "tips": "Use condição inicial suave (ex: gaussiana) para detectar instabilidades cedo.",
                                  "learningObjective": "Conectar teoria CFL com comportamento numérico prático.",
                                  "commonMistakes": "Código com bugs em boundaries; grids muito grandes para teste."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x = 0 em [0,2] com u(0,x)=sen(πx), use esquema upwind com Δx=0.1, Δt=0.15 inicial (σ=1.5 >1, instável). Ajuste Δt=0.09 (σ=0.9), rode 100 steps e observe propagação estável sem dispersão excessiva.",
                              "finalVerifications": [
                                "σ calculado corretamente e ≤ r para parâmetros finais.",
                                "Ajustes documentados com razões e alternativas consideradas.",
                                "Simulação numérica confirma ausência de instabilidade.",
                                "Número de iterações razoável para eficiência.",
                                "Comparação qualitativa com solução exata.",
                                "Relatório resume violações iniciais e correções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da CFL (100% fórmulas corretas).",
                                "Correção dos cálculos numéricos de σ (erro <1%).",
                                "Eficácia dos ajustes (estabilidade garantida com σ ótimo).",
                                "Qualidade da validação numérica (plots claros e análise).",
                                "Documentação completa e lógica dos steps.",
                                "Consideração de trade-offs (estabilidade vs custo computacional)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e choques em mecânica de fluidos.",
                                "Computação: Implementação eficiente de solvers numéricos em CFD.",
                                "Engenharia: Simulações em aerodinâmica e previsão numérica do tempo.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), a CFL garante estabilidade em previsões meteorológicas, modelagem de tsunamis ou otimização de turbinas eólicas, evitando crashes em supercomputadores e permitindo previsões precisas em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Estabilidade em Métodos Explícitos",
                        "description": "Análise de estabilidade para esquemas explícitos de diferenças finitas aplicados a equações hiperbólicas, destacando a necessidade da condição CFL e os riscos de instabilidade oscilatória.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Realizar análise de Von Neumann para métodos explícitos",
                            "description": "Aplicar o método de ampliação de Von Neumann para determinar o fator de amplificação e as condições de estabilidade |g| ≤ 1 em esquemas explícitos para a equação da onda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Análise de Von Neumann",
                                  "subSteps": [
                                    "Revise a equação da onda 1D: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Estude o conceito de estabilidade em métodos numéricos explícitos, focando em esquemas como o de diferenças finitas centrais.",
                                    "Aprenda a ansatz de Von Neumann: assumir solução u_j^n = g^n e^{i k j Δx}, onde k é o número de onda.",
                                    "Entenda que o fator de ampliação |g| deve satisfazer |g| ≤ 1 para todos os k para estabilidade.",
                                    "Identifique esquemas explícitos comuns, como o esquema de Leapfrog."
                                  ],
                                  "verification": "Explique em suas palavras o que é a análise de Von Neumann e por que |g| ≤ 1 é crucial; resuma em um parágrafo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque 'Finite Difference Methods'), notas de aula sobre equações hiperbólicas"
                                  ],
                                  "tips": "Comece com exemplos visuais de instabilidade numérica para motivar o método.",
                                  "learningObjective": "Dominar os princípios teóricos da análise de Von Neumann para esquemas explícitos.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com consistência",
                                    "Ignorar a dependência em k (frequências altas)",
                                    "Esquecer o papel do número de Courant"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Esquema Numérico Explícito",
                                  "subSteps": [
                                    "Escreva o esquema explícito para a equação da onda, ex: u_j^{n+1} = 2u_j^n - u_j^{n-1} + λ² (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde λ = c Δt / Δx.",
                                    "Defina os parâmetros: Δt, Δx, λ (número de CFL).",
                                    "Discuta aproximações de diferenças finitas para derivadas temporais e espaciais.",
                                    "Verifique a consistência do esquema derivando a equação limite.",
                                    "Liste premissas: malha uniforme, condições de contorno periódicas."
                                  ],
                                  "verification": "Escreva o stencil do esquema e confirme que recupera a equação da onda no limite Δt, Δx → 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para stencil",
                                    "Software como Python/Jupyter para visualizar malha"
                                  ],
                                  "tips": "Use notação consistente para índices j (espaço) e n (tempo).",
                                  "learningObjective": "Preparar precisamente o esquema numérico para análise.",
                                  "commonMistakes": [
                                    "Erro no sinal das diferenças espaciais",
                                    "Confundir λ com r em equações de difusão",
                                    "Esquecer termos de segunda ordem no tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Ansatz de Von Neumann e Derivar g(k)",
                                  "subSteps": [
                                    "Substitua u_j^n = g^n e^{i β j} em todas as posições do esquema, onde β = k Δx.",
                                    "Simplifique usando propriedades de exponenciais: e^{i β (j±1)} = e^{i β j} e^{± i β}.",
                                    "Colete termos para obter a relação polinomial: g^{n+1} e^{i β j} em função de g^n e g^{n-1}.",
                                    "Divida por g^{n-1} e^{i β j} para isolar o polinômio quadrático em g: a g² + b g + c = 0.",
                                    "Resolva para g usando fórmula quadrática."
                                  ],
                                  "verification": "Derive explicitamente g(β) para o esquema Leapfrog e verifique para β=0 (g=1).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy em Python ou Mathematica)",
                                    "Folha de exercícios com esquema genérico"
                                  ],
                                  "tips": "Trabalhe simbolicamente primeiro; numérico depois para verificação.",
                                  "learningObjective": "Executar a substituição Fourier e obter o fator de ampliação analiticamente.",
                                  "commonMistakes": [
                                    "Erro de fase em e^{i β (j+1)}",
                                    "Dividir incorretamente por g^{n-1}",
                                    "Esquecer fatorização comum"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar |g(β)| ≤ 1 e Determinar Condições de Estabilidade",
                                  "subSteps": [
                                    "Calcule |g(β)| para β ∈ [0, π] (frequências representáveis).",
                                    "Identifique o máximo de |g(β)| e imponha max |g| ≤ 1.",
                                    "Derive a condição CFL: |λ| ≤ 1 para o esquema Leapfrog.",
                                    "Plote |g(β)| vs β para diferentes λ usando software.",
                                    "Discuta implicações para modos de alta frequência (β ≈ π)."
                                  ],
                                  "verification": "Mostre graficamente que para λ > 1, |g| > 1 em algumas β, levando a instabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/MATLAB com NumPy/Matplotlib para plotar |g(β)|",
                                    "Exemplo de código pronto para análise Von Neumann"
                                  ],
                                  "tips": "Foquem em β = π/2 para o pior caso em muitos esquemas.",
                                  "learningObjective": "Extrair condições de estabilidade quantitativas da análise.",
                                  "commonMistakes": [
                                    "Avaliar |g| só em β=0",
                                    "Ignorar raízes complexas de g",
                                    "Confundir |g| com Re(g)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Resultados e Verificações Finais",
                                  "subSteps": [
                                    "Compare com análise de Lax-Wendroff ou outros métodos.",
                                    "Simule numericamente o esquema com λ estável e instável para validar.",
                                    "Discuta generalizações para 2D ou esquemas não-lineares.",
                                    "Registre a região de estabilidade no plano complexo λ.",
                                    "Resuma limitações da análise de Von Neumann (linear, periódica)."
                                  ],
                                  "verification": "Execute simulação numérica e confirme ausência de crescimento exponencial para λ ≤ 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python para solver FD da equação da onda",
                                    "Gráficos de soluções estáveis/instáveis"
                                  ],
                                  "tips": "Use condições iniciais com múltiplas frequências para testar todos os modos.",
                                  "learningObjective": "Conectar análise teórica com simulações práticas e interpretações.",
                                  "commonMistakes": [
                                    "Atribuir instabilidade só a CFL sem verificar código",
                                    "Generalizar prematuramente para não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema Leapfrog na equação da onda 1D com c=1: u_j^{n+1} = 2u_j^n - u_j^{n-1} + λ² δ_x² u_j^n. Substituindo a ansatz, obtém-se g + 1/g = 2 - 4 λ² sin²(β/2), levando a |λ| ≤ 1 para |g| ≤ 1.",
                              "finalVerifications": [
                                "Derive corretamente g(β) para um esquema dado.",
                                "Identifique a condição CFL exata: |λ| ≤ 1.",
                                "Plote |g(β)| mostrando estabilidade/instabilidade.",
                                "Explique por que modos de alta frequência são críticos.",
                                "Simule e valide numericamente a análise.",
                                "Discuta limitações da análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do polinômio de ampliação (sem erros algébricos).",
                                "Correta identificação da condição |g| ≤ 1 para todos β.",
                                "Qualidade dos gráficos e simulações numéricas.",
                                "Profundidade na interpretação física/matemática.",
                                "Clareza na documentação do processo.",
                                "Capacidade de generalizar para esquemas similares."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas acústicas/sísmicas.",
                                "Computação: Implementação eficiente de solvers FDTD.",
                                "Engenharia: Simulações em CFD para hiperbólicas.",
                                "Matemática Aplicada: Análise de Fourier e estabilidade linear."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, onde métodos explícitos são usados em grids 3D; a análise Von Neumann garante estabilidade para passos de tempo grandes, otimizando computação em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Identificar instabilidades em simulações explícitas",
                            "description": "Diagnosticar e ilustrar numericamente comportamentos instáveis quando a CFL é violada, usando exemplos como a equação de transporte hiperbólica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Condição CFL e o Esquema Explícito para Equação de Transporte Hiperbólica",
                                  "subSteps": [
                                    "Estude a equação de transporte hiperbólica: ∂u/∂t + a ∂u/∂x = 0.",
                                    "Revise o esquema explícito de Lax-Friedrichs ou upwind: u^{n+1}_j = (u^n_{j-1} + u^n_{j+1})/2 - (a Δt / (2 Δx)) (u^n_{j+1} - u^n_{j-1}).",
                                    "Derive a condição CFL: |a Δt / Δx| ≤ 1 para estabilidade.",
                                    "Calcule o número de Courant para diferentes Δt e Δx.",
                                    "Implemente uma grade numérica simples em código."
                                  ],
                                  "verification": "Confirme derivando a CFL corretamente e implementando uma grade 1D com N=100 pontos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter, Python com NumPy, Matplotlib; notas de aula sobre análise numérica.",
                                  "tips": "Use Δx=1/N com N grande para resolução fina; anote a fórmula exata da CFL.",
                                  "learningObjective": "Compreender teoricamente a origem da condição CFL em esquemas explícitos.",
                                  "commonMistakes": "Confundir CFL com condições de Dirichlet; ignorar o sinal de 'a' na derivação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Simular Caso Estável (CFL ≤ 1)",
                                  "subSteps": [
                                    "Defina condições iniciais: u(x,0) = sen(2πx) para x em [0,1], a=1.",
                                    "Escolha Δt tal que CFL=0.5 (ex: Δx=0.01, Δt=0.005).",
                                    "Implemente o esquema explícito em loop temporal até t=1.",
                                    "Plote a solução numérica vs. exata (u(x,t)=sen(2π(x-at))) em vários tempos.",
                                    "Calcule erro L2: sqrt(∑ (u_num - u_exata)^2 / N)."
                                  ],
                                  "verification": "Gráfico mostra preservação da forma da onda sem dispersão ou oscilação excessiva; erro L2 < 0.01.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (NumPy, Matplotlib, SciPy para solução exata).",
                                  "tips": "Use animação com matplotlib.animation para visualizar propagação.",
                                  "learningObjective": "Implementar simulação estável e validar contra solução analítica.",
                                  "commonMistakes": "Erros de indexação na grade; Δt muito pequeno levando a tempo de computação excessivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Observar Caso Instável (CFL > 1)",
                                  "subSteps": [
                                    "Mantenha mesmas condições iniciais e grade espacial.",
                                    "Aumente Δt para CFL=1.5 (ex: Δt=0.015).",
                                    "Execute a simulação até t=1 ou até blow-up.",
                                    "Plote evolução temporal: observe oscilações crescentes ou NaN.",
                                    "Registre o tempo em que instabilidade aparece (ex: após 20 iterações)."
                                  ],
                                  "verification": "Solução diverge com oscilações 2Δx ou valores infinitos; compare com caso estável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo código do Step 2, modificando Δt.",
                                  "tips": "Adicione print de max|u| por iteração para detectar blow-up precoce.",
                                  "learningObjective": "Reproduzir numericamente comportamentos instáveis devido a violação CFL.",
                                  "commonMistakes": "Não rodar tempo suficiente para ver blow-up; confundir dispersão numérica com instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar e Ilustrar Numericamente a Instabilidade",
                                  "subSteps": [
                                    "Compare gráficos lado a lado: estável vs. instável.",
                                    "Analise espectro de Fourier da solução instável para modos 2Δx.",
                                    "Varie CFL de 0.1 a 2.0 em simulações curtas e plote erro vs. CFL.",
                                    "Ilustre com zoom em região de oscilação.",
                                    "Documente: 'Instabilidade quando CFL>1: crescimento exponencial de altas frequências.'"
                                  ],
                                  "verification": "Relatório com plots mostra correlação clara entre CFL>1 e instabilidade; gráfico de erro crescendo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "SciPy.fft para análise espectral; código parametrizado por CFL.",
                                  "tips": "Use loop sobre CFL values para automação; salve figuras com plt.savefig.",
                                  "learningObjective": "Diagnosticar causas numéricas da instabilidade via visualização e análise quantitativa.",
                                  "commonMistakes": "Atribuir instabilidade a condições iniciais; escalas de plot inadequadas escondendo oscilações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Testar Variações",
                                  "subSteps": [
                                    "Teste com a<0 (onda esquerda) e confirme CFL=|a|Δt/Δx.",
                                    "Experimente esquema upwind e compare estabilidade.",
                                    "Crie tabela: CFL | Tempo até blow-up | Erro final.",
                                    "Discuta limitações: por que explícito requer CFL≤1?",
                                    "Salve código reutilizável com função identify_instability(cfl)."
                                  ],
                                  "verification": "Tabela e plots confirmam diagnóstico consistente; função funciona para novos parâmetros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código anterior; Excel ou Pandas para tabela.",
                                  "tips": "Vectorize computação com NumPy para eficiência em loops CFL.",
                                  "learningObjective": "Generalizar identificação de instabilidades para variações do problema.",
                                  "commonMistakes": "Ignorar direção da onda; não normalizar erros adequadamente."
                                }
                              ],
                              "practicalExample": "Simule a equação de transporte ∂u/∂t + ∂u/∂x = 0 com u(x,0)=exp(-50(x-0.5)^2), Δx=0.01, em [0,1]. Para CFL=0.9 (Δt=0.009), a gaussiana propaga suavemente; para CFL=1.2 (Δt=0.012), oscilações 2Δx crescem após t=0.3, levando a NaN em t=0.5. Plots de u vs. x em t=0,0.2,0.4 destacam o blow-up.",
                              "finalVerifications": [
                                "Simulação estável preserva norma L2 da solução inicial (±5%).",
                                "Instabilidade detectada quando max|u| > 10 * norma inicial.",
                                "Gráficos mostram oscilações de alta frequência (comprimento 2Δx) só no caso CFL>1.",
                                "Tabela de erro L2 vs. CFL é crescente para CFL>1.",
                                "Análise espectral revela amplificação de modos altos apenas em instável.",
                                "Função personalizada identifica corretamente estabilidade para 5 valores CFL testados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição CFL (100% correta).",
                                "Implementação numérica sem bugs (roda para 100 passos sem erro).",
                                "Qualidade dos plots: eixos rotulados, legenda, comparação clara estável/instável.",
                                "Análise quantitativa: erro L2 calculado corretamente e interpretado.",
                                "Relatório explica causalidade (violação CFL → instabilidade von Neumann).",
                                "Generalização: testes com a<0 e esquemas alternativos funcionais.",
                                "Código limpo, comentado e parametrizado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas em meios hiperbólicos (e.g., equação da onda).",
                                "Computação: Programação científica, análise numérica com FFT.",
                                "Engenharia: Simulações CFD onde CFL dita timestep em solvers explícitos.",
                                "Estatística: Análise de erros numéricos e convergência.",
                                "Visualização de Dados: Uso de Matplotlib para diagnósticos científicos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), como previsão de tempo ou aerodinâmica, violar CFL em solvers explícitos causa crashes ou resultados falsos, levando a redesenho de malhas ou adaptação adaptativa de timestep para missões espaciais ou design de aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Comparar esquemas explícitos estáveis",
                            "description": "Comparar estabilidade e precisão de esquemas como Lax-Wendroff e upwind sob a condição CFL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulações dos esquemas explícitos Upwind e Lax-Wendroff",
                                  "subSteps": [
                                    "Derive ou recorde a discretização do esquema Upwind para a equação de advecção linear u_t + a u_x = 0.",
                                    "Escreva a formulação explícita do esquema Lax-Wendroff, destacando os termos de segunda ordem.",
                                    "Implemente ambos os esquemas em pseudocódigo para uma grade uniforme.",
                                    "Calcule os estênceis espaciais e temporais para cada esquema.",
                                    "Compare visualmente os estênceis no papel ou software de diagramação."
                                  ],
                                  "verification": "Escreva as fórmulas corretas e pseudocódigo funcional para ambos os esquemas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque), papel e caneta, Python/MATLAB para pseudocódigo"
                                  ],
                                  "tips": "Use notação consistente: λ = a Δt / Δx como número de Courant.",
                                  "learningObjective": "Entender as diferenças fundamentais nas aproximações espaciais e temporais dos esquemas.",
                                  "commonMistakes": [
                                    "Confundir o sinal de 'a' no Upwind (downwind vs upwind)",
                                    "Esquecer o termo de correção de segunda ordem no Lax-Wendroff"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a condição CFL e seu papel na estabilidade",
                                  "subSteps": [
                                    "Explique o significado físico da condição CFL: relação entre velocidades numérica, de sinal e de fase.",
                                    "Derive a condição CFL para esquemas lineares usando análise de von Neumann.",
                                    "Calcule o número de Courant λ para cenários variados (a>0, a<0).",
                                    "Plote a região de estabilidade no plano complexo para esquemas escalares.",
                                    "Discuta como violar CFL leva a instabilidade."
                                  ],
                                  "verification": "Resolva um exercício simples: dado Δx=0.1, a=1, encontre Δt máximo para CFL=1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folhas de cálculo, software de plotagem (Matplotlib ou similar), notas de aula sobre von Neumann"
                                  ],
                                  "tips": "Lembre-se: CFL garante que informação não 'pule' células.",
                                  "learningObjective": "Dominar a condição CFL como base para estabilidade em métodos hiperbólicos.",
                                  "commonMistakes": [
                                    "Ignorar direção de 'a' (CFL assimétrica para Upwind)",
                                    "Confundir CFL com condições de precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar estabilidade e precisão individual de cada esquema",
                                  "subSteps": [
                                    "Aplique análise de von Neumann ao Upwind: encontre amplificação |g(ξ)| ≤1 para |λ|≤1.",
                                    "Faça o mesmo para Lax-Wendroff: verifique estabilidade para |λ|≤1, mas note oscilações.",
                                    "Calcule a ordem de truncagem: first-order para Upwind (dissipativo), second-order para Lax-Wendroff.",
                                    "Analise dissipação e dispersão qualitativamente para cada um.",
                                    "Compare erros de fase e amplitude via expansão de Taylor."
                                  ],
                                  "verification": "Desenhe gráficos de |g(ξ)| vs ξ para ambos sob λ=0.5 e λ=1.2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy/Wolfram), papel quadriculado para plots manuais"
                                  ],
                                  "tips": "Use ξ = k Δx para frequências; foque em ξ=π (alta frequência).",
                                  "learningObjective": "Quantificar estabilidade (região CFL) e precisão (ordem, dissipação/dispersão).",
                                  "commonMistakes": [
                                    "Erro no fator de amplificação para Lax-Wendroff",
                                    "Não distinguir dissipação numérica de dispersão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar estabilidade e precisão entre os esquemas sob CFL",
                                  "subSteps": [
                                    "Tabele regiões de estabilidade: Upwind (0<λ≤1 para a>0), Lax-Wendroff (|λ|≤1).",
                                    "Compare precisão: erro O(Δt + Δx) vs O(Δt² + Δx²), com trade-offs (dissipação vs oscilação).",
                                    "Simule numericamente uma onda gaussiana com ambos para λ=0.9 e compare plots.",
                                    "Quantifique erros L2 e observe leading errors.",
                                    "Conclua cenários ideais: Upwind para choques, Lax-Wendroff para ondas suaves."
                                  ],
                                  "verification": "Gere plots comparativos mostrando estabilidade e precisão para mesmo problema.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib, código template para advecção"
                                  ],
                                  "tips": "Use grids finas (Nx=200) e T=1 para visualização clara.",
                                  "learningObjective": "Sintetizar comparação: Lax-Wendroff mais preciso mas sensível, Upwind robusto.",
                                  "commonMistakes": [
                                    "Não normalizar erros adequadamente",
                                    "Ignorar efeitos de contorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a advecção de uma gaussiana u(x,0)=exp(-(x-0.5)^2 / 0.01) em [0,1] com a=1, Δx=0.01, Δt=0.9 Δx. Rode Upwind e Lax-Wendroff por 100 passos; plote u(t=1) vs exata, medindo erros L2. Observe: Upwind suaviza picos, Lax-Wendroff preserva melhor mas oscila levemente.",
                              "finalVerifications": [
                                "Pode derivar corretamente as condições de estabilidade para ambos esquemas.",
                                "Identifica diferenças qualitativas em dissipação e dispersão.",
                                "Implementa simulações numéricas comparativas sem erros de programação.",
                                "Explica trade-offs sob CFL=0.9 vs 1.1.",
                                "Calcula erros de truncagem e ordem de convergência.",
                                "Discute limitações em problemas não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de fatores de amplificação (von Neumann).",
                                "Correção das regiões CFL e identificação de instabilidades.",
                                "Análise qualitativa/quantitativa de precisão (ordens e erros numéricos).",
                                "Clareza em comparações tabulares e gráficas.",
                                "Profundidade na discussão de trade-offs práticos.",
                                "Uso correto de terminologia (dissipativo, dispersivo, CFL)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação em meios.",
                                "Computação: Implementação eficiente em CFD (Computational Fluid Dynamics).",
                                "Engenharia: Simulações em aerodinâmica e previsão meteorológica.",
                                "Matemática Aplicada: Análise de erros em PDEs elípticas/hiperbólicas.",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (ex: NASA CFD codes), Upwind é usado para capturar choques em fluxos supersônicos, enquanto Lax-Wendroff otimiza precisão em propagação de ondas em modelagem sísmica ou previsão de tsunamis, sempre respeitando CFL para evitar crashes computacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Estabilidade em Métodos Implícitos",
                        "description": "Estudo da estabilidade incondicional ou condicional em métodos implícitos para equações hiperbólicas, que resolvem sistemas lineares em cada passo de tempo mas permitem passos maiores.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Analisar estabilidade de esquemas implícitos",
                            "description": "Demonstrar via análise de Von Neumann que esquemas implícitos como o backward Euler são incondicionalmente estáveis para equações hiperbólicas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação hiperbólica linear e o esquema backward Euler",
                                  "subSteps": [
                                    "Escreva a equação hiperbólica linear padrão: u_t + a u_x = 0, onde a > 0.",
                                    "Discuta a discretização espacial usando diferenças finitas centradas: (u_j^{n+1} - u_j^n)/Δt + a (u_{j+1}^{n+1} - u_{j-1}^{n+1})/(2Δx) = 0 para o esquema implícito backward Euler.",
                                    "Simplifique o esquema para a forma: u_j^{n+1} - λ (u_{j+1}^{n+1} - u_{j-1}^{n+1})/2 = u_j^n, onde λ = a Δt / Δx.",
                                    "Identifique os termos implícitos e explique por que é chamado de backward Euler.",
                                    "Verifique a consistência do esquema com a equação original."
                                  ],
                                  "verification": "Confirme que o esquema está corretamente escrito e consistente derivando o erro de truncagem O(Δt + Δx^2).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Comece com a forma unidimensional simples para evitar confusão com multi-D.",
                                  "learningObjective": "Entender a formulação matemática do esquema backward Euler para equações hiperbólicas.",
                                  "commonMistakes": "Confundir o esquema explícito forward Euler com o implícito backward."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e aplicar a análise de Von Neumann",
                                  "subSteps": [
                                    "Explique o método de Von Neumann: assumir u_j^n = g^n e^{i k j Δx}, onde k é o número de onda.",
                                    "Substitua na equação do esquema para obter a equação característica para g.",
                                    "Derive o fator de amplificação g a partir do esquema backward Euler.",
                                    "Escreva g como função do número de Courant ξ = a Δt / Δx e do número de onda θ = k Δx.",
                                    "Discuta a condição geral de estabilidade: |g| ≤ 1 + O(Δt) para todos θ."
                                  ],
                                  "verification": "Obtenha a expressão explícita para g(θ, ξ) e verifique para θ=0 que g=1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software Mathematica ou Python com NumPy/SymPy para simbolismo"
                                  ],
                                  "tips": "Use a identidade e^{iθ} - e^{-iθ} = 2i sin(θ) para simplificar.",
                                  "learningObjective": "Dominar a aplicação da análise de Von Neumann a esquemas implícitos.",
                                  "commonMistakes": "Esquecer o tempo n+1 nos termos espaciais no implícito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o fator de amplificação para estabilidade",
                                  "subSteps": [
                                    "Calcule |g|^2 = g * conj(g) para o backward Euler: |g| = 1 / |1 + i ξ sin(θ)|.",
                                    "Mostre que |1 + i ξ sin(θ)| ≥ 1 para todo ξ > 0 e θ, pois é √(1 + (ξ sin(θ))^2) ≥ 1.",
                                    "Conclua que |g| ≤ 1 para todos os valores de ξ e θ, provando estabilidade incondicional.",
                                    "Compare com o esquema explícito forward Euler, que requer |ξ| ≤ 1.",
                                    "Plote |g(θ)| vs θ para diferentes ξ para visualização."
                                  ],
                                  "verification": "Prove matematicamente que |g| ≤ 1 e gere um gráfico confirmando.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Papel para prova analítica"
                                  ],
                                  "tips": "A prova chave é notar que o denominador tem módulo maior que 1.",
                                  "learningObjective": "Demonstrar analiticamente a estabilidade incondicional do backward Euler.",
                                  "commonMistakes": "Erro no cálculo de |g|, esquecendo que g é complexo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e verificar numericamente",
                                  "subSteps": [
                                    "Estenda para esquemas implícitos genéricos e discuta condições de Von Neumann.",
                                    "Implemente uma simulação numérica simples em Python para o backward Euler com ξ grande.",
                                    "Compare soluções numéricas com a solução exata para diferentes ξ.",
                                    "Analise dissipação numérica (como |g| < 1 para θ ≠ 0).",
                                    "Resuma as vantagens: estabilidade sem restrição CFL."
                                  ],
                                  "verification": "Execute simulação com ξ=10 e confirme ausência de instabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy, SciPy e Matplotlib",
                                    "Código template para advection"
                                  ],
                                  "tips": "Use solve linear para o sistema implícito em cada passo temporal.",
                                  "learningObjective": "Validar a análise teórica com experimentos computacionais.",
                                  "commonMistakes": "Não resolver corretamente o sistema tridiagonal implícito."
                                }
                              ],
                              "practicalExample": "Considere a equação de advecção u_t + u_x = 0 com condição inicial u(x,0) = sin(2πx). Aplique o backward Euler com Δx=0.01, Δt=0.1 (ξ=10). A análise de Von Neumann prevê |g| ≈ 1/√(1 + sin²(θ)) <1, e a simulação numérica mostra propagação estável sem oscilações, ao contrário do forward Euler que explode.",
                              "finalVerifications": [
                                "Derivar corretamente o fator g para backward Euler.",
                                "Provar |g| ≤ 1 independentemente de ξ.",
                                "Gerar gráfico de |g(θ)| mostrando estabilidade.",
                                "Implementar e rodar simulação estável para ξ>1.",
                                "Explicar verbalmente as diferenças com esquemas explícitos.",
                                "Identificar dissipação numérica como trade-off."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator de amplificação (100% correto).",
                                "Prova analítica rigorosa de |g| ≤ 1.",
                                "Gráficos e simulações numéricas livres de erros.",
                                "Explicação clara de implicações para CFL.",
                                "Generalização para outros esquemas implícitos.",
                                "Identificação correta de propriedades dissipativas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação sísmica.",
                                "Computação Científica: Solução de PDEs em simulações CFD.",
                                "Engenharia: Estabilidade em métodos numéricos para controle de sistemas.",
                                "Matemática Aplicada: Análise de estabilidade em EDOs lineares."
                              ],
                              "realWorldApplication": "Em simulações de propagação de ondas sísmicas ou acústicas, o backward Euler permite passos de tempo grandes sem instabilidade, acelerando previsões em softwares como SPECFEM ou COMSOL para monitoramento de terremotos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Implementar método implícito simples",
                            "description": "Implementar e testar um esquema implícito para a equação da onda, verificando estabilidade sem restrições CFL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e definir parâmetros do problema",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: NumPy, SciPy e Matplotlib.",
                                    "Definir parâmetros: comprimento do domínio L, número de pontos espaciais Nx, passos de tempo Nt, dt e dx.",
                                    "Especificar a equação da onda u_tt = c² u_xx com c=1, condições iniciais (ex: pulso gaussiano) e de contorno (Dirichlet zero).",
                                    "Criar arrays para grid espacial x e solução u (inicializar com zeros).",
                                    "Implementar função para condição inicial u(x,0) e u_t(x,0)."
                                  ],
                                  "verification": "Verificar se os arrays têm dimensões corretas e se a condição inicial plota corretamente com Matplotlib.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python 3, NumPy, Matplotlib, Jupyter Notebook",
                                  "tips": "Use np.linspace para grid uniforme e np.meshgrid para visualizações futuras.",
                                  "learningObjective": "Entender a configuração numérica básica para PDEs hiperbólicas.",
                                  "commonMistakes": "Escolher dx ou dt muito pequenos levando a alto custo computacional; esquecer unidades consistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a discretização espacial e condições iniciais",
                                  "subSteps": [
                                    "Definir operador laplaciano discreto: matriz tridiagonal A para d²u/dx² ≈ (u_{i+1} - 2u_i + u_{i-1})/dx².",
                                    "Aplicar condições de contorno: u[0] = u[Nx-1] = 0 em todos os tempos.",
                                    "Inicializar u_n (tempo n=0) e u_nm1 (tempo n=-1) usando condições iniciais e aproximação para u_t.",
                                    "Testar operador espacial em uma solução conhecida (ex: seno) para validar precisão.",
                                    "Visualizar solução inicial."
                                  ],
                                  "verification": "Aplicar A em vetor teste e comparar com valor analítico; plotar u inicial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "NumPy (para matrizes esparsas), SciPy.sparse para eficiência",
                                  "tips": "Use scipy.sparse.diags para construir A eficientemente, evitando matrizes densas.",
                                  "learningObjective": "Dominar discretização espacial finita diferenças para equações de onda.",
                                  "commonMistakes": "Índices errados nas fronteiras; não zerar corretamente condições de contorno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver e codificar o esquema implícito",
                                  "subSteps": [
                                    "Derivar esquema implícito: (u^{n+1} - 2u^n + u^{n-1})/dt² = A u^{n+1}, onde A é laplaciano.",
                                    "Reescrever como sistema linear: (I - (dt²/2) A) u^{n+1} = 2u^n - u^{n-1} (esquema médio implícito).",
                                    "Implementar matriz do sistema B = I - r A, com r = dt²/2.",
                                    "Usar solver linear sparse (scipy.sparse.linalg.spsolve) para cada passo.",
                                    "Atualizar u_nm1 = u_n e u_n = u_{n+1} no loop temporal."
                                  ],
                                  "verification": "Executar 1 passo de tempo e verificar se norma residual é <1e-10.",
                                  "estimatedTime": "1 hora",
                                  "materials": "SciPy.sparse.linalg, NumPy",
                                  "tips": "Pré-fatorar B se dt fixo usando LU para acelerar múltiplos solves.",
                                  "learningObjective": "Compreender derivação e implementação de esquemas implícitos para estabilidade.",
                                  "commonMistakes": "Confundir coeficientes do esquema (ex: usar dt em vez de dt²); matriz singular por BC erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulação, visualizar e analisar estabilidade",
                                  "subSteps": [
                                    "Implementar loop principal para Nt passos, salvando soluções em intervalos.",
                                    "Plotar animação ou snapshots da solução com Matplotlib.",
                                    "Testar com dt grande (ex: dt=10 dx, violando CFL para explícito).",
                                    "Comparar energia total ||u_t||² + ||u_x||² ao longo do tempo (deve ser conservada).",
                                    "Analisar estabilidade: rodar com dt variando e verificar ausência de blow-up."
                                  ],
                                  "verification": "Solução permanece bounded e oscila sem amortecimento artificial para dt grande.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib.animation, NumPy para computar energia",
                                  "tips": "Use %matplotlib notebook em Jupyter para animações interativas.",
                                  "learningObjective": "Verificar numericamente a estabilidade incondicional do método implícito.",
                                  "commonMistakes": "Loop infinito por solver não convergindo; plots sem labels/legends."
                                }
                              ],
                              "practicalExample": "Simule a vibração de uma corda de violão (L=1m) com pulso gaussiano inicial u(x,0)=exp(-(x-0.5)^2/0.01), u_t=0, condições fixas nas extremidades. Use Nx=100, Nt=1000, dt=0.1 (CFL violado para explícito). Observe ondas propagando sem instabilidade.",
                              "finalVerifications": [
                                "Código executa sem erros para dt=0.1 com Nx=100.",
                                "Solução visual é fisicamente plausível (ondas refletem nas bordas).",
                                "Energia total varia <1% ao longo da simulação.",
                                "Teste com dt=1.0: solução permanece estável (sem NaNs ou explosão).",
                                "Comparação qualitativa com solução analítica d'Alembert para poucos passos.",
                                "Tempo de execução razoável (<10s para Nt=1000)."
                              ],
                              "assessmentCriteria": [
                                "Correção do esquema implícito (derivada e coeficientes exatos).",
                                "Eficiência: uso de solvers esparsos e pré-condicionamento.",
                                "Validação numérica (energia conservada, estabilidade demonstrada).",
                                "Clareza do código: comentários, funções modulares.",
                                "Visualizações informativas com labels e animação.",
                                "Análise de estabilidade com múltiplos dt."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas mecânicas e acústicas.",
                                "Computação: Algoritmos numéricos, programação científica com Python.",
                                "Engenharia: Simulações em controle de estruturas vibrantes.",
                                "Matemática Aplicada: Análise de autovalores para estabilidade."
                              ],
                              "realWorldApplication": "Simulação de propagação de ondas sísmicas em prospecção de petróleo, modelagem de sinais acústicos em engenharia de som ou vibrações em pontes para análise de fadiga estrutural, onde passos de tempo grandes são necessários por eficiência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Discutir trade-offs de métodos implícitos",
                            "description": "Explicar as vantagens em estabilidade versus o custo computacional de resolver sistemas lineares tridiagonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de métodos explícitos e implícitos para equações hiperbólicas",
                                  "subSteps": [
                                    "Estude a diferença entre esquemas explícitos (e.g., FTCS) e implícitos (e.g., BTCS) para a equação de onda ou calor.",
                                    "Implemente um esquema explícito simples em Python ou MATLAB para uma equação hiperbólica 1D.",
                                    "Observe o comportamento numérico com passos de tempo variados.",
                                    "Registre as condições CFL para estabilidade no método explícito.",
                                    "Compare com a definição formal de métodos implícitos que envolvem sistemas lineares."
                                  ],
                                  "verification": "Capacidade de codificar e executar um esquema explícito que falha para Δt grande, confirmando instabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter com NumPy/SciPy, livro de análise numérica (e.g., LeVeque 'Finite Difference Methods')",
                                  "tips": "Use gráficos para visualizar instabilidade (oscilações ou blow-up).",
                                  "learningObjective": "Diferenciar mecanismos de atualização em métodos explícitos vs implícitos.",
                                  "commonMistakes": "Confundir ordem de precisão com estabilidade; ignorar condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar estabilidade incondicional dos métodos implícitos",
                                  "subSteps": [
                                    "Derive a matriz de amplificação para um esquema implícito como BTCS em equação de onda.",
                                    "Aplique análise de von Neumann para provar estabilidade incondicional (raio espectral ≤1 para qualquer Δt).",
                                    "Simule numericamente com Δt grande (violando CFL explícito) e verifique ausência de instabilidade.",
                                    "Discuta como a inversão da matriz (implícita) garante amortecimento de modos de alta frequência.",
                                    "Compare com métodos explícitos usando o mesmo problema."
                                  ],
                                  "verification": "Gráficos de solução estável para Δt = 10x CFL explícito, com erro de truncamento aceitável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de análise simbólica (SymPy), código de simulação pronto",
                                  "tips": "Foco em eigenvalues da matriz de amplificação para prova analítica.",
                                  "learningObjective": "Compreender por que métodos implícitos são incondicionalmente estáveis.",
                                  "commonMistakes": "Esquecer termos de contorno na análise de von Neumann; superestimar precisão sem verificar erro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar custo computacional de resolver sistemas tridiagonais",
                                  "subSteps": [
                                    "Identifique que métodos implícitos geram sistemas lineares tridiagonais Ax^{n+1} = b.",
                                    "Implemente o Algoritmo de Thomas (TDMA) para solução eficiente O(N).",
                                    "Meça tempo de execução para diferentes tamanhos de malha N e compare com explícito O(N).",
                                    "Analise complexidade: forward/backward sweep vs inversão direta (O(N^3) custosa).",
                                    "Teste com malhas grandes (N=10^4) para quantificar overhead."
                                  ],
                                  "verification": "Tempo de simulação implícito < 2x explícito para N=10^4, com solução correta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python com timeit, profiler (e.g., cProfile)",
                                  "tips": "Vetorize operações no NumPy para benchmarks justos.",
                                  "learningObjective": "Quantificar custo O(N) vs benefício de estabilidade.",
                                  "commonMistakes": "Usar solvers genéricos (e.g., np.linalg.solve) em vez de TDMA; ignorar overhead de setup."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar trade-offs e discutir cenários ótimos",
                                  "subSteps": [
                                    "Liste vantagens: estabilidade permite Δt grande, reduzindo iterações totais apesar de custo por passo.",
                                    "Liste desvantagens: overhead por passo (TDMA ~3-5x explícito), paralelização mais difícil.",
                                    "Calcule break-even: Δt_max implícito / Δt_max explícito > custo relativo.",
                                    "Avalie em problemas reais: ondas com fontes stiff vs simulações longas.",
                                    "Escreva um relatório resumindo trade-offs com números de simulações."
                                  ],
                                  "verification": "Relatório com tabela comparativa (estabilidade, tempo total, erro) para 3 cenários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou Markdown para tabela, resultados de simulações anteriores",
                                  "tips": "Considere problemas multidimensional (matrizes block-tridiagonais mais custosas).",
                                  "learningObjective": "Avaliar trade-offs quantitativamente para escolha de método.",
                                  "commonMistakes": "Focar só em custo por passo, ignorando ganhos em passos totais; generalizar sem contexto."
                                }
                              ],
                              "practicalExample": "Simule a equação da onda u_tt = c^2 u_xx em [0,1]x[0,T] com u(0,t)=u(1,t)=0, u(x,0)=sin(πx), u_t(x,0)=0. Use FTCS explícito (CFL=0.5) vs BTCS implícito com TDMA. Aumente Δt para 10x no implícito: observe estabilidade vs tempo total de CPU similar devido a menos passos.",
                              "finalVerifications": [
                                "Explicar verbalmente por que implícito é estável para qualquer Δt.",
                                "Implementar TDMA corretamente para sistema tridiagonal de tamanho 1000.",
                                "Comparar tempos de CPU e erros L2 para Δt variados.",
                                "Identificar cenário onde implícito é preferível (e.g., simulações longas).",
                                "Discutir limitações como dissipação numérica em implícitos.",
                                "Calcular fator de aceleração total (tempo total explícito / implícito)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de estabilidade (raio espectral correto).",
                                "Eficiência da implementação TDMA (O(N) confirmado por benchmark).",
                                "Análise quantitativa de trade-offs com dados numéricos.",
                                "Clareza na discussão de vantagens/desvantagens contextualizadas.",
                                "Uso correto de terminologia (tridiagonal, CFL, von Neumann).",
                                "Capacidade de generalizar para problemas 2D ou não-lineares."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação eficiente de solvers lineares (CS).",
                                "Física: Modelagem de ondas/propagação em meios contínuos.",
                                "Engenharia Computacional: Otimização em simulações CFD/FEM.",
                                "Otimização: Trade-offs custo-benefício em algoritmos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de engenharia acústica ou sísmica, métodos implícitos permitem passos de tempo grandes para previsões de longo prazo em reservatórios de óleo, equilibrando estabilidade para materiais heterogêneos com custo computacional viável via TDMA em malhas 1D/2D."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.4",
                        "name": "Noções de Dispersão e Dissipação",
                        "description": "Conceitos de erro numérico em métodos para equações hiperbólicas: dissipação (amortecimento artificial de amplitudes) e dispersão (erro de fase na propagação de ondas).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.4.1",
                            "name": "Definir dissipação e dispersão numérica",
                            "description": "Diferenciar dissipação (decaimento da amplitude do fator de amplificação |g| < 1) e dispersão (desvio da velocidade de fase numérica da física).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar análise de von Neumann e fator de amplificação",
                                  "subSteps": [
                                    "Explicar o método de análise de von Neumann para estabilidade de esquemas numéricos.",
                                    "Introduzir soluções de Fourier plano: u_j^n = g^n e^{i k j h}.",
                                    "Derivar a expressão do fator de amplificação g(k h) para esquemas lineares.",
                                    "Discutir condição de estabilidade |g| ≤ 1 para todos os k.",
                                    "Calcular g para o esquema forward Euler em equação de advecção simples."
                                  ],
                                  "verification": "Capacidade de derivar g(k h) para um esquema dado e verificar |g| ≤ 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: LeVeque)",
                                    "Caderno e lápis",
                                    "Software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Sempre normalize a frequência espacial ξ = k h ∈ [0, π] para análise.",
                                  "learningObjective": "Compreender a base espectral para análise de estabilidade em métodos hiperbólicos.",
                                  "commonMistakes": "Ignorar a dependência em k (frequência); confundir g com truncamento local."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e analisar dissipação numérica",
                                  "subSteps": [
                                    "Definir dissipação como decaimento da amplitude: |g(ξ)| < 1 para ξ > 0.",
                                    "Explicar que dissipação numérica introduz amortecimento artificial em componentes de alta frequência.",
                                    "Calcular |g(ξ)| para esquemas dissipativos como Lax-Friedrichs.",
                                    "Analisar o papel da dissipação na supressão de oscilações.",
                                    "Comparar com esquemas não dissipativos onde |g| = 1."
                                  ],
                                  "verification": "Identificar se um esquema é dissipativo plotando |g(ξ)| < 1 em gráfico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python/Matplotlib para plotar |g(ξ)|",
                                    "Exemplos de esquemas hiperbólicos"
                                  ],
                                  "tips": "Foquem em ξ próximo a π (ondas curtas) onde dissipação é mais pronunciada.",
                                  "learningObjective": "Caracterizar matematicamente a dissipação via módulo do fator de amplificação.",
                                  "commonMistakes": "Confundir |g| < 1 com instabilidade (|g| > 1); ignorar que |g(0)| = 1 sempre."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e analisar dispersão numérica",
                                  "subSteps": [
                                    "Definir velocidade de fase numérica: ω_num / k, onde g = |g| e^{i ω Δt}.",
                                    "Comparar com velocidade de fase física c_física da equação hiperbólica.",
                                    "Definir dispersão como desvio: ω_num(k) ≠ c k (dispersão física zero em hiperbólicas lineares).",
                                    "Calcular velocidade de fase para upwind e Lax-Wendroff.",
                                    "Plotar relação dispersiva ω_num vs ξ."
                                  ],
                                  "verification": "Calcular e comparar velocidades de fase para diferentes esquemas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python para análise de dispersão",
                                    "Gráficos de referência de livros"
                                  ],
                                  "tips": "Use arg(g) = ω Δt para extrair ω_num; normalize por c Δt / h.",
                                  "learningObjective": "Identificar dispersão pelo desvio da relação dispersiva linear.",
                                  "commonMistakes": "Confundir fase numérica com grupo; esquecer normalização por k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar dissipação e dispersão com exemplos",
                                  "subSteps": [
                                    "Resumir diferenças: dissipação afeta amplitude (|g|), dispersão afeta fase (arg(g)).",
                                    "Analisar esquema Lax-Wendroff: pouco dissipativo, mas dispersivo.",
                                    "Analisar esquema upwind: dissipativo, menos dispersivo.",
                                    "Combinar em exemplo de equação de onda: simular e observar efeitos.",
                                    "Discutir trade-offs em escolha de esquemas."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a distinção com fórmulas e gráficos.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Simulador numérico simples em Python",
                                    "Artigos sobre esquemas hiperbólicos"
                                  ],
                                  "tips": "Sempre associe a efeitos visuais: dissipação suaviza, dispersão oscila/distorce.",
                                  "learningObjective": "Diferenciar conceitual e quantitativamente dissipação de dispersão.",
                                  "commonMistakes": "Trocar termos; achar que ambos são 'erros de amplitude'."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + c u_x = 0 com esquema Lax-Friedrichs (λ = c Δt / h = 1): g(ξ) = cos(ξ) - i λ sin(ξ). Calcule |g| ≈ 0.9 <1 (dissipativo) e ω_num / k ≠ c (dispersivo para ξ alto), simulando uma onda gaussiana que amortecida e distorcida.",
                              "finalVerifications": [
                                "Definir corretamente dissipação como |g(ξ)| < 1.",
                                "Definir dispersão como desvio ω_num(k) ≠ c k.",
                                "Calcular g para Lax-Friedrichs e identificar ambos os efeitos.",
                                "Plotar |g(ξ)| e relação dispersiva.",
                                "Explicar impacto em simulações de ondas.",
                                "Diferenciar em tabela comparativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições matemáticas (fórmulas corretas).",
                                "Correção nos cálculos de |g| e arg(g).",
                                "Qualidade dos gráficos de análise espectral.",
                                "Clareza na diferenciação conceitual.",
                                "Uso apropriado de exemplos numéricos.",
                                "Identificação de trade-offs em esquemas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e amortecimento em meios viscosos.",
                                "Engenharia Computacional: Análise de erros em CFD (dinâmica de fluidos computacional).",
                                "Ciência da Computação: Complexidade algorítmica em solvers PDE.",
                                "Processamento de Sinais: Análise espectral e filtros digitais."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, dissipação controla ruído numérico em ondas de alta frequência, enquanto dispersão afeta a precisão da chegada de frentes de onda, essencial para imaging geológico preciso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.4.2",
                            "name": "Analisar dispersão e dissipação em esquemas",
                            "description": "Calcular os termos de dissipação e dispersão para esquemas como Lax-Wendroff usando expansão em série de Taylor ou Von Neumann.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de dispersão e dissipação",
                                  "subSteps": [
                                    "Defina dispersão como a introdução de componentes de alta frequência que propagam a velocidades erradas.",
                                    "Defina dissipação como o amortecimento artificial de componentes de onda.",
                                    "Explique a relação com a equação de onda exata e esquemas numéricos.",
                                    "Identifique quando dispersão e dissipação ocorrem em esquemas hiperbólicos.",
                                    "Diferencie dispersão de fase e amortecimento numérico."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos de cada conceito em um resumo de 200 palavras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), notas de aula, calculadora.",
                                  "tips": "Use analogias com ondas físicas para visualizar os efeitos.",
                                  "learningObjective": "Dominar as definições e impactos qualitativos de dispersão e dissipação.",
                                  "commonMistakes": "Confundir dispersão com difusão ou ignorar o contexto hiperbólico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar expansão em série de Taylor para esquemas numéricos",
                                  "subSteps": [
                                    "Lembre a expansão de Taylor da solução exata: u(t+Δt, x) = u + Δt u_t + (Δt)^2/2 u_tt + ...",
                                    "Expanda o esquema numérico Lax-Wendroff: u_j^{n+1} = u_j^n - (λ/2)(u_{j+1}^n - u_{j-1}^n) + (λ^2/2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n).",
                                    "Substitua operadores espaciais por derivadas: δ_x u ≈ Δx u_x, δ_xx u ≈ Δx^2 u_xx.",
                                    "Compare truncagem até ordem 3 ou 4 para identificar termos de erro.",
                                    "Extraia coeficientes de dissipação (ímpar) e dispersão (par)."
                                  ],
                                  "verification": "Derive os termos de truncagem até O(Δt^3) e identifique os de ordem 3.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel quadriculado, lápis, software simbólico como SymPy ou Mathematica.",
                                  "tips": "Mantenha consistência nos símbolos λ = c Δt / Δx e expanda sistematicamente por potências.",
                                  "learningObjective": "Aplicar expansão de Taylor para decompor erros numéricos em componentes dissipativos e dispersivos.",
                                  "commonMistakes": "Erros nos sinais das diferenças finitas ou esquecimento de termos mistos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar análise de Von Neumann para estabilidade e dispersão/dissipação",
                                  "subSteps": [
                                    "Assuma solução u_j^n = g^n e^{i k j Δx} para modo de Fourier.",
                                    "Substitua no esquema Lax-Wendroff e resolva para o fator de amplificação g(k Δx).",
                                    "|g| ≤ 1 para estabilidade; arg(g) ≈ -c k Δt para fase correta.",
                                    "Calcule dissipação: 1 - |g|^2 ≈ coeficiente de amortecimento.",
                                    "Calcule dispersão: erro de fase ω_num - ω_exata."
                                  ],
                                  "verification": "Plote |g| e fase vs. k Δx para λ=0.9 e verifique estabilidade.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "MATLAB ou Python (NumPy/Matplotlib), código template para Von Neumann.",
                                  "tips": "Use funções trigonométricas: sin(θ) onde θ = k Δx.",
                                  "learningObjective": "Quantificar dispersão e dissipação via análise espectral de Von Neumann.",
                                  "commonMistakes": "Confundir fator de amplificação com velocidade de fase ou erros em aproximações pequenas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e comparar resultados para esquemas",
                                  "subSteps": [
                                    "Compare Lax-Wendroff (2ª ordem, baixa dissipação) com Lax-Friedrichs (alta dissipação).",
                                    "Identifique regimes onde dispersão domina (ondas de alta frequência).",
                                    "Calcule coeficientes numéricos para um λ específico.",
                                    "Discuta trade-offs: precisão vs. estabilidade.",
                                    "Sugira modificações para reduzir dispersão/dissipação."
                                  ],
                                  "verification": "Escreva relatório comparando coeficientes para dois esquemas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos gerados no passo anterior, tabela de comparação.",
                                  "tips": "Foque em k Δx próximo a π para oscilações.",
                                  "learningObjective": "Analisar implicações práticas dos termos calculados.",
                                  "commonMistakes": "Ignorar dependência em λ ou generalizar inadequadamente."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + c u_x = 0 com c=1, λ=0.9, no esquema Lax-Wendroff, a expansão de Taylor revela termo de dispersão O(Δt^3): (c Δx^2 / 6) u_xxx, causando oscilações atrás da onda. Von Neumann mostra |g| ≈ 1 - (λ^3 sin^3(θ)/6), dissipação fraca, e erro de fase levando a propagação lenta de picos.",
                              "finalVerifications": [
                                "Deriva corretamente os termos de truncagem de Taylor para Lax-Wendroff até ordem 3.",
                                "Calcula fator de amplificação g(k) e plota |g| ≤ 1 para todo k.",
                                "Identifica coeficientes de dissipação (termo par) e dispersão (ímpar).",
                                "Compara qualitativamente com outro esquema como upwind.",
                                "Explica impacto em uma simulação numérica simples.",
                                "Propõe correção para alta dispersão."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas expansões (sem erros algébricos).",
                                "Correta interpretação de coeficientes como dissipativos/dispersivos.",
                                "Uso apropriado de análise Von Neumann com gráficos.",
                                "Profundidade na comparação entre métodos.",
                                "Clareza na ligação com estabilidade e precisão.",
                                "Criatividade em aplicações ou modificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e análise modal em mecânica quântica.",
                                "Computação Científica: Implementação de solvers em CFD (ex: OpenFOAM).",
                                "Engenharia: Simulações de fluxos hiperbólicos em aerodinâmica.",
                                "Matemática Aplicada: Teoria de Fourier e estabilidade de PDEs."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos compressíveis (ex: choques em jatos supersônicos), análise de dispersão/dissipação garante precisão em propagação de frentes de onda sem oscilações espúrias, essencial para previsão meteorológica e design de aeronaves."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.4.3",
                            "name": "Avaliar impacto em simulações hiperbólicas",
                            "description": "Interpretar numericamente os efeitos de dispersão e dissipação em soluções de equações de onda, propondo esquemas de baixa dissipação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos de dispersão e dissipação em equações hiperbólicas",
                                  "subSteps": [
                                    "Estudar a definição de dispersão numérica: diferença entre velocidade de fase numérica e exata.",
                                    "Analisar dissipação: atenuação artificial de amplitudes em esquemas numéricos.",
                                    "Derivar a relação de dispersão para métodos de diferenças finitas em equações de onda.",
                                    "Examinar símbolos de amplificação para dissipação em esquemas explícitos e implícitos.",
                                    "Comparar esquemas de alta ordem versus baixa ordem em termos de dispersão/dissipação."
                                  ],
                                  "verification": "Resumir em um diagrama as curvas de dispersão para diferentes esquemas e identificar regiões de erro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque 'Finite Difference Methods'), notebook Jupyter com Python/MATLAB"
                                  ],
                                  "tips": "Use gráficos de relação de dispersão vs. número de onda para visualização intuitiva.",
                                  "learningObjective": "Compreender matematicamente dispersão e dissipação como erros de fase e amplitude.",
                                  "commonMistakes": [
                                    "Confundir dispersão com difusão física",
                                    "Ignorar o papel do passo de tempo Δt"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar simulação numérica básica de equação de onda 1D",
                                  "subSteps": [
                                    "Configurar malha espacial e temporal com condições de contorno periódicas.",
                                    "Implementar esquema de Lax-Friedrichs ou Leapfrog para resolver ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Gerar pulso gaussiano inicial e simular propagação por 1000 passos temporais.",
                                    "Plotar solução numérica vs. solução exata em diferentes tempos.",
                                    "Calcular normas L2 de erro para quantificar dispersão acumulada."
                                  ],
                                  "verification": "Gerar plots mostrando oscilações espúrias atrás da onda (dispersão) e atenuação (dissipação).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy, SciPy, Matplotlib; ou MATLAB"
                                  ],
                                  "tips": "Escolha Δx = Δt * c para estabilidade CFL=1 em esquemas explícitos.",
                                  "learningObjective": "Dominar implementação de solvers numéricos para equações hiperbólicas.",
                                  "commonMistakes": [
                                    "Violar condição CFL levando a instabilidade",
                                    "Usar malha muito grosseira mascarando erros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar numericamente efeitos de dispersão e dissipação",
                                  "subSteps": [
                                    "Extrair perfis de fase e amplitude da solução numérica via FFT.",
                                    "Calcular erro de dispersão: Δω(k) = ω_num(k) - ω_exata(k) para modos k.",
                                    "Quantificar dissipação via decaimento exponencial de amplitudes de Fourier.",
                                    "Plotar curvas de dispersão/dissipação vs. número de pontos por comprimento de onda.",
                                    "Comparar múltiplos esquemas (ex: Lax-Wendroff vs. upwind)."
                                  ],
                                  "verification": "Produzir tabela com erros de dispersão/dissipação para 3 esquemas e Δx variadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Bibliotecas FFT (NumPy.fft), scripts de análise de erros"
                                  ],
                                  "tips": "Normalize frequências pelo número de onda exato para comparações precisas.",
                                  "learningObjective": "Interpretar soluções numéricas em domínio de Fourier para erros.",
                                  "commonMistakes": [
                                    "FFT sem janelamento causando vazamento espectral",
                                    "Não normalizar erros por comprimento de onda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto e propor esquemas de baixa dissipação",
                                  "subSteps": [
                                    "Simular cenários realistas (onda com múltiplos comprimentos de onda) e medir impacto em precisão.",
                                    "Analisar trade-offs: baixa dissipação vs. custo computacional.",
                                    "Implementar esquemas de baixa dissipação (ex: DRP de Tam ou filtros espectrais).",
                                    "Otimizar parâmetros para minimizar erros em faixas de k relevantes.",
                                    "Documentar recomendações baseadas em métricas quantitativas."
                                  ],
                                  "verification": "Relatório com plots comparativos mostrando redução >50% em erros para esquema proposto.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Códigos otimizados, referências como Tam & Webb (1993)"
                                  ],
                                  "tips": "Use esquemas Runge-Kutta de alta ordem para acoplamento tempo-espaço.",
                                  "learningObjective": "Propor melhorias numéricas baseadas em análise quantitativa.",
                                  "commonMistakes": [
                                    "Propor esquemas instáveis",
                                    "Ignorar custo computacional em propostas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a propagação de um pulso gaussiano em uma corda 1D usando esquema Leapfrog: observe dispersão como oscilações traseiras e dissipação como decaimento da amplitude frontal; proponha filtro de baixa passagem para mitigar.",
                              "finalVerifications": [
                                "Pode derivar e plotar relação de dispersão para esquema dado.",
                                "Implementa simulação estável e calcula erros L2/FFT.",
                                "Identifica corretamente regiões de alta dispersão/dissipação.",
                                "Propõe esquema alternativo com evidência quantitativa de melhoria.",
                                "Explica impacto em precisão de simulações longas (>10 períodos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica (80% match com literatura).",
                                "Corretude da implementação numérica (erro L2 <1e-2).",
                                "Profundidade da análise quantitativa (gráficos + métricas).",
                                "Criatividade e viabilidade da proposta de esquema.",
                                "Clareza na documentação de impactos e trade-offs.",
                                "Uso adequado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas/sísmicas.",
                                "Computação: Análise de Fourier e otimização numérica.",
                                "Engenharia: Simulações CFD para fluxos compressíveis.",
                                "Estatística: Análise de erros e validação de modelos."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, onde dispersão artificial pode distorcer velocidades de ondas P/S, ou em aeroacústica para modelar ruído de aviões sem dissipação excessiva de altas frequências."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Noções de Dispersão Numérica",
                    "description": "Fenômeno de dispersão em esquemas numéricos para equações hiperbólicas e sua análise.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Fenômeno de Dispersão Numérica",
                        "description": "Compreensão do fenômeno de dispersão como uma distorção de fase nas soluções numéricas de equações hiperbólicas, onde ondas de diferentes frequências propagam a velocidades diferentes da onda física.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar dispersão em soluções numéricas",
                            "description": "Reconhecer padrões de dispersão em gráficos de soluções numéricas para a equação de advecção linear, comparando com a solução exata e identificando oscilações de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos da equação de advecção linear e dispersão numérica",
                                  "subSteps": [
                                    "Estude a forma padrão da equação de advecção linear: ∂u/∂t + c ∂u/∂x = 0, onde c é a velocidade de advecção.",
                                    "Defina dispersão numérica como o fenômeno onde esquemas numéricos introduzem erros de fase, levando a oscilações espúrias de alta frequência atrás da frente de onda.",
                                    "Revise conceitos de estabilidade e consistência em métodos de diferenças finitas.",
                                    "Analise o papel do número de Courant (C = c Δt / Δx) na propagação de erros.",
                                    "Identifique que dispersão é distinta de dissipação, focando em ondas não físicas de alta frequência."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre dispersão e dissipação, com um esboço de gráfico ilustrativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: LeVeque), notas de aula, papel e caneta para esboços.",
                                  "tips": "Use analogias com ondas oceânicas para visualizar como picos se espalham desigualmente.",
                                  "learningObjective": "Compreender conceitualmente a dispersão numérica na equação de advecção.",
                                  "commonMistakes": "Confundir dispersão com amortecimento (dissipação); ignorar dependência do esquema numérico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e visualizar a solução exata da equação de advecção",
                                  "subSteps": [
                                    "Escolha condições iniciais simples, como u(x,0) = sen(2πx) ou uma função degrau.",
                                    "Derive a solução exata: u(x,t) = u(x - c t, 0), que propaga sem distorção.",
                                    "Plote a solução exata em diferentes tempos t usando software.",
                                    "Observe características: forma preservada, sem oscilações.",
                                    "Compare com solução em t=0 para confirmar preservação exata."
                                  ],
                                  "verification": "Gere plots idênticos à forma inicial deslocada, sem distorções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com Matplotlib/NumPy ou MATLAB, condições iniciais pré-definidas.",
                                  "tips": "Use grids finos (Δx pequeno) para plots suaves; fixe c=1 para simplicidade.",
                                  "learningObjective": "Dominar a solução exata como referência para detecção de erros numéricos.",
                                  "commonMistakes": "Esquecer o deslocamento exato c t; plotar em escalas inadequadas que mascaram diferenças."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e gerar soluções numéricas com esquemas suscetíveis a dispersão",
                                  "subSteps": [
                                    "Implemente o esquema Lax-Wendroff para a equação de advecção.",
                                    "Escolha parâmetros: Δx=0.01, Δt tal que C≈0.9, grid [0,2] com 200 pontos.",
                                    "Execute simulação até t=1 e plote em tempos intermediários.",
                                    "Repita com esquema upwind para contraste (menos dispersivo).",
                                    "Observe oscilações atrás da onda principal no Lax-Wendroff."
                                  ],
                                  "verification": "Plots mostram solução numérica com ondulações de alta frequência vs. exata lisa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Jupyter Notebook com código template para esquemas FD, computador.",
                                  "tips": "Salve plots em sequência animada para visualizar evolução temporal das oscilações.",
                                  "learningObjective": "Gerar dados numéricos que exibam dispersão para análise.",
                                  "commonMistakes": "Número de Courant instável (>1); resolução espacial insuficiente que confunde erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar soluções e identificar padrões de dispersão",
                                  "subSteps": [
                                    "Sobreponha plots: exata (linha sólida), numérica (linha tracejada).",
                                    "Identifique oscilações de alta frequência: comprimentos de onda ~2Δx atrás da frente.",
                                    "Meça erro de fase: deslocamento da crista principal vs. exata.",
                                    "Quantifique dispersão via análise espectral (opcional: FFT para componentes altas freq.).",
                                    "Documente padrões: amplitude crescente com tempo, dependência do esquema."
                                  ],
                                  "verification": "Relatório curto destacando 3 oscilações específicas e sua relação com Δx.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Plots gerados anteriormente, software de plotagem, régua digital para medições.",
                                  "tips": "Amplie regiões atrás da onda para melhor visualização de oscilações finas.",
                                  "learningObjective": "Reconhecer visual e quantitativamente dispersão em gráficos.",
                                  "commonMistakes": "Atribuir oscilações à solução exata; ignorar escalas de eixo que distorcem percepção."
                                }
                              ],
                              "practicalExample": "Para a equação ∂u/∂t + ∂u/∂x = 0 com u(x,0) = exp(-(x-0.5)^2 / 0.01) (gaussiana centrada em x=0.5), plote solução exata em t=0.5 (centrada em x=1.0). No esquema Lax-Wendroff com Δx=0.05, observe oscilações rippling de alta frequência (2-4 ciclos) imediatamente atrás do pico em t=0.5, ausentes na exata.",
                              "finalVerifications": [
                                "Descreve corretamente dispersão como oscilações de alta frequência em soluções numéricas.",
                                "Identifica dispersão em gráfico fornecido sem solução exata.",
                                "Compara fase e amplitude entre numérica e exata.",
                                "Explica impacto do esquema (ex: Lax-Wendroff vs. upwind).",
                                "Sugere refinamento (reduzir Δx) para mitigar.",
                                "Aplica a diferentes condições iniciais (senoidal vs. degrau)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de oscilações (90% das instâncias corretas).",
                                "Explicação conceitual clara e sem confusões com dissipação.",
                                "Uso correto de ferramentas para plots e comparações.",
                                "Quantificação qualitativa/quantitativa de erros (ex: contagem de picos).",
                                "Conexão com parâmetros numéricos (Δt, Δx, C).",
                                "Criatividade em exemplos adicionais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas ou transporte de poluentes.",
                                "Computação: Análise de erros em simulações CFD (Computational Fluid Dynamics).",
                                "Engenharia: Otimização de esquemas em software de simulação como COMSOL.",
                                "Estatística: Análise espectral para detecção de ruído numérico."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, identificar dispersão em modelos de advecção de umidade previne previsões errôneas de frentes de chuva; em engenharia acústica, corrige artefatos em simulações de propagação de som em tubos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Explicar causas da dispersão",
                            "description": "Descrever como a truncagem em esquemas de diferenças finitas leva a uma relação dispersiva entre frequência numérica e velocidade de fase, usando a equação de onda como exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação de onda e suas propriedades exatas",
                                  "subSteps": [
                                    "Estudar a equação de onda unidimensional: ∂²u/∂t² = c² ∂²u/∂x²",
                                    "Analisar a solução exata via d'Alembert: u(x,t) = f(x - c t) + g(x + c t)",
                                    "Derivar a velocidade de fase exata: ω / k = c, constante para todas as frequências",
                                    "Explicar ausência de dispersão física: todas as componentes viajam à mesma velocidade",
                                    "Resolver numericamente uma solução plana: u(x,t) = cos(k x - ω t) com ω = c k"
                                  ],
                                  "verification": "Derivar corretamente a velocidade de fase a partir da solução exata e explicar por que não há dispersão",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de equações diferenciais, caderno, calculadora simbólica (ex: Wolfram Alpha)",
                                  "tips": "Visualize ondas como superposição de planos; foque na independência de k",
                                  "learningObjective": "Entender as propriedades dispersivas nulas da equação de onda contínua",
                                  "commonMistakes": "Confundir velocidade de fase com velocidade de grupo ou assumir dispersão física"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir discretização via diferenças finitas",
                                  "subSteps": [
                                    "Definir malha espaço-tempo: x_i = i Δx, t_n = n Δt, r = c Δt / Δx",
                                    "Formular o esquema explícito centrado: u_i^{n+1} = 2(1 - r²) u_i^n + r² (u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}",
                                    "Verificar consistência pelo limite Δx, Δt → 0",
                                    "Discutir estabilidade via condição CFL: r ≤ 1",
                                    "Implementar em pseudocódigo uma iteração simples do esquema"
                                  ],
                                  "verification": "Escrever o esquema corretamente e verificar consistência expandindo em Taylor",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, software como Python/MATLAB para pseudocódigo",
                                  "tips": "Sempre normalize com r para simplicidade; teste com r=1 para onda sem dispersão numérica",
                                  "learningObjective": "Dominar a formulação discreta da equação de onda",
                                  "commonMistakes": "Esquecer o termo -u_i^{n-1} ou usar aproximações forward inadequadas"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o erro de truncagem local no esquema",
                                  "subSteps": [
                                    "Expandir u(x_i, t_{n+1}) via série de Taylor em torno de (x_i, t_n)",
                                    "Mostrar truncagem O(Δt⁴ + Δx⁴ + Δt² Δx²) para esquema centrado",
                                    "Identificar termos de erro que introduzem dependência em frequências altas",
                                    "Comparar com esquema exato: erro zero apenas para r=1 e baixas frequências",
                                    "Calcular erro local para uma onda plana de frequência k"
                                  ],
                                  "verification": "Derivar os termos principais de truncagem e identificá-los como fonte potencial de dispersão",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno para expansões Taylor, calculadora para coeficientes",
                                  "tips": "Use simetria temporal e espacial para simplificar expansões",
                                  "learningObjective": "Reconhecer como erros de ordem superior afetam altas frequências",
                                  "commonMistakes": "Ignorar termos mistos Δt² Δx² ou parar na ordem 2 prematuramente"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e interpretar a relação dispersiva via análise de von Neumann",
                                  "subSteps": [
                                    "Assumir solução plana: u_i^n = ξ^n e^{i θ i}, com θ = k Δx (frequência numérica)",
                                    "Substituir no esquema: obter relação dispersiva sin(ω Δt / 2) / (Δt / 2) = c [sin(θ / 2) / (Δx / 2)]",
                                    "Analisar velocidade de fase numérica: c_num = [sin(θ / 2) / (θ / 2)] c",
                                    "Mostrar que c_num < c para θ > 0, com dispersão: altas frequências (θ ≈ π) propagam mais devagar",
                                    "Plotar c_num vs θ para visualizar o fenômeno"
                                  ],
                                  "verification": "Derivar a equação dispersiva e plotar gráfico de c_num(θ) mostrando redução para altas frequências",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Excel/Python), papel para derivação",
                                  "tips": "Use identidade trigonométrica para ξ; foque em |ξ|=1 para neutralidade",
                                  "learningObjective": "Explicar como truncagem causa relação dispersiva ω_num(k) ≠ c k",
                                  "commonMistakes": "Confundir frequência numérica θ com k físico ou ignorar normalização por Δx"
                                }
                              ],
                              "practicalExample": "Simule numericamente uma pulso gaussiano inicial na equação de onda com r=0.9 em Python (usando numpy/matplotlib). Observe que componentes de alta frequência (bordas do pulso) propagam mais lentamente que o centro, distorcendo o pulso ao longo do tempo, ilustrando a dispersão numérica.",
                              "finalVerifications": [
                                "Derivar corretamente a relação dispersiva sin(ω Δt / 2)/(Δt / 2) = c sin(θ / 2)/(Δx / 2)",
                                "Explicar verbalmente por que altas frequências numéricas têm velocidade de fase reduzida",
                                "Identificar erro de truncagem como causa raiz da dispersão",
                                "Plotar e interpretar gráfico de velocidade de fase numérica vs frequência numérica",
                                "Comparar simulação numérica com solução exata, destacando distorção",
                                "Propor melhorias como esquemas de alta ordem para reduzir dispersão"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação dispersiva (equação exata)",
                                "Correta interpretação física: ligação truncagem → dispersão",
                                "Qualidade do gráfico c_num(θ), com limites corretos (1 em θ=0, 0 em θ=π)",
                                "Identificação de pelo menos 3 termos de erro de truncagem relevantes",
                                "Explicação clara da independência de frequência na contínua vs dependência na discreta",
                                "Aplicação correta da análise de von Neumann (amplificação e fase)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas acústicas e eletromagnéticas",
                                "Computação Científica: Análise de estabilidade e erro em PDEs numéricas",
                                "Engenharia Civil: Modelagem de ondas sísmicas em simulações",
                                "Processamento de Sinais: Análise espectral e filtros digitais"
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, a dispersão numérica pode distorcer a chegada de ondas P e S, levando a erros em modelos de risco; esquemas dispersão-livres são usados em software como SPECFEM para precisão em prospecção de petróleo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Diferenciar dispersão de dissipação",
                            "description": "Comparar dispersão (alteração de fase) com dissipação (amortecimento de amplitude), ilustrando ambos em esquemas explícitos para equações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de dispersão e dissipação",
                                  "subSteps": [
                                    "Ler definições padrão: dispersão como distorção de fase (ondas de diferentes frequências viajam em velocidades diferentes), dissipação como decaimento de amplitude devido a amortecimento.",
                                    "Estudar contexto em equações hiperbólicas (ex: equação da onda ∂²u/∂t² = c² ∂²u/∂x²).",
                                    "Identificar dispersão numérica em esquemas de diferenças finitas (ex: relação de dispersão ω(κΔx)).",
                                    "Identificar dissipação numérica como termo imaginário na análise de von Neumann.",
                                    "Compilar glossário pessoal com termos chave: fase, amplitude, estabilidade numérica."
                                  ],
                                  "verification": "Criar um mapa mental conectando dispersão (fase) e dissipação (amplitude) com exemplos verbais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: LeVeque), notas de aula, papel e caneta para mapa mental.",
                                  "tips": "Use analogias físicas: dispersão como prisma de luz separando cores, dissipação como atrito em um pêndulo.",
                                  "learningObjective": "Dominar definições conceituais para evitar confusão entre fenômenos físicos e numéricos.",
                                  "commonMistakes": "Confundir dispersão física com numérica; ignorar que ambos podem ocorrer simultaneamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar diferenças matemáticas via análise de von Neumann",
                                  "subSteps": [
                                    "Implementar análise de von Neumann para esquema Lax-Friedrichs em equação da onda.",
                                    "Calcular símbolo de amplificação g(κΔx) = |g| e^{iφ}, identificando |g|<1 como dissipação e φ ≠ ωΔt como dispersão.",
                                    "Derivar relação de dispersão numérica: sin(φ/2) / (Δt/2) vs frequência exata.",
                                    "Plotar curvas de dispersão (ω_num vs ω_exata) e dissipação (|g| vs κΔx).",
                                    "Comparar esquemas: Lax-Wendroff (dispersivo) vs upwind (dissipativo)."
                                  ],
                                  "verification": "Gerar gráficos mostrando curvas de dispersão e dissipação para pelo menos dois esquemas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com NumPy/Matplotlib, template de código para von Neumann (disponível online).",
                                  "tips": "Comece com Δx=Δt=0.1 para visualização clara; normalize frequências por π.",
                                  "learningObjective": "Entender representações matemáticas quantitativas das diferenças.",
                                  "commonMistakes": "Esquecer fator i no expoente para fase; confundir erro de fase com erro de amplitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar esquemas explícitos ilustrativos",
                                  "subSteps": [
                                    "Desenhar diagrama de onda exata vs numérica dispersiva (oscilações atrás da frente de onda).",
                                    "Esboçar onda dissipativa (amplitude decaindo sem distorção de fase).",
                                    "Usar software para simular: resolver equação da onda com barreira inicial gaussiana.",
                                    "Anotar esquemas com setas: 'dispersão → mudança de fase' e 'dissipação → redução de amplitude'.",
                                    "Comparar side-by-side: dispersão (oscilações espúrias) vs dissipação (suavização excessiva)."
                                  ],
                                  "verification": "Produzir 3 diagramas rotulados (onda exata, dispersiva, dissipativa) com legendas explicativas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de desenho (Draw.io, PowerPoint), código de simulação do Step 2.",
                                  "tips": "Escalone tempo/espaço para destacar diferenças; use cores: azul para fase, vermelho para amplitude.",
                                  "learningObjective": "Visualizar diferenças para retenção intuitiva.",
                                  "commonMistakes": "Diagramas não escalados corretamente; omitir condições iniciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e sintetizar conhecimentos em comparação prática",
                                  "subSteps": [
                                    "Simular problema teste: pulso gaussiano propagando em 1D com esquemas dispersivo e dissipativo.",
                                    "Medir métricas: erro de fase (dispersão) e norma L2 de amplitude (dissipação).",
                                    "Escrever relatório curto comparando impactos em precisão numérica.",
                                    "Discutir trade-offs: esquemas dispersivos preservam energia mas oscilam; dissipativos estabilizam mas amortecem.",
                                    "Testar refinamento de malha: dispersão melhora com h→0, dissipação persiste se artificial."
                                  ],
                                  "verification": "Relatório de 1 página com simulações, métricas e conclusões.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código de simulação expandido, template de relatório.",
                                  "tips": "Use animações GIF para propagação temporal; compare com solução exata via d'Alembert.",
                                  "learningObjective": "Integrar conceitos em análise crítica de métodos numéricos.",
                                  "commonMistakes": "Atribuir dissipação a dispersão em simulações ruidosas; ignorar CFL condition."
                                }
                              ],
                              "practicalExample": "Simule a equação da onda ∂²u/∂t² = ∂²u/∂x² com pulso gaussiano u(x,0)=exp(-x²/0.1), usando esquema Lax-Wendroff (dispersivo: oscilações pós-frente) vs Lax-Friedrichs (dissipativo: amplitude reduzida sem oscilações), plotando em t=1 e t=2 para comparar distorção de fase vs decaimento.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença sem consultar notas.",
                                "Identificar dispersão/dissipação em gráfico de simulação desconhecido.",
                                "Derivar símbolo de amplificação para esquema simples.",
                                "Criar diagrama ilustrativo do zero.",
                                "Discutir quando preferir esquema dispersivo vs dissipativo.",
                                "Medir erros em simulação própria com precisão <10%."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusão (30%).",
                                "Profundidade matemática: análise von Neumann com gráficos (25%).",
                                "Qualidade visual: esquemas claros e rotulados (20%).",
                                "Síntese prática: simulações com métricas quantitativas (15%).",
                                "Clareza explicativa: relatório conciso e lógico (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas acústicas/elásticas (dispersão em meios heterogêneos).",
                                "Engenharia Computacional: CFD para simulações hiperbólicas (controle de erros numéricos).",
                                "Processamento de Sinais: Análise espectral de filtros digitais.",
                                "Física Computacional: Modelagem de plasma ou fluidos compressíveis."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, diferenciar dispersão (distorção de chegada de ondas P/S) de dissipação (atenuação por materiais) otimiza esquemas numéricos para precisão em reservatórios de óleo, evitando artefatos que levam a erros em prospecção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Análise de Dispersão via Von Neumann",
                        "description": "Técnica de análise de estabilidade de Von Neumann aplicada à quantificação da dispersão em esquemas numéricos para equações hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Calcular o símbolo de dispersão",
                            "description": "Derivar a relação dispersiva ξ(kΔx) para esquemas como Lax-Wendroff na equação de advecção, plotando velocidade de fase numérica versus kΔx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a equação de advecção e o esquema Lax-Wendroff",
                                  "subSteps": [
                                    "Escreva a equação de advecção unidimensional: ∂u/∂t + a ∂u/∂x = 0, onde a > 0 é a velocidade de advecção.",
                                    "Defina a malha numérica uniforme com Δx (espaçamento espacial) e Δt (passo temporal), satisfazendo a condição CFL: |a|Δt/Δx ≤ 1.",
                                    "Apresente o esquema Lax-Wendroff explícito: u_j^{n+1} = u_j^n - (aΔt/(2Δx))(u_{j+1}^n - u_{j-1}^n) + (a²Δt²/(2Δx²))(u_{j+1}^n - 2u_j^n + u_{j-1}^n).",
                                    "Introduza o número de Courant σ = aΔt/Δx e reescreva o esquema em termos de σ.",
                                    "Verifique a consistência do esquema com a equação diferencial via expansão de Taylor."
                                  ],
                                  "verification": "Confirme que o esquema está corretamente escrito e satisfaz a ordem de truncamento O(Δt² + Δx²).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto (LaTeX/Jupyter Notebook); referência ao livro de análise numérica.",
                                  "tips": "Sempre normalize com σ para simplificar cálculos futuros.",
                                  "learningObjective": "Entender a formulação exata do esquema Lax-Wendroff para análise de estabilidade.",
                                  "commonMistakes": "Esquecer o termo de segunda ordem ou sinal incorreto nos coeficientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar análise de Von Neumann: assumir solução de Fourier",
                                  "subSteps": [
                                    "Assuma uma solução modal u_j^n = ξ^n e^{i k j Δx}, onde ξ = ξ(kΔx) é o símbolo de amplificação e k é o número de onda.",
                                    "Substitua esta forma no esquema Lax-Wendroff para obter a relação ξ^{n+1} e^{i k j Δx} em termos de ξ^n.",
                                    "Simplifique dividindo por ξ^n e^{i k j Δx}, resultando em ξ = 1 - i σ sin(θ)/2 - (σ²/2)(1 - cos(θ)), onde θ = k Δx.",
                                    "Expresse ξ em forma polar: ξ = |ξ| e^{i φ}, identificando o módulo |ξ| e a fase φ(θ).",
                                    "Verifique que |ξ| ≈ 1 para baixa dispersão em regimes bem resolvidos."
                                  ],
                                  "verification": "Derive ξ(θ) explicitamente e confira que para θ=0, ξ=1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica) ou papel para trigonometria.",
                                  "tips": "Use identidades trigonométricas: sin(θ) e 1-cos(θ)=2 sin²(θ/2) para simplificar.",
                                  "learningObjective": "Dominar a substituição de Fourier na análise de Von Neumann.",
                                  "commonMistakes": "Erro de fase no expoente ou divisão incorreta por termos comuns."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a relação dispersiva e velocidade de fase numérica",
                                  "subSteps": [
                                    "Extraia o argumento φ(θ) = arg(ξ(θ)) = Im(log(ξ)) ou atan2 da parte imaginária/real.",
                                    "Defina a velocidade de fase numérica c_ph_num = (φ(θ)/θ) * a, onde θ = k Δx.",
                                    "Compare com a velocidade exata c_ph_exact = a, destacando dispersão numérica quando c_ph_num ≠ a.",
                                    "Analise numericamente: para θ pequeno, expanda φ(θ) ≈ -θ + O(θ³) para mostrar dispersão de ordem 2.",
                                    "Calcule ξ(kΔx) para valores específicos de σ (ex: σ=0.5)."
                                  ],
                                  "verification": "Confirme que lim_{θ→0} c_ph_num = a e calcule dispersão para θ=π.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (Python com NumPy/Matplotlib ou MATLAB).",
                                  "tips": "Use unwrap da fase para plots contínuos.",
                                  "learningObjective": "Calcular e interpretar a dispersão via símbolo ξ.",
                                  "commonMistakes": "Confundir velocidade de fase com velocidade de grupo; erro no sinal de φ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e analisar velocidade de fase numérica versus kΔx",
                                  "subSteps": [
                                    "Gere θ de 0 a π (kΔx de 0 a π/Δx).",
                                    "Implemente função ξ(θ, σ) em código e compute c_ph_num(θ).",
                                    "Plote c_ph_num / a vs θ, sobrepondo a linha c=1 (exata).",
                                    "Analise: regime bem resolvido (θ<<π), dispersão leading/trailing waves (θ≈π).",
                                    "Varie σ e discuta impacto na dispersão."
                                  ],
                                  "verification": "O plot mostra c_ph_num < a para θ>0, com oscilações; código reproduzível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (Jupyter Notebook com Matplotlib) ou MATLAB; script pronto para ξ.",
                                  "tips": "Use np.linspace(0, np.pi, 1000) para resolução suave.",
                                  "learningObjective": "Visualizar e interpretar dispersão numérica graficamente.",
                                  "commonMistakes": "Escala errada em kΔx (deve ser 0 a π); plot sem normalização por a."
                                }
                              ],
                              "practicalExample": "Para a equação u_t + u_x = 0 com σ=0.5, derive ξ(θ) = 1 - i (0.5) sin(θ) - 0.125 (1 - cos(θ)). Plote c_ph_num vs θ: observe que para θ=2 rad, c_ph_num ≈ 0.85a, indicando ondas de cauda atrasadas, comum em simulações de advecção de pulsos.",
                              "finalVerifications": [
                                "ξ(0) = 1 e |ξ(θ)| ≤ 1 + O(Δt²) para todos θ.",
                                "Velocidade de fase numérica tende a a para kΔx → 0.",
                                "Plot exibe dispersão não monotônica, com mínimo em θ≈π/2.",
                                "Código reproduz plot idêntico ao derivado analiticamente.",
                                "Análise qualitativa explica leading/trailing waves corretamente.",
                                "Variação com σ mostra redução de dispersão para σ→1."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de ξ(θ): 100% dos termos corretos.",
                                "Correta extração de φ(θ) e c_ph_num sem erros trigonométricos.",
                                "Qualidade do plot: eixos rotulados, legenda, resolução adequada.",
                                "Interpretação física: ligação entre dispersão e comportamento de ondas.",
                                "Generalização para outros esquemas (ex: Lax-Friedrichs).",
                                "Eficiência computacional: vetorização em código."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e dispersão em equações hiperbólicas (ex: equação das ondas).",
                                "Programação: Implementação numérica em Python/MATLAB para visualização científica.",
                                "Matemática Aplicada: Séries de Fourier e análise assintótica.",
                                "Engenharia: Simulações CFD onde dispersão afeta precisão de choques.",
                                "Estatística: Análise de erro numérico e convergência."
                              ],
                              "realWorldApplication": "Em simulações numéricas de fluxo de fluidos (CFD), como previsão de tempo ou aerodinâmica, o cálculo de dispersão via Von Neumann otimiza escolhas de Δx/Δt para minimizar distorções de fase em propagação de ondas acústicas ou frentes de choque, evitando erros em modelos climáticos ou design de aviões."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Analisar erro de fase",
                            "description": "Quantificar o erro de fase acumulado ao longo do tempo em simulações hiperbólicas, usando a função de amplificação complexa g(θ) = |g|e^{iφ}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a análise de Von Neumann para o esquema numérico",
                                  "subSteps": [
                                    "Selecione uma equação hiperbólica modelo, como a equação da onda 1D: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Escolha um esquema numérico explícito, como Lax-Wendroff, e defina o fator de Courant σ = c Δt / Δx.",
                                    "Assuma uma solução modal u_j^n = g^n e^{i k j Δx}, onde θ = k Δx é o número de onda.",
                                    "Derive a função de amplificação g(θ) = |g| e^{iφ} a partir da relação de recorrência do esquema.",
                                    "Implemente a derivação simbólica ou numérica em código."
                                  ],
                                  "verification": "Verifique se g(θ) satisfaz |g(θ)| ≤ 1 para estabilidade e φ(θ) ≈ -c k Δt para baixa dispersão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno de anotações, Python/MATLAB com SymPy/NumPy, referência do livro de análise numérica.",
                                  "tips": "Comece com esquemas simples para validar a derivação antes de esquemas mais complexos.",
                                  "learningObjective": "Entender a base da análise de Von Neumann para dispersão em esquações hiperbólicas.",
                                  "commonMistakes": "Esquecer o fator de Courant na relação de amplificação ou confundir θ com k."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e plotar a fase φ(θ) da função de amplificação",
                                  "subSteps": [
                                    "Calcule g(θ) numericamente para θ de 0 a π em uma grade fina (ex: 100 pontos).",
                                    "Extraia φ(θ) = arg(g(θ)) usando atan2(Im(g), Re(g)) para evitar ambiguidades de ramo.",
                                    "Compare φ(θ) com a fase exata φ_exata(θ) = -σ sin(θ).",
                                    "Plote φ(θ) vs θ e φ_exata(θ) vs θ para visualizar o erro de fase por step.",
                                    "Calcule o erro de fase relativo ε(θ) = |φ(θ) - φ_exata(θ)|."
                                  ],
                                  "verification": "O plot deve mostrar boa aproximação para θ pequeno e dispersão crescente para θ próximo a π.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com Matplotlib/NumPy, script do Step 1.",
                                  "tips": "Use unwrap(φ) se necessário para continuidade da fase.",
                                  "learningObjective": "Dominar a extração da componente de fase da amplificação complexa.",
                                  "commonMistakes": "Não usar atan2 corretamente, levando a saltos de 2π na fase."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Quantificar o erro de fase acumulado ao longo do tempo",
                                  "subSteps": [
                                    "Defina o erro de fase por step como Δφ(θ) = φ(θ) + σ sin(θ).",
                                    "Calcule o erro acumulado após N steps: Φ(N,θ) = N Δφ(θ).",
                                    "Avalie para diferentes N (ex: 10, 100, 1000) e θ variados.",
                                    "Normalize pelo número de passos ou comprimento de onda para comparabilidade.",
                                    "Analise o impacto: frequência aparente ω_app = φ(θ)/Δt vs exata."
                                  ],
                                  "verification": "Confirme que |Φ(N,θ)| cresce linearmente com N e é pequeno para θ baixo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Script Python do Step 2, planilha para tabulação.",
                                  "tips": "Escolha N baseado no tempo de simulação realista (ex: T = N Δt fixo).",
                                  "learningObjective": "Quantificar numericamente a dispersão de fase em simulações de longo prazo.",
                                  "commonMistakes": "Acumular φ diretamente sem corrigir pelo exato, ou ignorar o sinal do erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e otimizar o esquema",
                                  "subSteps": [
                                    "Identifique regimes de θ onde |Δφ(θ)| > 0.01 (limiar de dispersão significativa).",
                                    "Compare com |g(θ)| para dissociação de dispersão vs amortecimento.",
                                    "Teste refinamento de malha (Δx menor) e veja se erro diminui como O(Δx²).",
                                    "Proponha ajustes ao esquema (ex: filtros de fase) para mitigar.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Relatório explica causas e soluções para erro de fase >5% em θ médio.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Scripts anteriores, software de plotagem avançada.",
                                  "tips": "Use log-log plots para ordem de convergência.",
                                  "learningObjective": "Aplicar análise para melhorar precisão numérica em simulações hiperbólicas.",
                                  "commonMistakes": "Atribuir dispersão a instabilidade quando é puramente fase."
                                }
                              ],
                              "practicalExample": "Em uma simulação da equação da onda 1D com esquema Lax-Friedrichs (σ=0.9), calcule g(θ) = (1 - 2σ²(1-cosθ)) + i σ sinθ √(1-σ²(1-cosθ)²). Para θ=π/2 e N=1000 steps, o erro acumulado Φ≈15 radianos causa defasagem de ~2 ciclos, distorcendo pacotes de onda de alta frequência.",
                              "finalVerifications": [
                                "Função g(θ) derivada corretamente e |g|≤1 para todo θ.",
                                "φ(θ) extraída sem discontinuidades e plotada com exata.",
                                "Erro acumulado Φ(N,θ) calculado para pelo menos 3 valores de N e θ.",
                                "Análise qualitativa identifica θ críticos de dispersão.",
                                "Convergência verificada com refinamento h.",
                                "Relatório resume achados com plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de g(θ): 100% match com fórmula padrão.",
                                "Qualidade dos plots: eixos rotulados, escalas adequadas, legenda.",
                                "Correção do cálculo de Δφ e Φ: erro <1% vs analítico.",
                                "Profundidade da interpretação: ligação com comportamento físico.",
                                "Criatividade em otimizações: pelo menos 2 sugestões viáveis.",
                                "Clareza do relatório: estrutura lógica, sem erros matemáticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas/elastodynamica onde dispersão afeta precisão.",
                                "Computação: Implementação eficiente de FFT para análise modal em simulações PDE.",
                                "Engenharia: Otimização de esquemas em CFD para escoamentos compressíveis.",
                                "Estatística: Análise de erro numérico como variância em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, análise de erro de fase garante que ondas de alta frequência não se disperem artificialmente, preservando resolução de reservatórios subterrâneos em modelos de 3D de longa duração."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Avaliar ordem de dispersão",
                            "description": "Determinar a ordem de precisão dispersiva de um esquema (ex.: segunda ordem para Lax-Wendroff) expandindo o símbolo em série de Taylor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise de Von Neumann e Símbolo de Amplificação",
                                  "subSteps": [
                                    "Relembrar a análise de Von Neumann para esquemas de diferenças finitas em equações hiperbólicas.",
                                    "Definir o símbolo de amplificação g(θ) para uma onda com número de onda kΔx = θ.",
                                    "Escrever a equação de advecção linear u_t + a u_x = 0 como referência.",
                                    "Identificar componentes de dispersão no símbolo: |g(θ)| ≈ 1 (não dissipativo) e arg(g(θ)) ≈ -a θ (não dispersivo).",
                                    "Preparar anotações sobre expansão em Taylor para símbolos."
                                  ],
                                  "verification": "Conseguir derivar manualmente o símbolo g(θ) para um esquema simples como forward Euler.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), caderno, calculadora.",
                                  "tips": "Use notação complexa e^{iθ} para facilitar expansões.",
                                  "learningObjective": "Compreender a base teórica para análise de dispersão.",
                                  "commonMistakes": "Confundir dispersão com dissipação; lembrar que dispersão afeta fase, dissipação afeta amplitude."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar ou Obter o Símbolo de Amplificação do Esquema Específico",
                                  "subSteps": [
                                    "Selecionar o esquema alvo, ex: Lax-Wendroff para u_t + u_x = 0.",
                                    "Escrever a stencil do esquema: u_j^{n+1} = u_j^n - (λ/2)(u_{j+1}^n - u_{j-1}^n) + (λ^2/2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde λ = Δt/Δx.",
                                    "Assumir solução de Fourier u_j^n = g^n e^{i k j Δx} e isolar g(θ) com θ = k Δx.",
                                    "Simplificar g(θ) = 1 - i λ θ sin(θ)/θ + ... (verificar forma exata).",
                                    "Verificar consistência de primeira ordem: g(0) = 1."
                                  ],
                                  "verification": "Calcular g(θ) para θ pequeno e confirmar g(0)=1, g'(0)=-i a.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software simbólico como SymPy ou Mathematica.",
                                  "tips": "Mantenha λ=1 para simplicidade em advecção unitária.",
                                  "learningObjective": "Derivar precisamente o símbolo para esquemas hiperbólicos.",
                                  "commonMistakes": "Erros em substituição de diferenças finitas; sempre teste com θ=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir o Símbolo em Série de Taylor",
                                  "subSteps": [
                                    "Expandir g(θ) em Taylor ao redor de θ=0 até ordem suficiente (ex: 5 ou 6).",
                                    "Usar expansões: sin(θ) = θ - θ^3/6 + O(θ^5), cos(θ) = 1 - θ^2/2 + O(θ^4).",
                                    "Separar parte real (dissipação) e imaginária (dispersão): g(θ) = 1 + i c1 θ + c2 θ^2 + i c3 θ^3 + ...",
                                    "Identificar termos pares/impares: ímpares para dispersão em esquemas centrados.",
                                    "Calcular coeficientes explicitamente para Lax-Wendroff."
                                  ],
                                  "verification": "Coeficientes até θ^3 devem coincidir com fórmula conhecida: para Lax-Wendroff, dispersão O(θ^3).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora gráfica ou Python/SymPy para expansões automáticas.",
                                  "tips": "Use identidade e^{iφ} para visualizar fase; expanda log(g) se necessário.",
                                  "learningObjective": "Dominar expansão de Taylor para análise assintótica.",
                                  "commonMistakes": "Parar cedo na expansão; sempre vá até ordem onde dispersão aparece."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Determinar a Ordem de Dispersão",
                                  "subSteps": [
                                    "Comparar fase numérica φ_num = arg(g(θ)) com exata φ_ex = -a θ.",
                                    "Dispersão δ = φ_num - φ_ex ≈ c_{p+1} θ^{p+1} + ..., onde p é ordem.",
                                    "Para Lax-Wendroff, confirmar c1 = -a, c3 ≠0, assim ordem 2 (primeiro termo dispersivo θ^3).",
                                    "Generalizar: ordem de dispersão é menor m impar >1 com c_m ≠0.",
                                    "Documentar conclusão: 'Esquema de ordem de dispersão 2'."
                                  ],
                                  "verification": "Plotar φ_num vs θ e superpor φ_ex; ver convergência como O(θ^3).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (Matplotlib, Excel), esquema de referência.",
                                  "tips": "Ordem de dispersão é (menor expoente ímpar -1)/2 para precisão.",
                                  "learningObjective": "Interpretar coeficientes para classificar ordem.",
                                  "commonMistakes": "Confundir ordem total (truncamento) com ordem dispersiva específica."
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Wendroff na equação u_t + u_x = 0 com λ=1: g(θ) = 1 - i sin(θ) - (1-cos(θ)) sin(θ)/(2i sin(θ)/θ) wait, exata: g(θ)=1 - i sin(θ) + (1-cos(θ))/2. Expansão: g(θ) ≈ 1 - iθ - (i/6)θ^3 + O(θ^4). Fase δ ≈ -(1/6)θ^3, ordem 2.",
                              "finalVerifications": [
                                "Expansão de Taylor correta até ordem necessária.",
                                "Identificação precisa dos termos dispersivos (ímpar).",
                                "Cálculo correto da ordem (ex: 2 para Lax-Wendroff).",
                                "Verificação numérica via plot de fase.",
                                "Conclusão consistente com literatura.",
                                "Tratamento de casos λ≠1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do símbolo (sem erros algébricos).",
                                "Expansão de Taylor completa e correta (coeficientes exatos).",
                                "Interpretação adequada de dispersão vs dissipação.",
                                "Generalização para outros esquemas.",
                                "Clareza na documentação e plots.",
                                "Tratamento de erros comuns demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de dispersão em equações de onda.",
                                "Computação: Implementação de esquemas em CFD (ex: Python NumPy).",
                                "Engenharia: Simulações numéricas em aerodinâmica.",
                                "Estatística: Análise de erro em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de fluidodinâmica computacional (CFD), avaliar ordem de dispersão garante precisão em propagação de ondas sem distorções de fase, essencial para modelagem de choques em aviação e previsão meteorológica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Esquemas de Baixa Dispersão",
                        "description": "Estudo de métodos numéricos com propriedades de baixa dispersão para equações hiperbólicas, incluindo esquemas explícitos e implícitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Comparar dispersão em esquemas explícitos",
                            "description": "Comparar o comportamento dispersivo do esquema upwind, Lax-Friedrichs e Lax-Wendroff para a equação de transporte, usando análise de Von Neumann.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de transporte e princípios da análise de Von Neumann",
                                  "subSteps": [
                                    "Escrever a equação de transporte linear: ∂u/∂t + a ∂u/∂x = 0, com a > 0.",
                                    "Explicar a análise de Von Neumann: assumir solução u_j^n = ξ^n e^{i k j Δx}, onde ξ é o símbolo de amplificação.",
                                    "Derivar a condição de estabilidade CFL: |ξ| ≤ 1 para todos os modos de Fourier k.",
                                    "Definir dispersão numérica como o erro na velocidade de fase: ω_num(k) vs ω_exata(k) = a k.",
                                    "Preparar notação comum: λ = a Δt / Δx (número de Courant)."
                                  ],
                                  "verification": "Capacidade de escrever corretamente a equação e derivar ξ genérico para um esquema simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), caderno de anotações, calculadora simbólica (Mathematica/SymPy).",
                                  "tips": "Comece com o modo de baixa frequência (k Δx << 1) para aproximações.",
                                  "learningObjective": "Compreender o framework teórico para análise de dispersão.",
                                  "commonMistakes": "Confundir dispersão (fase) com dissipação (amplitude); esquecer normalização de ξ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar dispersão no esquema upwind explícito",
                                  "subSteps": [
                                    "Escrever o esquema upwind: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n).",
                                    "Calcular o símbolo de amplificação: ξ_up = 1 - λ (1 - e^{-i θ}), onde θ = k Δx.",
                                    "Computar |ξ_up| e arg(ξ_up)/Δt para velocidade de fase numérica.",
                                    "Expandir em série de Taylor para θ pequeno: identificar termo dispersivo O(θ^3).",
                                    "Plotar dispersão: ω_num / ω_exata vs θ."
                                  ],
                                  "verification": "Derivação correta de ξ_up e plot qualitativo mostrando dispersão alta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB com numpy/matplotlib), papel para derivações.",
                                  "tips": "Use identidades trigonométricas: 1 - e^{-iθ} = 1 - cosθ + i sinθ.",
                                  "learningObjective": "Dominar cálculo de dispersão para esquema de primeira ordem.",
                                  "commonMistakes": "Erro no sinal do upwind (para a>0, usa j-1); ignorar fatorização de ξ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dispersão nos esquemas Lax-Friedrichs e Lax-Wendroff",
                                  "subSteps": [
                                    "Para Lax-Friedrichs: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (λ/2)(u_{j+1}^n - u_{j-1}^n). Calcular ξ_LF.",
                                    "Para Lax-Wendroff: incluir termo de segunda derivada. ξ_LW = 1 - i λ sinθ - (λ^2/2)(1 - cosθ).",
                                    "Comparar expansões: LF tem dissipação forte (baixa dispersão), LW tem dispersão O(θ^3) mas menos dissipação.",
                                    "Calcular coeficientes dispersivos: d_3 = Im(ξ)/θ - a, para cada esquema.",
                                    "Plotar curvas de dispersão para os três esquemas no mesmo gráfico."
                                  ],
                                  "verification": "Símbolos de amplificação corretos e identificação de LF como mais dissipativo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python pronto para ξ (NumPy), referências de fórmulas padrão.",
                                  "tips": "Verifique |ξ| ≤1: upwind e LW condicionalmente estáveis, LF mais restritivo.",
                                  "learningObjective": "Comparar símbolos e identificar trade-offs dissipação-dispersão.",
                                  "commonMistakes": "Confundir LF (central com média) e LW (Taylor expansão); erro em cosθ termos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e interpretar o comportamento dispersivo",
                                  "subSteps": [
                                    "Tabelar coeficientes dispersivos d_3 para cada esquema em função de λ.",
                                    "Analisar para λ=1: upwind sem oscilação, LW oscila atrás da onda.",
                                    "Discutir regimes: baixa frequência (todos similares), alta frequência (upwind damping, LW dispersive).",
                                    "Simular numericamente uma onda gaussiana com cada esquema e observar dispersão.",
                                    "Concluir: upwind alta dispersão/baixa oscilação, LF baixa dispersão/alta dissipação, LW balanceado."
                                  ],
                                  "verification": "Tabela comparativa e simulação mostrando diferenças visuais.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código de simulação 1D (Python com matplotlib para animações), dados de benchmark.",
                                  "tips": "Use Δx pequeno para alta resolução; fixe λ=0.5 para estabilidade.",
                                  "learningObjective": "Sintetizar comparações qualitativas e quantitativas.",
                                  "commonMistakes": "Atribuir dispersão errada (LW é menos dispersivo que upwind em baixa freq.)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar insights e aplicações",
                                  "subSteps": [
                                    "Resumir: upwind para choques, LF para suavização, LW para ondas sem dissipação excessiva.",
                                    "Discutir melhorias: esquemas de baixa dispersão como DRP ou WENO.",
                                    "Relacionar com análise de fase: erro de grupo vs fase.",
                                    "Preparar relatório com gráficos e tabela.",
                                    "Testar com variação de λ e θ."
                                  ],
                                  "verification": "Relatório com conclusões claras e gráficos rotulados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de LaTeX ou Markdown para relatório.",
                                  "tips": "Foco em implicações práticas para escolha de esquema.",
                                  "learningObjective": "Aplicar análise para seleção de métodos numéricos.",
                                  "commonMistakes": "Generalizar demais sem considerar λ específico."
                                }
                              ],
                              "practicalExample": "Simule a equação de transporte ∂u/∂t + ∂u/∂x = 0 com u(x,0) = exp(-(x-0.5)^2 / 0.01) em [0,2]x[0,2], usando Δx=0.01, λ=0.8. Plote soluções em t=0.5,1,1.5 para upwind, LF e LW: observe trailing oscillations em LW, smearing em LF, e leading error em upwind.",
                              "finalVerifications": [
                                "Derivação correta dos três símbolos de amplificação ξ.",
                                "Plots de dispersão ω_num(k) vs kΔx para todos esquemas.",
                                "Tabela comparativa de coeficientes dispersivos d_3(λ).",
                                "Simulação numérica reproduzindo comportamento teórico.",
                                "Explicação verbal das diferenças em 2 minutos.",
                                "Identificação correta do esquema de menor dispersão para ondas lisas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (90% correto).",
                                "Qualidade dos gráficos (eixos rotulados, escalas adequadas).",
                                "Profundidade da comparação (quantitativa e qualitativa).",
                                "Correta interpretação de trade-offs dissipação-dispersão.",
                                "Relevância da simulação prática ao teoria.",
                                "Clareza no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação em meios.",
                                "Computação: Implementação eficiente de solvers PDE em Python/Fortran.",
                                "Engenharia: Simulações CFD para fluxo compressível.",
                                "Estatística: Análise de erros em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de tráfego (equação LWR), upwind previne oscilações não-físicas em jams; em acústica computacional, LW minimiza dispersão de pulsos sonoros de alta frequência em modelagem de alto-falantes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Implementar esquema de baixa dispersão",
                            "description": "Codificar e testar um esquema de terceira ordem (ex.: TVD com limitador) em Python ou MATLAB, avaliando redução de dispersão em problemas hiperbólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar e derivar o esquema TVD de terceira ordem",
                                  "subSteps": [
                                    "Revise os conceitos de dispersão numérica em esquemas para equações hiperbólicas, focando em esquemas de Lax-Wendroff e suas limitações.",
                                    "Derive o esquema TVD (Total Variation Diminishing) de terceira ordem com limitador de fluxo (ex: van Leer ou minmod).",
                                    "Implemente as funções de limitador em pseudocódigo.",
                                    "Calcule manualmente os coeficientes de dispersão para o esquema derivado.",
                                    "Compare com esquemas de segunda ordem em termos de fase e dispersão."
                                  ],
                                  "verification": "Derivação correta confirmada comparando com referências bibliográficas (ex: LeVeque's book); pseudocódigo funcional.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livro 'Finite Difference Methods for ODEs and PDEs' de LeVeque; caderno para derivações; calculadora simbólica (SymPy online).",
                                  "tips": "Use diagramas de stencil para visualizar os pontos usados no esquema.",
                                  "learningObjective": "Compreender a matemática por trás de esquemas de baixa dispersão e sua estabilidade.",
                                  "commonMistakes": "Confundir o limitador de inclinação com limitador de fluxo; ignorar condições CFL."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o esquema em Python",
                                  "subSteps": [
                                    "Configure o ambiente com NumPy, Matplotlib e SciPy.",
                                    "Escreva a função principal para o esquema TVD de terceira ordem, incluindo reconstrução de alta ordem e limitadores.",
                                    "Implemente condições de contorno periódicas ou outflow.",
                                    "Adicione parâmetros para CFL, número de células e passos de tempo.",
                                    "Teste unitário com solução exata analítica para equação de advecção linear."
                                  ],
                                  "verification": "Código executa sem erros; solução converge para a exata com refinamento de malha (erro L2 < 1e-3).",
                                  "estimatedTime": "5 horas",
                                  "materials": "Python 3+, Jupyter Notebook; bibliotecas NumPy, Matplotlib; template de código de análise numérica.",
                                  "tips": "Vectorize operações com NumPy para eficiência; use loops apenas para tempo.",
                                  "learningObjective": "Codificar esquemas numéricos avançados de forma eficiente e modular.",
                                  "commonMistakes": "Índices off-by-one em arrays; esquecimento de atualização de ghost cells."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e simular problema teste hiperbólico",
                                  "subSteps": [
                                    "Defina problema inicial com pacote gaussiano ou onda sinusoidal para evidenciar dispersão.",
                                    "Implemente esquema de referência de alta dispersão (ex: Lax-Wendroff de segunda ordem).",
                                    "Execute simulações para ambos esquemas com mesmo grid e CFL=0.5.",
                                    "Gere plots de solução em tempos fixos e animação da evolução.",
                                    "Calcule métricas de erro de dispersão (ex: desvio de fase via FFT)."
                                  ],
                                  "verification": "Plots mostram oscilações reduzidas no TVD vs Lax-Wendroff; métricas quantitativas confirmam baixa dispersão.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Jupyter Notebook do step anterior; dados de solução exata (funções analíticas).",
                                  "tips": "Use logscale para erros; fixe semente para reprodutibilidade.",
                                  "learningObjective": "Aplicar o esquema a problemas reais e visualizar efeitos numéricos.",
                                  "commonMistakes": "CFL muito alto causando instabilidade; plots sem normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e avaliar redução de dispersão",
                                  "subSteps": [
                                    "Compute espectros de dispersão via análise de von Neumann.",
                                    "Compare erros de fase e amplitude entre esquemas em tabela.",
                                    "Teste convergência de ordem com refinamento h.",
                                    "Discuta limitações (ex: custo computacional) e melhorias.",
                                    "Gere relatório com gráficos, tabelas e conclusões."
                                  ],
                                  "verification": "Análise mostra ordem 3 no TVD e redução >50% em dispersão vs referência.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Resultados das simulações; ferramentas de plot (Matplotlib/Seaborn); LaTeX para relatório.",
                                  "tips": "Automatize análise com funções; foque em métricas objetivas.",
                                  "learningObjective": "Avaliar criticamente performance numérica e interpretar resultados.",
                                  "commonMistakes": "Confundir dispersão com difusão; análises sem baselines."
                                }
                              ],
                              "practicalExample": "Simule a advecção de um pulso gaussiano u_t + u_x = 0 em [0,2π] com 200 células. No esquema Lax-Wendroff, observe oscilações atrás da frente; no TVD de terceira ordem com minmod, o pulso propaga com dispersão mínima, mantendo forma por t=2π.",
                              "finalVerifications": [
                                "Código roda sem crashes para grids até 1000 células e T=10.",
                                "Gráficos mostram redução visível de oscilações (amplitude <5% do sinal).",
                                "Erro de fase <0.01 radianos por unidade de tempo.",
                                "Ordem de convergência ≈3 confirmada em tabela.",
                                "Relatório resume análise com pelo menos 3 figuras e 2 tabelas.",
                                "Testes com diferentes limitadores (minmod, van Leer) comparados."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da derivação e implementação (30%).",
                                "Eficiência computacional e modularidade do código (20%).",
                                "Qualidade visual e quantitativa da análise de dispersão (25%).",
                                "Profundidade da discussão de limitações e conexões teóricas (15%).",
                                "Relatório claro e bem estruturado (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e eletromagnéticas.",
                                "Computação: Otimização numérica e programação científica (NumPy/SciPy).",
                                "Engenharia: Simulações CFD em aerodinâmica.",
                                "Estatística: Análise de erros e convergência via regressão."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), esquemas de baixa dispersão como TVD são essenciais para propagar choques e frentes sem oscilações artificiais, usados em previsão meteorológica, design aeroespacial e simulações sísmicas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Noções de Dissipação Numérica",
                    "description": "Fenômeno de dissipação em métodos numéricos para equações hiperbólicas e controle.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Definição e Fenômeno de Dissipação Numérica",
                        "description": "Introdução ao conceito de dissipação numérica como o amortecimento artificial de modos de alta frequência em soluções aproximadas de equações hiperbólicas via métodos de diferenças finitas, analisado pelo módulo do fator de amplificação no método de von Neumann.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Definir dissipação numérica",
                            "description": "Explicar o fenômeno de dissipação numérica como a redução seletiva da amplitude de componentes de onda de alta frequência em esquemas numéricos para equações hiperbólicas, diferenciando-o de dispersão e relacionando-o à estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de equações hiperbólicas e esquemas numéricos",
                                  "subSteps": [
                                    "Estude a forma geral de equações hiperbólicas, como a equação de advecção u_t + a u_x = 0.",
                                    "Revise métodos de diferenças finitas explícitos, como Lax-Wendroff e upwind.",
                                    "Analise a análise de von Neumann para esquemas lineares, introduzindo o símbolo de amplificação g(θ).",
                                    "Identifique componentes de Fourier de alta e baixa frequência na solução numérica."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos revisados e liste 3 exemplos de esquemas numéricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque 'Finite Difference Methods'), notebook com Python/Octave"
                                  ],
                                  "tips": [
                                    "Comece com equações 1D simples para visualização; use gráficos de dispersão de fase."
                                  ],
                                  "learningObjective": "Compreender a base teórica necessária para dissipação numérica.",
                                  "commonMistakes": [
                                    "Confundir hiperbólicas com parabólicas; ignorar análise de estabilidade CFL."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e explicar o fenômeno de dissipação numérica",
                                  "subSteps": [
                                    "Defina dissipação numérica como a redução seletiva da amplitude de modos de alta frequência (θ próximo de π).",
                                    "Explique que |g(θ)| < 1 para altas frequências, enquanto |g(0)| ≈ 1 para baixas.",
                                    "Descreva o mecanismo físico: similar a viscosidade artificial que amortece oscilações.",
                                    "Ilustre com o símbolo de amplificação de esquemas como Lax-Friedrichs.",
                                    "Calcule |g(θ)| para um esquema dissipativo simples."
                                  ],
                                  "verification": "Escreva a definição formal e compute |g(π/2)| para esquema upwind.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folhas de cálculo, software MATLAB/Python para plotar |g(θ)|"
                                  ],
                                  "tips": [
                                    "Plote |g(θ)| vs θ para visualizar seletividade; compare com solução exata."
                                  ],
                                  "learningObjective": "Dominar a definição precisa e o mecanismo de dissipação numérica.",
                                  "commonMistakes": [
                                    "Achar que dissipação afeta todas as frequências igualmente; confundir com truncagem de erro."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar dissipação numérica de dispersão numérica",
                                  "subSteps": [
                                    "Defina dispersão: variação da velocidade de fase numérica ω(θ)/θ ≠ velocidade exata.",
                                    "Compare: dissipação afeta amplitude (|g| <1), dispersão afeta fase (arg(g)/θ ≠ k a).",
                                    "Analise esquemas: Lax-Wendroff é dispersivo, Lax-Friedrichs é dissipativo.",
                                    "Crie uma tabela comparativa de efeitos em soluções com descontinuidades.",
                                    "Simule numericamente uma onda para observar ambos os fenômenos."
                                  ],
                                  "verification": "Crie uma tabela de diferenças e simule um pulso para demonstrar.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python com NumPy/Matplotlib para simulação 1D"
                                  ],
                                  "tips": [
                                    "Use pacotes como PyFV para esquemas prontos; grave animações das simulações."
                                  ],
                                  "learningObjective": "Distinguir claramente dissipação de dispersão em termos matemáticos e visuais.",
                                  "commonMistakes": [
                                    "Confundir os efeitos em gibbs oscillations (dispersão causa oscilações)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar dissipação numérica à estabilidade de esquemas",
                                  "subSteps": [
                                    "Explique que dissipação ajuda estabilidade ao amortecer modos instáveis (|g| >1).",
                                    "Discuta condição CFL e como dissipação artificial previne blow-up.",
                                    "Analise esquemas TVD que combinam dissipação adaptativa.",
                                    "Estude exemplos onde falta de dissipação causa instabilidade.",
                                    "Conclua com trade-offs: dissipação excessiva borra solução."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como dissipação contribui para |g(θ)| ≤1 ∀θ.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos sobre esquemas hiperbólicos (ex: Toro 'Riemann Solvers'), simulador numérico"
                                  ],
                                  "tips": [
                                    "Teste estabilidade variando ν = Δt/Δx além de CFL para observar."
                                  ],
                                  "learningObjective": "Entender o papel da dissipação na estabilidade numérica.",
                                  "commonMistakes": [
                                    "Achar dissipação sempre ruim; ignorar que estabilidade requer max|g|≤1."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x =0 com esquema Lax-Friedrichs em Python: inicialize u(x,0) como pulso gaussiano, aplique 1000 passos com ν=0.9, plote u em t=1 e observe atenuação seletiva de altas frequências (perfil suavizado sem oscilações, diferentemente do esquema Lax-Wendroff que oscila).",
                              "finalVerifications": [
                                "Defina dissipação numérica em suas próprias palavras com fórmula de |g(θ)|.",
                                "Diferencie dissipação de dispersão com um exemplo gráfico.",
                                "Explique como dissipação afeta estabilidade em esquemas hiperbólicos.",
                                "Simule um esquema dissipativo e descreva os efeitos observados.",
                                "Identifique se um dado esquema (ex: upwind) é dissipativo analisando g(θ)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: menciona redução seletiva de altas frequências (peso 25%).",
                                "Correta diferenciação de dispersão: amplitude vs fase (peso 20%).",
                                "Relação com estabilidade: ligação com |g(θ)| ≤1 (peso 20%).",
                                "Uso de exemplos/simulações: demonstração prática (peso 20%).",
                                "Clareza e completude: sem erros conceituais (peso 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com amortecimento em ondas mecânicas e viscosidade.",
                                "Computação: Implementação de algoritmos numéricos em CFD (ex: OpenFOAM).",
                                "Engenharia: Modelagem de fluxos compressíveis em aerodinâmica.",
                                "Estatística: Análise de erros em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações numéricas de ondas sísmicas ou acústicas (ex: previsão de terremotos ou sonar), a dissipação numérica previne amplificação artificial de ruídos de alta frequência, garantindo soluções estáveis e realistas em softwares como SPECFEM ou COMSOL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Analisar fator de amplificação via von Neumann",
                            "description": "Calcular e interpretar o fator de amplificação g(θ) para um esquema numérico, identificando dissipação quando |g(θ)| < 1 para θ ≠ 0, usando a equação de advecção linear como exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de advecção linear e esquemas numéricos explícitos",
                                  "subSteps": [
                                    "Estude a equação de advecção linear: ∂u/∂t + a ∂u/∂x = 0, com a > 0.",
                                    "Descreva a discretização espacial em malha uniforme Δx e temporal Δt, definindo λ = a Δt / Δx (número de Courant).",
                                    "Apresente um esquema numérico exemplo, como o upwind: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n).",
                                    "Explique os conceitos de consistência e estabilidade via condição CFL: |λ| ≤ 1.",
                                    "Discuta o papel da análise de von Neumann para estabilidade local."
                                  ],
                                  "verification": "Escreva a equação e o esquema upwind corretamente, incluindo a condição CFL.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta; livro de análise numérica (ex: LeVeque 'Finite Difference Methods'); calculadora.",
                                  "tips": "Comece sempre pela forma contínua antes de discretizar para manter clareza.",
                                  "learningObjective": "Compreender o problema modelo e a necessidade de análise de estabilidade.",
                                  "commonMistakes": "Confundir advecção com difusão; ignorar o sinal de 'a' na condição CFL."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise de von Neumann e assumir solução de Fourier",
                                  "subSteps": [
                                    "Explique que a análise assume solução modal: u_j^n = g^n e^{i θ j}, onde θ = κ Δx (fase por célula).",
                                    "Substitua a forma assumida na equação discreta para obter uma relação algébrica em g.",
                                    "Ignore condições de contorno, focando em estabilidade local para modos de alta frequência (θ ≠ 0).",
                                    "Defina o fator de amplificação g(θ) como a raiz da equação característica.",
                                    "Note que para estabilidade, requer-se |g(θ)| ≤ 1 + O(Δt) para todo θ."
                                  ],
                                  "verification": "Derive a forma geral u_j^n = g^n e^{i θ j} e substitua em um esquema simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta; software simbólico como SymPy ou Mathematica para simplificação.",
                                  "tips": "Use notação complexa exponencial para evitar senos/cossenos iniciais.",
                                  "learningObjective": "Dominar a hipótese de solução periódica e sua substituição no esquema.",
                                  "commonMistakes": "Esquecer o expoente n em g^n; confundir θ com κ (onda number)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e calcular o fator de amplificação g(θ) para o esquema exemplo",
                                  "subSteps": [
                                    "Para o esquema upwind: substitua e resolva g = 1 - λ (1 - e^{-iθ}).",
                                    "Simplifique g(θ) = 1 - λ + λ e^{-iθ}.",
                                    "Calcule |g(θ)|^2 = |1 - λ + λ cosθ - i λ sinθ|^2 explicitamente.",
                                    "Obtenha |g(θ)|^2 = (1 - λ + λ cosθ)^2 + (λ sinθ)^2.",
                                    "Verifique para θ=0: |g(0)|=1 (preservação de energia para modo zero)."
                                  ],
                                  "verification": "Compute g(θ) e |g(θ)|^2 para λ=0.5 e θ=π/2, confirmando cálculo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para plotar |g(θ)| vs θ; quadro branco.",
                                  "tips": "Expanda e^{-iθ} = cosθ - i sinθ imediatamente após substituição.",
                                  "learningObjective": "Calcular analiticamente g(θ) para esquemas lineares simples.",
                                  "commonMistakes": "Erro no sinal do termo de diferença finita; não quadrar corretamente para módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar |g(θ)| e identificar dissipação numérica",
                                  "subSteps": [
                                    "Analise |g(θ)| < 1 para θ ≠ 0 como indício de dissipação artificial.",
                                    "Para upwind com λ<1, mostre que |g(θ)| ≤ 1, com igualdade só em θ=0.",
                                    "Plote |g(θ)| de 0 a π: observe decaimento em altas frequências (dissipação).",
                                    "Compare com esquemas não dissipativos (ex: Lax-Wendroff, que pode amplificar).",
                                    "Conclua que dissipação numérica controla oscilações, mas introduz erro de fase."
                                  ],
                                  "verification": "Desenhe gráfico de |g(θ)| e identifique intervalos onde |g|<1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com Matplotlib/NumPy para plotagem; exemplos de esquemas de livros.",
                                  "tips": "Foque em θ próximo a π (modos 2Δx) onde dissipação é máxima.",
                                  "learningObjective": "Interpretar g(θ) quanto a dissipação e estabilidade.",
                                  "commonMistakes": "Confundir dissipação (|g|<1) com instabilidade (|g|>1); ignorar dependência em λ."
                                }
                              ],
                              "practicalExample": "Para o esquema upwind na equação u_t + u_x = 0 com λ = 0.5: g(θ) = 1 - 0.5(1 - e^{-iθ}). Calcule |g(π)| ≈ 0.5, mostrando forte dissipação no modo de grade mais alta, o que amortece oscilações Gibbs em descontinuidades.",
                              "finalVerifications": [
                                "Calcula corretamente g(θ) para esquema upwind e outro exemplo.",
                                "Identifica |g(θ)| < 1 para θ ≠ 0 como dissipação.",
                                "Plota |g(θ)| e descreve seu comportamento qualitativo.",
                                "Explica o papel da dissipação em controlar instabilidades numéricas.",
                                "Aplica análise a um esquema diferente, como Lax-Friedrichs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de g(θ) (fórmula exata).",
                                "Correta interpretação de |g(θ)| ≤ 1 como estabilidade com dissipação.",
                                "Qualidade do gráfico |g(θ)| vs θ, com rótulos e análise.",
                                "Identificação de erros comuns em cálculos complexos.",
                                "Capacidade de generalizar para outros esquemas hiperbólicos.",
                                "Clareza na explicação de dissipação vs dispersão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em meios dispersivos/dissipativos.",
                                "Computação: Implementação de solvers numéricos em CFD (ex: Python Finite Differences).",
                                "Engenharia: Simulações de fluxo em aerodinâmica.",
                                "Estatística: Análise espectral de séries temporais numéricas."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, a análise von Neumann garante que esquemas dissipativos controlem ruído numérico em previsões de frentes frias, evitando amplificação espúria de pequenas perturbações em modelos de advecção de umidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Diferenciar dissipação de outros erros numéricos",
                            "description": "Comparar dissipação numérica com dispersão (fase errada) e oscilações, ilustrando com gráficos de |g(θ)| e arg(g(θ)) em esquemas clássicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de erros numéricos em esquemas para equações hiperbólicas",
                                  "subSteps": [
                                    "Defina dissipação numérica: redução artificial da amplitude das ondas devido a |g(θ)| < 1 para alguns θ.",
                                    "Defina dispersão: erro de fase onde arg(g(θ)) ≠ -σ θ Δt, causando velocidades de fase erradas.",
                                    "Defina oscilações: instabilidade onde |g(θ)| > 1 para alguns θ, levando a crescimento exponencial.",
                                    "Liste esquemas clássicos como Lax-Friedrichs (dissipativo), Lax-Wendroff (dispersivo) e upwind (dissipativo).",
                                    "Explique o papel do símbolo de amplificação g(θ) na análise de von Neumann."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças conceituais entre dissipação, dispersão e oscilações, citando pelo menos um exemplo de esquema para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica II (capítulo de equações hiperbólicas), notas de aula sobre estabilidade von Neumann.",
                                  "tips": "Use tabelas para comparar definições lado a lado para fixar diferenças.",
                                  "learningObjective": "Compreender as definições precisas e distinções qualitativas entre os três tipos de erros.",
                                  "commonMistakes": "Confundir dissipação com amortecimento físico real; ignorar que oscilações podem ocorrer em altas frequências."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o módulo |g(θ)| para diferenciar dissipação de oscilações",
                                  "subSteps": [
                                    "Derive ou revise a expressão de |g(θ)| para esquemas como Lax-Friedrichs (|g| ≤ 1, dissipativo) e esquemas explicitos instáveis (|g| > 1).",
                                    "Plote |g(θ)| vs θ para um esquema dissipativo (ex: |g(θ)| < 1 para θ ≠ 0) e um oscilatório (|g(θ)| > 1 em algumas regiões).",
                                    "Identifique regiões onde |g(θ)| < 1 (dissipação de altas frequências) vs |g(θ)| > 1 (amplificação e oscilações).",
                                    "Compare curvas: dissipação suaviza solução, oscilações geram ruído crescente.",
                                    "Calcule |g(θ)| para θ = π (alta frequência) em pelo menos dois esquemas."
                                  ],
                                  "verification": "Gere e interprete gráficos de |g(θ)| para dois esquemas, destacando regiões de dissipação vs instabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB com numpy/matplotlib), exemplos de g(θ) de notas de aula.",
                                  "tips": "Normalice θ entre 0 e π; foque em comportamentos assintóticos para θ pequeno e grande.",
                                  "learningObjective": "Dominar como |g(θ)| diagnostica dissipação (damping) versus oscilações (instabilidade).",
                                  "commonMistakes": "Interpretar |g(0)| ≠ 1 como dissipação (deve ser =1 para modo zero); plotar sem normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a fase arg(g(θ)) para diferenciar dissipação de dispersão",
                                  "subSteps": [
                                    "Revise arg(g(θ)) ideal: arg(g(θ)) = -σ θ Δt para exatidão de fase.",
                                    "Para esquemas dissipativos (ex: upwind), note que arg(g(θ)) ≈ correto mas com damping em amplitude.",
                                    "Para Lax-Wendroff (dispersivo), observe desvio em arg(g(θ)) para θ médio/alto, causando oscilações de fase.",
                                    "Plote arg(g(θ)) vs θ e compare com linha ideal -σ θ Δt.",
                                    "Quantifique dispersão via |arg(g(θ)) + σ θ Δt| e dissipação via 1 - |g(θ)|."
                                  ],
                                  "verification": "Plote arg(g(θ)) para esquemas dissipativo e dispersivo, anotando desvios de fase vs amplitude.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo software de plotagem, fórmulas de g(θ) para Lax-Wendroff e upwind.",
                                  "tips": "Use zoom em θ de 0 a π/2 para ver desvios sutis; sobreponha curvas ideais.",
                                  "learningObjective": "Distinguir erros de fase (dispersão) dos de amplitude (dissipação) via arg(g(θ)).",
                                  "commonMistakes": "Confundir pequeno desvio de fase com dissipação; ignorar que dissipação afeta amplitude, não fase diretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar diferenças com exemplos gráficos e exercícios comparativos",
                                  "subSteps": [
                                    "Crie painel de gráficos: |g(θ)| e arg(g(θ)) para um dissipativo, dispersivo e instável.",
                                    "Simule numericamente uma equação de onda 1D com cada esquema e observe soluções (suavização vs ripples vs blow-up).",
                                    "Responda: 'Por que Lax-Friedrichs dissipa mas não dispersa muito?'",
                                    "Classifique três novos esquemas baseados em seus g(θ).",
                                    "Discuta trade-offs: dissipação excessiva vs dispersão leading a Gibbs-like oscillations."
                                  ],
                                  "verification": "Produza relatório com gráficos comparativos e simulações, explicando diferenciações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python/MATLAB para simulação de onda (ex: advection equation), papel para esboços.",
                                  "tips": "Comece com Δx=Δt=1, σ=1; use condições iniciais gaussianas para visualizar erros.",
                                  "learningObjective": "Integrar análises gráficas para diferenciar todos os erros em contextos práticos.",
                                  "commonMistakes": "Atribuir oscilações a dispersão (são instabilidade); não simular para validar teoria."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com pulso inicial gaussiano usando Lax-Friedrichs (dissipação: pulso suaviza), Lax-Wendroff (dispersão: ripples atrás da frente) e um esquema instável (blow-up). Plote soluções em t=1 e superponha |g(θ)|/arg(g(θ)) para correlacionar erros observados.",
                              "finalVerifications": [
                                "Explique verbalmente as diferenças usando gráficos de |g(θ)| e arg(g(θ)).",
                                "Classifique corretamente três esquemas como dissipativos, dispersivos ou instáveis.",
                                "Simule e identifique o tipo de erro dominante em uma solução numérica fornecida.",
                                "Calcule |g(θ)| e arg(g(θ)) para um esquema dado e interprete.",
                                "Discuta por que dissipação é preferível a oscilações em modelagem de ondas.",
                                "Diferencie dissipação numérica de viscosidade artificial em um parágrafo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção: dissipação afeta |g|<1, dispersão arg(g)≠ideal, oscilações |g|>1 (90% acerto).",
                                "Qualidade dos gráficos: eixos corretos, legendas, interpretações claras.",
                                "Análise quantitativa: cálculos de g(θ) exatos para pelo menos dois θ.",
                                "Compreensão conceitual: explicações sem confusão entre amplitude e fase.",
                                "Aplicação prática: simulações executadas corretamente com conclusões alinhadas.",
                                "Síntese: identificação de trade-offs em esquemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações de onda acústica ou hidrodinâmica.",
                                "Computação: Implementação de solvers numéricos e visualização com Python/MATLAB.",
                                "Engenharia: Controle de erros em simulações CFD para previsão de tempo.",
                                "Estatística: Analogia com variância (dispersão) vs bias em métodos numéricos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas de frentes de onda (ex: previsão de tempestades), esquemas dissipativos como upwind previnem oscilações espúrias em modelos de equações hiperbólicas, garantindo previsões estáveis sem amplificação numérica, enquanto minimizando dispersão para precisão de fase em trajetórias de ondas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Dissipação em Métodos Explícitos",
                        "description": "Estudo da dissipação presente em métodos explícitos como Lax-Friedrichs e upwind, destacando sua natureza fortemente dissipativa para garantir estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Analisar dissipação no esquema Lax-Friedrichs",
                            "description": "Derivar o fator de amplificação g(θ) = cos(θ) - i λ sin(θ) para o esquema Lax-Friedrichs na equação de advecção, verificando |g(θ)| ≤ 1 e dissipação para θ ≠ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de advecção e o esquema Lax-Friedrichs",
                                  "subSteps": [
                                    "Escreva a equação de advecção linear: ∂u/∂t + a ∂u/∂x = 0.",
                                    "Apresente a discretização do esquema Lax-Friedrichs: u_j^{n+1} = (u_{j-1}^n + u_{j+1}^n)/2 - (λ a / 2) (u_{j+1}^n - u_{j-1}^n), onde λ = Δt/Δx.",
                                    "Identifique os termos de média (artificial viscosity) e advecção.",
                                    "Discuta a condição CFL: |λ a| ≤ 1 para estabilidade.",
                                    "Anote os símbolos: θ = k Δx (fase numérica)."
                                  ],
                                  "verification": "Esquema escrito corretamente e condição CFL identificada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (capítulo de EDP hiperbólicas)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize a stencil do esquema: depende de j-1, j+1, introduzindo dissipação artificial.",
                                  "learningObjective": "Compreender a forma explícita do esquema Lax-Friedrichs e sua motivação.",
                                  "commonMistakes": [
                                    "Confundir λ com a velocidade a",
                                    "Esquecer o fator 1/2 nos termos",
                                    "Ignorar a condição de estabilidade CFL"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar análise de von Neumann para obter o fator de amplificação",
                                  "subSteps": [
                                    "Assuma solução de Fourier: u_j^n = g^n e^{i k j Δx} = g^n e^{i θ j}, com θ = k Δx.",
                                    "Substitua na equação do esquema: g e^{i θ j} = [e^{i θ (j-1)} + e^{i θ (j+1)}]/2 g - (λ a / 2) [e^{i θ (j+1)} - e^{i θ (j-1)}] g.",
                                    "Divida ambos os lados por g e^{i θ j}: g = [e^{-i θ} + e^{i θ}]/2 - (λ a / 2) (e^{i θ} - e^{-i θ}).",
                                    "Simplifique usando identidades trigonométricas: cos(θ) e i sin(θ).",
                                    "Assuma a > 0 e λ > 0 para simplicidade, obtendo g(θ) = cos(θ) - i λ sin(θ)."
                                  ],
                                  "verification": "Derivação passo a passo resulta em g(θ) = cos(θ) - i λ sin(θ).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Papel quadriculado para fases complexas"
                                  ],
                                  "tips": "Fatore g^n e e^{i θ j} imediatamente para simplificar.",
                                  "learningObjective": "Dominar a análise de von Neumann para esquemas explícitos.",
                                  "commonMistakes": [
                                    "Erros em exponenciais: confundir e^{i θ (j+1)}",
                                    "Esquecer o sinal em -i para o termo imaginário",
                                    "Não assumir plano de Fourier corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o módulo |g(θ)| e verificar estabilidade",
                                  "subSteps": [
                                    "Compute |g(θ)|^2 = Re(g)^2 + Im(g)^2 = cos²(θ) + λ² sin²(θ).",
                                    "Reescreva: |g(θ)|^2 = 1 - sin²(θ) (1 - λ²).",
                                    "Mostre que |g(θ)|^2 ≤ 1 para |λ| ≤ 1, pois (1 - λ²) ≥ 0 e sin² ≤ 1.",
                                    "Verifique igualdade: |g| = 1 quando sin(θ) = 0 ou λ = 1.",
                                    "Plote |g(θ)| para λ = 0.5 em θ ∈ [0, π] para visualização."
                                  ],
                                  "verification": "|g(θ)|^2 ≤ 1 demonstrado analiticamente e gráfico qualitativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como Python/Matplotlib ou papel para esboço"
                                  ],
                                  "tips": "Use identidade cos² + sin² = 1 para reescrever elegantemente.",
                                  "learningObjective": "Analisar estabilidade via fator de amplificação.",
                                  "commonMistakes": [
                                    "Erro no cálculo de |g|^2: esquecer λ² no termo imaginário",
                                    "Concluir instabilidade sem verificar |λ| ≤ 1",
                                    "Ignorar θ = 0 mod 2π"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar propriedades de dissipação numérica",
                                  "subSteps": [
                                    "Defina dissipação: |g(θ)| < 1 para θ ≠ 0 (mod 2π), amortecendo modos de alta frequência.",
                                    "Mostre que para λ < 1, |g(θ)| < 1 quando sin(θ) ≠ 0.",
                                    "Compare com esquema de Lax-Wendroff (menos dissipativo).",
                                    "Discuta o papel da viscosidade artificial: termo (u_{j-1} + u_{j+1})/2 introduz Δx²/2Δt dissipação.",
                                    "Conclua que Lax-Friedrichs é dissipativo, útil para choques mas smear soluções suaves."
                                  ],
                                  "verification": "Demonstração de |g(θ)| < 1 para θ ≠ 0 e discussão qualitativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência: LeVeque 'Finite Difference Methods for ODE/PDE'",
                                    "Exemplos numéricos opcionais em código"
                                  ],
                                  "tips": "Pense em θ ≈ π (onda de Nyquist): máxima dissipação.",
                                  "learningObjective": "Interpretar dissipação numérica em termos de fator de amplificação.",
                                  "commonMistakes": [
                                    "Confundir dissipação com dispersão",
                                    "Achar não-dissipativo porque |g|≤1",
                                    "Não distinguir de esquemas não-dissipativos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x = 0 com λ=0.5, derive g(θ) para θ=π/2: g = 0 - i 0.5 = -0.5i, |g|=0.5 <1. Implemente o esquema em Python para uma senoide inicial e observe o amortecimento de oscilações de alta frequência após 10 passos.",
                              "finalVerifications": [
                                "g(θ) = cos(θ) - i λ sin(θ) derivado corretamente.",
                                "|g(θ)|^2 = cos²(θ) + λ² sin²(θ) ≤ 1 para |λ|≤1.",
                                "Dissipação confirmada: |g(θ)| <1 para θ≠0 e λ<1.",
                                "Condição CFL |λ a|≤1 explicitada.",
                                "Interpretação física da dissipação artificial fornecida.",
                                "Gráfico qualitativo de |g(θ)| esboçado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação simbólica (100% dos passos corretos).",
                                "Correção analítica de |g(θ)|≤1 com prova completa.",
                                "Análise qualitativa de dissipação com exemplos numéricos.",
                                "Uso correto de análise de von Neumann sem erros algébricos.",
                                "Clareza na explicação de viscosidade artificial.",
                                "Identificação de limitações do esquema (excesso de dissipação)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação de sinais.",
                                "Programação: Implementação em Python/NumPy para simulações CFD.",
                                "Engenharia: Análise de estabilidade em métodos de elementos finitos.",
                                "Estatística: Análise de erro numérico e truncamento."
                              ],
                              "realWorldApplication": "Em simulações de fluxo de tráfego ou ondas sísmicas, o esquema Lax-Friedrichs estabiliza soluções com descontinuidades, dissipando ruído numérico em previsões meteorológicas ou hidrodinâmica computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Comparar dissipação em esquemas upwind e Lax-Wendroff",
                            "description": "Calcular |g(θ)| para esquemas upwind (forte dissipação) e Lax-Wendroff (baixa dissipação, mas dispersiva), plotando curvas de dissipação numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar o símbolo de amplificação para o esquema upwind",
                                  "subSteps": [
                                    "Recordar a equação de advecção linear: ∂u/∂t + a ∂u/∂x = 0.",
                                    "Escrever a discretização upwind explícita: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), onde λ = a Δt / Δx.",
                                    "Assumir solução modal u_j^n = g^n e^{i θ j}, com θ = k Δx.",
                                    "Derivar g(θ) = 1 - λ (1 - e^{-iθ}).",
                                    "Simplificar para |g(θ)| = |1 - λ (1 - cosθ + i sinθ)|."
                                  ],
                                  "verification": "Verificar que |g(θ)| ≤ 1 para estabilidade (condição CFL λ ≤ 1) e plotar manualmente para θ=0 e θ=π.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque), papel e caneta, calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Use identidade trigonométrica para magnitude: |g|^2 = [1 - λ(1-cosθ)]^2 + [λ sinθ]^2.",
                                  "learningObjective": "Compreender a origem da dissipação no esquema upwind via análise de von Neumann.",
                                  "commonMistakes": [
                                    "Esquecer o fator e^{-iθ} na derivação",
                                    "Ignorar a condição de estabilidade CFL",
                                    "Confundir upwind com central difference"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o símbolo de amplificação para o esquema Lax-Wendroff",
                                  "subSteps": [
                                    "Escrever a discretização Lax-Wendroff: u_j^{n+1} = u_j^n - (λ/2)(u_{j+1}^n - u_{j-1}^n) + (λ^2/2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n).",
                                    "Assumir novamente u_j^n = g^n e^{i θ j}.",
                                    "Derivar g(θ) = 1 - i λ sinθ - (λ^2/2)(1 - cosθ).",
                                    "Calcular |g(θ)| = sqrt{ [1 - (λ^2/2)(1-cosθ)]^2 + (λ sinθ)^2 }.",
                                    "Verificar neutralidade em θ=0: |g(0)|=1."
                                  ],
                                  "verification": "Confirmar que |g(θ)| ≈ 1 para θ pequeno, indicando baixa dissipação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmos do Step 1, software para simplificação simbólica (Python com SymPy)"
                                  ],
                                  "tips": "Expanda em série de Taylor para θ pequeno para ver ordem de dissipação (4ª ordem vs 2ª no upwind).",
                                  "learningObjective": "Dominar a derivação do símbolo para esquemas de segunda ordem.",
                                  "commonMistakes": [
                                    "Erro no termo de correção (λ^2/2)",
                                    "Confundir com Lax-Friedrichs",
                                    "Não normalizar |g| corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculos numéricos e plotar curvas de |g(θ)|",
                                  "subSteps": [
                                    "Implementar funções em Python/MATLAB para g_upwind(θ, λ) e g_laxwendroff(θ, λ).",
                                    "Gerar θ de 0 a π com 100 pontos, fixar λ=0.5 (CFL estável).",
                                    "Calcular |g(θ)| para ambos esquemas.",
                                    "Plotar |g_upwind| e |g_laxwendroff| no mesmo gráfico, com legenda e rótulos.",
                                    "Adicionar linha |g|=1 como referência."
                                  ],
                                  "verification": "Gráfico mostra upwind abaixo de 1 (dissipativo) e Lax-Wendroff oscilando em torno de 1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python (NumPy, Matplotlib) ou MATLAB, Jupyter Notebook"
                                  ],
                                  "tips": "Use np.linspace(0, np.pi, 100) para θ; plote em escala log para pequenas diferenças.",
                                  "learningObjective": "Visualizar numericamente a dissipação via curvas de amplificação.",
                                  "commonMistakes": [
                                    "λ >1 causando instabilidade",
                                    "Erro em fase θ (usar kΔx)",
                                    "Eixos invertidos no plot"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e comparar as curvas de dissipação",
                                  "subSteps": [
                                    "Observar que upwind tem |g| <1 para θ>0, forte dissipação em altas frequências.",
                                    "Notar Lax-Wendroff com |g|≈1 mas pode >1 em algumas regiões (dispersão).",
                                    "Calcular dissipação relativa: 1 - |g(θ)| para ambos.",
                                    "Discutir trade-off: upwind estável mas 'smearing', LW preciso mas ondulações.",
                                    "Testar com λ diferente (ex: 0.9) para ver sensibilidade."
                                  ],
                                  "verification": "Relatório escrito com pelo menos 3 observações quantitativas (ex: max(1-|g|) ).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos gerados, editor de texto para relatório"
                                  ],
                                  "tips": "Foquem em θ=π (onda de Nyquist): upwind mata, LW preserva melhor.",
                                  "learningObjective": "Interpretar curvas para escolher esquema em aplicações reais.",
                                  "commonMistakes": [
                                    "Ignorar dispersão no LW",
                                    "Generalizar sem variar λ",
                                    "Confundir dissipação com dispersão"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a advecção de um pulso estreito (u(x,0)=exp(-(x-0.5)^2 / 0.01)) com 100 células, Δt=0.5 Δx /a. Após 10 períodos, upwind suaviza o pulso (dissipação), enquanto Lax-Wendroff mantém amplitude mas introduz oscilações atrás da frente.",
                              "finalVerifications": [
                                "Símbolos g(θ) derivados corretamente para ambos esquemas.",
                                "Curvas |g(θ)| plotadas para λ=0.5, mostrando upwind abaixo de 1 e LW próximo de 1.",
                                "Análise escrita identifica forte dissipação upwind vs baixa no LW.",
                                "Código Python/MATLAB reproduzível e comentado.",
                                "Testes com λ=0.9 confirmam estabilidade e diferenças.",
                                "Relatório discute implicações para simulações de ondas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações matemáticas (20%)",
                                "Qualidade dos plots e cálculos numéricos (25%)",
                                "Profundidade da comparação qualitativa/quantitativa (25%)",
                                "Clareza do código e documentação (15%)",
                                "Identificação de trade-offs e erros comuns (10%)",
                                "Conexão com aplicações práticas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas ou MHD onde dissipação artificial afeta precisão.",
                                "Computação: Implementação eficiente em Python/NumPy para análise von Neumann.",
                                "Engenharia: Escolha de esquemas em CFD para fluxos hiperbólicos sem amortecimento excessivo.",
                                "Estatística: Análise de erros numéricos como variância em frequências altas."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica (modelos como WRF), Lax-Wendroff reduz dissipação para preservar frentes de tempestade, enquanto upwind é usado em regiões com choques para estabilidade; em CFD aeroespacial, balanceia dissipação para precisão em escoamentos supersônicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Avaliar impacto da condição CFL na dissipação",
                            "description": "Examinar como a restrição CFL afeta o módulo |g(θ)| em métodos explícitos, relacionando-a ao controle de dissipação para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Condição CFL e Dissipação Numérica",
                                  "subSteps": [
                                    "Defina a condição CFL para esquemas explícitos em equações hiperbólicas: CFL = λ Δt / Δx ≤ 1, onde λ é a velocidade característica.",
                                    "Explique dissipação numérica como o amortecimento seletivo de modos de alta frequência via |g(θ)| < 1 para θ próximo a π.",
                                    "Identifique |g(θ)| como o símbolo de amplificação de Fourier para o esquema explícito (ex: Lax-Friedrichs ou upwind).",
                                    "Discuta como CFL controla o espectro de |g(θ)| para estabilidade.",
                                    "Calcule |g(θ)| para θ=0 (modo de baixa frequência, |g(0)|=1) e θ=π (Nyquist)."
                                  ],
                                  "verification": "Resuma em um parágrafo como CFL influencia |g(θ)|; confirme com fórmulas simbólicas corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre análise de Von Neumann; calculadora simbólica (SymPy ou papel).",
                                  "tips": "Comece com o caso 1D advection simples para clareza.",
                                  "learningObjective": "Compreender a relação matemática entre CFL, |g(θ)| e dissipação.",
                                  "commonMistakes": "Confundir CFL com condições de precisão em vez de estabilidade; ignorar dependência em θ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Expressão Analítica de |g(θ)| sob Variação de CFL",
                                  "subSteps": [
                                    "Escolha um esquema explícito (ex: upwind: u^{n+1}_j = u^n_j - ν (u^n_j - u^n_{j-1}), ν=CFL).",
                                    "Aplique análise de Von Neumann: assuma u^n_j = g^n e^{i k j Δx}, derive g(θ) com θ = k Δx.",
                                    "Compute |g(θ)| = |1 - ν (1 - e^{-iθ})| para upwind.",
                                    "Plote ou tabule |g(θ)| para ν=0.5, 0.9, 1.0 em θ ∈ [0,π].",
                                    "Observe como ν menor aumenta dissipação (queda mais acentuada de |g(θ)| em altas frequências)."
                                  ],
                                  "verification": "Gere gráfico ou tabela mostrando |g(θ)| <1 para ν≤1; verifique estabilidade (|g|≤1 ∀θ).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Matplotlib/Python ou MATLAB); fórmula do esquema.",
                                  "tips": "Use aproximação para pequenas θ: dissipação ~ ν θ^2 /2.",
                                  "learningObjective": "Derivar e visualizar impacto quantitativo de CFL em |g(θ)|.",
                                  "commonMistakes": "Erro na fatoração de g(θ); plotar apenas θ=0 ignorando o espectro completo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto Qualitativo e Quantitativo na Dissipação",
                                  "subSteps": [
                                    "Compare curvas |g(θ)| para ν baixo (alta dissipação, ondas lisas) vs. ν alto (baixa dissipação, oscilações).",
                                    "Calcule taxa de dissipação: d = 1 - |g(θ)|^2 para θ fixo (ex: θ=π/2).",
                                    "Avalie trade-off: CFL pequeno = mais estável mas dissipativo; CFL próximo a 1 = eficiente mas risco de instabilidade.",
                                    "Simule numericamente uma onda gaussiana com diferentes CFL e meça atenuação.",
                                    "Conclua como CFL controla dissipação para estabilidade sem excesso."
                                  ],
                                  "verification": "Relatório com tabelas/gráficos mostrando variação de d com ν; explique trade-offs.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python/MATLAB para simulação 1D advection; solver explícito.",
                                  "tips": "Use malha fina (Nx=256) para precisão espectral.",
                                  "learningObjective": "Quantificar e interpretar efeitos de CFL na dissipação numérica.",
                                  "commonMistakes": "Atribuir oscilações apenas a dispersão, ignorando dissipação; CFL>1 sem notar instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Relação CFL-Dissipação-Estabilidade",
                                  "subSteps": [
                                    "Resuma: CFL reduz domínio de |g(θ)|>1, mas aumenta dissipação em baixas frequências se muito restrito.",
                                    "Discuta otimização: escolha ν ótimo para mínimo dissipação sujeita a estabilidade.",
                                    "Compare com esquemas implícitos (sem CFL rígida).",
                                    "Aplique a exemplo multidimensional (2D advection).",
                                    "Documente conclusões em fluxograma ou equação resumida."
                                  ],
                                  "verification": "Crie fluxograma ligando CFL → |g(θ)| → dissipação → estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel/diagrama digital; exemplos de códigos anteriores.",
                                  "tips": "Pense em termos de 'janela de estabilidade' no plano (ν,θ).",
                                  "learningObjective": "Integrar análise para avaliação crítica do impacto CFL.",
                                  "commonMistakes": "Generalizar de 1D para ND sem adaptação; subestimar custos computacionais de CFL pequeno."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção 1D ∂u/∂t + ∂u/∂x =0 com upwind explícito, condição inicial gaussiana u(x,0)=exp(-(x-0.5)^2/0.01). Rode com Δx=1/100, Δt tal que ν=0.3, 0.8, 1.0 por 100 passos. Plote soluções e perfis |g(θ)|; observe que ν=0.3 dissipa a onda excessivamente (perda de amplitude 40%), ν=1.0 preserva mas oscila, ν=0.8 equilibra.",
                              "finalVerifications": [
                                "Confirme |g(θ)| ≤1 para todo θ ∈[0,π] sob CFL≤1.",
                                "Meça dissipação numérica via atenuação de modo θ=π/2: d>0.1 para ν<0.5.",
                                "Verifique estabilidade em simulação: ausência de crescimento exponencial.",
                                "Compare amplitude final da onda com solução exata: erro <5% para ν ótimo.",
                                "Analise espectro Fourier: decaimento correto de altas frequências.",
                                "Documente trade-off CFL vs. dissipação em tabela quantitativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de |g(θ)| (fórmulas corretas, 30%).",
                                "Qualidade de visualizações e simulações (clareza, precisão, 25%).",
                                "Análise qualitativa/quantitativa de impacto CFL (profundidade, 20%).",
                                "Identificação correta de trade-offs estabilidade-dissipação (15%).",
                                "Síntese e conclusões coerentes (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas/propagação em meios, análise de amortecimento.",
                                "Computação: Otimização de solvers numéricos em CFD (ex: OpenFOAM).",
                                "Engenharia: Simulações em aerodinâmica onde CFL limita timestep.",
                                "Estatística: Análise espectral e controle de ruído numérico."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD) para previsão de tempo ou design aeronáutico, ajustar CFL otimiza estabilidade sem dissipar estruturas de fluxo críticas, reduzindo tempo computacional em supercomputadores enquanto mantém precisão em previsões de furacões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Dissipação em Métodos Implícitos e Controle",
                        "description": "Análise da dissipação em métodos implícitos, que geralmente apresentam baixa dissipação, e estratégias para controlar o fenômeno em simulações hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Analisar dissipação em esquemas implícitos",
                            "description": "Derivar o fator de amplificação para o esquema implícito backward Euler na equação de advecção, mostrando dissipação mínima |g(θ)| ≈ 1 para baixas frequências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a equação de advecção e formular o esquema implícito backward Euler",
                                  "subSteps": [
                                    "Escreva a equação de advecção unidimensional: ∂u/∂t + a ∂u/∂x = 0, com a > 0.",
                                    "Defina a malha espacial Δx e temporal Δt, com ν = a Δt / Δx (número de Courant).",
                                    "Formule o esquema upwind implícito backward Euler: (u_j^{n+1} - u_j^n)/Δt + a (u_j^{n+1} - u_{j-1}^{n+1})/Δx = 0.",
                                    "Reorganize em forma matricial implícita: u^{n+1} = (I + ν A)^{-1} u^n, onde A é a matriz de diferenças finitas upwind.",
                                    "Verifique a consistência e estabilidade incondicional do esquema."
                                  ],
                                  "verification": "Confirme que o esquema reduz à equação original quando Δt, Δx → 0 e que é L-estável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, livro de análise numérica (ex: LeVeque 'Finite Difference Methods').",
                                  "tips": "Use notação consistente para índices j (espaço) e n (tempo).",
                                  "learningObjective": "Entender a discretização implícita para equações hiperbólicas.",
                                  "commonMistakes": "Confundir upwind com central difference; esquecer o termo implícito em j-1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a análise von Neumann para obter o fator de amplificação",
                                  "subSteps": [
                                    "Assuma solução de Fourier: u_j^n = g^n exp(i k j Δx), com θ = k Δx (fase por célula).",
                                    "Substitua na equação do esquema: g exp(i k j Δx) - exp(i k j Δx) + ν [g exp(i k j Δx) - g exp(i k (j-1) Δx)] = 0.",
                                    "Simplifique dividindo por exp(i k j Δx): g - 1 + ν g (1 - exp(-i θ)) = 0.",
                                    "Resolva para g(θ): g(θ) = 1 / [1 + ν (1 - exp(-i θ))].",
                                    "Expanda 1 - exp(-i θ) = 1 - cos θ + i sin θ."
                                  ],
                                  "verification": "Verifique que para θ=0, g(0)=1 (preservação de constantes).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora simbólica (ex: Mathematica ou papel), tabela de identidades trigonométricas.",
                                  "tips": "Normalize dividindo pela amplitude comum para isolar g.",
                                  "learningObjective": "Dominar a análise de amplificação espectral via von Neumann.",
                                  "commonMistakes": "Erro no sinal do expoente (-iθ para upwind); esquecer fatorização de g."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o módulo |g(θ)| e analisar sua magnitude",
                                  "subSteps": [
                                    "Escreva o denominador: D(θ) = 1 + ν (1 - cos θ + i sin θ).",
                                    "Calcule |D(θ)|^2 = [1 + ν (1 - cos θ)]^2 + [ν sin θ]^2.",
                                    "Então |g(θ)|^2 = 1 / |D(θ)|^2.",
                                    "Analise para θ → 0: expanda cos θ ≈ 1 - θ^2/2, sin θ ≈ θ, obtendo |g| ≈ 1 / sqrt(1 + O(θ^2)) ≈ 1 - O(θ^2).",
                                    "Compare com esquemas explícitos, notando dissipação mínima em baixas frequências."
                                  ],
                                  "verification": "Plote |g(θ)| para ν=1, θ de 0 a π; confirme |g| próximo de 1 para θ pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (ex: Python/Matplotlib ou Excel), derivadas de Taylor.",
                                  "tips": "Use expansão em série de Taylor para θ pequeno para aproximação analítica.",
                                  "learningObjective": "Quantificar dissipação numérica via |g(θ)| <1.",
                                  "commonMistakes": "Erro no cálculo de |D|^2 (quadrado do imaginário); confundir com fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e discutir propriedades dissipativas",
                                  "subSteps": [
                                    "Mostre que para todas θ, |g(θ)| ≤ 1, com igualdade em θ=0 (não dissipativo para modo zero).",
                                    "Demonstre que d|g|/dθ |_{θ=0} =0 e segunda derivada negativa (dissipação mínima inicial).",
                                    "Compare com forward Euler: |g_FE| pode >1 (instável), enquanto backward é sempre estável.",
                                    "Discuta controle de dissipação: ajuste ν para minimizar em baixas frequências.",
                                    "Conclua sobre adequação para simulações de longo prazo."
                                  ],
                                  "verification": "Escreva desigualdade |g(θ)| ≤1 e expansão |g(θ)| ≈ 1 - (ν θ^2 / 2)^2 / 2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de |g(θ)| para diferentes ν, referências bibliográficas.",
                                  "tips": "Foque em baixas frequências (θ < π/10) para aplicações práticas.",
                                  "learningObjective": "Interpretar análise espectral em termos de estabilidade e precisão.",
                                  "commonMistakes": "Ignorar que dissipação é desejável para altas frequências (filtros numéricos)."
                                }
                              ],
                              "practicalExample": "Em uma simulação de transporte de poluente em rio (a=1 m/s, Δx=10m, Δt=100s, ν=10), derive g(θ) para θ=0.1 (onda longa), calcule |g|≈0.998, e compare com solução exata após 100 passos: erro <0.1% vs. 5% em forward Euler.",
                              "finalVerifications": [
                                "g(θ) = 1 / [1 + ν (1 - exp(-i θ))] derivado corretamente.",
                                "|g(θ)|^2 = 1 / {[1 + ν(1-cosθ)]^2 + (ν sinθ)^2} simplificado.",
                                "Lim_{θ→0} |g(θ)| =1 e expansão de segunda ordem ≈1 - c θ^4.",
                                "Gráfico de |g(θ)| mostra platô em 1 para θ baixo.",
                                "Comparação qualitativa com esquemas explícitos feita.",
                                "Estabilidade incondicional confirmada (|g|≤1 ∀ν,θ)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica de g(θ) (sem erros de sinal ou fator).",
                                "Correção no cálculo de |g(θ)| e expansão assintótica para baixas frequências.",
                                "Interpretação física: dissipação mínima em modos de baixa frequência.",
                                "Uso adequado de análise von Neumann (assunção periódica, normalização).",
                                "Profundidade na discussão de propriedades (estabilidade, consistência).",
                                "Clareza em gráficos ou exemplos numéricos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em meios dispersivos e amortecimento.",
                                "Computação: Implementação de solvers implícitos em CFD (ex: PETSc).",
                                "Engenharia: Modelagem de fluxos em reservatórios petrolíferos.",
                                "Estatística: Análise espectral de séries temporais numéricas."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou hidrodinâmica computacional (CFD), o backward Euler controla dissipação em ondas de baixa frequência (ex: marés oceânicas), evitando amortecimento artificial em previsões de longo prazo, como em modelos do IPCC ou software ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Implementar medidas de controle de dissipação",
                            "description": "Descrever técnicas como adição artificial de viscosidade ou esquemas híbridos (TVD, ENO) para equilibrar dissipação e evitar oscilações em soluções hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de dissipação numérica e oscilações em equações hiperbólicas",
                                  "subSteps": [
                                    "Revise a definição de dissipação numérica em métodos de diferenças finitas para equações hiperbólicas lineares e não lineares.",
                                    "Analise exemplos de soluções com oscilações de Gibbs próximas a descontinuidades.",
                                    "Estude a relação entre dissipação, dispersão e estabilidade via análise de von Neumann.",
                                    "Identifique quando a dissipação excessiva ou insuficiente afeta a precisão da solução.",
                                    "Compare dissipação em métodos explícitos vs. implícitos."
                                  ],
                                  "verification": "Resuma em um diagrama os efeitos de dissipação alta/baixa e oscilações, com exemplos gráficos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica de LeVeque', capítulos sobre hiperbólicas",
                                    "Notebooks Jupyter com exemplos de Lax-Friedrichs e Lax-Wendroff",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use animações de soluções numéricas para visualizar oscilações dinamicamente.",
                                  "learningObjective": "Explicar qualitativamente como a dissipação controla oscilações sem excessiva suavização.",
                                  "commonMistakes": [
                                    "Confundir dissipação com dispersão",
                                    "Ignorar o papel do CFL number",
                                    "Não considerar não-linearidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar adição artificial de viscosidade",
                                  "subSteps": [
                                    "Derive a forma modificada da equação hiperbólica com termo de viscosidade artificial ε Δu.",
                                    "Escolha ε adaptativa baseada no gradiente da solução (e.g., minmod sensor).",
                                    "Incorpore o termo em um esquema base como Lax-Friedrichs via diferenças finitas.",
                                    "Codifique em Python usando NumPy para uma equação de advecção linear 1D.",
                                    "Teste com condição inicial de onda quadrada e plote soluções para diferentes ε."
                                  ],
                                  "verification": "Gere plots mostrando redução de oscilações com ε ótimo, sem oversmoothing.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, Matplotlib, SciPy",
                                    "Notebook Jupyter pronto com template de solver hiperbólico",
                                    "Artigo de Harten sobre artificial viscosity"
                                  ],
                                  "tips": "Comece com ε constante para depuração, depois torne adaptativo.",
                                  "learningObjective": "Implementar e calibrar viscosidade artificial para estabilizar soluções.",
                                  "commonMistakes": [
                                    "Escolha de ε muito grande causando difusão excessiva",
                                    "Erro na discretização do laplaciano",
                                    "Não normalizar ε pelo h^2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar esquemas TVD (Total Variation Diminishing)",
                                  "subSteps": [
                                    "Estude os limitadores de fluxo (minmod, superbee, van Leer) e sua propriedade TVD.",
                                    "Implemente o esquema MUSCL com reconstrução de inclinação limitada.",
                                    "Codifique um solver TVD para a equação de Burgers não-linear 1D.",
                                    "Compare TVD com upwind de primeira ordem em testes de precisão e monotonicidade.",
                                    "Analise numericamente a dissipação via entropia residual."
                                  ],
                                  "verification": "Verifique que a variação total não aumenta (TV(s^{n+1}) ≤ TV(s^n)) em simulações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código base de Godunov em Python",
                                    "Livro 'Riemann Solvers and Numerical Methods for Fluid Dynamics' de Toro",
                                    "Ferramentas de plotting como Matplotlib"
                                  ],
                                  "tips": "Teste limitadores em casos shock e rarefaction separadamente.",
                                  "learningObjective": "Construir um esquema TVD que previna oscilações mantendo precisão.",
                                  "commonMistakes": [
                                    "Implementação errada do minmod (sinais inconsistentes)",
                                    "Esquecimento do predictor-corrector em MUSCL",
                                    "CFL inadequado para TVD"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar esquemas ENO e híbridos para controle avançado",
                                  "subSteps": [
                                    "Revise ENO: seleção de stencil suave baseado em divided differences.",
                                    "Implemente ENO de segunda ordem para advecção linear.",
                                    "Crie um esquema híbrido: TVD em regiões lisas + ENO em descontinuidades.",
                                    "Teste em equação de Burgers com múltiplos shocks e compare com métodos anteriores.",
                                    "Otimize parâmetros para equilíbrio dissipação/precisão via análise de erro L1/L2."
                                  ],
                                  "verification": "Plots comparativos mostrando menos dissipação que TVD puro em regiões lisas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código ENO de exemplo em GitHub ou LeVeque's MATLAB codes traduzidos para Python",
                                    "Paper original de Harten, Engquist, Osher, Shu sobre ENO",
                                    "Jupyter para benchmarks"
                                  ],
                                  "tips": "Use stencil selection function modular para facilitar depuração.",
                                  "learningObjective": "Integrar ENO em híbridos para dissipação mínima adaptativa.",
                                  "commonMistakes": [
                                    "Cálculo incorreto de smoothness indicators",
                                    "Overhead computacional sem vetorização NumPy",
                                    "Não tratar stencil assimétrico corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um solver para a equação de Burgers 1D: u_t + (0.5 u^2)_x = 0, com u(x,0) = -sin(πx) para x em [0,1]. Use controle híbrido TVD-ENO para propagar o shock sem oscilações, comparando com Lax-Wendroff puro que oscila.",
                              "finalVerifications": [
                                "Código executa sem erros para CFL ≤ 1 e grids até 1000 pontos.",
                                "Soluções mostram ausência de oscilações pós-shock (verificar monotonicidade).",
                                "Dissipação medida por ||u_num - u_exata||_L1 < 0.01 para casos suaves.",
                                "Tempo de execução < 10s para 1000 passos temporais.",
                                "Análise de estabilidade: solução bounded para t até T=1.",
                                "Comparação gráfica com soluções de referência (e.g., método exato via characteristics)."
                              ],
                              "assessmentCriteria": [
                                "Precisão em regiões lisas (erro L2 < 1% do domínio).",
                                "Monotonicidade preservada em descontinuidades.",
                                "Eficiência computacional (ordem de complexidade O(N)).",
                                "Adaptabilidade do controle (dissipação variável por região).",
                                "Robustez a diferentes CFL (0.1 a 0.9).",
                                "Clareza do código com comentários e modularidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas de choque em dinâmica de fluidos compressíveis.",
                                "Computação: Algoritmos adaptativos e otimização numérica.",
                                "Engenharia: Simulações CFD em aerodinâmica.",
                                "Estatística: Análise de erros e validação de modelos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de fluxo supersônico em aeronáutica (NASA), controle de dissipação via TVD/ENO previne oscilações artificiais em predições de pressão de onda de choque, melhorando designs de asas e nozzles."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Avaliar dissipação em problemas reais",
                            "description": "Aplicar análise de von Neumann a uma equação hiperbólica não linear simples, quantificando dissipação via simulações numéricas e comparação com soluções exatas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e formular o problema hiperbólico não linear",
                                  "subSteps": [
                                    "Escolha uma equação hiperbólica não linear simples, como a equação de Burgers unidimensional: ∂u/∂t + u ∂u/∂x = 0 (sem viscosidade para foco em dissipação numérica).",
                                    "Defina condições iniciais e de contorno adequadas, como uma onda de choque inicial u(x,0) = 1 para x<0 e 0 para x>0.",
                                    "Discretize o domínio espacial e temporal: defina Δx, Δt e número de pontos N.",
                                    "Obtenha ou derive a solução exata para comparação, usando método de características para Burgers invíscida.",
                                    "Documente os parâmetros escolhidos e justifique a relevância para estudo de dissipação."
                                  ],
                                  "verification": "Verifique se a equação está corretamente formulada e se a solução exata inicial coincide com a condição inicial implementada.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Papel e caneta para derivações; Python com NumPy para protótipo inicial de condições iniciais.",
                                  "tips": "Comece com parâmetros CFL = Δt / Δx ≈ 1 para estabilidade explícita, mas prepare para implícito.",
                                  "learningObjective": "Compreender a estrutura de uma equação hiperbólica não linear e preparar benchmark exato.",
                                  "commonMistakes": "Escolher equação muito complexa sem solução exata conhecida; ignorar periodicidade nas condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar esquema numérico implícito",
                                  "subSteps": [
                                    "Formule um esquema implícito, como Crank-Nicolson ou Backward Euler para o termo não linear linearizado: u^{n+1}_j - u^n_j + (Δt/(2Δx)) (u^{n+1}_j (u^{n+1}_{j+1} - u^{n+1}_{j-1}) + u^n_j (u^n_{j+1} - u^n_{j-1})) = 0.",
                                    "Linearize o termo não linear usando extrapolação ou iteração de ponto fixo.",
                                    "Implemente em código: crie malha, loop temporal com solver linear (ex: scipy.linalg.solve).",
                                    "Teste convergência com grids refinados (Δx halved).",
                                    "Visualize solução numérica inicial vs. exata em t pequeno."
                                  ],
                                  "verification": "Execute simulação curta e confirme que resíduos do esquema implícito são <1e-6.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python com NumPy, SciPy (para solve), Matplotlib para plots.",
                                  "tips": "Use iterações de Picard (3-5) por timestep para convergência não linear rápida.",
                                  "learningObjective": "Dominar implementação de métodos implícitos para estabilidade incondicional em hiperbólicas.",
                                  "commonMistakes": "Não linearizar corretamente, levando a não convergência; timestep muito grande sem iterações suficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar análise de von Neumann para fator de amplificação",
                                  "subSteps": [
                                    "Linearize a equação ao redor de um estado base constante u_0.",
                                    "Assuma solução perturbada u = u_0 + ε exp(i k j Δx) g^n, derive |g(k Δx)| o fator de amplificação.",
                                    "Para esquema implícito, resolva equação quadrática para g: |g| ≤1 para estabilidade.",
                                    "Plote |g| vs. número de onda θ = k Δx para diferentes u_0, identifique dissipação numérica (decaimento seletivo de altos modos).",
                                    "Compare com esquema explícito para destacar controle de dissipação."
                                  ],
                                  "verification": "Confirme |g| ≤1 para todos θ ∈ [0,π]; plote deve mostrar decaimento suave para θ alto.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy e Matplotlib para plots de dispersão/dissipação.",
                                  "tips": "Use sympy para derivação simbólica de g se possível, senão numéricamente.",
                                  "learningObjective": "Quantificar dissipação via análise de von Neumann em contexto não linear linearizado.",
                                  "commonMistakes": "Esquecer linearização ou fator i na Fourier; plotar apenas Re(g) em vez de |g|."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações, comparar e quantificar dissipação",
                                  "subSteps": [
                                    "Rode simulações longas (T=10 unidades tempo) com diferentes Δx, Δt.",
                                    "Calcule erros L2: ∫ (u_num - u_exata)^2 dx^{1/2} em vários tempos.",
                                    "Meça taxa de dissipação: compare energia total E(t) = ∫ u^2 dx decay rate num vs exato.",
                                    "Analise espectro Fourier: decaimento de modos altos como métrica de dissipação numérica.",
                                    "Gere relatório com gráficos de u(x,t), erros e espectros."
                                  ],
                                  "verification": "Erros L2 <5% em T final; decay de energia coincide qualitativamente com análise von Neumann.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python com SciPy (fft), Matplotlib; solução exata via método exato.",
                                  "tips": "Use domínio periódico para FFT limpa; normalize erros por ||u_exata||.",
                                  "learningObjective": "Avaliar dissipação quantitativamente via simulações e benchmarks.",
                                  "commonMistakes": "Não sincronizar grids para comparação exata; ignorar aliasing em não lineares."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e propor controle de dissipação",
                                  "subSteps": [
                                    "Compare dissipação observada com predita por von Neumann para vários u_0.",
                                    "Quantifique: defina métrica δ = 1 - min(|g| para θ alto), avalie impacto em precisão.",
                                    "Teste modificações: adicione filtro espectral ou upwinding para controlar dissipação.",
                                    "Discuta limitações (não linearidade forte quebra von Neumann).",
                                    "Conclua com recomendações para problemas reais."
                                  ],
                                  "verification": "Relatório escrito com tabelas/plots mostrando correlação análise-simulação >80%.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Jupyter Notebook para relatório integrado.",
                                  "tips": "Foquem em um parâmetro chave por vez (ex: Δx effect).",
                                  "learningObjective": "Integrar teoria e prática para avaliação crítica de dissipação.",
                                  "commonMistakes": "Sobre-generalizar von Neumann para regimes não lineares fortes."
                                }
                              ],
                              "practicalExample": "Simule a equação de Burgers invíscida u_t + u u_x = 0 com u(x,0) = sech^2(x) (soliton-like), usando esquema implícito Crank-Nicolson linearizado. Rode até t=2, compare onda deformada numérica com exata via características, meça dissipação como perda de amplitude de 10% devido a modos numéricos.",
                              "finalVerifications": [
                                "Fator de amplificação |g(θ)| ≤1 para todos modos, com dissipação crescente em θ alto.",
                                "Erro L2 da simulação <3% da norma exata em t final.",
                                "Decaimento de energia numérica segue predição von Neumann dentro de 15%.",
                                "Espectro Fourier mostra atenuação seletiva de altas frequências.",
                                "Relatório identifica pelo menos 2 formas de controlar dissipação excessiva.",
                                "Código roda sem erros e reproduz resultados em máquina diferente."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação do esquema implícito (convergência demonstrada).",
                                "Correção da análise de von Neumann (plots e derivações).",
                                "Quantificação robusta de dissipação (métricas L2, energia, espectro).",
                                "Qualidade dos gráficos e comparações visuais.",
                                "Profundidade da interpretação e propostas de melhoria.",
                                "Clareza e completude do relatório.",
                                "Eficiência computacional (tempo de simulação razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas não lineares e choques em mecânica de fluidos.",
                                "Computação: Algoritmos numéricos, análise de estabilidade e programação científica.",
                                "Engenharia: Simulações CFD para aerodinâmica, controle de precisão numérica.",
                                "Estatística: Análise de erros e validação de modelos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), avaliar dissipação numérica garante precisão em propagação de ondas de choque em aviões supersônicos ou tsunamis, evitando amortecimento artificial que mascara fenômenos físicos reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Dispersão e Dissipação",
                "description": "Noções básicas de dispersão e dissipação em métodos de diferenças finitas.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Definição de Dissipação Numérica",
                    "description": "Conceito básico de dissipação como amortecimento artificial de componentes de alta frequência em esquemas de diferenças finitas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Definição Básica de Dissipação Numérica",
                        "description": "Conceito fundamental de dissipação numérica como o amortecimento artificial introduzido por esquemas de diferenças finitas, que reduz a amplitude de componentes de solução ao longo das iterações temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Definir dissipação numérica",
                            "description": "Articular a definição precisa de dissipação numérica como o mecanismo pelo qual esquemas numéricos dissipam energia de modos de alta frequência, diferenciando-a de dissipação física real em equações diferenciais parabólicas ou hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de análise de estabilidade numérica",
                                  "subSteps": [
                                    "Estudar a análise de von Neumann e decomposição em modos de Fourier.",
                                    "Entender o símbolo de amplificação g(θ) para esquemas numéricos lineares.",
                                    "Identificar a condição de estabilidade |g(θ)| ≤ 1 para todos os θ.",
                                    "Explorar o papel dos modos de alta frequência (θ próximo de π).",
                                    "Anotar definições chave de dispersão e dissipação introdutórias."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras explicando a análise de von Neumann e o símbolo de amplificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula de Análise Numérica II",
                                    "Livro 'Análise Numérica de LeVeque' (capítulo sobre estabilidade)",
                                    "Calculadora ou software como MATLAB para testes simples"
                                  ],
                                  "tips": "Visualize os modos de Fourier como ondas com diferentes comprimentos de onda; alta frequência significa oscilações rápidas.",
                                  "learningObjective": "Compreender a base teórica para analisar o comportamento de esquemas numéricos em diferentes frequências.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com estabilidade von Neumann.",
                                    "Ignorar a dependência angular θ no símbolo de amplificação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender dissipação física em equações diferenciais",
                                  "subSteps": [
                                    "Analisar equações parabólicas como a de difusão (u_t = ν u_xx), onde ν representa dissipação real.",
                                    "Estudar equações hiperbólicas como a de onda (u_tt = c² u_xx), sem dissipação inerente.",
                                    "Explicar como a dissipação física amortece todos os modos de frequência, especialmente altas.",
                                    "Comparar com equações sem dissipação, como advecção pura (u_t + a u_x = 0).",
                                    "Derivar qualitativamente o comportamento assintótico das soluções físicas."
                                  ],
                                  "verification": "Derivar ou descrever a solução fundamental para a equação de calor e destacar o amortecimento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de PDEs (ex: Evans ou Strauss)",
                                    "Artigos introdutórios sobre dissipação em ondas",
                                    "Gráficos de soluções analíticas"
                                  ],
                                  "tips": "Pense em dissipação física como 'fricção' natural que suaviza irregularidades ao longo do tempo.",
                                  "learningObjective": "Diferenciar dissipação como fenômeno físico inerente às equações diferenciais.",
                                  "commonMistakes": [
                                    "Confundir dissipação com difusão em contextos não parabólicos.",
                                    "Achar que todas as PDEs hiperbólicas têm dissipação intrínseca."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir dissipação numérica via símbolo de amplificação",
                                  "subSteps": [
                                    "Definir dissipação numérica: |g(θ)| < 1 para modos de alta frequência (θ ≈ π).",
                                    "Explicar que ela introduz amortecimento artificial seletivo nos esquemas numéricos.",
                                    "Analisar esquemas dissipativos como Lax-Friedrichs ou upwind.",
                                    "Calcular exemplos simples de |g(θ)| e identificar regimes dissipativos.",
                                    "Desenhar gráficos de |g(θ)| vs θ para esquemas dissipativos vs não-dissipativos."
                                  ],
                                  "verification": "Calcular |g(θ)| para um esquema simples e verificar |g(π)| < 1.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Fórmulas de símbolos de amplificação de esquemas comuns",
                                    "Software Python/MATLAB para plotar |g(θ)|",
                                    "Tabela de esquemas numéricos"
                                  ],
                                  "tips": "Alta frequência corresponde a θ=π (oscilação célula-a-célula); dissipação numérica 'mata' essas oscilações.",
                                  "learningObjective": "Articular a definição precisa de dissipação numérica como mecanismo numérico seletivo.",
                                  "commonMistakes": [
                                    "Achar que dissipação numérica afeta apenas baixas frequências.",
                                    "Confundir |g(θ)| <1 com dispersão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar dissipação numérica de dissipação física",
                                  "subSteps": [
                                    "Comparar: dissipação física afeta todos os modos uniformemente; numérica é seletiva para altas frequências.",
                                    "Discutir implicações em precisão: numérica adiciona viscosidade artificial.",
                                    "Analisar exemplos onde dissipação numérica estabiliza mas degrada precisão.",
                                    "Estudar esquemas com controle de dissipação (ex: TVD, ENO).",
                                    "Formular uma definição completa integrando ambos os conceitos."
                                  ],
                                  "verification": "Escrever um parágrafo comparando os dois tipos de dissipação com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos numéricos de simulações com e sem dissipação",
                                    "Gráficos comparativos de soluções numéricas vs exatas"
                                  ],
                                  "tips": "Use analogia: física é 'vento em todos os barcos'; numérica é 'freio só nos barcos pequenos (alta freq.)'.",
                                  "learningObjective": "Diferenciar claramente dissipação numérica de física em contextos de PDEs parabólicas e hiperbólicas.",
                                  "commonMistakes": [
                                    "Equiparar dissipação numérica a física, ignorando seletividade.",
                                    "Não reconhecer que dissipação numérica é artefato, não fenômeno real."
                                  ]
                                }
                              ],
                              "practicalExample": "No esquema Lax-Friedrichs para a equação de advecção u_t + u_x = 0: u_j^{n+1} = (u_{j-1}^n + u_{j+1}^n)/2 - λ/2 (u_{j+1}^n - u_{j-1}^n). O símbolo de amplificação é g(θ) = cos(θ) - i λ sin(θ). Para θ=π (alta frequência), |g(π)| = | -1 | =1? Não, wait: na verdade para Lax-Friedrichs é |g(θ)| = |cos(θ)| <1 para θ≠0,π, demonstrando dissipação numérica seletiva em altas frequências, ao contrário da advecção física sem dissipação.",
                              "finalVerifications": [
                                "Definir dissipação numérica usando |g(θ)| <1 para θ≈π.",
                                "Explicar seletividade para altas frequências.",
                                "Diferenciar de dissipação física em PDEs parabólicas.",
                                "Identificar exemplo de esquema dissipativo.",
                                "Descrever impacto na estabilidade numérica.",
                                "Comparar com dispersão numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição técnica (uso correto de g(θ)).",
                                "Clareza na diferenciação com dissipação física.",
                                "Exemplos relevantes de esquemas numéricos.",
                                "Compreensão da seletividade por frequência.",
                                "Capacidade de relacionar a estabilidade e precisão.",
                                "Uso correto de terminologia de análise von Neumann."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de amortecimento em equações de ondas e difusão.",
                                "Engenharia Computacional: Estabilização em simulações CFD.",
                                "Matemática Aplicada: Teoria de aproximação e erros numéricos.",
                                "Ciência da Computação: Algoritmos de alto desempenho para PDEs."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos (CFD) para previsão climática ou aerodinâmica, a dissipação numérica é essencial para suprimir oscilações de alta frequência (Gibbs phenomenon) em malhas grosseiras, estabilizando soluções sem adicionar termos físicos extras, permitindo simulações eficientes em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Identificar amortecimento artificial",
                            "description": "Reconhecer o amortecimento artificial como um erro numérico em esquemas de diferenças finitas, exemplificando com a análise de amplificação no método de von Neumann para esquemas explícitos em equações de onda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação de onda e esquemas de diferenças finitas explícitos",
                                  "subSteps": [
                                    "Estude a equação de onda unidimensional: ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Revise a discretização espacial e temporal usando diferenças finitas centradas: u_j^{n+1} = 2u_j^n - u_j^{n-1} + r² (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = c Δt / Δx.",
                                    "Identifique os componentes explícitos do esquema e sua representação em stencil.",
                                    "Compare com o comportamento físico exato da onda sem dissipação.",
                                    "Discuta limitações iniciais dos esquemas explícitos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o esquema aproxima a equação de onda e liste os parâmetros chave (r, Δt, Δx).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e caneta para stencil, software como Python/MATLAB para visualizar stencil.",
                                  "tips": "Desenhe o stencil no papel para visualizar melhor a propagação.",
                                  "learningObjective": "Dominar a formulação do esquema explícito para equação de onda.",
                                  "commonMistakes": "Confundir esquema explícito com implícito; ignorar a condição CFL (r ≤ 1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise de von Neumann e o fator de amplificação",
                                  "subSteps": [
                                    "Aprenda a assumir solução de Fourier: u_j^n = G^n e^{i k j Δx}.",
                                    "Derive a equação de amplificação: G² - 2(1 - 2 r² sin²(θ/2)) G + 1 = 0, onde θ = k Δx.",
                                    "Calcule as raízes G± e o módulo |G| = |cos(θ r)| para o esquema padrão.",
                                    "Interprete |G| = 1 para neutro, |G| > 1 instável, |G| < 1 dissipativo.",
                                    "Diferencie amplificação por modo (alta frequência vs baixa)."
                                  ],
                                  "verification": "Calcule |G| para θ = π (modo mais alto) e verifique se |G| < 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), notas de aula sobre von Neumann.",
                                  "tips": "Use identidade trigonométrica sin²(θ/2) = (1 - cos θ)/2 para simplificar.",
                                  "learningObjective": "Aplicar análise de von Neumann para obter o fator de amplificação G.",
                                  "commonMistakes": "Esquecer o expoente n em G^n; confundir θ com k Δx."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o amortecimento artificial via |G| < 1",
                                  "subSteps": [
                                    "Calcule |G(θ)| para diferentes θ e r; note que para r < 1 e θ alto, |G| < 1.",
                                    "Compare com solução exata (|G|_{exato} = 1 para todos modos).",
                                    "Identifique amortecimento artificial como dissipação numérica excessiva em altas frequências.",
                                    "Plote |G(θ)| vs θ para visualizar o decaimento seletivo.",
                                    "Discuta impacto: suavização artificial de ondas de alta frequência."
                                  ],
                                  "verification": "Gere gráfico de |G(θ)| e aponte regiões onde |G| < 1 significativamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com Matplotlib/NumPy para plotar |G(θ)|, template de código fornecido.",
                                  "tips": "Varie r de 0.1 a 1.0 para ver efeito; foque em θ próximo a π.",
                                  "learningObjective": "Reconhecer padrões de |G| < 1 como sinal de amortecimento artificial.",
                                  "commonMistakes": "Interpretar |G| ≈ 1 como sem amortecimento; ignorar dependência em θ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e diagnosticar amortecimento em simulações",
                                  "subSteps": [
                                    "Implemente simulação numérica da equação de onda com pulso inicial.",
                                    "Execute para r = 0.5 e compare amplitude inicial vs final para altas frequências.",
                                    "Meça taxa de decaimento e atribua a amortecimento artificial.",
                                    "Teste com filtro de modos altos para confirmar.",
                                    "Documente diagnóstico: 'Amortecimento artificial detectado pois |G(π)| = 0.75 < 1'."
                                  ],
                                  "verification": "Apresente simulação com gráfico de amplitude ao longo do tempo e análise de |G|.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python/Jupyter notebook pronto, computador com NumPy/Matplotlib.",
                                  "tips": "Use pulso gaussiano para espectro amplo; meça energia total E = ∑ (u_t)^2 + c² (u_x)^2.",
                                  "learningObjective": "Diagnosticar amortecimento artificial em esquemas numéricos reais.",
                                  "commonMistakes": "Atribuir decaimento a instabilidade; não normalizar energia inicial."
                                }
                              ],
                              "practicalExample": "Em uma simulação de onda acústica em tubo (equação de onda 1D), usando esquema explícito com r=0.6 e pulso gaussiano inicial, observe que após 100 passos temporais, a amplitude das oscilações de alta frequência cai 30% enquanto a exata permaneceria constante, confirmado por |G(π)| ≈ 0.82 < 1 na análise de von Neumann.",
                              "finalVerifications": [
                                "Calcula corretamente o fator de amplificação G para esquema explícito de onda.",
                                "Identifica |G(θ)| < 1 para θ alto como amortecimento artificial.",
                                "Diferencia amortecimento artificial de dispersão numérica.",
                                "Plota e interpreta gráfico de |G(θ)| vs θ.",
                                "Diagnostica corretamente em uma simulação numérica simples.",
                                "Explica impacto físico do amortecimento em propagação de ondas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G via von Neumann (90% correto).",
                                "Correta identificação de condições para |G| < 1 (todas as regiões θ relevantes).",
                                "Qualidade do gráfico de |G(θ)| com interpretação clara.",
                                "Análise de simulação numérica com métricas quantitativas (ex: taxa de decaimento).",
                                "Diferenciação clara de dissipação vs outros erros numéricos.",
                                "Explicação concisa do mecanismo físico do amortecimento artificial."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas em mecânica e acústica.",
                                "Computação: Implementação de métodos numéricos em Python/MATLAB.",
                                "Engenharia: Simulações em controle de vibrações e CFD.",
                                "Estatística: Análise de erros numéricos e estabilidade."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, amortecimento artificial em esquemas explícitos pode subestimar amplitudes de ondas de alta frequência, levando a erros em avaliações de risco estrutural; identificação via von Neumann permite otimizar Δt/Δx ou usar esquemas de alta ordem."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Diferenciar dissipação de dispersão",
                            "description": "Explicar a distinção entre dissipação (amortecimento de amplitude) e dispersão (erro de fase), relacionando ambos à análise de estabilidade em métodos de diferenças finitas para equações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Básica de Dissipação Numérica",
                                  "subSteps": [
                                    "Revise a definição de dissipação como o amortecimento artificial da amplitude das ondas em esquemas numéricos.",
                                    "Estude a fórmula matemática para o fator de amplificação em análise de von Neumann, focando no módulo |g| < 1.",
                                    "Analise como a dissipação introduz energia numérica dissipada em soluções de equações hiperbólicas.",
                                    "Compare com o comportamento físico real onde a amplitude deve ser preservada em meios não dissipativos.",
                                    "Pratique identificando termos dissipativos em esquemas explícitos como Lax-Friedrichs."
                                  ],
                                  "verification": "Escreva uma definição precisa de dissipação e identifique-a em um esquema numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque 'Finite Difference Methods'), papel e lápis, calculadora.",
                                  "tips": "Visualize ondas decrescendo em amplitude ao longo do tempo na simulação.",
                                  "learningObjective": "Definir dissipação numérica e reconhecer seu impacto na amplitude das soluções.",
                                  "commonMistakes": "Confundir dissipação com atenuação física real; ignorar o papel do módulo do fator de amplificação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Definição de Dispersão Numérica",
                                  "subSteps": [
                                    "Defina dispersão como o erro de fase que causa velocidades de fase numéricas diferentes da física.",
                                    "Examine a relação ω_num / k_num vs ω_física / k_física, onde ω é frequência angular e k é número de onda.",
                                    "Estude o argumento do fator de amplificação arg(g) para medir o erro de fase.",
                                    "Observe como a dispersão leva a oscilações espúrias ou distorções de forma de onda.",
                                    "Implemente um exemplo simples em código para visualizar dispersão em uma equação de advecção."
                                  ],
                                  "verification": "Calcule o erro de fase para um dado esquema e descreva o efeito visual na solução.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software MATLAB ou Python (NumPy/SciPy), exemplos de código de esquemas numéricos.",
                                  "tips": "Plote soluções numéricas vs exatas para ver ondas 'dispersando' em velocidades erradas.",
                                  "learningObjective": "Identificar dispersão como erro de fase e seu efeito na propagação de ondas.",
                                  "commonMistakes": "Misturar dispersão com difusão numérica; assumir que é sempre visível em baixa resolução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Contrastar Dissipação e Dispersão",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: dissipação afeta amplitude (|g|), dispersão afeta fase (arg(g)).",
                                    "Discuta cenários onde um esquema é dissipativo mas não dispersivo (ex: esquemas upwind).",
                                    "Analise esquemas como Leapfrog: não dissipativo mas altamente dispersivo.",
                                    "Relacione ambos à condição CFL para estabilidade em equações hiperbólicas.",
                                    "Resolva exercícios que pedem classificar esquemas quanto a dissipação/dispersão."
                                  ],
                                  "verification": "Preencha uma tabela de comparação e aplique a um esquema dado, justificando classificações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou tabela em documento, referências teóricas de análise de estabilidade.",
                                  "tips": "Use o plano complexo de G para visualizar regiões dissipativas vs dispersivas.",
                                  "learningObjective": "Diferenciar claramente os mecanismos de dissipação e dispersão em termos matemáticos e qualitativos.",
                                  "commonMistakes": "Trocar os termos: achar que dissipação afeta fase; subestimar interações entre os dois."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos à Análise de Estabilidade em Métodos de Diferenças Finitas",
                                  "subSteps": [
                                    "Revise a análise de von Neumann para equações hiperbólicas como a equação da onda.",
                                    "Determine condições de estabilidade considerando ambos erros: |g| ≤ 1 (estável, dissipativo se <1) e arg(g) ≈ ωΔt.",
                                    "Simule numericamente um problema hiperbólico e diagnostique dissipação vs dispersão nos erros.",
                                    "Discuta trade-offs: esquemas dissipativos estabilizam mas suavizam; dispersivos oscilam mas preservam energia.",
                                    "Conclua com critérios para escolher esquemas em aplicações reais."
                                  ],
                                  "verification": "Realize uma análise completa de estabilidade para um esquema dado e interprete resultados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB para simulação, gráficos de erro L2 e fase.",
                                  "tips": "Sempre normalize frequências e compare curvas de dispersão numérica vs física.",
                                  "learningObjective": "Relacionar dissipação e dispersão à estabilidade geral de esquemas numéricos hiperbólicos.",
                                  "commonMistakes": "Focar só em |g|≤1 sem checar fase; ignorar dependência no número de onda."
                                }
                              ],
                              "practicalExample": "Considere a equação da onda 1D: u_tt = c^2 u_xx. Usando o esquema Leapfrog central: u_j^{n+1} = 2u_j^n - u_j^{n-1} + r^2 (u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde r = cΔt/Δx. Este esquema é não dissipativo (|g|=1) mas dispersivo (fase errada para ondas curtas), levando a oscilações traseiras em pulsos propagantes.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre dissipação e dispersão sem consultar notas.",
                                "Identifique dissipação/dispersão em um esquema numérico desconhecido.",
                                "Gere um gráfico mostrando erro de fase vs número de onda.",
                                "Classifique corretamente 3 esquemas comuns (Lax-Wendroff, upwind, Leapfrog).",
                                "Relacione os conceitos à instabilidade em simulações hiperbólicas.",
                                "Resolva um problema de estabilidade considerando ambos erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de dissipação (amplitude): 0-4 pontos.",
                                "Precisão na definição de dispersão (fase): 0-4 pontos.",
                                "Clareza na comparação tabular ou gráfica: 0-4 pontos.",
                                "Correta aplicação à análise de von Neumann: 0-4 pontos.",
                                "Exemplo prático relevante e análise: 0-4 pontos.",
                                "Integração com estabilidade hiperbólica: 0-4 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e análise de erros em simulações acústicas/sísmicas.",
                                "Engenharia Computacional: Desenvolvimento de solvers CFD estáveis para escoamentos compressíveis.",
                                "Ciência da Computação: Otimização de algoritmos numéricos para alto desempenho.",
                                "Matemática Aplicada: Teoria de aproximação e análise de truncamento."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, esquemas dissipativos controlam oscilações numéricas sem mascarar sinais reais, enquanto dispersão mínima preserva a resolução temporal de ondas de chegada, impactando precisão em modelos geofísicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Componentes de Alta Frequência e Dissipação",
                        "description": "Papel seletivo da dissipação numérica no amortecimento de componentes de alta frequência (ondas curtas) em soluções aproximadas por diferenças finitas, preservando melhor componentes de baixa frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Caracterizar componentes de alta frequência",
                            "description": "Descrever componentes de alta frequência como modos com comprimentos de onda próximos ao tamanho da malha em esquemas de diferenças finitas, suscetíveis a dissipação excessiva em métodos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Análise de Estabilidade von Neumann em Esquemas de Diferenças Finitas",
                                  "subSteps": [
                                    "Estude a análise de von Neumann: assuma solução do tipo u_j^n = g^n e^{i k j h}, onde h é o tamanho da malha.",
                                    "Derive o símbolo de amplificação g(k) para um esquema simples, como Lax-Friedrichs ou upwind.",
                                    "Analise o espectro de frequências k de 0 a π/h, identificando o modo físico (baixa k) e oscilatório (alta k).",
                                    "Implemente um código simples em Python/MATLAB para plotar |g(k)| vs k.",
                                    "Compare g(k) para diferentes esquemas numéricos."
                                  ],
                                  "verification": "Plotar o símbolo de amplificação |g(k)| e confirmar picos em altas frequências k ≈ π/h.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de análise numérica (ex: LeVeque), Python com NumPy/Matplotlib ou MATLAB.",
                                  "tips": "Comece com a equação de transporte linear u_t + a u_x = 0 para simplicidade.",
                                  "learningObjective": "Compreender como a análise von Neumann revela comportamento de modos em esquemas FD.",
                                  "commonMistakes": "Confundir k (frequência espacial) com ω (temporal); ignorar normalização h=Δx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Identificar Componentes de Alta Frequência",
                                  "subSteps": [
                                    "Defina comprimento de onda λ = 2π / k; alta frequência quando λ ≤ 2h (k ≥ π/(2h)).",
                                    "Classifique: baixa frequência λ >> h (resolvida pela malha), alta frequência λ ≈ 2h (2 pontos por onda).",
                                    "Visualize com uma senoide de alta frequência: plote u_j = sin(π j) que oscila sinal alternado.",
                                    "Calcule numericamente o número de pontos por onda para diferentes k.",
                                    "Discuta o teorema de Nyquist: malha resolve até λ=2h."
                                  ],
                                  "verification": "Identificar corretamente que para k=π/h, λ=2h e o modo é (-1)^j.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel e lápis para sketches, software de plotagem.",
                                  "tips": "Use animações de ondas para visualizar: alta freq parece 'ruído' na malha.",
                                  "learningObjective": "Distinguir componentes de alta frequência baseados no comprimento de onda relativo a h.",
                                  "commonMistakes": "Confundir alta frequência com alta velocidade de fase; esquecer fator 2π em λ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Caracterizar Suscetibilidade à Dissipação Excessiva",
                                  "subSteps": [
                                    "Analise |g(k)| para alta k: em esquemas dissipativos (ex: upwind), |g| <<1 para k=π/h.",
                                    "Compare com esquemas não-dissipativos (ex: Lax-Wendroff): |g|≈1 mas oscilações.",
                                    "Calcule taxa de dissipação: arg(g) ≈ c k h para fase, |g|-1 ≈ -ν k^2 h^2 para baixa k, mas excessiva em alta k.",
                                    "Simule numericamente: resolva u_t = u_xx com malha fina/grossa e observe decaimento de alta freq.",
                                    "Quantifique: meça atenuação relativa de modos alta vs baixa freq."
                                  ],
                                  "verification": "Demonstrar via plot ou simulação que |g(π/h)| < 0.5 em esquemas dissipativos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código numérico pronto (ex: GitHub repos de PDE solvers), equação de calor ou advecção.",
                                  "tips": "Foquem em esquemas explícitos; adicione ruído inicial de alta freq para testar.",
                                  "learningObjective": "Explicar por que componentes de alta frequência sofrem dissipação excessiva em métodos numéricos.",
                                  "commonMistakes": "Atribuir dissipação só a viscosidade numérica sem analisar g(k); ignorar dependência em h."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Caracterização e Aplicar em Exemplo Prático",
                                  "subSteps": [
                                    "Escreva uma definição formal: 'Componentes de alta frequência: modos com k h ≈ π, λ ≈ 2Δx, dissipados excessivamente pois |g| <<1 enquanto fase errada'.",
                                    "Aplique a um esquema específico: caracterize para Leapfrog em equação de onda.",
                                    "Crie um relatório curto com plots de g(k), identificação de alta freq e implicações.",
                                    "Discuta filtros para remover alta freq (ex: suavização explícita).",
                                    "Teste sensibilidade: refine malha e veja redução de dissipação relativa."
                                  ],
                                  "verification": "Redigir parágrafo descrevendo caracterização com equação matemática e plot de suporte.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de texto, simulador numérico.",
                                  "tips": "Use cores nos plots: azul para baixa freq (preservada), vermelho para alta (dissipada).",
                                  "learningObjective": "Sintetizar descrição completa de componentes de alta frequência em contexto de dissipação numérica.",
                                  "commonMistakes": "Generalizar sem exemplo específico; omitir ligação com tamanho da malha."
                                }
                              ],
                              "practicalExample": "Em uma simulação da equação de advecção u_t + u_x = 0 com esquema upwind e h=0.1, adicione uma componente inicial sin(π x / h) (alta freq, λ=2h). Após 10 passos temporais, observe que ela decai para <1% da amplitude inicial devido a |g(π/h)|≈0.63^10, enquanto baixa freq sin(2π x /10h) preserva amplitude.",
                              "finalVerifications": [
                                "Definir corretamente alta frequência como λ ≈ 2h ou kh ≈ π.",
                                "Plotar |g(k)| mostrando dissipação excessiva em kh>π/2.",
                                "Explicar suscetibilidade: |g|<<1 para alta k vs ≈1 para baixa k.",
                                "Simulação numérica confirma decaimento seletivo de alta freq.",
                                "Relatório escrito resume caracterização com matemática e visual.",
                                "Identificar implicações para escolha de esquemas numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de comprimento de onda e frequência espacial.",
                                "Correta derivação/análise do símbolo de amplificação g(k).",
                                "Qualidade dos plots e simulações demonstrando dissipação.",
                                "Profundidade na discussão de suscetibilidade excessiva.",
                                "Clareza na síntese escrita e ligação com malha h.",
                                "Criatividade em exemplos e verificações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e dispersão em meios discretos (ex: rede cristalina).",
                                "Engenharia Computacional: CFD, onde alta freq causa 'blockiness' em soluções.",
                                "Ciência da Computação: Análise de algoritmos e estabilidade em solvers PDE.",
                                "Processamento de Sinais: Filtros numéricos e aliasing por subamostragem."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) com malhas grossas, componentes de alta frequência representam ruído numérico dissipado artificialmente, levando a soluções viscosas excessivas; caracterizá-los permite adicionar dissipação adaptativa ou refinar malha seletivamente em turbulência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Analisar impacto da dissipação em alta frequência",
                            "description": "Avaliar como a dissipação numérica amortece seletivamente ondas de alta frequência, usando o fator de amplificação |g(k)| < 1 para números de onda k altos na análise de Fourier simbólico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de dissipação numérica e análise de von Neumann",
                                  "subSteps": [
                                    "Estude a definição de dissipação numérica como o amortecimento artificial introduzido por esquemas de diferenças finitas.",
                                    "Revise a análise de estabilidade de von Neumann, assumindo soluções de Fourier plano e definindo o fator de amplificação g(k).",
                                    "Identifique como |g(k)| ≤ 1 garante estabilidade, com |g(k)| < 1 indicando dissipação.",
                                    "Analise exemplos simples de esquemas dissipativos, como o esquema de Lax-Friedrichs.",
                                    "Registre anotações sobre a relação entre dissipação e precisão numérica."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo de g(k) para um esquema conhecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: LeVeque), notas de aula, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Comece com esquemas 1D para simplicidade antes de generalizar.",
                                  "learningObjective": "Compreender a base teórica da dissipação via fator de amplificação.",
                                  "commonMistakes": "Confundir dissipação com dispersão; dissipação amortece, dispersão distorce fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar números de onda k e componentes de alta frequência",
                                  "subSteps": [
                                    "Defina o número de onda k = 2π/λ, onde λ é o comprimento de onda, e relacione com a malha numérica Δx.",
                                    "Identifique componentes de alta frequência como aquelas com kΔx próximo a π (comprimentos de onda ~2Δx).",
                                    "Calcule k para diferentes modos: baixo k (ondas longas), alto k (ondas curtas).",
                                    "Visualize em um gráfico k vs. frequência espacial.",
                                    "Discuta por que altas frequências são 'não-físicas' em simulações numéricas."
                                  ],
                                  "verification": "Crie uma tabela com k baixo, médio e alto, indicando comportamento esperado de |g(k)|.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis para gráficos, software de plotagem (Matplotlib ou similar).",
                                  "tips": "Lembre-se: k máx = π/Δx pelo teorema de Nyquist-Shannon.",
                                  "learningObjective": "Dominar a caracterização espectral de componentes de onda.",
                                  "commonMistakes": "Ignorar a normalização kΔx ∈ [0, π]; sempre trabalhar no intervalo físico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o comportamento de |g(k)| para k altos em esquemas dissipativos",
                                  "subSteps": [
                                    "Derive ou consulte a expressão de g(k) para um esquema numérico específico (ex: upwind com viscosidade artificial).",
                                    "Calcule |g(k)| analiticamente para k → π, mostrando |g(k)| < 1.",
                                    "Compare com esquemas não-dissipativos onde |g(k)| ≈ 1 para todos k.",
                                    "Plote |g(k)| vs. kΔx para visualizar amortecimento seletivo em altas frequências.",
                                    "Quantifique o impacto: taxa de amortecimento por iteração."
                                  ],
                                  "verification": "Gere um gráfico de |g(k)| e identifique o intervalo onde dissipação é dominante (kΔx > π/2).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SymPy ou MATLAB para derivação simbólica, Python para plotagem.",
                                  "tips": "Use expansões em série de Taylor para aproximar |g(k)| perto de k=π.",
                                  "learningObjective": "Avaliar matematicamente o amortecimento seletivo de altas frequências.",
                                  "commonMistakes": "Esquecer o módulo |g(k)|; foque na magnitude, não na fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar análise de Fourier simbólica para avaliar impacto prático",
                                  "subSteps": [
                                    "Implemente uma transformada de Fourier discreta (DFT) em uma solução numérica simulada.",
                                    "Aplique um esquema dissipativo a uma onda inicial com espectro amplo.",
                                    "Compare espectros antes/depois de várias iterações, focando em decaimento de modos altos k.",
                                    "Use ferramentas simbólicas para g(k) exato e numérico para validação.",
                                    "Escreva um relatório curto sobre o impacto na precisão e estabilidade."
                                  ],
                                  "verification": "Produza gráficos de espectro temporal mostrando dissipação seletiva.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (NumPy, SciPy para FFT), Jupyter Notebook.",
                                  "tips": "Inclua ruído de alta frequência na inicialização para testar dissipação.",
                                  "learningObjective": "Integrar teoria e prática para analisar dissipação em cenários reais.",
                                  "commonMistakes": "Não normalizar o espectro; sempre compare energias relativas."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com esquema upwind viscoso. Inicialize com uma gaussiana + ruído. Após 100 passos, o espectro FFT mostra decaimento exponencial para kΔx > 1.5, enquanto modos baixos k preservam amplitude (|g(k)| ≈1), demonstrando amortecimento seletivo.",
                              "finalVerifications": [
                                "Derivar corretamente |g(k)| para um esquema dado e mostrar |g(k)| <1 para k altos.",
                                "Plotar e interpretar gráfico de |g(k)| vs. kΔx com dissipação evidente.",
                                "Simular numericamente e confirmar decaimento seletivo via FFT.",
                                "Explicar verbalmente o papel da dissipação na supressão de oscilações 2Δx.",
                                "Comparar com esquema não-dissipativo, destacando instabilidades.",
                                "Quantificar taxa de dissipação para k=π."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de g(k): 30% (correta expressão simbólica).",
                                "Qualidade da análise gráfica: 25% (plots claros com legendas e insights).",
                                "Validação numérica: 20% (simulação converge sem artefatos).",
                                "Interpretação do impacto seletivo: 15% (explicação física/matemática).",
                                "Conexão com estabilidade geral: 10% (menção a CFL e precisão)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas amortecidas em acústica e fluidos.",
                                "Computação Científica: Otimização de solvers numéricos em CFD.",
                                "Engenharia: Controle de ruído numérico em simulações sísmicas.",
                                "Estatística: Análise espectral em séries temporais."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), a dissipação seletiva em esquemas como MUSCL estabiliza soluções ao amortecer oscilações de alta frequência geradas por choques, permitindo previsões precisas em aerodinâmica de aviões sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Relacionar com estabilidade numérica",
                            "description": "Conectar dissipação numérica à estabilidade de esquemas explícitos e implícitos, ilustrando como dissipação adequada previne instabilidades em simulações de equações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Dissipação Numérica e Estabilidade",
                                  "subSteps": [
                                    "Defina dissipação numérica como a atenuação artificial de componentes de alta frequência em esquemas de diferenças finitas.",
                                    "Explique o critério de von Neumann para estabilidade: |amplification factor| ≤ 1 para todas as frequências.",
                                    "Identifique que dissipação adequada reduz o módulo do fator de amplificação para <1 em altas frequências.",
                                    "Discuta como a falta de dissipação leva a crescimento exponencial de erros em simulações hiperbólicas.",
                                    "Compare dissipação com dispersão: dissipação amortece, dispersão distorce fase."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre dissipação e estabilidade, citando fórmulas chave como G(k) para fator de amplificação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: LeVeque), notas de aula sobre von Neumann, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Use diagramas de onda para visualizar atenuação de modos altos.",
                                  "learningObjective": "Compreender a base teórica ligando dissipação à estabilidade espectral.",
                                  "commonMistakes": "Confundir dissipação (amortecimento) com dispersão (fase errada); ignorar dependência em frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade em Esquemas Explícitos",
                                  "subSteps": [
                                    "Considere o esquema explícito forward-time central-space (FTCS) para a equação de advecção u_t + a u_x = 0.",
                                    "Calcule o fator de amplificação G(k) = 1 - i a Δt/Δx sin(k Δx) para FTCS.",
                                    "Mostre que |G(k)| >1 para certas k em CFL >1, levando a instabilidade.",
                                    "Introduza dissipação artificial via viscosidade numérica ou upwinding, reduzindo |G| <1.",
                                    "Plote |G(k)| vs. k para CFL=0.9 com e sem dissipação."
                                  ],
                                  "verification": "Gere plots confirmando instabilidade sem dissipação e estabilidade com ela.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com NumPy/Matplotlib, template de código para análise von Neumann.",
                                  "tips": "Normalize k de 0 a π; foque em modos 2Δx (alta frequência).",
                                  "learningObjective": "Demonstrar como esquemas explícitos requerem dissipação para estabilidade em hiperbólicas.",
                                  "commonMistakes": "Erro no cálculo de G(k): esquecer termos imaginários; CFL inadequado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Esquemas Implícitos e Dissipação Inerente",
                                  "subSteps": [
                                    "Analise o esquema implícito backward-time central-space (BTCS) para a mesma equação.",
                                    "Derive G(k) = 1 / (1 + i a Δt/Δx sin(k Δx)), mostrando |G(k)| ≤1 incondicionalmente.",
                                    "Explique que o denominador introduz dissipação numérica forte em altas frequências.",
                                    "Compare G(k) explícito vs. implícito via plots para CFL variados.",
                                    "Discuta trade-offs: implícitos são estáveis mas dissipam mais, suavizando soluções."
                                  ],
                                  "verification": "Compare plots de |G(k)| e explique verbalmente por que implícitos são incondicionalmente estáveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo ambiente Python/MATLAB, referências teóricas (ex: artigos sobre Leapfrog vs. Lax-Wendroff).",
                                  "tips": "Use aproximações assintóticas para kΔx → π: |G| ≈ 1 - (kΔx)^2/2 para dissipação.",
                                  "learningObjective": "Entender o papel da dissipação inerente em esquemas implícitos para prevenir instabilidades.",
                                  "commonMistakes": "Acreditar que implícitos eliminam dissipação (eles a aumentam); ignorar custo computacional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Simulação Numérica de Equação Hiperbólica",
                                  "subSteps": [
                                    "Implemente simulação da equação de onda u_tt = c^2 u_xx com esquema explícito Leapfrog.",
                                    "Adicione ruído inicial de alta frequência e rode sem/com dissipação (ex: filtro ou upwind).",
                                    "Observe instabilidade (blow-up) sem dissipação vs. amortecimento adequado com ela.",
                                    "Repita com esquema implícito para contrastar comportamentos.",
                                    "Quantifique estabilidade medindo norma L2 do erro ao longo do tempo."
                                  ],
                                  "verification": "Produza animações/plots mostrando blow-up sem dissipação e estabilidade com ela.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código Python completo (Jupyter notebook), condições iniciais gaussianas + ruído.",
                                  "tips": "Use Δt/Δx = CFL constante; grave vídeos para análise.",
                                  "learningObjective": "Aplicar conceitualmente a conexão dissipação-estabilidade em simulações reais.",
                                  "commonMistakes": "Resolução espacial insuficiente (Nyquist); CFL muito alto inicialmente."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 em [0,2π] com u(0,x)=sen(x) + 0.01*ruído aleatório. Use FTCS explícito com CFL=0.9 sem upwinding: observe oscilações crescendo. Adicione upwinding (dissipação): solução permanece estável e converge.",
                              "finalVerifications": [
                                "Explicar em 2-3 frases como dissipação numérica |G(k)|<1 previne |G|=1 com fase errada em explícitos.",
                                "Derivar G(k) para FTCS e BTCS, plotando |G(k)|.",
                                "Simular equação hiperbólica mostrando instabilidade sem dissipação.",
                                "Identificar em código onde dissipação é introduzida (ex: stencil assimétrico).",
                                "Discutir limitação: excesso de dissipação borra choques.",
                                "Resolver exercício teórico: provar estabilidade condicional de Lax-Friedrichs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de fatores de amplificação (100% das fórmulas corretas).",
                                "Clareza nos plots/simulações: legendas, escalas adequadas, múltiplas runs.",
                                "Profundidade conceitual: conexão explícita dissipação → estabilidade em hiperbólicas.",
                                "Análise qualitativa/quantitativa de resultados (normas de erro, taxas de crescimento).",
                                "Originalidade no exemplo prático: variação além do fornecido.",
                                "Comunicação: explicação oral/escrita fluida sem jargão desnecessário."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas onde dissipação numérica simula viscosidade real.",
                                "Engenharia Computacional: CFD em aerodinâmica, evitando instabilidades em simulações supersônicas.",
                                "Ciência da Computação: Otimização de algoritmos paralelos para solvers implícitos estáveis.",
                                "Matemática Aplicada: Análise de Fourier em PDEs, ligando a processamento de sinais."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos como WRF), dissipação numérica adequada em esquemas explícitos previne 'explosões' de ruído em previsões de furacões, garantindo estabilidade em grids globais para runs de dias."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Dissipação em Esquemas de Diferenças Finitas",
                        "description": "Aplicação prática do conceito de dissipação em esquemas de diferenças finitas para equações parabólicas e hiperbólicas, com referências à consistência e convergência.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Exemplificar dissipação em esquemas explícitos",
                            "description": "Demonstrar dissipação em esquemas explícitos para a equação de advecção ou onda, calculando o fator de dissipação a partir da função de amplificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Dissipação Numérica e Função de Amplificação",
                                  "subSteps": [
                                    "Defina dissipação numérica como a redução artificial da amplitude das componentes de alta frequência em esquemas de diferenças finitas.",
                                    "Explique a função de amplificação G(θ) como o fator pelo qual uma onda com número de onda θ é multiplicada em um passo temporal.",
                                    "Discuta que dissipação ocorre quando |G(θ)| < 1 para θ ≠ 0.",
                                    "Revise a equação de advecção u_t + a u_x = 0 e seu comportamento exato (sem dissipação).",
                                    "Compare com esquemas implícitos vs. explícitos, focando em explícitos como FTCS e upwind."
                                  ],
                                  "verification": "Resuma em suas palavras o que é dissipação e escreva a condição |G(θ)| < 1 com um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de dispersão/dissipação)",
                                    "Notas de aula sobre equação de advecção",
                                    "Calculadora ou software como Python/Jupyter para anotações"
                                  ],
                                  "tips": [
                                    "Use diagramas de von Neumann para visualizar G(θ).",
                                    "Comece com θ pequeno para ondas longas (sem dissipação)."
                                  ],
                                  "learningObjective": "Identificar e explicar dissipação numérica via função de amplificação em esquemas explícitos.",
                                  "commonMistakes": [
                                    "Confundir dissipação com dispersão (dispersão afeta fase, dissipação afeta amplitude).",
                                    "Ignorar que |G(0)| = 1 sempre para consistência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Descrever um Esquema Explícito para a Equação de Advecção",
                                  "subSteps": [
                                    "Escolha o esquema upwind explícito: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), onde λ = a Δt / Δx.",
                                    "Derive a stencil do esquema e identifique coeficientes.",
                                    "Assuma solução de Fourier u_j^n = g^n e^{i θ j}, levando à recursão g = G(θ).",
                                    "Calcule G(θ) = 1 - λ (1 - e^{-iθ}).",
                                    "Simplifique para |G(θ)|^2 = [1 - λ (1 - cosθ)]^2 + [λ sinθ]^2."
                                  ],
                                  "verification": "Escreva a fórmula de G(θ) para o esquema upwind e verifique |G(0)| = 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado para stencil",
                                    "Software MATLAB/Python para plotar G(θ)",
                                    "Referência: LeVeque 'Finite Difference Methods for ODEs and PDEs'"
                                  ],
                                  "tips": [
                                    "Mantenha 0 < λ ≤ 1 para estabilidade.",
                                    "Use expansão em série para θ pequeno: |G| ≈ 1 - (λ θ^2)/2."
                                  ],
                                  "learningObjective": "Derivar a função de amplificação para um esquema explícito específico.",
                                  "commonMistakes": [
                                    "Erro no sinal do upwind (use a > 0).",
                                    "Esquecer o expoente iθ na solução de Fourier."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Analisar o Fator de Dissipação",
                                  "subSteps": [
                                    "Compute |G(θ)| explicitamente para upwind: |G(θ)| = sqrt{1 - 4λ(1-λ) sin^2(θ/2)}.",
                                    "Identifique o fator de dissipação como |G(θ)|, mostrando que diminui com θ crescente.",
                                    "Compare com FTCS: G(θ) = 1 - i λ sinθ - (λ^2/2)(1 - cosθ), notando instabilidade (|G|>1).",
                                    "Plote |G(θ)| vs. θ para λ=0.5, observando dissipação seletiva em altas frequências.",
                                    "Calcule dissipação numérica por passo: ΔE ≈ (1 - |G|^2) E."
                                  ],
                                  "verification": "Calcule |G(π)| para λ=0.5 e confirme |G(π)| = |1 - 2λ| <1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para plots",
                                    "Planilha Excel para cálculos tabulares",
                                    "Artigo sobre análise de von Neumann"
                                  ],
                                  "tips": [
                                    "Use identidade trigonométrica 1 - cosθ = 2 sin^2(θ/2).",
                                    "Foquem em θ de 0 a π (frequências Nyquist)."
                                  ],
                                  "learningObjective": "Extrair e interpretar o fator de dissipação da função de amplificação.",
                                  "commonMistakes": [
                                    "Calcular |G| errado por não usar módulo complexo corretamente.",
                                    "Confundir fator de dissipação com taxa de dispersão (arg G)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e Visualizar Dissipação em um Caso Prático",
                                  "subSteps": [
                                    "Implemente o esquema upwind em código para advecção com pulso inicial.",
                                    "Execute simulação com λ=0.5, compare solução numérica vs. exata.",
                                    "Meça dissipação observando suavização do pulso ao longo do tempo.",
                                    "Varie λ e θ efetivo para demonstrar impacto no fator de dissipação.",
                                    "Gere gráfico de |G(θ)| e animação da solução para ilustrar."
                                  ],
                                  "verification": "Produza plot mostrando dissipação (pulso exato vs. numérico após 100 passos).",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Jupyter Notebook com código Python pronto",
                                    "Dados de teste: pulso gaussiano u(x,0)=exp(-(x-0.5)^2)",
                                    "Bibliotecas: NumPy, Matplotlib"
                                  ],
                                  "tips": [
                                    "Use Δx=1/100, Δt=λ Δx /a com a=1.",
                                    "Salve frames para animação."
                                  ],
                                  "learningObjective": "Aplicar cálculo de dissipação em simulação numérica real.",
                                  "commonMistakes": [
                                    "Violação CFL (λ>1 leva a instabilidade, não dissipação).",
                                    "Escala errada no plot ocultando dissipação."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x =0 com pulso inicial gaussiano centrado em x=0.5, usando esquema upwind explícito com λ=0.5: após 100 passos, o pulso numérico é suavizado (dissipado) comparado ao exato, com |G(π)|≈0 confirmando forte dissipação em oscilações de alta frequência.",
                              "finalVerifications": [
                                "Calcule corretamente G(θ) e |G(θ)| para upwind e FTCS.",
                                "Interprete plot de |G(θ)| mostrando dissipação seletiva.",
                                "Simule advecção e identifique artefato de dissipação na solução.",
                                "Compare dissipação em esquemas explícitos vs. implícitos.",
                                "Explique por que dissipação é desejável para estabilizar altas frequências.",
                                "Verifique estabilidade via |G(θ)| ≤1 para todo θ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G(θ) (fórmula exata).",
                                "Correta interpretação de |G(θ)| como fator de dissipação.",
                                "Qualidade do plot/simulação demonstrando dissipação.",
                                "Análise qualitativa/quantitativa do impacto em solução numérica.",
                                "Identificação de erros comuns e correções.",
                                "Conexão clara com estabilidade e precisão numérica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas amortecidas e difusão numérica em fluidos.",
                                "Computação: Análise de estabilidade em métodos numéricos (von Neumann).",
                                "Engenharia: Simulações CFD onde dissipação artificial controla oscilações.",
                                "Estatística: Análise de erro numérico em séries de Fourier."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM), esquemas com dissipação controlada previnem acúmulo de energia em escalas pequenas, garantindo estabilidade em previsões de longo prazo; em CFD aeroespacial, reduz wiggles em choques."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Avaliar dissipação em métodos ADI",
                            "description": "Discutir como métodos ADI para equações parabólicas introduzem dissipação controlada, relacionando à estabilidade e redução de oscilações de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos ADI para Equações Parabólicas",
                                  "subSteps": [
                                    "Estudar a equação parabólica modelo: u_t = Δu em 2D.",
                                    "Explicar a decomposição em passos unidimensionais (direção x e y).",
                                    "Derivar o esquema ADI implícito alternado.",
                                    "Analisar a matriz tridiagonal resultante em cada direção.",
                                    "Implementar um código básico em Python ou MATLAB para teste."
                                  ],
                                  "verification": "Executar simulação ADI estável para equação de calor 2D e comparar com solução explícita.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Python com NumPy/SciPy",
                                    "Notas sobre diferenças finitas"
                                  ],
                                  "tips": "Use malha uniforme inicialmente para simplificar análise.",
                                  "learningObjective": "Dominar a formulação e implementação básica do ADI.",
                                  "commonMistakes": [
                                    "Esquecer a alternância de direções",
                                    "Aplicar condições de contorno incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Conceitos de Dissipação Numérica",
                                  "subSteps": [
                                    "Definir dissipação como atenuação seletiva de componentes de alta frequência.",
                                    "Introduzir fator de amplificação |g(θ)| via análise de von Neumann.",
                                    "Calcular dissipação para esquemas parabólicos clássicos (Crank-Nicolson, explícito).",
                                    "Plotar |g(θ)| vs. frequência espacial θ para visualização.",
                                    "Discutir relação com norma L2 e energia numérica."
                                  ],
                                  "verification": "Derivar e plotar |g(θ)| para esquema FTCS e confirmar |g| < 1 para θ alto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de derivadas de amplificação",
                                    "MATLAB/Python para plots",
                                    "Referências sobre estabilidade numérica"
                                  ],
                                  "tips": "Normalizar θ entre 0 e π para clareza.",
                                  "learningObjective": "Identificar e quantificar dissipação em esquemas genéricos.",
                                  "commonMistakes": [
                                    "Confundir dissipação com dispersão",
                                    "Ignorar o módulo complexo de g"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Dissipação Específica nos Métodos ADI",
                                  "subSteps": [
                                    "Derivar o símbolo do operador ADI para análise de Fourier.",
                                    "Calcular o fator de amplificação multistep do ADI.",
                                    "Comparar dissipação ADI vs. métodos ponto-implícito ou Douglas.",
                                    "Verificar que ADI introduz dissipação controlada via fatores (1 - σ sin²(θ/2)).",
                                    "Simular numericamente atenuação de modos em malha fina."
                                  ],
                                  "verification": "Computar |g_ADI(θ)| analiticamente e validar com simulação numérica (erro < 1%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Cálculo simbólico (SymPy)",
                                    "Código ADI modificado",
                                    "Artigos sobre ADI (Peaceman-Rachford)"
                                  ],
                                  "tips": "Aproxime para pequenos Δt para insight analítico.",
                                  "learningObjective": "Quantificar a dissipação introduzida pelo ADI.",
                                  "commonMistakes": [
                                    "Linearizar incorretamente o operador bilinear",
                                    "Negligenciar termos cruzados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Dissipação ADI à Estabilidade e Redução de Oscilações",
                                  "subSteps": [
                                    "Explicar como dissipação controlada garante estabilidade incondicional.",
                                    "Demonstrar redução de oscilações de alta frequência via plots de solução.",
                                    "Comparar soluções ADI com esquemas não-dissipativos (ex: Leapfrog).",
                                    "Avaliar trade-off: dissipação vs. precisão de fase.",
                                    "Realizar estudo de sensibilidade em Δx, Δt."
                                  ],
                                  "verification": "Gerar gráficos mostrando atenuação seletiva e ausência de oscilações em solução ADI.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Códigos de simulação expandidos",
                                    "Ferramentas de plot (Matplotlib)",
                                    "Benchmark com solução exata"
                                  ],
                                  "tips": "Use condições iniciais com alta frequência (sen(10πx)) para evidenciar efeito.",
                                  "learningObjective": "Avaliar impactos da dissipação ADI em estabilidade e qualidade da solução.",
                                  "commonMistakes": [
                                    "Atribuir estabilidade só à implicitidade",
                                    "Sobreestimar dissipação em baixas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de calor 2D u_t = u_xx + u_yy em [0,1]x[0,1] com u(x,y,0) = sin(8πx)sin(8πy) (alta frequência), usando ADI com Δt=0.01, Δx=0.05. Plote u em t=0.1 e compare com solução exata e esquema Crank-Nicolson, observando atenuação controlada das oscilações.",
                              "finalVerifications": [
                                "Derivar corretamente |g(θ)| para ADI mostrando |g| < 1 para todas θ.",
                                "Explicar verbalmente como ADI dissipa oscilações sem comprometer estabilidade.",
                                "Implementar simulação ADI e quantificar dissipação via norma L2 de erro.",
                                "Comparar dissipação ADI vs. outro esquema em relatório curto.",
                                "Identificar parâmetros que controlam nível de dissipação."
                              ],
                              "assessmentCriteria": [
                                "Precisão analítica na derivação do fator de amplificação (erro < 5%).",
                                "Correta interpretação de plots numéricos de dissipação.",
                                "Demonstração clara da relação dissipação-estabilidade-oscilações.",
                                "Implementação numérica estável e eficiente.",
                                "Análise de trade-offs com argumentos quantitativos.",
                                "Relatório com gráficos e conclusões fundamentadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e amortecimento em ondas.",
                                "Computação Científica: Análise de estabilidade em solvers PDE.",
                                "Engenharia Mecânica: Simulações de propagação de calor em estruturas.",
                                "Matemática Aplicada: Teoria de semigrupos e operadores dissipativos."
                              ],
                              "realWorldApplication": "Em simulações CFD para previsão de difusão de poluentes em aquíferos ou calor em painéis solares, onde métodos ADI dissipam ruído numérico de alta frequência, garantindo soluções estáveis e precisas para otimização de designs industriais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Definição de Dispersão Numérica",
                    "description": "Conceito básico de dispersão como variação da velocidade de propagação de ondas de diferentes frequências em métodos numéricos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Velocidade de Fase em Ondas",
                        "description": "Conceito fundamental da velocidade de fase como a velocidade com que um plano de fase constante de uma onda se propaga, dependendo da frequência da onda em meios dispersivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Definir velocidade de fase física",
                            "description": "Explicar a definição matemática da velocidade de fase ω/k, onde ω é a frequência angular e k o número de onda, e sua importância na propagação de ondas monocromáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais: Frequência Angular (ω) e Número de Onda (k)",
                                  "subSteps": [
                                    "Defina frequência angular ω como ω = 2πf, onde f é a frequência em Hz.",
                                    "Explique que ω representa a taxa angular de oscilação em radianos por segundo.",
                                    "Defina número de onda k como k = 2π/λ, onde λ é o comprimento de onda.",
                                    "Descreva k como o número de radianos por unidade de comprimento espacial.",
                                    "Discuta unidades: ω em rad/s, k em rad/m."
                                  ],
                                  "verification": "Resuma as definições de ω e k em suas próprias palavras e forneça exemplos numéricos de unidades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Física Ondas (capítulo sobre ondas harmônicas)",
                                    "Calculadora",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use analogias visuais, como um relógio para ω e uma régua para k, para fixar os conceitos.",
                                  "learningObjective": "Compreender as definições matemáticas e físicas de ω e k como pré-requisitos para velocidade de fase.",
                                  "commonMistakes": "Confundir ω com f (frequência linear) ou k com 1/λ (sem o 2π)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Matematicamente a Velocidade de Fase Física",
                                  "subSteps": [
                                    "Apresente a fórmula v_p = ω / k como a velocidade de fase.",
                                    "Derive intuitivamente: v_p representa quanto a fase da onda avança por unidade de tempo.",
                                    "Mostre que v_p = f λ, relacionando com velocidade de onda clássica.",
                                    "Discuta interpretação física: velocidade com que planos de fase constante se movem.",
                                    "Calcule um exemplo simples: para ω = 2π rad/s e k = π rad/m, v_p = 2 m/s."
                                  ],
                                  "verification": "Derive a fórmula v_p = ω / k a partir da forma geral da onda e calcule para valores dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Software de plotagem como Desmos ou Python (Matplotlib)",
                                    "Video tutorial sobre ondas (opcional)"
                                  ],
                                  "tips": "Visualize plotando uma onda senoidal e marcando planos de fase para ver o movimento.",
                                  "learningObjective": "Dominar a definição exata e derivação da velocidade de fase v_p = ω / k.",
                                  "commonMistakes": "Esquecer o 2π nas definições de ω e k, levando a erros numéricos; confundir com velocidade de grupo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Importância na Propagação de Ondas Monocromáticas",
                                  "subSteps": [
                                    "Descreva ondas monocromáticas como senos puras com ω e k fixos.",
                                    "Explique que v_p determina a velocidade de propagação da fase em meios homogêneos.",
                                    "Discuta implicações: em meios dispersivos, v_p varia com frequência, afetando pulsos.",
                                    "Relacione com conservação de fase: pontos de mesma fase mantêm relação temporal-espacial.",
                                    "Compare com cenários reais onde v_p ≠ velocidade de energia."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que v_p é crucial para ondas monocromáticas, com um contraexemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo ou seção sobre dispersão em ondas",
                                    "Simulador online de ondas (PhET Waves)"
                                  ],
                                  "tips": "Pense em luz laser (monocromática) propagando em fibra ótica para contextualizar.",
                                  "learningObjective": "Entender o papel físico da v_p na propagação e limitações para ondas puras.",
                                  "commonMistakes": "Assumir v_p = velocidade de partícula ou energia; ignorar contexto monocromático."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Compreensão com Exemplos Numéricos",
                                  "subSteps": [
                                    "Calcule v_p para uma onda sonora: f=440 Hz, λ=0.78 m em ar.",
                                    "Analise como mudança em k afeta v_p mantendo ω constante.",
                                    "Discuta dispersão numérica: em esquemas finitos, v_p numérica ≠ física.",
                                    "Crie gráfico de v_p vs. k para ilustração.",
                                    "Resolva problema: dada v_p e ω, encontre k."
                                  ],
                                  "verification": "Resolva 3 problemas numéricos independentes e interprete resultados fisicamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos",
                                    "Gráficos de ondas impressos"
                                  ],
                                  "tips": "Sempre verifique unidades para consistência (m/s).",
                                  "learningObjective": "Aplicar a definição de v_p em cálculos e contextualizar em propagação.",
                                  "commonMistakes": "Erros de unidade (ex: k em 1/m ao invés de rad/m); não distinguir v_p de v_g."
                                }
                              ],
                              "practicalExample": "Considere uma onda eletromagnética monocromática em vácuo com f = 5 GHz (ω = 2π*5e9 rad/s) e λ = 0.06 m (k = 2π/0.06 rad/m). Calcule v_p = ω/k ≈ 3e8 m/s, que coincide com a velocidade da luz c, ilustrando propagação de fase em meios não dispersivos.",
                              "finalVerifications": [
                                "Deriva corretamente v_p = ω/k a partir da forma da onda.",
                                "Explica verbalmente a importância para ondas monocromáticas.",
                                "Calcula v_p com precisão para valores dados, checando unidades.",
                                "Distingue v_p de velocidade de grupo e de partícula.",
                                "Identifica cenários onde v_p é relevante (ex: lasers).",
                                "Relaciona com dispersão numérica em contextos computacionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (ω/k com unidades corretas): 25%.",
                                "Compreensão física da propagação de fase: 25%.",
                                "Capacidade de cálculo e derivação: 20%.",
                                "Explicação da importância para ondas monocromáticas: 15%.",
                                "Identificação de erros comuns e distinções chave: 10%.",
                                "Aplicação em exemplo prático: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas sonoras e eletromagnéticas.",
                                "Engenharia: Simulações numéricas em CFD e métodos de elementos finitos.",
                                "Computação: Análise de dispersão em esquemas de diferenças finitas.",
                                "Matemática Aplicada: Equações diferenciais parciais para ondas."
                              ],
                              "realWorldApplication": "Na telecomunicações ópticas, a velocidade de fase determina a latência de sinal em fibras, essencial para redes 5G; em oceanografia, modela a propagação de ondas de superfície para previsão de tsunamis."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Identificar dispersão física",
                            "description": "Reconhecer que a dispersão ocorre quando a velocidade de fase varia com a frequência, causando separação de componentes de diferentes frequências em uma onda composta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de velocidade de fase em ondas",
                                  "subSteps": [
                                    "Revise a definição de velocidade de fase: v_p = ω / k, onde ω é a frequência angular e k é o número de onda.",
                                    "Estude como a velocidade de fase representa a velocidade de propagação de um plano de onda monocromático.",
                                    "Analise a relação entre frequência (f) e velocidade de fase em meios homogêneos versus heterogêneos.",
                                    "Desenhe um diagrama de uma onda senoidal mostrando cristas e vales propagando.",
                                    "Calcule v_p para uma onda simples usando fórmulas básicas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é velocidade de fase e dê um exemplo numérico simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de análise numérica ou física de ondas",
                                    "Papel e caneta para diagramas",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre relacione v_p à componente individual de frequência para evitar confusão com velocidade de grupo.",
                                  "learningObjective": "Definir e calcular velocidade de fase para ondas monocromáticas.",
                                  "commonMistakes": "Confundir velocidade de fase com velocidade de grupo ou velocidade de propagação total."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a dependência da velocidade de fase com a frequência",
                                  "subSteps": [
                                    "Examine a dispersão linear: v_p(ω) = c / n(ω), onde n(ω) varia com ω.",
                                    "Plote gráficos de v_p versus f para meios dispersivos (ex: vidro para luz).",
                                    "Compare meios não-dispersivos (v_p constante) com dispersivos (v_p varia).",
                                    "Use equações de dispersão como ω = c k / √(1 + (ω/ω_0)^2) para simular.",
                                    "Identifique regiões onde dv_p/dω ≠ 0, indicando dispersão."
                                  ],
                                  "verification": "Crie um gráfico manual ou digital mostrando variação de v_p com f e rotule pontos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem como Python/Matplotlib ou Excel",
                                    "Tabelas de índices de refração",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Use escalas logarítmicas para frequências amplas para visualizar melhor a variação.",
                                  "learningObjective": "Reconhecer matematicamente quando v_p depende de f.",
                                  "commonMistakes": "Assumir que todos os meios têm v_p constante, ignorando dependência material."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decompor ondas compostas em componentes de Fourier",
                                  "subSteps": [
                                    "Aplique transformada de Fourier para representar onda composta como soma de senoides.",
                                    "Mostre que cada componente tem sua própria v_p(f_i).",
                                    "Simule propagação: componentes de alta f viajam mais devagar/rápido que baixa f.",
                                    "Calcule delay temporal entre componentes: Δt = L (1/v_p(f1) - 1/v_p(f2)).",
                                    "Visualize o alargamento do pulso devido à separação."
                                  ],
                                  "verification": "Decomponha uma onda quadrada em Fourier e calcule delays para duas frequências.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python ou MATLAB para FFT",
                                    "Exemplos de sinais de referência",
                                    "Folha de cálculo para cálculos manuais"
                                  ],
                                  "tips": "Comece com poucas harmônicas (3-5) para simplificar a visualização.",
                                  "learningObjective": "Entender como ondas compostas se separam devido a v_p(f).",
                                  "commonMistakes": "Ignorar que dispersão afeta apenas a forma da onda, não a energia total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar dispersão física em cenários reais",
                                  "subSteps": [
                                    "Compare propagação em vácuo (sem dispersão) vs. fibra ótica (com dispersão).",
                                    "Analise espectro de um pulso antes/depois da propagação.",
                                    "Defina critérios: alargamento do pulso, chirp de frequência.",
                                    "Diferencie dispersão física de numérica (discretização).",
                                    "Teste com simulação: propague pulso e observe separação."
                                  ],
                                  "verification": "Descreva um exemplo onde dispersão física é observada e explique o mecanismo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador de ondas (ex: PhET ou código Python)",
                                    "Vídeos de experimentos ópticos",
                                    "Artigos sobre dispersão em fibras"
                                  ],
                                  "tips": "Foque em evidências visuais como espalhamento de cores em prisma.",
                                  "learningObjective": "Diagnosticar dispersão física pela variação v_p(f) em ondas compostas.",
                                  "commonMistakes": "Confundir dispersão com absorção ou atenuação."
                                }
                              ],
                              "practicalExample": "Em uma fibra óptica, um pulso de luz Gaussian curto (contendo frequências de 193 THz a 200 THz) propaga 10 km. Componentes de alta frequência viajam a v_p = 0.68c, baixa a 0.70c, causando alargamento de 10 ps para 100 ps, separando o sinal e limitando taxa de dados.",
                              "finalVerifications": [
                                "Defina dispersão física usando v_p(f).",
                                "Explique por que ondas compostas se dispersam.",
                                "Diferencie dispersão de velocidade de grupo.",
                                "Identifique em gráfico: pulso alargado vs. original.",
                                "Calcule delay simples entre duas frequências.",
                                "Descreva exemplo real sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de v_p e sua dependência em f (30%).",
                                "Compreensão da decomposição Fourier e impactos (25%).",
                                "Capacidade de análise gráfica e cálculos (20%).",
                                "Identificação correta em exemplos práticos (15%).",
                                "Clareza na explicação de mecanismos físicos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Óptica e mecânica quântica de ondas.",
                                "Engenharia de Telecomunicações: Design de fibras e compensadores de dispersão.",
                                "Ciência da Computação: Simulações numéricas de PDEs para ondas.",
                                "Química: Dispersão em meios moleculares e espectroscopia."
                              ],
                              "realWorldApplication": "Nas telecomunicações por fibra óptica, identificar dispersão física permite projetar compensadores (ex: G.655 fibras) para manter integridade de sinais em redes 5G/6G, evitando perda de dados em longas distâncias."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Relacionar com equações hiperbólicas",
                            "description": "Associar o conceito de velocidade de fase à equação da onda ou de advecção linear, destacando a não-dispersão em meios homogêneos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Velocidade de Fase e Equações Hiperbólicas",
                                  "subSteps": [
                                    "Defina velocidade de fase como ω/k, onde ω é frequência angular e k é número de onda.",
                                    "Explique equações hiperbólicas parciais diferenciais (PDHs) como aquelas com velocidades de propagação finitas.",
                                    "Identifique exemplos clássicos: equação da onda ∂²u/∂t² = c² ∂²u/∂x² e equação de advecção ∂u/∂t + c ∂u/∂x = 0.",
                                    "Discuta meios homogêneos como aqueles com coeficientes constantes.",
                                    "Esboce soluções planares e= e^{i(kx - ωt)} para ondas."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições e exemplos, confirmando independência de k na velocidade de fase.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), caderno, calculadora.",
                                  "tips": "Use analogias visuais como cordas vibrando para ondas.",
                                  "learningObjective": "Compreender os pilares matemáticos da velocidade de fase e PDHs hiperbólicas.",
                                  "commonMistakes": "Confundir velocidade de fase com velocidade de grupo; lembre-se que fase é para planos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Equação da Onda e Sua Velocidade de Fase Constante",
                                  "subSteps": [
                                    "Derive a relação dispersiva ω = c k para a equação da onda.",
                                    "Mostre que c = velocidade de fase é constante, independente de k.",
                                    "Simule numericamente uma onda gaussiana propagando sem distorção em meio homogêneo.",
                                    "Calcule numericamente para diferentes k e verifique constância de c.",
                                    "Discuta implicações: ausência de dispersão para pacotes de ondas."
                                  ],
                                  "verification": "Plote dispersão ω vs k e confirme linearidade perfeita.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (SciPy), exemplos de código para FT de ondas.",
                                  "tips": "Comece com solução analítica exata antes de numérica.",
                                  "learningObjective": "Associar velocidade de fase constante à não-dispersão na equação da onda.",
                                  "commonMistakes": "Ignorar condições de contorno; use domínio periódico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Equação de Advecção Linear e Não-Dispersão",
                                  "subSteps": [
                                    "Apresente a equação ∂u/∂t + c ∂u/∂x = 0 e sua solução u(x,t) = f(x - c t).",
                                    "Derive ω = c k, confirmando velocidade de fase c constante.",
                                    "Compare com equação da onda: ambas hiperbólicas com propagação não-dispersiva.",
                                    "Implemente simulação numérica (ex: Lax-Friedrichs) e observe preservação de forma.",
                                    "Analise em meios homogêneos (c constante)."
                                  ],
                                  "verification": "Execute simulação e meça velocidade efetiva para múltiplas frequências.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/Matplotlib, notebook Jupyter.",
                                  "tips": "Use upwind scheme para estabilidade em advecção.",
                                  "learningObjective": "Relacionar advecção à velocidade de fase constante e não-dispersão.",
                                  "commonMistakes": "Usar esquemas centrados sem estabilização, causando oscilações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Relações e Destacar Não-Dispersão em Meios Homogêneos",
                                  "subSteps": [
                                    "Compare curvas de dispersão: linear ω = c k para ambas equações.",
                                    "Explique por que meios homogêneos evitam dispersão (c independente de x).",
                                    "Discuta contrastes com meios heterogêneos ou esquemas numéricos dispersivos.",
                                    "Crie tabela resumindo: equação, ω(k), dispersão (não).",
                                    "Aplique a um problema: propagação de pulso acústico."
                                  ],
                                  "verification": "Elabore um relatório de 1 página com gráficos e tabela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, software de plotagem.",
                                  "tips": "Foco em linearidade da relação ω-k como chave para não-dispersão.",
                                  "learningObjective": "Integrar conceitos, destacando ausência de dispersão hiperbólica.",
                                  "commonMistakes": "Generalizar para não-lineares; foque em lineares homogêneas."
                                }
                              ],
                              "practicalExample": "Simule a propagação de uma onda gaussiana u(x,0) = exp(-x²/2) na equação da onda com c=1 em [0,10]x[0,5], usando FT para mostrar que o pacote se move sem espalhamento, velocidade de fase constante confirmada por picos de fase.",
                              "finalVerifications": [
                                "Derivar corretamente ω = c k para ambas equações.",
                                "Simulações numéricas mostram propagação sem distorção de forma.",
                                "Tabela comparativa completa e precisa.",
                                "Explicação clara de não-dispersão em meios homogêneos.",
                                "Identificação de pelo menos 3 implicações numéricas.",
                                "Gráficos de dispersão linear confirmados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (80%+ correto).",
                                "Qualidade das simulações numéricas (sem artefatos dispersivos).",
                                "Profundidade na distinção de meios homogêneos.",
                                "Clareza na síntese de relações velocidade de fase-equação.",
                                "Criatividade no exemplo prático.",
                                "Completude da tabela e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas acústicas e eletromagnéticas.",
                                "Engenharia Computacional: Esquemas numéricos para PDHs hiperbólicas.",
                                "Geofísica: Modelagem de ondas sísmicas em meios uniformes.",
                                "Processamento de Sinais: Análise de Fourier em sinais não-dispersivos."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para previsão de terremotos, onde equações hiperbólicas modelam ondas P em crosta homogênea, garantindo precisão na velocidade de fase para alertas rápidos sem distorções artificiais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Dispersão Numérica em Métodos de Diferenças Finitas",
                        "description": "Definição de dispersão numérica como a variação artificial da velocidade de propagação de ondas numéricas de diferentes frequências em esquemas de diferenças finitas para equações hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Definir dispersão numérica",
                            "description": "Descrever a dispersão numérica como o erro introduzido quando a velocidade de fase numérica c_num = (ω_num / k) difere da velocidade física c, variando com o número de onda k em esquemas numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos básicos de velocidade de fase física",
                                  "subSteps": [
                                    "Revise a definição de onda física: uma perturbação que propaga com velocidade constante c.",
                                    "Defina velocidade de fase física c = ω / k, onde ω é a frequência angular e k o número de onda.",
                                    "Estude exemplos de ondas em meios físicos, como ondas sonoras ou eletromagnéticas.",
                                    "Compare propagação exata em meios contínuos versus discretos.",
                                    "Identifique por que a velocidade de fase é crucial para modelagem precisa."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula c = ω / k e dê um exemplo físico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Física de Ondas (cap. 1)",
                                    "Vídeo introdutório sobre ondas (YouTube: Khan Academy)"
                                  ],
                                  "tips": "Visualize ondas com animações para fixar o conceito.",
                                  "learningObjective": "Compreender a velocidade de fase em contextos físicos contínuos.",
                                  "commonMistakes": [
                                    "Confundir velocidade de fase com velocidade de grupo",
                                    "Ignorar a relação inversa entre ω e k"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a velocidade de fase numérica em esquemas discretos",
                                  "subSteps": [
                                    "Analise esquemas numéricos de diferenças finitas para equações de onda.",
                                    "Defina ω_num como a frequência numérica obtida da amplificação do esquema.",
                                    "Estabeleça c_num = ω_num / k como a velocidade de fase numérica.",
                                    "Compare c_num com c física usando o símbolo de dispersão.",
                                    "Derive simbolicamente para um esquema simples de segunda ordem."
                                  ],
                                  "verification": "Calcule c_num para um k específico em um esquema dado e compare com c.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e calculadora",
                                    "Software MATLAB ou Python para plotar dispersão"
                                  ],
                                  "tips": "Use aproximações de Taylor para entender a origem de ω_num.",
                                  "learningObjective": "Definir e calcular a velocidade de fase numérica.",
                                  "commonMistakes": [
                                    "Esquecer que k é discreto em grades numéricas",
                                    "Confundir ω_num com ω física"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o erro de dispersão numérica",
                                  "subSteps": [
                                    "Descreva dispersão numérica como a discrepância |c_num - c| > 0.",
                                    "Explique que isso causa ondas de diferentes k a propagarem em velocidades distintas.",
                                    "Ilustre com gráfico de c_num(k) vs c (dispersão não física).",
                                    "Discuta causas: truncamento em diferenças finitas.",
                                    "Classifique esquemas dispersivos vs não-dispersivos."
                                  ],
                                  "verification": "Escreva uma definição precisa em 2-3 frases e identifique um esquema dispersivo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre análise de Von Neumann",
                                    "Gráficos de dispersão de livros de CFD"
                                  ],
                                  "tips": "Foquem em kΔx pequeno (ondas longas) vs grande (ondas curtas).",
                                  "learningObjective": "Reconhecer dispersão como erro de propagação diferencial.",
                                  "commonMistakes": [
                                    "Pensar que dispersão é só dissipação",
                                    "Ignorar dependência com h (passo espacial)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a variação da dispersão com o número de onda k",
                                  "subSteps": [
                                    "Analise como c_num varia com k em esquemas típicos (ex: Leapfrog).",
                                    "Plote curvas de dispersão para diferentes ordens de precisão.",
                                    "Discuta regimes: baixa k (precisa), alta k (dispersiva).",
                                    "Calcule o erro relativo (c_num - c)/c para vários k.",
                                    "Conclua implicações para resolução numérica."
                                  ],
                                  "verification": "Gere um gráfico de c_num(k) e destaque regiões de alta dispersão.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Notebook Jupyter pronto para dispersão"
                                  ],
                                  "tips": "Normalize k por π/Δx para visualizar o espectro.",
                                  "learningObjective": "Demonstrar dependência da dispersão com k.",
                                  "commonMistakes": [
                                    "Assumir dispersão uniforme para todos k",
                                    "Não normalizar k adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um esquema de diferenças finitas central de segunda ordem para a equação de onda ∂²u/∂t² = c² ∂²u/∂x², com Δt e Δx, calcule ω_num = 2/Δt * arcsin( (c Δt / Δx) sin(k Δx / 2) ). Então c_num = ω_num / k. Para k Δx = π/2, mostre que c_num < c, causando atraso em ondas curtas.",
                              "finalVerifications": [
                                "Defina corretamente dispersão numérica usando c_num = ω_num / k.",
                                "Explique a diferença entre c física e c_num.",
                                "Identifique que dispersão varia com k.",
                                "Dê um exemplo de esquema numérico dispersivo.",
                                "Descreva o impacto em simulações de ondas.",
                                "Calcule c_num para um k dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de dispersão.",
                                "Correta derivação ou cálculo de c_num.",
                                "Compreensão da dependência com k e h.",
                                "Identificação de erros comuns em esquemas.",
                                "Capacidade de ilustrar com gráfico ou exemplo.",
                                "Clareza na explicação verbal/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de propagação de ondas e estabilidade.",
                                "Engenharia Computacional: Simulações CFD e acústica numérica.",
                                "Processamento de Sinais: Análise espectral e filtros digitais.",
                                "Matemática Aplicada: Análise de estabilidade de Von Neumann."
                              ],
                              "realWorldApplication": "Nas simulações numéricas de ondas sísmicas em prospecção de petróleo ou previsão de tsunamis, onde a dispersão numérica distorce ondas de alta frequência, levando a erros em modelos geofísicos; esquemas de alta ordem reduzem isso para precisão em reservatórios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Analisar via análise de von Neumann",
                            "description": "Explicar como a análise de von Neumann, usando a função de amplificação g(θ) com θ = k Δx, revela a dispersão através da derivada imaginária da fase numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Análise de von Neumann",
                                  "subSteps": [
                                    "Revise a suposição básica: solução numérica assumida como u_j^n = g^n e^{i k j Δx}, onde k é o número de onda físico.",
                                    "Defina o parâmetro adimensional θ = k Δx, que captura o comportamento numérico dos modos.",
                                    "Explique o significado físico: modos de alta frequência (θ ≈ π) representam oscilações em escalas de grade.",
                                    "Discuta como inserir essa forma no esquema de diferenças finitas para obter uma equação algébrica para g(θ).",
                                    "Verifique a condição de consistência para θ → 0, onde g(θ) deve aproximar a solução exata."
                                  ],
                                  "verification": "Escreva a forma assumida e defina θ corretamente em um exemplo simples de equação de advecção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de análise numérica",
                                    "Papel e lápis para derivações",
                                    "Referência: Livro de LeVeque 'Finite Difference Methods for ODEs and PDEs'"
                                  ],
                                  "tips": "Sempre reduza θ ao intervalo [0, π] devido à periodicidade e aliasing numérico.",
                                  "learningObjective": "Dominar a formulação básica da análise de von Neumann e seu propósito na detecção de dispersão e dissipação.",
                                  "commonMistakes": [
                                    "Confundir o número de onda físico k com θ = k Δx.",
                                    "Esquecer o fator temporal g^n na suposição de von Neumann."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Função de Amplificação g(θ)",
                                  "subSteps": [
                                    "Selecione um esquema de diferenças finitas, como o upwind para u_t + a u_x = 0: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), com λ = a Δt / Δx.",
                                    "Substitua u_j^n = g^n e^{i θ j} na equação discreta.",
                                    "Simplifique para obter g(θ) = 1 - λ (1 - e^{-i θ}).",
                                    "Generalize para esquemas centrados ou multi-níveis, computando g(θ) simbolicamente.",
                                    "Plote |g(θ)| para verificar estabilidade (deve ser ≤ 1 para todo θ)."
                                  ],
                                  "verification": "Derive e plote |g(θ)| para o esquema upwind com λ=0.5, confirmando estabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software como Python com NumPy/Matplotlib ou MATLAB",
                                    "SymPy para álgebra simbólica"
                                  ],
                                  "tips": "Use a identidade e^{i θ} = cos θ + i sin θ para simplificar expressões trigonométricas.",
                                  "learningObjective": "Capacitar a derivação explícita de g(θ) para esquemas comuns de diferenças finitas.",
                                  "commonMistakes": [
                                    "Erro no fator de shift espacial: e^{i θ (j+1)} = e^{i θ j} e^{i θ}.",
                                    "Ignorar o tempo Δt na definição de λ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e Analisar a Fase Numérica φ(θ)",
                                  "subSteps": [
                                    "Expresse g(θ) em forma polar: g(θ) = |g(θ)| e^{i φ(θ)}, onde φ(θ) = arg(g(θ)).",
                                    "Calcule φ(θ) = atan2(Im(g), Re(g)) para o exemplo upwind.",
                                    "Compare com a fase exata φ_exata(θ) = - λ θ para advecção unitária.",
                                    "Plote φ_num(θ) vs φ_exata(θ) para θ ∈ [0, π], observando desvios.",
                                    "Discuta como desvios na fase indicam erros de propagação de fase."
                                  ],
                                  "verification": "Gere plots de φ(θ) e φ_exata(θ), identificando regiões de desvio significativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotting",
                                    "Exemplos de esquemas de livros de análise numérica"
                                  ],
                                  "tips": "Use unwrap(φ) em software para lidar com descontinuidades de 2π na fase.",
                                  "learningObjective": "Interpretar a fase numérica como medida de erro de propagação em esquemas numéricos.",
                                  "commonMistakes": [
                                    "Não desembrulhar a fase, causando jumps artificiais nos plots.",
                                    "Confundir arg(g) com log(g), ignorando a parte real."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Revelar Dispersão pela Derivada Imaginária da Fase Numérica",
                                  "subSteps": [
                                    "Defina a derivada da fase: dφ/dθ ≈ Δφ/Δθ numericamente ou analiticamente via g'(θ)/g(θ).",
                                    "Note que dφ/dθ = Im( (1/i) d log(g)/dθ ) = Im( -i g'/g ), capturando a 'derivada imaginária'.",
                                    "Compare dφ_num/dθ com dφ_exata/dθ = -λ, onde diferenças indicam dispersão (velocidades de fase diferentes por modo).",
                                    "Quantifique dispersão: erro relativo |dφ_num/dθ - dφ_exata/dθ| / |dφ_exata/dθ|.",
                                    "Interprete: dispersão causa trailing ou leading de pacotes de ondas em simulações."
                                  ],
                                  "verification": "Compute e plote dφ/dθ para o esquema, destacando regiões dispersivas (alta frequência).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python para diferenciação numérica",
                                    "Referências sobre análise de dispersão em PDEs numéricas"
                                  ],
                                  "tips": "Para derivada analítica, use sympy.diff; numericamente, use diferenças centrais com Δθ pequeno.",
                                  "learningObjective": "Usar a derivada da fase para diagnosticar e quantificar dispersão numérica.",
                                  "commonMistakes": [
                                    "Tratar φ como complexa; ela é real, mas sua derivada relaciona-se à parte imaginária de log(g).",
                                    "Avaliar em θ=π sem cuidado com singularidades."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Wendroff em u_t + u_x = 0 (λ=1): g(θ) = 1 - i sinθ - (sin²(θ/2)) (1 - cosθ). Compute φ(θ) = arg(g), plote dφ/dθ vs -1, observe dispersão positiva em baixas frequências e negativa em altas, simulando ondas que se espalham artificialmente em CFD.",
                              "finalVerifications": [
                                "Derivação correta de g(θ) para esquemas upwind e centrados.",
                                "Plots precisos de φ(θ) e dφ/dθ com comparações exatas.",
                                "Explicação verbal de como Im(derivada da fase) revela dispersão.",
                                "Identificação de esquemas dispersivos vs não-dispersivos (ex: Beam-Warming).",
                                "Aplicação a um plot real de solução numérica mostrando phase error.",
                                "Cálculo quantitativo de erro de dispersão médio sobre θ."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g(θ) e φ(θ) (40%).",
                                "Qualidade e interpretação correta de plots de fase e derivada (30%).",
                                "Compreensão conceitual de dispersão via 'derivada imaginária' (15%).",
                                "Capacidade de generalizar para novos esquemas (10%).",
                                "Clareza na documentação e exemplos práticos (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Relações de dispersão em equações de onda e mecânica quântica.",
                                "Engenharia Computacional: Otimização de solvers em CFD e simulações sísmicas.",
                                "Ciência da Computação: Análise de complexidade em algoritmos numéricos paralelos.",
                                "Matemática Pura: Teoria de funções analíticas e expansões em séries de Fourier."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos de oceanos), dispersão numérica distorce a propagação de ondas de Rossby, afetando previsões de El Niño; análise de von Neumann guia o design de esquemas de alta ordem com baixa dispersão para precisão em previsões de longo prazo."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Comparar com dissipação",
                            "description": "Diferenciar dispersão (erro de fase) de dissipação (amortecimento artificial de altas frequências), ambos erros de truncamento em métodos para PDEs hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de dispersão e dissipação numéricas",
                                  "subSteps": [
                                    "Ler a definição de dispersão numérica como erro de fase em esquemas de diferenças finitas para PDEs hiperbólicas.",
                                    "Estudar dissipação numérica como amortecimento artificial de componentes de altas frequências.",
                                    "Identificar que ambos são erros de truncamento de ordem superior.",
                                    "Consultar símbolos matemáticos: ξ (dispersão) e amortecimento numérico.",
                                    "Anotar fórmulas básicas do símbolo de amplificação."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras diferenciando os conceitos iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula de Análise Numérica II",
                                    "Livro de LeVeque 'Finite Difference Methods for ODEs and PDEs'",
                                    "Artigo sobre análise de von Neumann"
                                  ],
                                  "tips": "Use diagramas de ondas para visualizar a distorção de fase vs. decaimento de amplitude.",
                                  "learningObjective": "Compreender as definições conceituais básicas de dispersão e dissipação.",
                                  "commonMistakes": [
                                    "Confundir dispersão com difusão física",
                                    "Ignorar o contexto de PDEs hiperbólicas",
                                    "Misturar erro de fase com erro de grupo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar erros de fase (dispersão) em esquemas numéricos",
                                  "subSteps": [
                                    "Calcular o símbolo de dispersão ξ para esquemas como Lax-Friedrichs e Lax-Wendroff.",
                                    "Plotar curvas de dispersão ξ(kΔx) vs. kΔx para diferentes ordens.",
                                    "Interpretar quando ξ > velocidade física (dispersão leading) ou ξ < (dispersão trailing).",
                                    "Comparar com a dispersão exata (ξ = c para onda advectiva).",
                                    "Simular numericamente uma pulso gaussiano para observar oscilações."
                                  ],
                                  "verification": "Gerar um gráfico de dispersão e explicar uma anomalia observada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy/SciPy/Matplotlib)",
                                    "Código template para análise von Neumann",
                                    "Tabela de esquemas comuns"
                                  ],
                                  "tips": "Comece com esquemas de 1ª ordem para contrastar com 2ª ordem.",
                                  "learningObjective": "Dominar a caracterização quantitativa da dispersão via símbolo de fase.",
                                  "commonMistakes": [
                                    "Esquecer normalização por Δt/Δx",
                                    "Confundir velocidade de fase numérica com exata",
                                    "Não variar o número de onda k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar amortecimento artificial (dissipação) em esquemas numéricos",
                                  "subSteps": [
                                    "Estudar o fator de amplificação |g(k)| < 1 para altas frequências (kΔx ≈ π).",
                                    "Comparar esquemas dissipativos (upwind) vs. não-dissipativos (Leapfrog).",
                                    "Calcular taxas de dissipação para diferentes ordens de truncamento.",
                                    "Visualizar decaimento de amplitude em simulações de ondas.",
                                    "Relacionar com viscosidade numérica artificial."
                                  ],
                                  "verification": "Computar |g| para kΔx = π/2 em dois esquemas e discutir implicações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmo software do passo anterior",
                                    "Referência: Gustafsson et al. 'Time-Dependent PDEs'",
                                    "Exemplos de código para fator de amplificação"
                                  ],
                                  "tips": "Foquem em modos de Nyquist (altas frequências) onde dissipação é mais evidente.",
                                  "learningObjective": "Quantificar e interpretar a dissipação numérica em termos de estabilidade e precisão.",
                                  "commonMistakes": [
                                    "Confundir dissipação com instabilidade (|g| > 1)",
                                    "Ignorar dependência em Δt/Δx",
                                    "Achar que dissipação é sempre ruim"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e contrastar dispersão vs. dissipação em contextos práticos",
                                  "subSteps": [
                                    "Criar tabela comparativa: causas, efeitos visuais, esquemas afetados, remédios (filtros, esquemas de alta ordem).",
                                    "Simular PDE de advecção com esquemas dispersivos e dissipativos, comparando soluções.",
                                    "Discutir trade-offs: dispersão preserva energia mas oscila; dissipação suaviza mas amortece.",
                                    "Analisar erros de truncamento comuns em ambos.",
                                    "Propor quando priorizar controle de um vs. outro."
                                  ],
                                  "verification": "Apresentar uma tabela e gráfico comparativos explicando diferenças chave.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Códigos integrados dos passos anteriores",
                                    "Papel ou ferramenta de tabela (Excel/Google Sheets)",
                                    "Exemplos de soluções numéricas instáveis"
                                  ],
                                  "tips": "Use animações de simulações para intuição visual.",
                                  "learningObjective": "Diferenciar claramente dispersão de dissipação e suas implicações em métodos para PDEs hiperbólicas.",
                                  "commonMistakes": [
                                    "Tratar ambos como 'erros genéricos'",
                                    "Não considerar o espectro de frequências",
                                    "Omitir contexto hiperbólico vs. parabólico"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com esquema upwind (dissipativo: observe suavização de picos) vs. Lax-Wendroff (dispersivo: observe oscilações atrás da onda). Compare soluções em t=1 com Δx=0.01, plotando u numérica vs. exata para destacar erro de fase (oscilações) vs. amortecimento (perda de amplitude).",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre erro de fase e amortecimento artificial.",
                                "Identifique dispersão vs. dissipação em um gráfico de solução numérica fornecido.",
                                "Calcule ξ e |g| para um esquema dado e classifique seus erros dominantes.",
                                "Proponha um filtro para mitigar dispersão sem adicionar dissipação excessiva.",
                                "Discuta por que ambos surgem de truncamento em PDEs hiperbólicas.",
                                "Compare impactos em simulações de ondas acústicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual (erro de fase vs. altas frequências).",
                                "Correta aplicação de análise von Neumann (símbolos ξ e g).",
                                "Qualidade de visualizações e simulações comparativas.",
                                "Profundidade na discussão de trade-offs e remédios.",
                                "Clareza na tabela comparativa e exemplos práticos.",
                                "Compreensão contextual em métodos para PDEs hiperbólicas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e análise de Fourier em mecânica ondulatória.",
                                "Computação: Implementação eficiente de simulações numéricas em Python/MATLAB.",
                                "Engenharia: Modelagem em dinâmica de fluidos computacional (CFD) e controle de erros.",
                                "Estatística: Análise de erros de truncamento e convergência em métodos numéricos."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para prospecção de petróleo, controlar dispersão evita artefatos oscilatórios falsos, enquanto dissipação controlada previne ruído de altas frequências; em CFD aeroespacial, equilibra precisão de frentes de choque sem amortecimento excessivo de turbulência."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.4",
                            "name": "Exemplificar em esquema explícito",
                            "description": "Calcular a velocidade de fase numérica para o esquema de Lax-Friedrichs ou upwind para a equação de advecção, identificando o erro de dispersão para ondas de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de advecção e os esquemas Lax-Friedrichs e upwind",
                                  "subSteps": [
                                    "Escrever a equação de advecção linear: ∂u/∂t + a ∂u/∂x = 0, com a > 0.",
                                    "Definir o esquema upwind: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), onde λ = a Δt / Δx.",
                                    "Definir o esquema Lax-Friedrichs: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (λ/2) (u_{j+1}^n - u_{j-1}^n).",
                                    "Explicar a análise von Neumann: assumir solução u_j^n = g^n e^{i k j Δx}, com θ = k Δx.",
                                    "Identificar o fator de amplificação g(θ) para cada esquema."
                                  ],
                                  "verification": "Esquemas e fator g(θ) anotados corretamente em um caderno ou software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Papel e caneta",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Use notação consistente para Δt, Δx e λ em todos os passos.",
                                  "learningObjective": "Compreender a base teórica dos esquemas e preparar para análise de dispersão.",
                                  "commonMistakes": [
                                    "Confundir upwind com Lax-Friedrichs",
                                    "Esquecer a condição CFL: 0 < λ ≤ 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o fator de amplificação e relação de dispersão para o esquema upwind",
                                  "subSteps": [
                                    "Substituir a forma von Neumann no esquema upwind para obter g(θ) = 1 - λ (1 - e^{-iθ}).",
                                    "Simplificar g(θ) = 1 - λ + λ e^{-iθ}.",
                                    "Calcular |g(θ)| e arg(g(θ)) para verificar estabilidade e fase.",
                                    "Derivar a velocidade de fase numérica: c_num / a = [arg(g(θ)) / Δt] / (k), com k = θ / Δx.",
                                    "Expressar c_num(θ) ≈ a [sin(θ/2)/(θ/2)] para aproximação."
                                  ],
                                  "verification": "g(θ) e c_num(θ) calculados e plotados para θ de 0 a π.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem (Matlab/Python/Mathematica)",
                                    "Folha de derivadas"
                                  ],
                                  "tips": "Use identidades trigonométricas: 1 - e^{-iθ} = 2i sin(θ/2) e^{-iθ/2}.",
                                  "learningObjective": "Calcular precisamente a dispersão numérica no upwind.",
                                  "commonMistakes": [
                                    "Erro no sinal do expoente em e^{-iθ}",
                                    "Ignorar normalização por Δt"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o fator de amplificação e relação de dispersão para Lax-Friedrichs",
                                  "subSteps": [
                                    "Substituir no Lax-Friedrichs: g(θ) = cos(θ) - i λ sin(θ).",
                                    "Verificar |g(θ)|² = cos²(θ) + λ² sin²(θ) ≤ 1 sob CFL.",
                                    "Calcular arg(g(θ)) = -atan[λ sin(θ) / cos(θ)].",
                                    "Obter velocidade de fase numérica: c_num / a = arg(g(θ)) / (θ λ / a Δt), ajustando unidades.",
                                    "Comparar expressões de c_num para upwind vs. Lax-Friedrichs."
                                  ],
                                  "verification": "g(θ) derivado e c_num(θ) coincidem com referências padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referência: Tannehill 'Computational Fluid Mechanics'",
                                    "Python para verificação numérica"
                                  ],
                                  "tips": "Plotar Re(g) e Im(g) para visualizar dissipação.",
                                  "learningObjective": "Dominar análise para esquemas dissipativos como Lax-Friedrichs.",
                                  "commonMistakes": [
                                    "Confundir cos(θ) com (e^{iθ} + e^{-iθ})/2 incorretamente",
                                    "Esquecer fator i na fase"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular velocidades de fase e identificar erro de dispersão em altas frequências",
                                  "subSteps": [
                                    "Comparar c_num(θ) com c_exata = a para θ baixo (baixas freq.) e θ → π (altas freq.).",
                                    "Para upwind: mostrar c_num / a → 0 quando θ → π (dispersão de fase lag).",
                                    "Para Lax-Friedrichs: c_num / a ≈ 0 para θ=π devido a forte dissipação.",
                                    "Quantificar erro: |c_num - a| / a, plotar para θ ∈ [0, π].",
                                    "Concluir: ondas de alta freq. viajam mais devagar ou são atenuadas, causando dispersão numérica."
                                  ],
                                  "verification": "Gráficos de c_num/a vs. θ mostram erro crescente em altas freq., com legenda.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/Matlab script para plots",
                                    "Artigo sobre análise von Neumann"
                                  ],
                                  "tips": "Use λ=0.5 fixo para comparações justas.",
                                  "learningObjective": "Identificar e quantificar erro de dispersão específico para altas frequências.",
                                  "commonMistakes": [
                                    "Normalizar incorretamente c_num por a",
                                    "Ignorar que erro é O(Δx) leading order"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar resultados e verificar com simulação numérica simples",
                                  "subSteps": [
                                    "Resumir: upwind tem dispersão lag, Lax-Friedrichs tem mais dissipação.",
                                    "Implementar simulação 1D em Python para u_t + u_x=0 com pulso inicial.",
                                    "Rodar upwind e Lax-Friedrichs, observar distorção de fase em altas freq.",
                                    "Comparar fase numérica observada com analítica.",
                                    "Documentar conclusões em relatório curto."
                                  ],
                                  "verification": "Simulação reproduz erro de dispersão previsto analiticamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com numpy/matplotlib",
                                    "Código template de advecção"
                                  ],
                                  "tips": "Use N=100 pontos, T=1, λ=0.5; filtre altas freq. no inicial.",
                                  "learningObjective": "Validar teoria com prática computacional.",
                                  "commonMistakes": [
                                    "Instabilidade por λ>1",
                                    "Resolução insuficiente para altas freq."
                                  ]
                                }
                              ],
                              "practicalExample": "Para λ=0.5 e θ=π/2 no upwind: g = 1 - 0.5(1 - i) ≈ 0.75 - 0.5i, arg(g) ≈ -0.588 rad. c_num ≈ a * (arg(g)/ (θ * λ / Δt * Δt)) ajustado = 0.75a (lag de fase). Para θ=π, c_num→0, ondas estacionárias numéricas.",
                              "finalVerifications": [
                                "Fatores g(θ) corretos para ambos esquemas.",
                                "Velocidades c_num(θ) plotadas e comparadas com a.",
                                "Erro de dispersão identificado como lag para altas θ.",
                                "Simulação numérica confirma análise teórica.",
                                "Relatório resume diferenças upwind vs. Lax-Friedrichs.",
                                "Condições de estabilidade verificadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações de g(θ) (100% fórmulas corretas).",
                                "Qualidade dos plots de c_num/a vs. θ (legendas, escalas).",
                                "Identificação correta do erro em altas freq. (θ>π/2).",
                                "Validação via simulação (match qualitativo/quantitativo).",
                                "Clareza no relatório (equações, conclusões).",
                                "Uso correto de CFL e normalizações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em meios dispersivos (acústica, óptica).",
                                "Computação: Implementação eficiente de PDEs em CFD.",
                                "Engenharia: Modelagem de fluxos convectivos (aerodinâmica).",
                                "Estatística: Análise de erro numérico em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou dinâmica de fluidos computacional (CFD), esquemas como upwind são usados para advecção de umidade; entender dispersão evita distorções em frentes de onda de alta frequência, melhorando precisão em modelos climáticos ou simulações de tráfego."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Análise de Dissipação via Função de Amplificação",
                    "description": "Uso da função de amplificação para quantificar e analisar o comportamento dissipativo em esquemas de diferenças finitas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Função de Amplificação em Esquemas de Diferenças Finitas",
                        "description": "Definição e cálculo da função de amplificação G(ξ) utilizando a análise de von Neumann para avaliar o comportamento de esquemas numéricos em problemas de evolução temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Realizar análise de von Neumann para esquemas lineares",
                            "description": "Aplicar a análise de von Neumann assumindo soluções de Fourier planas e derivando a função de amplificação G(ξ) = amplificação por passo temporal para um dado número de onda ξ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o esquema linear de diferenças finitas",
                                  "subSteps": [
                                    "Identifique a equação diferencial parcial (PDE) linear subjacente, como a equação de transporte ou de calor.",
                                    "Escreva o esquema de diferenças finitas em forma matricial ou soma: ∑ c_k u^{n}_{j+k} = u^{n+1}_j.",
                                    "Defina os parâmetros: passos de tempo Δt, espaço Δx, e coeficientes c_k.",
                                    "Verifique linearidade: confirme que o esquema é uma convolução linear.",
                                    "Normalize os coeficientes se necessário para análise adimensional."
                                  ],
                                  "verification": "Esquema escrito corretamente em notação padrão e verificado por substituição simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque 'Finite Difference Methods'), papel e caneta, software simbólico como SymPy"
                                  ],
                                  "tips": "Use notação consistente com índices temporais n e espaciais j.",
                                  "learningObjective": "Compreender a representação discreta linear de PDEs para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir índices de tempo e espaço",
                                    "Omitir termos de contorno periódicos",
                                    "Não normalizar coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir solução de Fourier plana",
                                  "subSteps": [
                                    "Assuma condições periódicas e solução modal: u^n_j = g^n e^{i ξ j Δx}, onde ξ é o número de onda.",
                                    "Substitua na equação do esquema: derive a relação de recorrência para g^{n+1}/g^n.",
                                    "Identifique g como função de ξ: g(ξ) = G(ξ), a função de amplificação.",
                                    "Explique o significado físico: ξ = 2π/λ, com λ comprimento de onda.",
                                    "Verifique para ξ=0 (modo constante): G(0) deve ser 1 para consistência."
                                  ],
                                  "verification": "Relação g^{n+1} = G(ξ) g^n obtida corretamente por substituição.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de exercícios, calculadora simbólica ou MATLAB/SymPy para Fourier",
                                    "Exemplos de esquemas padrão"
                                  ],
                                  "tips": "Use exp(i θ) com θ = ξ Δx para simplificar cálculos trigonométricos.",
                                  "learningObjective": "Dominar a ansatz de Fourier para decomposição modal em métodos numéricos.",
                                  "commonMistakes": [
                                    "Esquecer o fator i na exponencial",
                                    "Não usar condições periódicas",
                                    "Confundir ξ com k = ξ/Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar explicitamente a função de amplificação G(ξ)",
                                  "subSteps": [
                                    "Substitua u^n_j = g^n e^{i ξ j Δx} em cada termo do esquema.",
                                    "Some os termos: G(ξ) = 1 / ∑ c_k e^{-i ξ k Δx} (para forma explícita).",
                                    "Simplifique usando identidades trigonométricas: cos(ξ Δx), sin(ξ Δx).",
                                    "Calcule para ξ de 0 a π (Nyquist).",
                                    "Teste em casos limite: ξ→0 (precisão) e ξ=π (oscilações)."
                                  ],
                                  "verification": "G(ξ) expressa analiticamente e plotada para validação visual.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de plotagem (Python/MATLAB), tabela trigonométrica",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Fatore Δt/Δx em um número de CFL para generalidade.",
                                  "learningObjective": "Derivar G(ξ) de forma algébrica para esquemas lineares arbitrários.",
                                  "commonMistakes": [
                                    "Erro de sinal no expoente",
                                    "Dividir incorretamente os coeficientes",
                                    "Ignorar normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar estabilidade via |G(ξ)|",
                                  "subSteps": [
                                    "Calcule |G(ξ)|^2 = G(ξ) \bar{G(ξ)} para todo ξ ∈ [-π/Δx, π/Δx].",
                                    "Verifique critério de von Neumann: sup_ξ |G(ξ)| ≤ 1.",
                                    "Identifique regiões de dispersão (fase errada) e dissipação (|G|<1).",
                                    "Compare com solução exata para esquemas conhecidos.",
                                    "Discuta implicações para passos Δt e Δx."
                                  ],
                                  "verification": "Gráfico de |G(ξ)| ≤1 em todo domínio e conclusão de estabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib para plots",
                                    "Referências teóricas sobre estabilidade"
                                  ],
                                  "tips": "Use loop numérico para verificar sup |G| se analítico complexo.",
                                  "learningObjective": "Interpretar G(ξ) para prever comportamento numérico em simulações.",
                                  "commonMistakes": [
                                    "Verificar só Re(G) em vez de |G|",
                                    "Limitar ξ a [0,π] sem simetria",
                                    "Confundir com análise de Lax"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema FTCS (Forward Time Centered Space) na equação de advecção u_t + u_x =0: u^{n+1}_j = u^n_j - (Δt/(2Δx))(u^n_{j+1} - u^n_{j-1}). Substituindo Fourier: G(ξ) = 1 - i (Δt/Δx) sin(ξ Δx). Então |G(ξ)| = sqrt(1 + (c sin θ)^2) >1 para c=Δt/Δx >0, instável.",
                              "finalVerifications": [
                                "G(ξ) derivada corretamente para esquema dado.",
                                "|G(ξ)| plotado e sup ≤1 verificado.",
                                "Comportamento em ξ=0 e ξ=π analisado.",
                                "Número de CFL identificado para estabilidade.",
                                "Dissipação/dispersão qualitativamente descrita.",
                                "Comparação com literatura padrão."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação (100%).",
                                "Interpretação física de G(ξ) (clareza e profundidade).",
                                "Uso apropriado de ferramentas computacionais.",
                                "Identificação precisa de condições de estabilidade.",
                                "Análise de erros comuns evitados.",
                                "Apresentação clara com plots e fórmulas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e modos normais em mecânica quântica/clássica.",
                                "Computação: Otimização de códigos CFD e simulações paralelas.",
                                "Engenharia: Estabilidade em modelagem de fluidos e estruturas.",
                                "Estatística: Análise espectral de séries temporais numéricas."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos computacional (CFD) para aviação, onde análise de von Neumann garante que erros de alta frequência não amplifiquem, evitando crashes em previsões climáticas ou design de turbinas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Calcular G(ξ) para esquemas explícitos simples",
                            "description": "Derivar explicitamente a função de amplificação para o esquema forward Euler aplicado à equação de calor ou onda, expressando G(ξ) em termos de ξ e parâmetros do esquema como Δt e Δx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a equação diferencial parcial modelo e o esquema forward Euler",
                                  "subSteps": [
                                    "Identifique a equação de calor u_t = α u_xx ou equação de onda u_tt = c² u_xx como modelo.",
                                    "Escreva a discretização espacial via diferenças finitas centrais: δ²u_j / Δx² ≈ (u_{j-1} - 2u_j + u_{j+1}) / Δx².",
                                    "Defina o parâmetro de esquema r = α Δt / Δx² para calor ou similar para onda.",
                                    "Escreva o esquema explícito forward Euler: u^{n+1}_j = u^n_j + r (u^n_{j-1} - 2u^n_j + u^n_{j+1}).",
                                    "Verifique a consistência do esquema com a equação contínua limitando Δt, Δx → 0."
                                  ],
                                  "verification": "Confirme que o esquema forward Euler está corretamente escrito em termos de r, Δt e Δx.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica (ex: LeVeque ou Burden)",
                                    "Calculadora para simulações rápidas"
                                  ],
                                  "tips": "Sempre normalize com r para generalidade; lembre que forward Euler é condicionalmente estável.",
                                  "learningObjective": "Compreender a formulação do esquema explícito forward Euler para PDEs parabólicas ou hiperbólicas simples.",
                                  "commonMistakes": [
                                    "Confundir o operador laplaciano com derivada forward/backward",
                                    "Esquecer o fator α na definição de r",
                                    "Usar Δx em vez de Δx² no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a análise von Neumann e assumir a forma modal de Fourier",
                                  "subSteps": [
                                    "Explique a análise von Neumann: assume solução u^n_j = g^n e^{i ξ j Δx}, onde ξ é o número de onda.",
                                    "Substitua na equação discreta: o lado esquerdo vira g^{n+1} e^{i ξ j Δx}.",
                                    "Para o lado direito, compute a stencil: u^n_{j-1} = g^n e^{i ξ (j-1) Δx} = g^n e^{i ξ j Δx} e^{-i ξ Δx}.",
                                    "Similar para u^n_{j+1} = g^n e^{i ξ j Δx} e^{i ξ Δx}, e u^n_j = g^n e^{i ξ j Δx}.",
                                    "Divida ambos os lados por g^n e^{i ξ j Δx} para isolar g = G(ξ)."
                                  ],
                                  "verification": "Obtenha a relação G(ξ) e^{i ξ j Δx} = [1 + r (e^{-i θ} - 2 + e^{i θ})] e^{i ξ j Δx}, onde θ = ξ Δx.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como Mathematica ou SymPy para verificação",
                                    "Notas de aula sobre von Neumann"
                                  ],
                                  "tips": "Use θ = ξ Δx para simplificar notação; visualize ondas com ξ baixo (longo comprimento de onda) vs alto.",
                                  "learningObjective": "Dominar a substituição modal de Fourier na análise de estabilidade.",
                                  "commonMistakes": [
                                    "Esquecer o expoente n em g^n",
                                    "Não dividir corretamente para isolar G(ξ)",
                                    "Confundir ξ (número de onda) com k (vetor de onda físico)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a expressão explícita de G(ξ)",
                                  "subSteps": [
                                    "Simplifique o termo da stencil: e^{-i θ} + e^{i θ} - 2 = 2 cos θ - 2 = -4 sin²(θ/2), usando identidade trigonométrica.",
                                    "Assim, G(ξ) = 1 + r (-4 sin²(θ/2)) = 1 - 4 r sin²(ξ Δx / 2).",
                                    "Para equação de onda, adapte se necessário: para Leapfrog ou similar, mas foque em forward Euler.",
                                    "Expresse todos os termos em função de ξ, com θ = ξ Δx e r = Δt / Δx² (assumindo α=1).",
                                    "Generalize para esquemas explícitos similares, como upwind para advecção."
                                  ],
                                  "verification": "Verifique que G(ξ) = 1 - 4 r sin²(ξ Δx / 2) é obtida corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de identidades trigonométricas",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "A identidade cos θ = 1 - 2 sin²(θ/2) é chave; teste para θ=0: G(0)=1 (preserva constantes).",
                                  "learningObjective": "Derivar analiticamente a função de amplificação para esquemas de diferenças finitas explícitos.",
                                  "commonMistakes": [
                                    "Erro no sinal: +4 em vez de -4",
                                    "Usar sin θ em vez de sin²(θ/2)",
                                    "Esquecer dependência em Δx dentro de sin"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e verificar a função G(ξ) derivada",
                                  "subSteps": [
                                    "Plote |G(ξ)| vs ξ Δx para r fixo; verifique |G| ≤ 1 para estabilidade (r ≤ 1/2 para calor).",
                                    "Compute fase arg(G(ξ)) para dispersão.",
                                    "Teste casos limites: ξ=0 (G=1), ξ=π/Δx (G=1-4r, instável se r>1/2).",
                                    "Compare com solução exata: para calor, G_exata ≈ e^{-α ξ² Δt}.",
                                    "Discuta extensões para esquemas multi-estágio explícitos."
                                  ],
                                  "verification": "Confirme estabilidade condicional e dissipação numérica via |G(ξ)| <1 para ξ≠0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotar |G(ξ)|",
                                    "Papel para análise qualitativa"
                                  ],
                                  "tips": "Sempre normalize ξ Δx ∈ [0, π]; use gráficos para insight visual.",
                                  "learningObjective": "Interpretar G(ξ) em termos de dissipação e estabilidade numérica.",
                                  "commonMistakes": [
                                    "Ignorar condição CFL r ≤ 1/2",
                                    "Confundir dissipação (|G|<1) com dispersão (fase errada)",
                                    "Não testar ξ=π"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de calor u_t = u_xx com forward Euler e r=0.4: derive G(ξ) = 1 - 1.6 sin²(ξ Δx / 2). Plote |G(ξ)| para ξ Δx de 0 a π, mostrando |G|≤1 e dissipação crescente com ξ alto. Implemente em Python para verificar numericamente.",
                              "finalVerifications": [
                                "G(0) = 1 exatamente.",
                                "|G(ξ)| ≤ 1 para todo ξ se r ≤ 1/2.",
                                "Expressão simplificada usa sin²(ξ Δx / 2), não exponenciais complexos.",
                                "G(ξ) é real e par em ξ para esquemas centrais.",
                                "Dissipação: |G(ξ)| < 1 para ξ ≠ 0.",
                                "Comparação qualitativa com solução exata e^{-ξ² Δt}."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação da stencil espacial (peso 25%).",
                                "Aplicação precisa da identidade trigonométrica (peso 25%).",
                                "Expressão final em termos de ξ, Δt, Δx ou r (peso 20%).",
                                "Análise de estabilidade via |G(ξ)| ≤1 (peso 15%).",
                                "Interpretação física de dissipação (peso 10%).",
                                "Clareza na apresentação passo a passo (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica ou propagação de ondas.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Simulações CFD (Computational Fluid Dynamics).",
                                "Matemática Aplicada: Análise de Fourier e estabilidade linear."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas para previsão de difusão de poluentes (equação de calor/advecção-difusão), onde G(ξ) guia escolha de Δt/Δx para minimizar dissipação artificial em escalas finas, evitando perda de precisão em mesoescalas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Interpretar o domínio da função de amplificação",
                            "description": "Analisar o espectro de ξ ∈ [-π, π] e identificar modos de alta e baixa frequência na função G(ξ), relacionando com resolução espacial do esquema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o domínio espectral ξ ∈ [-π, π]",
                                  "subSteps": [
                                    "Revise o conceito de frequência espacial normalizada ξ = k Δx, onde k é o número de onda e Δx a malha espacial.",
                                    "Identifique que ξ varia de -π a π, correspondendo ao espectro completo de modos representáveis na malha.",
                                    "Explique que ξ = 0 representa modos constantes (baixa frequência) e ξ = ±π modos alternados (alta frequência).",
                                    "Desenhe o intervalo [-π, π] e marque pontos chave: 0, π/2, π.",
                                    "Discuta a periodicidade de G(ξ) com período 2π."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o domínio ξ ∈ [-π, π] com exemplos de frequências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software de desenho (GeoGebra, Python com Matplotlib)",
                                  "tips": "Lembre-se: ξ > π não é representável na malha discreta (Teorema de Nyquist-Shannon).",
                                  "learningObjective": "Entender o significado físico e matemático do domínio de ξ.",
                                  "commonMistakes": "Confundir ξ com frequência temporal ω ou ignorar a simetria par/impar de G(ξ)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar modos de baixa frequência em G(ξ) (ξ ≈ 0)",
                                  "subSteps": [
                                    "Expanda G(ξ) em série de Taylor ao redor de ξ=0: |G(ξ)| ≈ 1 para precisão.",
                                    "Calcule G(ξ) para ξ pequeno e verifique dispersão/dissipação mínima.",
                                    "Plote |G(ξ)| e arg(G(ξ)) próximo a 0.",
                                    "Interprete: modos bem resolvidos, propagação física correta.",
                                    "Compare com solução exata da equação contínua."
                                  ],
                                  "verification": "Mostre que |G(0)| = 1 e derivadas baixas ordem coincidem com a solução exata.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora simbólica (SymPy, Mathematica) ou papel para expansões.",
                                  "tips": "Use aproximação sin(ξ/2) ≈ ξ/2 para ξ pequeno.",
                                  "learningObjective": "Identificar características de baixa frequência na função de amplificação.",
                                  "commonMistakes": "Negligenciar a fase (arg(G(ξ))) que indica dispersão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar modos de alta frequência em G(ξ) (ξ ≈ ±π)",
                                  "subSteps": [
                                    "Avalie G(ξ) próximo a ξ=π: espere |G(π)| < 1 (dissipação) ou oscilações.",
                                    "Plote G(ξ) para ξ de π/2 a π e observe amplificação ou atenuação.",
                                    "Classifique: alta frequência como modos mal resolvidos (ondas curtas).",
                                    "Discuta estabilidade: |G(ξ)| ≤ 1 para todo ξ.",
                                    "Exemplo numérico: compute para esquema específico."
                                  ],
                                  "verification": "Identifique intervalos onde |G(ξ)| >1 (instável) ou <0.5 (dissipativo).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB com numpy/scipy)",
                                  "tips": "Foquem em |G(ξ)| para dissipação e arg para dispersão.",
                                  "learningObjective": "Reconhecer comportamentos de alta frequência e suas implicações.",
                                  "commonMistakes": "Confundir dissipação (|G|<1) com dispersão (fase errada)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar ξ com resolução espacial do esquema",
                                  "subSteps": [
                                    "Lembre: resolução espacial Δx determina ξ_max = π/Δx (frequência de Nyquist).",
                                    "Analise como refinar malha (Δx menor) expande o espectro bem resolvido.",
                                    "Discuta trade-off: custo computacional vs. resolução de altas frequências.",
                                    "Interprete gráfico: região ξ<π/3 bem resolvida tipicamente.",
                                    "Conclua implicações para escolha de esquema (e.g., upwind dissipativo)."
                                  ],
                                  "verification": "Explique como Δx afeta a faixa de ξ bem resolvida e dê exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de códigos numéricos (Jupyter notebook)",
                                  "tips": "Pense em termos de número de pontos por onda: >2 pontos para boa resolução.",
                                  "learningObjective": "Conectar análise espectral com design de malha numérica.",
                                  "commonMistakes": "Ignorar que altas frequências causam oscilações não-físicas em simulações."
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Friedrichs na equação de advecção u_t + c u_x =0: G(ξ) = cos(ξ/2) - i (cΔt/Δx) sin(ξ/2). Plote |G(ξ)| em [-π,π]; observe dissipação forte em altas frequências (ξ>π/2), preservando baixas (ξ<π/3), ideal para choques.",
                              "finalVerifications": [
                                "Pode plotar corretamente G(ξ) no domínio [-π,π] para um esquema dado.",
                                "Identifica corretamente modos de baixa (ξ≈0) e alta (ξ≈π) frequência.",
                                "Relaciona ξ com Δx e explica impacto na resolução espacial.",
                                "Avalia estabilidade via |G(ξ)|≤1 ∀ξ.",
                                "Discute dispersão/dissipação qualitativamente.",
                                "Compara com solução exata em baixas frequências."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do domínio ξ ∈ [-π,π] (20%)",
                                "Correta identificação de baixa/alta frequência (25%)",
                                "Análise qualitativa/quantitativa de G(ξ) (25%)",
                                "Relacionamento com resolução espacial (15%)",
                                "Uso de exemplos e plots claros (10%)",
                                "Interpretação de implicações numéricas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de Fourier em ondas e espectros.",
                                "Engenharia Computacional: Von Neumann stability analysis.",
                                "Processamento de Sinais: Frequências de Nyquist.",
                                "Física Computacional: Simulações de PDEs."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), análise de G(ξ) guia escolha de esquemas para evitar oscilações espúrias em turbulência, otimizando malhas em previsão meteorológica ou aerodinâmica."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Quantificação da Dissipação via Módulo de G(ξ)",
                        "description": "Uso do módulo |G(ξ)| da função de amplificação para medir a dissipação numérica, onde |G(ξ)| < 1 indica atenuação de amplitudes ao longo do tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Avaliar dissipação qualitativa",
                            "description": "Determinar se um esquema é dissipativo analisando se |G(ξ)| ≤ 1 para todo ξ, com igualdade apenas para ξ=0 (modo zero-frequência).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de função de amplificação e dissipatividade",
                                  "subSteps": [
                                    "Ler a definição formal de esquema dissipativo: |G(ξ)| ≤ 1 para todo ξ ∈ [0, π], com igualdade apenas em ξ=0.",
                                    "Entender que G(ξ) é a função de amplificação obtida via análise de von Neumann.",
                                    "Identificar o significado físico: ξ=0 corresponde ao modo de baixa frequência (solução exata), enquanto ξ=π é alta frequência (erros oscilatórios).",
                                    "Anotar exemplos de esquemas conhecidos (ex: Lax-Friedrichs é dissipativo).",
                                    "Explicar em palavras próprias a diferença entre dissipativo e não-dissipativo."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo as condições de dissipatividade e confirmar com auto-perguntas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise de von Neumann",
                                    "Livro de análise numérica (ex: LeVeque)",
                                    "Artigo sobre estabilidade de esquemas"
                                  ],
                                  "tips": "Visualize G(ξ) como um fator de amplificação de Fourier modes; dissipatividade 'amortece' modos espúrios.",
                                  "learningObjective": "Dominar os conceitos teóricos de G(ξ) e dissipatividade qualitativa.",
                                  "commonMistakes": [
                                    "Confundir dissipatividade com estabilidade (estável pode ser não-dissipativo)",
                                    "Ignorar a exceção estrita em ξ=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar ou obter a função de amplificação G(ξ) para um esquema dado",
                                  "subSteps": [
                                    "Selecionar um esquema numérico simples (ex: forward Euler para advecção).",
                                    "Aplicar análise de von Neumann: assumir solução u_j^n = g^n e^{i ξ j}, derivar G(ξ) = g(ξ).",
                                    "Calcular explicitamente |G(ξ)|^2 para ξ simbólico.",
                                    "Verificar |G(0)| = 1 (preservação de constantes).",
                                    "Testar numericamente em software para ξ discretos."
                                  ],
                                  "verification": "Comparar G(ξ) derivada com fórmula conhecida do esquema e plotar |G(ξ)|.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e lápis ou Mathematica/MATLAB para derivação simbólica",
                                    "Código Python para plotagem"
                                  ],
                                  "tips": "Use aproximações de Taylor para G(ξ) perto de 0 para validar.",
                                  "learningObjective": "Capacitar-se a extrair G(ξ) de esquemas lineares.",
                                  "commonMistakes": [
                                    "Erro na fase da análise de von Neumann (esquecer iξ)",
                                    "Não normalizar corretamente para |G(0)|=1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar qualitativamente o módulo |G(ξ)| no domínio de frequência",
                                  "subSteps": [
                                    "Plotar |G(ξ)| vs ξ em [0, π] usando gráfico ou tabela.",
                                    "Identificar se |G(ξ)| ≤ 1 para todo ξ, focando em máximos.",
                                    "Verificar se igualdade ocorre apenas em ξ=0 (inspecionar derivadas ou valores próximos).",
                                    "Analisar comportamento assintótico: |G(ξ)| <1 para ξ>0 indica dissipação.",
                                    "Comparar com limiar: se max |G(ξ)| >1, não dissipativo."
                                  ],
                                  "verification": "Confirmar graficamente ou tabularmente que condições são satisfeitas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/MATLAB com numpy/matplotlib)",
                                    "Tabelas de valores de |G(ξ)|"
                                  ],
                                  "tips": "Amplie o eixo y em [0.5, 1.1] para detectar violações sutis.",
                                  "learningObjective": "Desenvolver habilidade em inspeção qualitativa de |G(ξ)|.",
                                  "commonMistakes": [
                                    "Avaliar só em ξ=0 e π, ignorando máximo intermediário",
                                    "Confundir |G(ξ)| com arg(G(ξ))"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e documentar a dissipatividade do esquema",
                                  "subSteps": [
                                    "Resumir: 'O esquema é dissipativo porque |G(ξ)| ≤ 1 ∀ξ, =1 só em ξ=0'.",
                                    "Discutir implicações: amortecimento de oscilações de alta frequência.",
                                    "Testar com contraexemplo (ex: esquema upwind instável).",
                                    "Redigir relatório curto com plot e conclusão.",
                                    "Autoavaliar rigor da análise qualitativa."
                                  ],
                                  "verification": "Produzir declaração clara de dissipatividade com evidência gráfica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Template de relatório",
                                    "Plots gerados anteriormente"
                                  ],
                                  "tips": "Use frases como 'inspeção revela...' para qualitativo.",
                                  "learningObjective": "Sintetizar análise em julgamento qualitativo assertivo.",
                                  "commonMistakes": [
                                    "Concluir dissipativo sem checar todo o intervalo",
                                    "Não justificar exceção em ξ=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Friedrichs na equação de advecção u_t + a u_x =0: G(ξ) = [1 - (sin(ξ/2)/(ξ/2))^2 * σ^2 ] cos(ξ σ /2) + i algo, mas |G(ξ)| ≤1 com =1 só em ξ=0. Plote e confirme dissipatividade qualitativa.",
                              "finalVerifications": [
                                "Correta derivação de |G(0)|=1.",
                                "Identificação precisa de max |G(ξ)| ≤1.",
                                "Confirmação de igualdade estrita só em ξ=0.",
                                "Interpretação física correta (amortecimento de modos espúrios).",
                                "Análise consistente para pelo menos dois esquemas.",
                                "Relatório com plot e conclusão inequívoca."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G(ξ) (sem erros algébricos).",
                                "Qualidade da análise qualitativa (cobertura completa de [0,π]).",
                                "Rigor na verificação da condição estrita em ξ=0.",
                                "Clareza na documentação e interpretação.",
                                "Uso adequado de ferramentas computacionais.",
                                "Identificação de implicações numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em equações de onda e amortecimento viscoso.",
                                "Engenharia Computacional: Análise de CFD e simulações de fluidos.",
                                "Processamento de Sinais: Filtros digitais e resposta em frequência.",
                                "Ciência da Computação: Complexidade e estabilidade de algoritmos iterativos."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos (CFD), esquemas dissipativos previnem amplificação de ruído numérico em turbulência, garantindo precisão em previsões meteorológicas e aerodinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Calcular taxa de dissipação",
                            "description": "Computar a taxa de dissipação numérica como -Re(log |G(ξ)|)/Δt e plotar perfis de dissipação para diferentes esquemas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Função de Amplificação G(ξ) para o Esquema Numérico",
                                  "subSteps": [
                                    "Identifique o esquema numérico de interesse (ex: Lax-Wendroff ou upwind).",
                                    "Derive ou recupere a expressão analítica de G(ξ) para o esquema, onde ξ é o número de onda adimensional.",
                                    "Verifique as propriedades de G(ξ): |G(ξ)| ≤ 1 para estabilidade.",
                                    "Calcule G(ξ) para valores discretos de ξ de 0 a π.",
                                    "Registre os valores complexos de G(ξ) em uma tabela."
                                  ],
                                  "verification": "Confirme que |G(0)| = 1 e |G(π)| < 1 para esquemas dissipativos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora ou Python (NumPy para cálculos complexos)",
                                  "tips": "Comece com ξ = 0 para verificar consistência exata.",
                                  "learningObjective": "Compreender o papel da função de amplificação na análise de dissipação.",
                                  "commonMistakes": "Confundir ξ com kΔx; sempre normalize corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Módulo |G(ξ)| e Logaritmo Complexo",
                                  "subSteps": [
                                    "Compute |G(ξ)| = sqrt(Re(G)^2 + Im(G)^2) para cada ξ.",
                                    "Calcule log(|G(ξ)|), usando log natural (ln).",
                                    "Extraia a parte real: Re(log(|G(ξ)|)) = ln(|G(ξ)|), que é negativa para dissipação.",
                                    "Armazene valores em um array ou tabela para múltiplos ξ.",
                                    "Valide que Re(log(|G(ξ)|)) ≤ 0 para todos ξ."
                                  ],
                                  "verification": "Verifique se ln(|G(ξ)|) diminui monotonicamente com ξ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (NumPy, cmath para log complexa) ou MATLAB",
                                  "tips": "Use funções vetoriais para eficiência em arrays de ξ.",
                                  "learningObjective": "Dominar o cálculo numérico do módulo e logaritmo da função de amplificação.",
                                  "commonMistakes": "Usar log base 10 em vez de ln; sempre use log natural."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a Taxa de Dissipação Numérica",
                                  "subSteps": [
                                    "Aplique a fórmula: taxa = -Re(log(|G(ξ)|)) / Δt.",
                                    "Escolha um Δt típico (ex: 0.01) e compute para cada ξ.",
                                    "Gere perfis de taxa vs. ξ para um esquema.",
                                    "Compare com o caso exato (taxa = 0 para solução sem dissipação).",
                                    "Salve os dados em formato plotável (CSV ou array)."
                                  ],
                                  "verification": "Taxa deve ser positiva e crescente com ξ para esquemas dissipativos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (NumPy para divisão, Pandas para dados)",
                                  "tips": "Fixe Δt consistente com CFL para relevância física.",
                                  "learningObjective": "Aplicar a fórmula exata da taxa de dissipação.",
                                  "commonMistakes": "Esquecer o sinal negativo, resultando em taxa negativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e Comparar Perfis de Dissipação para Diferentes Esquemas",
                                  "subSteps": [
                                    "Selecione 2-3 esquemas (ex: upwind, Lax-Friedrichs, Leapfrog).",
                                    "Gere G(ξ) para cada e compute taxas.",
                                    "Crie plots: taxa vs. ξ, com curvas para cada esquema.",
                                    "Adicione legendas, rótulos e grade.",
                                    "Analise qualitativamente: qual esquema dissipa mais em altas frequências?"
                                  ],
                                  "verification": "Gráficos mostram dissipação mínima perto de ξ=0 e máxima perto de ξ=π.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (Matplotlib para plotting) ou MATLAB",
                                  "tips": "Use semilogx se taxas variam muito em magnitude.",
                                  "learningObjective": "Visualizar e comparar dissipação entre esquemas numéricos.",
                                  "commonMistakes": "Escalas erradas no plot; normalize ξ de 0 a π."
                                }
                              ],
                              "practicalExample": "Para o esquema upwind em equação de advecção (u_t + a u_x = 0), com aΔt/Δx = 0.5: G(ξ) = 1 - 0.5(1 - exp(-iξ)). Compute |G(ξ)| para ξ = [0, π/4, π/2, 3π/4, π], obtenha taxas ≈ [0, 0.07, 0.35, 0.87, 1.39]/Δt, e plote vs. ξ comparando com Lax-Friedrichs.",
                              "finalVerifications": [
                                "Taxas calculadas são não-negativas e crescem com ξ.",
                                "Plots mostram distinções claras entre esquemas.",
                                "|G(ξ)| ≤ 1 para todos ξ testados.",
                                "Fórmula aplicada corretamente: -Re(ln|G|)/Δt.",
                                "Gráficos têm eixos rotulados e legendas.",
                                "Valores em ξ=0 coincidem com zero dissipação."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos cálculos de G(ξ) e |G(ξ)| (erro < 1e-10).",
                                "Correta aplicação da fórmula de taxa de dissipação.",
                                "Qualidade visual dos plots (clareza, escalas apropriadas).",
                                "Comparação quantitativa/qualitativa entre esquemas.",
                                "Documentação de passos e valores intermediários.",
                                "Identificação de tendências físicas corretas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de amortecimento em ondas (equações de onda/parabólicas).",
                                "Engenharia Computacional: Otimização de esquemas em CFD e simulações acústicas.",
                                "Programação: Uso de bibliotecas numéricas (NumPy, SciPy) para análise von Neumann.",
                                "Estatística: Interpretação de perfis de erro numérico."
                              ],
                              "realWorldApplication": "Em simulações numéricas de previsão meteorológica ou propagação de ondas sísmicas, calcular taxas de dissipação ajuda a escolher esquemas que minimizem distorções artificiais em altas frequências, melhorando a precisão de modelos em oceanografia e aeroacústica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Comparar dissipação em esquemas implícitos e explícitos",
                            "description": "Derivar e comparar |G(ξ)| para esquemas como Lax-Friedrichs (dissipativo) versus Leapfrog (não dissipativo), destacando impactos em suavização numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Função de Amplificação e Dissipação",
                                  "subSteps": [
                                    "Definir a função de amplificação G(ξ) para esquemas de diferenças finitas em EDOs ou PVI.",
                                    "Explicar o papel do módulo |G(ξ)| na quantificação da dissipação numérica.",
                                    "Discutir o espectro de ξ (frequências de Fourier) e comportamento para ξ próximo de 0 e π.",
                                    "Classificar esquemas como dissipativos (|G(ξ)| < 1 para ξ ≠ 0) ou não dissipativos (|G(ξ)| = 1).",
                                    "Identificar exemplos: Lax-Friedrichs (dissipativo explícito) e Leapfrog (não dissipativo explícito)."
                                  ],
                                  "verification": "Derivar corretamente a definição de G(ξ) para a equação de advecção linear e plotar |G(ξ)| qualitativamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: LeVeque)",
                                    "Papel e caneta ou Jupyter Notebook para anotações"
                                  ],
                                  "tips": "Comece com a equação modelo u_t + a u_x = 0 para simplificar derivações.",
                                  "learningObjective": "Compreender como |G(ξ)| mede a amortecimento de componentes de alta frequência.",
                                  "commonMistakes": "Confundir dissipação com dispersão; lembrar que dissipação afeta amplitude, não fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar |G(ξ)| para Esquemas Explícitos",
                                  "subSteps": [
                                    "Escrever a estencil do esquema Lax-Friedrichs: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (λ/2)(u_{j+1}^n - u_{j-1}^n).",
                                    "Aplicar análise de von Neumann: assumir u_j^n = g^n e^{i ξ j}, derivar g(ξ).",
                                    "Calcular |G(ξ)| = |g(ξ)| explicitamente para Lax-Friedrichs.",
                                    "Repetir para Leapfrog: u_j^{n+1} = u_j^{n-1} - λ (u_{j+1}^n - u_{j-1}^n)/2.",
                                    "Plotar |G(ξ)| para ambos esquemas no intervalo [0, π]."
                                  ],
                                  "verification": "Obter |G_LF(ξ)| = |cos(ξ) - λ sin(ξ)| e |G_Leap(ξ)| ≈ 1 para baixa dissipação, confirmando com gráfico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python com NumPy/Matplotlib)",
                                    "Folha de derivação"
                                  ],
                                  "tips": "Use sympy para derivações simbólicas se disponível, para evitar erros algébricos.",
                                  "learningObjective": "Derivar analiticamente |G(ξ)| para esquemas explícitos padrão.",
                                  "commonMistakes": "Esquecer o fator de amortecimento médio em Leapfrog; verificar estabilidade CFL."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Analisar |G(ξ)| para Esquemas Implícitos",
                                  "subSteps": [
                                    "Introduzir esquema implícito dissipativo: Backward Euler u_j^{n+1} = u_j^n - λ (u_{j+1}^{n+1} - u_{j-1}^{n+1})/2.",
                                    "Resolver o sistema tridiagonal para g(ξ) via matriz de amplificação.",
                                    "Calcular |G(ξ)| para Backward Euler e Crank-Nicolson (não dissipativo implícito).",
                                    "Comparar numericamente |G(ξ)| com esquemas explícitos via tabelas ou plots.",
                                    "Destacar vantagens implícitas: estabilidade incondicional e menor dissipação em CN."
                                  ],
                                  "verification": "Derivação correta de |G_BE(ξ)| = 1 / |1 + i λ sin(ξ)| e plot comparativo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python/MATLAB para resolver e plotar",
                                    "Referência: notas de aula sobre esquemas implícitos"
                                  ],
                                  "tips": "Aproximação para ξ pequeno: Taylor expandir para analisar ordem de dissipação.",
                                  "learningObjective": "Entender diferenças em |G(ξ)| entre implícitos e explícitos.",
                                  "commonMistakes": "Ignorar resolução matricial em implícitos; usar fórmula explícita para g."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Dissipação e Discutir Impactos na Suavização Numérica",
                                  "subSteps": [
                                    "Tabular |G(ξ)| em pontos chave (ξ=0, π/4, π/2, π) para todos esquemas.",
                                    "Analisar: Lax-Friedrichs suaviza mais (alta dissipação), Leapfrog preserva energia.",
                                    "Discutir trade-offs: dissipação controla oscilações mas introduz difusão numérica.",
                                    "Simular numericamente uma onda com cada esquema para visualizar suavização.",
                                    "Concluir sobre escolha baseada em aplicação (ex: ondas vs. choques)."
                                  ],
                                  "verification": "Relatório com tabela, plots e simulação mostrando diferenças qualitativas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código de simulação 1D (Python com matplotlib para animação)",
                                    "Dados de teste: pulso gaussiano"
                                  ],
                                  "tips": "Use Δt pequeno para estabilidade explícita; compare erros L2.",
                                  "learningObjective": "Comparar quantitativamente dissipação e impactos em precisão.",
                                  "commonMistakes": "Atribuir dispersão à dissipação; verificar com ξ alto (ondas curtas)."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 com pulso inicial gaussiano em [0,1]. Aplique Lax-Friedrichs (suaviza o pulso rapidamente) vs. Leapfrog (preserva forma, mas oscilações) vs. Crank-Nicolson (estável, mínima dissipação).",
                              "finalVerifications": [
                                "Derivação correta de |G(ξ)| para Lax-Friedrichs e Leapfrog.",
                                "Plot comparativo mostrando |G_LF(ξ)| < 1 e |G_Leap(ξ)| ≈ 1.",
                                "Análise qualitativa de Backward Euler como mais dissipativo que CN.",
                                "Simulação numérica reproduzindo suavização diferencial.",
                                "Explicação verbal dos impactos em componentes de alta frequência."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações analíticas (80% peso).",
                                "Qualidade dos plots e tabelas comparativos (15%).",
                                "Interpretação física da dissipação vs. suavização (5%).",
                                "Correção na identificação de esquemas dissipativos/não dissipativos.",
                                "Capacidade de simular e discutir trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Modelagem de ondas em meios dissipativos.",
                                "Engenharia Aeronáutica: CFD para simulações de fluxo com amortecimento numérico.",
                                "Ciência de Dados: Análise de estabilidade em MLPs para séries temporais.",
                                "Processamento de Sinais: Filtros numéricos e atenuação de ruído."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM), Leapfrog minimiza dissipação para preservar energia em escalas planetárias, enquanto Lax-Friedrichs controla ruído em regiões de gradientes íngremes como frentes meteorológicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Análise de Comportamento Dissipativo em PDEs",
                        "description": "Aplicação da função de amplificação para analisar dissipação em esquemas para equações parabólicas e hiperbólicas, relacionando com estabilidade e precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Analisar dissipação em equações parabólicas",
                            "description": "Aplicar G(ξ) ao método explícito para a equação de calor, identificando como dissipação artificial afeta a solução em longos tempos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a função de amplificação G(ξ) para o método explícito na equação de calor",
                                  "subSteps": [
                                    "Escrever a equação de calor unidimensional: ∂u/∂t = α ∂²u/∂x², com α > 0.",
                                    "Apresentar a discretização pelo método explícito: u_j^{n+1} = u_j^n + r (u_{j-1}^n - 2u_j^n + u_{j+1}^n), onde r = α Δt / Δx².",
                                    "Aplicar análise de von Neumann: assumir u_j^n = ρ^n e^{i ξ j}, com ξ = κ Δx o número de onda não-dimensional.",
                                    "Substituir na equação discreta e resolver para ρ = G(ξ) = 1 - 4r sin²(ξ/2).",
                                    "Verificar a forma exata de G(ξ) simbolicamente."
                                  ],
                                  "verification": "G(ξ) derivada corretamente como 1 - 4r sin²(ξ/2), com ξ ∈ [0, π].",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX",
                                    "Software simbólico como SymPy (Python) ou Mathematica",
                                    "Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Use a identidade trigonométrica para sin²(θ/2) para simplificar expressões.",
                                  "learningObjective": "Compreender a origem espectral da função de amplificação no método explícito.",
                                  "commonMistakes": "Confundir ξ com θ = ξ/2 ou esquecer o fator 4r no termo dissipativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o módulo |G(ξ)| e identificar regimes de dissipação",
                                  "subSteps": [
                                    "Calcular |G(ξ)| = |1 - 4r sin²(ξ/2)| para ξ de 0 a π e diferentes valores de r (ex: r=0.1, 0.4, 0.49).",
                                    "Plotar |G(ξ)| vs ξ usando software gráfico.",
                                    "Identificar condição de estabilidade: |G(ξ)| ≤ 1 para todo ξ, implicando r ≤ 1/2.",
                                    "Observar dissipação: para ξ baixo (modos suaves), |G| ≈ 1; para ξ alto (modos oscilatórios), |G| < 1.",
                                    "Classificar dissipação artificial como o amortecimento excessivo de componentes de alta frequência."
                                  ],
                                  "verification": "Gráficos mostram |G(ξ)| ≤ 1 e queda acentuada para ξ > π/2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "GNU Octave ou MATLAB",
                                    "Folha de cálculo para cálculos manuais"
                                  ],
                                  "tips": "Fixe r próximo de 1/2 para visualizar dissipação máxima sem instabilidade.",
                                  "learningObjective": "Interpretar |G(ξ)| como fator de amortecimento por modo espacial.",
                                  "commonMistakes": "Ignorar que dissipação é seletiva (mais forte em altas frequências)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o comportamento dissipativo em longos tempos",
                                  "subSteps": [
                                    "Analisar o comportamento assintótico: após N passos, fator global [G(ξ)]^N.",
                                    "Para t = N Δt fixo e Δt → 0 (r fixo), modos altos decaem como e^{-c t / Δx²}, excessivamente rápido.",
                                    "Comparar com solução exata da equação de calor, que dissipa como e^{-α κ² t}.",
                                    "Quantificar erro: dissipação artificial ≈ O(Δx² / Δt) para altas frequências.",
                                    "Discutir implicações para precisão em simulações prolongadas."
                                  ],
                                  "verification": "Explicação escrita mostra decaimento super-rápido de [G(ξ)]^N para ξ alto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Caderno para derivações assintóticas",
                                    "Python para simulações de longo prazo",
                                    "Referências teóricas sobre erros numéricos"
                                  ],
                                  "tips": "Use log(|G(ξ)|^N) para visualizar decaimento exponencial.",
                                  "learningObjective": "Reconhecer como dissipação artificial distorce soluções em regimes transientes longos.",
                                  "commonMistakes": "Confundir dissipação física (exata) com artificial (numérica)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar análise com implementação numérica e visualização",
                                  "subSteps": [
                                    "Implementar método explícito para u_t = u_xx em [0,π] com u(x,0)=sin(3x) (alta frequência).",
                                    "Simular até t=5 com r=0.4, Δx=π/20, e plotar solução numérica vs exata e^{ -9t } sin(3x).",
                                    "Comparar perfis: observar subestimação de amplitude devido a dissipação.",
                                    "Repetir com r menor e analisar redução do erro dissipativo.",
                                    "Documentar conclusões sobre impacto em longos tempos."
                                  ],
                                  "verification": "Plots mostram amortecimento artificial quantificável (ex: amplitude reduzida em 20%).",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Python com NumPy, SciPy e Matplotlib",
                                    "Jupyter Notebook para reprodutibilidade"
                                  ],
                                  "tips": "Escolha condição inicial com múltiplos modos para ver dissipação seletiva.",
                                  "learningObjective": "Aplicar teoria para diagnosticar e mitigar erros numéricos.",
                                  "commonMistakes": "Usar r > 1/2 levando a instabilidade em vez de dissipação pura."
                                }
                              ],
                              "practicalExample": "Simule a equação de calor u_t = u_xx em [0,1] com u(x,0) = sin(π x) + 0.5 sin(5 π x), condições de Dirichlet u(0,t)=u(1,t)=0, α=1. Use método explícito com Δx=0.05, r=0.45. Em t=2, a solução exata preserva amplitudes relativas e^{- (π² t)} e e^{- (25 π² t)}, mas numérica dissipa excessivamente o modo sin(5πx), reduzindo sua amplitude em ~40% a mais que o físico.",
                              "finalVerifications": [
                                "Derivação correta de G(ξ) = 1 - 4r sin²(ξ/2).",
                                "Identifica dissipação quando |G(ξ)| < 1 para ξ alto.",
                                "Explica impacto em longos tempos via [G(ξ)]^{t/Δt}.",
                                "Compara com dissipação física e^{-α κ² t}.",
                                "Demonstra numericamente o erro artificial em simulação.",
                                "Propõe mitigação como refinar malha ou usar métodos implícitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de G(ξ) (20%).",
                                "Interpretação qualitativa e quantitativa de |G(ξ)| (25%).",
                                "Análise assintótica para longos tempos correta (20%).",
                                "Qualidade de plots e simulações numéricas (20%).",
                                "Conclusões sobre dissipação artificial e recomendações (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão térmica e amortecimento de ondas.",
                                "Computação: Análise de estabilidade em algoritmos numéricos.",
                                "Engenharia: Simulações em CFD e transferência de calor.",
                                "Estatística: Quantificação de erros de truncamento numérico."
                              ],
                              "realWorldApplication": "Na previsão de temperaturas em reatores nucleares ou simulações climáticas de longo prazo, a dissipação artificial no método explícito pode subestimar gradientes térmicos persistentes, levando a erros em projetos de isolamento ou modelagem de derretimento de geleiras, exigindo análise para escolher esquemas numéricos adequados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Avaliar trade-off dissipação vs dispersão",
                            "description": "Examinar gráficos de |G(ξ)| e arg(G(ξ)) para esquemas hiperbólicos, quantificando como dissipação controla oscilações mas introduz suavização excessiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais da função de amplificação G(ξ)",
                                  "subSteps": [
                                    "Defina G(ξ) como a função de amplificação para esquemas hiperbólicos em análise de von Neumann.",
                                    "Explique o papel de ξ (frequência espacial normalizada) no domínio discreto.",
                                    "Discuta condições de estabilidade: |G(ξ)| ≤ 1 para todos ξ.",
                                    "Identifique componentes reais e imaginárias de G(ξ).",
                                    "Pratique cálculo simbólico de G(ξ) para um esquema simples como upwind."
                                  ],
                                  "verification": "Capacidade de derivar G(ξ) corretamente para um esquema dado e plotar |G(ξ)| qualitativamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de análise numérica (ex: LeVeque), papel e lápis ou SymPy/Jupyter Notebook.",
                                  "tips": "Comece com esquemas 1D lineares para simplicidade antes de PDEs.",
                                  "learningObjective": "Compreender a base matemática da função de amplificação.",
                                  "commonMistakes": "Confundir ξ com o passo de tempo; ignorar normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar dissipação através do módulo |G(ξ)|",
                                  "subSteps": [
                                    "Plote |G(ξ)| para esquemas dissipativos (ex: upwind) vs não-dissipativos.",
                                    "Quantifique dissipação: meça declínio de |G(ξ)| para ξ altos (modos oscilatórios).",
                                    "Calcule taxa de dissipação: log(|G(ξ)|) vs ξ.",
                                    "Identifique suavização excessiva: |G(ξ)| << 1 para ξ médios.",
                                    "Compare com solução exata (|G_exata| = 1)."
                                  ],
                                  "verification": "Gráficos de |G(ξ)| mostram controle de oscilações sem perda excessiva em baixas frequências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Python (Matplotlib/NumPy), exemplos de esquemas hiperbólicos.",
                                  "tips": "Use escalas logarítmicas para visualizar declínios sutis.",
                                  "learningObjective": "Quantificar como dissipação suprime oscilações.",
                                  "commonMistakes": "Interpretar |G(ξ)| >1 como dissipação (é instabilidade)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dispersão através da fase arg(G(ξ))",
                                  "subSteps": [
                                    "Plote arg(G(ξ)) vs ξ e compare com fase exata arg(G_exata(ξ)) = -c ξ Δt.",
                                    "Meça erro de dispersão: |arg(G(ξ)) - arg(G_exata(ξ))|.",
                                    "Identifique dispersão de fase: desvios lineares causam ondas falsas.",
                                    "Calcule velocidade de fase numérica: d(arg(G))/dξ.",
                                    "Avalie impacto em pacotes de onda (superposição de ξ)."
                                  ],
                                  "verification": "Gráficos mostram desvios de fase lineares e quantificação do erro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de plotagem (MATLAB/Python), tabelas de G(ξ) para esquemas como Lax-Wendroff.",
                                  "tips": "Normalize fases para evitar ambiguidades de 2π.",
                                  "learningObjective": "Identificar e quantificar erros de dispersão.",
                                  "commonMistakes": "Ignorar envoltório de fase; confundir com amortecimento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar trade-off quantitativo entre dissipação e dispersão",
                                  "subSteps": [
                                    "Sobreponha gráficos de |G(ξ)| e arg(G(ξ)) para múltiplos esquemas.",
                                    "Defina métricas: Dissipation Index = ∫ log(|G|) dξ; Dispersion Error = ∫ |arg_err| dξ.",
                                    "Otimize trade-off: minimize soma ponderada das métricas.",
                                    "Teste em PDEs reais (ex: equação de advecção com fonte).",
                                    "Recomende esquema baseado em trade-off (ex: mais dissipação para oscilações fortes)."
                                  ],
                                  "verification": "Relatório com gráficos comparativos e escolha justificada de esquema.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Jupyter Notebook para integração numérica, exemplos de PDEs hiperbólicas.",
                                  "tips": "Use pesos adaptativos baseados no espectro esperado da solução.",
                                  "learningObjective": "Realizar avaliação holística do trade-off.",
                                  "commonMistakes": "Focar só em estabilidade, ignorando precisão de fase."
                                }
                              ],
                              "practicalExample": "Para a equação de advecção u_t + u_x = 0 com esquema upwind (dissipativo): plote |G(ξ)| decaindo rapidamente (controla oscilações) mas arg(G(ξ)) com erro de fase baixo; compare com Lax-Wendroff (dispersivo): |G|≈1 mas arg com oscilações, levando a ondas fantasmas. Quantifique: upwind tem Dissipation= -0.2, Dispersion=0.05; Lax-Wendroff: Dissipation=0, Dispersion=0.15. Escolha upwind para soluções descontínuas.",
                              "finalVerifications": [
                                "Gráficos de |G(ξ)| e arg(G(ξ)) corretamente plotados e interpretados.",
                                "Métricas quantitativas calculadas para pelo menos 3 esquemas.",
                                "Trade-off explicitamente avaliado com recomendação fundamentada.",
                                "Aplicação demonstrada em um PDE hiperbólico simples.",
                                "Identificação correta de suavização excessiva vs ondas falsas.",
                                "Comparação com solução exata em espectro de frequências."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e plotagem de G(ξ) (30%).",
                                "Quantificação correta de dissipação e dispersão (25%).",
                                "Análise qualitativa/quantitativa do trade-off (20%).",
                                "Uso de métricas integradas e otimização (15%).",
                                "Clareza em gráficos e relatório (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações de ondas e fluidos.",
                                "Engenharia Computacional: Otimização de CFD solvers.",
                                "Ciência da Computação: Análise de algoritmos numéricos paralelos.",
                                "Estatística: Espectros de frequências e análise de Fourier."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), avaliar trade-offs em solvers para turbulência: alta dissipação previne instabilidades em choques, mas dispersão excessiva (ex: Lax-Wendroff) gera estruturas falsas; usado em previsão meteorológica e aerodinâmica automotiva para equilibrar precisão e estabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Verificar estabilidade via dissipação",
                            "description": "Confirmar o critério de estabilidade |G(ξ)| ≤ 1 + O(Δt) e analisar esquemas condicionalmente estáveis com base no perfil dissipativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o critério de estabilidade via dissipação",
                                  "subSteps": [
                                    "Revise a definição da função de amplificação G(ξ) para esquemas numéricos em PDEs parabólicas ou hiperbólicas.",
                                    "Estude o critério |G(ξ)| ≤ 1 + O(Δt) para todos os ξ no espectro de frequências.",
                                    "Diferencie dissipação (decaimento de |G(ξ)| < 1 para ξ altos) de estabilidade incondicional vs. condicional.",
                                    "Analise como O(Δt) permite um leve crescimento tolerável devido à truncagem.",
                                    "Discuta o papel do perfil dissipativo em amortecer modos de alta frequência."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o critério e dê um exemplo onde ele falha.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), notas de aula, calculadora simbólica (SymPy).",
                                  "tips": "Comece com esquemas simples como forward Euler para visualizar |G(ξ)|.",
                                  "learningObjective": "Dominar a interpretação matemática do critério de estabilidade dissipativa.",
                                  "commonMistakes": "Confundir |G(ξ)| ≤ 1 estrito com a versão relaxada 1 + O(Δt); ignorar dependência em Δt."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de amplificação G(ξ) para um esquema numérico",
                                  "subSteps": [
                                    "Escolha um esquema modelo, como o esquema implícito de Crank-Nicolson para a equação de calor.",
                                    "Aplique a análise von Neumann: assuma solução u_j^n = g^n e^{i ξ j Δx}.",
                                    "Resolva para G(ξ) = g(ξ), expressando em termos de λΔt (número de Courant) e ξΔx.",
                                    "Simplifique para regimes de alta e baixa frequência (ξ → 0 e ξ → π/Δx).",
                                    "Verifique consistência: lim_{Δt→0} |G(ξ)| → 1."
                                  ],
                                  "verification": "Derive G(ξ) para um esquema dado e plote |G(ξ)| manualmente ou via software.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e lápis, software como MATLAB/Python/Mathematica para plotagem.",
                                  "tips": "Use aproximações trigonométricas: sin(ξΔx/2) ≈ ξΔx/2 para ξ pequenos.",
                                  "learningObjective": "Capacitar derivação analítica de G(ξ) para esquemas lineares.",
                                  "commonMistakes": "Erros em fatores de i ou conjugados complexos; esquecer normalização Δx."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar o critério |G(ξ)| ≤ 1 + O(Δt)",
                                  "subSteps": [
                                    "Calcule |G(ξ)|^2 explicitamente para o esquema.",
                                    "Encontre o máximo de |G(ξ)| sobre ξ ∈ [0, π/Δx].",
                                    "Expanda em série de Taylor em Δt para confirmar O(Δt).",
                                    "Teste numericamente para valores finitos de Δt e ξ.",
                                    "Identifique regiões onde |G(ξ)| > 1 + O(Δt), indicando instabilidade."
                                  ],
                                  "verification": "Produza gráfico de max_ξ |G(ξ)| vs Δt e confirme linearidade em Δt pequeno.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Script Python/MATLAB para computar e plotar |G(ξ)|.",
                                  "tips": "Use loop sobre ξ discretos (ex: 1000 pontos) para máximo numérico preciso.",
                                  "learningObjective": "Aplicar o critério quantitativamente para validar estabilidade.",
                                  "commonMistakes": "Avaliar apenas em ξ=0 (onde |G|=1 sempre); ignorar O(Δt) em grandes Δt."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar esquemas condicionalmente estáveis via perfil dissipativo",
                                  "subSteps": [
                                    "Compare perfis |G(ξ)| para esquemas estáveis/instáveis (ex: upwind vs. Lax-Friedrichs).",
                                    "Identifique condições CFL onde max |G| ≤ 1 + O(Δt).",
                                    "Examine dissipação numérica: quanto |G(ξ)| decai para ξ altos.",
                                    "Discuta trade-offs: mais dissipação melhora estabilidade mas reduz precisão.",
                                    "Simule numericamente uma PDE para validar análise teórica."
                                  ],
                                  "verification": "Gere relatório com plots de |G(ξ)| para diferentes CFL e interprete estabilidade.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Código de simulação numérica (ex: método de elementos finitos simples).",
                                  "tips": "Foque em esquemas com dissipação artificial controlável por parâmetros.",
                                  "learningObjective": "Interpretar perfis dissipativos para prever comportamento condicional.",
                                  "commonMistakes": "Confundir dissipação com dispersão (fase errada); superestimar estabilidade sem checar todos ξ."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e generalizar para PDEs reais",
                                  "subSteps": [
                                    "Aplique a análise a uma PDE não-trivial (ex: equação de onda amortecida).",
                                    "Considere multi-D ou esquemas não-lineares aproximados linearmente.",
                                    "Discuta limitações do critério von Neumann (assumindo periodicidade).",
                                    "Relacione com energia L2: d||u||^2/dt ≤ O(Δt) ||u||^2.",
                                    "Planeje extensões para esquemas adaptativos."
                                  ],
                                  "verification": "Resolva problema de homework: analise estabilidade de um esquema dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos de referência (ex: Gustafsson et al.), quadro branco.",
                                  "tips": "Use norma de energia como verificação alternativa ao von Neumann.",
                                  "learningObjective": "Generalizar a análise para contextos avançados em Análise Numérica.",
                                  "commonMistakes": "Aplicar von Neumann a problemas com fronteiras sem modificações."
                                }
                              ],
                              "practicalExample": "Para o esquema upwind em u_t + a u_x = 0: G(ξ) = 1 - ν (1 - e^{-iξΔx}), onde ν = a Δt/Δx. Plote |G(ξ)| para ν=0.5, 0.9, 1.1; observe que para ν>1, max|G|>1 + O(Δt), confirmando instabilidade, enquanto ν≤1 mostra dissipação crescente com ξ.",
                              "finalVerifications": [
                                "Deriva corretamente G(ξ) para esquemas lineares padrão.",
                                "Identifica condições de estabilidade condicional via max|G(ξ)|.",
                                "Interpreta perfis dissipativos e trade-offs com precisão.",
                                "Aplica critério a exemplos numéricos com plots precisos.",
                                "Explica limitações e conexões com normas de energia.",
                                "Resolve problemas de análise dissipativa sem erros algébricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de G(ξ) (90% correto).",
                                "Correta aplicação e interpretação do critério |G| ≤ 1 + O(Δt).",
                                "Qualidade de plots e análise numérica de perfis.",
                                "Profundidade na discussão de estabilidade condicional.",
                                "Clareza em exemplos práticos e generalizações.",
                                "Identificação de erros comuns e dicas preventivas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de amortecimento em equações de onda/difusão.",
                                "Engenharia Computacional: Estabilidade em CFD e simulações acústicas.",
                                "Ciência da Computação: Análise de algoritmos numéricos paralelizáveis.",
                                "Matemática Aplicada: Séries de Fourier e análise espectral."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos de previsão de tempo), verifica-se dissipação em esquemas para equações de Navier-Stokes para evitar amplificação numérica de ruído em escalas pequenas, garantindo previsões estáveis e realistas."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Implementar análise numérica de G(ξ)",
                            "description": "Usar software como MATLAB ou Python para plotar |G(ξ)| e analisar dissipação em um esquema dado, referenciando bibliografia como LeVeque.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria da função de amplificação G(ξ) e selecionar esquema numérico",
                                  "subSteps": [
                                    "Leia seções relevantes do livro de LeVeque sobre análise von Neumann para esquemas de diferenças finitas.",
                                    "Identifique a equação PDE alvo, como a equação de advecção u_t + a u_x = 0.",
                                    "Escolha um esquema específico, ex: upwind ou Lax-Wendroff, e derive sua matriz de amplificação.",
                                    "Defina o parâmetro ξ = k h, onde k é o número de onda e h o passo espacial.",
                                    "Anote a fórmula explícita de G(ξ) para o esquema escolhido."
                                  ],
                                  "verification": "Escreva um resumo de 1 página com a fórmula de G(ξ) derivada e verifique se |G(0)|=1 e |G(π)|<1 para dissipação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de LeVeque (Finite Difference Methods for ODEs/PDEs)",
                                    "Caderno de anotações",
                                    "Referências online sobre análise von Neumann"
                                  ],
                                  "tips": "Comece com esquemas simples como upwind para validar entendimento antes de esquemas mais complexos.",
                                  "learningObjective": "Compreender a base teórica da função de amplificação e sua relação com dissipação numérica.",
                                  "commonMistakes": "Confundir ξ com outros parâmetros como CFL; ignorar normalização |G(0)|=1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de software e definir parâmetros numéricos",
                                  "subSteps": [
                                    "Instale ou abra MATLAB/Python (recomendado: NumPy, Matplotlib para Python).",
                                    "Defina parâmetros: número de onda ξ de 0 a π, passo CFL λ, coeficiente de advecção a=1.",
                                    "Crie arrays para ξ usando linspace(0, pi, 1000).",
                                    "Implemente constantes do esquema, ex: para upwind, G(ξ) = 1 - λ (1 - exp(-i ξ)).",
                                    "Teste um valor simples: compute G(0) e verifique se é 1."
                                  ],
                                  "verification": "Execute código para ξ=0 e confirme |G(0)| ≈ 1 (erro < 1e-10).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/Matplotlib",
                                    "Editor de código (Jupyter Notebook recomendado)"
                                  ],
                                  "tips": "Use complex numbers corretamente: em Python, 1j para i; em MATLAB, 1i.",
                                  "learningObjective": "Preparar ambiente computacional para análise simbólica e numérica de G(ξ).",
                                  "commonMistakes": "Esquecer de usar números complexos, levando a valores reais incorretos; range errado de ξ (deve ser 0 a π)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo e plotagem de |G(ξ)|",
                                  "subSteps": [
                                    "Codifique a função G(ξ) como função complexa baseada no esquema.",
                                    "Compute |G(ξ)| = abs(G(xi)) para o array de ξ.",
                                    "Crie plot: ξ no eixo x (0 a π), |G(ξ)| no eixo y, use semilogx para dissipação.",
                                    "Adicione linha |G|=1 como referência e legendas.",
                                    "Salve figura como PNG/PDF."
                                  ],
                                  "verification": "Plot mostra |G(ξ)| ≤ 1 para todo ξ, com decaimento visível em altas frequências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Documentação Matplotlib/Plot MATLAB"
                                  ],
                                  "tips": "Use semilogx(x, absG) para destacar dissipação em baixas amplitudes.",
                                  "learningObjective": "Desenvolver habilidades de programação numérica para visualização de análise de estabilidade.",
                                  "commonMistakes": "Erro na fase: usar cos/sin incorretos; plot linear em vez de semilog."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar dissipação e referenciar bibliografia",
                                  "subSteps": [
                                    "Identifique regiões onde |G(ξ)| < 1 (dissipação) e compare com teoria de LeVeque.",
                                    "Calcule taxa de dissipação: ex, slope de log(|G|) vs ξ em altas frequências.",
                                    "Compare plots para diferentes esquemas (upwind vs central).",
                                    "Documente insights: ex, upwind dissipa altas frequências efetivamente.",
                                    "Cite seções específicas de LeVeque e salve relatório com plots."
                                  ],
                                  "verification": "Relatório de 1-2 páginas explica pelo menos 3 observações sobre dissipação com referências.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Plots gerados",
                                    "Livro de LeVeque",
                                    "Template de relatório LaTeX/Word"
                                  ],
                                  "tips": "Quantifique: compute max(|G(ξ)|) e min para objetividade.",
                                  "learningObjective": "Interpretar resultados numéricos no contexto teórico de dissipação em PDEs.",
                                  "commonMistakes": "Análise qualitativa sem quantificação; ignorar dependência em CFL."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e iterar análise para variação de parâmetros",
                                  "subSteps": [
                                    "Varie CFL (0.1 a 0.9) e re-plot |G(ξ)| para cada.",
                                    "Analise estabilidade: regiões onde |G|>1 indicam instabilidade.",
                                    "Teste esquema diferente e compare dissipação.",
                                    "Execute simulação 1D simples da PDE para validar numericamente.",
                                    "Atualize relatório com conclusões finais."
                                  ],
                                  "verification": "Todos plots mostram consistência com teoria; simulação 1D converge sem oscilações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código reutilizável",
                                    "Solver numérico simples para PDE"
                                  ],
                                  "tips": "Automatize loops sobre CFL para eficiência.",
                                  "learningObjective": "Aplicar análise paramétrica para otimização de esquemas numéricos.",
                                  "commonMistakes": "CFL >1 levando a instabilidade artificial; não normalizar plots."
                                }
                              ],
                              "practicalExample": "Para o esquema upwind na equação de advecção com a=1, λ=0.5: implemente G(ξ) = 1 - 0.5*(1 - exp(-1j*ξ)), plote |G(ξ)| mostrando dissipação forte em ξ próximo a π, confirmando amortecimento de modos oscilatórios de alta frequência em simulações de ondas.",
                              "finalVerifications": [
                                "Plot de |G(ξ)| exibe decaimento monotônico ou esperado para o esquema.",
                                "Todos valores |G(ξ)| ≤ 1 + 1e-10 para estabilidade.",
                                "Relatório cita pelo menos duas seções de LeVeque com fórmulas corretas.",
                                "Análise identifica pelo menos uma métrica quantitativa de dissipação (ex: slope em log scale).",
                                "Código é reproduzível e comentado.",
                                "Variação com CFL mostra impacto correto na dissipação."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação de G(ξ): erro <1e-8 em testes analíticos.",
                                "Qualidade visual e legibilidade dos plots (escalas, labels, múltiplos esquemas).",
                                "Profundidade da análise: ligação explícita entre plot e comportamento dissipativo.",
                                "Referenciação bibliográfica precisa e relevante.",
                                "Robustez do código: funciona para múltiplos parâmetros sem erros.",
                                "Insights originais sobre trade-offs dissipação vs dispersão."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: uso avançado de arrays complexos e plotting.",
                                "Física Computacional: aplicação em modelagem de ondas e fluidos.",
                                "Engenharia Numérica: otimização de solvers CFD.",
                                "Estatística: análise quantitativa de decaimento exponencial."
                              ],
                              "realWorldApplication": "Em simulações CFD para previsão de clima ou aerodinâmica, essa análise garante que esquemas numéricos dissipem ruído numérico sem distorcer soluções físicas, evitando instabilidades em previsões de longo prazo como furacões ou fluxo turbulento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Análise de Dispersão via Relação de Dispersão",
                    "description": "Relação de dispersão que compara frequências numéricas e físicas, identificando erros de fase em aproximações numéricas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Solução Física e Frequência Exata",
                        "description": "Compreender a solução analítica de equações de onda hiperbólicas e a relação de dispersão física, onde a frequência ω é igual à velocidade de fase vezes o número de onda k (ω = c k), servindo como referência para comparações numéricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Identificar a equação de onda unidimensional",
                            "description": "Reconhecer a forma padrão da equação de onda ∂²u/∂t² = c² ∂²u/∂x² e suas soluções de onda plana u(x,t) = e^{i(kx - ω t)}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar derivadas parciais e equações diferenciais de segunda ordem",
                                  "subSteps": [
                                    "Estude a notação de derivadas parciais ∂u/∂x e ∂²u/∂x².",
                                    "Revise equações diferenciais parciais (EDPs) hiperbólicas versus parabólicas.",
                                    "Identifique termos temporais ∂²u/∂t² e espaciais ∂²u/∂x² em EDPs.",
                                    "Pratique calculando derivadas parciais de funções simples como u(x,t) = sin(x)t.",
                                    "Compare com equação de calor ∂u/∂t = α ∂²u/∂x² para diferenciar."
                                  ],
                                  "verification": "Escreva corretamente as derivadas parciais de u(x,t) = f(x)t² e explique a diferença entre EDPs hiperbólicas e parabólicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Calculadora",
                                    "Referência de EDPs (PDF ou livro)"
                                  ],
                                  "tips": "Use diagramas para visualizar como ondas se propagam em 1D.",
                                  "learningObjective": "Compreender os blocos de construção matemáticos da equação de onda.",
                                  "commonMistakes": "Confundir ∂²u/∂t² com ∂u/∂t (equação de calor) ou ignorar o fator c²."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a forma padrão da equação de onda unidimensional",
                                  "subSteps": [
                                    "Memorize a forma canônica: ∂²u/∂t² = c² ∂²u/∂x², onde c é a velocidade de fase.",
                                    "Derive brevemente de modelo físico: tensão em corda vibrante.",
                                    "Identifique condições de contorno e iniciais típicas (u(0,t)=0, ∂u/∂t(x,0)=0).",
                                    "Escreva exemplos numéricos com c=1 para simplicidade.",
                                    "Destaque simetria temporal-espacial e propriedades de propagação."
                                  ],
                                  "verification": "Reescreva a equação de onda a partir de memória e identifique c² como coeficiente de propagação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de equações como LaTeX ou MathJax online"
                                  ],
                                  "tips": "Pense em c como velocidade da onda; teste com valores reais como som no ar (c≈343 m/s).",
                                  "learningObjective": "Reconhecer instantaneamente a equação de onda em qualquer notação.",
                                  "commonMistakes": "Escrever incorretamente como ∂u/∂t² ou esquecer o quadrado nas derivadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar soluções de onda plana u(x,t) = e^{i(kx - ω t)}",
                                  "subSteps": [
                                    "Verifique se satisfaz a equação: compute ∂²u/∂t² = -ω² u e ∂²u/∂x² = -k² u, logo ω = c k.",
                                    "Entenda relação de dispersão ω(k) = c k (não dispersiva).",
                                    "Interprete k como número de onda e ω como frequência angular.",
                                    "Converta para forma real: u(x,t) = A cos(kx - ω t + φ).",
                                    "Plote graficamente para t fixo e x fixo para visualizar propagação."
                                  ],
                                  "verification": "Substitua u(x,t) = e^{i(kx - ω t)} na equação e derive ω = c k corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora complexa ou Python/Mathematica para plotar",
                                    "Gráficos de ondas online"
                                  ],
                                  "tips": "Use Euler: e^{iθ} = cosθ + i sinθ para validar soluções reais.",
                                  "learningObjective": "Associar soluções planas à equação de onda e sua relação de dispersão.",
                                  "commonMistakes": "Confundir ω t com ω + t ou esquecer o sinal negativo em -ω t."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em contextos variados",
                                  "subSteps": [
                                    "Analise EDPs dadas e classifique como equação de onda.",
                                    "Compare com onda em 2D/3D: ∂²u/∂t² = c² ∇² u.",
                                    "Resolva problema simples: onda em corda infinita.",
                                    "Identifique em código numérico (método de diferenças finitas).",
                                    "Crie variações: mude c para material diferente."
                                  ],
                                  "verification": "Dado uma EDP aleatória, identifique se é equação de onda e escreva sua solução plana.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online (Khan Academy, MIT OCW)",
                                    "Notebook Jupyter para simulação"
                                  ],
                                  "tips": "Sempre verifique dimensionalmente: [c] = velocidade para consistência.",
                                  "learningObjective": "Aplicar reconhecimento em problemas reais e numéricos.",
                                  "commonMistakes": "Não reconhecer generalizações como com coeficientes variáveis."
                                }
                              ],
                              "practicalExample": "Simule uma corda de violão vibrando: a displacamento u(x,t) segue ∂²u/∂t² = c² ∂²u/∂x² com c≈400 m/s. Use Python para plotar u(x,t)=sin(πx/L)cos(π c t /L) e observe propagação sem distorção.",
                              "finalVerifications": [
                                "Escreve corretamente ∂²u/∂t² = c² ∂²u/∂x² de memória.",
                                "Deriva ω = c k para u(x,t) = e^{i(kx - ω t)}.",
                                "Diferencia de equação de difusão ∂u/∂t = α ∂²u/∂x².",
                                "Plota uma onda plana e explica propagação.",
                                "Identifica em um problema físico real (onda sonora).",
                                "Explica não-dispersividade da equação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escrita da forma padrão (100% correto).",
                                "Correta substituição e verificação da solução plana.",
                                "Explicação clara da relação de dispersão ω = c k.",
                                "Identificação correta em 4/5 EDPs dadas.",
                                "Interpretação física adequada (velocidade c).",
                                "Ausência de erros em derivadas parciais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica ondulatória e acústica.",
                                "Engenharia: Simulações numéricas em CFD e propagação de sinais.",
                                "Computação: Métodos de elementos finitos para EDPs.",
                                "Matemática: Análise de Fourier e transformadas.",
                                "Geofísica: Modelagem de ondas sísmicas."
                              ],
                              "realWorldApplication": "Modelagem de ondas sonoras em microfones, vibrações em pontes (análise modal), propagação de sinais em fibras óticas e simulações sísmicas para previsão de terremotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Calcular a frequência física",
                            "description": "Derivar a relação de dispersão física ω(k) = c |k| para ondas planas e calcular a velocidade de fase c = ω/k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de onda unidimensional e soluções de onda plana",
                                  "subSteps": [
                                    "Escreva a equação de onda ∂²u/∂t² = c² ∂²u/∂x², onde c é a velocidade de propagação.",
                                    "Identifique as condições iniciais e de contorno para ondas planas em meios infinitos.",
                                    "Assuma a forma de solução u(x,t) = A exp(i(kx - ωt)) para ondas planas complexas.",
                                    "Explique o significado físico de k (número de onda) e ω (frequência angular).",
                                    "Verifique a realidade da solução tomando a parte real."
                                  ],
                                  "verification": "Confirme que a equação de onda está corretamente escrita e a forma da solução plana é padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Física Matemática ou Análise Numérica"
                                  ],
                                  "tips": "Use representação complexa para simplificar derivações, mas lembre-se de tomar parte real no final.",
                                  "learningObjective": "Compreender a base matemática das ondas planas e sua representação exponencial.",
                                  "commonMistakes": "Confundir ω com f (frequência cíclica: ω = 2πf) ou esquecer o módulo |k| para ondas em ambas direções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Substituir a solução de onda plana na equação de onda",
                                  "subSteps": [
                                    "Calcule as derivadas espaciais: ∂u/∂x = i k u, ∂²u/∂x² = -k² u.",
                                    "Calcule as derivadas temporais: ∂u/∂t = -i ω u, ∂²u/∂t² = -ω² u.",
                                    "Substitua na equação de onda: -ω² u = c² (-k² u).",
                                    "Simplifique dividindo por -u (assumindo u ≠ 0): ω² = c² k².",
                                    "Extraia a raiz: ω = c |k|, justificando o valor absoluto para frequência positiva."
                                  ],
                                  "verification": "Verifique se ω² = c² k² leva corretamente a ω(k) = c |k|.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como Mathematica/MATLAB",
                                    "Folha de derivadas"
                                  ],
                                  "tips": "Mantenha a forma complexa durante cálculos para evitar erros de sinal.",
                                  "learningObjective": "Derivar analiticamente a relação de dispersão a partir da equação diferencial.",
                                  "commonMistakes": "Esquecer o sinal negativo nas segundas derivadas ou não usar |k| para k negativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a relação de dispersão ω(k) = c |k|",
                                  "subSteps": [
                                    "Plote mentalmente ou esboce ω vs k: gráfico linear com inclinação c para k>0 e simétrico.",
                                    "Identifique que é não-dispersiva: velocidade independente de k.",
                                    "Compare com relações dispersivas (ex: ω = √(g k) para ondas de água).",
                                    "Discuta simetria para ondas viajando em +x e -x.",
                                    "Confirme dimensionalmente: [ω] = 1/T, [k]=1/L, [c]=L/T."
                                  ],
                                  "verification": "Esboço do gráfico ω(k) mostra linearidade e simetria.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfica ou software de plotagem como Desmos/Python"
                                  ],
                                  "tips": "Pense em termos físicos: frequência aumenta linearmente com número de onda.",
                                  "learningObjective": "Reconhecer propriedades de dispersão não-dispersiva.",
                                  "commonMistakes": "Confundir dispersão (dependência v_f de k) com dissipação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a velocidade de fase c = ω / k",
                                  "subSteps": [
                                    "Defina velocidade de fase v_p = ω / k para k > 0.",
                                    "Substitua ω(k): v_p = (c |k|) / k = c (sign(k)), que é c para k>0 e -c para k<0.",
                                    "Calcule numericamente para exemplo: k=2π/λ, ω=2πf, c=f λ.",
                                    "Verifique consistência: para onda sonora, c≈343 m/s no ar.",
                                    "Discuta relação com velocidade de grupo v_g = dω/dk = c sign(k)."
                                  ],
                                  "verification": "Cálculo de v_p resulta em ±c, confirmando propagação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos numéricos prontos",
                                    "Tabela de velocidades de onda reais"
                                  ],
                                  "tips": "Sempre especifique direção de propagação via sinal de k.",
                                  "learningObjective": "Calcular e interpretar velocidades de fase e grupo.",
                                  "commonMistakes": "Dividir por |k| em vez de k, perdendo direção."
                                }
                              ],
                              "practicalExample": "Para uma onda sonora no ar com λ=1m (k=2π rad/m), c=343 m/s, calcule ω = 343 * 2π ≈ 2154 rad/s, então v_p = ω/k = 343 m/s, confirmando propagação sem dispersão.",
                              "finalVerifications": [
                                "Relação derivada: ω(k) = c |k| está correta e simétrica.",
                                "Velocidade de fase calculada como c = ω/k para k>0.",
                                "Gráfico de dispersão esboçado corretamente.",
                                "Exemplo numérico resolvido sem erros dimensionais.",
                                "Diferença entre v_p e v_g explicitada.",
                                "Justificativa física para não-dispersividade fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das segundas derivadas (sem erros de sinal).",
                                "Correto uso de |k| na relação de dispersão.",
                                "Cálculo exato de v_p com direção apropriada.",
                                "Interpretação física clara e concisa.",
                                "Exemplo prático com valores reais e verificação.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas mecânicas, acústica e óptica.",
                                "Engenharia: Simulação numérica de PDEs em CFD.",
                                "Computação: Análise de estabilidade em métodos numéricos (Courant-Friedrichs-Lewy).",
                                "Física Computacional: Esquemas de diferenças finitas para equações de onda."
                              ],
                              "realWorldApplication": "Em simulações de propagação de ondas sísmicas ou sonar, a relação ω(k)=c|k| garante precisão na modelagem de velocidades de fase para previsão de terremotos ou detecção submarina, evitando erros em análises numéricas dispersivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Interpretar propagação física de ondas",
                            "description": "Explicar como a relação ω = c k implica propagação sem dispersão na solução física exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Ondas",
                                  "subSteps": [
                                    "Defina frequência angular ω e número de onda k em termos de frequência f e comprimento de onda λ.",
                                    "Explique a forma geral de uma onda plana: ψ(x,t) = A cos(kx - ωt).",
                                    "Calcule a velocidade de fase v_p = ω / k.",
                                    "Discuta a solução exata da equação de onda unidimensional ∂²ψ/∂t² = c² ∂²ψ/∂x².",
                                    "Identifique componentes harmônicas em uma onda arbitrária via transformada de Fourier."
                                  ],
                                  "verification": "Escreva as definições e derive v_p para uma onda exemplo; confirme que ψ satisfaz a equação de onda.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Física (Cap. Ondas), calculadora, papel para derivações.",
                                  "tips": "Use notação consistente: ω = 2πf, k = 2π/λ.",
                                  "learningObjective": "Compreender os blocos de construção matemáticos de ondas físicas.",
                                  "commonMistakes": "Confundir ω com f ou k com 1/λ sem fator 2π."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Relação de Dispersão ω = c k",
                                  "subSteps": [
                                    "Derive ω = c k a partir da equação de onda assumindo soluções ψ ~ e^{i(kx - ωt)}.",
                                    "Calcule a velocidade de grupo v_g = dω/dk.",
                                    "Mostre que v_p = v_g = c para esta relação linear.",
                                    "Compare com relações dispersivas como ω = c k² (equação de Schrödinger).",
                                    "Verifique dimensionalmente: [ω] = 1/T, [k] = 1/L, [c] = L/T."
                                  ],
                                  "verification": "Derive explicitamente ω(k) e v_g; plote ω vs k para linearidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matplotlib ou Desmos), notas de aula sobre EDOs.",
                                  "tips": "Substitua na equação de onda: -ω² = -c² k² ⇒ ω = ± c k.",
                                  "learningObjective": "Dominar a origem e propriedades da relação de dispersão não-dispersiva.",
                                  "commonMistakes": "Esquecer o sinal negativo na derivada temporal ou confundir v_p com v_g."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Ausência de Dispersão na Propagação",
                                  "subSteps": [
                                    "Defina dispersão como dependência de v_p em ω ou k, causando deformação de pacotes de ondas.",
                                    "Mostre que para ω = c k, todas as componentes viajam a c, preservando forma.",
                                    "Decomponha uma pulso inicial em Fourier e some após propagação t: ψ(x,t) = ∫ ψ̂(k) e^{i k (x - c t)} dk.",
                                    "Demonstre que o perfil se desloca rigidamente sem espalhamento.",
                                    "Contraste com esquemas numéricos onde ω_num(k) ≠ c k, introduzindo dispersão."
                                  ],
                                  "verification": "Simule numericamente uma soma de Fourier antes/depois de t; confirme deslocamento sem mudança de forma.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy para FFT, tutorial de Fourier.",
                                  "tips": "Use pulso gaussiano: ψ(x,0) = e^{-x²/2}; verifique ∫ |ψ(x,t)|² dx = constante.",
                                  "learningObjective": "Interpretar matematicamente por que a solução exata não dispersa.",
                                  "commonMistakes": "Pensar que linearidade sempre implica não-dispersão (ex: plasma tem dispersão linear ω² = ω_p² + c² k²)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Fisicamente a Propagação sem Dispersão",
                                  "subSteps": [
                                    "Relacione à conservação de energia e momento em meios não-dispersivos.",
                                    "Discuta exemplos físicos: ondas sonoras em ar ideal, EM no vácuo.",
                                    "Explique implicações para soluções numéricas: erro de fase por dispersão numérica.",
                                    "Calcule erro de fase: Δφ = (ω_num - ω_exata) t.",
                                    "Sintetize: solução exata propaga fielmente devido a ω ∝ k.",
                                    "Crie diagrama de dispersão ω(k)."
                                  ],
                                  "verification": "Escreva parágrafo explicando implicações físicas e numéricas; inclua diagrama.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel para diagrama, referências físicas (Griffiths ou similar).",
                                  "tips": "Foco em 'todas frequências viajam igual' para intuição física.",
                                  "learningObjective": "Conectar matemática à física real e análise numérica.",
                                  "commonMistakes": "Ignorar que soluções exatas são ideais; sempre mencionar limitações reais (ex: não-linearidades)."
                                }
                              ],
                              "practicalExample": "Considere uma onda sonora propagando em ar: um pulso curto de 1 ms mantém sua forma ao viajar 340 m/s, sem espalhamento de baixas frequências, pois ω = c k garante v_p constante para todo espectro.",
                              "finalVerifications": [
                                "Deriva corretamente ω = c k da equação de onda.",
                                "Calcula v_p = v_g = c e explica igualdade.",
                                "Decompõe pulso via Fourier e mostra propagação rígida.",
                                "Identifica dispersão numérica vs exata.",
                                "Desenha diagrama ω(k) linear.",
                                "Explica fisicamente com exemplo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (80% peso).",
                                "Clareza na distinção dispersão/exata (15%).",
                                "Uso correto de Fourier e velocidades (5%).",
                                "Profundidade de interpretação física.",
                                "Ausência de erros conceituais comuns.",
                                "Qualidade do exemplo prático e diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Física: Equação de onda e óptica geométrica.",
                                "Engenharia: Simulações CFD e métodos finitos.",
                                "Computação: Análise de estabilidade numérica (von Neumann).",
                                "Acústica: Projeto de alto-falantes sem distorção.",
                                "Geofísica: Propagação sísmica P-waves."
                              ],
                              "realWorldApplication": "Em simulações numéricas de ondas sísmicas ou acústicas, entender ω = c k guia escolha de esquemas sem dispersão artificial, essencial para previsão precisa de terremotos ou design de ultrassom médico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Análise von Neumann em Esquemas Numéricos",
                        "description": "Aplicar o método de von Neumann para obter o símbolo de amplificação e introduzir o ângulo de fase numérico θ = k Δx em esquemas de diferenças finitas para equações hiperbólicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Aplicar ansatz de von Neumann",
                            "description": "Substituir u_j^n = e^{i(θ j - Ω n)} em um esquema explícito como FTCS para obter a equação de amplificação g(θ) = e^{-i Ω}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e formular o esquema numérico explícito FTCS",
                                  "subSteps": [
                                    "Escolha a equação diferencial parcial (PDE) de referência, como a equação de calor u_t = ν u_xx ou advecção.",
                                    "Escreva a discretização FTCS: u_j^{n+1} = u_j^n + r (u_{j+1}^n - 2 u_j^n + u_{j-1}^n), onde r = ν Δt / Δx².",
                                    "Verifique os índices espaciais (j) e temporais (n) e os coeficientes de estabilidade.",
                                    "Anote os parâmetros Δt, Δx e o número de Courant ou r.",
                                    "Confirme que o esquema é explícito (u^{n+1} depende apenas de u^n)."
                                  ],
                                  "verification": "O esquema FTCS está corretamente escrito e corresponde à PDE escolhida, sem erros nos operadores de diferença finita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica (capítulo de métodos explícitos)",
                                    "Calculadora para verificar r"
                                  ],
                                  "tips": "Sempre normalize os termos pela malha Δx e Δt para evitar confusões dimensionais.",
                                  "learningObjective": "Dominar a formulação precisa do esquema FTCS para PDEs parabólicas ou hiperbólicas.",
                                  "commonMistakes": [
                                    "Confundir FTCS com esquemas implícitos como BTCS",
                                    "Erros nos sinais das diferenças centrais",
                                    "Omitir o fator r corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o ansatz de von Neumann",
                                  "subSteps": [
                                    "Defina a forma de Fourier plana: u_j^n = e^{i (θ j - Ω n)}, onde θ = k Δx é o número de onda não-dimensional e Ω = ω Δt.",
                                    "Calcule as derivadas temporais: u_j^{n+1} = e^{i (θ j - Ω (n+1))} = e^{-i Ω} u_j^n.",
                                    "Identifique a fator de amplificação temporal g(θ) = e^{-i Ω}, que deve ser unitário em módulo para esquemas não dissipativos.",
                                    "Explique o significado: representa modos de Fourier independentes na malha.",
                                    "Verifique a normalização: |g(θ)| ≤ 1 para estabilidade."
                                  ],
                                  "verification": "O ansatz está corretamente definido e u_j^{n+1} = g(θ) u_j^n é explícito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de identidades trigonométricas",
                                    "Software simbólico como Mathematica (opcional)"
                                  ],
                                  "tips": "Lembre-se que θ varia de 0 a 2π para cobrir todos os modos, incluindo o modo 2Δx (θ=π).",
                                  "learningObjective": "Compreender a motivação física do ansatz como superposição de ondas planas.",
                                  "commonMistakes": [
                                    "Usar e^{i (θ j + Ω n)} em vez de subtração",
                                    "Confundir θ com k (comprimento de onda)",
                                    "Esquecer o fator i na exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir o ansatz no esquema FTCS",
                                  "subSteps": [
                                    "Substitua u_j^n pelo ansatz em todos os termos do esquema: u_j^n → e^{i (θ j - Ω n)}.",
                                    "Simplifique os vizinhos espaciais: u_{j+1}^n = e^{i θ} u_j^n, u_{j-1}^n = e^{-i θ} u_j^n.",
                                    "Escreva o esquema amplificado: g(θ) u_j^n = u_j^n + r (e^{i θ} - 2 + e^{-i θ}) u_j^n.",
                                    "Use identidade e^{i θ} + e^{-i θ} = 2 cos θ para compactar.",
                                    "Divida por u_j^n (assumindo ≠0) para isolar g(θ)."
                                  ],
                                  "verification": "Todos os termos do esquema foram substituídos corretamente, resultando em uma equação para g(θ).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Identidades de Euler: e^{iθ} = cos θ + i sin θ"
                                  ],
                                  "tips": "Fatore u_j^n para simplificar imediatamente; isso evita erros algébricos.",
                                  "learningObjective": "Executar substituição algébrica precisa no contexto de análise de estabilidade.",
                                  "commonMistakes": [
                                    "Erro nos expoentes para u_{j±1}^n",
                                    "Não dividir por u_j^n ao final",
                                    "Confundir o tempo n+1 apenas no lado esquerdo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e interpretar a equação de amplificação g(θ) = e^{-i Ω}",
                                  "subSteps": [
                                    "Simplifique: g(θ) = 1 + r (2 cos θ - 2) = 1 - 4 r sin²(θ/2).",
                                    "Compare com a solução exata: para equação de calor, g_exata ≈ e^{- (θ² ν Δt / Δx²)}.",
                                    "Identifique dispersão (fase errada de Ω) e dissipação (|g| <1).",
                                    "Plote |g(θ)| e arg(g(θ)) vs θ para θ ∈ [0, π].",
                                    "Conclua condições de estabilidade: r ≤ 1/2 para |g| ≤1."
                                  ],
                                  "verification": "g(θ) está simplificada corretamente e condições de estabilidade derivadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos em Python/MATLAB para |g(θ)|",
                                    "Software de plotagem"
                                  ],
                                  "tips": "Use sin²(θ/2) = (1 - cos θ)/2 para verificação trigonométrica.",
                                  "learningObjective": "Interpretar g(θ) em termos de dispersão, dissipação e estabilidade.",
                                  "commonMistakes": [
                                    "Erro na identidade trigonométrica",
                                    "Ignorar o modo θ=π (oscilação checkerboard)",
                                    "Confundir amplificação com fase"
                                  ]
                                }
                              ],
                              "practicalExample": "Para FTCS na equação de calor u_t = u_xx (ν=1), com r=0.1: g(θ) = 1 - 0.4 sin²(θ/2). Calcule |g(π)| ≈ 0.64 <1 (dissipativo) e arg(g(0))=0 (sem dispersão em onda longa).",
                              "finalVerifications": [
                                "Pode derivar g(θ) para FTCS sem consultar notas.",
                                "Identifica corretamente |g(θ)| ≤1 para todo θ.",
                                "Explica dispersão como desvio de Ω da solução exata.",
                                "Aplica a condição r ≤ 1/2 para estabilidade.",
                                "Plota g(θ) e interpreta picos de erro em θ=π.",
                                "Compara com solução exata e^{-θ² r}."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de g(θ) (sem erros de sinal ou fator).",
                                "Correta interpretação física de |g| (dissipação) e arg(g) (dispersão).",
                                "Condições de estabilidade derivadas matematicamente.",
                                "Uso apropriado de identidades trigonométricas.",
                                "Análise qualitativa para diferentes valores de r e θ.",
                                "Clareza na apresentação dos passos intermediários."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações de onda e difusão (mecânica quântica, acústica).",
                                "Computação Científica: Implementação e teste de estabilidade em códigos CFD (Python/NumPy).",
                                "Engenharia: Simulações numéricas em aerodinâmica e previsão meteorológica.",
                                "Matemática Pura: Teoria de Fourier e análise assintótica de erros."
                              ],
                              "realWorldApplication": "Na modelagem computacional de dinâmica de fluidos (CFD) e previsão climática, onde a análise von Neumann garante que simulações de longo prazo não explodam devido a instabilidades numéricas, evitando erros catastróficos em previsões de furacões ou turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Calcular símbolo de amplificação",
                            "description": "Derivar |g(θ)| ≤ 1 para estabilidade e identificar a frequência numérica Ω(θ) a partir de arg(g(θ)) = -Ω.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise von Neumann",
                                  "subSteps": [
                                    "Explicar a motivação: analisar estabilidade e dispersão de esquemas numéricos para PDEs via amplificação de modos de Fourier.",
                                    "Introduzir a ansatz de solução: assumir u_j^n = g^n e^{i θ j}, onde θ = k Δx é o número de onda numérico.",
                                    "Relacionar θ com frequência física: k = 2π/λ, e identificar o espectro relevante θ ∈ [0, 2π].",
                                    "Discutir condições de estabilidade CFL e relação de dispersão geral.",
                                    "Esboçar o esquema numérico genérico: u^{n+1} = A u^n, levando à equação de amplificação."
                                  ],
                                  "verification": "Escrever corretamente a ansatz de Fourier e substitui-la em um esquema simples, obtendo a equação para g(θ).",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica II",
                                    "Livro 'Finite Difference Schemes and Partial Differential Equations' de LeVeque (cap. 3)",
                                    "Papel e lápis ou software como Mathematica/MATLAB para símbolos"
                                  ],
                                  "tips": "Sempre normalize θ em [-π, π] para cobrir todos os modos numéricos sem aliasing.",
                                  "learningObjective": "Compreender a base teórica da análise von Neumann e preparar a derivação do símbolo de amplificação.",
                                  "commonMistakes": [
                                    "Confundir θ (numérico) com ω (físico)",
                                    "Esquecer o expoente n em g^n",
                                    "Ignorar o domínio completo de θ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Símbolo de Amplificação g(θ)",
                                  "subSteps": [
                                    "Selecionar um esquema numérico específico (ex: upwind para u_t + u_x = 0: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), λ = Δt/Δx).",
                                    "Substituir u_j^n = g^n e^{i θ j} em ambos os lados do esquema.",
                                    "Simplificar usando e^{i θ (j-1)} = e^{i θ j} e^{-i θ}, isolando g(θ).",
                                    "Generalizar para esquemas lineares: g(θ) = soma de coeficientes vezes e^{i θ k} para shifts k.",
                                    "Verificar algebricamente para o exemplo: g(θ) = 1 - λ (1 - e^{-i θ})."
                                  ],
                                  "verification": "Derivar g(θ) explicitamente para o esquema upwind e expressá-lo em forma polar: |g| e^{i arg(g)}.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Software simbólico como SymPy ou MATLAB Symbolic Toolbox",
                                    "Exemplos de esquemas de aula",
                                    "Calculadora ou papel para expansões trigonométricas"
                                  ],
                                  "tips": "Expanda e^{-i θ} = cos θ - i sin θ imediatamente para facilitar cálculos.",
                                  "learningObjective": "Dominar a derivação algébrica do símbolo de amplificação a partir de qualquer stencil finito.",
                                  "commonMistakes": [
                                    "Erro de sinal no expoente de Fourier",
                                    "Confundir shifts forward/backward",
                                    "Não isolar g corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade via |g(θ)| ≤ 1",
                                  "subSteps": [
                                    "Calcular |g(θ)|^2 = g(θ) \bar{g(θ)} ou usar |1 - λ(1 - e^{-iθ})|^2 para o exemplo.",
                                    "Simplificar trigonometricamente: |g(θ)|^2 = 1 - 4λ(1-λ) sin^2(θ/2).",
                                    "Verificar |g(θ)| ≤ 1 ∀ θ ∈ [0, 2π], identificando condição CFL: 0 < λ ≤ 1.",
                                    "Plotar |g(θ)| vs θ para visualizar amplificação/dissipação.",
                                    "Discutir implicações: |g| >1 leva a instabilidade exponencial."
                                  ],
                                  "verification": "Provar que |g(θ)| ≤ 1 para λ ∈ [0,1] e identificar θ onde |g| é máximo/mínimo.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "MATLAB/Python (NumPy/Matplotlib) para plotar |g(θ)|",
                                    "Tabela de identidades trigonométricas"
                                  ],
                                  "tips": "Use a identidade sin^2(φ/2) = (1 - cos φ)/2 para simplificações.",
                                  "learningObjective": "Avaliar estabilidade de esquemas numéricos através da norma do símbolo de amplificação.",
                                  "commonMistakes": [
                                    "Calcular |g| em vez de |g|^2 inicialmente",
                                    "Esquecer de checar todos θ",
                                    "Ignorar λ=0 trivial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Frequência Numérica Ω(θ) via arg(g(θ)) = -Ω",
                                  "subSteps": [
                                    "Calcular arg(g(θ)) = Im(log g(θ)) ou atan2(Im(g), Re(g)) para o exemplo.",
                                    "Para upwind: arg(g) = -λ sin θ / |g(θ)| aproximado, mas exato via fórmula.",
                                    "Definir Ω(θ) = -arg(g(θ)) / Δt, comparando com frequência física ω = sin(k Δx).",
                                    "Analisar dispersão: plotar Ω(θ) vs θ, verificando se Ω(θ)/ω(k) ≈1 para precisão.",
                                    "Interpretar erros de fase: atraso ou avanço de fase em ondas numéricas."
                                  ],
                                  "verification": "Computar e plotar Ω(θ) para o esquema, identificando dispersão não-linear.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Python com NumPy/Scipy para arg e plots",
                                    "Referência sobre relação de dispersão"
                                  ],
                                  "tips": "Use unwrap(phase) em plots para continuidade em [0,2π].",
                                  "learningObjective": "Extrair e interpretar a relação de dispersão do argumento do símbolo de amplificação.",
                                  "commonMistakes": [
                                    "Sinal errado em Ω = -arg(g)",
                                    "Não normalizar arg em [-π,π]",
                                    "Confundir dispersão com dissipação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema upwind de primeira ordem na equação de advecção u_t + u_x = 0: u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n). Derivação: g(θ) = 1 - λ (1 - e^{-iθ}). Então |g(θ)|^2 = [1 - λ + λ cos θ]^2 + [λ sin θ]^2 ≤1 para λ≤1. Ω(θ) = -arg(g(θ)), mostrando dispersão com ondas curtas viajando mais devagar.",
                              "finalVerifications": [
                                "Derivar g(θ) corretamente para esquemas dados (upwind, Lax-Friedrichs).",
                                "Provar |g(θ)| ≤1 com condição CFL explícita.",
                                "Plotar |g(θ)| e arg(g(θ)) mostrando estabilidade e dispersão.",
                                "Identificar Ω(θ) e comparar com dispersão física exata.",
                                "Explicar impacto de violações em simulações reais.",
                                "Generalizar para esquemas multi-D ou não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de g(θ) (sem erros de sinal ou expansão).",
                                "Correta verificação de |g(θ)| ≤1 com prova analítica ou numérica.",
                                "Interpretação qualitativa/quantitativa de Ω(θ) e erros de dispersão.",
                                "Qualidade de plots e análise visual de comportamento em todo espectro θ.",
                                "Capacidade de conectar resultados a propriedades do esquema (dissipativo/dispersivo).",
                                "Clareza na documentação de passos e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas e propagação em meios dispersivos (equações de onda/telegráfico).",
                                "Computação Científica: Implementação e debugging de solvers PDE em CFD (OpenFOAM, FEniCS).",
                                "Engenharia: Análise de estabilidade em simulações de fluidos e estruturas.",
                                "Estatística: Análise espectral e FFT para validação numérica."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos computacional (CFD) para aviação e previsão meteorológica, onde esquemas estáveis com baixa dispersão garantem precisão em previsões de turbulência e frentes de onda sem amplificação numérica espúria."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Relação de Dispersão e Erros de Fase",
                        "description": "Derivar a relação de dispersão numérica Ω(θ)/Δt vs k Δx = θ, comparando com a física para quantificar erros de dispersão (desvio de fase) em aproximações numéricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Derivar a relação de dispersão numérica",
                            "description": "Obter Ω(θ) = (1/Δt) acos( ... ) para esquemas como Lax-Wendroff e plotar ω_num(k Δx) vs ω_fís(k Δx).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema numérico e assumir solução plano-onda",
                                  "subSteps": [
                                    "Identifique o esquema alvo, como Lax-Wendroff para a equação de advecção u_t + a u_x = 0.",
                                    "Escreva a stencil do esquema: u_j^{n+1} = u_j^n - (σ/2)(u_{j+1}^n - u_{j-1}^n) + (σ^2/2)(u_{j+1}^n - 2u_j^n + u_{j-1}^n), onde σ = a Δt / Δx.",
                                    "Assuma solução numérica u_j^n = A e^{i (k j Δx - Ω n Δt)}, com θ = k Δx.",
                                    "Substitua a forma plano-onda na equação para obter a relação de amplificação G(θ) = e^{-i Ω Δt}.",
                                    "Verifique que |G(θ)| ≈ 1 para baixa dissipação."
                                  ],
                                  "verification": "Confirme que a substituição leva a uma equação envolvendo cos(θ) e sin(θ).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora simbólica (SymPy ou Mathematica), notas do esquema Lax-Wendroff.",
                                  "tips": "Use notação complexa exponencial para simplificar trigonométricas.",
                                  "learningObjective": "Compreender a origem von Neumann da análise de estabilidade e dispersão.",
                                  "commonMistakes": "Confundir σ com θ; esquecer o fator i na fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a relação de amplificação G(θ)",
                                  "subSteps": [
                                    "Substitua u_j^n = e^{i (k j Δx - Ω n Δt)} na stencil do Lax-Wendroff.",
                                    "Calcule cada termo: u_{j±1}^n = e^{i θ (j±1)} e^{-i Ω n Δt} = u_j^n e^{± i θ}.",
                                    "Simplifique para G(θ) = 1 - i σ sin(θ) - (σ^2 / 2) (1 - cos(2θ)).",
                                    "Expresse em forma polar: G(θ) = |G| e^{-i Ω Δt}, onde Ω Δt é o argumento.",
                                    "Verifique para θ=0: G(0)=1, sem dispersão."
                                  ],
                                  "verification": "G(θ) deve satisfazer |G(θ)| ≤ 1 para estabilidade CFL.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de cálculo simbólica, software como Python com NumPy/SymPy.",
                                  "tips": "Use identidade cos(2θ) = 2 cos²(θ) - 1 para simplificar.",
                                  "learningObjective": "Dominar a derivação algébrica da relação de amplificação.",
                                  "commonMistakes": "Erro no sinal do termo dissipativo; não normalizar por u_j^n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter a frequência numérica Ω(θ)",
                                  "subSteps": [
                                    "Da relação G(θ) = e^{-i Ω Δt}, isole o argumento: Ω Δt = - arg(G(θ)).",
                                    "Para Lax-Wendroff: cos(Ω Δt) = 1 - 2 σ² sin²(θ), então Ω(θ) = (1/Δt) acos(1 - 2 σ² sin²(θ)).",
                                    "Expanda para pequenas θ: Ω ≈ (a k) (1 - (σ²/6) θ²), mostrando dispersão de fase.",
                                    "Compare com ω_fís = a k (dispersão exata).",
                                    "Teste numérico: compute Ω para σ=0.9, θ de 0 a π."
                                  ],
                                  "verification": "Para θ→0, Ω → a k / Δx * θ, matching físico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "SymPy para simplificação trigonométrica, plotter (Matplotlib).",
                                  "tips": "Acos é multi-valor; tome ramo principal entre 0 e π.",
                                  "learningObjective": "Extrair Ω numérica da amplificação complexa.",
                                  "commonMistakes": "Usar sin em vez de cos; ignorar dependência em σ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e analisar dispersão numérica vs física",
                                  "subSteps": [
                                    "Defina ω_fís(k Δx) = a k = a θ / Δx.",
                                    "Implemente função Ω_num(θ) em código.",
                                    "Gere plots: ω_num Δt vs θ, e ω_num / ω_fís vs θ.",
                                    "Identifique erros de fase: onda numérica atrasa para altos k.",
                                    "Varie σ e observe impacto na dispersão."
                                  ],
                                  "verification": "Curva ω_num abaixo de ω_fís para θ >0, convergindo em baixa frequência.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python (NumPy, Matplotlib), Jupyter Notebook.",
                                  "tips": "Normalize por ω_fís para visualizar erro relativo.",
                                  "learningObjective": "Visualizar e interpretar erros de dispersão.",
                                  "commonMistakes": "Escala errada em k Δx; plotar Ω Δt em vez de ω_num."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e generalizar para outros esquemas",
                                  "subSteps": [
                                    "Derive para Lax-Friedrichs: cos(Ω Δt) = cos(θ) / (1 + σ² sin²(θ)/2) ou similar.",
                                    "Compare plots multi-esquemas.",
                                    "Calcule erro de fase φ = (ω_fís - ω_num) Δt.",
                                    "Discuta ordem: Lax-Wendroff é ordem 2, menos dispersivo.",
                                    "Documente em relatório com equações e figuras."
                                  ],
                                  "verification": "Derivação consistente com literatura (ex: LeVeque book).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referências: 'Finite Difference Schemes' de LeVeque, código anterior.",
                                  "tips": "Use loop para múltiplos esquemas no plot.",
                                  "learningObjective": "Generalizar análise de dispersão.",
                                  "commonMistakes": "Não considerar estabilidade por esquema."
                                }
                              ],
                              "practicalExample": "Para Lax-Wendroff com σ=0.9 na equação de advecção, derive Ω(θ) = (1/Δt) acos(1 - 2*(0.9)^2 sin²(θ)). Plote ω_num(k Δx) / ω_fís(k Δx) mostrando queda para k Δx > π/4, explicando atraso de fase em simulações de ondas.",
                              "finalVerifications": [
                                "Derivação de Ω(θ) para Lax-Wendroff bate com fórmula padrão.",
                                "Plot mostra dispersão leading/trailing corretamente.",
                                "Cálculo de erro de fase para θ=π/2 é negativo.",
                                "Generalização para upwind scheme funciona.",
                                "Análise qualitativa liga a plots observados.",
                                "Validação numérica via código Python sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de G(θ) (90% correto).",
                                "Correção da fórmula Ω(θ) = (1/Δt) acos(...).",
                                "Qualidade do plot: eixos rotulados, múltiplas curvas.",
                                "Interpretação física dos erros de dispersão.",
                                "Generalização para outro esquema com validação.",
                                "Clareza no relatório com equações LaTeX."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e velocidades de fase/grupo.",
                                "Computação: Implementação numérica em CFD (Python/MATLAB).",
                                "Engenharia: Análise de erro em simulações acústicas/sismicas.",
                                "Estatística: Análise de sensibilidade a parâmetros σ."
                              ],
                              "realWorldApplication": "Em simulações numéricas de fluidos (CFD), derivar dispersão otimiza malhas Δx/Δt para minimizar erros de fase em previsões meteorológicas ou propagação sonora, evitando distorções em modelos climáticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.2",
                              "10.1.6.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Identificar erros de fase",
                            "description": "Calcular o erro de fase φ = (ω_fís - ω_num) t e classificar esquemas dispersivos (ondas de alta frequência atrasam).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Frequências Física e Numérica na Relação de Dispersão",
                                  "subSteps": [
                                    "Revise a equação da onda física e sua solução exata, identificando ω_fís = c k, onde c é a velocidade de fase e k o número de onda.",
                                    "Analise a relação de dispersão numérica do esquema, derivando ω_num como função de k, h (passo espacial) e Δt (passo temporal).",
                                    "Compare ω_fís e ω_num plotando ambas em um gráfico de dispersão para diferentes valores de k h.",
                                    "Identifique como discrepâncias surgem devido à discretização.",
                                    "Discuta o impacto em componentes de diferentes frequências."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um gráfico de dispersão mostrando ω_fís e ω_num para um esquema exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou software de plotagem (Matplotlib/Python)",
                                    "Notas sobre relação de dispersão do esquema (ex: Lax-Wendroff)"
                                  ],
                                  "tips": "Sempre normalize por k para visualizar o erro relativo; foque em regimes de baixa e alta frequência.",
                                  "learningObjective": "Definir e diferenciar ω_fís e ω_num, reconhecendo sua dependência em k.",
                                  "commonMistakes": [
                                    "Confundir ω_fís (exata, linear em k) com ω_num (não-linear)",
                                    "Ignorar normalização por kh",
                                    "Esquecer dependência em parâmetros do esquema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Diferença de Frequência Δω",
                                  "subSteps": [
                                    "Selecione valores específicos: ω_fís = c k e ω_num da relação de dispersão.",
                                    "Compute Δω = ω_fís - ω_num para múltiplos kh (ex: kh=0.1, 1.0, π).",
                                    "Analise o sinal de Δω: positivo (ondas aceleram), negativo (atrasam).",
                                    "Calcule numericamente usando uma fórmula exemplo, como para esquema forward-time central-space.",
                                    "Registre resultados em tabela para kh variando de 0 a π."
                                  ],
                                  "verification": "Produza uma tabela com Δω para 5 valores de kh, mostrando sinal correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter para computação",
                                    "Fórmula da relação de dispersão anotada"
                                  ],
                                  "tips": "Use aproximações de Taylor para validar Δω em kh pequeno (ordem do erro).",
                                  "learningObjective": "Calcular Δω com precisão e interpretar seu sinal físico.",
                                  "commonMistakes": [
                                    "Erro de sinal: Δω = ω_num - ω_fís em vez de vice-versa",
                                    "Usar kh > π (aliasing)",
                                    "Não variar kh adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Erro de Fase φ",
                                  "subSteps": [
                                    "Defina φ(t) = Δω * t, onde t é o tempo de simulação.",
                                    "Escolha t relevante (ex: t = L / c, tempo para atravessar domínio de comprimento L).",
                                    "Compute φ para os valores de Δω da tabela anterior.",
                                    "Avalie magnitude: |φ| << 1 indica baixa dispersão; |φ| > π/2 indica erro grave.",
                                    "Plote φ vs kh para visualizar o erro de fase."
                                  ],
                                  "verification": "Calcule φ para kh=π/2 e t=1, confirmando valor numérico exato.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou código Python simples",
                                    "Tabela de Δω do passo anterior"
                                  ],
                                  "tips": "Expresse t em termos normalizados (ex: t c / h) para generalidade.",
                                  "learningObjective": "Aplicar fórmula φ = (ω_fís - ω_num) t e avaliar sua magnitude.",
                                  "commonMistakes": [
                                    "Usar ω_num - ω_fís",
                                    "Esquecer multiplicar por t",
                                    "Escolher t irrealisticamente pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar Esquemas Dispersivos Baseado em Erros de Fase",
                                  "subSteps": [
                                    "Examine φ para altas frequências (kh → π): se φ < 0, ondas altas atrasam (dispersão trailing).",
                                    "Classifique: esquema leading (φ > 0, altas freq aceleram), trailing (φ < 0, atrasam), ou não-dispersivo.",
                                    "Compare com exemplos: upwind (trailing), Lax-Wendroff (leading para altas k).",
                                    "Discuta implicações: trailing causa oscilações atrás da frente de onda.",
                                    "Proponha mitigação: filtros ou esquemas de alta ordem.",
                                    "Teste com gráfico qualitativo de pacote de onda."
                                  ],
                                  "verification": "Classifique corretamente um esquema dado (ex: FTCS como trailing) com justificativa via φ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de dispersão de esquemas padrão",
                                    "Exemplos de soluções numéricas vs exatas"
                                  ],
                                  "tips": "Foque em kh > π/2 para altas frequências; lembre que trailing é comum em esquemas dissipativos.",
                                  "learningObjective": "Interpretar sinal e magnitude de φ para classificar dispersão.",
                                  "commonMistakes": [
                                    "Inverter leading/trailing",
                                    "Ignorar altas frequências",
                                    "Confundir com dissipação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação da onda 1D u_t + u_x = 0 discretizada com esquema upwind (u_j^{n+1} = u_j^n - λ (u_j^n - u_{j-1}^n), λ=1): relação de dispersão dá sin(ω_num Δt /2) / (Δt/2) ≈ ω_num. Para kh=2.5, ω_fís ≈2.5, ω_num≈1.8, Δω≈0.7>0? Não, calcule φ≈0.7*t; para altas k, φ<0 indicando atraso de ondas curtas, visível como dispersão trailing na simulação.",
                              "finalVerifications": [
                                "Calcula φ corretamente para kh arbitrário e t dado.",
                                "Identifica sinal de Δω e interpreta atraso/aceleração.",
                                "Classifica esquema como leading/trailing com evidência.",
                                "Plota dispersão mostrando regime de altas frequências.",
                                "Explica impacto em pacote de onda Gaussian.",
                                "Sugere escolha de Δt/h para minimizar |φ|."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em cálculos de ω_num, Δω e φ (erro <1%).",
                                "Correta interpretação do sinal de φ (atraso se negativo).",
                                "Classificação precisa de esquemas baseados em análise qualitativa/quantitativa.",
                                "Uso apropriado de kh no intervalo [0,π] com foco em altas frequências.",
                                "Clareza em gráficos e tabelas de resultados.",
                                "Identificação de erros comuns e mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de ondas e pacotes de onda em mecânica quântica/acústica.",
                                "Engenharia Computacional: Análise de erro em CFD e simulações de PDEs.",
                                "Programação: Implementação numérica em Python/MATLAB para validar dispersão.",
                                "Física Computacional: Modelagem de plasma e óptica numérica."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou de tsunamis (ex: modelo SWASH), identificar erros de fase trailing previne atrasos artificiais em cristas de ondas curtas, melhorando precisão em previsões de inundação costeira e alertas de desastres."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Analisar dispersão em esquemas específicos",
                            "description": "Comparar relação de dispersão para métodos explícito FTCS (instável), Lax-Friedrichs (dissipativo) e Lax-Wendroff (dispersivo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e derivar as relações de dispersão dos esquemas FTCS, Lax-Friedrichs e Lax-Wendroff",
                                  "subSteps": [
                                    "Estude a equação de advecção linear ∂u/∂t + c ∂u/∂x = 0 e os operadores de diferenças finitas básicos (forward, backward, centered).",
                                    "Derive a relação de amplificação para o esquema FTCS explícito: u^{n+1}_j = u^n_j + (c Δt / (2 Δx)) (u^n_{j+1} - u^n_{j-1}).",
                                    "Derive a relação para Lax-Friedrichs: u^{n+1}_j = (u^n_{j+1} + u^n_{j-1})/2 - (c Δt / (2 Δx)) (u^n_{j+1} - u^n_{j-1}).",
                                    "Derive a relação para Lax-Wendroff: u^{n+1}_j = u^n_j - (c Δt / (2 Δx)) (u^n_{j+1} - u^n_{j-1}) + (c^2 Δt^2 / (2 Δx^2)) (u^n_{j+1} - 2 u^n_j + u^n_{j-1}).",
                                    "Substitua a solução de Fourier u^n_j = g^n e^{i k j Δx} em cada relação para obter g(k, c Δt / Δx) = relação de dispersão."
                                  ],
                                  "verification": "Escreva as três relações de dispersão g(k) explicitamente e verifique se |g(k)| ≤ 1 para estabilidade onde aplicável.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Análise Numérica (ex: LeVeque), caderno de anotações, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Use notação padrão com σ = c Δt / Δx e ξ = k Δx para simplificar expressões.",
                                  "learningObjective": "Dominar a derivação das relações de dispersão via análise von Neumann.",
                                  "commonMistakes": "Esquecer o fator i na exponencial de Fourier ou confundir operadores espaciais (forward vs centered)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar estabilidade e dissipação em cada esquema",
                                  "subSteps": [
                                    "Para FTCS: Calcule |g(k)|^2 e mostre que >1 para certos k, provando instabilidade.",
                                    "Para Lax-Friedrichs: Derive |g(k)|^2 = cos^2(ξ/2) - σ^2 sin^2(ξ/2) e analise dissipação (Re(g) <1).",
                                    "Para Lax-Wendroff: Mostre |g(k)| ≈1 mas com fase errada; verifique estabilidade condicional |σ|≤1.",
                                    "Plote |g(k)| vs ξ para σ fixo (ex: σ=0.5) usando software.",
                                    "Identifique regimes onde dissipação domina (LF) vs onde não (FTCS/LW)."
                                  ],
                                  "verification": "Gere gráficos de |g(k)| para os três esquemas e anote condições de estabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python/MATLAB com NumPy/Matplotlib, template de script para análise von Neumann.",
                                  "tips": "Normalize ξ de 0 a π; foque em ξ pequenos para comportamento de onda longa.",
                                  "learningObjective": "Identificar instabilidade numérica e dissipação artificial em esquemas.",
                                  "commonMistakes": "Ignorar dependência em σ ao avaliar |g| ou plotar para σ>1 sem notar instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dispersão e erros de fase",
                                  "subSteps": [
                                    "Defina velocidade de fase numérica ω/k onde g = |g| e^{i ω Δt}.",
                                    "Para cada esquema, derive ω_num(k) e compare com ω_exata = c k.",
                                    "Para LF: Mostre forte dispersão numérica (fase atrasada devido a dissipação).",
                                    "Para LW: Destaque dispersão de onda curta (fase leading para ξ altos).",
                                    "Para FTCS: Note que instabilidade mascara análise de fase.",
                                    "Plote velocidade de fase normalizada c_num/c vs ξ."
                                  ],
                                  "verification": "Crie gráficos comparativos de c_num/c e discuta erros de fase qualitativamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Mesmo software do step 2, referências sobre análise de fase (ex: artigos de Trefethen).",
                                  "tips": "Use arg(g)/Δt para ω; amplie gráfico perto de ξ=0 para ondas longas.",
                                  "learningObjective": "Compreender dispersão como erro de propagação de fase em esquemas hiperbólicos.",
                                  "commonMistakes": "Confundir dispersão com dissipação ou derivar ω incorretamente de Im(log g)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar esquemas e sintetizar implicações",
                                  "subSteps": [
                                    "Tabele resumo: estabilidade, dissipação, dispersão para cada esquema.",
                                    "Compare qualitativamente: FTCS (instável), LF (dissipativo, estável mas smeary), LW (dispersivo, oscilações).",
                                    "Discuta trade-offs: estabilidade vs precisão de fase.",
                                    "Simule numericamente uma onda gaussiana com cada esquema para validar análise.",
                                    "Conclua quando usar cada um (ex: LF para choques, LW para ondas suaves)."
                                  ],
                                  "verification": "Produza tabela comparativa e simulações que reproduzam comportamentos previstos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código de simulação 1D (Python com loops explícitos), dados de entrada (onda gaussiana).",
                                  "tips": "Use Δt/Δx = σ=0.5; rode por 100 passos e anime plots.",
                                  "learningObjective": "Sintetizar análises para seleção informada de esquemas numéricos.",
                                  "commonMistakes": "Generalizar demais sem considerar σ ou condições iniciais."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção ∂u/∂t + ∂u/∂x = 0 com u(x,0) = exp(-(x-50)^2/10) em [0,100], usando N=200 pontos, σ=0.5. Compare soluções numéricas FTCS (explode), LF (alisa), LW (oscila atrás da frente) aos 50 timesteps, validando dispersão/dissipação via plots lado a lado.",
                              "finalVerifications": [
                                "Derivações corretas das relações g(k) para os três esquemas.",
                                "Gráficos precisos de |g(k)| e c_num(k)/c mostrando diferenças qualitativas.",
                                "Tabela comparativa clara identificando instabilidade (FTCS), dissipação (LF) e dispersão (LW).",
                                "Simulações numéricas reproduzem análises teóricas.",
                                "Explicação coerente de trade-offs em aplicações reais.",
                                "Identificação correta de erros de fase em regimes de onda longa/curta."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Qualidade e legibilidade dos gráficos/plots (eixos rotulados, escalas apropriadas).",
                                "Profundidade da comparação qualitativa e quantitativa.",
                                "Validação via simulações numéricas.",
                                "Clareza na discussão de implicações práticas.",
                                "Correção na distinção entre dissipação, dispersão e instabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas ou equações hiperbólicas em mecânica de fluidos.",
                                "Computação: Implementação eficiente de solvers numéricos em Python/MATLAB.",
                                "Engenharia: Análise de estabilidade em simulações CFD (Computational Fluid Dynamics).",
                                "Estatística: Analogia com erros de variância em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou acústicas, Lax-Wendroff é usado para propagar ondas sem amortecimento excessivo, mas requer filtros para oscilações; Lax-Friedrichs estabiliza choques em fluxos compressíveis, como em aviônica ou previsão de tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Interpretar gráficos de dispersão",
                            "description": "Analisar curvas de dispersão normalizadas ω_num / (c k) para identificar regimes de baixa e alta frequência e propor melhorias numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes do gráfico de dispersão normalizada",
                                  "subSteps": [
                                    "Revise a definição de relação de dispersão: ω_num(k) é a frequência numérica, c é a velocidade de fase exata, k é o número de onda.",
                                    "Identifique os eixos: eixo x é k Δx (normalizado), eixo y é ω_num / (c k).",
                                    "Compare com a dispersão exata: linha reta y=1 para solução analítica.",
                                    "Colete dados do gráfico: marque pontos de curvas para diferentes ordens de precisão.",
                                    "Anote símbolos: Δx (espaçamento de grade), Δt (passo de tempo)."
                                  ],
                                  "verification": "Desenhe ou anote os eixos e componentes principais corretamente em um esboço do gráfico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico de dispersão fornecido, papel e lápis ou software de desenho (ex: Draw.io), calculadora.",
                                  "tips": "Sempre normalize pelo regime não-dispersivo (y=1) para facilitar comparações.",
                                  "learningObjective": "Entender a estrutura matemática e física do gráfico de dispersão normalizada.",
                                  "commonMistakes": "Confundir ω_num com ω_exato ou ignorar a normalização por c k."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o regime de baixa frequência (k Δx << 1)",
                                  "subSteps": [
                                    "Selecione a região esquerda do gráfico onde k Δx é pequeno (ex: 0 a π/10).",
                                    "Verifique se ω_num / (c k) ≈ 1; meça o desvio percentual.",
                                    "Calcule o erro de fase: φ = ω Δt - k Δx.",
                                    "Compare com expansão em série de Taylor para ordens de precisão.",
                                    "Registre se o esquema é de segunda ordem (erro O((k Δx)^2))."
                                  ],
                                  "verification": "Calcule e confirme que o erro é inferior a 1% no regime de baixa k.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráfico, planilha (Excel ou Python com NumPy), régua para medições.",
                                  "tips": "Use zoom no gráfico para precisão; foque em assimetrias iniciais.",
                                  "learningObjective": "Identificar precisão em ondas longas, onde métodos numéricos devem ser acurados.",
                                  "commonMistakes": "Considerar todo o gráfico como 'baixa frequência'; ignorar termos de ordem superior."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o regime de alta frequência (k Δx ≈ π)",
                                  "subSteps": [
                                    "Examine a região direita (k Δx próximo a π).",
                                    "Observe oscilações ou desvios: ω_num / (c k) <1 ou >1 indica dispersão.",
                                    "Meça o fator de dispersão: quantas vezes mais lento ou rápido que exato.",
                                    "Identifique padrões: ex: esquemas centrados mostram dispersão par.",
                                    "Compare múltiplas curvas (diferentes Δx) para ver convergência."
                                  ],
                                  "verification": "Descreva qualitativamente o comportamento (ex: sub-dispersivo) e quantifique desvio máximo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráfico, software de plotagem (Matplotlib ou MATLAB), lupa ou zoom digital.",
                                  "tips": "Plote logaritmicamente para exagerar desvios em alta k.",
                                  "learningObjective": "Reconhecer artefatos numéricos em ondas curtas e sua causa física.",
                                  "commonMistakes": "Atribuir dispersão a ruído em vez de propriedades do esquema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor melhorias numéricas baseadas na análise",
                                  "subSteps": [
                                    "Sintetize achados: liste regimes problemáticos (ex: alta k com dispersão >20%).",
                                    "Sugira refinamentos: reduzir Δx, usar esquemas de ordem superior (ex: DRP).",
                                    "Considere filtros: adicionar dissipação artificial para alta frequência.",
                                    "Avalie trade-offs: estabilidade vs precisão.",
                                    "Esboce gráfico melhorado hipotético."
                                  ],
                                  "verification": "Escreva 2-3 propostas específicas com justificativa quantitativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para brainstorm, referências de esquemas numéricos (livro ou PDF).",
                                  "tips": "Priorize melhorias custo-efetivas como adaptação de coeficientes.",
                                  "learningObjective": "Aplicar análise para otimizar métodos numéricos.",
                                  "commonMistakes": "Propor soluções genéricas sem ligar ao gráfico específico."
                                }
                              ],
                              "practicalExample": "Em um esquema de Lax-Friedrichs para a equação de advecção, o gráfico mostra ω_num/(c k) ≈0.8 em k Δx=π/2. Identifique dispersão de fase de 20%, propondo upwinding de terceira ordem para corrigir.",
                              "finalVerifications": [
                                "Gráfico corretamente rotulado com regimes identificados.",
                                "Erros quantificados em baixa/alta frequência (<5% e descrito).",
                                "Propostas de melhoria com pelo menos duas opções viáveis.",
                                "Comparação com solução exata visualmente confirmada.",
                                "Nenhum erro conceitual em definições (ω_num vs ω_exato).",
                                "Análise consistente com contexto de dispersão numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de regimes (baixa/alta k).",
                                "Quantificação correta de erros de dispersão.",
                                "Qualidade e relevância das propostas de melhoria.",
                                "Uso adequado de normalização ω_num/(c k).",
                                "Profundidade dos sub-steps executados.",
                                "Clareza na documentação e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Relação com propagação de ondas em meios dispersivos.",
                                "Computação: Implementação em Python/MATLAB para geração de gráficos.",
                                "Engenharia: Otimização em simulações CFD (dinâmica de fluidos computacional).",
                                "Estatística: Análise de resíduos em regressão não-linear similar."
                              ],
                              "realWorldApplication": "Em simulações numéricas de ondas acústicas ou sísmicas na indústria petrolífera, interpretar dispersão garante precisão em previsões de propagação, evitando erros em modelos de reservatórios que custam milhões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Relação com Estabilidade e Precisão",
                    "description": "Conexão entre dispersão, dissipação, estabilidade e precisão em métodos de diferenças finitas para equações diferenciais parciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Dispersão Numérica",
                        "description": "A dispersão numérica refere-se ao erro na propagação da fase das ondas em métodos de diferenças finitas para equações diferenciais parciais hiperbólicas, onde componentes de alta frequência propagam mais lentamente que as de baixa frequência, afetando a precisão da solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Definir e identificar dispersão via análise de Von Neumann",
                            "description": "Explicar o conceito de dispersão numérica utilizando a análise de Von Neumann, calculando o símbolo de dispersão ξ(kh) para esquemas explícitos e identificando quando ξ(kh) ≠ ω Δt, com exemplos da equação da onda.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Análise de Von Neumann e Dispersão Numérica",
                                  "subSteps": [
                                    "Revise a análise de Von Neumann: assuma soluções planares e^{i(kx - ωt)} e derive o fator de amplificação g(kh).",
                                    "Defina dispersão numérica como a discrepância entre a velocidade de fase numérica ξ(kh)/k e a física ω/k.",
                                    "Estude a condição de dispersão neutra: ξ(kh) = ω Δt para todos os comprimentos de onda kh.",
                                    "Analise como esquemas explícitos introduzem dispersão devido à aproximação de diferenças finitas.",
                                    "Compare dispersão com dissipação: dispersão afeta fase, dissipação afeta amplitude."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre dispersão numérica e física, com um diagrama de dispersão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de análise numérica (ex: LeVeque), notas de aula sobre Von Neumann",
                                    "Software como Python/Jupyter para plotar curvas de dispersão"
                                  ],
                                  "tips": "Comece com a equação da onda u_t + c u_x = 0 para simplicidade.",
                                  "learningObjective": "Compreender conceitualmente dispersão via Von Neumann e sua relação com precisão numérica.",
                                  "commonMistakes": [
                                    "Confundir fator de amplificação g com símbolo de dispersão ξ",
                                    "Ignorar dependência em kh (comprimento de onda normalizado)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Símbolo de Dispersão ξ(kh) para um Esquema Explícito Simples",
                                  "subSteps": [
                                    "Considere o esquema forward-time central-space (FTCS) para u_t + c u_x = 0: u_j^{n+1} = u_j^n - (c Δt / (2 Δx)) (u_{j+1}^n - u_{j-1}^n).",
                                    "Substitua solução teste e^{i k (j Δx)} e derive g(kh) = 1 - i (c Δt / Δx) sin(kh), onde h = Δx.",
                                    "Extraia o símbolo de dispersão: ξ(kh) = arg(g(kh)) / Δt.",
                                    "Calcule ξ(kh) explicitamente: ξ(kh) = - (c / h) sin(kh) para FTCS.",
                                    "Plote ξ(kh) vs kh e compare com ω = c k (dispersão física)."
                                  ],
                                  "verification": "Derive e plote ξ(kh) para FTCS, mostrando que ξ(kh) ≠ c k para kh ≠ 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Python com NumPy/Matplotlib para plots"
                                  ],
                                  "tips": "Use identidade trigonométrica sin(kh) ≈ kh para kh pequeno para aproximação.",
                                  "learningObjective": "Derivar analiticamente ξ(kh) para esquemas explícitos lineares.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo imaginário em g(kh)",
                                    "Esquecer de dividir arg(g) por Δt para obter ξ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar à Equação da Onda e Calcular Exemplos",
                                  "subSteps": [
                                    "Estenda para equação da onda u_{tt} = c^2 u_{xx}: considere esquemas como Lax-Wendroff.",
                                    "Derive g(kh) para Lax-Wendroff: g = 1 - 2 r^2 (1 - cos(kh)) + i 2 r^2 sin(kh) (1 - cos(kh))/ (kh), onde r = c Δt / Δx.",
                                    "Calcule ξ(kh) = Im( ln(g) ) / Δt e compare com ω(k) = c k.",
                                    "Implemente numericamente: resolva PDE e compare fase numérica vs exata.",
                                    "Identifique comprimentos de onda onde dispersão é máxima (ex: kh ≈ π)."
                                  ],
                                  "verification": "Compute ξ(kh) para Lax-Wendroff em kh=π/2 e mostre desvio de ω Δt.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python pronto para Von Neumann (template)",
                                    "Referência: Tannehill ou similar para esquemas de onda"
                                  ],
                                  "tips": "Use sympy para derivação simbólica se manual for tediosa.",
                                  "learningObjective": "Calcular e visualizar dispersão em esquemas para equação da onda.",
                                  "commonMistakes": [
                                    "Confundir equação advecção com onda",
                                    "Erro em aproximação de segunda ordem para onda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Mitigar Dispersão Numérica",
                                  "subSteps": [
                                    "Defina critérios para identificar dispersão: |ξ(kh) - ω Δt| > tolerância para kh altos.",
                                    "Analise esquemas de alta ordem: mostre que ordem maior reduz dispersão de fase.",
                                    "Discuta filtros de dispersão ou esquemas implicitos para redução.",
                                    "Simule um pulso de onda e observe distorção de fase devido a dispersão.",
                                    "Proponha refinamento de malha (reduzir h) como solução prática."
                                  ],
                                  "verification": "Identifique em um gráfico onde ξ(kh) ≠ ω Δt e sugira melhoria no esquema.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador numérico (MATLAB/Python)",
                                    "Artigos sobre esquemas dispersão-free"
                                  ],
                                  "tips": "Foquem em kh > π/4 onde dispersão é notável em malhas grosseiras.",
                                  "learningObjective": "Diagnosticar dispersão e propor estratégias de correção.",
                                  "commonMistakes": [
                                    "Achar que estabilidade (CFL) resolve dispersão",
                                    "Ignorar efeitos não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o esquema Lax-Friedrichs na equação da onda 1D, derive ξ(kh) = arcsin( r sin(kh) ) / Δt. Plote para r=0.9, mostre que ondas curtas (kh=π) propagam mais devagar que longas, simulando um pulso gaussiano em Python e observando a dispersão de cauda.",
                              "finalVerifications": [
                                "Derive corretamente ξ(kh) para FTCS e Lax-Wendroff.",
                                "Plote curvas de dispersão e identifique desvios de ω Δt.",
                                "Explique verbalmente quando e por que dispersão ocorre em esquemas explícitos.",
                                "Simule equação da onda e quantifique erro de fase.",
                                "Proponha pelo menos duas maneiras de reduzir dispersão.",
                                "Compare dispersão vs dissipação em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de g(kh) e ξ(kh) (fórmulas corretas).",
                                "Qualidade dos plots: eixos rotulados, escalas apropriadas, interpretação.",
                                "Identificação correta de condições ξ(kh) ≠ ω Δt.",
                                "Profundidade na análise de exemplos da equação da onda.",
                                "Criatividade em conexões com aplicações reais.",
                                "Clareza na explicação de erros comuns e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas em meios dispersivos (acústica, óptica).",
                                "Computação Científica: Desenvolvimento de solvers CFD dispersão-controlados.",
                                "Engenharia: Simulações sísmicas onde dispersão afeta precisão de previsões.",
                                "Matemática Pura: Análise de símbolos pseudo-diferenciais."
                              ],
                              "realWorldApplication": "Em simulações sísmicas para exploração de petróleo, análise de Von Neumann identifica dispersão em esquemas FD, permitindo otimizar malhas para prever velocidades de ondas P e S com precisão, evitando erros em imagens subterrâneas que custam milhões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Calcular erro de dispersão em esquemas FTCS e Lax-Friedrichs",
                            "description": "Derivar a relação dispersiva para os esquemas FTCS e Lax-Friedrichs aplicados à equação de advecção ou onda, avaliando o impacto do número de Courant na distorção de fase para diferentes números de onda k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de advecção e os esquemas FTCS e Lax-Friedrichs",
                                  "subSteps": [
                                    "Escrever a equação de advecção linear: ∂u/∂t + c ∂u/∂x = 0.",
                                    "Definir o esquema FTCS: u^{n+1}_j = u^n_j - (σ/2)(u^n_{j+1} - u^n_{j-1}), onde σ = c Δt / Δx é o número de Courant.",
                                    "Definir o esquema Lax-Friedrichs: u^{n+1}_j = (u^n_{j+1} + u^n_{j-1})/2 - (σ/2)(u^n_{j+1} - u^n_{j-1}).",
                                    "Explicar a análise von Neumann: assumir solução u_j^n = g^n e^{i k j Δx}, derivar g(k).",
                                    "Identificar componentes de dispersão: arg(g) ≈ -c k Δt (dispersão numérica quando arg(g)/Δt ≠ -c k)."
                                  ],
                                  "verification": "Verificar se as fórmulas dos esquemas estão corretas comparando com referências padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque 'Finite Difference Methods'), papel e lápis, calculadora"
                                  ],
                                  "tips": "Comece com a equação discreta em stencil para visualizar vizinhos.",
                                  "learningObjective": "Compreender a base matemática dos esquemas e preparar para análise de Fourier.",
                                  "commonMistakes": [
                                    "Confundir σ com CFL (são iguais), esquecer normalização de k por Δx"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a relação dispersiva para o esquema FTCS",
                                  "subSteps": [
                                    "Substituir a forma von Neumann no esquema FTCS para obter g = 1 - i σ sin(θ), onde θ = k Δx.",
                                    "Calcular a fase numérica: φ_num = arg(g) = -atan(σ sin(θ) / (1 - σ cos(θ))) aproximado.",
                                    "Derivar a velocidade de fase numérica: ω_num / k = -φ_num / Δt.",
                                    "Comparar com exata ω_ex = c k, obtendo erro de dispersão ε = (ω_num - ω_ex)/ω_ex.",
                                    "Simplificar para pequenos θ: ε ≈ (σ^2 θ^2 / 6) (1 - σ^2 / 3)."
                                  ],
                                  "verification": "Resolver g para θ=π/2 e verificar |g| ≈1 para σ<1, mas instável em geral.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel quadriculado, software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Use identidades trigonométricas: e^{iθ} - e^{-iθ} = 2i sin(θ).",
                                  "learningObjective": "Dominar a derivação exata da relação de amplificação e fase para FTCS.",
                                  "commonMistakes": [
                                    "Esquecer o i na parte imaginária, confundir |g| com arg(g)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a relação dispersiva para o esquema Lax-Friedrichs",
                                  "subSteps": [
                                    "Substituir no Lax-Friedrichs: g = cos(θ) - i σ sin(θ).",
                                    "Calcular φ_num = arg(g) = -atan(σ sin(θ) / cos(θ)).",
                                    "Derivar velocidade de fase: comparar com FTCS, notando dissipação extra |g| = sqrt(cos²(θ) + σ² sin²(θ)) <1.",
                                    "Calcular erro de dispersão ε para Lax-Friedrichs: mais dispersivo que FTCS para σ fixo.",
                                    "Analisar limite θ→0: ε ≈ - (θ^2 / 6) (1 - σ^2)."
                                  ],
                                  "verification": "Plotar φ_num vs θ para σ=0.5 e comparar graficamente com -σ θ.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/MATLAB para plotar arg(g), notas do Step 2"
                                  ],
                                  "tips": "Normalize φ_num / (σ θ) para visualizar distorção de fase.",
                                  "learningObjective": "Contrastar dispersão entre esquemas estável e instável.",
                                  "commonMistakes": [
                                    "Confundir cos(θ) com (1 - sin²(θ)/2), ignorar normalização |g|"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto do número de Courant na distorção de fase para diferentes k",
                                  "subSteps": [
                                    "Fixar σ e variar θ = k Δx de 0 a π (modos de onda).",
                                    "Calcular ε(σ, θ) para ambos esquemas e plotar curvas de dispersão.",
                                    "Analisar: para σ=1, Lax-Friedrichs tem menos distorção em baixos k; FTCS amplifica altos k.",
                                    "Estudar dependência em σ: dispersão cresce com |1-σ| para Lax-Friedrichs.",
                                    "Implementar numéricamente: simular pulso advectado e medir defasagem de fase."
                                  ],
                                  "verification": "Gerar plots onde para σ=0.9, erro <5% para θ<π/4.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python (NumPy, Matplotlib), código de simulação 1D"
                                  ],
                                  "tips": "Use θ = 2π / λ * Δx para relacionar com comprimentos de onda.",
                                  "learningObjective": "Quantificar e visualizar como CFL afeta precisão de fase em diferentes escalas.",
                                  "commonMistakes": [
                                    "Usar k físico em vez de θ = k Δx, ignorar aliasing para θ>π"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a advecção de um pulso gaussiano com c=1, Δx=0.1, Δt=0.09 (σ=0.9) usando FTCS (instável, observe oscilações) e Lax-Friedrichs (suavizado). Meça defasagem de fase no pico após t=1 comparando posição exata x=c t com numérica, calculando ε ≈ 2% para k dominante θ=0.5.",
                              "finalVerifications": [
                                "Derivação correta de g(FTCS) e g(Lax-Friedrichs) para θ arbitrário.",
                                "Cálculo preciso de φ_num e ε para σ=0.5, θ=π/4.",
                                "Plots de dispersão mostrando distorção crescente com θ.",
                                "Análise qualitativa: Lax-Friedrichs dispersivo em altos k, FTCS neutro mas instável.",
                                "Simulação numérica com defasagem <3% validada contra analítica.",
                                "Identificação de σ ótimo minimizando ε médio."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nas derivações (sem erros trigonométricos).",
                                "Correta interpretação de dispersão como erro em ω_num.",
                                "Análise quantitativa do impacto de σ em ε(θ).",
                                "Qualidade dos plots e simulações (legíveis, escalados corretamente).",
                                "Conexão clara entre teoria e prática numérica.",
                                "Identificação de trade-offs estabilidade vs dispersão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e velocidades de fase em meios dispersivos.",
                                "Computação: Implementação eficiente de esquemas FD em Python/NumPy.",
                                "Engenharia: Modelagem numérica em CFD e simulações acústicas.",
                                "Matemática Aplicada: Análise de Fourier e estabilidade von Neumann."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (modelos de advecção de umidade), Lax-Friedrichs reduz dispersão de frentes climáticas, permitindo previsões precisas de fase em diferentes escalas espaciais com CFL próximo de 1 para eficiência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Avaliar impacto da dispersão na precisão global",
                            "description": "Analisar como erros de dispersão acumulam ao longo do tempo em simulações de longo prazo, comparando soluções numéricas com exatas para ondas gaussianas em métodos de diferenças finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de dispersão numérica em métodos de diferenças finitas",
                                  "subSteps": [
                                    "Estudar a equação de onda unidimensional e sua discretização via diferenças finitas centrais.",
                                    "Analisar o fator de amplificação e a relação de dispersão derivada da análise de von Neumann.",
                                    "Identificar como a velocidade de fase numérica difere da exata para diferentes números de onda.",
                                    "Examinar o impacto da condição CFL na dispersão.",
                                    "Derivar qualitativamente o acúmulo de fase errada ao longo do tempo."
                                  ],
                                  "verification": "Resumir em um diagrama a relação dispersão vs. número de onda e explicar verbalmente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de análise numérica (cap. diferenças finitas)",
                                    "Notas de aula sobre von Neumann",
                                    "Software de plotagem como Python/Matplotlib"
                                  ],
                                  "tips": "Comece com esquemas simples (explícito 1D) antes de generalizar.",
                                  "learningObjective": "Explicar matematicamente como a dispersão surge em esquemas de diferenças finitas.",
                                  "commonMistakes": [
                                    "Confundir dispersão com dissipação",
                                    "Ignorar dependência no número de onda kΔx",
                                    "Não considerar propagação de longo prazo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar simulação numérica de uma onda gaussiana usando diferenças finitas",
                                  "subSteps": [
                                    "Configurar malha espacial e temporal com condição CFL estável (ex: σ=0.5).",
                                    "Implementar esquema de diferenças finitas explícito para equação de onda ∂²u/∂t² = c² ∂²u/∂x².",
                                    "Inicializar condição inicial como gaussiana u(x,0) = exp(-(x-x0)²/(2σ²)), ∂u/∂t=0.",
                                    "Executar simulação para tempo curto (T=10 períodos) e plotar snapshot.",
                                    "Validar código comparando com solução exata em tempo curto."
                                  ],
                                  "verification": "Gerar plots de u(x,t) numérico vs. exato com erro L2 < 1% em tempo curto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib",
                                    "Template de código para FDTD",
                                    "Documentação SciPy para solução exata (opcional)"
                                  ],
                                  "tips": "Use arrays vetorizados no NumPy para eficiência; teste com malhas grosseiras primeiro.",
                                  "learningObjective": "Implementar e validar um solver numérico básico para ondas.",
                                  "commonMistakes": [
                                    "Violação CFL causando instabilidade",
                                    "Condições de contorno erradas (use periódicas)",
                                    "Normalização incorreta da gaussiana"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular propagação de longo prazo e quantificar acúmulo de erro de dispersão",
                                  "subSteps": [
                                    "Executar simulação para tempo longo (T=100-500 períodos).",
                                    "Calcular erro de fase acumulado medindo deslocamento do pico gaussiano vs. tempo.",
                                    "Computar normas de erro global (L1, L2, L∞) em função do tempo.",
                                    "Plotar erro vs. tempo e identificar tendência quadrática devido à dispersão.",
                                    "Variar resolução espacial (Δx) e observar redução do erro."
                                  ],
                                  "verification": "Plots mostram erro crescente ~ t² e redução com refinamento de malha.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código da Step 2 estendido",
                                    "Ferramentas de profiling para simulações longas",
                                    "Jupyter Notebook para análise interativa"
                                  ],
                                  "tips": "Monitore uso de memória para simulações longas; use FFT para análise espectral opcional.",
                                  "learningObjective": "Quantificar numericamente o acúmulo de erro dispersivo em simulações prolongadas.",
                                  "commonMistakes": [
                                    "Atribuir erro à instabilidade em vez de dispersão",
                                    "Escala de tempo inadequada",
                                    "Não normalizar erros por norma da solução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar soluções numéricas e exatas, avaliando impacto na precisão global",
                                  "subSteps": [
                                    "Implementar ou usar solução exata para onda gaussiana (d'Alembert adaptada).",
                                    "Comparar formas, amplitudes e velocidades de fase em múltiplos tempos.",
                                    "Calcular métricas de precisão global: erro relativo de fase, dispersão efetiva.",
                                    "Analisar trade-offs: precisão vs. custo computacional (refinamento malha).",
                                    "Concluir com relatório sobre quando dispersão compromete simulações de longo prazo."
                                  ],
                                  "verification": "Relatório com tabelas/plots mostrando impacto quantitativo (ex: erro >10% após T=200).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código integrado das steps anteriores",
                                    "Referências para solução exata gaussiana",
                                    "LaTeX ou Markdown para relatório"
                                  ],
                                  "tips": "Use log-log plots para erro vs. tempo/resolução; foque em componentes de baixa frequência.",
                                  "learningObjective": "Avaliar criticamente a precisão global e propor melhorias (ex: esquemas de alta ordem).",
                                  "commonMistakes": [
                                    "Solução exata incorreta para gaussiana (não é harmônica pura)",
                                    "Ignorar efeitos de contorno em domínios finitos",
                                    "Conclusões sem quantificação estatística"
                                  ]
                                }
                              ],
                              "practicalExample": "Em modelagem sísmica, simule uma onda gaussiana representando pulso P-wave propagando por 1000 km em meio homogêneo usando Δx=10m, c=3000m/s. Após 500s (longo prazo), observe o pico atrasado em 5% devido à dispersão numérica, comprometendo interpretação de reflexões.",
                              "finalVerifications": [
                                "Plots de simulação mostram distorção fase crescente com tempo.",
                                "Erro L2 escala como (Δx)^2 * t^2 para esquema padrão.",
                                "Comparação qualitativa/quantitativa com exato identifica dispersão como dominante.",
                                "Relatório explica limiares de precisão para aplicações reais.",
                                "Aluno ajusta parâmetros para mitigar erro <5% em T longo.",
                                "Análise espectral revela atenuação seletiva de altos k."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação de dispersão (80% correto).",
                                "Implementação numérica estável e validada (erro inicial <1%).",
                                "Análise quantitativa de erro com métricas apropriadas (L2, fase).",
                                "Interpretação correta do acúmulo temporal e dependência em Δx.",
                                "Relatório claro com plots, conclusões e sugestões de melhoria.",
                                "Criatividade em variações (ex: diferentes CFL ou ordens)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Propagação de ondas e análise modal.",
                                "Computação: Programação científica e análise de estabilidade numérica.",
                                "Engenharia: Simulações CFD/acústicas onde dispersão afeta precisão.",
                                "Estatística: Quantificação de erros e convergência.",
                                "Visualização de Dados: Plots de erro e animações de ondas."
                              ],
                              "realWorldApplication": "Em simulações climáticas de ondas oceânicas ou acústica médica, dispersão numérica distorce previsões de longo prazo, exigindo esquemas dispersão-free para precisão em forecasts de tsunamis ou imagens ultra-som."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Dissipação Numérica",
                        "description": "A dissipação numérica é o amortecimento artificial de componentes de alta frequência em métodos de diferenças finitas, comum em esquemas para equações parabólicas e hiperbólicas, influenciando a estabilidade e suavizando soluções.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Definir dissipação e seu papel em esquemas numéricos",
                            "description": "Descrever a dissipação como o módulo do fator de amplificação |g(kh)| < 1 na análise de Von Neumann, diferenciando-a de dispersão e exemplificando em esquemas implícitos para a equação do calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição básica de dissipação na análise de Von Neumann",
                                  "subSteps": [
                                    "Revise a análise de Von Neumann para esquemas de diferenças finitas em PDEs parabólicas.",
                                    "Identifique o fator de amplificação g(kh) como a magnitude da solução numérica em modo de Fourier.",
                                    "Defina dissipação como o fenômeno onde |g(kh)| < 1 para todos os comprimentos de onda kh, levando à atenuação artificial de componentes de alta frequência.",
                                    "Compare com amplificação (|g| > 1), que causa instabilidade.",
                                    "Anote a fórmula geral para g em esquemas lineares explícitos e implícitos."
                                  ],
                                  "verification": "Escreva uma definição precisa de dissipação em suas próprias palavras e calcule |g| para um kh simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Finite Difference Methods for Ordinary and Partial Differential Equations' de Randall LeVeque; calculadora ou Python/MATLAB para plots.",
                                  "tips": "Comece com kh pequeno (baixas frequências) para ver |g| ≈ 1 e kh grande para |g| << 1.",
                                  "learningObjective": "Compreender dissipação como atenuação numérica controlada por |g(kh)| < 1.",
                                  "commonMistakes": "Confundir dissipação com instabilidade (que é |g| > 1) ou assumir que |g| < 1 sempre é desejável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o papel da dissipação na precisão e estabilidade de esquemas numéricos",
                                  "subSteps": [
                                    "Analise como dissipação excessiva suaviza soluções, removendo oscilações de alta frequência mas borrando choques ou descontinuidades.",
                                    "Discuta o trade-off: dissipação moderada melhora estabilidade em esquemas explícitos para equações hiperbólicas.",
                                    "Examine o espectro de kh: dissipação forte em kh ≈ π (Nyquist) previne aliasing.",
                                    "Calcule o limite de dissipação para estabilidade von Neumann.",
                                    "Registre exemplos onde falta de dissipação causa blow-up numérico."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como dissipação contribui para estabilidade em esquemas condicionalmente estáveis.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel e lápis para diagramas de espectro; software como MATLAB para plotar |g(kh)| vs kh.",
                                  "tips": "Plote |g(kh)| para visualizar o 'damping' em altas frequências.",
                                  "learningObjective": "Reconhecer o papel da dissipação em equilibrar estabilidade e precisão numérica.",
                                  "commonMistakes": "Ignorar que dissipação é benéfica para estabilidade mas prejudicial para precisão em longos tempos de simulação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar dissipação de dispersão em análise de Von Neumann",
                                  "subSteps": [
                                    "Defina dispersão como erro de fase onde |g(kh)| = 1 mas arg(g) ≠ -kh (velocidade de fase errada).",
                                    "Compare: dissipação afeta amplitude (|g| < 1), dispersão afeta fase.",
                                    "Identifique esquemas dissipativos (ex: Lax-Friedrichs) vs dispersivos (ex: Lax-Wendroff).",
                                    "Crie uma tabela comparativa: efeitos em ondas de alta vs baixa frequência.",
                                    "Exemplifique com equação de advecção: dissipação amortece, dispersão oscila."
                                  ],
                                  "verification": "Preencha uma tabela comparando dissipação e dispersão com exemplos de esquemas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela em Excel ou papel; notas de aula sobre esquemas clássicos.",
                                  "tips": "Lembre: dispersão leva a 'trailing oscillations', dissipação a 'smearing'.",
                                  "learningObjective": "Distinguir claramente dissipação (amplitude) de dispersão (fase).",
                                  "commonMistakes": "Confundir os dois, achando que ambos causam oscilações (dispersão sim, dissipação não)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar dissipação em esquemas implícitos para a equação do calor",
                                  "subSteps": [
                                    "Considere a equação do calor u_t = u_xx; derive o esquema implícito backward Euler.",
                                    "Calcule g(kh) = 1 / (1 + 4 r sin²(kh/2)) onde r = Δt/Δx².",
                                    "Mostre que |g(kh)| ≤ 1 sempre, com dissipação forte para kh alto quando r pequeno.",
                                    "Implemente numericamente e plote solução vs exata para verificar atenuação.",
                                    "Compare com esquema explícito FTCS (instável sem restrições)."
                                  ],
                                  "verification": "Compute e plote |g(kh)| para r=0.5 e verifique |g| < 1 para kh > 0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python com NumPy/SciPy; código template para esquema implícito.",
                                  "tips": "Use solver linear para implícito; teste com condição inicial sinusoidal.",
                                  "learningObjective": "Aplicar definição de dissipação a um esquema implícito concreto.",
                                  "commonMistakes": "Esquecer que implícito é incondicionalmente estável mas sempre dissipativo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar o papel geral da dissipação em esquemas numéricos",
                                  "subSteps": [
                                    "Resuma: dissipação é essencial para estabilidade em esquemas de baixa ordem.",
                                    "Discuta modificações (ex: TVD schemes) para minimizar dissipação.",
                                    "Analise impacto em precisão de ordem: esquemas dissipativos perdem precisão em altas frequências.",
                                    "Crie um fluxograma: dado um esquema, classifique dissipativo/dispersivo.",
                                    "Reflita sobre quando priorizar dissipação vs precisão."
                                  ],
                                  "verification": "Crie um resumo de 1 página integrando todos os conceitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documento Word ou notebook Jupyter para síntese.",
                                  "tips": "Use analogia física: dissipação como viscosidade numérica.",
                                  "learningObjective": "Integrar dissipação ao contexto mais amplo de análise numérica.",
                                  "commonMistakes": "Superestimar dissipação como sempre ruim, ignorando seu papel estabilizador."
                                }
                              ],
                              "practicalExample": "Em um esquema implícito para a equação do calor u_t = u_xx com r=0.5, compute g(π) = 1/(1+2) ≈ 0.333, mostrando dissipação forte que amortece modos de alta frequência, preservando estabilidade mesmo para Δt grande.",
                              "finalVerifications": [
                                "Defina dissipação como |g(kh)| < 1 e dê um exemplo numérico.",
                                "Diferencie dissipação (amplitude) de dispersão (fase) com esquemas.",
                                "Calcule |g| para esquema implícito de calor e interprete.",
                                "Explique o trade-off dissipação-estabilidade-precisão.",
                                "Classifique Lax-Friedrichs como dissipativo.",
                                "Descreva efeito em solução numérica de PDE parabólica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de dissipação via Von Neumann (exato |g|<1).",
                                "Correta diferenciação de dissipação vs dispersão com exemplos.",
                                "Cálculo correto de g(kh) em esquema implícito.",
                                "Compreensão do papel em estabilidade (essencial para implícitos).",
                                "Análise qualitativa de trade-offs (suavização vs precisão).",
                                "Uso apropriado de terminologia (kh, Nyquist, fator amplificação)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com difusão/viscosidade em equações de calor/fluidos.",
                                "Engenharia Computacional: Otimização de simulações CFD com esquemas dissipativos.",
                                "Ciência da Computação: Análise de estabilidade em algoritmos paralelos para PDEs.",
                                "Matemática Aplicada: Conexão com análise espectral e autovalores."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou de propagação de calor em engenharia, esquemas dissipativos implícitos previnem instabilidades numéricas em grids grosseiros, permitindo simulações eficientes em supercomputadores para previsão de tempo ou design térmico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Analisar dissipação em métodos ADI e implícitos",
                            "description": "Calcular o fator de amplificação para métodos ADI em equações parabólicas bidimensionais e esquemas implícitos para hiperbólicas, identificando como a dissipação controla oscilações de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos ADI e Implícitos",
                                  "subSteps": [
                                    "Estude a formulação do método ADI para equações parabólicas bidimensionais, como a equação de calor u_t = α (u_xx + u_yy).",
                                    "Revise esquemas implícitos para equações hiperbólicas, como a equação de onda ou advecção u_t + a u_x = 0.",
                                    "Identifique as matrizes tridiagonais envolvidas na solução ADI e nos esquemas implícitos lineares.",
                                    "Derive a forma matricial genérica para o avanço temporal em ambos os métodos.",
                                    "Calcule o fator de amplificação ξ para modo de alta frequência (kΔx = π)."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças chave entre ADI e implícitos, com equações anotadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula sobre EDOs parabólicas e hiperbólicas",
                                    "Software como MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Comece com 1D para intuitar antes de 2D; use diagramas de fluxo para ADI.",
                                  "learningObjective": "Compreender as bases matemáticas para análise de dissipação.",
                                  "commonMistakes": [
                                    "Confundir ADI com explicit, ignorar separação direcional em 2D"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Fator de Amplificação para Método ADI",
                                  "subSteps": [
                                    "Considere a equação parabólica 2D discretizada: escreva o esquema ADI em duas meias-passadas (x e y).",
                                    "Assuma solução modal u_{m,n}^j = ξ^j e^{i k_x m Δx} e^{i k_y n Δy}.",
                                    "Calcule ξ para ADI: ξ = [1 + i r sin²(θ_x/2)]^{-1} [1 + i r sin²(θ_y/2)]^{-1}, onde r = α Δt / Δx², θ = k Δx.",
                                    "Analise |ξ| para θ_x, θ_y ≈ π (alta frequência): mostre |ξ| < 1.",
                                    "Compare com Crank-Nicolson 1D para validar."
                                  ],
                                  "verification": "Implemente código simples para plotar |ξ| vs θ em 2D.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Python/MATLAB para plotar superfície |ξ(θ_x, θ_y)|"
                                  ],
                                  "tips": "Use aproximação sin(θ/2) ≈ θ/2 para baixas frequências; foque em |ξ|.",
                                  "learningObjective": "Derivar e interpretar o fator de amplificação ADI.",
                                  "commonMistakes": [
                                    "Erro na separação ADI (não inverter ordem x-y), esquecer i na derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Dissipação em Esquemas Implícitos para Hiperbólicas",
                                  "subSteps": [
                                    "Revise esquema implícito backward Euler para u_t + a u_x = 0: u^{j+1} - u^j + λ (u^{j+1}_m - u^{j+1}_{m-1}) = 0.",
                                    "Derive ξ = 1 / (1 + i λ sin θ + (λ/2)^2 (1 - cos θ)), approx.",
                                    "Calcule |ξ| ≈ 1 - (λ sin(θ/2))^2 para θ=π: mostre dissipação forte em oscilações altas.",
                                    "Compare com Leapfrog (não dissipativo) para destacar controle de oscilações.",
                                    "Discuta termo dissipativo numérico: ordem O(Δt² + Δx²)."
                                  ],
                                  "verification": "Tabela comparativa de |ξ| para θ=0, π/2, π entre implícito e explícito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de cálculos simbólicos (SymPy online)",
                                    "Gráficos de |ξ| pré-computados"
                                  ],
                                  "tips": "Linearize para derivadas finitas; teste com λ=1.",
                                  "learningObjective": "Quantificar dissipação numérica em hiperbólicas.",
                                  "commonMistakes": [
                                    "Usar forward em vez de backward, confundir dispersão com dissipação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Controle de Oscilações via Dissipação",
                                  "subSteps": [
                                    "Simule uma solução com ruído de alta frequência em ADI e implícito.",
                                    "Meça decaimento de amplitudes altas vs preservação de baixas frequências.",
                                    "Calcule taxa de dissipação: log(|ξ|) por passo temporal.",
                                    "Discuta trade-off: dissipação excessiva vs estabilidade.",
                                    "Valide com exemplo numérico: resolva equação de calor 2D com ADI."
                                  ],
                                  "verification": "Gráfico de solução numérica mostrando amortecimento de oscilações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python completo para simulação ADI 2D",
                                    "Biblioteca SciPy para solvers"
                                  ],
                                  "tips": "Adicione ruído senoidal inicial; compare com solução exata.",
                                  "learningObjective": "Ligar dissipação à supressão de oscilações instáveis.",
                                  "commonMistakes": [
                                    "Escala errada em plots, ignorar CFL para hiperbólicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de calor 2D u_t = u_xx + u_yy em malha 50x50 com condição inicial senoidal de alta frequência (k_x=k_y=π/Δx). Use ADI com r=0.5; plote |u| ao longo do tempo, mostrando dissipação seletiva de modos altos enquanto modo fundamental persiste.",
                              "finalVerifications": [
                                "Derivação correta de |ξ| <1 para ADI em θ=π.",
                                "Gráfico de |ξ(θ)| confirmando dissipação em altas frequências.",
                                "Simulação numérica demonstra controle de oscilações.",
                                "Comparação qualitativa ADI vs implícito para parabólica/hiperbólica.",
                                "Explicação verbal do papel da dissipação na estabilidade.",
                                "Cálculo de taxa de decaimento log(|ξ|) para modo π."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator de amplificação (equações corretas).",
                                "Interpretação física da dissipação (amortecimento seletivo).",
                                "Qualidade dos gráficos e simulações numéricas.",
                                "Identificação de trade-offs estabilidade vs precisão.",
                                "Conexão com conceitos de von Neumann.",
                                "Clareza na discussão de oscilações de alta frequência."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão em materiais (equação de calor).",
                                "Engenharia Computacional: CFD para simulações 2D/3D.",
                                "Processamento de Sinais: Filtros numéricos e amortecimento.",
                                "Matemática Aplicada: Análise de Fourier em malhas.",
                                "Ciência de Dados: Estabilidade em ML para PDE solvers."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos de oceanos 2D com ADI para difusão térmica) e CFD (esquemas implícitos em turbulência para dampen oscilações numéricas em aviões), controlando erros de alta frequência sem comprometer precisão global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Comparar dissipação em esquemas explícitos vs. implícitos",
                            "description": "Comparar níveis de dissipação numérica entre esquemas explícitos (ex.: Lax-Wendroff) e implícitos, usando gráficos de |g(kh)| vs. kh para equações hiperbólicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Dissipação Numérica",
                                  "subSteps": [
                                    "Defina dissipação numérica como a atenuação artificial de componentes de alta frequência na solução numérica.",
                                    "Explique a função de amplificação g(kh), onde |g(kh)| < 1 indica dissipação para modo kh.",
                                    "Diferencie esquemas explícitos (resolvidos diretamente) de implícitos (requerem solução de sistema linear).",
                                    "Identifique exemplos: Lax-Wendroff (explícito) e Crank-Nicolson adaptado ou backward Euler para hiperbólicas.",
                                    "Relacione com equações hiperbólicas como a de advecção u_t + a u_x = 0."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras cobrindo definições e diferenças, sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de Análise Numérica II",
                                    "Livro 'Finite Difference Schemes and Partial Differential Equations' de LeVeque",
                                    "Acesso a Python ou MATLAB"
                                  ],
                                  "tips": "Use diagramas de von Neumann para visualizar amplificação por modo de Fourier.",
                                  "learningObjective": "Compreender os fundamentos teóricos de dissipação e funções de amplificação em esquemas numéricos.",
                                  "commonMistakes": [
                                    "Confundir dissipação (amortecimento) com dispersão (fase errada)",
                                    "Ignorar dependência no número de Courant-Friedrichs-Lewy (CFL)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Funções de Amplificação g(kh)",
                                  "subSteps": [
                                    "Derive g(kh) para esquema explícito Lax-Wendroff: g = 1 - (ν²/2)(1 - cos(kh)) + i ν sin(kh), com ν = a Δt / Δx.",
                                    "Calcule |g(kh)| para Lax-Wendroff: |g|² ≈ 1 - ν² (1 - cos(kh))² / 2 para pequenas ν.",
                                    "Derive g(kh) para um esquema implícito, ex.: Lax-Friedrichs implícito ou beam-warming implícito: tipicamente |g| mais próximo de 1 em altas frequências.",
                                    "Compare analiticamente: explícitos dissipam mais em kh ≈ π (ondas curtas).",
                                    "Plote analiticamente |g(kh)| vs. kh para ν fixo (ex. ν=0.9)."
                                  ],
                                  "verification": "Mostre derivações passo a passo e equações finais para ambos os esquemas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e caneta ou Jupyter Notebook",
                                    "Referências: Tannehill 'Computational Fluid Mechanics'"
                                  ],
                                  "tips": "Use aproximações de Taylor para sin(kh) ≈ kh e cos(kh) ≈ 1 - (kh)²/2 em baixas frequências.",
                                  "learningObjective": "Dominar a derivação e interpretação de |g(kh)| para esquemas explícitos e implícitos.",
                                  "commonMistakes": [
                                    "Erro no fator i na parte imaginária",
                                    "Esquecer normalização para |g| ≤ 1 em esquemas estáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Gerar Gráficos de |g(kh)|",
                                  "subSteps": [
                                    "Implemente funções em Python/MATLAB para calcular |g(kh)| de Lax-Wendroff explícito.",
                                    "Implemente |g(kh)| para esquema implícito (ex.: esquema implícito de segundo ordem).",
                                    "Gere gráficos de |g(kh)| vs. kh (0 a π) para ν=0.5, 0.9, sobrepondo explícito e implícito.",
                                    "Adicione curvas para kh baixo (ondas longas) e alto (ondas curtas).",
                                    "Salve figuras com legendas claras."
                                  ],
                                  "verification": "Execute código e verifique que gráficos mostram dissipação maior no explícito para kh > π/2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, Matplotlib ou MATLAB",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use np.linspace(0, np.pi, 1000) para kh suave; fixe ν <1 para estabilidade.",
                                  "learningObjective": "Aplicar computacionalmente funções de amplificação e visualizá-las.",
                                  "commonMistakes": [
                                    "Gráficos com kh > π (não físico)",
                                    "Escala log em |g| para melhor visualização de dissipação fraca"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Níveis de Dissipação",
                                  "subSteps": [
                                    "Compare curvas: note que explícitos (Lax-Wendroff) têm |g| caindo mais rápido para kh alto.",
                                    "Quantifique: calcule integral média de 1 - |g(kh)| ou dissipação em % para kh=π.",
                                    "Discuta trade-offs: explícitos mais dissipativos mas computacionalmente baratos.",
                                    "Relacione com precisão: dissipação excessiva suaviza soluções.",
                                    "Conclua implicações para escolha de esquema em problemas hiperbólicos."
                                  ],
                                  "verification": "Escreva relatório de 1 página com comparações numéricas e conclusões.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Gráficos gerados",
                                    "Ferramenta de edição de texto"
                                  ],
                                  "tips": "Foque em regimes: baixas frequências (pouca diferença), altas (explícito > dissipação).",
                                  "learningObjective": "Interpretar graficamente e quantitativamente diferenças de dissipação entre esquemas.",
                                  "commonMistakes": [
                                    "Afirmar implícitos sempre melhores sem custo computacional",
                                    "Ignorar instabilidade se ν>1"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, plote |g(kh)| para Lax-Wendroff explícito e um esquema implícito como o de Laasonen para a equação de advecção. Para ν=0.9, observe que no explícito |g(π)| ≈ 0.6 (alta dissipação de ondas curtas), enquanto implícito mantém |g(π)| ≈ 0.95, demonstrando menor amortecimento artificial.",
                              "finalVerifications": [
                                "Gráficos corretos de |g(kh)| para ambos esquemas com sobreposição clara.",
                                "Identificação precisa de maior dissipação em explícitos para kh > π/2.",
                                "Cálculos analíticos/numericos de |g| em pontos chave (kh=0, π/2, π).",
                                "Relatório resume trade-offs computacionais e de precisão.",
                                "Código reproduzível gera figuras idênticas.",
                                "Conexão explícita com estabilidade von Neumann."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações de g(kh) (100% correto).",
                                "Qualidade visual e legibilidade dos gráficos (eixos, legendas).",
                                "Análise quantitativa: métricas como max(1-|g|) ou área sob curva.",
                                "Profundidade da comparação: pelo menos 3 diferenças chave.",
                                "Clareza do relatório: estrutura lógica e linguagem técnica.",
                                "Correção de erros comuns como confusão dispersão/dissipação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas e propagação em meios dissipativos.",
                                "Computação: Análise de estabilidade via análise de Fourier e visualização de dados.",
                                "Engenharia: Simulações CFD onde dissipação afeta precisão de choques.",
                                "Matemática Aplicada: Análise assintótica e aproximações de Taylor."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos computacional (CFD) para previsão meteorológica ou aerodinâmica, esquemas explícitos como Lax-Wendroff dissipam turbulência numérica excessiva em escalas pequenas, enquanto implícitos permitem passos de tempo maiores em problemas rígidos, equilibrando precisão e eficiência computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Relações entre Dispersão, Dissipação, Estabilidade e Precisão",
                        "description": "Conexões fundamentais: dissipação adequada garante estabilidade ao dampen modos instáveis, enquanto dispersão excessiva reduz precisão; análise integrada via critério de Lax para consistência, estabilidade e convergência.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Relacionar dissipação com critério de estabilidade de Von Neumann",
                            "description": "Demonstrar como dissipação numérica ( |g| < 1 para kh ≈ π ) previne instabilidade em esquemas para EDP hiperbólicas e parabólicas, usando o teorema de Lax-Friedrichs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos da análise de estabilidade de Von Neumann",
                                  "subSteps": [
                                    "Explicar o método de Von Neumann para análise de estabilidade em esquemas de diferenças finitas.",
                                    "Introduzir a solução modal assumindo forma u_j^n = g^n e^{i k j h}.",
                                    "Derivar o fator de amplificação g(kh) para esquemas lineares.",
                                    "Estabelecer o critério de estabilidade |g(kh)| ≤ 1 para todos os k.",
                                    "Destacar a importância dos modos de alta frequência (kh ≈ π)."
                                  ],
                                  "verification": "Derivar corretamente o fator g para o esquema forward Euler em advecção e verificar |g| ≤ 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque)",
                                    "Papel e calculadora",
                                    "Software como Python/MATLAB para plotar |g(kh)|"
                                  ],
                                  "tips": "Sempre normalize kh entre 0 e π e plote |g| vs kh para visualização.",
                                  "learningObjective": "Compreender o critério |g| ≤ 1 e sua relação com instabilidades.",
                                  "commonMistakes": "Esquecer a soma sobre vizinhos ou confundir com análise de Fourier contínua."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de dissipação numérica",
                                  "subSteps": [
                                    "Definir dissipação como |g(kh)| < 1, especialmente para kh ≈ π.",
                                    "Explicar como dissipação amortece componentes de alta frequência.",
                                    "Comparar com dispersão (fase errada) e sua relação com estabilidade.",
                                    "Analisar esquemas sem dissipação (ex: Leapfrog) que são neutros (|g|=1) mas instáveis.",
                                    "Calcular exemplos numéricos de |g| para diferentes esquemas."
                                  ],
                                  "verification": "Calcular |g(π)| para um esquema e mostrar que <1 introduz dissipação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folhas de exercícios",
                                    "Python com NumPy para computar g(kh)",
                                    "Gráficos de |g| pré-computados"
                                  ],
                                  "tips": "Pense em dissipação como 'fricção numérica' que previne oscilações 2Δx.",
                                  "learningObjective": "Identificar dissipação como mecanismo de controle de alta frequência.",
                                  "commonMistakes": "Confundir |g|<1 com precisão; dissipação reduz precisão mas garante estabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o esquema Lax-Friedrichs e seu teorema",
                                  "subSteps": [
                                    "Apresentar o esquema Lax-Friedrichs para u_t + a u_x = 0: u_j^{n+1} = (u_{j+1}^n + u_{j-1}^n)/2 - (a Δt / 2Δx)(u_{j+1}^n - u_{j-1}^n).",
                                    "Derivar o fator de amplificação g(kh) explicitamente.",
                                    "Mostrar que |g| ≤ 1 sob condição CFL, com dissipação artificial.",
                                    "Estudar o teorema de Lax-Friedrichs sobre consistência e estabilidade implicando convergência.",
                                    "Verificar numericamente para kh ≈ π."
                                  ],
                                  "verification": "Derivar g(kh) para Lax-Friedrichs e plotar |g(kh)| confirmando |g|<1 em alta frequência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para esquema",
                                    "Referência ao teorema (artigo Lax-Friedrichs)",
                                    "Computador"
                                  ],
                                  "tips": "Use expansão em série de Fourier para simplificar derivação de g.",
                                  "learningObjective": "Dominar a análise Von Neumann do Lax-Friedrichs.",
                                  "commonMistakes": "Erro no sinal da CFL ou esquecer o termo (u_{j+1} + u_{j-1})/2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a relação dissipação-estabilidade em EDP hiperbólicas e parabólicas",
                                  "subSteps": [
                                    "Aplicar a esquemas para EDP hiperbólicas (advecção) e parabólicas (difusão).",
                                    "Mostrar como dissipação previne instabilidades em grids não-refinados.",
                                    "Comparar Lax-Friedrichs com esquemas não-dissipativos (ex: Lax-Wendroff).",
                                    "Simular numericamente uma instabilidade sem dissipação vs estável com.",
                                    "Concluir com o papel no teorema de convergência."
                                  ],
                                  "verification": "Implementar simulação em Python mostrando estabilidade só com dissipação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Jupyter Notebook",
                                    "Dados de teste (onda ou pulso)",
                                    "Biblioteca Matplotlib"
                                  ],
                                  "tips": "Teste com kh=π inicializando ruído de alta frequência.",
                                  "learningObjective": "Relacionar dissipação com prevenção de instabilidade prática.",
                                  "commonMistakes": "Ignorar condição CFL; sempre verifique μ = aΔt/Δx ≤1."
                                }
                              ],
                              "practicalExample": "Para a EDP hiperbólica u_t + u_x = 0 com Δt=Δx=0.5 (μ=0.5), no esquema Lax-Friedrichs, g(kh) = cos(kh) - i μ sin(kh), com |g| = sqrt(cos²(kh) + μ² sin²(kh)) <1 para kh≈π, amortecendo o modo checkerboard e prevenindo instabilidade, ao contrário do upwind sem dissipação adequada.",
                              "finalVerifications": [
                                "Deriva corretamente g(kh) para Lax-Friedrichs e interpreta |g(π)|<1.",
                                "Explica como dissipação controla modos kh≈π em EDP hiperbólicas.",
                                "Aplica o teorema de Lax-Friedrichs para justificar convergência.",
                                "Simula numericamente instabilidade sem vs com dissipação.",
                                "Discute limitações da dissipação excessiva em precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de g(kh) (100% correto).",
                                "Interpretação física correta da dissipação como amortecimento.",
                                "Uso apropriado do teorema Lax-Friedrichs.",
                                "Análise qualitativa e quantitativa de estabilidade.",
                                "Capacidade de generalizar para EDP parabólicas.",
                                "Clareza em simulações e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Modelagem de ondas e amortecimento numérico.",
                                "Engenharia Mecânica: Simulações CFD com esquemas estáveis.",
                                "Ciência da Computação: Análise de complexidade e estabilidade algorítmica.",
                                "Matemática Aplicada: Teoria de EDP e métodos espectrais."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), previsão climática e propagação de ondas sísmicas, onde esquemas dissipativos como Lax-Friedrichs garantem estabilidade em malhas grosseiras, evitando crashes em supercomputadores e permitindo previsões confiáveis em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Avaliar trade-off dispersão-dissipação na estabilidade",
                            "description": "Analisar esquemas como Lax-Wendroff (baixa dissipação, alta dispersão) vs. Lax-Friedrichs (alta dissipação, estável), avaliando estabilidade condicional via número CFL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de dispersão e dissipação",
                                  "subSteps": [
                                    "Defina dispersão como o erro de fase que propaga ondas com velocidades erradas.",
                                    "Defina dissipação como o amortecimento artificial de componentes de alta frequência.",
                                    "Explique como ambos afetam a estabilidade em esquemas hiperbólicos.",
                                    "Revise a análise de Von Neumann para símbolos de amplificação.",
                                    "Identifique como dispersão leva a oscilações, enquanto dissipação suaviza soluções."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre dispersão e dissipação, com exemplos gráficos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (LeVeque), notas de aula sobre Von Neumann",
                                    "Software MATLAB ou Python para plots de símbolos"
                                  ],
                                  "tips": "Use diagramas de fase para visualizar efeitos; foque em equação da advecção linear.",
                                  "learningObjective": "Compreender as definições e impactos qualitativos de dispersão e dissipação na precisão numérica.",
                                  "commonMistakes": [
                                    "Confundir dispersão com difusão física",
                                    "Ignorar o papel das frequências de Fourier altas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o esquema Lax-Friedrichs",
                                  "subSteps": [
                                    "Derive a fórmula do esquema Lax-Friedrichs para a equação de advecção u_t + a u_x = 0.",
                                    "Calcule o símbolo de amplificação via análise de Von Neumann.",
                                    "Identifique a alta dissipação (decaição rápida de modos altos) e ausência de dispersão.",
                                    "Determine a condição de estabilidade CFL: |a Δt / Δx| ≤ 1.",
                                    "Simule numericamente para visualizar o amortecimento excessivo."
                                  ],
                                  "verification": "Plote o símbolo de amplificação e confirme |g(k)| ≤ 1 para CFL ≤ 1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB template para esquemas FD",
                                    "Artigo original de Lax-Friedrichs"
                                  ],
                                  "tips": "Teste com CFL = 0.5 e 1.0; observe 'escada' na solução.",
                                  "learningObjective": "Dominar a análise de estabilidade e dissipação do Lax-Friedrichs.",
                                  "commonMistakes": [
                                    "Esquecer o termo de média (u_{j-1} + u_{j+1})/2",
                                    "Aplicar CFL >1 sem notar instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o esquema Lax-Wendroff",
                                  "subSteps": [
                                    "Derive o esquema Lax-Wendroff usando expansão de Taylor no tempo.",
                                    "Calcule o símbolo de amplificação, destacando baixa dissipação mas alta dispersão.",
                                    "Identifique oscilações atrás de descontinuidades devido à dispersão.",
                                    "Confirme condição CFL: |a Δt / Δx| ≤ 1, com estabilidade marginal.",
                                    "Compare plots numéricos com Lax-Friedrichs para a mesma onda."
                                  ],
                                  "verification": "Gere plots mostrando oscilações no Lax-Wendroff vs. suavização no Lax-Friedrichs.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmo código Python/MATLAB, expandido para Lax-Wendroff",
                                    "Referência: LeVeque Ch. 5"
                                  ],
                                  "tips": "Use perfil de onda gaussiana inicial; CFL=0.9 para ver diferenças claras.",
                                  "learningObjective": "Entender os trade-offs do Lax-Wendroff em precisão vs. estabilidade.",
                                  "commonMistakes": [
                                    "Erro no termo de segunda ordem (a^2 Δt^2 / 2 Δx^2)",
                                    "Subestimar dispersão em CFL alto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar trade-offs e estabilidade via número CFL",
                                  "subSteps": [
                                    "Compare símbolos de amplificação: dissipação alta (L-F) vs. dispersão alta (L-W).",
                                    "Avalie estabilidade condicional: ambos CFL ≤1, mas L-F mais robusto.",
                                    "Discuta escolhas: L-F para estabilidade em fluxos irregulares, L-W para precisão em ondas suaves.",
                                    "Quantifique trade-off com métricas (erro L2, fator de dissipação).",
                                    "Conclua com tabela comparativa de prós/contras."
                                  ],
                                  "verification": "Crie tabela e gráfico comparando erros para diferentes CFL.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Jupyter para tabelas",
                                    "Códigos das steps anteriores"
                                  ],
                                  "tips": "Varie CFL de 0.1 a 1.0; priorize soluções com descontinuidades.",
                                  "learningObjective": "Capacitar avaliação quantitativa de trade-offs para seleção de esquemas.",
                                  "commonMistakes": [
                                    "Ignorar dependência CFL na magnitude da dispersão",
                                    "Generalizar sem contexto do problema"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + u_x = 0 em [0,2] com u(0,x)=sen(4πx), Δx=0.01, para t=2. Use Lax-Friedrichs (CFL=0.8): observe suavização excessiva; Lax-Wendroff (mesmo CFL): oscilações de fase. Meça erro de fase e amplitude.",
                              "finalVerifications": [
                                "Explica corretamente dispersão (oscilações de fase) vs. dissipação (amortecimento).",
                                "Deriva símbolos de amplificação para ambos esquemas.",
                                "Identifica condição CFL e violações levando a instabilidade.",
                                "Compara numericamente soluções, destacando trade-offs.",
                                "Seleciona esquema apropriado para problema dado (ex: L-F para choques)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de esquemas e símbolos (90% correto).",
                                "Análise qualitativa/quantitativa de trade-offs (gráficos/tabelas claros).",
                                "Compreensão de CFL: cálculos e interpretações corretas.",
                                "Exemplos práticos com simulações funcionais.",
                                "Conclusões fundamentadas em estabilidade e precisão.",
                                "Ausência de erros comuns como confusão de termos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas e propagação em meios.",
                                "Engenharia Computacional: CFD para simulações de fluidos compressíveis.",
                                "Ciência da Computação: Otimização de algoritmos numéricos paralelos.",
                                "Estatística: Análise de erros numéricos como variância em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas (previsão de frentes frias), Lax-Friedrichs previne instabilidades em grids grosseiros, enquanto Lax-Wendroff preserva ondas de Rossby em alta resolução; trade-off guiado por CFL determina viabilidade computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Quantificar impacto na precisão e convergência",
                            "description": "Explicar como erros de dispersão e dissipação afetam a ordem de precisão e convergência em métodos de diferenças finitas, referenciando truncamento local vs. erros de fase/dissipação em LeVeque (2007).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de dispersão e dissipação em métodos de diferenças finitas",
                                  "subSteps": [
                                    "Defina dispersão como erro de fase que causa oscilações não físicas na solução numérica.",
                                    "Defina dissipação como amortecimento artificial de componentes de alta frequência.",
                                    "Revise a análise de von Neumann para esquemas lineares: calcule símbolos de amplificação e fase.",
                                    "Identifique esquemas dispersivos (ex.: Lax-Wendroff) e dissipativos (ex.: esquemas upwind).",
                                    "Compare com truncamento local de Taylor para entender diferenças qualitativas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre dispersão, dissipação e truncamento local, citando exemplos de esquemas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro LeVeque (2007) capítulos 2-3; notas de aula sobre análise de von Neumann; calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Use diagramas de dispersão/dissipação para visualizar comportamentos em diferentes números de onda.",
                                  "learningObjective": "Compreender as definições e origens qualitativas de dispersão e dissipação.",
                                  "commonMistakes": "Confundir dispersão com oscilações físicas reais; ignorar dependência no número de onda kΔx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar truncamento local versus erros de fase e dissipação conforme LeVeque (2007)",
                                  "subSteps": [
                                    "Leia seções relevantes de LeVeque (2007) sobre análise de modificação de equação.",
                                    "Derive o termo de truncamento local para um esquema central de segunda ordem.",
                                    "Calcule o erro de fase φ(kΔx) - ωΔt e o símbolo de amplificação |g(kΔx)|.",
                                    "Compare: truncamento local é O(Δt² + Δx²), mas erros de fase/dissipação persistem em malha fina.",
                                    "Plote curvas de dispersão (φ numérico vs. exato) e dissipação (|g| vs. 1)."
                                  ],
                                  "verification": "Gere plots de dispersão e dissipação para o esquema Lax-Wendroff e confirme desvios de LeVeque.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "LeVeque (2007) PDF; Python/MATLAB com NumPy/Matplotlib para plots; código template para análise von Neumann.",
                                  "tips": "Normalice pelo número de onda exato para destacar erros relativos.",
                                  "learningObjective": "Distinguir truncamento local (converge com refinamento) de erros de fase/dissipação (dominam em resoluções altas).",
                                  "commonMistakes": "Assumir que ordem de truncamento implica convergência global; negligenciar regime de alta frequência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Quantificar impacto na ordem de precisão usando análise de erro global",
                                  "subSteps": [
                                    "Estude a ordem de precisão p onde ||e|| ~ C h^p, com h = Δx.",
                                    "Derive como dispersão reduz p efetiva: erro de fase acumula como O((kΔx)^3 L / Δx).",
                                    "Para dissipação, modele decaimento exponencial: ||e|| ~ exp(-α t) com α ~ (Δx)^q.",
                                    "Use fórmula de LeVeque para perda de precisão: p_num = p_local - log(erro_fase)/log(h).",
                                    "Calcule numericamente para uma EDO de advecção: compare ||u_num - u_exato|| em malhas refinadas."
                                  ],
                                  "verification": "Compute ordens de convergência em tabela para h=1/10, 1/20, 1/40 e observe redução devido a dispersão.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python para solver de diferenças finitas; dados de malha refinada; LeVeque (2007) Seção 4.2.",
                                  "tips": "Use norma L2 global para capturar erros acumulados ao longo do domínio.",
                                  "learningObjective": "Quantificar matematicamente como dispersão/dissipação degradam a ordem de precisão observada.",
                                  "commonMistakes": "Medir erro local em vez de global; ignorar tempo de simulação longo onde erros acumulam."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto na convergência e mitigações",
                                  "subSteps": [
                                    "Simule convergência para esquemas dispersivo vs. não-dispersivo (ex.: upwind vs. central).",
                                    "Calcule taxa de convergência log-log: slope de log(||e||) vs. log(h).",
                                    "Quantifique: para dispersão, perda de 1-2 ordens em onda curta; dissipação acelera para baixa resolução.",
                                    "Discuta mitigações: filtros, esquemas de alta ordem resolvidos (DRP), ou malha adaptativa.",
                                    "Valide com exemplo de LeVeque: advecção linear com solução exata senoidal."
                                  ],
                                  "verification": "Produza gráfico log-log mostrando platô ou redução na slope devido a erros de fase.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código de simulação completo; solver numérico (FiPy ou custom FD); referências LeVeque.",
                                  "tips": "Teste múltiplos k para isolar efeitos de dispersão em componentes específicos.",
                                  "learningObjective": "Medir e interpretar perda de convergência quantitativamente.",
                                  "commonMistakes": "Usar norma L∞ que mascara erros dispersivos; não normalizar tempo físico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e interpretar resultados em contexto de estabilidade",
                                  "subSteps": [
                                    "Relacione com estabilidade: dispersão pode desestabilizar via aliasing.",
                                    "Compile tabela: esquema | ordem local | perda por dispersão | perda por dissipação.",
                                    "Discuta trade-offs: precisão vs. estabilidade em aplicações reais.",
                                    "Resolva exercício de LeVeque: quantifique para onda de choque suave.",
                                    "Escreva relatório curto com conclusões."
                                  ],
                                  "verification": "Relatório de 1 página com tabelas/plots confirmando impactos quantificados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Templates de relatório; todos códigos e plots anteriores.",
                                  "tips": "Enfatize regime CFL e resolução espacial relativa ao comprimento de onda.",
                                  "learningObjective": "Integrar quantificação em framework de estabilidade e precisão geral.",
                                  "commonMistakes": "Isolar dispersão de CFL; superestimar convergência em testes curtos."
                                }
                              ],
                              "practicalExample": "Simule a equação de advecção u_t + a u_x = 0 com a=1, u(0,x)=sin(2π x / λ), λ=10 Δx inicial. Use esquema Lax-Wendroff (dispersivo). Refine malha de Δx=0.1 para 0.001, compute norma L2 do erro de fase acumulado em t=1. Observe ordem de precisão cair de 2 para ~1 devido a dispersão, conforme LeVeque.",
                              "finalVerifications": [
                                "Calcule corretamente símbolo de fase e amplificação para um esquema dado.",
                                "Gere plots de dispersão/dissipação alinhados com figuras de LeVeque (2007).",
                                "Demonstre redução quantitativa na ordem de convergência via log-log plot.",
                                "Explique verbalmente distinção truncamento local vs. erros persistentes.",
                                "Aplique quantificação a um novo esquema e preveja impacto.",
                                "Identifique quando dissipação domina sobre dispersão em simulações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivações de erros de fase/dissipação (90%+ correção).",
                                "Qualidade dos plots e tabelas de convergência (legíveis, corretos slopes).",
                                "Compreensão conceitual: explica trade-offs estabilidade-precisão.",
                                "Uso correto de referências LeVeque para suporte quantitativo.",
                                "Capacidade de generalizar a esquemas não testados.",
                                "Relatório claro com interpretações numéricas fundamentadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas onde dispersão numérica polui espectros.",
                                "Engenharia Computacional: Otimização de CFD para precisão em turbulência.",
                                "Ciência da Computação: Análise de complexidade em solvers de alta ordem.",
                                "Matemática Aplicada: Teoria de aproximação e análise assintótica de erros."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM), dispersão numérica distorce frentes de onda climáticas, reduzindo precisão de previsões de longo prazo; quantificação guia escolha de esquemas para manter convergência O(h^2) em grids globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.4",
                            "name": "Aplicar conceitos em condições de contorno Dirichlet/Neumann",
                            "description": "Discutir como dispersão e dissipação interagem com condições de Dirichlet e Neumann em equações elípticas e parabólicas, afetando estabilidade e precisão global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Dispersão, Dissipação e Condições de Contorno",
                                  "subSteps": [
                                    "Defina dispersão como a propagação de erros de fase em esquemas numéricos para PDEs.",
                                    "Explique dissipação como a amortecimento de componentes de alta frequência.",
                                    "Descreva condições de Dirichlet: u = g na fronteira.",
                                    "Descreva condições de Neumann: ∂u/∂n = h na fronteira.",
                                    "Discuta como BCs influenciam o espectro de autovalores em discretizações."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições e relações iniciais, conferindo com referências padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: LeVeque), notas de aula sobre PDEs"
                                  ],
                                  "tips": "Use diagramas de von Neumann para visualizar dispersão/dissipação.",
                                  "learningObjective": "Compreender os conceitos básicos e sua interconexão com BCs.",
                                  "commonMistakes": [
                                    "Confundir dispersão com difusão física",
                                    "Ignorar o impacto das BCs no análise de Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Interações em Equações Elípticas",
                                  "subSteps": [
                                    "Considere a equação de Poisson: ∇²u = f com BCs Dirichlet/Neumann.",
                                    "Estude o esquema de diferenças finitas e sua matriz de discretização.",
                                    "Examine autovalores: Dirichlet promove dissipação, Neumann pode introduzir modos espúrios.",
                                    "Simule numericamente um exemplo simples (ex: u_xx + u_yy = 0 em quadrado).",
                                    "Compare precisão global: erro em norma L2 para diferentes BCs."
                                  ],
                                  "verification": "Gere gráficos de solução numérica vs. exata, medindo erro máximo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy), código base para diferenças finitas"
                                  ],
                                  "tips": "Normalice autovalores para comparar dispersão entre BCs.",
                                  "learningObjective": "Identificar como BCs afetam estabilidade em problemas elípticos estacionários.",
                                  "commonMistakes": [
                                    "Usar análise von Neumann diretamente sem ajustar para BCs não-periódicas",
                                    "Negligenciar inconsistências na aproximação de Neumann"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Efeitos em Equações Parabólicas",
                                  "subSteps": [
                                    "Considere a equação de calor: u_t = Δu com BCs Dirichlet/Neumann.",
                                    "Implemente esquema explícito/implicito e analise fator de amplificação.",
                                    "Avalie dispersão: oscilações fase em ondas com Dirichlet rígido.",
                                    "Avalie dissipação: Neumann permite vazamento de energia, afetando estabilidade.",
                                    "Execute simulações temporais e plote perfis de erro ao longo do tempo."
                                  ],
                                  "verification": "Verifique se a solução converge monotonicamente e sem oscilações anômalas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com Matplotlib para plots temporais, códigos de PDE parabólicas"
                                  ],
                                  "tips": "Use CFL condition para estabilidade explícita, variando BCs.",
                                  "learningObjective": "Entender dinâmicas temporais de dispersão/dissipação sob diferentes BCs.",
                                  "commonMistakes": [
                                    "Aplicar análise de estabilidade elíptica diretamente a parabólicas",
                                    "Esquecer tratamento de Neumann em esquemas upwind"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Impactos na Estabilidade e Precisão Global",
                                  "subSteps": [
                                    "Compare resultados de elípticas e parabólicas: Dirichlet estabiliza mas dispersa fases.",
                                    "Discuta trade-offs: Neumann aumenta precisão em fluxos mas risco de instabilidade.",
                                    "Calcule métricas: taxa de convergência, norma de erro global.",
                                    "Proponha mitigações: esquemas absorventes ou BCs artificiais.",
                                    "Documente conclusões em relatório com gráficos e tabelas."
                                  ],
                                  "verification": "Escreva um resumo de 300 palavras ligando conceitos à estabilidade/precisão.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Ferramentas de LaTeX para relatório, dados de simulações anteriores"
                                  ],
                                  "tips": "Foque em quantificar: use tabelas de erros para BCs variadas.",
                                  "learningObjective": "Aplicar conceitos integrados para avaliar e melhorar precisão numérica.",
                                  "commonMistakes": [
                                    "Generalizar resultados de um tipo de PDE para outro",
                                    "Ignorar efeitos de malha fina na dispersão"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de onda 1D u_tt = c² u_xx em [0,1]x[0,T] com Dirichlet u(0,t)=u(1,t)=0 (parede rígida, alta dissipação) vs. Neumann u_x(0,t)=u_x(1,t)=0 (fronteira livre, dispersão aumentada). Compare animações de onda e erros de fase/amplitude.",
                              "finalVerifications": [
                                "Explicar verbalmente como Dirichlet induz dissipação em autovalores.",
                                "Implementar código que alterna BCs e plota erros.",
                                "Identificar instabilidade em simulação Neumann explícita.",
                                "Calcular taxa de dispersão via análise de fase.",
                                "Propor ajuste de esquema para mitigar efeitos adversos.",
                                "Discutir precisão global em norma H1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção de dispersão/dissipação (20%)",
                                "Correta implementação e análise numérica de BCs (30%)",
                                "Interpretação qualitativa/quantitativa de estabilidade (25%)",
                                "Uso de métricas de erro e gráficos claros (15%)",
                                "Conclusões interdisciplinares e mitigações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas acústicas com BCs reais (absorvedores).",
                                "Engenharia: Simulações CFD com condições de parede/entrada-saída.",
                                "Computação: Otimização de solvers paralelos para matrizes com BCs.",
                                "Estatística: Análise de erro em métodos Monte Carlo para PDEs."
                              ],
                              "realWorldApplication": "Em simulações de previsão numérica do tempo (modelos parabólicos), Dirichlet modela superfícies terrestres estabilizando o esquema, enquanto Neumann em oceanos permite fluxos realistas, balanceando precisão para forecasts de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 296
          }
        ],
        "totalSkills": 296
      }
    ]
  }
}